<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="PerformSelector原理">




  <meta name="keywords" content="iOS开发,阅读,">




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x">



<link rel="canonical" href="http://blog.chenyalun.com/2018/09/30/PerformSelector原理/">


<meta name="description" content="PerformSelector相关知识。">
<meta name="keywords" content="iOS开发,阅读">
<meta property="og:type" content="article">
<meta property="og:title" content="PerformSelector原理">
<meta property="og:url" content="http://blog.chenyalun.com/2018/09/30/PerformSelector原理/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="PerformSelector相关知识。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image.chenyalun.com/2018/09/30/002.png">
<meta property="og:image" content="https://image.chenyalun.com/2018/09/30/001.png">
<meta property="og:updated_time" content="2019-09-22T07:22:44.642Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PerformSelector原理">
<meta name="twitter:description" content="PerformSelector相关知识。">
<meta name="twitter:image" content="https://image.chenyalun.com/2018/09/30/002.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> PerformSelector原理 · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          PerformSelector原理
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018年9月30日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本"><span class="toc-text">基本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄露"><span class="toc-text">内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消除waring"><span class="toc-text">消除waring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决内存泄漏"><span class="toc-text">解决内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#延迟"><span class="toc-text">延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#performSelector-withObject-afterDelay"><span class="toc-text">performSelector:withObject:afterDelay:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cancelPreviousPerformRequestsWithTarget-selector-object"><span class="toc-text">cancelPreviousPerformRequestsWithTarget: selector:object:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模式"><span class="toc-text">模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#performSelector-target-argument-order-modes"><span class="toc-text">performSelector:target:argument:order:modes:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#performSelector-onThread-withObject-waitUntilDone-modes"><span class="toc-text">performSelector:onThread:withObject:waitUntilDone:modes:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任意线程调用"><span class="toc-text">任意线程调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主线程调用"><span class="toc-text">主线程调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Background调用"><span class="toc-text">Background调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-amp-A"><span class="toc-text">Q&amp;A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#printInfo方法会执行吗"><span class="toc-text">printInfo方法会执行吗</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GCD调用"><span class="toc-text">GCD调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSThread调用"><span class="toc-text">NSThread调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSThread无效"><span class="toc-text">NSThread无效</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p align="center"> PerformSelector相关知识。 </p>

<a id="more"></a>
<p>performSelector系列是个很神奇的存在，能传参，能延迟，还能子线程调，能让任意对象执行任意方法，读了gnustep中有关performSelector的源码后，这里做个总结。</p>
<blockquote>
<p>源码地址：<a href="https://github.com/gnustep/libs-base/releases/tag/base-1_25_1" target="_blank" rel="noopener">https://github.com/gnustep/libs-base/releases/tag/base-1_25_1</a></p>
</blockquote>
<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>最基本的performSelector有三个接口方法，可以不传参，传一个参数以及传两个参数。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object1 withObject:<span class="params">(id)</span>object2;</span><br></pre></td></tr></table></figure>
<p>使用示例:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参 </span></span><br><span class="line">id obj1 = [self <span class="string">performSelector:</span><span class="meta">@selector</span>(printString)];</span><br><span class="line"><span class="comment">// 一个参数</span></span><br><span class="line">id obj2 = [self <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">printString:</span>) <span class="string">withObject:</span>@<span class="string">"string"</span>];</span><br><span class="line"><span class="comment">// 两个参数</span></span><br><span class="line">id obj3 = [self <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">printString:</span><span class="string">str2:</span>) <span class="string">withObject:</span>@<span class="string">"string"</span> <span class="string">withObject:</span>@&#123;@<span class="string">"key"</span>: @(<span class="number">3</span>)&#125;];</span><br></pre></td></tr></table></figure>
<p>以传递两个参数为例，它的实现是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector</span><br><span class="line">           withObject:(<span class="keyword">id</span>)object1</span><br><span class="line">           withObject:(<span class="keyword">id</span>)object2 &#123;</span><br><span class="line">    IMP msg;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="built_in">NSException</span> raise: <span class="built_in">NSInvalidArgumentException</span></span><br><span class="line">                    format: <span class="string">@"%@ null selector given"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">    &#125;</span><br><span class="line">    msg = objc_msg_lookup(<span class="keyword">self</span>, aSelector);</span><br><span class="line">    <span class="keyword">if</span> (!msg) &#123;</span><br><span class="line">        [<span class="built_in">NSException</span> raise: <span class="built_in">NSGenericException</span></span><br><span class="line">                    format: <span class="string">@"invalid selector '%s' passed to %s"</span>,</span><br><span class="line">         sel_getName(aSelector), sel_getName(_cmd)];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*msg)(<span class="keyword">self</span>, aSelector, object1, object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见就是根据方法名，<strong>使用Runtime中的<code>objc_msg_lookup()</code>获取到函数指针IMP，进而进行函数调用。</strong>当然，还有对方法名和函数指针的容错处理。</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>performSelector系列颇具有动态性，当使用这三个方法时，编译器很容易就给出警告：PerformSelector may cause a leak because its selector is unknown。为什么会提示有内存泄漏问题呢？</p>
<p>首先要明确：<strong>调用<code>performSelector:</code>编译器会假设调用方法的返回值是一个对象，且不会对返回值进行retain/release</strong>。</p>
<p>如果调用的方法是<code>alloc, new, copy, mutableCopy</code>方法家族中的方法(包含以它们开头)，方法调用的结果是开辟了一块内存空间，但是系统仍然按照非retain/release处理，没有对它们的引用计数纳入管理，这时内存空间无法释放，就会产生内存泄露。</p>
<p>当<strong>显式调用</strong>这些方法时，编译器都能明显分析出来，并给出提示：Error：PerformSelector names a selector which retains the object。告诉我们这不符合引用计数管理的规则，编译不通过。</p>
<p>There are really only 4 things that ARC would consider for the return value:4</p>
<ul>
<li>Ignore non-object types (void, int, etc)</li>
<li>Retain object value, then release when it is no longer used (standard assumption)</li>
<li>Release new object values when no longer used (methods in the init/ copy family or attributed with ns_returns_retained)</li>
<li>Do nothing &amp; assume returned object value will be valid in local scope (until inner most release pool is drained, attributed with ns_returns_autoreleased)</li>
</ul>
<p>The call to methodForSelector: assumes that the return value of the method it’s calling is an object, but does not retain/release it. So you could end up creating a leak if your object is supposed to be released as in #3 above (that is, the method you’re calling returns a new object).</p>
<p>比如这样：<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">- (id)<span class="keyword">new</span><span class="type">Object</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [NSObject <span class="keyword">new</span><span class="type"></span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用method family中的方法：</span></span><br><span class="line">[str <span class="string">performSelector:</span><span class="meta">@selector</span>(copy)];</span><br><span class="line"><span class="comment">// 调用以method family中的方法名开头的方法：</span></span><br><span class="line">[self <span class="string">performSelector:</span><span class="meta">@selector</span>(newObject)];</span><br></pre></td></tr></table></figure>
<p>但是<strong>隐式调用</strong>的时候，编译器无能为力了，只能给出警告：PerformSelector may cause a leak because its selector is unknown。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐式调用无法分析出错误: 出现内存泄露</span></span><br><span class="line"><span class="keyword">id</span> obj1 = [str performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"copy"</span>)];</span><br><span class="line">[str performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"mutableCopy"</span>)];</span><br><span class="line"><span class="keyword">id</span> obj2 = [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"new"</span>)];</span><br><span class="line"><span class="keyword">id</span> obj3 = [<span class="keyword">self</span> performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)];</span><br></pre></td></tr></table></figure>
<h3 id="消除waring"><a href="#消除waring" class="headerlink" title="消除waring"></a>消除waring</h3><p>最简单的，可以利用<code>#pragma</code>消除警告。</p>
<figure class="highlight leaf"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic push"</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic ignored \"</span>-<span class="variable">Warc</span>-<span class="variable">performSelector</span>-<span class="variable">leaks</span>\<span class="string">""</span>)</span></span></span><br><span class="line">[person performSelector:selector]; // 插入需要消除警告的代码</span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic pop"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>或者换种思路，根据<code>performSelector</code>的实现，效果上可以直接使用<code>IMP</code>，也可以使用<code>objc_msgSend()</code>，甚至使用<code>NSInvocation</code>、<code>sendAction</code>等，这样就达到同等实现而没有警告了。</p>
<p>方式1：methodForSelector<br><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!person) return;</span><br><span class="line"><span class="comment">// 获取函数指针</span></span><br><span class="line">IMP imp = [person methodForSelector:<span class="keyword">selector</span>];</span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line">void <span class="comment">(*func)(id, SEL) = (void *)</span>imp;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">func(person, <span class="keyword">selector</span>);</span><br></pre></td></tr></table></figure></p>
<p>方式2：methodForSelector简化版<br><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">((<span class="name">void</span> (<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))[person methodForSelector:selector])(<span class="name">self</span>, selector)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>方式3：使用objc_msgSend<br><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">((<span class="name">void</span> *(<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))objc_msgSend)((<span class="name"><span class="builtin-name">id</span></span>)self, NSSelectorFromString(@<span class="string">"show"</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>方式4：NSInvocation<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"show"</span>);</span><br><span class="line"><span class="built_in">NSMethodSignature</span> *methodSig = [[<span class="keyword">self</span> <span class="keyword">class</span>] instanceMethodSignatureForSelector:selector];</span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:methodSig];</span><br><span class="line">[invocation setSelector:selector];</span><br><span class="line">[invocation setTarget:<span class="keyword">self</span>];</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure></p>
<p>方式5: sendAction<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIApplication</span>.sharedApplication sendAction:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"show"</span>) to:<span class="keyword">self</span> from:<span class="literal">nil</span> forEvent:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p>
<h3 id="解决内存泄漏"><a href="#解决内存泄漏" class="headerlink" title="解决内存泄漏"></a>解决内存泄漏</h3><p>当我们一定要调用<code>newObject</code>这类特殊的方法时（可能性极小），怎么解决内存泄漏问题呢？把return的对象的引用计数减少即可，比如：</p>
<p>当使用<code>objc_msgSend()</code>时<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = <span class="built_in">CFBridgingRelease</span>(((<span class="keyword">void</span> *(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(<span class="keyword">self</span>, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)));</span><br></pre></td></tr></table></figure></p>
<p>当使用<code>methodForSelector</code>时<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = <span class="built_in">CFBridgingRelease</span>(((<span class="keyword">void</span> *(*)(<span class="keyword">id</span>, SEL))[<span class="keyword">self</span> methodForSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)])(<span class="keyword">self</span>, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)));</span><br></pre></td></tr></table></figure></p>
<h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument;</span><br><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget;</span><br></pre></td></tr></table></figure>
<h3 id="performSelector-withObject-afterDelay"><a href="#performSelector-withObject-afterDelay" class="headerlink" title="performSelector:withObject:afterDelay:"></a>performSelector:withObject:afterDelay:</h3><p>源码实现:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector</span><br><span class="line">             withObject:(<span class="keyword">id</span>)argument</span><br><span class="line">             afterDelay:(<span class="built_in">NSTimeInterval</span>)seconds &#123;</span><br><span class="line">    <span class="built_in">NSRunLoop</span> *loop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    GSTimedPerformer *item;</span><br><span class="line">    <span class="comment">// item引用计数+1</span></span><br><span class="line">    item = [[GSTimedPerformer alloc] initWithSelector:aSelector</span><br><span class="line">                                               target:<span class="keyword">self</span></span><br><span class="line">                                             argument:argument</span><br><span class="line">                                                delay:seconds];</span><br><span class="line">    <span class="comment">// 持有item</span></span><br><span class="line">    [[loop _timedPerformers] addObject:item];</span><br><span class="line">    <span class="comment">// item引用计数-1</span></span><br><span class="line">    RELEASE(item);</span><br><span class="line">    <span class="comment">// 持有timer</span></span><br><span class="line">    [loop addTimer:item-&gt;timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要做了这些事:</p>
<ol>
<li>获取当前线程的Runloop对象。</li>
<li>根据方法名、方法参数、方法调用者及延迟时间等信息创建一个<code>GSTimedPerformer</code>对象，把该对象添加到Runloop的<code>_timedPerformers</code>数组中保存。</li>
<li>把GSTimedPerformer中的定时器timer添加到Runloop中。</li>
</ol>
<p>如官方文档所说:This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode.</p>
<p>看看GSTimedPerformer做了什么:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GSTimedPerformer</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">  SEL selector;</span><br><span class="line">  <span class="keyword">id</span> target;</span><br><span class="line">  <span class="keyword">id</span> argument;</span><br><span class="line">  <span class="built_in">NSTimer</span> *timer;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)fire;</span><br><span class="line">- (<span class="keyword">id</span>)initWithSelector:(SEL)aSelector</span><br><span class="line">                target:(<span class="keyword">id</span>)target</span><br><span class="line">              argument:(<span class="keyword">id</span>)argument</span><br><span class="line">                 delay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line">- (<span class="keyword">void</span>)invalidate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GSTimedPerformer</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span> finalize];</span><br><span class="line">    TEST_RELEASE(timer);</span><br><span class="line">    <span class="comment">// 释放target对象</span></span><br><span class="line">    RELEASE(target);</span><br><span class="line">    RELEASE(argument);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)finalize &#123;</span><br><span class="line">    [<span class="keyword">self</span> invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fire &#123;</span><br><span class="line">    DESTROY(timer);</span><br><span class="line">    [target performSelector:selector withObject:argument];</span><br><span class="line">    [[[<span class="built_in">NSRunLoop</span> currentRunLoop] _timedPerformers] removeObjectIdenticalTo:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithSelector:(SEL)aSelector</span><br><span class="line">                target:(<span class="keyword">id</span>)aTarget</span><br><span class="line">              argument:(<span class="keyword">id</span>)anArgument</span><br><span class="line">                 delay:(<span class="built_in">NSTimeInterval</span>)delay &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        selector = aSelector;</span><br><span class="line">        <span class="comment">// 持有target</span></span><br><span class="line">        target = RETAIN(aTarget);</span><br><span class="line">        argument = RETAIN(anArgument);</span><br><span class="line">        timer = [[<span class="built_in">NSTimer</span> allocWithZone:<span class="built_in">NSDefaultMallocZone</span>()]</span><br><span class="line">                 initWithFireDate:<span class="literal">nil</span></span><br><span class="line">                 interval:delay</span><br><span class="line">                 target:<span class="keyword">self</span></span><br><span class="line">                 selector:<span class="keyword">@selector</span>(fire)</span><br><span class="line">                 userInfo:<span class="literal">nil</span></span><br><span class="line">                 repeats:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">        DESTROY(timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>The GSTimedPerformer class is used to hold information about messages which are due to be sent to objects at a particular time.</p>
<p>可见，<code>GSTimedPerformer</code>作用就是保存关于消息的信息，具体方法的延迟和调用主要还是依靠其内部的定时器。分析源码可知，Runloop的<code>_timedPerformers</code>数组持有了<code>GSTimedPerformer</code>，Runloop还持有<code>GSTimedPerformer</code>内部的定时器<code>timer</code>，定时器<code>timer</code>持有着<code>target(self)</code>。而<code>GSTimedPerformer</code>持有着<code>target(self)</code>和定时器<code>timer</code>。</p>
<p>引用关系如图所示：<br><img src="https://image.chenyalun.com/2018/09/30/002.png" style="zoom:40%"></p>
<p>当设置的时间到的时候，<code>GSTimedPerformer</code>内部的<code>fire</code>方法得到调用，此时外界的<code>target</code>便调用了被设置的<code>selector</code>，起到了延迟执行的效果。紧接着，Runloop的<code>_timedPerformers</code>数组移除了对<code>GSTimedPerformer</code>的引用，<code>GSTimedPerformer</code>自然会销毁，它的<code>dealloc</code>方法得到调用。而<code>GSTimedPerformer</code>中的<code>dealloc</code>内部调用了<code>finalize</code>方法，<code>finalize</code>方法的目的是<code>invalidate</code>掉定时器<code>timer</code>并减少它的引用计数。此时，<code>timer</code>只有Runloop持有着它了，关键是timer一旦被<code>invalidate</code>，Runloop也不会再持有它了（Timers are removed automatically when they are invalid）。这样，<code>timer</code>彻底死掉，对<code>target</code>的强引用也没有了，一切恢复如初。</p>
<p>这一切的前提建立在Runloop运行在<code>NSDefaultRunLoopMode</code>模式下并顺利调用<code>fire</code>方法。<strong>当延迟方法因种种原因没有执行就可能出现内存泄露。</strong></p>
<p>很经典的例子：从A控制器push到B控制器，B控制器此时执行一个方法：<code>[self performSelector:@selector(printInfo) withObject:nil afterDelay:100];</code>。此时从B控制器pop到A控制器，很明显B控制器并没有销毁，因为Runloop还（间接）强引用着它，可以理解为出现了内存泄露(尽管100s后<code>printInfo</code>方法得到执行，B控制器会销毁)。</p>
<blockquote>
<p>performSelector关于内存管理的执行原理是这样的执行 [self performSelector:@selector(method1:) withObject:self afterDelay:3]; 的时候，系统会将self的引用计数加1，执行完这个方法时，还会将self的引用计数减1，当方法还没有执行的时候，要返回父视图释放当前视图的时候，self的计数没有减少到0，而导致无法调用dealloc方法，出现了内存泄露。 </p>
</blockquote>
<p><img src="https://image.chenyalun.com/2018/09/30/001.png" style="zoom:60%"></p>
<p>比较好的做法是及时取消掉之前的延迟调用:<code>cancelPreviousPerformRequestsWithTarget: selector:object:</code>，那么<code>cancelPreviousPerformRequestsWithTarget: selector:object:</code>做了什么呢?</p>
<p><span id="jump1"></span></p>
<h3 id="cancelPreviousPerformRequestsWithTarget-selector-object"><a href="#cancelPreviousPerformRequestsWithTarget-selector-object" class="headerlink" title="cancelPreviousPerformRequestsWithTarget: selector:object:"></a>cancelPreviousPerformRequestsWithTarget: selector:object:</h3><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">NSObject</span> cancelPreviousPerformRequestsWithTarget:self]<span class="comment">;</span></span><br><span class="line">[<span class="name">NSObject</span> cancelPreviousPerformRequestsWithTarget:self selector:NSSelectorFromString(<span class="name">@</span><span class="string">"printString:"</span>) object:@<span class="string">"str"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这两个方法可以取消perform延迟调用，它们内部做了什么？</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)targe</span><br><span class="line">                                       selector:(SEL)aSelector</span><br><span class="line">                                         object:(id)arg &#123;</span><br><span class="line">    NSMutableArray *perf = [[NSRunLoop currentRunLoop] _timedPerformers];</span><br><span class="line">    unsigned <span class="built_in">count</span> = [perf <span class="built_in">count</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        GSTimedPerformer *array[<span class="built_in">count</span>];</span><br><span class="line">        IF_NO_GC(RETAIN(<span class="keyword">target</span>));</span><br><span class="line">        IF_NO_GC(RETAIN(arg));</span><br><span class="line">        [perf getObjects: array];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">count</span>-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            // 遍历查找</span><br><span class="line">            GSTimedPerformer *p = array[<span class="built_in">count</span>];</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;<span class="keyword">target</span> == <span class="keyword">target</span> &amp;&amp; sel_isEqual(p-&gt;selector, aSelector)</span><br><span class="line">                &amp;&amp; (p-&gt;argument == arg || [p-&gt;argument isEqual:arg])) &#123;</span><br><span class="line">                // <span class="keyword">target</span>\sel\argument均一致</span><br><span class="line">                [p invalidate];</span><br><span class="line">                [perf removeObjectAtIndex: <span class="built_in">count</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(arg);</span><br><span class="line">        RELEASE(<span class="keyword">target</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获取Runloop内部持有的<code>_timedPerformers</code>数组(数组中的是<code>GSTimedPerformer</code>对象)。</li>
<li>创建一个C语言数组，并把<code>_timedPerformers</code>数组中的内容copy到这个C语言数组array。</li>
<li>遍历该C语言数组array：如果给定参数中的<code>target</code>、<code>argument</code>、<code>selector</code>均<strong>一一对应</strong>，那么销毁<code>GSTimedPerformer</code>对象中的定时器，并根据当前的索引移除<code>_timedPerformers</code>数组的<code>GSTimedPerformer</code>对象。</li>
</ol>
<p>换句话说，如果<code>target</code>、<code>argument</code>、<code>selector</code>中有一个参数没有对应，那么便不会执行销毁定时器操作和移除操作。那么，判定<code>target</code>、<code>argument</code>、<code>selector</code>均一一对应的标准是：Matching of the argument may be either by pointer equality or by use of the [NSObject -isEqual:] method.就是指针比较以及<code>isEqual</code>方法。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(p-&gt;</span>target == target </span><br><span class="line">&amp;&amp; <span class="function"><span class="title">sel_isEqual</span>(p-&gt;</span>selector, aSelector)</span><br><span class="line">&amp;&amp; (<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">argument</span> == arg || [p-&gt;</span>argument isEqual:arg])) </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里的<code>sel_isEqual</code>就等价于<code>==</code>，多说一句，<code>SEL</code>实际上就是根据方法名hash化了的一个字符串（<code>char *</code>），对于字符串的比较只要比较地址就可以了。</p>
<p>同理，<code>+ (void)cancelPreviousPerformRequestsWithTarget:(id)target</code>方法实现原理与上面的方法类似，只是不用比较<code>argument</code>和<code>selector</code>参数，把<code>target</code>有关的所有定时器都销毁，并把所有与之相关的<code>GSTimedPerformer</code>对象都从<code>_timedPerformers</code>数组中移除。<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">count</span>-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   GSTimedPerformer *p = array[<span class="built_in">count</span>];</span><br><span class="line">   <span class="keyword">if</span> (p-&gt;<span class="keyword">target</span> == <span class="keyword">target</span>) &#123;</span><br><span class="line">       [p invalidate];</span><br><span class="line">       [perf removeObjectAtIndex:<span class="built_in">count</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当手动销毁定时器并把<code>GSTimedPerformer</code>从Runloop中移除时，定时器对<code>target</code>的强引用不存在；<code>GSTimedPerformer</code>销毁，<code>GSTimedPerformer</code>对<code>target</code>的强引用也不存在，这样，内存泄露问题解决了。这也是为什么使用<code>cancelPreviousPerformRequestsWithTarget</code>取消还没有执行的perform就可以解决<code>target</code>无法释放掉的原因。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p><span id="jump2"></span></p>
<h3 id="performSelector-target-argument-order-modes"><a href="#performSelector-target-argument-order-modes" class="headerlink" title="performSelector:target:argument:order:modes:"></a>performSelector:target:argument:order:modes:</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector target:(<span class="keyword">id</span>)target argument:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg order:(<span class="built_in">NSUInteger</span>)order modes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line">- (<span class="keyword">void</span>)cancelPerformSelector:(SEL)aSelector target:(<span class="keyword">id</span>)target argument:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg;</span><br><span class="line">- (<span class="keyword">void</span>)cancelPerformSelectorsWithTarget:(<span class="keyword">id</span>)target;</span><br></pre></td></tr></table></figure>
<p>这里主要看<code>performSelector:target:argument:order:modes:</code>是如何实现的。</p>
<p>Sets up sending of aSelector to target with argument. The selector is sent before the next runloop iteration (unless cancelled before then) in any of the specified modes.The target and argument objects are retained.<br>The order value is used to determine the order in which messages are sent if multiple messages have been set up. Messages with a lower order value are sent first.If the modes array is empty, this method has no effect.<br>说的很明白了，就是在指定模式的Runloop下一次迭代之前把selector、argument等信息丢给target，以便调用。这里的<code>order</code>指定了这个调用的优先级，值越小，越早被调用。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector</span><br><span class="line">                 target:(<span class="keyword">id</span>)target</span><br><span class="line">               argument:(<span class="keyword">id</span>)argument</span><br><span class="line">                  order:(<span class="built_in">NSUInteger</span>)order</span><br><span class="line">                  modes:(<span class="built_in">NSArray</span> *)modes &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> count = [modes count];</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *array[count];</span><br><span class="line">        GSRunLoopPerformer *item;</span><br><span class="line">        item = [[GSRunLoopPerformer alloc] initWithSelector:aSelector</span><br><span class="line">                                                     target:target</span><br><span class="line">                                                   argument:argument</span><br><span class="line">                                                      order:order];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把modes中的内容copy到array</span></span><br><span class="line">        <span class="keyword">if</span> ([modes isProxy]) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                array[i] = [modes objectAtIndex:i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [modes getObjects:array];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有mode</span></span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *mode = array[count];</span><br><span class="line">            <span class="keyword">unsigned</span> end;</span><br><span class="line">            <span class="keyword">unsigned</span> i;</span><br><span class="line">            GSRunLoopCtxt *context;</span><br><span class="line">            GSIArray performers;</span><br><span class="line">            </span><br><span class="line">            context = <span class="built_in">NSMapGet</span>(_contextMap, mode);</span><br><span class="line">            <span class="keyword">if</span> (context == <span class="literal">nil</span>) &#123;</span><br><span class="line">                context = [[GSRunLoopCtxt alloc] initWithMode:mode extra:_extra];</span><br><span class="line">                <span class="built_in">NSMapInsert</span>(_contextMap, context-&gt;mode, context);</span><br><span class="line">                RELEASE(context);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取Runloop某个mode下对应的context中的performers</span></span><br><span class="line">            performers = context-&gt;performers;</span><br><span class="line">            <span class="comment">// performers的数量</span></span><br><span class="line">            end = GSIArrayCount(performers);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; end; i++) &#123;</span><br><span class="line">                <span class="comment">// 遍历整个performers数组</span></span><br><span class="line">                GSRunLoopPerformer *p;</span><br><span class="line">                p = GSIArrayItemAtIndex(performers, i).obj;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;order &gt; order) &#123;</span><br><span class="line">                    <span class="comment">// 新添加进来的item的优先级高于当前索引i对应item的优先级, 插入</span></span><br><span class="line">                    GSIArrayInsertItem(performers, (GSIArrayItem)((<span class="keyword">id</span>)item), i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一种可能: i和end都为0, performers数组为空, 上面的for循环没有执行</span></span><br><span class="line">            <span class="comment">// 第二种可能: 新添加进来的item的优先级最低, 上面的for循环没有执行, 把它添加到数组的最后位置</span></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                GSIArrayInsertItem(performers, (GSIArrayItem)((<span class="keyword">id</span>)item), i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            i = GSIArrayCount(performers);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span> &amp;&amp; i &gt; context-&gt;maxPerformers) &#123;</span><br><span class="line">                <span class="comment">// 更新context中的performer最大数量</span></span><br><span class="line">                context-&gt;maxPerformers = i;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"WARNING ... there are %u performers scheduled"</span></span><br><span class="line">                      <span class="string">@" in mode %@ of %@\n(Latest: [%@ %@])"</span>,</span><br><span class="line">                      i, mode, <span class="keyword">self</span>, <span class="built_in">NSStringFromClass</span>([target <span class="keyword">class</span>]),</span><br><span class="line">                      <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据方法实现来看，这个方法做了这些事:</p>
<ol>
<li>如果数组modes中没有内容就直接return。</li>
<li>把<code>target</code>、<code>argument</code>、<code>selector</code>、<code>order</code>等信息包装成一个<code>GSRunLoopPerformer</code>对象。</li>
<li>创建一个字符串数组array，把modes中的内容copy到array。</li>
<li>遍历array。找到每一种mode(<code>NSString</code>类型)在<code>_contextMap</code>(<code>NSMapTable</code>类型)表中对应的context(<code>GSRunLoopCtxt</code>类型)，获得context中需要执行的performers(<code>GSIArray</code>类型)数组。</li>
<li>遍历原来的performers数组，根据第2步中包装好的<code>GSRunLoopPerformer</code>对象的优先级order，插入到performers中的合适位置。</li>
</ol>
<p>总而言之，就是把<code>target</code>、<code>argument</code>、<code>selector</code>、<code>order</code>等信息包装成一个<code>GSRunLoopPerformer</code>对象，并把该对象添加到Runloop（中的<code>_contextMap</code>）里面的performers，供其在合适的时机调用。具体啥时候调用呢？官方文档说是Runloop的下一次迭代的时候。</p>
<p>自不必说，<code>cancelPerformSelector:target:argument:</code>就是根据<code>selector</code>、<code>target</code>和<code>argument</code>移除performers数组中的<code>GSRunLoopPerformer</code>。要求三者完全对应。<br><code>cancelPerformSelector:target:</code>是根据<code>selector</code>、<code>target</code>移除performers数组中相关的所有的<code>GSRunLoopPerformer</code>对象。原理与上文中所说的<a href="#jump1">cancelPreviousPerformRequestsWithTarget:</a>基本一致。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="performSelector-onThread-withObject-waitUntilDone-modes"><a href="#performSelector-onThread-withObject-waitUntilDone-modes" class="headerlink" title="performSelector:onThread:withObject:waitUntilDone:modes:"></a>performSelector:onThread:withObject:waitUntilDone:modes:</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line"><span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line"><span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg;</span><br></pre></td></tr></table></figure>
<p>第二个方法与第一个方法对应，其modes是<code>kCFRunLoopCommonModes</code>，selector在主线程执行。<br>第四个方法与第三个方法对应，其modes是<code>kCFRunLoopCommonModes</code>，selector在指定的子线程执行。<br>第五个方法省略很多参数，selector在内置的子线程执行。</p>
<p>先分析第四个方法即可。具体的实现如下所示:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector</span><br><span class="line">               onThread:(<span class="built_in">NSThread</span> *)aThread</span><br><span class="line">             withObject:(<span class="keyword">id</span>)anObject</span><br><span class="line">          waitUntilDone:(<span class="built_in">BOOL</span>)aFlag</span><br><span class="line">                  modes:(<span class="built_in">NSArray</span>*)anArray &#123;</span><br><span class="line">    GSRunLoopThreadInfo  *info;</span><br><span class="line">    <span class="built_in">NSThread</span> *t;</span><br><span class="line">    <span class="keyword">if</span> ([anArray count] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    t = GSCurrentThread();</span><br><span class="line">    <span class="keyword">if</span> (aThread == <span class="literal">nil</span>) aThread = t;</span><br><span class="line">    info = GSRunLoopInfoForThread(aThread);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t == aThread) &#123;</span><br><span class="line">        <span class="comment">// Perform in current thread.</span></span><br><span class="line">        <span class="keyword">if</span> (aFlag == <span class="literal">YES</span> || info-&gt;loop == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">// Wait until done or no run loop.</span></span><br><span class="line">            [<span class="keyword">self</span> performSelector:aSelector withObject:anObject];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Don't wait ... schedule operation in run loop.</span></span><br><span class="line">            [info-&gt;loop performSelector:aSelector</span><br><span class="line">                                 target:<span class="keyword">self</span></span><br><span class="line">                               argument:anObject</span><br><span class="line">                                  order:<span class="number">0</span></span><br><span class="line">                                  modes:anArray];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GSPerformHolder *h;</span><br><span class="line">        <span class="built_in">NSConditionLock</span> *l = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 线程Finished判断</span></span><br><span class="line">        <span class="keyword">if</span> ([aThread isFinished] == <span class="literal">YES</span>) &#123;</span><br><span class="line">            [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                        format: <span class="string">@"perform on finished thread"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 阻塞等待加锁</span></span><br><span class="line">        <span class="keyword">if</span> (aFlag == <span class="literal">YES</span>) &#123;</span><br><span class="line">            l = [[<span class="built_in">NSConditionLock</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        h = [GSPerformHolder newForReceiver:<span class="keyword">self</span></span><br><span class="line">                                   argument:anObject</span><br><span class="line">                                   selector:aSelector</span><br><span class="line">                                      modes:anArray</span><br><span class="line">                                       lock:l];</span><br><span class="line">        [info addPerformer:h];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 条件锁创建成功(也即参数aFlag为YES)</span></span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">nil</span>) &#123;</span><br><span class="line">            [l lockWhenCondition:<span class="number">1</span>]; <span class="comment">// 当条件为1时加锁</span></span><br><span class="line">            [l unlock];</span><br><span class="line">            RELEASE(l);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// holder已经失效则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> ([h isInvalidated] == <span class="literal">YES</span>) &#123;</span><br><span class="line">                RELEASE(h);</span><br><span class="line">                [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                            format: <span class="string">@"perform on finished thread"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// holder自身就产生exception了, 那么再次抛出异常</span></span><br><span class="line">            <span class="comment">// If we have an exception passed back from the remote thread, re-raise it.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nil</span> != h-&gt;exception) &#123;</span><br><span class="line">                <span class="built_in">NSException</span> *e = AUTORELEASE(RETAIN(h-&gt;exception));</span><br><span class="line">                RELEASE(h);</span><br><span class="line">                [e raise];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要做了这些什么?</p>
<ol>
<li>首先对传进来的<code>modes</code>(Runloop模式数组)个数进行判断，如果为0，则直接return。</li>
<li>获取该方法执行上下文中的线程： <code>t</code>，并把它与作为参数传进来的线程<code>aThread</code>进行比较，看是否一致。当然，如果传进来的<code>aThread</code>为空，那么执行<code>aThread = t;</code>，就让<code>selector</code>在当前上下文中的线程中执行。</li>
<li>当两个线程一致时，如果参数<code>aFlag</code>为YES或者线程对应的Runloop为空，说明需要等待，也即这个方法应该等到selector被执行完毕后再return。这就好办了，直接调用<code>[self performSelector: aSelector withObject: anObject];</code>方法，同步执行即可。如果不需要等待呢? 把<code>selector</code>、<code>argument</code>、<code>modes</code>等信息交给线程对应的Runloop再进一步处理（schedule operation in run loop）。</li>
<li>当两个线程不一致时，首先判断<code>aThread</code>有没有<code>finished</code>，线程死了自然<code>selector</code>无法执行，抛出异常。再者判断是否需要阻塞等待，如果需要的话就创建一个条件锁。接着把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个<code>GSPerformHolder</code>对象，并把它交给封装线程信息的<code>GSRunLoopThreadInfo</code>对象。之后是一些收尾工作：设置条件锁的condition及一些异常判断。</li>
</ol>
<p>需要着重说明的是参数<code>aFlag</code>： 是否立即返回。如果参数<code>aFlag</code>为YES，则这个方法应该等到<code>selector</code>被执行完毕后再return。如果<code>selector</code>是在当前方法上下文的线程中执行，且该线程对应的Runloop没有run，那么会忽略<code>modes</code>，直接执行：<code>performSelector:aSelector withObject:</code>。</p>
<p>当两个线程一致时，也即<code>selector</code>执行的线程就是当前方法上下文中的线程，这比较好处理，把<code>selector</code>、<code>argument</code>、<code>modes</code>等信息交给线程对应的Runloop即可，就是模式中的方法：<a href="#jump2">performSelector:target:argument:order:modes:</a>。</p>
<p><strong>GSPerformHolder</strong></p>
<p>两个线程不一致时，“把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个<code>GSPerformHolder</code>对象，并把它交给封装线程信息的<code>GSRunLoopThreadInfo</code>对象”又是怎么做的呢?</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(GSPerformHolder</span> <span class="string">*)h</span> <span class="string">=</span> <span class="string">[GSPerformHolder</span> <span class="attr">newForReceiver:self</span></span><br><span class="line"><span class="attr">                                             argument:</span><span class="string">anObject</span></span><br><span class="line"><span class="attr">                                             selector:</span><span class="string">aSelector</span></span><br><span class="line"><span class="attr">                                                modes:</span><span class="string">anArray</span></span><br><span class="line"><span class="attr">                                                 lock:</span><span class="string">l];</span></span><br><span class="line"><span class="string">[(GSRunLoopThreadInfo</span> <span class="string">*)info</span> <span class="attr">addPerformer:h];</span></span><br></pre></td></tr></table></figure>
<p><code>newForReceiver:argument:selector:modes:lock:</code> 这个方法就是做一些信息封装，无需多言。主要是这个<code>addPerformer</code>，删除<code>#if defined(_WIN32)</code>的代码后具体实现如下:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addPerformer:(<span class="keyword">id</span>)performer &#123;</span><br><span class="line">    <span class="built_in">BOOL</span>  signalled = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">// NSLock加锁</span></span><br><span class="line">    [lock lock];</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> start = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 使用write函数向 outputFd 中写入 1 字节数据，数据为: "0"。</span></span><br><span class="line">    <span class="keyword">while</span> (outputFd &gt;= <span class="number">0</span> &amp;&amp; <span class="literal">NO</span> == (signalled = (write(outputFd, <span class="string">"0"</span>, <span class="number">1</span>) == <span class="number">1</span>) ? <span class="literal">YES</span> : <span class="literal">NO</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSTimeInterval</span>    now = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0.0</span> == start) &#123;</span><br><span class="line">            start = now;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now - start &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Unable to signal %@ within a second; blocked?"</span>, <span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock];</span><br><span class="line">        [lock lock];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据成功，把performer添加到GSRunLoopThreadInfo数组中</span></span><br><span class="line">    <span class="keyword">if</span> (signalled) [performers addObject: performer];</span><br><span class="line">    <span class="comment">// NSLock解锁</span></span><br><span class="line">    [lock unlock];</span><br><span class="line">    <span class="comment">// 写入数据失败，销毁performer</span></span><br><span class="line">    <span class="keyword">if</span> (!signalled) [performer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充write函数知识点:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * <span class="built_in">write</span>函数</span><br><span class="line"> * ssize_t  <span class="built_in">write</span>(int __fd, const void * __buf, size_t __nbyte) __DARWIN_ALIAS_C(<span class="built_in">write</span>);</span><br><span class="line"> * <span class="built_in">write</span> 函数向 __fd 中写入 __nbyte 字节数据，数据来源为 __buf 。返回值一般总是等于 __nbyte</span><br><span class="line"> * 返回值如果不是等于__nbyte，就是出错了。常见的出错原因是磁盘空间满了或者超过了文件大小限制。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* The <span class="built_in">write</span> could concievably fail <span class="keyword">if</span> <span class="keyword">the</span> pipe <span class="keyword">is</span> full.</span><br><span class="line"> * In <span class="keyword">that</span> case we need <span class="keyword">to</span> release <span class="keyword">the</span> lock temporarily <span class="keyword">to</span> allow <span class="keyword">the</span> other</span><br><span class="line"> * thread <span class="keyword">to</span> consume data <span class="keyword">from</span> <span class="keyword">the</span> pipe.  It's possible <span class="keyword">that</span> <span class="keyword">the</span> thread</span><br><span class="line"> * <span class="keyword">and</span> <span class="keyword">its</span> runloop might stop during <span class="keyword">that</span> ... so we need <span class="keyword">to</span> check <span class="keyword">that</span></span><br><span class="line"> * outputFd <span class="keyword">is</span> still valid.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>不是十分理解write函数在这里的作用，根据一些异常信息<code>&quot;Failed to set non block flag for perform in thread&quot; &quot;Failed to create event to handle perform in thread&quot;</code>，可能是向文件中写入一些flag表示线程指定事件对象的信号状态吧。</p>
<p>如果信号状态设置成功，就把这个perform对象(<code>GSPerformHolder</code>类型)添加到<code>GSRunLoopThreadInfo</code>的performers数组中。</p>
<p>这个<code>GSRunLoopThreadInfo</code>对象把<code>GSPerformHolder</code>对象添加到自己数组中后，具体最原先的perform什么时候执行呢? <strong>是在调用<code>GSRunLoopThreadInfo</code>对象的<code>fire</code>方法时逐个执行</strong>：</p>
<p>GSRunLoopThreadInfo对象的<code>fire</code>方法部分实现:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">for</span> <span class="string">(i</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span> <span class="string">i</span> <span class="string">&lt;</span> <span class="string">c;</span> <span class="string">i++)</span> <span class="string">&#123;</span></span><br><span class="line">   <span class="string">GSPerformHolder</span> <span class="meta">*h</span> <span class="string">=</span> <span class="string">[toDo</span> <span class="attr">objectAtIndex:i];</span></span><br><span class="line">   </span><br><span class="line">   <span class="string">[loop</span> <span class="attr">performSelector:@selector(fire)</span></span><br><span class="line"><span class="attr">                  target:</span><span class="string">h</span></span><br><span class="line"><span class="attr">                argument:</span><span class="string">nil</span></span><br><span class="line"><span class="attr">                   order:</span><span class="number">0</span></span><br><span class="line"><span class="attr">                   modes:</span><span class="string">[h</span> <span class="string">modes]];</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可见是逐个取出数组中的<code>GSPerformHolder</code>对象，一个接一个地调用<code>GSPerformHolder</code>的<code>fire</code>方法，这也是个<code>fire</code>方法，它内部做了什么？就是<code>[receiver performSelector: selector withObject: argument];</code>。</p>
<p>捋一捋: 两个线程不一致时，把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个<code>GSPerformHolder</code>对象，并把它添加到<code>GSRunLoopThreadInfo</code>对象的performers数组中。当调用<code>GSRunLoopThreadInfo</code>对象的<code>fair</code>方法时会遍历performers数组，然后逐个调用数组中每一个元素的<code>fair</code>方法，而这个<code>fair</code>方法内部就是调用<code>performSelector:withObject</code>方法。</p>
<p>最最关键的一个问题: 什么时候调用<code>GSRunLoopThreadInfo</code>对象的<code>fair</code>方法? 官方文档说:<strong> May only be called from the runloop when the event/descriptor is triggered.</strong></p>
<p>我在Runloop的<code>+(BOOL)awakenedBefore:</code>和 <code>-(BOOL)pollUntil:within:</code>方法中找到了调用痕迹。</p>
<h3 id="任意线程调用"><a href="#任意线程调用" class="headerlink" title="任意线程调用"></a>任意线程调用</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">- (void)performSelector:(SEL)aSelector</span><br><span class="line"><span class="symbol">               onThread:</span>(NSThread*)aThread</span><br><span class="line"><span class="symbol">             withObject:</span>(id)anObject</span><br><span class="line"><span class="symbol">          waitUntilDone:</span>(BOOL)<span class="class">aFlag </span>&#123;</span><br><span class="line">    [self performSelector:aSelector</span><br><span class="line"><span class="symbol">                 onThread:</span>aThread</span><br><span class="line"><span class="symbol">               withObject:</span>anObject</span><br><span class="line"><span class="symbol">            waitUntilDone:</span>aFlag</span><br><span class="line"><span class="symbol">                    modes:</span>commonModes()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runloop的五种mode分别是:<code>NSDefaultRunLoopMode，NSConnectionReplyMode，NSModalPanelRunLoopMode，NSEventTrackingRunLoopMode，NSRunLoopCommonModes</code>。<br><strong>这个方法省略了modes参数，内部使用common mode</strong>，也即<code>NSDefaultRunLoopMode</code>和<code>NSConnectionReplyMode</code>(不是<code>NSEventTrackingRunLoopMode</code>)。所以如果有鼠标或者手势事件需要处理，省略modes参数可能不是个好做法。</p>
<h3 id="主线程调用"><a href="#主线程调用" class="headerlink" title="主线程调用"></a>主线程调用</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector</span><br><span class="line"><span class="symbol">                         withObject:</span>(id)anObject</span><br><span class="line"><span class="symbol">                      waitUntilDone:</span>(BOOL)aFlag</span><br><span class="line"><span class="symbol">                              modes:</span>(NSArray*)<span class="class">anArray </span>&#123;</span><br><span class="line">    if (defaultThread == nil) defaultThread = [NSThread mainThread];</span><br><span class="line">    [self performSelector:aSelector</span><br><span class="line"><span class="symbol">                 onThread:</span>defaultThread</span><br><span class="line"><span class="symbol">               withObject:</span>anObject</span><br><span class="line"><span class="symbol">            waitUntilDone:</span>aFlag</span><br><span class="line"><span class="symbol">                    modes:</span>anArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个方法指定了主线程。</strong></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector</span><br><span class="line"><span class="symbol">                         withObject:</span>(id)anObject</span><br><span class="line"><span class="symbol">                      waitUntilDone:</span>(BOOL)<span class="class">aFlag </span>&#123;</span><br><span class="line">    [self performSelectorOnMainThread:aSelector</span><br><span class="line"><span class="symbol">                           withObject:</span>anObject</span><br><span class="line"><span class="symbol">                        waitUntilDone:</span>aFlag</span><br><span class="line"><span class="symbol">                                modes:</span>commonModes()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这两个方法指定了主线程，内部使用common mode。</strong></p>
<h3 id="Background调用"><a href="#Background调用" class="headerlink" title="Background调用"></a>Background调用</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">- (void)performSelectorInBackground:(SEL)aSelector</span><br><span class="line"><span class="symbol">                         withObject:</span>(id)<span class="class">anObject </span>&#123;</span><br><span class="line">    [NSThread detachNewThreadSelector:aSelector</span><br><span class="line"><span class="symbol">                             toTarget:</span>self</span><br><span class="line"><span class="symbol">                           withObject:</span>anObject];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个方法会创建一条任意的线程执行<code>selector</code>方法。</strong></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="printInfo方法会执行吗"><a href="#printInfo方法会执行吗" class="headerlink" title="printInfo方法会执行吗"></a>printInfo方法会执行吗</h3><h4 id="GCD调用"><a href="#GCD调用" class="headerlink" title="GCD调用"></a>GCD调用</h4><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [self performSelector:@selector(<span class="name">printInfo</span>) withObject<span class="symbol">:nil</span> afterDelay:<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>很明显是不会的。因为<code>performSelector</code>具体实现中并没有主动触发线程对应Runloop运行。子线程对应的Runloop没有run。怎么让它执行？启动Runloop:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [self performSelector:@selector(<span class="name">printInfo</span>) withObject<span class="symbol">:nil</span> afterDelay:<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    [[NSRunLoop currentRunLoop] run]<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="NSThread调用"><a href="#NSThread调用" class="headerlink" title="NSThread调用"></a>NSThread调用</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] <span class="string">initWithBlock:</span>^&#123;</span><br><span class="line">   [self <span class="string">performSelector:</span><span class="meta">@selector</span>(printInfo) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">1</span>];</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<p>同理:</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">NSThread *thread = <span class="comment">[<span class="comment">[NSThread alloc]</span> initWithBlock:^&#123;</span></span><br><span class="line"><span class="comment">   <span class="comment">[self performSelector:@selector(printInfo) withObject:nil afterDelay:1]</span>;</span></span><br><span class="line"><span class="comment">   <span class="comment">[<span class="comment">[NSRunLoop currentRunLoop]</span> run]</span>;</span></span><br><span class="line"><span class="comment">&#125;]</span>;</span><br><span class="line"><span class="comment">[thread start]</span>;</span><br></pre></td></tr></table></figure>
<p>这就有一个问题了。在GCD中<code>[[NSRunLoop currentRunLoop] run];</code>放在<code>performSelector</code>前面或者后面貌似都是可以的，但是在NSThread中<code>[[NSRunLoop currentRunLoop] run];</code>只能放在<code>performSelector</code>的后面。</p>
<p>在NSThread方法中:</p>
<blockquote>
<p>因为run方法只是尝试想要开启当前线程中的runloop，但是如果该线程中并没有任何事件(source、timer、observer)的话，并不会成功的开启。</p>
</blockquote>
<p>为什么GCD中即使<code>[[NSRunLoop currentRunLoop] run];</code>放在前面<code>printInfo</code>方法还是调用了呢? 代码实际测试，延迟效果没有了，并且有时方法执行，有时方法没有执行。</p>
<p>综上，<strong>在子线程中使用performSelector的延迟方法，需要加上<code>[[NSRunLoop currentRunLoop] run];</code>使得Runloop能够运行，并且该方法要放在<code>performSelector</code>的后面来保证Runloop成功运行。</strong></p>
<h4 id="NSThread无效"><a href="#NSThread无效" class="headerlink" title="NSThread无效"></a>NSThread无效</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] <span class="string">initWithBlock:</span>^&#123;&#125;];</span><br><span class="line">[thread start];</span><br><span class="line">[self <span class="string">performSelector:</span><span class="meta">@selector</span>(printMainInfo) <span class="string">onThread:</span>thread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br></pre></td></tr></table></figure>
<p>上面这段代码为什么没有执行printMainInfo方法?</p>
<p>子线程执行完操作之后就会立即释放，即使我们使用强引用引用子线程使子线程不被释放，也不能给子线程再次添加操作，或者再次开启。这里可以使用Runloop。子线程获取其对应的Runloop对象并使之运行。一般使用常驻子线程。</p>
<p>正确实践：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">   <span class="comment">// 执行一次而已</span></span><br><span class="line">   <span class="built_in">NSRunLoop</span> *currentRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">   [currentRunLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(printMainInfo) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>梳理本文，比较重要的几个小点如下：</p>
<ol>
<li><code>performSelector</code>内部的实现就是使用<code>IMP</code>直接调用对象的方法。</li>
<li>严格遵守ARC规则，注意方法的命名，不然会为内存泄漏埋下伏笔。</li>
<li>反射<code>NSSelectorFromString()</code>很强大，但是使用<code>@selector()</code>显式告诉编译器将要调用的方法是更优的选择。</li>
<li><code>performSelector</code>能实现延迟是因为定时器，要及时取消无法执行的延迟方法。</li>
<li>子线程中使用延迟方法，需要主动使Runloop能够运行。</li>
<li>NSTimer在其<code>invalidate</code>方法调用后，Runloop会自动移除对它的引用。</li>
</ol>
<p>具体在业务上，可以举几个简单的场景。</p>
<p>对于文件或者模型的下载，有时候需要用到进度条提示。这时候可以在子线程下载，跑到主线程更新UI：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[self <span class="string">performSelectorOnMainThread:</span><span class="meta">@selector</span>(updateProgress) <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br></pre></td></tr></table></figure></p>
<p>有些时候需要进行简单的Tip提示，3秒后自动让它自动隐藏：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[self.tipView <span class="string">performSelector:</span><span class="meta">@selector</span>(dismiss) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">3.</span>f];</span><br></pre></td></tr></table></figure></p>
<p>当使用多态的时候，动态调用方法创建实例对象：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Class cls = Nil;</span><br><span class="line"><span class="keyword">if</span> (item.isForChinese) &#123;</span><br><span class="line">    cls = NSClassFromString(@<span class="string">"YAChinesePopView"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cls = NSClassFromString(@<span class="string">"YAEnglishPopView"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> [cls <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">popViewWithItem:</span>) <span class="string">withObject:</span>item];</span><br></pre></td></tr></table></figure></p>
<p>偶然间发现一个好玩的例子：直接调用某个对象的某个方法，而不导入其头文件。比如手百自定义一个继承自WKWebView的子类，并把这个实例暴露出来，我们想让它执行某段JavaScript，但是又不想导入繁重的头文件：</p>
<pre><code>if ([obj respondsToSelector:@selector(evaluateJavaScript:completionHandler:)]) {
    [obj performSelector:@selector(evaluateJavaScript:completionHandler:) withObject:js withObject:nil];
} 
</code></pre><p>上面的只是冰山一角，其合理性需要结合具体的业务场景具体分析，只是想阐明，performSelector在一些情况下是很有用的。</p>
<hr>
<blockquote>
<p>参考资料<br><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html" target="_blank" rel="noopener">Advanced Memory Management Programming Guide</a><br><a href="https://zhongwuzw.github.io/2017/01/19/Objective-C之performSelector编译器内存泄露警告/" target="_blank" rel="noopener">Objective-C之performSelector编译器内存泄露警告</a><br><a href="https://blog.csdn.net/dean19900504/article/details/8067679" target="_blank" rel="noopener">用performSelector的时候要注意别内存泄露了</a><br><a href="https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown" target="_blank" rel="noopener">PerformSelector May Cause a Leak</a><br><a href="https://blog.csdn.net/wei371522/article/details/81216853" target="_blank" rel="noopener">performSelector 注意问题及原理</a><br><a href="https://blog.csdn.net/king16304/article/details/52192259" target="_blank" rel="noopener">c/c++ read 函数和 write 函数</a></p>
</blockquote>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/iOS开发/">iOS开发</a>
            
              <a href="/tags/阅读/">阅读</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/12/20/读「YYModel」/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">读「YYModel」</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/07/10/Runtime基础/">
        <span class="next-text nav-default">Runtime基础</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
