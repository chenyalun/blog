<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="详解performSelector">




  <meta name="keywords" content="iOS开发,阅读,">




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x">



<link rel="canonical" href="http://blog.chenyalun.com/2018/09/30/详解performSelector/">


<meta name="description" content="performSelector相关知识。">
<meta name="keywords" content="iOS开发,阅读">
<meta property="og:type" content="article">
<meta property="og:title" content="详解performSelector">
<meta property="og:url" content="http://blog.chenyalun.com/2018/09/30/详解performSelector/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="performSelector相关知识。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image.chenyalun.com/2018/09/30/002.png">
<meta property="og:image" content="https://image.chenyalun.com/2018/09/30/001.png">
<meta property="og:updated_time" content="2019-03-29T03:01:43.583Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="详解performSelector">
<meta name="twitter:description" content="performSelector相关知识。">
<meta name="twitter:image" content="https://image.chenyalun.com/2018/09/30/002.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> 详解performSelector · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          详解performSelector
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018年9月30日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本"><span class="toc-text">基本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄露"><span class="toc-text">内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决办法"><span class="toc-text">解决办法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方式一-methodForSelector-没有解决内存泄露"><span class="toc-text">方式一: methodForSelector(没有解决内存泄露)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方式二-methodForSelector简化版-没有解决内存泄露"><span class="toc-text">方式二: methodForSelector简化版(没有解决内存泄露)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方式三-消除警告-没有解决内存泄露"><span class="toc-text">方式三: 消除警告(没有解决内存泄露)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方式四-使用objc-msgSend-没有解决内存泄露"><span class="toc-text">方式四: 使用objc_msgSend(没有解决内存泄露)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方式五-objc-msgSend手动释放内存-解决内存泄露"><span class="toc-text">方式五: objc_msgSend手动释放内存(解决内存泄露)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方式六-methodForSelector手动释放内存-解决内存泄露"><span class="toc-text">方式六: methodForSelector手动释放内存(解决内存泄露)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方式七-NSInvocation-没有解决内存泄露"><span class="toc-text">方式七: NSInvocation(没有解决内存泄露)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方式八-sendAction-没有解决内存泄露"><span class="toc-text">方式八: sendAction(没有解决内存泄露)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#延迟"><span class="toc-text">延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#performSelector-withObject-afterDelay"><span class="toc-text">performSelector:withObject:afterDelay:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cancelPreviousPerformRequestsWithTarget-selector-object"><span class="toc-text">cancelPreviousPerformRequestsWithTarget: selector:object:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#performSelector-onThread-withObject-waitUntilDone-modes"><span class="toc-text">performSelector:onThread:withObject:waitUntilDone:modes:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#两个线程一致时"><span class="toc-text">两个线程一致时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个线程不一致时"><span class="toc-text">两个线程不一致时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关方法"><span class="toc-text">相关方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一些题目"><span class="toc-text">一些题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#printInfo方法会执行吗"><span class="toc-text">printInfo方法会执行吗</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GCD调用"><span class="toc-text">GCD调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSThread调用"><span class="toc-text">NSThread调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSThread无效"><span class="toc-text">NSThread无效</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p align="center"> performSelector相关知识。 </p>

<a id="more"></a>
<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object1 withObject:<span class="params">(id)</span>object2;</span><br></pre></td></tr></table></figure>
<p>代码:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参</span></span><br><span class="line">- (<span class="keyword">id</span>)printString &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个参数</span></span><br><span class="line">- (<span class="keyword">id</span>)printString:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个参数</span></span><br><span class="line">- (<span class="keyword">id</span>)printString:(<span class="built_in">NSString</span> *)str1 str2:(<span class="keyword">id</span>)obj &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, str1, obj[<span class="string">@"key"</span>]);</span><br><span class="line">    <span class="keyword">return</span> str1;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">id</span> obj1 = [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(printString)];</span><br><span class="line"><span class="keyword">id</span> obj2 = [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(printString:) withObject:<span class="string">@"string"</span>];</span><br><span class="line"><span class="keyword">id</span> obj3 = [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(printString:str2:) withObject:<span class="string">@"string"</span> withObject:@&#123;<span class="string">@"key"</span>: @(<span class="number">3</span>)&#125;];</span><br></pre></td></tr></table></figure>
<p>实现方式: </p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) performSelector: (SEL)aSelector</span><br><span class="line">	    withObject: (<span class="keyword">id</span>) object1</span><br><span class="line">	    withObject: (<span class="keyword">id</span>) object2</span><br><span class="line">&#123;</span><br><span class="line">  IMP msg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (aSelector == <span class="number">0</span>)</span><br><span class="line">    [<span class="built_in">NSException</span> raise: <span class="built_in">NSInvalidArgumentException</span></span><br><span class="line">		format: <span class="string">@"%@ null selector given"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">  msg = objc_msg_lookup(<span class="keyword">self</span>, aSelector);</span><br><span class="line">  <span class="keyword">if</span> (!msg)</span><br><span class="line">    &#123;</span><br><span class="line">      [<span class="built_in">NSException</span> raise: <span class="built_in">NSGenericException</span></span><br><span class="line">		   format: <span class="string">@"invalid selector '%s' passed to %s"</span>,</span><br><span class="line">                   sel_getName(aSelector), sel_getName(_cmd)];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (*msg)(<span class="keyword">self</span>, aSelector, object1, object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Runtime中的API<code>objc_msg_lookup()</code>，根据方法名获取到函数指针IMP，进而进行间接调用。在这其中还包括了方法名和函数指针的容错处理。<br>主要就是这样:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 获取函数指针</span></span><br><span class="line"><span class="type">IMP</span> imp = [<span class="keyword">self</span> methodForSelector:@selector(printString:)];</span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line">void (*<span class="function"><span class="keyword">func</span>)<span class="params">(id, SEL, id)</span></span> = (void *)imp;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">self</span>, @selector<span class="params">(printString:)</span></span></span>, @<span class="string">"string"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><ol>
<li>调用<code>alloc, copy, init, mutableCopy, new</code>等方法出现内存泄露。</li>
<li>调用以<code>alloc, new, copy, mutableCopy</code>开头的方法出现内存泄露。You create an object using a method whose name begins with “alloc”, “new”, “copy”, or “mutableCopy” (for example, alloc, newObject, or mutableCopy).</li>
</ol>
<ul>
<li>有内存泄露</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"mutableString"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调用出现Error: PerformSelector names a selector which retains the object</span></span><br><span class="line">[str performSelector:<span class="keyword">@selector</span>(<span class="keyword">copy</span>)];</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(newObject)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式调用无法分析出错误: 出现内存泄露</span></span><br><span class="line"><span class="keyword">id</span> obj4 = [str performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"copy"</span>)];</span><br><span class="line">[str performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"mutableCopy"</span>)];</span><br><span class="line"><span class="keyword">id</span> newObject = [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"new"</span>)];</span><br></pre></td></tr></table></figure>
<ul>
<li>没有内存泄露</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有内存泄露</span></span><br><span class="line">- (<span class="keyword">id</span>)createNewObject &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"string"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">id</span> newObject = [<span class="keyword">self</span> performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"createNewObject"</span>)];</span><br></pre></td></tr></table></figure>
<ul>
<li>有内存泄露</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有内存泄露</span></span><br><span class="line">- (id)<span class="keyword">new</span><span class="type">Object</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [NSObject <span class="keyword">new</span><span class="type"></span>];</span><br><span class="line">&#125;</span><br><span class="line">id <span class="keyword">new</span><span class="type">Object</span> = [self performSelector:<span class="type">NSSelectorFromString</span>(@<span class="string">"newObject"</span>)];</span><br></pre></td></tr></table></figure>
<p>There are really only 4 things that ARC would consider for the return value:4</p>
<ul>
<li>Ignore non-object types (void, int, etc)</li>
<li>Retain object value, then release when it is no longer used (standard assumption)</li>
<li>Release new object values when no longer used (methods in the init/ copy family or attributed with ns_returns_retained)</li>
<li>Do nothing &amp; assume returned object value will be valid in local scope (until inner most release pool is drained, attributed with ns_returns_autoreleased)</li>
</ul>
<p>The call to methodForSelector: assumes that the return value of the method it’s calling is an object, but does not retain/release it. So you could end up creating a leak if your object is supposed to be released as in #3 above (that is, the method you’re calling returns a new object).</p>
<p><img src="https://image.chenyalun.com/2018/09/30/002.png" alt></p>
<p>内存泄露的原因:</p>
<ol>
<li>调用<code>performSelector:</code>编译器会假设调用方法的返回值是一个对象，且不会对返回值进行retain/release。</li>
<li>如果调用的方法是<code>alloc, new, copy, mutableCopy</code>家族中的方法(包含以它们开头)，方法调用的结果是开辟了一块内存空间，但是系统仍然按照非retain/release处理，内存空间无法释放，故而产生内存泄露。</li>
</ol>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>下面的是为了消除警告而列出的方法。</p>
<h4 id="方式一-methodForSelector-没有解决内存泄露"><a href="#方式一-methodForSelector-没有解决内存泄露" class="headerlink" title="方式一: methodForSelector(没有解决内存泄露)"></a>方式一: methodForSelector(没有解决内存泄露)</h4><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!person) return;</span><br><span class="line"><span class="comment">// 获取函数指针</span></span><br><span class="line">IMP imp = [person methodForSelector:<span class="keyword">selector</span>];</span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line">void <span class="comment">(*func)(id, SEL) = (void *)</span>imp;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">func(person, <span class="keyword">selector</span>);</span><br></pre></td></tr></table></figure>
<h4 id="方式二-methodForSelector简化版-没有解决内存泄露"><a href="#方式二-methodForSelector简化版-没有解决内存泄露" class="headerlink" title="方式二: methodForSelector简化版(没有解决内存泄露)"></a>方式二: methodForSelector简化版(没有解决内存泄露)</h4><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">((<span class="name">void</span> (<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))[person methodForSelector:selector])(<span class="name">self</span>, selector)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="方式三-消除警告-没有解决内存泄露"><a href="#方式三-消除警告-没有解决内存泄露" class="headerlink" title="方式三: 消除警告(没有解决内存泄露)"></a>方式三: 消除警告(没有解决内存泄露)</h4><figure class="highlight leaf"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic push"</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic ignored \"</span>-<span class="variable">Warc</span>-<span class="variable">performSelector</span>-<span class="variable">leaks</span>\<span class="string">""</span>)</span></span></span><br><span class="line">[person performSelector:selector]; // 插入需要消除警告的代码</span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic pop"</span>)</span></span></span><br><span class="line">     </span><br><span class="line">// 使用<span class="function"><span class="keyword">#</span><span class="title">pragm</span><span class="params">(与以上无异)</span></span></span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored "-Warc-performSelector-leaks"</span><br><span class="line">YAPerson *person = [[YAPerson alloc] init];</span><br><span class="line">[person performSelector:selector];</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure>
<h4 id="方式四-使用objc-msgSend-没有解决内存泄露"><a href="#方式四-使用objc-msgSend-没有解决内存泄露" class="headerlink" title="方式四: 使用objc_msgSend(没有解决内存泄露)"></a>方式四: 使用objc_msgSend(没有解决内存泄露)</h4><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">((<span class="name">void</span> *(<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))objc_msgSend)((<span class="name"><span class="builtin-name">id</span></span>)self, NSSelectorFromString(@<span class="string">"newObject"</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="方式五-objc-msgSend手动释放内存-解决内存泄露"><a href="#方式五-objc-msgSend手动释放内存-解决内存泄露" class="headerlink" title="方式五: objc_msgSend手动释放内存(解决内存泄露)"></a>方式五: objc_msgSend手动释放内存(解决内存泄露)</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 就是方式二, 只不过添加了Release Bridge</span></span><br><span class="line"><span class="keyword">id</span> obj = <span class="built_in">CFBridgingRelease</span>(((<span class="keyword">void</span> *(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(<span class="keyword">self</span>, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)));</span><br></pre></td></tr></table></figure>
<h4 id="方式六-methodForSelector手动释放内存-解决内存泄露"><a href="#方式六-methodForSelector手动释放内存-解决内存泄露" class="headerlink" title="方式六: methodForSelector手动释放内存(解决内存泄露)"></a>方式六: methodForSelector手动释放内存(解决内存泄露)</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = <span class="built_in">CFBridgingRelease</span>(((<span class="keyword">void</span> *(*)(<span class="keyword">id</span>, SEL))[<span class="keyword">self</span> methodForSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)])(<span class="keyword">self</span>, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)));</span><br></pre></td></tr></table></figure>
<h4 id="方式七-NSInvocation-没有解决内存泄露"><a href="#方式七-NSInvocation-没有解决内存泄露" class="headerlink" title="方式七: NSInvocation(没有解决内存泄露)"></a>方式七: NSInvocation(没有解决内存泄露)</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>);</span><br><span class="line"><span class="built_in">NSMethodSignature</span> *methodSig = [[<span class="keyword">self</span> <span class="keyword">class</span>] instanceMethodSignatureForSelector:selector];</span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:methodSig];</span><br><span class="line">[invocation setSelector:selector];</span><br><span class="line">[invocation setTarget:<span class="keyword">self</span>];</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure>
<h4 id="方式八-sendAction-没有解决内存泄露"><a href="#方式八-sendAction-没有解决内存泄露" class="headerlink" title="方式八: sendAction(没有解决内存泄露)"></a>方式八: sendAction(没有解决内存泄露)</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIApplication</span>.sharedApplication sendAction:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>) to:<span class="keyword">self</span> from:<span class="literal">nil</span> forEvent:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>除此之外，还有许多许多，并没有全部列出来。尤其是一些看似<code>一顿操作猛如虎</code>却没有解决实质问题的方法。<br>总结以上方法，既能消除警告，又能避免内存泄露，还不会丢掉动态调用的便利，三全其美的便是方法五和方法六，尤其是方法五。当然，两者本质上是一样的，只不过一个看着顺眼些。核心还是<code>CFBridgingRelease</code>: 把遗漏的对象释放掉。<br>(注: 笔者目前没有在网上看到有人使用类似的方法，但是，亲自实验过后发现其确实可以解决内存泄露问题。若有不妥，请指正:<a href="mailto:iChenYalun@gmail.com" target="_blank" rel="noopener">iChenYalun@gmail.com</a>)</p>
<h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument;</span><br><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget;</span><br></pre></td></tr></table></figure>
<h3 id="performSelector-withObject-afterDelay"><a href="#performSelector-withObject-afterDelay" class="headerlink" title="performSelector:withObject:afterDelay:"></a>performSelector:withObject:afterDelay:</h3><p>源码实现:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">- (void)performSelector: (<span class="keyword">SEL)aSelector</span></span><br><span class="line"><span class="keyword">	</span>      withObject: (id)argument</span><br><span class="line"><span class="symbol">	      afterDelay:</span> (NSTimeInterval)seconds &#123;</span><br><span class="line">  NSRunLoop		*loop = [NSRunLoop currentRunLoop]<span class="comment">;</span></span><br><span class="line">  GSTimedPerformer	*<span class="keyword">item;</span></span><br><span class="line"><span class="keyword"> </span> // <span class="keyword">item引用计数+1</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">item </span>= [[GSTimedPerformer alloc] initWithSelector: aSelector</span><br><span class="line"><span class="symbol">					     target:</span> <span class="keyword">self</span></span><br><span class="line"><span class="keyword">	</span>				   argument: argument</span><br><span class="line"><span class="symbol">					      delay:</span> seconds]<span class="comment">;</span></span><br><span class="line">	// 持有<span class="keyword">item</span></span><br><span class="line"><span class="keyword"> </span> [[loop _timedPerformers] <span class="keyword">addObject: </span><span class="keyword">item];</span></span><br><span class="line"><span class="keyword"> </span> // <span class="keyword">item引用计数-1</span></span><br><span class="line"><span class="keyword"> </span> RELEASE(<span class="keyword">item);</span></span><br><span class="line"><span class="keyword"> </span> // 持有timer</span><br><span class="line">  [loop <span class="keyword">addTimer: </span><span class="keyword">item-&gt;timer </span>forMode: NSDefaultRunLoopMode]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要做了这些事:</p>
<ol>
<li>获取当前线程的Runloop对象。</li>
<li>根据方法名、方法参数、方法调用者及延迟时间等信息创建一个GSTimedPerformer对象，把该对象添加到Runloop的_timedPerformers数组中保存。</li>
<li>把GSTimedPerformer中的定时器timer添加到Runloop中。</li>
</ol>
<p>如官方文档所说:This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode.</p>
<p>看看GSTimedPerformer做了什么:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GSTimedPerformer</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">  SEL		selector;</span><br><span class="line">  <span class="keyword">id</span>		target;</span><br><span class="line">  <span class="keyword">id</span>		argument;</span><br><span class="line">  <span class="built_in">NSTimer</span>	*timer;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)fire;</span><br><span class="line">- (<span class="keyword">id</span>)initWithSelector: (SEL)aSelector</span><br><span class="line">		 target: (<span class="keyword">id</span>)target</span><br><span class="line">	       argument: (<span class="keyword">id</span>)argument</span><br><span class="line">		  delay: (<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line">- (<span class="keyword">void</span>)invalidate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GSTimedPerformer</span></span></span><br><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">  [<span class="keyword">self</span> finalize];</span><br><span class="line">  TEST_RELEASE(timer);</span><br><span class="line">  <span class="comment">// 释放target对象</span></span><br><span class="line">  RELEASE(target);</span><br><span class="line">  RELEASE(argument);</span><br><span class="line">  [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) finalize &#123;</span><br><span class="line">  [<span class="keyword">self</span> invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) fire &#123;</span><br><span class="line">   DESTROY(timer);</span><br><span class="line">   [target performSelector: selector withObject: argument];</span><br><span class="line">   [[[<span class="built_in">NSRunLoop</span> currentRunLoop] _timedPerformers]</span><br><span class="line">    removeObjectIdenticalTo: <span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithSelector:(SEL)aSelector</span><br><span class="line">                target:(<span class="keyword">id</span>)aTarget</span><br><span class="line">              argument:(<span class="keyword">id</span>)anArgument</span><br><span class="line">                 delay:(<span class="built_in">NSTimeInterval</span>)delay &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        selector = aSelector;</span><br><span class="line">        <span class="comment">// 持有target</span></span><br><span class="line">        target = RETAIN(aTarget);</span><br><span class="line">        argument = RETAIN(anArgument);</span><br><span class="line">        timer = [[<span class="built_in">NSTimer</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()]</span><br><span class="line">                 initWithFireDate: <span class="literal">nil</span></span><br><span class="line">                 interval: delay</span><br><span class="line">                 target: <span class="keyword">self</span></span><br><span class="line">                 selector: <span class="keyword">@selector</span>(fire)</span><br><span class="line">                 userInfo: <span class="literal">nil</span></span><br><span class="line">                 repeats: <span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">        DESTROY(timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>The GSTimedPerformer class is used to hold information about messages which are due to be sent to objects at a particular time.</p>
<p>由此可见，<code>GSTimedPerformer</code>作用就是保存关于消息的信息，具体方法的延迟和调用主要还是依靠其内部的定时器。<br>综上，Runloop的<code>_timedPerformers</code>数组持有了<code>GSTimedPerformer</code>，Runloop还持有<code>GSTimedPerformer</code>内部的定时器<code>timer</code>。<code>GSTimedPerformer</code>持有了<code>target(self)</code>。<code>GSTimedPerformer</code>销毁的时候释放掉<code>target(self)</code>。<code>GSTimedPerformer</code>什么时候销毁? Runloop运行在<code>NSDefaultRunLoopMode</code>模式下并顺利调用该方法。也即，<code>GSTimedPerformer</code>在定时器时间截止时调用<code>fire</code>方法，之后<code>GSTimedPerformer</code>不再持有timer，接着Runloop不再持有<code>GSTimedPerformer</code>，于是<code>GSTimedPerformer</code>销毁，它对target的强引用也不复存在。</p>
<p>如图:</p>
<p><img src="https://image.chenyalun.com/2018/09/30/001.png" alt></p>
<p>这也是网上许多文章所称的”Runloop强持有target对象(self)”。</p>
<p>当延迟方法因种种原因没有执行就可能出现内存泄露，网上有一篇文章是这样描述的:</p>
<blockquote>
<p>performSelector关于内存管理的执行原理是这样的执行 [self performSelector:@selector(method1:) withObject:self afterDelay:3]; 的时候，系统会将self的引用计数加1，执行完这个方法时，还会将self的引用计数减1，当方法还没有执行的时候，要返回父视图释放当前视图的时候，self的计数没有减少到0，而导致无法调用dealloc方法，出现了内存泄露。 </p>
</blockquote>
<p>最简单的例子: 从A控制器push到B控制器，B控制器此时执行一个方法:<code>[self performSelector:@selector(printInfo) withObject:nil afterDelay:100];</code>。此时从B控制器pop到A控制器，很明显B控制器并没有销毁，因为Runloop还强引用着它，可以理解为出现了内存泄露(尽管100s后<code>printInfo</code>方法得到执行，B控制器会销毁)。</p>
<p>比较好的做法是取消掉之前的延迟调用:<code>cancelPreviousPerformRequestsWithTarget: selector:object:</code>，那么<code>cancelPreviousPerformRequestsWithTarget: selector:object:</code>做了什么呢?</p>
<h3 id="cancelPreviousPerformRequestsWithTarget-selector-object"><a href="#cancelPreviousPerformRequestsWithTarget-selector-object" class="headerlink" title="cancelPreviousPerformRequestsWithTarget: selector:object:"></a>cancelPreviousPerformRequestsWithTarget: selector:object:</h3><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">NSObject</span> cancelPreviousPerformRequestsWithTarget:self]<span class="comment">;</span></span><br><span class="line">[<span class="name">NSObject</span> cancelPreviousPerformRequestsWithTarget:self selector:NSSelectorFromString(<span class="name">@</span><span class="string">"printString:"</span>) object:@<span class="string">"str"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这两个方法可以取消perform延迟调用，它们内部做了什么？</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)target</span><br><span class="line"><span class="symbol">                                        selector:</span>(SEL)aSelector</span><br><span class="line"><span class="symbol">                                          object:</span>(id)arg &#123;</span><br><span class="line">  </span><br><span class="line">    NSMutableArray *perf = [[NSRunLoop currentRunLoop] _timedPerformers]<span class="comment">;</span></span><br><span class="line">    unsigned	<span class="built_in">count</span> = [perf <span class="built_in">count</span>]<span class="comment">;</span></span><br><span class="line">    if (<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      GSTimedPerformer	*array[<span class="built_in">count</span>]<span class="comment">;</span></span><br><span class="line">      IF_NO_GC(RETAIN(target))<span class="comment">;</span></span><br><span class="line">      IF_NO_GC(RETAIN(arg))<span class="comment">;</span></span><br><span class="line">      [perf getObjects: array]<span class="comment">;</span></span><br><span class="line">        while (<span class="built_in">count</span>-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            GSTimedPerformer	*p = array[<span class="built_in">count</span>]<span class="comment">;</span></span><br><span class="line">            if (p-&gt;target == target &amp;&amp; sel_isEqual(p-&gt;selector, aSelector)</span><br><span class="line">                &amp;&amp; (p-&gt;argument == arg <span class="title">||</span> [p-&gt;argument isEqual: arg])) &#123;</span><br><span class="line">                [p invalidate]<span class="comment">;</span></span><br><span class="line">                [perf removeObjectAtIndex: <span class="built_in">count</span>]<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(arg)<span class="comment">;</span></span><br><span class="line">        RELEASE(target)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获取Runloop内部持有的_timedPerformers数组(数组中的是GSTimedPerformer对象)。</li>
<li>创建一个C语言数组，并把_timedPerformers数组中的内容copy到这个C语言数组array。</li>
<li>遍历该C语言数组array: 如果给定参数中的target、argument、selector均一一对应，那么销毁GSTimedPerformer对象中的定时器，并根据当前的索引移除_timedPerformers数组的GSTimedPerformer对象。</li>
</ol>
<p>换句话说，如果target、argument、selector中有一个参数没有对应，那么便不会执行销毁定时器操作和移除操作。那么，判定target、argument、selector均一一对应的标准是:Matching of the argument may be either by pointer equality or by use of the [NSObject-isEqual:] method.就是指针和isEqual方法。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(p-&gt;</span>target == target </span><br><span class="line">&amp;&amp; <span class="function"><span class="title">sel_isEqual</span>(p-&gt;</span>selector, aSelector)</span><br><span class="line">&amp;&amp; (<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">argument</span> == arg || [p-&gt;</span>argument isEqual: arg])) </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里的<code>sel_isEqual</code>就等价于<code>==</code>，这样的话如果我们自己需要预先判断参数是否一一对应不妨就按照它这么写。</p>
<p>同理，<code>+ (void)cancelPreviousPerformRequestsWithTarget:(id)target</code>方法执行原理与上面的方法类似，只是不用比较参数，把所有定时器都销毁，并把所有GSTimedPerformer对象都从_timedPerformers数组中移除。</p>
<p>如上文所述:</p>
<blockquote>
<p>GSTimedPerformer在定时器时间截止时调用<code>fire</code>方法，之后GSTimedPerformer不再持有timer，接着Runloop不再持有GSTimedPerformer，于是GSTimedPerformer销毁，它对target的强引用也不复存在。</p>
</blockquote>
<p>当手动销毁定时器并把GSTimedPerformer从Runloop从移除时，GSTimedPerformer销毁，GSTimedPerformer对target的强引用不存在，这样，内存泄露问题解决了。这也是为什么使用<code>cancelPreviousPerformRequestsWithTarget</code>取消还没有执行的perform就可以解决<code>target</code>无法释放掉的原因。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="performSelector-onThread-withObject-waitUntilDone-modes"><a href="#performSelector-onThread-withObject-waitUntilDone-modes" class="headerlink" title="performSelector:onThread:withObject:waitUntilDone:modes:"></a>performSelector:onThread:withObject:waitUntilDone:modes:</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br></pre></td></tr></table></figure>
<p>要求perform在指定的线程执行。具体的实现如下所示:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector</span><br><span class="line">               onThread:(<span class="built_in">NSThread</span>*)aThread</span><br><span class="line">             withObject:(<span class="keyword">id</span>)anObject</span><br><span class="line">          waitUntilDone:(<span class="built_in">BOOL</span>)aFlag</span><br><span class="line">                  modes:(<span class="built_in">NSArray</span>*)anArray &#123;</span><br><span class="line">  </span><br><span class="line">    GSRunLoopThreadInfo  *info;</span><br><span class="line">    <span class="built_in">NSThread</span> *t;</span><br><span class="line">    <span class="keyword">if</span> ([anArray count] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    t = GSCurrentThread();</span><br><span class="line">    <span class="keyword">if</span> (aThread == <span class="literal">nil</span>) aThread = t;</span><br><span class="line">    info = GSRunLoopInfoForThread(aThread);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t == aThread) &#123;</span><br><span class="line">        <span class="comment">// Perform in current thread.</span></span><br><span class="line">        <span class="keyword">if</span> (aFlag == <span class="literal">YES</span> || info-&gt;loop == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">// Wait until done or no run loop.</span></span><br><span class="line">            [<span class="keyword">self</span> performSelector: aSelector withObject: anObject];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Don't wait ... schedule operation in run loop.</span></span><br><span class="line">            [info-&gt;loop performSelector: aSelector</span><br><span class="line">                                 target: <span class="keyword">self</span></span><br><span class="line">                               argument: anObject</span><br><span class="line">                                  order: <span class="number">0</span></span><br><span class="line">                                  modes: anArray];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GSPerformHolder   *h;</span><br><span class="line">        <span class="built_in">NSConditionLock</span>	*l = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 线程Finished判断</span></span><br><span class="line">        <span class="keyword">if</span> ([aThread isFinished] == <span class="literal">YES</span>) &#123;</span><br><span class="line">            [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                      format: <span class="string">@"perform on finished thread"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 阻塞等待加锁</span></span><br><span class="line">        <span class="keyword">if</span> (aFlag == <span class="literal">YES</span>) &#123;</span><br><span class="line">            l = [[<span class="built_in">NSConditionLock</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h = [GSPerformHolder newForReceiver:<span class="keyword">self</span></span><br><span class="line">				                   argument:anObject</span><br><span class="line">				                   selector:aSelector</span><br><span class="line">                                      modes:anArray</span><br><span class="line">				                       lock:l];</span><br><span class="line">        [info addPerformer: h];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 条件锁创建成功(也即参数aFlag为YES)</span></span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">nil</span>) &#123;</span><br><span class="line">            [l lockWhenCondition: <span class="number">1</span>]; <span class="comment">// 当条件为1时加锁</span></span><br><span class="line">            [l unlock];</span><br><span class="line">            RELEASE(l);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// holder已经失效则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> ([h isInvalidated] == <span class="literal">YES</span>) &#123;</span><br><span class="line">                RELEASE(h);</span><br><span class="line">                [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                          format: <span class="string">@"perform on finished thread"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// holder自身就产生exception了, 那么再次抛出异常</span></span><br><span class="line">            <span class="comment">// If we have an exception passed back from the remote thread, re-raise it.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nil</span> != h-&gt;exception) &#123;</span><br><span class="line">              <span class="built_in">NSException</span>       *e = AUTORELEASE(RETAIN(h-&gt;exception));</span><br><span class="line">              RELEASE(h);</span><br><span class="line">              [e raise];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      RELEASE(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要做了这些什么?</p>
<ol>
<li>首先对传进来的modes(Runloop模式数组)个数进行判断，如果为0，则直接return。</li>
<li>获取该方法执行上下文中的线程: <code>t</code>，并把它与作为参数传进来的线程<code>aThread</code>进行比较，看是否一致。当然，如果传进来的<code>aThread</code>为空，那么执行<code>aThread = t;</code>，简单粗暴地假定传进来的线程和上下文中的线程一致。</li>
<li>当两个线程一致时，如果参数<code>aFlag</code>为YES或者线程对应的Runloop为空，说明需要等待，也即这个方法应该等到selector被执行完毕后再return。这就好办了，直接调用<code>[self performSelector: aSelector withObject: anObject];</code>方法，同步执行即可。如果不需要等待呢? 把<code>selector</code>、<code>argument</code>、<code>modes</code>等信息交给线程对应的Runloop再进一步处理。</li>
<li>当两个线程不一致时，首先判断<code>aThread</code>有没有finished，线程死了自然selector无法执行，抛出异常。再者判断是否需要阻塞等待，如果需要的话就创建一个条件锁。接着把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个GSPerformHolder对象，并把它交给封装线程信息的GSRunLoopThreadInfo对象。之后是一些收尾工作:设置条件锁的condition及以下异常判断。</li>
</ol>
<p>需要着重说明的是参数<code>aFlag</code>: 是否立即返回。如果参数<code>aFlag</code>为YES，则这个方法应该等到selector被执行完毕后再return。那么就有一个问题，这个方法本身并不会触发<code>aThread</code>对应的Runloop运行，换句话说，如果<code>aThread</code>对应的Runloop一直不运行那么这个方法也一直不会return，咦，如果<code>aThread</code>和当前线程一致，Runloop要是一直没运行，那整个程序不就锁在这段代码了吗。</p>
<p>所以，针对这个特殊情况:参数<code>aFlag</code>为YES且<code>aThread</code>和当前线程一致，那<code>modes</code>将会被忽略，这个selector会立刻执行(因此上面的方法实现中直接调用<code>performSelector:withObject</code>而不是走到条件锁那段代码)。这就巧妙地避免了由于当前线程的Runloop没运行而线程被一个永远无法执行的<code>perform</code>阻塞的问题。</p>
<h4 id="两个线程一致时"><a href="#两个线程一致时" class="headerlink" title="两个线程一致时"></a>两个线程一致时</h4><p>问题一: 两个线程一致时，”把<code>selector</code>、<code>argument</code>、<code>modes</code>等信息交给线程对应的Runloop再进一步处理。”，具体怎么做的呢?</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(SEL)</span>aSelector</span><br><span class="line">		            target:<span class="params">(id)</span>target</span><br><span class="line">		          argument:<span class="params">(id)</span>argument</span><br><span class="line">		           order:<span class="params">(NSUInteger)</span>order</span><br><span class="line">                   modes:<span class="params">(NSArray*)</span>modes;</span><br></pre></td></tr></table></figure>
<p>Sets up sending of aSelector to target with argument. The selector is sent before the next runloop iteration (unless cancelled before then) in any of the specified modes.The target and argument objects are retained.<br>The order value is used to determine the order in which messages are sent if multiple messages have been set up. Messages with a lower order value are sent first.If the modes array is empty, this method has no effect.<br>说的很明白了，就是在指定模式的Runloop下一次迭代之前把selector、argument等信息丢给target，以便调用。这里的<code>order</code>指定了这个调用的优先级。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector</span><br><span class="line">		          target:(<span class="keyword">id</span>)target</span><br><span class="line">		        argument:(<span class="keyword">id</span>)argument</span><br><span class="line">		           order:(<span class="built_in">NSUInteger</span>)order</span><br><span class="line">                   modes:(<span class="built_in">NSArray</span>*)modes &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">unsigned</span>		count = [modes count];</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span>			*array[count];</span><br><span class="line">        GSRunLoopPerformer	*item;</span><br><span class="line">        item = [[GSRunLoopPerformer alloc] initWithSelector:aSelector</span><br><span class="line">                                                     target: target</span><br><span class="line">                                                   argument: argument</span><br><span class="line">                                                      order: order];</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 把modes中的内容copy到array</span></span><br><span class="line">        <span class="keyword">if</span> ([modes isProxy]) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                array[i] = [modes objectAtIndex: i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [modes getObjects: array];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span>	*mode = array[count];</span><br><span class="line">            <span class="keyword">unsigned</span>	end;</span><br><span class="line">            <span class="keyword">unsigned</span>	i;</span><br><span class="line">            GSRunLoopCtxt	*context;</span><br><span class="line">            GSIArray	performers;</span><br><span class="line"></span><br><span class="line">            context = <span class="built_in">NSMapGet</span>(_contextMap, mode);</span><br><span class="line">            <span class="keyword">if</span> (context == <span class="literal">nil</span>) &#123;</span><br><span class="line">                context = [[GSRunLoopCtxt alloc] initWithMode: mode extra: _extra];</span><br><span class="line">                <span class="built_in">NSMapInsert</span>(_contextMap, context-&gt;mode, context);</span><br><span class="line">                RELEASE(context);</span><br><span class="line">            &#125;</span><br><span class="line">	 </span><br><span class="line">            performers = context-&gt;performers;</span><br><span class="line">            end = GSIArrayCount(performers);</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; end; i++) &#123;</span><br><span class="line">                GSRunLoopPerformer	*p;</span><br><span class="line">                p = GSIArrayItemAtIndex(performers, i).obj;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;order &gt; order) &#123;</span><br><span class="line">                    GSIArrayInsertItem(performers, (GSIArrayItem)((<span class="keyword">id</span>)item), i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                GSIArrayInsertItem(performers, (GSIArrayItem)((<span class="keyword">id</span>)item), i);</span><br><span class="line">            &#125;</span><br><span class="line">	  </span><br><span class="line">            i = GSIArrayCount(performers);</span><br><span class="line">	  </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span> &amp;&amp; i &gt; context-&gt;maxPerformers) &#123;</span><br><span class="line">                context-&gt;maxPerformers = i;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"WARNING ... there are %u performers scheduled"</span></span><br><span class="line">                <span class="string">@" in mode %@ of %@\n(Latest: [%@ %@])"</span>,</span><br><span class="line">                i, mode, <span class="keyword">self</span>, <span class="built_in">NSStringFromClass</span>([target <span class="keyword">class</span>]),</span><br><span class="line">                <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据方法实现来看，这个方法做了这些事:</p>
<ol>
<li>如果数组modes中没有内容就直接return。</li>
<li>把<code>target</code>、<code>argument</code>、<code>selector</code>、<code>order</code>等信息包装成一个对象GSRunLoopPerformer。</li>
<li>创建一个字符串数组array，把modes中的内容copy到array。</li>
<li>遍历array。根据array中的模式mode(NSString类型)找到_contextMap(NSMapTable类型)表中对应的context(GSRunLoopCtxt类型)，获得context中需要执行的performers(GSIArray类型)。</li>
<li>把第2步中包装好的GSRunLoopPerformer对象放到performers中。遍历performers，根据order确定优先级，调整performers中的索引。</li>
</ol>
<p>总而言之，就是把<code>target</code>、<code>argument</code>、<code>selector</code>、<code>order</code>等信息包装成一个GSRunLoopPerformer对象，并把该对象交给Runloop(中的_contextMap中的performers)，供其在合适的时机调用。具体啥时候调用呢?官方文档说是Runloop的下一次迭代的时候。</p>
<h4 id="两个线程不一致时"><a href="#两个线程不一致时" class="headerlink" title="两个线程不一致时"></a>两个线程不一致时</h4><p>问题二: 两个线程不一致时，”把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个GSPerformHolder对象，并把它交给封装线程信息的GSRunLoopThreadInfo对象”又是怎么做的呢?</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(GSPerformHolder</span> <span class="string">*)h</span> <span class="string">=</span> <span class="string">[GSPerformHolder</span> <span class="attr">newForReceiver:self</span></span><br><span class="line">		                   <span class="attr">argument:anObject</span></span><br><span class="line">		                   <span class="attr">selector:aSelector</span></span><br><span class="line"><span class="attr">                            modes:</span><span class="string">anArray</span></span><br><span class="line">		                       <span class="attr">lock:l];</span></span><br><span class="line"><span class="string">[(GSRunLoopThreadInfo</span> <span class="string">*)info</span> <span class="attr">addPerformer:</span> <span class="string">h];</span></span><br></pre></td></tr></table></figure>
<p><code>newForReceiver:argument:selector:modes:lock:</code> 这个方法就是做一些信息封装，无需多言。主要是这个<code>addPerformer</code>，删除<code>#if defined(_WIN32)</code>的代码后具体实现如下:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addPerformer:(<span class="keyword">id</span>)performer &#123;</span><br><span class="line">    <span class="built_in">BOOL</span>  signalled = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">// NSLock加锁</span></span><br><span class="line">    [lock lock];</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> start = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 使用write函数向 outputFd 中写入 1 字节数据，数据为: "0"。</span></span><br><span class="line">    <span class="keyword">while</span> (outputFd &gt;= <span class="number">0</span> &amp;&amp; <span class="literal">NO</span> == (signalled = (write(outputFd, <span class="string">"0"</span>, <span class="number">1</span>) == <span class="number">1</span>) ? <span class="literal">YES</span> : <span class="literal">NO</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSTimeInterval</span>    now = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0.0</span> == start) &#123;</span><br><span class="line">            start = now;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now - start &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Unable to signal %@ within a second; blocked?"</span>, <span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock];</span><br><span class="line">        [lock lock];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据成功，把performer添加到GSRunLoopThreadInfo数组中</span></span><br><span class="line">    <span class="keyword">if</span> (signalled) [performers addObject: performer];</span><br><span class="line">    <span class="comment">// NSLock解锁</span></span><br><span class="line">    [lock unlock];</span><br><span class="line">    <span class="comment">// 写入数据失败，销毁performer</span></span><br><span class="line">    <span class="keyword">if</span> (!signalled) [performer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充write函数知识点:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * <span class="built_in">write</span>函数</span><br><span class="line"> * ssize_t  <span class="built_in">write</span>(int __fd, const void * __buf, size_t __nbyte) __DARWIN_ALIAS_C(<span class="built_in">write</span>);</span><br><span class="line"> * <span class="built_in">write</span> 函数向 __fd 中写入 __nbyte 字节数据，数据来源为 __buf 。返回值一般总是等于 __nbyte</span><br><span class="line"> * 返回值如果不是等于__nbyte，就是出错了。常见的出错原因是磁盘空间满了或者超过了文件大小限制。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* The <span class="built_in">write</span> could concievably fail <span class="keyword">if</span> <span class="keyword">the</span> pipe <span class="keyword">is</span> full.</span><br><span class="line"> * In <span class="keyword">that</span> case we need <span class="keyword">to</span> release <span class="keyword">the</span> lock temporarily <span class="keyword">to</span> allow <span class="keyword">the</span> other</span><br><span class="line"> * thread <span class="keyword">to</span> consume data <span class="keyword">from</span> <span class="keyword">the</span> pipe.  It's possible <span class="keyword">that</span> <span class="keyword">the</span> thread</span><br><span class="line"> * <span class="keyword">and</span> <span class="keyword">its</span> runloop might stop during <span class="keyword">that</span> ... so we need <span class="keyword">to</span> check <span class="keyword">that</span></span><br><span class="line"> * outputFd <span class="keyword">is</span> still valid.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>不是十分理解write函数在这里的作用，根据一些异常信息<code>&quot;Failed to set non block flag for perform in thread&quot; &quot;Failed to create event to handle perform in thread&quot;</code>，可能是向文件中写入一些flag表示线程指定事件对象的信号状态吧。</p>
<p>如果信号状态设置成功，就把这个perform对象(GSPerformHolder类型)添加到GSRunLoopThreadInfo的performers数组中。</p>
<p>这个GSRunLoopThreadInfo对象把GSPerformHolder对象添加到自己数组中后，具体最原先的perform什么时候执行呢? 是在调用GSRunLoopThreadInfo对象的fire方法时逐个执行:</p>
<p>GSRunLoopThreadInfo对象的<code>fire</code>方法部分实现:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">for</span> <span class="string">(i</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span> <span class="string">i</span> <span class="string">&lt;</span> <span class="string">c;</span> <span class="string">i++)</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line">    <span class="string">GSPerformHolder</span>	<span class="meta">*h</span> <span class="string">=</span> <span class="string">[toDo</span> <span class="attr">objectAtIndex:</span> <span class="string">i];</span></span><br><span class="line"></span><br><span class="line">    <span class="string">[loop</span> <span class="attr">performSelector:</span> <span class="string">@selector(fire)</span></span><br><span class="line"><span class="attr">     target:</span> <span class="string">h</span></span><br><span class="line"><span class="attr">   argument:</span> <span class="string">nil</span></span><br><span class="line"><span class="attr">      order:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      modes:</span> <span class="string">[h</span> <span class="string">modes]];</span></span><br><span class="line">  <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可见是逐个取出数组中的<code>GSPerformHolder</code>对象，一个接一个地调用<code>GSPerformHolder</code>的<code>fire</code>方法，这也是个<code>fire</code>方法，它内部做了什么?就是<code>[receiver performSelector: selector withObject: argument];</code>。</p>
<p>捋一捋: 两个线程不一致时，把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个<code>GSPerformHolder</code>对象，并把它添加到<code>GSRunLoopThreadInfo</code>对象的performers数组中。当调用<code>GSRunLoopThreadInfo</code>对象的<code>fair</code>方法时会遍历performers数组，然后逐个调用数组中每一个元素的<code>fair</code>方法，而这个<code>fair</code>方法内部就是调用<code>performSelector:withObject</code>方法。</p>
<p>最最关键的一个问题: 什么时候调用<code>GSRunLoopThreadInfo</code>对象的<code>fair</code>方法? 官方文档说: May only be called from the runloop when the event/descriptor is triggered.<br>我在Runloop的<code>+(BOOL)awakenedBefore:</code>和 <code>-(BOOL)pollUntil:within:</code>方法中找到了调用痕迹。</p>
<h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">(void)</span> <span class="attr">performSelector:(SEL)aSelector</span></span><br><span class="line"><span class="attr">                onThread:</span><span class="string">(NSThread*)aThread</span></span><br><span class="line"><span class="attr">              withObject:</span><span class="string">(id)anObject</span></span><br><span class="line"><span class="attr">           waitUntilDone:</span><span class="string">(BOOL)aFlag</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">[self</span> <span class="attr">performSelector:aSelector</span></span><br><span class="line"><span class="attr">               onThread:</span><span class="string">aThread</span></span><br><span class="line"><span class="attr">             withObject:</span><span class="string">anObject</span></span><br><span class="line"><span class="attr">          waitUntilDone:</span><span class="string">aFlag</span></span><br><span class="line"><span class="attr">                  modes:</span><span class="string">commonModes()];</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Runloop的五种mode分别是:<code>NSDefaultRunLoopMode，NSConnectionReplyMode，NSModalPanelRunLoopMode，NSEventTrackingRunLoopMode，NSRunLoopCommonModes</code>。<br>这个方法省略了modes参数，内部使用common mode，也即<code>NSDefaultRunLoopMode</code>和<code>NSConnectionReplyMode</code>(不是<code>NSEventTrackingRunLoopMode</code>)。所以如果有鼠标或者手势事件需要处理，省略modes参数可能不是个好做法。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">(void)</span> <span class="attr">performSelectorOnMainThread:(SEL)aSelector</span></span><br><span class="line">			  <span class="attr">withObject:(id)anObject</span></span><br><span class="line">		       <span class="attr">waitUntilDone:(BOOL)aFlag</span></span><br><span class="line">			       <span class="attr">modes:(NSArray*)anArray</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">if</span> <span class="string">(defaultThread</span> <span class="string">==</span> <span class="string">nil)</span> <span class="string">[NSThread</span> <span class="string">mainThread];</span></span><br><span class="line">  <span class="string">[self</span> <span class="attr">performSelector:aSelector</span></span><br><span class="line"><span class="attr">               onThread:</span><span class="string">defaultThread</span></span><br><span class="line"><span class="attr">             withObject:</span><span class="string">anObject</span></span><br><span class="line"><span class="attr">          waitUntilDone:</span><span class="string">aFlag</span></span><br><span class="line"><span class="attr">                  modes:</span><span class="string">anArray];</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">(void)performSelectorOnMainThread:(SEL)aSelector</span></span><br><span class="line">			  <span class="attr">withObject:(id)anObject</span></span><br><span class="line">		       <span class="attr">waitUntilDone:(BOOL)aFlag</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">[self</span> <span class="attr">performSelectorOnMainThread:aSelector</span></span><br><span class="line">			 <span class="attr">withObject:anObject</span></span><br><span class="line">		      <span class="attr">waitUntilDone:aFlag</span></span><br><span class="line">			      <span class="attr">modes:commonModes()];</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这两个方法指定了主线程。一: 如果参数aFlag是YES且方法调用的当前线程就是主线程，那么modes参数会被忽略。与上文所说的”参数<code>aFlag</code>为YES且<code>aThread</code>和当前线程一致，那<code>modes</code>将会被忽略，这个selector会立刻执行”一致。</p>
<p>后台执行:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">(void)</span> <span class="attr">performSelectorInBackground:(SEL)aSelector</span></span><br><span class="line"><span class="attr">                          withObject:</span><span class="string">(id)anObject</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">[NSThread</span> <span class="attr">detachNewThreadSelector:aSelector</span></span><br><span class="line"><span class="attr">                           toTarget:</span><span class="string">self</span></span><br><span class="line"><span class="attr">                         withObject:</span><span class="string">anObject];</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>就是随意创建一个线程执行selector方法。</p>
<h2 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h2><h3 id="printInfo方法会执行吗"><a href="#printInfo方法会执行吗" class="headerlink" title="printInfo方法会执行吗"></a>printInfo方法会执行吗</h3><h4 id="GCD调用"><a href="#GCD调用" class="headerlink" title="GCD调用"></a>GCD调用</h4><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">     [self performSelector:@selector(<span class="name">printInfo</span>) withObject<span class="symbol">:nil</span> afterDelay:<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>很明显是不会的。因为performSelector具体实现中并没有主动触发线程对应Runloop运行。子线程对应的Runloop没有run。怎么让它执行?启动Runloop:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [self performSelector:@selector(<span class="name">printInfo</span>) withObject<span class="symbol">:nil</span> afterDelay:<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    [[NSRunLoop currentRunLoop] run]<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="NSThread调用"><a href="#NSThread调用" class="headerlink" title="NSThread调用"></a>NSThread调用</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] <span class="string">initWithBlock:</span>^&#123;</span><br><span class="line">    [self <span class="string">performSelector:</span><span class="meta">@selector</span>(printInfo) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">1</span>];</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<p>同理:</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">NSThread *thread = <span class="comment">[<span class="comment">[NSThread alloc]</span> initWithBlock:^&#123;</span></span><br><span class="line"><span class="comment">    <span class="comment">[self performSelector:@selector(printInfo) withObject:nil afterDelay:1]</span>;</span></span><br><span class="line"><span class="comment">    <span class="comment">[<span class="comment">[NSRunLoop currentRunLoop]</span> run]</span>;</span></span><br><span class="line"><span class="comment">&#125;]</span>;</span><br><span class="line"><span class="comment">[thread start]</span>;</span><br></pre></td></tr></table></figure>
<p>这就有一个问题了。在GCD中<code>[[NSRunLoop currentRunLoop] run];</code>放在<code>performSelector</code>前面或者后面貌似都是可以的，但是在NSThread中<code>[[NSRunLoop currentRunLoop] run];</code>只能放在<code>performSelector</code>的后面。</p>
<p>在NSThread方法中:</p>
<blockquote>
<p>因为run方法只是尝试想要开启当前线程中的runloop，但是如果该线程中并没有任何事件(source、timer、observer)的话，并不会成功的开启。</p>
</blockquote>
<p>为什么GCD中即使<code>[[NSRunLoop currentRunLoop] run];</code>放在前面<code>printInfo</code>方法还是调用了呢? 代码实际测试，延迟效果没有了，并且有时方法执行，有时方法没有执行。</p>
<p>综上，在子线程中使用performSelector的延迟方法是，需要加上<code>[[NSRunLoop currentRunLoop] run];</code>使得Runloop能够运行，并且该方法要放在<code>performSelector</code>的后面来保证正确成功地开启。</p>
<h4 id="NSThread无效"><a href="#NSThread无效" class="headerlink" title="NSThread无效"></a>NSThread无效</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">NSThread *thread = [[NSThread alloc] <span class="string">initWithBlock:</span>^&#123;&#125;];</span><br><span class="line">[thread start];</span><br><span class="line">[self <span class="string">performSelector:</span><span class="meta">@selector</span>(printMainInfo) <span class="string">onThread:</span>thread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br></pre></td></tr></table></figure>
<p>上面这段代码为什么没有执行printMainInfo方法?</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 执行一次而已</span></span><br><span class="line">    <span class="built_in">NSRunLoop</span> *currentRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [currentRunLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(printMainInfo) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<p>子线程执行完操作之后就会立即释放，即使我们使用强引用引用子线程使子线程不被释放，也不能给子线程再次添加操作，或者再次开启。这里可以使用Runloop。子线程获取其对应的Runloop对象并使之运行。一般使用常驻子线程。</p>
<hr>
<blockquote>
<p>参考资料<br><a href="https://zhongwuzw.github.io/2017/01/19/Objective-C之performSelector编译器内存泄露警告/" target="_blank" rel="noopener">https://zhongwuzw.github.io/2017/01/19/Objective-C之performSelector编译器内存泄露警告/</a><br> <a href="https://blog.csdn.net/dean19900504/article/details/8067679" target="_blank" rel="noopener">https://blog.csdn.net/dean19900504/article/details/8067679</a><br><a href="https://www.jianshu.com/p/4f5566125148" target="_blank" rel="noopener">https://www.jianshu.com/p/4f5566125148</a><br> <a href="https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown" target="_blank" rel="noopener">https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown</a><br> <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html</a><br> <a href="https://blog.csdn.net/wei371522/article/details/81216853" target="_blank" rel="noopener">https://blog.csdn.net/wei371522/article/details/81216853</a><br> <a href="https://blog.csdn.net/king16304/article/details/52192259" target="_blank" rel="noopener">https://blog.csdn.net/king16304/article/details/52192259</a></p>
</blockquote>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/iOS开发/">iOS开发</a>
            
              <a href="/tags/阅读/">阅读</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/12/20/读「YYModel」/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">读「YYModel」</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/07/10/Runtime基础/">
        <span class="next-text nav-default">Runtime基础</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
