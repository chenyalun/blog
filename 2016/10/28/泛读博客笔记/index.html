<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="泛读博客笔记"><meta name="keywords" content="iOS开发, C语言, 笔记, Ya"><link rel="alternate" href="/atom.xml" title="Ya"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="https://blog.chenyalun.com/2016/10/28/泛读博客笔记/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>泛读博客笔记 - Ya</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/archives/">
        <li class="mobile-menu-item">时间线
          </li>
      </a><a href="/tags/阅读/">
        <li class="mobile-menu-item">阅读
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            时间线
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            阅读
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">泛读博客笔记
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-10-28
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#读感"><span class="toc-text">读感</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#钩玄"><span class="toc-text">钩玄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-C语言中怎么控制输入与输出格式"><span class="toc-text">1.C语言中怎么控制输入与输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-getchar-scanf-gets的区别"><span class="toc-text">2.getchar/scanf/gets的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-puts-prints-putchar的区别"><span class="toc-text">3.puts/prints/putchar的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-介绍指针"><span class="toc-text">4.介绍指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见字符串处理函数的用法"><span class="toc-text">5.常见字符串处理函数的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-如何使一个函数有多个返回值"><span class="toc-text">6.如何使一个函数有多个返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-字符串常量与字符串变量"><span class="toc-text">7.字符串常量与字符串变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-返回指针的函数"><span class="toc-text">8.返回指针的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-指向函数的指针"><span class="toc-text">9.指向函数的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-将函数作为参数在函数间传递"><span class="toc-text">10.将函数作为参数在函数间传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-宏的使用"><span class="toc-text">11.宏的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-include中-lt-gt-与“”的区别"><span class="toc-text">12.include中&lt;&gt;与“”的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-如何避免-include重复包含同一个头文件"><span class="toc-text">13.如何避免#include重复包含同一个头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-变量的作用域"><span class="toc-text">14.变量的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-编译链接流程"><span class="toc-text">15.编译链接流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-extern与static关键字的作用"><span class="toc-text">16.extern与static关键字的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-如何定义结构体"><span class="toc-text">17.如何定义结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-结构体指针的使用"><span class="toc-text">18.结构体指针的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-typedef的主要使用"><span class="toc-text">19.typedef的主要使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-import与include的区别"><span class="toc-text">20.import与include的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-UIView显示的过程"><span class="toc-text">21.UIView显示的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-position与anchorPoint"><span class="toc-text">22.position与anchorPoint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Core-Animation会阻塞主线程吗"><span class="toc-text">23.Core Animation会阻塞主线程吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-空指针"><span class="toc-text">24.空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-不同编译器下各类型所占字节"><span class="toc-text">25.不同编译器下各类型所占字节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-self与super"><span class="toc-text">26.self与super</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-消息发送"><span class="toc-text">27.消息发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-通知"><span class="toc-text">28.通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-屏幕"><span class="toc-text">29.屏幕</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-程序启动"><span class="toc-text">30.程序启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-alloc方法"><span class="toc-text">31.alloc方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-init方法"><span class="toc-text">32.init方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-运行时"><span class="toc-text">33.运行时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-方法选择器"><span class="toc-text">34.方法选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-IMP"><span class="toc-text">35.IMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-消息调用流程"><span class="toc-text">36.消息调用流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-synthesize"><span class="toc-text">37.@synthesize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-消息转发"><span class="toc-text">38.消息转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-Cocoa"><span class="toc-text">39.Cocoa</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-Runloop"><span class="toc-text">40.Runloop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-创建NSTimer"><span class="toc-text">41.创建NSTimer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-响应者对象（Responder-Object）"><span class="toc-text">42.响应者对象（Responder Object）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-响应者链"><span class="toc-text">43.响应者链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-响应者链方法的处理流程"><span class="toc-text">44.响应者链方法的处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-类别与类扩展的区别："><span class="toc-text">45.类别与类扩展的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-KVC"><span class="toc-text">46.KVC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-内存管理规则"><span class="toc-text">47.内存管理规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-weak和assign的异同"><span class="toc-text">48.weak和assign的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-使用ARC需要遵守的新规则"><span class="toc-text">49.使用ARC需要遵守的新规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-instancetype"><span class="toc-text">50.instancetype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-沙盒目录："><span class="toc-text">51.沙盒目录：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-空"><span class="toc-text">52.空</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-NSNull"><span class="toc-text">53.NSNull</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-imageNamed"><span class="toc-text">54.imageNamed</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><blockquote>
<p>2017.04.03 修改<br>2016.12.04 修改<br>2019.08.15 完善</p>
</blockquote>
<p align="center"> C语言和Objective-C语言。 </p>

<a id="more"></a>
<h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>一口气把前辈博客里面的所有文章都读完了，文章质量都特别高，在此做个记录。</p>
<h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><h2 id="1-C语言中怎么控制输入与输出格式"><a href="#1-C语言中怎么控制输入与输出格式" class="headerlink" title="1.C语言中怎么控制输入与输出格式"></a>1.C语言中怎么控制输入与输出格式</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">printf</span>(<span class="string">"My height is %8.1f"</span>, <span class="number">179.95</span>f);<span class="regexp">//</span> 左对齐,小数点后<span class="number">1</span>位        </span><br><span class="line">   </span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"My height is %-4d"</span>, <span class="number">60</span>); <span class="regexp">//</span> 左对齐，右边填空格</span><br><span class="line">scanf(<span class="string">"%d-%d-%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">scanf(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">  </span><br><span class="line">// putchar一次只能输出一个字符，而<span class="keyword">printf</span>可以同时输出多个字符</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">65</span>;</span><br><span class="line">putchar(a);</span><br></pre></td></tr></table></figure>
<h2 id="2-getchar-scanf-gets的区别"><a href="#2-getchar-scanf-gets的区别" class="headerlink" title="2.getchar/scanf/gets的区别"></a>2.getchar/scanf/gets的区别</h2><ol>
<li><p>gets和getchar函数可以读入空格、TAB，直到遇到回车为止。scanf不能读入空格和TAB。</p>
</li>
<li><p>gets一次只能读取一个字符串，getchar一次只能读入一个字符。scanf则可以同时接收多个字符。</p>
</li>
<li><p>getchar还能读入回车换行符，这时候要敲2次回车键。第1次敲的回车换行符被getchar读入，第2次敲的回车键代表输入结束。</p>
</li>
</ol>
<h2 id="3-puts-prints-putchar的区别"><a href="#3-puts-prints-putchar的区别" class="headerlink" title="3.puts/prints/putchar的区别"></a>3.puts/prints/putchar的区别</h2><ol>
<li>putchar一次只能输出一个字符，puts函数一次只能输出一个字符串，printf函数则可以同时输出多个字符串。</li>
<li>printf与puts函数会首地址开始输出字符，一直到\0字符为止。</li>
</ol>
<h2 id="4-介绍指针"><a href="#4-介绍指针" class="headerlink" title="4.介绍指针"></a>4.介绍指针</h2><ol>
<li>计算机中的内存是以字节为单位的存储空间，内存的每一个字节都有一个唯一的编号，这个编号就称为地址。</li>
<li>凡存放在内存中的程序和数据都有一个地址，也就是说，一个函数也有自己的内存地址。变量存储单元的第一个字节的地址就是该变量的地址。</li>
<li><p>通过变量名引用变量，由系统自动完成变量名和其存储地址之间的转换，称为变量的“直接引用”方式。首先将变量a的地址存放在另一个变量中，比如存放在变量b中，然后通过变量b来间接引用变量a，间接读写变量a的值。这就是“间接引用”。</p>
</li>
<li><p>在指针变量没有指向确定地址之前，不要对它所指的内容赋值。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; *p = <span class="number">10</span>; <span class="comment">//这是错误的</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 也可以int *b = &amp;a;</span></span><br><span class="line"><span class="keyword">int</span> *b; <span class="comment">//b是指针变量</span></span><br><span class="line">b = &amp;a;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 通过*b间接修改a的值</span></span><br><span class="line">*b = <span class="number">15</span>; <span class="comment">// 根据b地址访问对应的存储值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针操作中，数组名a是个常量，不能进行赋值运算</p>
 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char s[<span class="number">10</span>]<span class="comment">;</span></span><br><span class="line"><span class="attribute">s</span> = <span class="string">"mj"</span><span class="comment">;// 错误! s是常量</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="5-常见字符串处理函数的用法"><a href="#5-常见字符串处理函数的用法" class="headerlink" title="5.常见字符串处理函数的用法"></a>5.常见字符串处理函数的用法</h2><p>包含string.h头文件后，strlen\strcpy\strcat\strcmp函数的用法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测量字符串的字符个数，不包括\0</span></span><br><span class="line"><span class="comment">// 长度为7</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="built_in">strlen</span>(<span class="string">"abcdefg"</span>);</span><br><span class="line"><span class="comment">// 长度为2</span></span><br><span class="line"><span class="keyword">char</span> s[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'\0'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 右边拷贝到左边,</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, <span class="string">"abcdefg"</span>);</span><br><span class="line"><span class="comment">// 遇到\0截断</span></span><br><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'\0'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(s,c);<span class="comment">// 结果ab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边拼接到左边,遇到\0截断</span></span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">30</span>] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'\0'</span>, <span class="string">'d'</span>&#125;;</span><br><span class="line"><span class="built_in">strcat</span>(s1, <span class="string">"OC"</span>);<span class="comment">// 结果abOC</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 左减右,逐字符比较ASCII码差值,直到字符不相同或者遇见'\0'为止</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2);</span><br></pre></td></tr></table></figure></p>
<p>注意:strcpy中若数组长度不足以容纳整个字符串，则程序运行崩溃。</p>
<h2 id="6-如何使一个函数有多个返回值"><a href="#6-如何使一个函数有多个返回值" class="headerlink" title="6.如何使一个函数有多个返回值"></a>6.如何使一个函数有多个返回值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b,<span class="keyword">int</span> *c)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 赋值给指针指向的变量</span></span><br><span class="line">  *c = a + b;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">2</span>,n = <span class="number">4</span>,s1,s2;</span><br><span class="line">  s1 =  test(m, n, &amp;s2);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d---%d"</span>,s1,s2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-字符串常量与字符串变量"><a href="#7-字符串常量与字符串变量" class="headerlink" title="7.字符串常量与字符串变量"></a>7.字符串常量与字符串变量</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *s = <span class="string">"mj"</span><span class="comment">;</span></span><br><span class="line">*s = <span class="string">"like"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>两个错误:</p>
<ol>
<li>s指向的是“mj”的首字符“m”，只有一个字节，要“like”存进1个字节的空间内，肯定内存溢出。</li>
<li>s指向的是字符串常量“mj”，不能再通过指针来修改字符串内容(字符数组可以修改)。</li>
</ol>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">a</span>[] = <span class="string">"lmj"</span>;<span class="comment"> // 定义的是一个字符串变量</span></span><br><span class="line"><span class="keyword">char</span> *p2 = <span class="string">"lmj"</span>;<span class="comment"> // 定义的是一个字符串常量</span></span><br></pre></td></tr></table></figure>
<h2 id="8-返回指针的函数"><a href="#8-返回指针的函数" class="headerlink" title="8.返回指针的函数"></a>8.返回指针的函数</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串str中的小写字母变成大写字母，并返回改变后的字符串</span></span><br><span class="line"><span class="comment">// 注意的是：这里的参数要传字符串变量，不能传字符串常量</span></span><br><span class="line"><span class="keyword">char</span> * upper(<span class="keyword">char</span> *<span class="keyword">str</span>) &#123;</span><br><span class="line">    <span class="comment">// 先保留最初的地址。因为等会str指向的位置会变来变去的。</span></span><br><span class="line">    <span class="keyword">char</span> *dest = <span class="keyword">str</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 如果还不是空字符</span></span><br><span class="line">    <span class="keyword">while</span> (*<span class="keyword">str</span> != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是小写字母</span></span><br><span class="line">        <span class="keyword">if</span> (*<span class="keyword">str</span> &gt;= <span class="string">'a'</span> &amp;&amp; *<span class="keyword">str</span> &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">            <span class="comment">// 变为大写字母。小写和大写字母的ASCII值有个固定的差值</span></span><br><span class="line">            *<span class="keyword">str</span> -= <span class="string">'a'</span> - <span class="string">'A'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">        <span class="comment">// 遍历下一个字符</span></span><br><span class="line">        <span class="keyword">str</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 返回字符串</span></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line"><span class="comment">// 调用:</span></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="comment">// 定义一个字符串变量</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">str</span>[] = <span class="string">"lmj"</span>;</span><br><span class="line">         </span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">char</span> *dest = upper(<span class="keyword">str</span>);</span><br><span class="line">         </span><br><span class="line">    printf(<span class="string">"%s"</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-指向函数的指针"><a href="#9-指向函数的指针" class="headerlink" title="9.指向函数的指针"></a>9.指向函数的指针</h2><p>函数名的本质就是函数的地址。<br>假定函数的名称为func，返回类型是整型。则，<code>int *a = func; // 指针a与指针func一致</code></p>
<p>调用的三种方式:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span>(); <span class="comment">// 原先的调用方式:通过指针func调用</span></span><br><span class="line">*<span class="selector-tag">a</span>();   <span class="comment">// *a指向函数本身</span></span><br><span class="line"><span class="selector-tag">a</span>();    <span class="comment">// 相当于func();</span></span><br></pre></td></tr></table></figure></p>
<p>实例:</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">sum</span>(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">// 定义一个指针变量p，指向<span class="built_in">sum</span>函数</span><br><span class="line">// 把函数名替换为(*p)即可,*p就相当于<span class="built_in">sum</span></span><br><span class="line"><span class="built_in">int</span> (*p)(<span class="built_in">int</span> a, <span class="built_in">int</span> b) = <span class="built_in">sum</span>;</span><br><span class="line">    // 或者 <span class="built_in">int</span> (*p)(<span class="built_in">int</span>, <span class="built_in">int</span>) = <span class="built_in">sum</span>;</span><br><span class="line">    // 或者 <span class="built_in">int</span> (*p)() = <span class="built_in">sum</span>;</span><br><span class="line">     </span><br><span class="line">    // *p就相当于<span class="built_in">sum</span></span><br><span class="line">    <span class="built_in">int</span> result = (*p)(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    // 或者</span><br><span class="line">    <span class="built_in">int</span> result = p(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">     </span><br><span class="line">    printf(<span class="string">"%d"</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-将函数作为参数在函数间传递"><a href="#10-将函数作为参数在函数间传递" class="headerlink" title="10.将函数作为参数在函数间传递"></a>10.将函数作为参数在函数间传递</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 减法运算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 加法运算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 这个counting函数是用来做a和b之间的计算，至于做加法还是减法运算，由函数的第1个参数决定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting</span>(<span class="params"><span class="keyword">int</span> (*p</span>)(<span class="params"><span class="keyword">int</span>, <span class="keyword">int</span></span>) , <span class="keyword">int</span> a, <span class="keyword">int</span> b) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = p(a, b);</span><br><span class="line">    printf(<span class="string">"计算结果为：%d\n"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 进行加法运算,传进来函数指针sum</span></span><br><span class="line">    counting(sum, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 进行减法运算</span></span><br><span class="line">    counting(minus, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-宏的使用"><a href="#11-宏的使用" class="headerlink" title="11.宏的使用"></a>11.宏的使用</h2><ol>
<li><p>所有预处理指令都以符号“#”开头，并且结尾不用分号，作用范围是从它出现的位置到文件尾，主要有：宏定义、文件包含、条件编译等。</p>
</li>
<li><p>使用带参数的宏定义，最好将参数和结果都用括号括起来。</p>
</li>
<li><p>宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题，宏替换只在<strong>编译预处理</strong>阶段进行，带参数的宏比函数具有更高的执行效率。</p>
</li>
<li><p>条件编译</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#if</span> 条件<span class="number">1</span></span><br><span class="line">..<span class="selector-class">.code1</span>...</span><br><span class="line"><span class="selector-id">#elif</span> 条件<span class="number">2</span></span><br><span class="line">..<span class="selector-class">.code2</span>...</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">..<span class="selector-class">.code3</span>...</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#if</span> defined(MAX)</span><br><span class="line"> ..<span class="selector-class">.code</span>...</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line"><span class="selector-id">#if</span> !defined(MAX)</span><br><span class="line"> ..<span class="selector-class">.code</span>...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="12-include中-lt-gt-与“”的区别"><a href="#12-include中-lt-gt-与“”的区别" class="headerlink" title="12.include中&lt;&gt;与“”的区别"></a>12.include中&lt;&gt;与“”的区别</h2><p><code>#include　&lt;文件名&gt;</code>到C语言库函数头文件所在的目录中寻找文件。<br><code>#include　&quot;文件名&quot;</code>系统会先在源程序当前目录下寻找，若找不到，再到操作系统的path路径中查找，最后才到C语言库函数头文件所在目录中查找。</p>
<h2 id="13-如何避免-include重复包含同一个头文件"><a href="#13-如何避免-include重复包含同一个头文件" class="headerlink" title="13.如何避免#include重复包含同一个头文件"></a>13.如何避免#include重复包含同一个头文件</h2><p>使用条件编译<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ONE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ONE_H_</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="14-变量的作用域"><a href="#14-变量的作用域" class="headerlink" title="14.变量的作用域"></a>14.变量的作用域</h2><ol>
<li><p>在函数内部定义的变量，称为局部变量。形式参数也属于局部变量，在所有函数外部定义的变量，称为全局变量。</p>
</li>
<li><p>所有的局部变量在默认情况下都是自动变量，是存储在堆栈中的。所有的全局变量和被关键字<code>static</code>修饰的局部变量都是静态变量，是存储在静态内存中的，也就是不属于堆栈。</p>
</li>
<li><p>静态变量在程序运行之前创建，在程序的整个运行期间始终存在，直到程序结束。在程序执行到声明自动变量的代码块(函数)时，自动变量才被创建；当自动变量所在的代码块(函数)执行完毕后，这些自动变量就会自行销毁。</p>
</li>
<li><p>被关键字<code>register</code>修饰的<strong>自动变量</strong>都是寄存器变量，是存储在硬件寄存器中的，其生命周期即是自动变量的生命周期。寄存器变量只限于int、char和指针类型变量使用，将一些频繁使用的自动变量定义为寄存器变量，这样程序尽可能地为它分配寄存器存放，而不用内存。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">char</span> b;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> *c;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="15-编译链接流程"><a href="#15-编译链接流程" class="headerlink" title="15.编译链接流程"></a>15.编译链接流程</h2><ol>
<li><p>如果一个程序中有多个源文件(.c)，编译成功会生成对应的多个目标文件(.obj)，这些目标文件不能单独运行，因为这些目标文件之间可能会有关联。将这些相关联的目标文件链接在一起后才能生成可执行文件。</p>
</li>
<li><p>所谓编译，就是单独检查每个源文件的语法是否合理，并不会检查每个源文件之间的关联关系，一个源文件编译成功就生成一个目标文件。所谓链接，就是检查目标文件的关联关系，将相关联的目标文件组合在一起，生成可执行文件。</p>
</li>
<li><p>根据在当前文件中定义的函数是否允许其他文件访问，可将函数分为内部函数和外部函数。默认情况下，所有的函数都是外部函数。不允许重复定义同一个外部函数。</p>
</li>
</ol>
<h2 id="16-extern与static关键字的作用"><a href="#16-extern与static关键字的作用" class="headerlink" title="16.extern与static关键字的作用"></a>16.extern与static关键字的作用</h2><p>使用<code>extern</code>关键字，表示引用其他文件的“外部函数”: <code>extern void test();</code>，然而extern可以省略，故直接声明即可。正规的项目里面，把“外部函数”的声明另写到一个头文件中，使用时直接包含头文件即可。</p>
<p>在定义函数时，在函数的最左边加上<code>static</code>可以把该函数声明为内部函数(又叫静态函数)，不允许其他文件访问。不同的文件中有同名的内部函数，则互不干扰。</p>
<p>默认情况下，一个函数不可以访问在它后面定义的全局变量。不同源文件中的同名全局变量代表着同一个变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a文件</span></span><br><span class="line"><span class="keyword">int</span> ss =<span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// b文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span>  ss ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ss);<span class="comment">// 是10</span></span><br></pre></td></tr></table></figure>
<p>在定义全局变量的时候加上<code>static</code>关键字，此时<code>static</code>的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰。</p>
<h2 id="17-如何定义结构体"><a href="#17-如何定义结构体" class="headerlink" title="17.如何定义结构体"></a>17.如何定义结构体</h2><p>定义结构体的三种形式(枚举变量的定义与之类似)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 利用上面结构体定义结构体变量stu</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 直接定义结构体变量stu</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; stu;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义结构体变量stu后,此结构体永不再用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; stu;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 特殊:struct前放置typedef表示声明此"匿名"结构体的名字为Student</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; Student;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ol>
<li>定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间。</li>
<li>将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。</li>
</ol>
<h2 id="18-结构体指针的使用"><a href="#18-结构体指针的使用" class="headerlink" title="18.结构体指针的使用"></a>18.结构体指针的使用</h2><p>结构体指针变量的定义形式：<code>struct 结构体名称 *指针变量名</code>，三种访问方式:</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结构体变量名.成员名</span><br><span class="line">(*指针变量名).成员名</span><br><span class="line">指针变量名-&gt;成员名</span><br></pre></td></tr></table></figure>
<h2 id="19-typedef的主要使用"><a href="#19-typedef的主要使用" class="headerlink" title="19.typedef的主要使用"></a>19.typedef的主要使用</h2><ol>
<li><p>typedef给指针起别名</p>
 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 相当于char *<span class="keyword">str </span>= <span class="string">"This is a string!"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="keyword">str </span>= <span class="string">"This is a string!"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>typedef给结构体起别名</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">CGRect</span> &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> origin;</span><br><span class="line">    <span class="built_in">CGSize</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CGRect</span> <span class="built_in">CGRect</span>;</span><br><span class="line"><span class="comment">// 为 struct CGRect 起别名叫作 CGRect</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>typedef给指向结构体的指针起别名</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义一个结构体并起别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 给Point *起别名PP</span></span><br><span class="line"><span class="keyword">typedef</span> Point *PP;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义结构体变量</span></span><br><span class="line">    Point point = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">         </span><br><span class="line">    <span class="comment">// 定义指针变量Point *p = &amp;point;</span></span><br><span class="line">    PP p = &amp;point;</span><br><span class="line">         </span><br><span class="line">    <span class="comment">// 利用指针变量访问结构体成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x=%f，y=%f"</span>, p-&gt;x, p-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li>typedef与枚举类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> Season &#123;spring, summer, autumn, winter&#125;;</span><br><span class="line"><span class="comment">// 给枚举类型enum Season起别名为Season</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> Season Season;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义枚举变量</span></span><br><span class="line">    Season s = spring;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>typedef给指向函数的指针类型起别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个sum函数，计算a跟b的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d + %d = %d"</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*MySum)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个指向sum函数的指针变量p</span></span><br><span class="line">    MySum p = sum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用指针变量p调用sum函数</span></span><br><span class="line">    (*p)(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>typedef与#define，给类型起别名，最好使用typedef，而不是使用#define</p>
 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">typedef</span> char *<span class="keyword">String1;</span></span><br><span class="line"><span class="keyword">#define </span><span class="keyword">String2 </span>char *</span><br><span class="line"> </span><br><span class="line">// 相当于char *<span class="keyword">str1;char </span>*<span class="keyword">str2;</span></span><br><span class="line"><span class="keyword">String1 </span><span class="keyword">str1, </span><span class="keyword">str2;</span></span><br><span class="line"><span class="keyword">// </span>相当于char *<span class="keyword">str3;char </span> <span class="keyword">str4;产生误会</span></span><br><span class="line"><span class="keyword">String2 </span><span class="keyword">str3, </span><span class="keyword">str4;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="20-import与include的区别"><a href="#20-import与include的区别" class="headerlink" title="20.import与include的区别"></a>20.import与include的区别</h2><p> <code>#import</code>是一个预处理指令，作用跟C语言的<code>#include</code>类似，都是 包含(拷贝)某个文件的内容 到 预处理指令所在的位置。在Objective-C中，使用<code>#import</code>来包含头文件，可以自动<strong>防止同一个头文件被包含多次</strong>。<code>#import &lt;...&gt;</code>表示包含系统自带的文件，<code>#import &quot;...&quot;</code>表示包含开发人员自己创建的文件。</p>
<h2 id="21-UIView显示的过程"><a href="#21-UIView显示的过程" class="headerlink" title="21.UIView显示的过程"></a>21.UIView显示的过程</h2><p><code>UIView</code>之所以能显示在屏幕上，完全是因为它内部的一个层(<code>CALayer</code>对象)。当<code>UIView</code>需要显示到屏幕上时，会调用<code>drawRect:</code>方法进行绘图，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了<code>UIView</code>的显示。<br>当<code>UIView</code>需要显示时，它内部的层会准备好一个<code>CGContextRef</code>(图形上下文)，然后调用<code>delegate</code>(这里就是<code>UIView</code>)的<code>drawLayer:inContext:</code>方法，并且传入已经准备好的<code>CGContextRef</code>对象。而<code>UIView</code>在<code>drawLayer:inContext:</code>方法中又会调用自己的<code>drawRect:</code>方法。</p>
<h2 id="22-position与anchorPoint"><a href="#22-position与anchorPoint" class="headerlink" title="22.position与anchorPoint"></a>22.position与anchorPoint</h2><p><code>position</code>可以用来设置<code>CALayer</code>在父层中的位置，它是以父层的左上角为坐标原点(0, 0);<code>anchorPoint</code>称为“定位点”，它决定着CALayer身上的哪个点会在<code>position</code>属性所指的位置。它的x、y取值范围都是0~1，默认值为(0.5, 0.5)。</p>
<h2 id="23-Core-Animation会阻塞主线程吗"><a href="#23-Core-Animation会阻塞主线程吗" class="headerlink" title="23.Core Animation会阻塞主线程吗"></a>23.Core Animation会阻塞主线程吗</h2><p>Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程，而且是直接作用在CALayer上的，并非UIView。</p>
<h2 id="24-空指针"><a href="#24-空指针" class="headerlink" title="24.空指针"></a>24.空指针</h2><p>没有存储任何内存地址的指针就称为空指针(<code>NULL</code>指针，指向<code>nil</code>)，空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。可以给空指针发送消息，但消息发送不出去。“野指针”不是<code>NULL</code>指针，是指向“垃圾”内存（不可用内存）的指针。</p>
<h2 id="25-不同编译器下各类型所占字节"><a href="#25-不同编译器下各类型所占字节" class="headerlink" title="25.不同编译器下各类型所占字节"></a>25.不同编译器下各类型所占字节</h2><p><img src="http://static.chenyalun.com/2017/04/03/20170403001.png" alt></p>
<h2 id="26-self与super"><a href="#26-self与super" class="headerlink" title="26.self与super"></a>26.self与super</h2><p><code>self</code> 是方法的隐藏的参数，指向当前调用方法的对象，另一个隐藏参数是 <code>_cmd</code>，代表当前方法的 <code>selector</code>。<code>super</code> 只是一个“编译器指示符”(编译器特性)，它和 <code>self</code> 指向的是相同的消息接收者。不同的是，<code>super</code> 告诉编译器，要先去调用父类的方法，而不是本类里的。当使用 <code>self</code> 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则先从父类的方法列表中开始找，然后调用父类的这个方法。</p>
<h2 id="27-消息发送"><a href="#27-消息发送" class="headerlink" title="27.消息发送"></a>27.消息发送</h2><p><code>id objc_msgSend(id theReceiver, SEL theSelector, ...)</code></p>
<p>以<code>[self setName:]</code> 为例，编译器会替换成调用<code>objc_msgSend</code> 的函数调用，其中 <code>theReceiver</code> 是 <code>self</code>，<code>theSelector</code> 是 <code>@selector(setName:)</code>，这个 <code>selector</code> 是从当前 <code>self</code> 的 <code>class</code> 的方法列表开始找的 <code>setName</code>，当找到后把对应的 <code>selector</code> 传递过去。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    <span class="keyword">id</span> receiver;</span><br><span class="line">    Class superClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>而当使用<code>[super setName]</code> 调用时，会使用 <code>objc_msgSendSuper</code> 函数，结构体包含了两个成员，一个是 <code>receiver</code>，这个类似<code>objc_msgSend</code> 的第一个参数 <code>receiver</code>，第二个成员是记录所谓的“父类”。从 <code>objc_super</code> 结构体指向的 <code>superClass</code> 的方法列表开始找 <code>setName</code> 的 <code>selector</code>，找到后再以 <code>objc_super-&gt;receiver</code> 去调用这个 <code>selector</code>。</p>
<h2 id="28-通知"><a href="#28-通知" class="headerlink" title="28.通知"></a>28.通知</h2><p><code>NSNotification</code>使用的是<strong>同步操作</strong>，如果想让<code>NSNotification</code>的<code>post</code>处和<code>observer</code>处异步执行，可以通过<code>NSNotificationQueue</code>实现。对于同一个通知，如果注册了多个观察者，则这多个观察者的<strong>执行顺序和他们的注册顺序是保持一致</strong>的。<code>observer</code>的回调方法执行线程和<code>post</code>的线程保持一致，如果想让<code>post</code>的线程和转发的线程不同，可以通过<code>NSNotification</code>重定向技术实现。<code>addObserver</code>和<code>removeObserver</code>必须成对出现，或者说添加了<code>Observer</code>必须适时移除<code>Observer</code>。因为通知中心并不retain Observer，若不移除，会极易造成给释放的对象发送消息，出现坏内存访问。</p>
<h2 id="29-屏幕"><a href="#29-屏幕" class="headerlink" title="29.屏幕"></a>29.屏幕</h2><p>普屏中1点 = 1像素，Retina屏：1点 = 2像素。人手指的最小点击范围是44pixels，所以在iPhone的很多细节上都是44 pixels。使用图片资源时，方法：<code>[UIImage imageNamed:@&quot;adflower.png&quot;]]</code>，在实际运行时，如果发现当前的设备是Retina屏，会自动寻找图片名为<code>adflower@ 2x.png</code>的图片。  <code>[UIScreen mainScreen].applicationFrame</code>获取app尺寸(去掉状态栏)，<code>[UIScreen mainScreen].bounds</code>获取屏幕尺寸，<code>[[UIApplicationsharedApplication] statusBarFrame]</code>获取状态栏尺寸。</p>
<h2 id="30-程序启动"><a href="#30-程序启动" class="headerlink" title="30.程序启动"></a>30.程序启动</h2><p>在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个“描述其定义的对象”，也就是<strong>类对象</strong>(class object)，它<strong>是一个单例</strong>(singleton)，这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。任何直接或间接继承了<code>NSObject</code>的类，它的实例对象(instance objec)中都有一个<code>isa</code>指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个  <strong>实例对象(instace object)</strong>  所属的类的定义的一切：包括变量、方法、遵守的协议等等。 类对象并不是类的实例本身。它没有自己的实例变量，也不能执行类的实例的方法。类对象是一个功能完整的对象，也能被动态识别（dynamically typed），接收消息，从其他类继承方法。特殊之处在于<strong>它们是由编译器创建的</strong>，缺少它们自己的数据结构(实例变量），只是在运行时产生实例的代理。类对象是元类对象的一个实例，元类是根元类(root class’s metaclass)的实例，而根元类是其自身的实例，即根元类的<code>isa</code>指针指向自身。</p>
<p>一个消息发送给任何一个对象， 方法的检查 从对象的 <code>isa</code> 指针开始，然后是父类。<strong>实例方法在类中定义， 类方法 在元类和根类中定义</strong>。（根类的元类就是根类自己）。类对象(class object)中包含了类的实例变量、实例方法的定义，而元类对象(metaclass object)中包括了类的类方法的定义。类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。</p>
<p>①<code>object_getClass</code>跟随实例的<code>isa</code>指针，返回此实例所属的类，对于实例对象(instance)返回的是类(class)，对于类(class)则返回的是元类(metaclass)。<br>②<code>- class</code>方法对于实例对象(instance)会返回类(class)，但对于类(class)则不会返回元类(metaclass)，而只会返回类本身。<br>③<code>class_isMetaClass</code>可判断某类是否为元类。<br>④使用<code>objc_allocateClassPair</code>可在运行时创建新的类与元类对，使用<code>class_addMethod</code>和<code>class_addIvar</code>可向类中增加方法和实例变量，最后使用<code>objc_registerClassPair</code>注册后，就可以使用此类了。</p>
<h2 id="31-alloc方法"><a href="#31-alloc方法" class="headerlink" title="31.alloc方法"></a>31.alloc方法</h2><p>通过<code>alloc</code>或<code>allocWithZone</code>方法创建对象时，</p>
<ol>
<li>cocoa会遍历该对象所有的成员变量，通过成员变量的类型来计算所需占用的内存返回一个未“初使化”过的对象。</li>
<li>将该新对象的引用计数(Retain Count)设置成1。</li>
<li>该新对象的<code>isa</code>成员变量指向它的类对象。</li>
<li>将该新对象的所有其它成员变量的值设置成零。（根据成员变量类型的不同，零有可能是指nil或0）</li>
<li>返回指向该对象的一个指针。</li>
</ol>
<h2 id="32-init方法"><a href="#32-init方法" class="headerlink" title="32.init方法"></a>32.init方法</h2><p>大部分情况下，我们都不希望所有成员变量都是零，所以<br>①<code>init</code>方法做初使化工作，让对象的成员变量的值符合我们程序逻辑中的初始化状态。<br>②返回真正可以使用的指向该对象的指针<br>某些情况下，init会造成alloc的原本空间不够用，而进行第二次分配内存空间。所以下面的写法是错的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>  *s = [<span class="built_in">NSString</span> alloc];</span><br><span class="line">[s init];<span class="comment">// 这儿init返回的地址可能会变。s原本的指针地址可能是无效的地址。</span></span><br></pre></td></tr></table></figure></p>
<p>正确的写法是<code>NSString  *s = [[NSString alloc] init];</code><br>new简单地等价于 alloc + init，但不能指定<code>init</code>的参数，很少用。<br><code>NSInteger</code>是一个有符号型<code>int</code>，它与<code>int</code>的区别就在于<code>NSInteger</code>可以自动识别机器是32位还是64位。<code>NSInteger</code>的无符号版本是<code>NSUInteger</code>。</p>
<h2 id="33-运行时"><a href="#33-运行时" class="headerlink" title="33.运行时"></a>33.运行时</h2><p>消息只有到运行时才会和函数实现绑定起来，而不是按照编译好的逻辑一成不变的执行。编译阶段只是确定了要去向<code>receiver</code>对象发送<code>message</code>消息，但是却没有发送，真正发送是等到运行的时候进行。<code>NSObject</code> 类定义了<code>description</code>方法，返回该类内容的字符串表示。某些 <code>NSObject</code> 的方法只是简单地从运行时系统中获得信息，从而允许对象进行一定程度的自我检查。</p>
<p>例如，<code>class</code> 返回对象的类;<code>isKindOfClass:</code>和 <code>isMemberOfClass:</code>则检查对象是否在指定的 类继承体系中;<code>respondsToSelector:</code>检查对象能否响应指定的消息;<code>conformsToProtocol:</code> 检查对象是否实现了指定协议类的方法;<code>methodForSelector:</code>则返回指定方法实现的地址。</p>
<p>①message（消息）<br><code>message</code> 是一种抽象，包括了函数名+参数列表，并没有实际的实体存在。<br>②method（方法）<br><code>method</code>是真正的存在的代码。如：<code>- (int)meaning { return 42; }</code><br>③selector（方法选择器）<br><code>selector</code> 通过<code>SEL</code>类型存在，描述一个特定的<code>method</code> 或者说 <code>message</code>。在实际编程中，可以通过<code>selector</code>进行检索方法等操作。</p>
<h2 id="34-方法选择器"><a href="#34-方法选择器" class="headerlink" title="34.方法选择器"></a>34.方法选择器</h2><p>它是一个<code>char *</code>指针，仅仅表示它所代表的方法名字。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;  </span><br><span class="line">SEL selector = <span class="keyword">@selector</span>(message); <span class="comment">// @selector不是函数调用，只是给编译器的一个提示   </span></span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%s"</span>, (<span class="keyword">char</span> *)selector);   <span class="comment">//print message</span></span><br></pre></td></tr></table></figure></p>
<p><code>Objective-C</code>在编译的时候，会根据方法的名字，生成一个用来区分这个方法的唯一的一个ID，这个ID就是<code>SEL</code>类型的（生成唯一的<code>SEL</code>）。只要方法的名字相同，那么它们的ID都是相同的。编译器会根据，这个Set简单的说就是一个经过了优化过的<strong>hash表</strong>。<code>SEL</code>实际上就是根据方法名<code>hash</code>化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，从而加快方法的查询速度。</p>
<h2 id="35-IMP"><a href="#35-IMP" class="headerlink" title="35.IMP"></a>35.IMP</h2><p><code>typedef id (*IMP)(id, SEL, ...);</code><br>由于每个方法都对应唯一的<code>SEL</code>，可以通过<code>SEL</code>方便、快速、准确的获得它所对应的<code>IMP</code>（也就是函数指针），而在取得了函数指针之后，也就意味着取得了执行这段方法的代码的入口，这样就可以像普通的C语言函数调用一样使用这个函数指针。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void <span class="comment">(*performMessage)(id,SEL); //定义一个IMP（函数指针）   </span></span><br><span class="line"><span class="comment">performMessage = (void (*)</span>(id,SEL))</span><br><span class="line"><span class="comment">// 通过methodForSelector方法根据SEL获取对应的函数指针   </span></span><br><span class="line">[<span class="keyword">self</span> methodForSelector:@<span class="keyword">selector</span>(message)];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过取到的IMP（函数指针）跳过runtime消息传递机制，直接执行message方法。</span></span><br><span class="line">performMessage(<span class="keyword">self</span>,@<span class="keyword">selector</span>(message));</span><br></pre></td></tr></table></figure>
<p>用<code>IMP</code> 的方式，省去了runtime消息传递过程中所做的一系列动作，比直接向对象发送消息高效一些。</p>
<h2 id="36-消息调用流程"><a href="#36-消息调用流程" class="headerlink" title="36.消息调用流程"></a>36.消息调用流程</h2><p>消息表达式<code>[receiver message]</code>在被转换成<code>objc_msgSend(receiver, SEL)</code>后，在运行时，runtime system会做以下事情：</p>
<ul>
<li><p>1、检查忽略的<code>selector</code>（比如将会忽略retain和release消息）。</p>
</li>
<li><p>2、检查<code>receiver</code>是否为<code>nil</code>。（如果<code>receiver</code>为空，则会将 <code>selector</code>也设置为空，并且直接返回到消息调用的地方。）如果对象非空，就继续下一步。</p>
</li>
<li><p>3、根据<code>SEL</code>到当前类中查找对应的<code>IMP</code>，首先会在<code>cache</code>中检索它，如果找到了就根据函数指针跳转到这个函数执行，否则进行下一步。</p>
</li>
<li><p>4、检索当前类对象中的方法表（method list），如果找到了，加入<code>cache</code>中，并且就跳转到这个函数执行，否则进行下一步。</p>
</li>
<li><p>5、从父类中寻找，直到根类：<code>NSObject</code>类。找到了就将方法加入对应类的<code>cache</code>表中，如果仍未找到，则要进入动态方法决议。</p>
</li>
<li><p>6、如果动态方法决议仍不能解决问题，只能进行最后一次尝试，进入消息转发流程。</p>
</li>
</ul>
<p>注意：cache的原则就是缓存那些可能要执行的函数地址，下次调用的时候，速度就可以快速很多。</p>
<p>类方法和实例方法中，都可以访问<code>self</code>和<code>_cmd</code>这两个属性，因为它们都不属于类的实例变量，而是<strong>形参</strong>。<code>objc_msgSend</code>找到方法对应的实现时，将直接调用该方法实现，并将消息中所有的参数都传递给方法实现，同时，它还将传递两个隐藏的参数:接收消息的对象（也就是<code>self</code>指向的内容），方法选标（<code>_cmd</code>指向的内容）</p>
<p>隐藏：因为它们并没有在定义方法的源代码中声明，而是<strong>在代码编译时是插入方法的实现中</strong>的。在方法中可以通过 self 来引用消息接收者对象，通过选标<code>_cmd</code>来引用方法本身。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)message &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = <span class="string">@"James"</span>;<span class="comment">//通过self关键字给当前对象的属性赋值  </span></span><br><span class="line">    SEL currentSel = _cmd;<span class="comment">//通过_cmd关键字取到当前函数对应的SEL  </span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentSel is :%s"</span>,(<span class="keyword">char</span> *)currentSel);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 当被调用的方法实现部分没有找到，而消息转发机制启动之前的这个中间时刻(动态添加方法)。<code>+(BOOL) resolveInstanceMethod:(SEL) sel</code>将被调用。这是<code>NSObject</code>根类提供的类方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="comment">// implementation ....  </span></span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"sel is %@"</span>, <span class="built_in">NSStringFromSelector</span>(sel));  </span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(setName:)) &#123;  </span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>],sel,(IMP)dynamicMethodIMP,<span class="string">"v@:"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@dynamic</code>关键字的作用:①告诉编译器<strong>不要创建</strong>实现属性所用的<strong>实例变量</strong>；②告诉编译器<strong>不要创建</strong>该属性的<strong>get和setter方法</strong>。让编译器相信存取方法会在运行时找到。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明文件中</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name; </span><br><span class="line">   </span><br><span class="line"><span class="comment">// 实现文件中</span></span><br><span class="line"><span class="keyword">@dynamic</span> name;</span><br></pre></td></tr></table></figure></p>
<h2 id="37-synthesize"><a href="#37-synthesize" class="headerlink" title="37.@synthesize"></a>37.@synthesize</h2><p>默认情况下，编译器会为当前类自动生成一个<code>NSString *_name</code>的实例变量（如果想改变实例变量的名称可以用<code>@synthesize</code>关键字），同时会生成两个名为<code>- (NSString *)name</code>和<code>- (void)setName:(NSString *)aName</code>的存取方法。</p>
<h2 id="38-消息转发"><a href="#38-消息转发" class="headerlink" title="38.消息转发"></a>38.消息转发</h2><p>外部调用的某个方法对象没有实现，而且<code>resolveInstanceMethod</code>方法中也没有做重定向处理时，就会触发<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>方法。这个方法通常用来将不能处理的消息转发给其它的对象。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)invocation  &#123;</span><br><span class="line">    SEL invSEL = invocation.selector;  </span><br><span class="line">    <span class="keyword">if</span> ([someOtherObject <span class="string">respondsToSelector:</span>invSEL])  </span><br><span class="line">         [anInvocation <span class="string">invokeWithTarget:</span>someOtherObject];  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">         [self <span class="string">doesNotRecognizeSelector:</span>invSEL];   </span><br><span class="line">    &#125;                                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="39-Cocoa"><a href="#39-Cocoa" class="headerlink" title="39.Cocoa"></a>39.Cocoa</h2><p>它是一个面向对象的软件组件——类的集成套件，它使开发者可以快速创建强壮和全功能的 Mac OS X （iOS）应用程序。Cocoa包含了很多框架，其中最最核心的是Foundation框架和Application Kit（AppKit）框架（Cocoa Touch中叫UIKit框架）。</p>
<h2 id="40-Runloop"><a href="#40-Runloop" class="headerlink" title="40.Runloop"></a>40.Runloop</h2><p>它是为了线程而生，是线程的基础架构部分，<strong>每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象</strong>。主线程的run loop默认是启动的。<code>UIApplicationMain()</code>函数，会为main thread设置一个<code>NSRunLoop</code>对象。<code>NSRunLoop</code>类并不是线程安全的，不能在一个线程中去操作另外一个线程的run loop对象，<code>CFRunLoopRef</code>是线程安全的。<br>获取到当前线程的run loop:<code>[NSRunLoop currentRunLoop];</code><br>获取对应的<code>CFRunLoopRef</code>类：<code>- (CFRunLoopRef)getCFRunLoop;</code></p>
<p>一个run loop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。对消息处理过程进行了更好的抽象和封装，在<code>NSRunLoop</code>中每一个消息就被打包在input source或者是timer source中了。使用run loop可以使线程在有工作的时候工作，没有工作的时候休眠，这可以大大节省系统资源。创建输入源的时候，需要将其分配给run loop中的一个或多个模式。定时源在预设的时间点同步方式传递消息，这些消息都会发生在特定时间或者重复的时间间隔。定时源则直接传递消息给处理例程，不会立即退出run loop。</p>
<h2 id="41-创建NSTimer"><a href="#41-创建NSTimer" class="headerlink" title="41.创建NSTimer"></a>41.创建NSTimer</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一:自动把timer加入MainRunloop的NSDefaultRunLoopMode中</span></span><br><span class="line">NSTimer *timer = [NSTimer <span class="string">scheduledTimerWithTimeInteral:</span><span class="number">1.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">action:</span>) <span class="string">userInfo:</span>ni] <span class="string">repeat:</span>NO]; </span><br><span class="line"><span class="comment">// 停止</span></span><br><span class="line">[timer invalidate];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二(需手动加到run loop中)</span></span><br><span class="line">NSTimer *timer = [NSTimer <span class="string">timerWithTimeInterval:</span><span class="number">5</span> <span class="string">target:</span>self <span class="string">seletor:</span><span class="meta">@selector</span>(timerAction) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line">[[NSRunloop mainRunloop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSDefaultRunloopMode];</span><br></pre></td></tr></table></figure>
<p>调用创建方法后，target对象的引用计数会+1，直到执行完毕，自动-1。如果RunLoop正在执行一个连续的运算，timer就会被延迟触发。</p>
<h2 id="42-响应者对象（Responder-Object）"><a href="#42-响应者对象（Responder-Object）" class="headerlink" title="42.响应者对象（Responder Object）"></a>42.响应者对象（Responder Object）</h2><p>指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。<code>UIResponder</code>是所有响应对象的基类，在<code>UIResponder</code>类中定义了处理上述各种事件的接口。</p>
<h2 id="43-响应者链"><a href="#43-响应者链" class="headerlink" title="43.响应者链"></a>43.响应者链</h2><p>通常是由视图（UIView）构成的。</p>
<ul>
<li>一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）。</li>
<li>视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图。</li>
<li>单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者。</li>
<li>单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。</li>
</ul>
<p>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。<code>UIWindow</code>对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。<code>UIWindow</code>实例对象会首先在它的内容视图上调用<code>hitTest:withEvent:</code>，此方法会在其视图层级结构中的每个视图上调用<code>pointInside:withEvent:</code>。</p>
<h2 id="44-响应者链方法的处理流程"><a href="#44-响应者链方法的处理流程" class="headerlink" title="44.响应者链方法的处理流程"></a>44.响应者链方法的处理流程</h2><p>首先调用当前视图的<code>pointInside:withEvent:</code>方法判断触摸点是否在当前视图内；<br>若返回NO，则<code>hitTest:withEvent:</code>返回<code>nil</code>;<br>若返回YES，则向当前视图的所有子视图(subviews)发送<code>hitTest:withEvent:</code>消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从<code>subviews</code>数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；<br>若第一次有子视图返回非空对象，则<code>hitTest:withEvent:</code>方法返回此对象，处理结束；<br>如所有子视图都返回空对象，则<code>hitTest:withEvent:</code>方法返回自身(self)。</p>
<h2 id="45-类别与类扩展的区别："><a href="#45-类别与类扩展的区别：" class="headerlink" title="45.类别与类扩展的区别："></a>45.类别与类扩展的区别：</h2><p>①类别中只能增加方法。<br>②类扩展不仅可以增加方法，还可以增加实例变量（或者合成属性），只是该实例变量默认是<code>@private</code>类型的。<br>③类扩展中声明的方法没被实现，编译器会警告，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为<strong>类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中</strong>。<br>④类扩展所声明的方法必须依托对应类的实现部分来实现。<br>⑤定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。</p>
<h2 id="46-KVC"><a href="#46-KVC" class="headerlink" title="46.KVC"></a>46.KVC</h2><p>全称是Key-value coding，翻译成键值编码。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。KVO全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。KVO机制很适合实现model和controller类之间的通讯。<br>KVC是不会自动调用键值验证方法的，我们需要手动验证：<code>- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</code><br>KVC可以自动的将数值或结构体型的数据打包或解包成<code>NSNumber</code>或<code>NSValue</code>对象，以达到适配的目的。</p>
<h2 id="47-内存管理规则"><a href="#47-内存管理规则" class="headerlink" title="47.内存管理规则"></a>47.内存管理规则</h2><p>ARC的英文全名是：Automatic Reference Counting，是编译器提供的管理Objective-C对象内存的一个机制。它并不是像垃圾回收机制那样，有一个负责内存回收的系统，而是仍然以引用计数为基础：在编译阶段，编译器会在需要<code>retain</code>或<code>release</code>对象的地方自动为我们加上对应的代码。一个对象存在<code>strong</code>类型的指针指向时，该对象就不会被释放。</p>
<p>采用散列表来管理引用计数，统一存储所有对象的引用计数，不用考虑每个对象内存块中引用计数所占的内存，在引用计数表中存储各个对象的内存地址。</p>
<p>①strong<br>该属性值对应 <code>__strong</code>关键字，即该属性所声明的指针变量将成为对象的持有者。<code>strong</code>是指向对象指针的默认属性。<br>②weak<br>该属性对应<code>__weak</code>关键字，与<code>__weak</code>定义的变量一致，该属性所声明的变量将没有对象的所有权，并且当对象被破弃之后，指针将被自动赋值<code>nil</code>。<br>④copy<br>也是对象的所有者，与<code>strong</code>的区别是声明的指针变量是拷贝对象的持有者。<br>⑤assign<br>一般数值型变量用该属性声明，比如，<code>int、BOOL</code>，但无需显示写出，因为数值型变量的默认属性类型就是<code>assign</code>。</p>
<p>使用关键字声明指针类型规范写法:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规范的写法</span></span><br><span class="line">MyClass * __<span class="keyword">weak</span> myWeakReference;</span><br></pre></td></tr></table></figure></p>
<h2 id="48-weak和assign的异同"><a href="#48-weak和assign的异同" class="headerlink" title="48.weak和assign的异同"></a>48.weak和assign的异同</h2><p>相同点：指向的对象都是随时有可能被释放，即不拥有指向的对象。<br>不同点：<br>①<code>weak</code>只能用来修饰对象，<code>assign</code><strong>既可以用来声明对象，也可以用来声明数值型变量</strong>；<br>②很关键的一点区别，当一个<code>weak</code>关键字声明的指针指向的对象被释放掉得时候，该指针会自动的被指向<code>nil</code>，而<code>assign</code>不存在该特性。</p>
<p>使用<code>@property</code>声明或作为普通实例变量声明的指向对象的指针属性默认都是<code>strong</code>；而使用<code>@property</code>声明的数值型变量属性默认的是<code>assign</code>。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>关键字</th>
<th>所有权</th>
</tr>
</thead>
<tbody>
<tr>
<td>strong</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>copy</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
<td>无</td>
</tr>
<tr>
<td>assign</td>
<td>__unsafe_unretained</td>
<td>无</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe_unretained</td>
<td>无</td>
</tr>
</tbody>
</table>
<h2 id="49-使用ARC需要遵守的新规则"><a href="#49-使用ARC需要遵守的新规则" class="headerlink" title="49.使用ARC需要遵守的新规则"></a>49.使用ARC需要遵守的新规则</h2><p>①不要在<code>dealloc</code>方法中调用<code>[super dealloc];</code>。<br>②不能使用 <code>retain/release/retainCount/autorelease</code><br>③不能使用 <code>NSAllocateObject/NSDeallocateObject</code><br>④不能使用 <code>NSZone</code><br>⑤对象不能作为C语言结构体（struct/union）的成员</p>
<h2 id="50-instancetype"><a href="#50-instancetype" class="headerlink" title="50.instancetype"></a>50.instancetype</h2><p>表示某个方法返回的某种类型的对象，<code>instancetype</code>的作用，就是使那些<strong>非关联返回类型的方法返回所在类的类型</strong>，能够确定对象的类型。有利于开发者在编译阶段发现错误。<br>关联返回类型（related result types）<br>1、类方法中，以<code>alloc</code>或<code>new</code>开头；<br>2、实例方法中，以<code>autorelease，init，retain</code>或<code>self</code>开头；</p>
<p><code>instancetype</code>和<code>id</code>的异同:<br>1、相同点:都可以作为方法的返回类型<br>2、不同点<br>①<code>instancetype</code>可以返回和方法所在类相同类型的对象，<code>id</code>只能返回未知类型的对象；<br>②<code>instancetype</code>只能作为返回值，不能像<code>id</code>那样作为参数；</p>
<h2 id="51-沙盒目录："><a href="#51-沙盒目录：" class="headerlink" title="51.沙盒目录："></a>51.沙盒目录：</h2><p>1、MyApp.app<br>存放应用程序本身的数据，整个目录是只读的，不能被iTunes同步。<br>2、Documents<br>存放不可再生的的数据文件，会被iTunes同步。<br>3、Library<br>存放默认设置或其它状态信息。<br>除了Caches子目录外，会被iTunes同步。<br>4、Library/Caches<br>存放缓存文件，保存那些可再生的文件，不会被iTunes同步。<br>5、Library/Preferences<br>存放应用程序的偏好设置文件。我们使用NSUserDefaults写的设置数据都会保存到该目录下的一个plist文件中，会被iTunes同步。<br>6、tmp<br>存放各种临时文件，不会被iTunes同步。</p>
<h2 id="52-空"><a href="#52-空" class="headerlink" title="52.空"></a>52.空</h2><p><code>NULL</code>本质上是：<code>(void*)0</code>，表示C指针为空，如<code>charchar *string = NULL;</code>。<br><code>nil</code>本质上是：<code>(void *)0</code>，表示指向对象的指针为空。<br><code>Nil</code>本质上也是：(void *)0,表示<code>Class</code>类型的变量值为空，<code>Class anyClass = Nil;</code>。</p>
<h2 id="53-NSNull"><a href="#53-NSNull" class="headerlink" title="53.NSNull"></a>53.NSNull</h2><p>是一个Objective-C类，该类通常用于在集合对象中保存一个空的占位对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遇到nil截断</span></span><br><span class="line"><span class="built_in">NSArray</span> *arr = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"wang"</span>,<span class="string">@"zz"</span>,<span class="literal">nil</span>,<span class="string">@"foogry"</span>];</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 存储空的占位对象</span></span><br><span class="line"><span class="built_in">NSArray</span> *arr = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"wang"</span>,<span class="string">@"zz"</span>,[<span class="built_in">NSNull</span> null], <span class="string">@"foogry"</span>];</span><br></pre></td></tr></table></figure>
<h2 id="54-imageNamed"><a href="#54-imageNamed" class="headerlink" title="54.imageNamed"></a>54.imageNamed</h2><p><code>imageNamed</code>的优点在于可以缓存已经加载的图片。这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回。<br><code>imageWithContentsOfFile</code>方法只是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到程序。当不需要重用该图像，或者需要将图像以数据方式存储到数据库，又或者要通过网络下载一个很大的图像时，可以使用这种方式。</p>
<blockquote>
<p>读完他们的博客，仿佛看到未来的自己……</p>
</blockquote>
<blockquote>
<p>向前辈致谢：<br><a href="http://blog.csdn.net/wzzvictory" target="_blank" rel="noopener">王中周的个人博客</a><br><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="noopener">M了个J</a><br>参考：<br><a href="http://c.biancheng.net/cpp/html/88.html" target="_blank" rel="noopener">C语言中文网</a></p>
</blockquote>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/iOS开发/">iOS开发</a>
            <a href="/tags/C语言/">C语言</a>
            <a href="/tags/笔记/">笔记</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2016/12/20/Python3入门笔记/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Python3入门笔记</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2016/10/23/C语言交换两个数值的八种方法/">
        <span class="next-text nav-default">C语言交换两个数值的八种方法</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        </div><div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  <span class="division"> </span>
  <span class="theme-info">
    Better
    <a class="theme-link" href> </a>
  </span>

  <span class="copyright-year">&copy;2016 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
