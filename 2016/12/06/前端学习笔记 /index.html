<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="前端学习笔记"/>




  <meta name="keywords" content="笔记,HTML,CSS,JavaScript," />




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x" />



<link rel="canonical" href="http://blog.chenyalun.com/2016/12/06/前端学习笔记 /"/>


<meta name="description" content="大前端时代。">
<meta name="keywords" content="笔记,HTML,CSS,JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="前端学习笔记">
<meta property="og:url" content="http://blog.chenyalun.com/2016/12/06/前端学习笔记 /index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="大前端时代。">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2019-03-29T03:02:43.774Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端学习笔记">
<meta name="twitter:description" content="大前端时代。">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> 前端学习笔记 · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          前端学习笔记
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016年12月6日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML"><span class="toc-text">HTML</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Date日期对象"><span class="toc-text">Date日期对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MATH常用属性方法"><span class="toc-text">MATH常用属性方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组常用方法"><span class="toc-text">数组常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#window对象方法"><span class="toc-text">window对象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#history对象"><span class="toc-text">history对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#location对象"><span class="toc-text">location对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#navigator对象"><span class="toc-text">navigator对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#window中的screen-对象"><span class="toc-text">window中的screen 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文档对象模型"><span class="toc-text">文档对象模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docuument常用方法"><span class="toc-text">docuument常用方法</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p align="center"> 大前端时代。 </p>

<a id="more"></a>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul>
<li><code>&lt;html&gt;&lt;/html&gt;</code>是根标签,<code>&lt;heal&gt;</code>定义文档的头部,常包含<code>&lt;title&gt; &lt;script&gt;</code></li>
<li><code>&lt;style&gt; &lt;meta&gt; &lt;link&gt;</code></li>
<li><code>&lt;em&gt;</code>表示强调，<code>&lt;strong&gt;</code> 表示更强烈的强调。并且在浏览器中<code>&lt;em&gt;</code> 默认用斜体表示，<code>&lt;strong&gt;</code>用粗体表示。</li>
<li><code>&lt;span&gt;</code>标签是没有语义的，它的作用就是为了设置单独的样式用的。</li>
<li>用<code>&lt;q&gt;</code>标签引用别人的语句,是对简短文本的引用:加上双引号</li>
<li><code>&lt;blockquote</code>是长文本引用:整体缩进</li>
<li>空标签现在一般使用 xhtml1.0 的版本的写法,如<code>&lt;br/&gt; &lt;img/&gt; &lt;hr/&gt;</code></li>
<li>在html代码中输入空格、回车都是没有作用的。要想输入空格，必须写入<code>&amp;nbsp;</code>。</li>
<li><code>&lt;adress&gt;</code>标签,添加地址:显示为斜体</li>
<li><code>&lt;code&gt;</code>标签:添加一行代码,<code>&lt;pre&gt;</code>预显示格式标签,被包围在 pre 元素中的文本通常会保留空格和换行符:添加一段代码(会转换其中的<code>&lt;br/&gt;</code>等)</li>
<li>ul-li是没有前后顺序的信息列表:每项li前都自带一个圆点</li>
<li>ol-li是有前后顺序的信息列表:每项li前都自带一个序号,序号默认从1开始</li>
<li>容器标签<code>&lt;div&gt;</code>,为网页划分独立的版块,给div命名:添加唯一的id属性，使逻辑更加清晰<br>创建表格的五个元素：`table、tr(一行)、th(表格表头)、td(一个单元格,有几个说明就有几列,表格中列的个数，取决于一行中数据单元格的个数。),</li>
<li>注意<code>tbody</code>:当表格内容非常多时，表格会下载一点显示一点，但如果加上<tbody>标签后，这个表格就要等表格内容全部下载完才会显示。注意1、table表格在没有添加css样式之前，在浏览器中显示是没有表格线的 2、表头，也就是th标签中的文本默认为粗体并且居中显示</tbody></li>
<li><code>&lt;table summary=&quot;表格简介文本&quot;&gt;</code>添加表格摘要,表格摘要并不会显示,<code>&lt;caption&gt;标题文本&lt;/caption&gt;</code>添加表格标题,显示在表格上方居中,需要包含在table标签中</li>
<li><code>&lt;a  href=&quot;目标网址&quot;  title=&quot;鼠标滑过显示的文本&quot;&gt;链接显示的文本&lt;/a&gt;</code>,title属性的作用，鼠标滑过链接文字时会显示这个属性的文本内容。加入a标签后，文字的颜色就会自动变为蓝色（被点击过的文本颜色为紫色）</li>
<li>新窗口打开超链接<code>&lt;a href=&quot;目标网址&quot; target=&quot;_blank&quot;&gt;click here!&lt;/a&gt;</code></li>
<li>使用mailto协议发送电子邮件,<code>mailto://abc@qq.com?&amp;cc=abcd@qq.com&amp;bcc=ab@qq.com&amp;subject=主题&amp;body=邮件内容</code>,其中,cc表示抄送,bcc表示密件抄送</li>
<li>插入图片语法<code>&lt;img src=&quot;图片地址&quot; alt=&quot;下载失败时的替换文本&quot; title = &quot;提示文本&quot;&gt;</code></li>
<li>表单是可以把浏览者输入的数据传送到服务器端,语法:<code>&lt;form   method=&quot;传送方式&quot;   action=&quot;服务器文件&quot;&gt;</code>,action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。method ： 数据传送的方式（get/post）</li>
<li><p>文本输入框input的类型:<code>text：文本框 password：密码框 raido：单选按钮 checkbox：复选框 file：文件选择框 submit：提交按钮,reset:重置</code></p>
<pre><code>&lt;form&gt;
   &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt;
&lt;/form&gt;`其中name为文本框命名,方便后台使用,value为文本框设置默认值,一般起提示作用

文本输入域`&lt;textarea  rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt;`,在&lt;textarea&gt;&lt;/textarea&gt;标签之间可以输入默认值。注意这两个属性可用css样式的width和height来代替：col用width、row用height来代替。
</code></pre></li>
<li>单选框与复选框:注意:同一组的单选按钮，name 取值一定要一致</li>
<li><p>下拉列表:</p>
<pre><code>&lt;select&gt;
  &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt;
  &lt;option value=&quot;旅游&quot;&gt;旅游&lt;/option&gt;
  &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt;
  &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt;
&lt;/select&gt;` value为向服务器提交的值,设置selected=“selected”属性,则默认选中.
</code></pre></li>
<li>下拉列表也可以进行多选操作，在<code>&lt;select&gt;</code>标签中设置multiple=”multiple”属性，就可以实现多选功能，在 windows 操作系统下，进行多选时按下Ctrl键同时进行单击（在 Mac下使用 Command +单击），可以选择多个选项。</li>
<li><p>form表单中的label标签:用于显示提示文本,并且当用户点击label时,将焦点转移到与之对应的控件(常用输入框)上,但是标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。 </p>
<pre><code>&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;
&lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt;
</code></pre></li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><ul>
<li>css 样式由选择符和声明组成，而声明又由属性和值组成,属性和值之间用英文冒号“：”分隔。当有多条声明时，中间可以英文分号“;”分隔,最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号。</li>
<li>CSS中有注释语句：用<code>/*</code>注释语句<code>*/</code>来标明,（Html中使用<code>&lt;!--注释语句--&gt;</code>)</li>
<li>内联式css样式表就是把css代码直接写在现有的HTML标签中，注意要写在元素的开始标签里,css样式代码要写在style=””双引号中，如果有多条css样式代码设置可以写在一起，中间用分号隔开</li>
<li><p>嵌入式css样式，写在当前的文件中.嵌入式css样式必须写在<code>&lt;style&gt;&lt;/style&gt;之间</code>，并且一般情况下嵌入式css样式写在<code>&lt;head&gt;&lt;/head&gt;</code>之间。注意设置style的type属性.</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
span{
   color:blue;
}
&lt;/style&gt;
</code></pre></li>
<li>外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以“.css”为扩展名，在<code>&lt;head&gt;</code>内（不是在<code>&lt;style&gt;</code>标签内）使用<code>&lt;link&gt;</code>标签将css样式文件链接到HTML文件内,<code>&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</code>,<code>rel=&quot;stylesheet&quot; type=&quot;text/css&quot;</code>是固定写法不可修改。<code>&lt;link&gt;</code>标签位置一般写在<code>&lt;head&gt;</code>标签之内。</li>
<li>标签选择器; <code>标签名称{css样式代码;}</code></li>
<li>类选择器:<code>.类选器名称{css样式代码;}</code></li>
<li>ID选择器:<code>#id名称{css样式代码;}</code></li>
<li>子选择器:即大于符号(&gt;),用于选择指定标签元素的第一代子元素(只能是孩子)。<code>.food&gt;li{border:1px solid red;}</code></li>
<li>包含选择器:加入空格,用于选择指定标签元素下的后辈元素。<code>.first  span{color:red;}</code></li>
<li>通用选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素</li>
<li>伪类选择符:<code>a:hover{color:red;}</code></li>
<li>分组选择符:为html中多个<strong>标签元素</strong>设置同一个样式（，)<code>h1,span{color:red;}</code></li>
<li>类选择器和ID选择器的区别:1.ID选择器只能在文档中使用一次,类选择器可以使用多次,也即id选择器(名称)具有唯一性;2.可以使用类选择器词列表方法为一个元素同时设置多个样式。也即一个元素可以具有多个类,但只能有一个id:<code>&lt;span class=&quot;stress bigsize&quot;&gt;三年级&lt;/span&gt;</code></li>
<li><code>border:1px solid red;相当于border-width:1px;//边框宽度    border-style:solid; //边框风格    border-color:red; //边框颜色</code></li>
<li>继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。<code>border:1px solid red;</code>无法继承.</li>
<li>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于最后面的css样式会被应用。</li>
<li>继承是指标签的样式可以由子代继承，但有些标签是不能继承的，eg：border。<br>特殊性指用用权重来确定最后起作用的样式，id=100，class=10，标签=1，继承=0.1；<br>层叠指当权重相同时，后面的样式覆盖前面的样式。<br>important的使用。</li>
<li>浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式，但记住!important优先级样式是个例外，权值高于用户自己设置的样式。<code>p{color:red !important;}</code>注意分号放在!important的后面</li>
<li>任意浏览器的默认字体高度16px（16像素）。所有未经调整的浏览器都符合:1em=16px。为了简化font-size的换算，需要在css中的body选择器中声明font-size=62.5%，这就使em值变为16px*62.5%=10px,这样12px=1.2em,10px=1em,也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。注：建议不要使用em作为中文站点的文字单位，会导致文字变形十分严重的。em的值并不是固定的； em会继承父级元素的字体大小。</li>
<li><p>图片居中，不能直接对img标签使用<code>text-align:center;</code>而是对该img标签所在的div或者其他块级元素使用才会达到这种效果。</p>
<pre><code>字体:`font-family:”Microsoft Yahei”;`
文字颜色,字号:`font-size:12px;color:#666`
文字粗体:`font-weight:bold;`
文字斜体:`font-style:italic;`
文字下划线;`text-decoration:underline;`
文字删除线:`text-decoration:line-through;`
文本缩进:`text-indent:2em;`两个空格
行间距(行高):`line-height:2em;`
设置文字间隔或者字母间隔:`letter-spacing:50px;`注意：这个样式使用在英文单词时，是设置字母与字母之间的间距。
单词间距:`word-spacing:50px;`
为块状元素中的文本、图片设置居中样式:`text-align:center;`
常用的块状元素有：`&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;`
常用的内联元素有：`&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;`
常用的内联块状元素有：`&lt;img&gt;、&lt;input&gt;`
</code></pre></li>
<li>块状元素都自带换行效果；内联元素都是定义行内小区域且不换行，但如果没有内容就没有意义，不占空间；内联块状元素除了不换行，即使没有内容也会占空间。</li>
<li>在html中<code>&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;</code>就是块级元素。设置<code>display:block</code>就是将元素显示为块级元素。</li>
<li>将内联元素转换为块级元素:<code>a{display:block;}</code></li>
<li>块级元素特点：1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）2、元素的高度、宽度、行高以及顶和底边距都可设置。3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</li>
<li>在html中，<code>&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;</code>就是典型的内联元素（行内元素）（inline）元素。当然块状元素也可以通过代码<code>display:inline</code>将元素设置为内联元素。<code>display:inline;</code></li>
<li>内联元素特点：1、和其他元素都在一行上；2、元素的高度、宽度及顶部和底部边距不可设置；3、元素的宽度就是它包含的文字或图片的宽度，不可改变。</li>
<li>联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码<code>display:inline-block</code>就是将元素设置为内联块状元素。(css2.1新增)，<code>&lt;img&gt;、&lt;input&gt;</code>标签就是这种内联块状标签。</li>
<li>inline-block 元素特点：1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置。</li>
<li>边框:<code>border:2px  solid  red;</code>对应:<code>border-width:2px;border-style:solid;border-color:red;</code>border-style（边框样式）常见样式有：<br>dashed（虚线）| dotted（点线）| solid（实线）。border-width（边框宽度）中的宽度也可以设置为：thin | medium | thick（但不是很常用），最常还是用像素（px）</li>
<li>单独设置下边框:<code>border-bottom:1px solid red;</code> top right left bottom</li>
<li>css内定义的宽（width）和高（height），指的是填充以里的内容范围。因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</li>
<li>元素与其它元素之间的距离可以使用边界（margin）来设置。</li>
<li>元素内容与边框之间是可以设置距离的，称之为“填充”<code>padding-top</code>。 顺时针:上 右 下 左  或者 上下 左右 或者 上下左右</li>
<li>CSS包含3种基本的布局模型，用英文概括为：Flow、Layer 和 Float。在网页中，元素有三种布局模型：1、流动模型（Flow）2、浮动模型 (Float)3、层模型（Layer）</li>
<li>流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。流动布局模型具有2个比较典型的特征：第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）</li>
<li>块状元素这么霸道都是独占一行，设置元素浮动就可以实现让两个块状元素并排显示。<br>任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动.<code>float:left;</code></li>
<li>层布局模型就像是图像软件PhotoShop中非常流行的图层编辑功能一样，每个图层能够精确定位操作.CSS定义了一组定位（positioning）属性来支持层布局模型。层模型有三种形式：1、绝对定位(position: absolute)2、相对定位(position: relative)3、固定定位(position: fixed)</li>
<li>设置position:absolute(表示绝对定位)，作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。对于以前位置(<strong>右上角</strong>）向左移动100像素，向下移动20像素。<code>right:100px;   top:20px;</code>right的是让right的margin变为100px，同理top是让top的margin变为20px，所以要向右和向下移。</li>
<li>如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。<code>position:relative;    left:100px;    top:50px;</code>（相对于以前位置<strong>左上角</strong>）向右移动100像素，向下移动50像素。</li>
<li>absolute表里如一，移动了就是移动了。relative只是表面显示移动了，但实际还在文档流中原有位置，别的元素无法占据。</li>
<li>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与<code>background-attachment:fixed;</code>属性功能相同。</li>
<li>使用<code>position:relative</code>,相对于其它元素进行定位,参照定位的元素必须是相对定位元素的前辈元素;参照定位的元素必须加入position:relative;定位元素加入position:absolute，便可以使用top、bottom、left、right来进行偏移定位了</li>
<li><p>参照物不是浏览器</p>
<pre><code>#box1{
    width:200px;
    height:200px;
    position:relative;        
    }

#box2{
    position:absolute;
    top:20px;
    left:30px;
    } //box2就可以相对于父元素box1定位
</code></pre></li>
<li><p>设置的颜色是16进制的色彩值时，如果每两位的值相同，可以缩写一半。<code>p{color:#000000;} == p{color:#000;} p{color: #336699;}==p{color: #369;}</code></p>
</li>
<li>字体的缩写<code>body{    font:12px/1.5em  &quot;宋体&quot;,sans-serif;}</code>1、使用这一简写方式你至少要指定 font-size 和 font-family 属性，其他的属性(如 font-weight、font-style、font-varient、line-height)如未指定将自动使用默认值。2、在缩写时 font-size 与 line-height 中间要加入“/”斜扛。</li>
<li>设置颜色值的三种方式:1,英文命令.2.RGB <code>p{color:rgb(133,45,200);}</code>每一项在0-255之间,也可以是百分数<code>p{color:rgb(20%,33%,25%);}</code>.3.十六进制(较普遍)<code>p{color:#00ffff;}</code></li>
<li><p>长度单位</p>
<pre><code>目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。
1、像素
像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS规范中假设“90像素=1英寸”）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。
2、em
就是本元素给定字体的 **font-size 值**，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。如下代码：
p{font-size:12px;text-indent:2em;}
上面代码就是可以实现段落首行缩进 24px（也就是两个字体大小的距离）。
下面注意一个特殊情况：
但当给 font-size 设置单位为 em 时，此时计算的标准以 p 的父元素的 font-size 为基础。如下代码：
html:
&lt;p&gt;以这个&lt;span&gt;例子&lt;/span&gt;为例。&lt;/p&gt;
css:
p{font-size:14px}
span{font-size:0.8em;}
结果 span 中的字体“例子”字体大小就为 11.2px（14 * 0.8 = 11.2px）。
3、百分比
p{font-size:12px;line-height:130%}
设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。
</code></pre></li>
<li><p>水平居中设置-行内元素:如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 <code>text-align:center</code>来实现的。</p>
</li>
<li>水平居中设置-定宽块状元素:当被设置元素为 块状元素 时用 <code>text-align：center</code>就不起作用了，这时也分两种情况：定宽块状元素和不定宽块状元素。定宽块状元素：块状元素的宽度width为固定值。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。</li>
<li><p>水平居中设置-不定宽块状元素方法（一）:(不定宽块状元素：块状元素的宽度width不固定。)不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）:1.加入 table 标签,为这个 table 设置“左右 margin 居中”（这个和定宽块状元素的方法一样,利用table标签的长度自适应性,可以看做一个定宽度块元素)<br>2.设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置3.设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的</p>
<pre><code>&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;&lt;td&gt;
    &lt;ul&gt;
        &lt;li&gt;我是第一行文本&lt;/li&gt;
        &lt;li&gt;我是第二行文本&lt;/li&gt;
        &lt;li&gt;我是第三行文本&lt;/li&gt;
    &lt;/ul&gt;
    &lt;/td&gt;&lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
或者直接设置`display:table; margin:0 auto;
`也即 .wrap{background:#ccc;display:table;margin:0 auto;
}
</code></pre></li>
<li><p>水平居中设置-不定宽块状元素方法（二）:改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。它将块状元素的 display 类型改为 inline，变成了行内元素，所以少了一些功能，比如设定长度值。</p>
</li>
<li>水平居中设置-不定宽块状元素方法（三）:通过给父元素设置 float值为left，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。</li>
<li>垂直居中-父元素高度确定的单行文本:设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。这种文字行高与块高一致带来了一个弊端：当文字内容的长度大于块的宽时，就有内容脱离了块。</li>
<li>垂直居中-父元素高度确定的多行文本（方法一）:插入 table标签，同时设置 vertical-align：middle。</li>
<li>垂直居中-父元素高度确定的多行文本（方法二）:设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式, 兼容性比较差。    <code>display:table-cell;/*IE8以上及Chrome、Firefox*/    vertical-align:middle;/*IE8以上及Chrome、Firefox*/</code></li>
<li>隐性改变display类型:有一个有趣的现象就是当为元素（不论之前是什么类型元素，display:none 除外）设置以下 2 个句之一： 1. position : absolute  2. float : left 或 float:right 简单来说，只要html代码中出现以上两句之一，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。</li>
</ul>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><ul>
<li>我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。放在<head><meta name="generator" content="Hexo 3.8.0">部分最常用的方式是在页面中head部分放置script&gt;元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。</head></li>
<li><p>放在<body>部分JavaScript代码在网页读取到该语句的时候就会执行。注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。</body></p>
<pre><code> &lt;script type=&quot;text/javascript&quot;&gt;
  document.write(&quot;I love JS&quot;)
&lt;/script&gt;
</code></pre></li>
<li>单行注释，在注释内容前加符号 “//”。多行注释以”/<em>“开始，以”</em>/“结束。</li>
<li>1.变量必须使用字母、下划线(<em>)或者美元符(<code>$</code>)开始。2.然后可以使用任意多个英文字母、数字、下划线(</em>)或者美元符(<code>$</code>)组成。 3.不能使用JavaScript关键词与JavaScript保留字。变量要先声明再赋值，JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。</li>
<li>document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。第一种:输出内容用””括起，直接输出””号内的内容。第二种:通过变量，输出内容.第三种:输出多项内容，内容之间用+号连接。第四种:输出HTML标签，并起作用，标签使用<code>&quot;&quot;</code>括起来。<code>document.write(mystr+&quot;&lt;br&gt;&quot;);</code></li>
<li>js输出空格:<code>&quot;&amp;nbsp;”</code>或者<code>document.write(&quot;&lt;span style=&#39;white-space:pre;&#39;&gt;&quot;+&quot;  1        2    3    &quot;+&quot;&lt;/span&gt;”);</code>输出时添加<code>“white-space:pre;”</code>样式属性。这个样式表示”空白会被浏览器保留”</li>
<li>JavaScript-警告（alert 消息对话框）</li>
<li><p>JavaScript-确认（confirm 消息对话框）弹出对话框(包括一个确定按钮和一个取消按钮)。 <code>confirm(str);</code>当用户点击”确定”按钮时，返回true当用户点击”取消”按钮时，返回false</p>
<pre><code>function rec(){
   var mymessage=confirm(&quot;你好棒&quot;)         ;
   if(mymessage==true)
   {
       document.write(&quot;你是女士!&quot;);
   }
   else
   {
       document.write(&quot;你是男士!&quot;);
   }
 }    
</code></pre></li>
<li><p>JavaScript-提问（prompt 消息对话框）弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。<code>prompt(str1, str2);</code>str1: 要显示在消息对话框中的文本，不可修改,str2：文本框中的内容，可以修改.1. 点击确定按钮，文本框中的内容将作为函数返回值2. 点击取消按钮，将返回null.注:在用户点击对话框的按钮前，不能进行任何其它操作。</p>
<pre><code>score =  prompt(&quot;哈喽哈&quot;,&quot;默认值&quot;);
if(score&gt;=90)
{
   document.write(&quot;你很棒!&quot;);
}
</code></pre></li>
<li><p>JavaScript-打开新窗口（window.open）<code>window.open([URL], [窗口名称], [参数字符串])</code></p>
<pre><code>           URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。
          窗口名称：可选参数，被打开窗口的名称。                  

 1.该名称由字母、数字和下划线字符组成。
 2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。
    _blank：在新窗口显示目标网页
    _self：在当前窗口显示目标网页
    _top：框架网页中在上部窗口中显示目标网页
 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。
4.name 不能包含有空格。
</code></pre></li>
<li><p>参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。toolbar工具栏,scrollbars滚动条,status状态栏menubar菜单栏 值为yes/no 窗口宽高度width/height以及窗口顶部/左端距离屏幕顶部的像素数top/left  </p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt; window.open(&apos;http://www.imooc.com&apos;,
&apos;_blank&apos;,&apos;width=300,height=200,
menubar=no,toolbar=no, status=no,scrollbars=yes’)
    &lt;/script&gt;
</code></pre></li>
</ul>
<ul>
<li><p>JavaScript-关闭窗口（window.close）</p>
<pre><code> window.close();   //关闭本窗口
 &lt;窗口对象&gt;.close();   //关闭指定的窗口
 &lt;script type=&quot;text/javascript&quot;&gt;
   var mywin=window.open(&apos;http://www.imooc.com&apos;); //将新打的窗口对象，存储在变量mywin中
   mywin.close();
&lt;/script&gt;
</code></pre></li>
<li>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</li>
<li><p>HTML文档可以说由节点构成的集合，三种常见的DOM节点:1. 元素节点：上图中<code>&lt;html&gt;、&lt;body&gt;、&lt;p&gt;</code>等都是元素节点，即标签。2. 文本节点:向用户展示的内容，如<code>&lt;li&gt;...&lt;/li&gt;</code>中的JavaScript、DOM、CSS等文本。3. 属性节点:元素属性，如<code>&lt;a&gt;</code>标签的链接属性<code>href=&quot;http://www.chenyalun.com&quot;</code>。</p>
</li>
<li><p>通过ID获取元素:<code>document.getElementById(“id”)</code>,返回<code>[object HTMLParagraphElement]</code> ,注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。用<code>document.getELementById().innerHTML;</code>才可以获取到其中的内容.</p>
</li>
<li>innerHTML 属性用于获取或替换 HTML 元素的内容。Object.innerHTML,1.Object是获取的元素对象，如通过document.getElementById(“ID”)获取的元素。2.注意书写，innerHTML区分大小写。</li>
<li>改变 HTML 样式:<code>Object.style.property=new style;</code>例如:<code>mychar.style.color=red;</code></li>
<li>显示和隐藏（display属性）Object.style.display = value,其中value为none隐藏,value为block块级元素显示.其中none与block要加上引号</li>
<li>控制类名（className 属性）className 属性设置或返回元素的class 属性。<code>object.className = classname</code>作用:1.获取元素的class 属性2. 为网页内的某个元素指定一个css样式来更改该元素的外观</li>
<li>删除修改的样式:<code>document.getElementById(&quot;txt&quot;).removeAttribute(&quot;style&quot;);</code></li>
<li>外部引入JS <code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></li>
<li>变量:字母数字下划线美元符,变量名区分大小写,不允许使用关键字保留字</li>
<li>变量也可以不声明，直接使用，但为了规范，需要先声明，后使用。</li>
<li>“+”连接字符串时,符号两边不能有空格</li>
<li><code>jq1=numa + 30 &gt;10 &amp;&amp; numb * 3&lt;20;</code>算术操作符 → 比较操作符 → 逻辑操作符 → “=”赋值符号</li>
<li>定义数组: <code>var myarr=new Array();  myarr[0]=80;</code>实际上数组都是变长的,即使指定了长度为8，仍然可以将元素存储在规定长度以外。</li>
<li>创建数组:<code>var myarr = new Array(11,25,35); var myarr = [12,25,416];</code></li>
<li>只需使用下一个未用的索引，任何时刻可以不断向数组增加新元素。<code>myarray[5]=88; //使用一个新索引，为数组增加一个新元素</code></li>
<li>数组的属性:length长度</li>
<li>二维数组的表示:<code>myarray[ ][ ]</code>,简单定义:<code>var Myarr = [[0 , 1 , 2 ],[1 , 2 , 3]]</code>,也可以使用循环,myarr[0][1]=5; //将5的值传入到数组中，覆盖原有值。</li>
<li><code>==先转换类型再比较，===先判断类型，如果不是同一类型直接为false。</code></li>
<li>函数调用的两种情况:1.script标签中直接调用,2.点击按钮调用onClick事件</li>
<li>有参数的函数:<code>function 函数名(参数1,参数2){     函数代码}</code>,参数不要声明类型</li>
<li><code>function add2(x,y){   sum = x + y;   return sum; //返回函数值,return后面的值叫做返回值。}</code></li>
<li>事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。</li>
<li><p>常用JS事件:</p>
<pre><code>onclick鼠标单击事件
onmouseover鼠标经过事件
onmouseout鼠标移开事件
onchange文本框**内容**改变事件,一般是textarea
onselect文本框**内容**选中事件,一般是textarea
onfocus光标聚焦
onblur光标移开
onload网页加载后,事件会在页面加载完成后，立即发生，同时执行被调用的程序。
加载页面时，触发onload事件，**事件写在&lt;body&gt;标签内**。
onunload卸载事件,当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，
同时执行被调用的程序。该事件目前只对IE起作用。
</code></pre></li>
<li><p>使用parseInt()函数可解析一个字符串,并返回一个整数。</p>
</li>
<li>JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。对象的属性：反映该对象某些特定的性质的，如：字符串的长度、图像的长宽等；对象的方法：能够在对象上执行的动作。例如，表单的“提交”(Submit)，时间的“获取”(getYear)等；</li>
</ul>
<h2 id="Date日期对象"><a href="#Date日期对象" class="headerlink" title="Date日期对象"></a>Date日期对象</h2><ul>
<li><p>日期对象,使用关键字new，Date()的首字母必须大写。</p>
<pre><code>// 日期的相关属性与方法
get/setDate() 返回设置日期
get/setFullYear()  返回设置年份,用四位数表示
get/setYear() 返回/设置年份
get/setMonth() 返回/设置月份
get/setHours() 返回/设置小时,24小时制
get/setMinutes() 返回/设置分钟数
get/setSeconds() 返回/设置秒钟数
get/setTime() 返回/设置时间(毫秒为单位)
getDay() 返回星期，返回的是0-6的数字，0 表示星期天。
</code></pre></li>
<li><p>使用 String 对象的 toUpperCase() 方法来将字符串小写字母转换为大写.使用toLowerCase()方法，将字符串所有大写字母都变成小写的字符串</p>
</li>
<li>charAt() 方法可返回指定位置的字符。返回的字符是长度为 1 的字符串。</li>
<li>注意：1.字符串中第一个字符的下标是 0。最后一个字符的下标为字符串长度减一（string.length-1）。2.如果参数 index 不在 0 与 string.length-1 之间，该方法将返回一个空字符串。</li>
<li>indexOf(,) 方法可返回某个指定的字符串值在字符串中首次出现的位置。1.该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 substring。2.可选参数，从stringObject的startpos位置开始查找substring，如果没有此参数将从stringObject的开始位置查找。3.如果找到一个 substring，则返回 substring 的第一次出现的位置。stringObject 中的字符位置是从 0 开始的。</li>
<li>split(separator,limit) 方法将字符串分割为字符串数组，并返回此数组。注意：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。separator必须,从该参数指定的地方分割stringObject,limite,可选参数,分割的次数,如果设置该参数,则返回的子串不会多于这个参数指定的数组,如果无参数,则不限定次数</li>
<li>substring(起始位置,可选的结束位置(不包含该位置的字符)) 方法用于提取字符串中介于两个指定下标之间的字符。注意：1. 返回的内容是从 start开始(包含start位置的字符)到 stop-1 处的所有字符，其长度为 stop 减start。2. 如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。3. 如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。</li>
<li>substr() 方法从字符串中提取从 startPos位置开始的指定数目的字符串。<code>stringObject.substr(startPos,length)</code>  注意：如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。如果startPos为负数且绝对值大于字符串长度，startPos为0。</li>
<li>string.substring( 起点 ， 终点 )  string.substr( 起点 ，长度 )</li>
<li>Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。</li>
</ul>
<h2 id="MATH常用属性方法"><a href="#MATH常用属性方法" class="headerlink" title="MATH常用属性方法"></a>MATH常用属性方法</h2><ul>
<li><p>MATH</p>
<pre><code>E 返回算数常量e(约为2.71828)
LN2 返回2的自然对数
LN10 返回10的自然对数
LOG2E 返回以2为底的e的对数
LOG10E 返回以10为底的e的对数
PI 圆周率
SQRT1_2 返回2的平方根的倒数
SQRT2 返回2 的平方根
MATH常用方法
abs(x) 返回数的绝对值
acos(x) 返回数的反余弦值
asin(x) 返回数的反正弦值
atan(x) 返回数的反正切值
atan2(y,x)返回由x轴到点(x,y)的角度(以弧度为单位)
ceil(x)对数进行上舍入
cos(x) 返回数的余弦
exp(x) 返回e的指数
floor(x)对数进行下舍入
log(x) 返回数的自然对数
max(x,y) 返回最高值
min(x,y) 返回最小值
pow(x,y) 返回x的y 次方
random() 返回0--1之间的随机数
round(x) 把数四舍五入最为接近的数
sin(x) 正弦
cos(x) 余弦
tan(x) 正切
sqrt(x) 平方根
toSourse() 返回该对象的源代码
value() 返回MATH对象的原始值
</code></pre></li>
</ul>
<h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><ul>
<li><p>数组</p>
<pre><code>concat() 连接两个或更多的数组,并返回结果
join() 把数组的所有元素放入一个字符串,元素通过指定的分隔符分割
pop() 删除并返回数组的最后一个元素
push() 向数组的末尾添加一个或更多元素,并返回新的长度
reverse() 颠倒数组元素的顺序
shift() 删除并返回数组的第一个元素
slice(start,可选的end) 从某个已有的数组返回选定的元素
sort() 对数组的元素进行排序
splice() 删除元素,并向数组添加新元素
toSource() 返回该对象的源代码
toString() 把数组转换为字符串,并返回结果
toLocalString() 把数组转化为本地数组,并返回结果
unshift() 向数组的开头添加一个或者更多元素,并返回新的长度()
valueOf() 返回数组对象的原始值
</code></pre></li>
</ul>
<h2 id="window对象方法"><a href="#window对象方法" class="headerlink" title="window对象方法"></a>window对象方法</h2><ul>
<li><p>window</p>
<pre><code>alert() 显示带有一段消息和一个确定按钮的警告框
prompt() 显示可以提示用户输入的对话框
confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框
open() 打开一个新的浏览器窗口或者查找一个已命名的窗口
close() 关闭浏览器窗口
print() 打印当前窗口的内容
focus() 把键盘焦点给予一个窗口
blur() 把键盘焦点从顶层窗口移开
moveBy() 相对窗口的当前坐标移动指定的像素
moveTo() 把窗口的左上角移动一个指定的坐标
resizeBy() 按照指定的像素调整窗口的大小
resizeTo() 把窗口的大小调整到指定的宽度和高度
scrollBy() 按照指定的像素滚动内容
scrollTo() 把内容滚动到指定的坐标
setInterval(代码,间隔时间) 每隔一定时间执行代码(间隔性触发计时器),在执行时,从载入页面后每隔指定的时间执行代码。代码:函数或代码串,如”clock()”或者clock,交互时间:以毫秒为单位.返回该定时器
setTimeout() 在指定的时间延迟后指定代码(一次性计时器)
clearInterval() 取消setInterval() 的设置,传入定时器
clearTimeout() 取消setTimeout() 的设置
</code></pre></li>
</ul>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><ul>
<li><p>history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。<code>window.history.[属性|方法]</code></p>
<pre><code>length 返回浏览器历史列表的URL数量
back() 加载history列表中前一个URL
forward() 加载history列表下一个URL
go(number) 加载history列表某一个具体的页面,0:当前页面
back()相当于go(-1),forward()相当于go(1)
</code></pre></li>
</ul>
<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><ul>
<li><p>location用于获取或设置窗体的URL，并且可以用于解析URL。<code>location.[属性|方法]</code></p>
<pre><code>hash 设置或返回从#开始的URL(锚点)
host 设置或返回主机名和当前URL的端口号
hostname 设置或返回当前URL的主机名
href 设置或返回完成的URL
pathname 设置或返回当前URL的路径部分
port 设置或返回当前URL的端口号
protocol 设置或返回当前URL的协议
search 设置或者返回从?开始的URL(查询部分)
assign() 加载新的文档
reload() 重新加载当前文档
replace() 用新的文档替换当前文档
</code></pre></li>
</ul>
<h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><ul>
<li><p>navigator 对* navigator 对象包含有关浏览器的信息</p>
<pre><code>appCodeName 浏览器代码名的字符串表示
appName 浏览器的名称
appVersion 浏览器平台以及版本
platform 运行浏览器的操作系统平台
userAgent 返回user-agent头部的值
</code></pre></li>
</ul>
<h2 id="window中的screen-对象"><a href="#window中的screen-对象" class="headerlink" title="window中的screen 对象"></a>window中的screen 对象</h2><ul>
<li>window.screen 对象在编写时可以不使用 window 这个前缀。</li>
<li><p>screen对象用于获取用户的屏幕信息。<code>window.screen.属性</code>    </p>
<pre><code>height 屏幕的高度,单位像素
width  屏幕的宽度,单位像素
availHeight 窗口可用的屏幕高度,单位像素,减去界面特性，比如任务栏。
availWidth 窗口可用的屏幕宽度,单位像素,减去界面特性，比如任务栏。
colorDepth 用户浏览器表示的颜色位数,通常32位(每像素的位数)
pixelDepth 浏览器颜色位数,通常32位(每像素的位数)(IE不支持)
</code></pre></li>
</ul>
<h2 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h2><ul>
<li><p>节点属性与方法</p>
<pre><code>nodeName 返回一个字符串,其内容是给定节点的名字
nodeType 返回一个整数,这个数值代表给定节点的类型
nodeValue 返回给定节点的当前值
innerHTML 节点内置文本
childNodes 返回一个数组,这个数组由给定元素节点的子节点构成
firstChild 返回第一个子节点
lastChild 返回最后一个子节点
parentNode 返回一个给定节点的父节点
nextSibling返回给定节点的下一个子节点
previousSibling 返回给定节点的上一个子节点
document.createElement(&quot;elementType&quot;) 创建一个新的元素节点

document.cr    document.createTextNode(&quot;text&quot;) 创建一个包含着给定文本的新文本节点,text为文本
appendChild(node) 指定节点的最后一个子节点列表后添加一个新的子节点
insertBefore(newnode,node) 将一个给定节点插入到一个给定元素节点的给定节点前面
removeChild(node) 从一个给定元素中删除一个子节点
replaceChild(newnode,oldnew) 把一个给定元素里的一个子节点替换为另外一个节点
</code></pre><h3 id="docuument常用方法"><a href="#docuument常用方法" class="headerlink" title="docuument常用方法"></a>docuument常用方法</h3></li>
<li>document.getElementsByName(name) 返回带有指定名称的节点对象的集合。与getElementById() 方法不同的是，通过元素的 name 属性查询元素，而不是通过 id 属性</li>
<li>document.getElementsByTagName(Tagname)  Tagname是标签的名称，如p、a、img等标签名。和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。</li>
<li>elementNode.getAttribute(name),其中elementNode：使用getElementById()、getElementsByTagName()等方法，获取到的元素节点.name：要想查询的元素节点的属性名字.</li>
<li>elementNode.setAttribute(name,value),name: 要设置的属性名。value: 要设置的属性值。把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。</li>
<li><p>在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：nodeName : 节点的名称,nodeValue ：节点的值,nodeType ：节点的类型</p>
</li>
<li><p>nodeName 属性: 节点的名称，是只读的。</p>
<pre><code>1. 元素节点的 nodeName 与标签名相同
2. 属性节点的 nodeName 是属性的名称
3. 文本节点的 nodeName 永远是 #text
4. 文档节点的 nodeName 永远是 #document
</code></pre></li>
<li><p>nodeValue 属性：节点的值</p>
<pre><code>1. 元素节点的 nodeValue 是 undefined 或 null
2. 文本节点的 nodeValue 是文本自身
3. 属性节点的 nodeValue 是属性的值
</code></pre></li>
<li><p>nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型:</p>
<pre><code>元素类型    节点类型
  元素          1
  属性          2
  文本          3
  注释          8
  文档          9
</code></pre></li>
<li><p>elementNode.childNodes,访问子节点.</p>
</li>
<li>node.firstChild,node.lastChild,访问子节点的第一项,最后一项,如果选定的节点没有子节点，则该属性返回 NULL。</li>
<li>elementNode.parentNode,获取指定节点的父节点,父节点只能有一个。览器兼容问题，chrome、firefox等浏览器标签之间的空白也算是一个文本节点。</li>
<li><code>nodeObject.nextSibling,nodeObject.previousSibling</code>,访问兄弟节点</li>
<li>appendChild(newnode),在指定节点的最后一个子节点列表之后添加一个新的子节点。</li>
<li>removeChild(),把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。如果要完全删除对象，给 x 赋 null 值</li>
<li><code>document.documentElement.clientHeight</code>表示HTML文档所在窗口的当前高度。,<code>window.innerHeight</code>- 浏览器窗口的内部高度,<code>document.body.clientHeight</code>,Document对象的body属性对应HTML文档的<body>标签</body></li>
<li><p>通用解决方案:</p>
<pre><code>var w=document.documentElement.scrollWidth
   || 
   document.body.scrollWidth;
var h=document.documentElement.scrollHeight
   || 
   document.body.scrollHeight;
</code></pre></li>
</ul>
<ul>
<li>网页尺寸:scrollHeight和scrollWidth，获取网页内容高度和宽度。scrollHeight 是网页内容实际高度，可以小于 clientHeight。scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。</li>
<li><p>通用解决方案:</p>
<pre><code>var w=document.documentElement.scrollWidth || 
document.body.scrollWidt h;
var h=document.documentElement.scrollHeight || 
document.body.scrollHeight;
</code></pre></li>
<li><p>offsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。</p>
</li>
<li><p>通用解决方案</p>
<pre><code>var w= document.documentElement.offsetWidth || 
document.body.offsetWidth;
var h= document.documentElement.offsetHeight || 
document.body.offsetHeight;       
</code></pre></li>
<li><p>scrollLeft:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。</p>
</li>
<li>scrollTop:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。</li>
<li>offsetLeft:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。</li>
<li>offsetTop:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。</li>
<li>offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。</li>
<li>clientHeight,大家对 clientHeight 都没有什么异议，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个工具条以下到状态栏以上的这个区域，与页面内容无关。</li>
<li>offsetHeight,IE、Opera 认为 offsetHeight = clientHeight + 滚动条 + 边框。,NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。</li>
<li>scrollHeight,IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。,NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。</li>
<li>浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;</li>
<li>JavaScript不区分整数和浮点数，统一用Number表示</li>
<li>NaN;NaN表示Not a Number，当无法计算结果时用NaN表示.Infinity;Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</li>
<li><code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；<br>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。始终坚持使用===比较</li>
<li>NaN这个特殊的Number与所有其他值都不相等，包括它自己,唯一能判断NaN的方法是通过isNaN()函数,<code>isNaN(NaN); // true</code></li>
<li>Swift用nil，Python用None表示,JavaScript用null</li>
<li>JavaScript的数组可以包括任意数据类型。</li>
<li>JavaScript的对象是一组由键-值组成的无序集合,JavaScript对象的键都是字符串类型，值可以是任意数据类型。</li>
<li>变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。</li>
<li>如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量,在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误,启用strict模式的方法是在JavaScript代码的第一行写上：<code>&#39;use strict&#39;;</code></li>
<li><code></code>你好, ${name}, 你今年${age}岁了!<code>;</code>注意不是单引号</li>
<li>直接给Array的length赋一个新的值会导致Array大小的变化,如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化</li>
<li>空数组继续pop不会报错，而是返回undefined,如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉</li>
<li>空数组继续shift不会报错，而是返回undefined</li>
<li>splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素,从索引2开始删除3个元素,然后再添加两个元素:<code>arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook’);</code></li>
<li>concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里</li>
<li>unshift()和push()对应,头部添加若干元素,shift()和pop()对应删除末尾元素.</li>
<li><p>声明对象</p>
<pre><code>var person = {
name : “AA”,
age : 12,
&apos;m-s&apos;: &apos;No&apos;,// 非有效变量
sex : true
};
// 访问:person.name;  person[&apos;m-s&apos;]; person.a;
// 访问不存在的属性不报错，而是返回undefined
// 自由增加属性:person.b = 12;
// 删除属性 delete person.age;
// 检测对象以及父类具有某属性 &apos;name&apos; in person 返回布尔
// 检测某对象具有某属性 person.hasOwnProperty(&apos;name&apos;); 返回布尔
</code></pre></li>
<li><p>JavaScript把null、undefined、0、NaN和空字符串’’视为false，其他值一概视为true</p>
</li>
<li>for (var index in array) {// 此处的index是索引而非array中的元素}</li>
<li><p>Map是一组键值对的结构，具有极快的查找速度。<br><code>var m = new Map([[&#39;Michael&#39;, 95], [&#39;Bob&#39;, 75], [&#39;Tracy&#39;, 85]]); m.get(&#39;Michael&#39;); // 95</code><br>常用操作:</p>
<pre><code>var m = new Map(); // 空Map
m.set(&apos;Adam&apos;, 67); // 添加新的key-value
m.set(&apos;Bob&apos;, 59);
m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: true
m.get(&apos;Adam&apos;); // 67
m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;
m.get(&apos;Adam&apos;); // undefined
</code></pre></li>
<li><p>Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。<code>var s2 = new Set([1, 2, 3]); // 含1, 2, 3</code>.通过add(key)方法可以添加元素到Set中,通过delete(key)方法可以删除元素</p>
</li>
<li>遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for … of循环来遍历。</li>
<li>for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。索引+属性</li>
<li>for … of循环则完全修复了这些问题，它只循环集合本身的元素,元素本身</li>
<li><p>forEach遍历</p>
<pre><code>var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];
a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
    alert(element);
});

var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);
s.forEach(function (element, sameElement, set) {
    alert(element);
});

var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);
m.forEach(function (value, key, map) {
    alert(value);
});
</code></pre></li>
<li>JavaScript允许传入任意个参数而不影响调用,传入的参数比定义的少也没有问题</li>
<li>JavaScript还有一个关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。类似数组不是数组</li>
<li><p>不在任何函数内定义的变量就具有全局作用域。全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。</p>
<pre><code>// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = &apos;myapp&apos;;
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return &apos;foo&apos;;
};
</code></pre></li>
<li>JavaScript的变量作用域实际上是函数内部,用let替代var可以申明一个块级作用域的变量,const来定义常量，const与let都具有块级作用域</li>
<li>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字</li>
<li>非strict环境下:直接使用this没毛病,strict环境下:函数内部首先写上var that = this;之后使用that</li>
<li>据是否是strict模式，this指向undefined或window</li>
<li>apply()把参数打包成Array再传入；  call()把参数按顺序传入。</li>
<li>简单的高阶函数:一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</li>
<li><p>map():对<strong>数组</strong>中的每一个且仅是单独的元素执行操作,</p>
<pre><code>// 把每一个元素转化为字符串 ,得到的仍是数组
array.map(String)

// 执行pow()
function pow(x) {
    return x * x;
}
array.map(pow),得到的仍是数组
</code></pre></li>
<li><p>reduce():对<strong>数组</strong>中的最开始两个元素进行操作,将结果与第三个元素操作,以此类推</p>
<pre><code>// 数组求和
arr.reduce(function (x, y) {
    return x + y;
});
</code></pre></li>
<li><p>filter():根据传入的函数,作用于每一个元素,返回true或false,把数组中的某些元素过滤掉,返回剩余的元素</p>
<pre><code>var r = arr.filter(function (s) {
    return  x % 2 !== 0; 
            });
arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]
</code></pre></li>
<li>sort():排序,默认把所有元素先转换为String再排序,传入的排序函数,根据返回-1进行排序</li>
<li><p>箭头函数:在箭头函数中,可以直接使用this,而非that</p>
<pre><code>x =&gt; x*x
// 相当于
function (x) {
return x*x;
}
// 含有多条语句,多个参数时
(x,y) =&gt; {
if (x &gt;0 ) {
return 0;
}
return x*y;
}
// 不能省略{}
// 特别注意返回一个对象:
x =&gt; ({ foo: x })
</code></pre></li>
<li><p>generator和函数不同的是，generator由function*定义,除了return语句，还可以用yield返回多次。调用generator对象有两个方法，一是不断地调用generator对象的next()方法,第二个方法是直接用for … of循环迭代generator对象</p>
</li>
<li>用typeof操作符获取对象的类型，它总是返回一个字符串:’number’,’boolean’,’string’,’function’,’object’,’undefined’,特别注意null的类型是object，Array的类型也是object</li>
<li>包装对象:<code>var n = new Number(123);</code>,返回object</li>
<li>JavaScript的月份范围用整数表示是0~11，0表示一月，1表示二月</li>
<li>RegExp中:在正则表达式中，如果直接给出字符，就是精确匹配。<code>用\d可以匹配一个数字，\w可以匹配一个字母或数字,.可以匹配任意字符，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符,\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格</code></li>
<li>更精确的匹配,[]表示范围:<code>[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线,[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串,[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）,A|B可以匹配A或B,^表示行的开头，^\d表示必须以数字开头。$表示行的结束，\d$表示必须以数字结束。js也可以匹配&#39;jsp&#39;，但是加上^js$就变成了整行匹配，就只能匹配&#39;js&#39;了</code></li>
<li><p>JavaScript有两种方式创建一个正则表达式：第一种方式是直接通过/正则表达式/写出来，第二种方式是通过new RegExp(‘正则表达式’)创建一个RegExp对象。</p>
<pre><code>var re1 = /as\_32/; // 最好,不用考虑转义问题
var re2 = new RegExp(“as\\_32”);
// 如果使用第二种写法，因为字符串的转义问题，字符串的两个\\实际上是一个\

//RegExp对象的test()方法用于测试给定的字符串是否符合条件
re1.test(&apos;sfdf&apos;);// 返回false
</code></pre></li>
<li><p>用()表示的就是要提取的分组（Group）,exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。exec()方法在匹配失败时返回null</p>
<pre><code>var re = /^(\d{3})-(\d{3,8})$/;
re.exec(&apos;010-12345&apos;); // [&apos;010-12345&apos;, &apos;010&apos;, &apos;12345&apos;]
</code></pre></li>
<li>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符,加个?就可以让\d+采用非贪婪匹配</li>
<li><code>g表示全局匹配,var r1 = /test/g;// 等价于:var r2 = new RegExp(&#39;test&#39;, &#39;g&#39;);指定i标志，表示忽略大小写，m标志，表示执行多行匹配</code></li>
<li>注意,在范围匹配[]中,字符要加上反斜杠\,在一般匹配中不需要</li>
<li><code>[a-zA-Z_]其实就是\w</code></li>
<li>JSON序列化:JSON.stringify(object,[propertyName:value],’  ‘); 第二个参数用于控制如何筛选对象的键值，标明指定属性可以输出指定的属性,也可以传入函数进行处理,可以不写,第三个参数是缩进</li>
<li>反序列化:JSON.parse()把它变成一个JavaScript对象</li>
<li>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。<code>xiaoming.__proto__ = Student;</code></li>
<li>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</li>
<li>如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;</li>
<li>造函数首字母应当大写，而普通函数首字母应当小写</li>
</ul>
<p><br></p>
<p>花了一个周末学习一下前端方面的知识,笔记略微粗糙,复习时再做修正.</p>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/笔记/">笔记</a>
            
              <a href="/tags/HTML/">HTML</a>
            
              <a href="/tags/CSS/">CSS</a>
            
              <a href="/tags/JavaScript/">JavaScript</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/12/20/Python3入门笔记/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Python3入门笔记</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2016/10/28/泛读博客笔记/">
        <span class="next-text nav-default">泛读博客笔记</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
