<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ios开发," />





  <link rel="alternate" href="/atom.xml" title="Ya" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="许多鞭辟入里的文章.">
<meta property="og:type" content="article">
<meta property="og:title" content="读「王中周博客」">
<meta property="og:url" content="http://blog.chenyalun.com/2016/11/10/读王中周博客/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="许多鞭辟入里的文章.">
<meta property="og:updated_time" content="2016-12-28T10:03:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读「王中周博客」">
<meta name="twitter:description" content="许多鞭辟入里的文章.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 11510108,
      author: 'YA'
    }
  };
</script>




  <link rel="canonical" href="http://blog.chenyalun.com/2016/11/10/读王中周博客/"/>

  <title> 读「王中周博客」 | Ya </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-82867422-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Ya</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Write Less, Do More.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />
            
            时间线
          </a>
        </li>
      
        
        <li class="menu-item menu-item-reading">
          <a href="/categories/阅读/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            阅读
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                读「王中周博客」
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-10T16:02:17+08:00" content="2016-11-10">
              2016-11-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/阅读/" itemprop="url" rel="index">
                    <span itemprop="name">阅读</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p align="center"> 许多鞭辟入里的文章. </p>

<a id="more"></a>
<p>标注的文章:<br><a href="http://blog.csdn.net/wzzvictory/article/details/22417181" target="_blank" rel="external">Core Animation系列之CADisplayLink</a> </p>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/17694129" target="_blank" rel="external">Objective-C高级编程：iOS与OS X多线程和内存管理</a> </p>
<h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>零零碎碎花了一个多星期才把博客看完,文章比较详细,许多底层的东西我读了好几遍才理解,受益匪浅,把重要的知识点记下来,作复习之用.</p>
<h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><ol>
<li><p>self 是类的隐藏的参数，指向当前调用方法的类，另一个隐藏参数是 _cmd，代表当前类方法的 selector。</p>
</li>
<li><p>super 只是一个“编译器指示符”(编译器特性)，它和 self 指向的是相同的消息接收者。不同的是，super 告诉编译器，要去调用父类的方法，而不是本类里的。</p>
</li>
<li><p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法。</p>
</li>
<li><p>消息发送</p>
</li>
</ol>
<p><code>id objc_msgSend(id theReceiver, SEL theSelector, ...)</code></p>
<p>以<code>[self setName:]</code> 为例，编译器会替换成调用<code>objc_msgSend</code> 的函数调用，其中 theReceiver 是 self，theSelector 是 <code>@selector(setName:)</code>，这个 selector 是从当前 self 的 class 的方法列表开始找的 setName，当找到后把对应的 selector 传递过去。</p>
<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
struct objc_super {
    id receiver;
   Class superClass;
};
</code></pre><p> 而当使用<code>[super setName]</code> 调用时，会使用 <code>objc_msgSendSuper</code> 函数，结构体包含了两个成员，一个是 receiver，这个类似objc_msgSend 的第一个参数 receiver，第二个成员是记录所谓的“父类”。从 objc_super 结构体指向的 superClass 的方法列表开始找 setName 的 selector，找到后再以 <code>objc_super-&gt;receiver</code> 去调用这个 selector。</p>
<ol>
<li><p>NSNotification使用的是同步操作，如果想让NSNotification的post处和observer处异步执行，可以通过NSNotificationQueue实现。</p>
</li>
<li><p>对于同一个通知，如果注册了多个观察者，则这多个观察者的执行顺序和他们的注册顺序是保持一致的。observer的回调方法执行线程和post的线程保持一致，如果想让post的线程和转发的线程不同，可以通过NSNotification重定向技术实现。</p>
</li>
<li><p>addObserver和removeObserver必须成对出现，或者说添加了Observer必须适时移除Observer。因为通知中心并不retain Observer，若不移除，会极易给释放的对象发送消息。</p>
</li>
</ol>
<ol>
<li><p>普屏中1点 = 1像素，Retina屏：1点 = 2像素。人手指的最小点击范围是44pixels，所以在iPhone的很多细节上都是44 pixels。</p>
</li>
<li><p>使用图片资源时，方法：<code>[UIImage imageNamed:@&quot;adflower.png&quot;]]</code>，在实际运行时，如果发现当前的设备是Retina屏，会自动寻找图片”adflower@2x.png”。</p>
</li>
<li><p><code>[UIScreen mainScreen].applicationFrame</code>获取app尺寸(去掉状态栏)，<code>[ UIScreen mainScreen].bounds</code>获取屏幕尺寸，<code>[[UIApplicationsharedApplication] statusBarFrame]</code>状态栏尺寸。</p>
</li>
</ol>
<ol>
<li><p>在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是类对象(class object),它是一个单例(singleton),这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。</p>
</li>
<li><p>任何直接或间接继承了NSObject的类，它的实例对象(instance objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个  <strong>实例对象(instace object)</strong>  所属的类的定义的一切：包括变量，方法，遵守的协议等等。</p>
</li>
<li><p>类对象并不是类的实例本身。它没有自己的实例变量，也不能执行类的实例的方法。</p>
</li>
<li><p>类对象是一个功能完整的对象，也能被动态识别（dynamically typed），接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量），只是在运行时产生实例的代理。</p>
</li>
<li><p>类对象是元类对象的一个实例，元类是根元类(root class’s metaclass)的实例,而根元类是其自身的实例，即根元类的isa指针指向自身。</p>
</li>
<li><p>一个消息发送给任何一个对象， 方法的检查 从对象的 isa 指针开始，然后是父类。实例方法在类中定义， 类方法 在元类和根类中定义。（根类的元类就是根类自己）。</p>
</li>
<li><p>类对象(class object)中包含了类的实例变量、实例方法的定义，而元类对象(metaclass object)中包括了类的类方法的定义。类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。</p>
</li>
<li><p>①object_getClass跟随实例的isa指针，返回此实例所属的类，对于实例对象(instance)返回的是类(class),对于类(class)则返回的是元类(metaclass),<br>②<code>- class</code>方法对于实例对象(instance)会返回类(class),但对于类(class)则不会返回元类(metaclass),而只会返回类本身。<br>③class_isMetaClass可判断某类是否为元类.<br>④使用objc_allocateClassPair可在运行时创建新的类与元类对，使用class_addMethod和class_addIvar可向类中增加方法和实例变量，最后使用objc_registerClassPair注册后，就可以使用此类了。</p>
</li>
</ol>
<ol>
<li>alloc方法</li>
</ol>
<p>通过alloc或allocWithZone方法创建对象时，</p>
<ol>
<li>cocoa会遍历该对象所有的成员变量，通过成员变量的类型来计算所需占用的内存返回一个未”初使化“过的对象。</li>
<li>将该新对象的引用计数(Retain Count)设置成1。</li>
<li>该新对象的isa成员变量指向它的类对象。</li>
<li>将该新对象的所有其它成员变量的值设置成零。（根据成员变量类型的不同，零有可能是指nil或0）</li>
<li>返回指向该对象的一个指针。</li>
</ol>
<ol>
<li>init方法</li>
</ol>
<p>大部分情况下，我们都不希望所有成员变量都是零，所以</p>
<p>①init方法做初使化工作，让对象的成员变量的值符合我们程序逻辑中的初始化状态。<br>②返回真正可以使用的指向该对象的指针</p>
<p>某些情况下，init会造成alloc的原本空间不够用，而进行第二次分配内存空间。所以下面的写法是错的：</p>
<pre><code>NSString  *s=[NSString alloc];

[s init];// 这儿init返回的地址可能会变。s原本的指针地址可能是无效的地址。
</code></pre><p>正确的写法是<code>NSString  *s=[[NSString alloc] init];</code></p>
<p>new简单地等价于 alloc + init，但不能指定init的参数，很少用。</p>
<ol>
<li>NSInteger是一个有符号型int，它与int的区别就在于NSInteger可以自动识别机器是32位还是64位。NSInteger的无符号版本是NSUInteger。</li>
</ol>
<ol>
<li><p>运行时<br>消息只有到运行时才会和函数实现绑定起来，而不是按照编译好的逻辑一成不变的执行。编译阶段只是确定了要去向receiver对象发送message消息，但是却没有发送，真正发送是等到运行的时候进行。 </p>
</li>
<li><p>NSObject 类定义了description方法,返回该类内容的字符串表示。</p>
</li>
<li><p>某些 NSObject 的方法只是简单地从运行时系统中获得信息,从而允许对象进行一定程度的自我检查。<br>例如,class 返回对象的类;<code>isKindOfClass:</code>和 <code>isMemberOfClass:</code>则检查对象是否在指定的 类继承体系中;<code>respondsToSelector:</code>检查对象能否响应指定的消息;<code>conformsToProtocol:</code> 检查对象是否实现了指定协议类的方法;<code>methodForSelector:</code>则返回指定方法实现的地址。</p>
</li>
</ol>
<p>①message（消息）<br>message 是一种抽象，包括了函数名+参数列表，并没有实际的实体存在。<br>②method（方法）<br>method是真正的存在的代码。如：<code>- (int)meaning { return 42; }</code><br>③selector（方法选择器）<br>selector 通过SEL类型存在，描述一个特定的method 或者说 message。在实际编程中，可以通过selector进行检索方法等操作。</p>
<ol>
<li><p>方法选择器仅仅是一个<code>char *</code>指针，仅仅表示它所代表的方法名字。</p>
<pre><code>typedef struct objc_selector *SEL;  
    SEL selector = @selector(message); //@selector不是函数调用，只是给编译器的一个提示   
    NSLog (@&quot;%s&quot;, (char *)selector); //print message   
</code></pre></li>
<li><p>Objective-C在编译的时候，会根据方法的名字，生成一个用来区分这个方法的唯一的一个ID，这个ID就是SEL类型的（生成唯一的SEL）。只要方法的名字相同，那么它们的ID都是相同的。</p>
</li>
</ol>
<ol>
<li>编译器会根据每个方法的方法名为那个方法生成唯一的SEL，这些SEL组成了一个Set集合，这个Set简单的说就是一个经过了优化过的hash表。SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，从而加快方法的查询速度。</li>
</ol>
<ol>
<li>IMP <code>typedef id (*IMP)(id, SEL, ...);</code><br>由于每个方法都对应唯一的SEL，可以通过SEL方便、快速、准确的获得它所对应的IMP（也就是函数指针），而在取得了函数指针之后，也就意味着取得了执行这段方法的代码的入口，这样就可以像普通的C语言函数调用一样使用这个函数指针。</li>
</ol>
<pre><code>void (* performMessage)(id,SEL);//定义一个IMP（函数指针）   
performMessage = (void (*)(id,SEL))
[self methodForSelector:@selector(message)];
//通过methodForSelector方法根据SEL获取对应的函数指针   

performMessage(self,@selector(message));
//通过取到的IMP（函数指针）跳过runtime消息传递机制，直接执行message方法。
</code></pre><ol>
<li>用IMP 的方式，省去了runtime消息传递过程中所做的一系列动作，比直接向对象发送消息高效一些。</li>
</ol>
<ol>
<li>消息调用流程<br>消息表达式[receiver message]在被转换成objc_msgSend(receiver, SEL)后，在运行时，runtime system会做以下事情：</li>
</ol>
<ul>
<li><p>1、检查忽略的Selector（比如将会忽略retain和release消息）。</p>
</li>
<li><p>2、检查receiver是否为nil。（如果receiver为空，则会将 selector也设置为空，并且直接返回到消息调用的地方。）如果对象非空，就继续下一步。</p>
</li>
<li><p>3、根据SEL到当前类中查找对应的IMP，首先会在cache中检索它，如果找到了就根据函数指针跳转到这个函数执行，否则进行下一步。</p>
</li>
<li><p>4、检索当前类对象中的方法表（method list），如果找到了，加入cache中，并且就跳转到这个函数执行，否则进行下一步。</p>
</li>
<li><p>5、从父类中寻找,直到根类：NSObject类。找到了就将方法加入对应类的cache表中，如果仍未找到，则要进入动态方法决议。</p>
</li>
<li><p>6、如果动态方法决议仍不能解决问题，只能进行最后一次尝试，进入消息转发流程。</p>
</li>
</ul>
<p>注意：cache的原则就是缓存那些可能要执行的函数地址，下次调用的时候，速度就可以快速很多。</p>
<ol>
<li><p>类方法和实例方法中，都可以访问self和_cmd这两个属性，因为它们都不属于类的实例变量，而是形参。</p>
</li>
<li><p>objc_msgSend找到方法对应的实现时,将直接调用该方法实现,并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:<br><em>接收消息的对象（也就是self指向的内容）
</em>方法选标（_cmd指向的内容）</p>
</li>
</ol>
<p>”隐藏“：因为它们并没有在定义方法的源代码中声明,而是在代码编译时是插入方法的实现中的。在方法中可以通过 self 来引用消息接收者对象,通过选标_cmd 来引用方法本身。</p>
<pre><code>- (void)message  
{  
    self.name = @&quot;James&quot;;//通过self关键字给当前对象的属性赋值  
    SEL currentSel = _cmd;//通过_cmd关键字取到当前函数对应的SEL  
    NSLog(@&quot;currentSel is :%s&quot;,(char *)currentSel);  
} 
</code></pre><ol>
<li>当被调用的方法实现部分没有找到，而消息转发机制启动之前的这个中间时刻(动态添加方法)。<code>+(BOOL) resolveInstanceMethod:(SEL) sel</code>将被调用。这是NSObject根类提供的类方法。</li>
<li><p>@dynamic关键字的作用:①告诉编译器不要创建实现属性所用的实例变量；②告诉编译器不要创建该属性的get和setter方法。让编译器相信存取方法会在运行时找到。</p>
<pre><code>// 声明文件中
@property(nonatomic,retain) NSString    *name; 

// 实现文件中
@dynamic name;  
</code></pre></li>
<li><p>默认情况下，编译器会为当前类自动生成一个NSString   <em>_name的实例变量（如果想改变实例变量的名称可以用@synthesize关键字），同时会生成两个名为` - (NSString </em>)name<code>和</code>- (void)setName:(NSString *)aName`的存取方法。</p>
<pre><code>void dynamicMethodIMP(id self, SEL _cmd)  
{  
    // implementation ....  
}  

+ (BOOL)resolveInstanceMethod:(SEL)sel  
{  
    NSLog(@&quot;sel is %@&quot;, NSStringFromSelector(sel));  
    if(sel == @selector(setName:)){  
        class_addMethod([self class],sel,(IMP)dynamicMethodIMP,&quot;v@:&quot;);  
        return YES;  
    }  
    return [super resolveInstanceMethod:sel];  
}  
</code></pre></li>
<li><p>消息转发.外部调用的某个方法对象没有实现，而且resolveInstanceMethod方法中也没有做重定向处理时，就会触发<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>方法。这个方法通常用来将不能处理的消息转发给其它的对象。</p>
<pre><code>-(void)forwardInvocation:(NSInvocation *)invocation  
{  
    SEL invSEL = invocation.selector;  
    if ([someOtherObject respondsToSelector:invSEL])  
        [anInvocation invokeWithTarget:someOtherObject];  
    } else {  
        [self doesNotRecognizeSelector:invSEL];   
    }                                                                            
}  
</code></pre></li>
<li><p>Cocoa（iOS上的叫Cocoa Touch）是一个面向对象的软件组件——类的集成套件，它使开发者可以快速创建强壮和全功能的 Mac OS X （IOS）应用程序。Cocoa包含了很多框架，其中最最核心的是Foundation框架和Application Kit（AppKit）框架（Cocoa Touch中叫UIKit框架）。</p>
</li>
<li><p>imageNamed的优点在于可以缓存已经加载的图片。这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回.</p>
</li>
<li>imageWithContentsOfFile方法只是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到程序。当不需要重用该图像，或者需要将图像以数据方式存储到数据库，又或者要通过网络下载一个很大的图像时，可以使用这种方式。</li>
<li>run loop是为了线程而生,是线程的基础架构部分，每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。主线程的run loop默认是启动的。</li>
<li>UIApplicationMain()函数，会为main thread设置一个NSRunLoop对象.</li>
<li>NSRunLoop类并不是线程安全的,不能在一个线程中去操作另外一个线程的run loop对象,CFRunLoopRef是线程安全的.</li>
<li>获取到当前线程的run loop:<code>[NSRunLoop currentRunLoop];</code>获取对应的CFRunLoopRef类<code>- (CFRunLoopRef)getCFRunLoop;</code></li>
<li>一个run loop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。对消息处理过程进行了更好的抽象和封装，在NSRunLoop中每一个消息就被打包在input source或者是timer source中了。使用run loop可以使线程在有工作的时候工作，没有工作的时候休眠，这可以大大节省系统资源。</li>
<li>创建输入源的时候，需要将其分配给run loop中的一个或多个模式.</li>
<li>定时源在预设的时间点同步方式传递消息，这些消息都会发生在特定时间或者重复的时间间隔。定时源则直接传递消息给处理例程，不会立即退出run loop。</li>
<li>创建NSTimer</li>
</ol>
<pre><code>// 方式一:自动把timer加入MainRunloop的NSDefaultRunLoopMode中
NSTimer *timer = [NSTimer scheduledTimerWithTimeInteral:1.0 target:self selector:@selector(action:) userInfo:ni] repeat:NO];

// 停止
[timer invalidate];


// 方式二(需手动加到run loop中)
   NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self seletor:@selector(timerAction) userInfo:nil repeats:YES];

   [[NSRunloop mainRunloop] addTimer:timer forMode:NSDefaultRunloopMode];
</code></pre><p>特点:调用创建方法后,target对象的引用计数会+1,直到执行完毕,自动-1.如果RunLoop正在执行一个连续的运算,timer就会被延迟触发</p>
<ol>
<li>响应者对象（Responder Object），指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。</li>
</ol>
<ul>
<li><p>响应者链通常是由视图（UIView）构成的；</p>
</li>
<li><p>一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）；</p>
</li>
<li><p>视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图；</p>
</li>
<li><p>单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者.</p>
</li>
<li><p>单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。</p>
</li>
</ul>
<ol>
<li><p>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。</p>
</li>
<li><p>UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。</p>
</li>
<li><p>UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:</p>
</li>
</ol>
<ol>
<li>方法的处理流程如下:<br>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；<br>若返回NO,则hitTest:withEvent:返回nil;<br>若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；<br>若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；<br>如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。</li>
</ol>
<ol>
<li><p>非正式协议通常定义为NSObject的类别。</p>
</li>
<li><p>类别与类扩展的区别：<br>①类别中只能增加方法；<br>②类扩展不仅可以增加方法，还可以增加实例变量（或者合成属性），只是该实例变量默认是@private类型的；<br>③类扩展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中。<br>④类扩展所声明的方法必须依托对应类的实现部分来实现。<br>⑤定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。</p>
</li>
<li><p>KVC全称是Key-value coding，翻译成键值编码。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。KVO全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。KVO机制很适合实现model和controller类之间的通讯。</p>
</li>
<li>KVC是不会自动调用键值验证方法的，我们需要手动验证。<code>- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</code></li>
<li>KVC可以自动的将数值或结构体型的数据打包或解包成NSNumber或NSValue对象，以达到适配的目的。</li>
<li>代码片段存放路径<code>~/Library/Developer/Xcode/UserData/CodeSnippets</code></li>
<li>ARC的英文全名是：Automatic Reference Counting，是编译器提供的管理Objective-C对象内存的一个机制。它并不是像垃圾回收机制那样，有一个负责内存回收的系统，而是仍然以引用计数为基础：在编译阶段，编译器会在需要retain或release对象的地方自动为我们加上对应的代码。</li>
<li>内存管理规则：一个Object-C对象存在strong类型的指针指向时，该对象就不会被释放。</li>
<li><p>①strong<br>该属性值对应 <code>__strong</code>关键字，即该属性所声明的指针变量将成为对象的持有者。strong是指向Objective-C对象指针的默认属性。<br>②weak<br>该属性对应<code>__weak</code>关键字，与<code>__weak</code>定义的变量一致，该属性所声明的变量将没有对象的所有权，并且当对象被破弃之后，对象将被自动赋值nil。<br>④copy<br>也是对象的所有者，与strong的区别是声明的指针变量是拷贝对象的持有者。<br>⑤assign<br>一般数值型变量用该属性声明，比如,int, BOOL，但无需显示写出，因为数值型变量的默认属性类型就是assign</p>
</li>
<li><p>使用关键字声明指针类型规范写法:</p>
<pre><code>//规范的写法
MyClass * __weak myWeakReference;
</code></pre></li>
<li><p>weak和assign的异同</p>
</li>
</ol>
<p>相同点：指向的对象都是随时有可能被释放，即不拥有指向的对象<br>不同点：①weak只能用来声明Objective-C对象，assign既可以用来声明对象，也可以用来声明数值型变量；②很关键的一点区别，当一个weak关键字声明的指针指向的对象被释放掉得时候，该指针会自动的被指向nil而assign不存在该特性.</p>
<ol>
<li>使用@property声明或作为普通实例变量声明的指向Objective-C对象的指针属性默认都是strong；而使用@property声明的数值型变量属性默认的是assign，普通的数值型变量的属性是__unsafe_unretaind。</li>
</ol>
<table>
<thead>
<tr>
<th>属性</th>
<th>关键字</th>
<th>所有权</th>
</tr>
</thead>
<tbody>
<tr>
<td>strong</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>copy</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
<td>无</td>
</tr>
<tr>
<td>assign</td>
<td>__unsafe_unretained</td>
<td>无</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe_unretained</td>
<td>无</td>
</tr>
</tbody>
</table>
<ol>
<li><p>使用ARC需要遵守的新规则<br>①不要在dealloc方法中调用[super dealloc];<br>②不能使用 retain/release/retainCount/autorelease<br>③不能使用 NSAllocateObject/NSDeallocateObject<br>④不能使用 NSZone<br>⑤Objective-C 对象不能作为C语言结构体（struct/union）的成员</p>
</li>
<li><p>instancetype表示某个方法返回的未知类型的Objective-C对象,instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型,能够确定对象的类型.有利于开发者在编译阶段发现错误。</p>
</li>
<li>关联返回类型（related result types）1、类方法中，以alloc或new开头2、实例方法中，以autorelease，init，retain或self开头.</li>
<li><p>instancetype和id的异同: 1、相同点:都可以作为方法的返回类型<br>2、不同点<br>①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；<br>②instancetype只能作为返回值，不能像id那样作为参数</p>
</li>
<li><p>每个应用的沙盒目录都是相似的，主要包含4个目录：<br>1、MyApp.app<br>存放应用程序本身的数据,整个目录是只读的,不能被iTunes同步<br>2、Documents<br>存放不可再生的的数据文件,会被iTunes同步.<br>3、Library<br>存放默认设置或其它状态信息。<br>除了Caches子目录外,会被iTunes同步.<br>4、Library/Caches<br>存放缓存文件，保存那些可再生的文件,不会被iTunes同步<br>5、Library/Preferences<br>存放应用程序的偏好设置文件。我们使用NSUserDefaults写的设置数据都会保存到该目录下的一个plist文件中，会被iTunes同步<br>6、tmp<br>存放各种临时文件,不会被iTunes同步</p>
</li>
</ol>
<ol>
<li>runtime采用散列表来管理引用计数,统一存储所有对象的引用计数,不用考虑每个对象内存块中引用计数所占的内存,在引用计数表中存储各个对象的内存地址.</li>
<li>NULL本质上是：(void<em>)0,表示C指针为空,如`charchar </em>string = NULL; `</li>
<li>nil本质上是：(void *)0,表示指向Objective-C中对象的指针为空</li>
<li>Nil本质上也是：(void *)0,表示Objective-C中Class类型的变量值为空,<code>Class anyClass = Nil;</code></li>
<li><p>NSNull是一个Objective-C类,该类通常用于在集合对象中保存一个空的占位对象</p>
<pre><code>// 遇到nil截断
NSArray *arr = [NSArray arrayWithObjects:@&quot;wang&quot;,@&quot;zz&quot;,nil,@&quot;foogry&quot;];

// 存储空的占位对象
NSArray *arr = [NSArray arrayWithObjects:@&quot;wang&quot;,@&quot;zz&quot;,[NSNull null],@&quot;foogry&quot;];
</code></pre></li>
</ol>
<blockquote>
<p>向作者致谢!<br>王中周的个人博客:<a href="http://blog.csdn.net/wzzvictory" target="_blank" rel="external">http://blog.csdn.net/wzzvictory</a></p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ios开发/" rel="tag">#ios开发</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/10/28/读李明杰博客/" rel="next" title="读「李明杰博客」">
                <i class="fa fa-chevron-left"></i> 读「李明杰博客」
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/06/前端学习笔记 /" rel="prev" title="HTML/CSS/JavaScript学习笔记">
                HTML/CSS/JavaScript学习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://chenyaluncos-10005661.cos.myqcloud.com/touxiang.jpg"
               alt="Ya" />
          <p class="site-author-name" itemprop="name">Ya</p>
          <p class="site-description motion-element" itemprop="description">Being a Full Stack Developer</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">随笔</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/icqk" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/ChenYalun" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://stackoverflow.com/users/7026915/allen" target="_blank" title="SOF">
                  
                    <i class="fa fa-fw fa-stack-overflow"></i>
                  
                  SOF
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#读感"><span class="nav-number">1.</span> <span class="nav-text">读感</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#知识"><span class="nav-number">2.</span> <span class="nav-text">知识</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ya</span>
</div>

<div class="powered-by">
  May Be Better
</div>

<div class="theme-info">
  心有猛虎，细嗅蔷薇。 
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
