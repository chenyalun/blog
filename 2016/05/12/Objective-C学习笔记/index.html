<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Objective-C学习笔记"><meta name="keywords" content="Objective-C, 笔记, Ya"><link rel="alternate" href="/atom.xml" title="Ya"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="http://blog.chenyalun.com/2016/05/12/Objective-C学习笔记/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "6TxhaeHxBXUD0Ve4JVeecCsg-gzGzoHsz",
      appKey: "KV4HGemodXGubbgselgJbMls"
    });
  </script><script>
  window.config = {"leancloud":{"app_id":"6TxhaeHxBXUD0Ve4JVeecCsg-gzGzoHsz","app_key":"KV4HGemodXGubbgselgJbMls"},"toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>Objective-C学习笔记 - Ya</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/archives/">
        <li class="mobile-menu-item">时间线
          </li>
      </a><a href="/tags/阅读/">
        <li class="mobile-menu-item">阅读
          </li>
      </a><a href="/about">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            时间线
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            阅读
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about">
            关于
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Objective-C学习笔记
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-05-12
        </span><span class="post-visits" data-url="/2016/05/12/Objective-C学习笔记/" data-title="Objective-C学习笔记"> ^_^
          
        </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-类的设计"><span class="toc-text">1.类的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-类的声明"><span class="toc-text">2.类的声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-类的实现"><span class="toc-text">3.类的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-创建对象"><span class="toc-text">4.创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-方法与函数的区别以及注意"><span class="toc-text">5.方法与函数的区别以及注意</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-匿名对象"><span class="toc-text">6.匿名对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-对象方法"><span class="toc-text">7.对象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-枚举"><span class="toc-text">8.枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-结构体"><span class="toc-text">9.结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-注意事项"><span class="toc-text">10.注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-封装"><span class="toc-text">11.封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-调用未声明、未实现的对象方法"><span class="toc-text">12.调用未声明、未实现的对象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-调用已声明、未实现的对象方法"><span class="toc-text">13.调用已声明、未实现的对象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-调用未声明、已实现的对象方法"><span class="toc-text">14.调用未声明、已实现的对象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-类方法"><span class="toc-text">15.类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-self关键字"><span class="toc-text">16.self关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-继承"><span class="toc-text">17.继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-super"><span class="toc-text">18.super</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-多态"><span class="toc-text">19.多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-NSString的使用"><span class="toc-text">20.NSString的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-点语法"><span class="toc-text">21.点语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-方法的展开原理："><span class="toc-text">22.方法的展开原理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-死循环"><span class="toc-text">23.死循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-成员变量的作用域"><span class="toc-text">24.成员变量的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#private"><span class="toc-text">@private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#protected"><span class="toc-text">@protected</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#public"><span class="toc-text">@public</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package"><span class="toc-text">@package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意点"><span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-property和-synthesize属性合成"><span class="toc-text">25.@property和@synthesize属性合成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新特性"><span class="toc-text">新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-id"><span class="toc-text">26.id</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#id类型的定义"><span class="toc-text">id类型的定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-构造方法"><span class="toc-text">27.构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-init方法的重写"><span class="toc-text">28.init方法的重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-自定义构造方法"><span class="toc-text">29.自定义构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-h文件和-m文件"><span class="toc-text">30. .h文件和.m文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-分类"><span class="toc-text">31.分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意点-1"><span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-类的私有方法"><span class="toc-text">32.类的私有方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-类的本质"><span class="toc-text">33.类的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-load"><span class="toc-text">34.+load</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-initialize"><span class="toc-text">35.+initialize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-description方法"><span class="toc-text">36.description方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description方法"><span class="toc-text">-description方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#description方法-1"><span class="toc-text">+description方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-SEL"><span class="toc-text">37.SEL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-p-test-原理解释"><span class="toc-text">38. [p test]原理解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-NSLog方法总结"><span class="toc-text">39.NSLog方法总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-代理"><span class="toc-text">40.代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意点-2"><span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-block"><span class="toc-text">41.block</span></a></li></ol>
    </div>
  </div><div class="post-content"><blockquote>
<p>2016.10.28 修改<br>2019.3.29 整合所有关于Objective-C的笔记</p>
</blockquote>
<p align="center"> 关于Objective-C的笔记。 </p>

<a id="more"></a>
<h2 id="1-类的设计"><a href="#1-类的设计" class="headerlink" title="1.类的设计"></a>1.类的设计</h2><p>三要素：事物名称（类名）；属性；行为（功能）。具有相同（或者类似）属性和行为的对象可以抽象出一个类。</p>
<h2 id="2-类的声明"><a href="#2-类的声明" class="headerlink" title="2.类的声明"></a>2.类的声明</h2><p><strong>类名</strong><br>1，首字母大写；2，不能有下划线；3，多个英文单词，使用驼峰标识</p>
<p><strong>行为</strong><br>哪个对象最清楚行为怎么做，就把行为设计在哪个对象身上</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> Person : NSObject &#123;</span><br><span class="line"><span class="meta">@public</span></span><br><span class="line">    <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="built_in">bool</span> _sex;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">-(<span class="keyword">void</span>)<span class="built_in">print</span>;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<p>大括号内用来声明对象属性（成员变量也即实例变量）,<code>@public</code>让外界指针可以间接访问对象内部的成员变量。成员变量默认会初始化为0.</p>
<p><code>: NSObject</code>（继承基类）使声明的类具有创建对象的能力。</p>
<h2 id="3-类的实现"><a href="#3-类的实现" class="headerlink" title="3.类的实现"></a>3.类的实现</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">-(<span class="keyword">void</span>)print  &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@”输出内容”);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>已经导入声明文件<code>#import “Person.h”</code><br>类的实现即方法的实现。</p>
<h2 id="4-创建对象"><a href="#4-创建对象" class="headerlink" title="4.创建对象"></a>4.创建对象</h2><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span> *p=<span class="comment">[<span class="comment">[Person alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[p print]</span>;</span><br></pre></td></tr></table></figure>
<p>对象的本质是结构体，对象需要通过指针操纵。</p>
<p>类在内存中也占据存储空间，在创建对象之前为类分配一份内存空间，将类加载进内存。而且只存储方法列表，其中由类产生的对象，都有一个isa指针指向类。</p>
<p>方法调用：<code>[行为执行者   行为名称]</code>;</p>
<p><code>[Person new]</code>执行Person这个类的new行为创建对象，返回对象地址。</p>
<p><code>Person *p=[Person new];</code>定义一个Person 类型的指针变量p，指向Person类型的对象。指针的类型是Person *，指针指向的类型是Person。</p>
<p><code>[p print];</code>表示给p指向的对象发送一条print消息。</p>
<p><code>Person p=[Person new];</code>等价于 <code>Person p;p=[Person new];</code>另外<code>Person *p2=p;</code>表示p2、p指向同一个内容。<code>p=p2</code>:将p2存储的指针交给p，使p存储的也是p2存储的内容。</p>
<h2 id="5-方法与函数的区别以及注意"><a href="#5-方法与函数的区别以及注意" class="headerlink" title="5.方法与函数的区别以及注意"></a>5.方法与函数的区别以及注意</h2><ul>
<li><p>OC方法只能声明在<code>@interface</code>和<code>@end</code>之间，只能实现在<code>@implementation</code>和<code>@end</code>之间。也就是说OC方法不能独立于类存在</p>
</li>
<li><p>C函数不属于类，跟类没有联系，C函数只归定义函数的文件所有</p>
</li>
<li><p>C函数不能访问OC对象的成员</p>
</li>
<li><p>对象方法归类／对象所有，函数属于整个文件所有，任何地方都可以放置函数（如果放在<code>@interface</code>与<code>@end</code>之间，将会忽略掉函数，即未定义）</p>
</li>
<li><p>方法只有声明，没有实现（经典错误）</p>
</li>
<li>方法没有声明，只有实现（编译器警告，但是能调用，OC的弱语法）</li>
<li>编译的时候：访问没有的成员变量直接报错，访问没有的方法，只是警告</li>
<li>同一个类中不允许两个对象方法同名</li>
</ul>
<h2 id="6-匿名对象"><a href="#6-匿名对象" class="headerlink" title="6.匿名对象"></a>6.匿名对象</h2><p>属性访问 <code>[Car new]-&gt;speed = 200;</code><br>方法调用<code>[ [Car new] run];</code></p>
<h2 id="7-对象方法"><a href="#7-对象方法" class="headerlink" title="7.对象方法"></a>7.对象方法</h2><p>不带参数的对象方法：</p>
<p><code>-(void)print; 方法名print</code></p>
<p>带一个参数的对象方法：</p>
<p><code>-(void)print:(int) a; 方法名print :</code></p>
<p>带多个参数的对象方法：</p>
<p><code>-(void)print:(int) a WithOther:(int) b;</code>方法名</p>
<p><code>print : WithOther:</code></p>
<h2 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8.枚举"></a>8.枚举</h2><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span>｛</span></span><br><span class="line">    SexMan,</span><br><span class="line">    SexWoman</span><br><span class="line">｝Sex;</span><br></pre></td></tr></table></figure>
<h2 id="9-结构体"><a href="#9-结构体" class="headerlink" title="9.结构体"></a>9.结构体</h2><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">year</span>;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">month</span>;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">day</span>;</span><br><span class="line">&#125; <span class="built_in">Date</span>;</span><br></pre></td></tr></table></figure>
<p>访问枚举：<code>s-&gt;sex=SexMan;</code></p>
<p>访问结构体：<code>s-&gt;birthday.year=2016;</code></p>
<p>定义结构体：</p>
<p><code>Date d={2016,4,30};</code></p>
<p>访问结构体：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">s-&gt;birthday.<span class="attribute">year</span>=2016;</span><br><span class="line">    </span><br><span class="line">s-&gt;birthday.<span class="attribute">month</span>=4;</span><br><span class="line">    </span><br><span class="line">s-&gt;birthday.<span class="attribute">day</span>=16;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Date d=&#123;<span class="number">2016</span>,<span class="number">4</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    </span><br><span class="line">s-&gt;birthday=d;</span><br></pre></td></tr></table></figure>
<h2 id="10-注意事项"><a href="#10-注意事项" class="headerlink" title="10.注意事项"></a>10.注意事项</h2><ul>
<li>打印函数中注意％与%的区别</li>
<li>定义枚举、结构体等必需放在@interface的前面方可使用</li>
<li>OC方法中一个参数一个冒号</li>
<li>对象中有对象</li>
</ul>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> &#123;</span><br><span class="line">@<span class="keyword">public</span></span><br><span class="line"><span class="comment">//狗</span></span><br><span class="line">Dog *dog;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">-(<span class="keyword">void</span>)letDogRun &#123;</span><br><span class="line">    [<span class="meta">dog run</span>];</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment">// main.m文件</span></span><br><span class="line">Student *stu=[Student <span class="keyword">new</span>];</span><br><span class="line">Dog *dog=[Dog <span class="keyword">new</span>];</span><br><span class="line">stu-&gt;dog=dog;</span><br><span class="line">[<span class="meta">stu letDogRun</span>];</span><br></pre></td></tr></table></figure>
<h2 id="11-封装"><a href="#11-封装" class="headerlink" title="11.封装"></a>11.封装</h2><p>优点：过滤不合理的值，屏蔽内部的赋值过程，让外界不必关注内部的细节。</p>
<p>成员变量的命名：以下划线开头。用于区分get方法名称和局部变量名称。尽量不设置为@public公有属性</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    int _speed<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set方法：设置成员变量，过滤一些不符合要求的值。以set开头，返回类型为void，后面跟上成员变量名，形参不与成员变量重名，形参类型与成员变量相同，成员变量的首字母大写。在set方法中设置行为，监听属性的改变。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)<span class="built_in">setSpeed</span>:(<span class="keyword">int</span>)s;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)<span class="built_in">setSpeed</span>:(<span class="keyword">int</span>)s &#123;</span><br><span class="line">    _speed=s+<span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> get方法：获取对象内部的成员变量，不接收参数，返回类型与成员变量类型相同，方法名称与成员变量名称相同（不含下划线）。不推荐以get开头。</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">(int)speed;</span></span><br><span class="line"><span class="ruby">   </span></span><br><span class="line"><span class="ruby">-(int)speed &#123;</span></span><br><span class="line"><span class="ruby">    <span class="keyword">return</span> _speed; </span></span><br><span class="line"><span class="ruby">&#125;</span></span><br></pre></td></tr></table></figure>
<p>只读：只提供get方法。可读可写：提供get和set方法。</p>
<h2 id="12-调用未声明、未实现的对象方法"><a href="#12-调用未声明、未实现的对象方法" class="headerlink" title="12.调用未声明、未实现的对象方法"></a>12.调用未声明、未实现的对象方法</h2><p>编译 报错 <code>No visible @interface for ‘Dog’ declares the selector ‘ssss’</code>，链接运行 报错。</p>
<p><code>reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1002014a0’</code></p>
<p>给Dog对象发送不能识别的消息。</p>
<h2 id="13-调用已声明、未实现的对象方法"><a href="#13-调用已声明、未实现的对象方法" class="headerlink" title="13.调用已声明、未实现的对象方法"></a>13.调用已声明、未实现的对象方法</h2><p>编译警告：<code>Method definition for ‘ssss’ not found</code> 未实现方法 链接正常，运行报错</p>
<p><code>reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1001002a0’</code></p>
<h2 id="14-调用未声明、已实现的对象方法"><a href="#14-调用未声明、已实现的对象方法" class="headerlink" title="14.调用未声明、已实现的对象方法"></a>14.调用未声明、已实现的对象方法</h2><p>编译 链接运行 错误 <code>No visible @interface for ‘Dog’ declares the selector ‘ssss’</code></p>
<p>在Dog的@interface中，对于ssss的声明是不可见的。</p>
<h2 id="15-类方法"><a href="#15-类方法" class="headerlink" title="15.类方法"></a>15.类方法</h2><p>类本身在内存中占据存储空间，里面有类\对象方法列表。直接通过类名执行的方法。</p>
<p>以+开头，只能由类名调用，类方法中不能访问成员变量（实例变量）。允许类方法与对象方法重名。(执行者不同，当然可以重名！)</p>
<p>使用场合：当不需要访问成员变量的时候，尽量使用类方法，提升效率。</p>
<p>输出类的名称：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+(<span class="keyword">void</span>)showClassName;</span><br><span class="line">   </span><br><span class="line">+(<span class="keyword">void</span>)showClassName &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@”类的名称是：%@”,<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：<code>[Dog showClassName];</code></p>
<h2 id="16-self关键字"><a href="#16-self关键字" class="headerlink" title="16.self关键字"></a>16.self关键字</h2><p>self是指针，指向当前对象或类的调用者。出现在对象方法中，代表当前对象，出现在类方法中，代表当前类。不能出现在函数中（会报错：<code>Use of undeclared identifier ‘self’</code>使用未声明的标识符）。</p>
<p>用途：</p>
<ol>
<li>self-&gt;成员变量名 在对象方法中访问当前方法调用的成员变量，也即当成员变量与局部变量同名时，用来区分同名的局部变量。</li>
</ol>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">-(void)<span class="keyword">showSelfOfObject;</span></span><br><span class="line"><span class="keyword"> </span>  </span><br><span class="line">-(void)<span class="keyword">showSelfOfObject </span>&#123;</span><br><span class="line">    NSLog(@”<span class="keyword">showSelfOfObject方法被调用”);</span></span><br><span class="line"><span class="keyword"> </span>   int _speed<span class="comment">;</span></span><br><span class="line">    self-&gt;_speed=<span class="number">200</span><span class="comment">;</span></span><br><span class="line">    _speed+=<span class="number">1000</span><span class="comment">;</span></span><br><span class="line">    int result= self-&gt;_speed+<span class="number">10</span><span class="comment">;</span></span><br><span class="line">    NSLog(@”result的值是：%i”,result)<span class="comment">;</span></span><br><span class="line">    NSLog(@”_speed的值是：%i”,_speed)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当成员变量与局部变量同名时（编译警告<code>Local declaration of ‘_speed’ hides the instance variable</code>局部变量隐藏了成员变量），采用就近原则，访问局部变量。因此需要用self访问成员变量。</p>
<ol start="2">
<li>方法的调用:在对象方法中调用当前对象的对象方法以及在类方法中调用当前类的类方法</li>
</ol>
<p>在对象方法中调用当前对象的对象方法</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">(void)showSelfOfObject;</span></span><br><span class="line"><span class="ruby">-(void)showTestObject;</span></span><br><span class="line"><span class="ruby">-(void)showSelfOfObject &#123;</span></span><br><span class="line"><span class="ruby">    NSLog(@”showSelfOfObject方法被调用”);</span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">   </span></span><br><span class="line"><span class="ruby">-(void)showTestObject &#123;</span></span><br><span class="line"><span class="ruby">    [<span class="keyword">self</span> showSelfOfObject];</span></span><br><span class="line"><span class="ruby">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在类方法中调用当前类的类方法</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">+(void)<span class="keyword">showSelfOfClass;</span></span><br><span class="line"><span class="keyword">+(void)showTestClass;</span></span><br><span class="line"><span class="keyword">+(void)showSelfOfClass </span>&#123;</span><br><span class="line">    NSLog(@”<span class="keyword">showSelfOfClass方法被调用”);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword"> </span>  </span><br><span class="line">+(void)<span class="keyword">showTestClass </span>&#123;</span><br><span class="line">    [self <span class="keyword">showSelfOfClass];</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<p>常见错误：</p>
<ol>
<li><p>在对象方法中调用类方法（编译错误<code>No visible @interface for ‘Dog’ declares the selector ‘showSelfOfClass‘</code>）错误相当于未声明未定义却调用这个方法。</p>
</li>
<li><p>在类方法中调用对象方法（编译错误<code>No known class method for selector ‘showSelfOfObject‘</code>）未知的类方法</p>
</li>
</ol>
<p>3，self的死循环:调用本身</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">showSelfOfObject</span> &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@”showSelfOfObject方法被调用”);</span><br><span class="line">    <span class="selector-attr">[self showSelfOfObject]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4，调用函数</p>
<p>函数不依赖对象。<code>void f(); [self f]</code> 错误</p>
<h2 id="17-继承"><a href="#17-继承" class="headerlink" title="17.继承"></a>17.继承</h2><p>场景：当两个类拥有相同的属性和方法时，将相同的内容抽取到父类中。当A类完全拥有B类的部分属性或方法时，考虑A类作为父类。</p>
<ol>
<li><p>父类必须声明在子类前面。</p>
</li>
<li><p>不允许子类和父类拥有相同的成员变量（如果子类有和父类拥有相同的成员变量，意味着，同一成员变量声明定义两次，编译错误 <code>Duplicute member ‘_age’</code>，哪怕成员变量的访问属性不同，子类公开父类私有，或者父类公开子类私有，都不行！）</p>
</li>
<li><p>子类方法和属性的访问过程：如果子类没有，再访问父类。即由子类开始。</p>
</li>
<li><p>Objective-C中只有单继承（与C＋＋不同）</p>
</li>
</ol>
<p>方法的重写:父类和子类拥有相同签名的类方法或者对象方法（子类重新实现了父类中的方法），则优先调用子类的同名方法。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">父类<span class="keyword">Person</span>：</span><br><span class="line">-(void)show &#123;</span><br><span class="line">    NSLog(@”调用了<span class="keyword">Person</span>的show方法”);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">子类Student：</span><br><span class="line">-(void)show &#123;</span><br><span class="line">//<span class="comment">[super show]</span>;</span><br><span class="line">NSLog(@”调用了Student的show方法”);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">调用：</span><br><span class="line">Student *p=<span class="comment">[<span class="comment">[Student alloc]</span> init]</span>; <span class="comment">[p show]</span>;</span><br></pre></td></tr></table></figure>
<p>很明显，调用的是重写的子类Student的show方法。</p>
<h2 id="18-super"><a href="#18-super" class="headerlink" title="18.super"></a>18.super</h2><p>场景：子类重写父类的方法时，想调用父类的方法（包括类方法和对象方法）。</p>
<p>效果与self类似，super在对象方法中就调用父类的对象方法，在类方法中就调用父类的类方法。</p>
<p>继承可以在不改变原来模型的基础上拓充方法，抽取公共代码，建立类与类之间的联系，减少代码的冗余性，但是，会增加耦合性。</p>
<h2 id="19-多态"><a href="#19-多态" class="headerlink" title="19.多态"></a>19.多态</h2><p>某一种事物的多种形态。<br>在实现继承的前提下，父类类型指针指向子类对象（右边是左边），指向子类对象的父类指针可以调用子类中重写父类的方法，但是指向子类对象的父类指针不能调用子类中拓展的方法（父类中没有的方法）。<code>Person *p=[[Student alloc] init]; [p show];</code>  </p>
<p>Student是Person，show方法在子类和父类中都有，这里调用的是子类的show方法。</p>
<p>当子类拓展了一个showStudent对象方法，如果还想调用，则强制转换：将指向子类对象的父类指针强制转化为子类指针。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span> *p=<span class="comment">[<span class="comment">[Student alloc]</span> init]</span>;</span><br><span class="line">Student p2=(Student )p;</span><br><span class="line"><span class="comment">[p2 showStudent]</span>;</span><br></pre></td></tr></table></figure>
<p>将父类指针p强制转换为子类指针，使它可以调用子类Student拓展的showStudent方法。</p>
<p>如果不做强制转换，而直接调用子类拓展的方法</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span> *p=<span class="comment">[<span class="comment">[Student alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[p showStudent]</span>;</span><br></pre></td></tr></table></figure>
<p>编译报错： <code>No visible @interface for ‘Person’ declares the selector ‘showStudent’</code></p>
<p>转换语法： { 相应子类名 p=(父类名 )指向子类对象的父类指针；}</p>
<p>主要应用：<strong>动态绑定</strong><br>如果参数使用父类类型，可以传入父类、子类对象，调用相应的方法（如将子类对象传递给参数，调用子类的方法；将父类对象传递给参数，则调用父类的方法）</p>
<h2 id="20-NSString的使用"><a href="#20-NSString的使用" class="headerlink" title="20.NSString的使用"></a>20.NSString的使用</h2><ol>
<li>创建字符串与输出字符串</li>
</ol>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">NSString <span class="symbol">*</span>s=<span class="meta">@”Sometimes”;</span></span><br><span class="line">NSLog(<span class="meta">@”%</span><span class="meta">@”,s);</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>格式化字符串</li>
</ol>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age=<span class="number">85</span>;</span><br><span class="line">NSString *s=[NSString stringWithFormat:@”传入的年龄参数是%d”,age];</span><br><span class="line">NSLog(@”%@”,s);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>调用NSString类方法。<br>length返回字数（不是字符数）</li>
</ol>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">NSString *s=@”<span class="number">123</span> <span class="number">456</span>”; </span><br><span class="line">NSLog(@”%@”,s);</span><br><span class="line">NSUInteger <span class="keyword">size</span>=[s length];</span><br><span class="line">NSLog(@”%lu”,(unsigned long)<span class="keyword">size</span>);</span><br></pre></td></tr></table></figure>
<p>返回的是7，包括空格。</p>
<h2 id="21-点语法"><a href="#21-点语法" class="headerlink" title="21.点语法"></a>21.点语法</h2><p>本质是方法调用，不访问成员变量。前提是已经存在get和set方法(否则报错：<code>Property ‘age’ not found on object of type ‘Person *’</code>)。</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">[p setAge:<span class="number">50</span>];</span><br><span class="line"><span class="built_in">int</span> <span class="literal">result</span>=[p age];</span><br><span class="line"><span class="type">NSLog</span>(@”<span class="literal">result</span>的结果是：%i”,<span class="literal">result</span>);</span><br></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">p.age=<span class="number">50</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="literal">result</span>=p.age;</span><br><span class="line"><span class="type">NSLog</span>(@”<span class="literal">result</span>的结果是：%i”,<span class="literal">result</span>);</span><br></pre></td></tr></table></figure>
<p>注意：此处的result未必等于50，因为在set方法中，age的值可能改变。</p>
<h2 id="22-方法的展开原理："><a href="#22-方法的展开原理：" class="headerlink" title="22.方法的展开原理："></a>22.方法的展开原理：</h2><p><code>[p setAge:50];</code>对应 <code>p.age = 50;</code> 而<code>int result = [p age];</code>对应<code>int result = p.age;</code></p>
<h2 id="23-死循环"><a href="#23-死循环" class="headerlink" title="23.死循环"></a>23.死循环</h2><p>1，set方法中</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)<span class="string">setAge:</span>(<span class="keyword">int</span>)a &#123;</span><br><span class="line">   self.age=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是在set方法中调用set方法。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">int</span>)age &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在get方法中调用get方法。<br>以上编译链接均无警告、无错误，但是运行会报错。</p>
<h2 id="24-成员变量的作用域"><a href="#24-成员变量的作用域" class="headerlink" title="24.成员变量的作用域"></a>24.成员变量的作用域</h2><h3 id="private"><a href="#private" class="headerlink" title="@private"></a>@private</h3><p>私有。<br>只能在当前类的对象方法中直接访问（当前类的对象方法的@implementation中访问），子类虽然继承（内存中存在），但无权限访问（感觉貌似没有继承，一层网给过滤掉。</p>
<h3 id="protected"><a href="#protected" class="headerlink" title="@protected"></a>@protected</h3><p>保护（默认是保护，不是私有）。<br>可以在当前类和子类的对象方法中直接访问（当前类和子类的@implementation中访问）。<br>假设父类Person有保护的成员变量_number，子类继承，什么变量都不增加，那么子类对象方法中访问的是父类的_number。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)show &#123;</span><br><span class="line">    <span class="keyword">self</span>-&gt;_number=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="keyword">self</span>-&gt;_number;</span><br><span class="line">    _number=<span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">int</span> result2= _number;</span><br><span class="line">    <span class="built_in">NSLog</span>(@”<span class="keyword">self</span>-&gt;_number的值是：%i”,result);</span><br><span class="line">    <span class="built_in">NSLog</span>(@”_number的值是：%i”,result2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="public"><a href="#public" class="headerlink" title="@public"></a>@public</h3><p>公开。任何地方都可以访问。一般用不到。</p>
<h3 id="package"><a href="#package" class="headerlink" title="@package"></a>@package</h3><p>同一个框架内可以访问，介于@public和@private之间。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1,在类方法中不可能访问成员变量。<br>2,也可以在@implementation中声明成员变量。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@implementation</span> <span class="attribute">Student</span>:NSObject &#123;</span><br><span class="line">   <span class="variable">@public</span> int age;</span><br><span class="line">   <span class="variable">@private</span> int number;</span><br><span class="line">   <span class="variable">@protected</span> int no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>然而.m文件一般不会被包含，也即一般没有必要访问，故而一般不把成员变量放在实现文件中。</p>
<h2 id="25-property和-synthesize属性合成"><a href="#25-property和-synthesize属性合成" class="headerlink" title="25.@property和@synthesize属性合成"></a>25.@property和@synthesize属性合成</h2><p>@property用在@interface中，代替get和set方法<br>如：<code>@property int age;</code><br>等价于</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">int</span>)age;</span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">setAge:</span>(<span class="keyword">int</span>)age;</span><br></pre></td></tr></table></figure>
<p>即便是<code>@property int _age;</code>那也会生成</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-(<span class="keyword">int</span>)_age;</span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">setAge:</span>(<span class="keyword">int</span>)_age;</span><br></pre></td></tr></table></figure>
<p>而<code>@synthesize</code>用在<code>@implementation</code>实现中：<code>@synthesize  age=成员变量名;</code> 不允许对成员变量进行条件过滤，如<code>@synthesize age=_age+100;</code></p>
<p><code>@synthesize age=_age;</code></p>
<p>等价于</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">int</span>)age &#123;</span><br><span class="line">   <span class="keyword">return</span> _age;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">setAge:</span>(<span class="keyword">int</span>)age &#123;</span><br><span class="line">   _age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 1，如果.h文件中没有这个_age成员变量。那么，利用@property可以自动生成私有@private的_age。而默认的_age却是@protected的。<br> 2，@synthesize age将会访问age这个成员变量而非_age。<br> 3，若手动实现getter方法，编译器只会自动生成setter方法；若手动实现setter方法，编译器只会自动生成getter方法。</p>
<h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><p>@property已经独揽@synthesize的实现了，也即</p>
<p><code>@synthesize age=_age;</code>可以省略。只用写<code>@property int  age</code>就好了。（当然，前提是不对参数进行过滤，直接传到成员变量中，如果要过滤，还是要自己生成相应的方法。）</p>
<p> 4，默认情况下，getter和setter方法中的实现会访问下划线开头的成员变量。</p>
<h2 id="26-id"><a href="#26-id" class="headerlink" title="26.id"></a>26.id</h2><p>相当于<code>NSObject  *</code>  ，是万能指针。</p>
<h3 id="id类型的定义"><a href="#id类型的定义" class="headerlink" title="id类型的定义"></a>id类型的定义</h3><figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;*id;</span><br></pre></td></tr></table></figure>
<h2 id="27-构造方法"><a href="#27-构造方法" class="headerlink" title="27.构造方法"></a>27.构造方法</h2><p>用来初始化对象的方法，完整地创建一个可用对象。</p>
<p><code>Person *p=[Person alloc];</code><br>+alloc方法分配存储空间，返回对象。</p>
<p><code>p=[p init];</code><br>-init方法初始化</p>
<h2 id="28-init方法的重写"><a href="#28-init方法的重写" class="headerlink" title="28.init方法的重写"></a>28.init方法的重写</h2><p>目的：在对象创建完毕之后，使成员变量就有了一些默认的值。<br>注意：一定要先调用父类的构造方法，再进行子类内部成员变量的初始化<br>在@implementation中进行重写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">-(id)<span class="keyword">init</span> &#123;</span><br><span class="line">   <span class="comment">// 一定要先调用super的init方法，这是为了初始化父类的一些成员变量和其他属性</span></span><br><span class="line">   <span class="keyword">self</span>=[<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">   <span class="comment">// 判断对象是否初始化成功，如果对象初始化成功，再进行接下来的自定义初始化</span></span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">self</span>!=<span class="literal">nil</span>) &#123;</span><br><span class="line">          _age=<span class="number">10086</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回一个已经初始化完毕的对象</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码不够简化，一般用下面代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">-(id)<span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="comment">// 简化版</span></span><br><span class="line">   <span class="keyword">if</span>([<span class="keyword">super</span> <span class="keyword">init</span>]) &#123;</span><br><span class="line">       _age=<span class="number">10086</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="29-自定义构造方法"><a href="#29-自定义构造方法" class="headerlink" title="29.自定义构造方法"></a>29.自定义构造方法</h2><p>要求：是对象方法（对象的初始化），返回值是id类型，方法名以initWith开头。<br>注意：-init方法重写不需要在@interface中声明，因为已经声明过了，而自定义的构造方法需要在@interface中显式声明。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line">-(<span class="keyword">id</span>)initWithAge:(<span class="keyword">int</span>)age;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line">-(<span class="keyword">id</span>)initWithAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">   <span class="keyword">if</span>([<span class="keyword">super</span> init]) &#123;</span><br><span class="line">       _age=age+<span class="number">100</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用示例：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Person *p=[Person alloc]<span class="comment">;</span></span><br><span class="line">p=[p init]<span class="comment">;</span></span><br><span class="line">int r=p.age<span class="comment">;</span></span><br><span class="line">NSLog(@”r的值是%i”,r)<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">p= [p initWithAge:<span class="number">110</span>]<span class="comment">;</span></span><br><span class="line">int r2=p.age<span class="comment">;</span></span><br><span class="line">NSLog(@”r2的值是%i”,r2)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>显而易见一个对象可以初始化多次。</p>
<p>含有多个参数的构造方法：<br><code>-(id)initWithAge:(int)age andNumber:(int)number;</code></p>
<h2 id="30-h文件和-m文件"><a href="#30-h文件和-m文件" class="headerlink" title="30. .h文件和.m文件"></a>30. .h文件和.m文件</h2><p>每个类分布在不同的文件中<br>类的声明放在.h文件中，类的实现放在.m文件中<br>若想使用某个类，就包含某个类的.h文件即可。</p>
<h2 id="31-分类"><a href="#31-分类" class="headerlink" title="31.分类"></a>31.分类</h2><p>场合：在不修改原来类模型的情况下，给类扩充一些方法，且仅是方法，不扩充成员变量。可以给系统自带的类添加分类，扩充方法。（注意引入分类文件）<br>当添加分类的方法是重写原来类中的方法时,不需要引入分类文件。<br>声明文件的命名方式 【类+分类.h】</p>
<pre><code>@interface 类名 (分类名)
@end
</code></pre><p>实现文件的命名方式 【类+分类.m】</p>
<pre><code>@implementation 类名 (分类名)
@end
</code></pre><p>特征：用括号括住添加的分类<br>好处：一个庞大的类可以分模块开发、由多个人编写，有利于团队合作。</p>
<h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><p>1，分类可以访问原来类中的成员变量，但不能增加成员变量。（若要增加成员变量，可以使用继承）</p>
<p>2，分类的优先级最高，当调用类中的一个方法时，优先去分类中查找，再去原类中查找，最后去父类中查找。也即，倘若在分类中重写了原类中的方法，会覆盖掉原来的方法，导致原来的方法无法使用。（不建议重写原来类中的方法）<br>重写会出现警告：Category is implementing a method which will also be implemented by its primary class.</p>
<p>3，如果多个分类中有相同（方法签名相同，但不一样）的方法，则调用的是最后编译的方法。</p>
<h2 id="32-类的私有方法"><a href="#32-类的私有方法" class="headerlink" title="32.类的私有方法"></a>32.类的私有方法</h2><ul>
<li>方式1，直接在.m文件中写方法实现，不要在.h文件中进行方法声明</li>
<li>方式2，在.m文件中定义一个category，然后在category中声明一些方法，最后在@implementation和@end之间作方法实现。</li>
</ul>
<h2 id="33-类的本质"><a href="#33-类的本质" class="headerlink" title="33.类的本质"></a>33.类的本质</h2><p>类也是一个对象，是Class类型的对象，简称类对象，类对象就是类。<br>class类型的定义:<code>typedef struct objc_class *Class;</code><br>类名代表着类对象，每个类只有一个类对象。</p>
<h2 id="34-load"><a href="#34-load" class="headerlink" title="34.+load"></a>34.+load</h2><p>在程序启动的时候，就会加载所有的类和分类，并调用一次所有类和分类的+load方法；</p>
<ul>
<li>先加载父类，再加载子类，也即先调用父类的+load方法，再调用子类的+load方法;</li>
<li>先加载原始类，再加载分类（顺序也即父类——父类的分类——子类）。</li>
<li>不管程序运行过程中有没有用到这个类，都会调用+load加载。</li>
</ul>
<h2 id="35-initialize"><a href="#35-initialize" class="headerlink" title="35.+initialize"></a>35.+initialize</h2><p>在第一次使用某个类时（比如创建对象），就会调用一次+initialize方法<br>一个类只会调用一次+initialize方法，先调用父类的，再调用子类的<br>获取类对象的两种方式</p>
<pre><code>Class c = [Person class];//类方法
</code></pre><p>或者</p>
<pre><code>Person *p = [Person new];
Class c = [p class];//对象方法
</code></pre><p>很明显，[p class]和[Person class]方法返回的都是是class类型<br>类对象调用类方法：</p>
<pre><code>Class c=[Person class];
Person *p2=[c new];
</code></pre><h2 id="36-description方法"><a href="#36-description方法" class="headerlink" title="36.description方法"></a>36.description方法</h2><p>类似其他语言的ToString方法，NSObject自带的方法。返回值类型是<code>NSString ＊</code><br>默认情况下，使用NSLog和%@打印一个对象，输出的是&lt;类名:内存地址&gt;<br>如：<code>&lt;Person: 0x1002070a0&gt;</code><br>而NSLog(@”%@”,p)会调用-description方法</p>
<h3 id="description方法"><a href="#description方法" class="headerlink" title="-description方法"></a>-description方法</h3><p>使用NSLog和%@输出某个对象时，会调用对象的-description方法</p>
<h3 id="description方法-1"><a href="#description方法-1" class="headerlink" title="+description方法"></a>+description方法</h3><p>使用NSLog和%@输出某个类对象时，会调用类对象的+description方法</p>
<p>可以重写+description和-description方法修改NSLog的默认输出<br>注意：如果在-description方法中使用NSLog打印self，会造成死循环。</p>
<pre><code>// 重写-description方法
-(NSString *)description {
    return [NSString stringWithFormat:@”%@”, self];    
}
</code></pre><p>编译无警告，无报错，运行出错。<br>真正重写：<br>假设属性为</p>
<pre><code>// 重写-description方法
-(NSString *)description {
  return [NSString stringWithFormat:@”姓名：%@ 年龄：%d”, _name,_age];
}
</code></pre><h2 id="37-SEL"><a href="#37-SEL" class="headerlink" title="37.SEL"></a>37.SEL</h2><p>每个类的方法列表都存储在类对象中,每个方法都有一个与之对应的SEL类型的对象<br>根据一个SEL对象就可以找到方法的地址，进而调用方法<br>SEL类型定义</p>
<pre><code>typedef struct objc_selector *SEL;
</code></pre><p>SEL对象的创建：</p>
<pre><code>SEL s=@selector(test);
SEL s2=NSSelectorFromString(@”test”);
</code></pre><p>将SEL对象转换为NSString对象</p>
<pre><code>NSString *s3=NSStringFromSelector(s);
</code></pre><p>调用对象p的show方法：</p>
<pre><code>// 创建p对象
Person *p=[[Person alloc] init];
// 将show方法封装为SEL类型数据的s
SEL s=@selector(show);
// 调用s间接调用show方法
[p performSelector:s];
</code></pre><h2 id="38-p-test-原理解释"><a href="#38-p-test-原理解释" class="headerlink" title="38. [p test]原理解释"></a>38. [p test]原理解释</h2><ol>
<li>把test包装成SEL类型的数据</li>
<li>根据SEL数据找到对应的方法地址</li>
<li>根据方法地址调用相应的方法<br>消息就是SEL。</li>
</ol>
<h2 id="39-NSLog方法总结"><a href="#39-NSLog方法总结" class="headerlink" title="39.NSLog方法总结"></a>39.NSLog方法总结</h2><ol>
<li><p>打印对象的内存地址</p>
<pre><code>NSLog(@”%p”,p);
</code></pre></li>
<li><p>打印指针的内存地址（&amp;p取出地址）</p>
<pre><code>NSLog(@”%p”,&amp;p);
</code></pre></li>
<li><p>打印某一对象（默认返回类名+内存地址，可以通过重写-description方法改变输出内容）</p>
<pre><code>NSLog(@”%@”,p);
</code></pre></li>
<li><p>打印代码行号</p>
<pre><code>NSLog(@”%d”,__LINE__);
</code></pre></li>
<li><p>打印文件路径</p>
<pre><code>NSLog(@”%d”,__FILE__);
</code></pre><p>注意：如果文件路径中存在中文，则无法输出<br>这时可以使用：</p>
<pre><code>printf(“%s\n”__FILE__);输出包含中文字符的路径（\n只是为了观看清晰）
</code></pre></li>
<li><p>打印当前函数名称</p>
<pre><code>NSLog(@”%s”,__func__);
</code></pre><h2 id="40-代理"><a href="#40-代理" class="headerlink" title="40.代理"></a>40.代理</h2></li>
</ol>
<p>一系列方法的列表（不能增加成员变量）。其中声明的方法可以被任何类实现，这种模式一般称作代理（delegation）。<br>如果一些类之间没有继承的关系，但是有某些相同的行为，这时要考虑使用代理。<br>代理的定义：<br>当一代理只针对某个类中，代理最好放在一个类的.h文件中，使用时引入即可。（假定在Person.h文件中）</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 要在@interface之外设置代理</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MyProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">// 必须实现的方法</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">-(<span class="keyword">void</span>)show;</span><br><span class="line">-(<span class="keyword">void</span>)myShow;</span><br><span class="line"><span class="comment">// 可选实现的方法</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">+(<span class="keyword">void</span>)herShow;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在Dog.h文件中遵守协议：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">// 声明协议@protocol  MyProtocol;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span>  <span class="title">MyProtocol</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">NSObject</span>&lt;<span class="title">MyProtocol</span>&gt;</span></span><br><span class="line"><span class="comment">// 遵守某个协议</span></span><br><span class="line"><span class="comment">// 注意导入协议文件#import "Person.h"或者声明协议@protocol  MyProtocol;</span></span><br><span class="line">-(<span class="keyword">void</span>)show;</span><br><span class="line">-(<span class="keyword">void</span>)myShow;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>当某一代理用在多个类中，协议需要放在单独创建的.h文件中<br>此时创建的只有一个名为BigProtocol的.h文件。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">BigProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">-(<span class="keyword">void</span>)bigShow;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">-(<span class="keyword">void</span>)bigShow2;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在Cat.h文件中遵守协议</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">//@protocol BigProtocol;</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"BigProtocol.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Cat</span> : <span class="title">NSObject</span>&lt;<span class="title">BigProtocol</span>&gt;</span></span><br><span class="line">-(<span class="keyword">void</span>)bigShow;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在Dog.h文件中遵守协议</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">//@protocol BigProtocol;</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"BigProtocol.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_Dog</span> : <span class="title">NSObject</span>&lt;<span class="title">BigProtocol</span>&gt;</span></span><br><span class="line">-(<span class="keyword">void</span>)bigShow;</span><br><span class="line">-(<span class="keyword">void</span>)bigShow2;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>在遵守协议时，如果使用@protocol BigProtocol;编译器会警告：无法找到协议的定义<br>而使用<code>#import “BigProtocol.h“</code>，则完全没有问题。</p>
</li>
<li><p>如果某个类遵守多个协议，协议之间用逗号分隔：</p>
<pre><code>@interface Cat : NSObject&lt;BigProtocol,MyProtocol&gt;
</code></pre></li>
<li><p>一个协议本身可以遵守其他协议，如遵守名字叫NSObject的协议（默认是这种情况，基协议NSObject）<br>如果A协议遵守B协议，这时A协议就能拥有B协议的所有方法声明。</p>
<pre><code>@protocol BigProtocol &lt;NSObject&gt;
@end
</code></pre></li>
</ol>
<p>BigProtocol拥有NSObject协议的所有方法声明。</p>
<ol start="4">
<li><p>约定框架中后缀为Delegate的都是协议。（协议类似其他语言的接口，就像C#中默认以I开头的都是接口 ）</p>
</li>
<li><p>要求某个对象必须遵守某个协议（如要求obj保存的对象遵守协议MyProtocol，并且继承Person）</p>
<pre><code>Person&lt;MyProtocol&gt; *obj=[[Person alloc] init];
</code></pre></li>
<li><p>利用conformsToProtocol:判断某个类是否实现了某个协议</p>
<pre><code>Cat *c=[[Cat alloc] init ];
bool result=  [c conformsToProtocol:@protocol(BigProtocol)];
NSLog(@&quot;%@&quot;,result?@&quot;YES&quot;:@&quot;NO&quot;);
[c conformsToProtocol:@protocol(BigProtocol)];返回的是bool类型。
</code></pre></li>
</ol>
<h2 id="41-block"><a href="#41-block" class="headerlink" title="41.block"></a>41.block</h2><p>块。<br>有返回值（void也可以）、有形参。block封装了一段代码，可以在任何时候执行。block可以作为函数参数或者函数返回值，而其本身又可以带输入参数和返回值。<br>在多线程，异步任务，集合遍历，集合排序，动画专场使用较多。</p>
<p>定义: <code>返回值类型  (^+block名称)(参数类型列表)=^(参数列表){   代码内容  };</code></p>
<ol>
<li><p>注意大括号后面有分号</p>
</li>
<li><p>对比函数</p>
</li>
</ol>
<pre><code>int (^MySum)(int ,int )=^(int a,int b){ return a+b;};
int     MySum (int a,int b){return a+b;}
</code></pre><ol start="3">
<li>block可以访问局部变量，但不能更改局部变量。<br>如果更改则报错：<code>Variable is not assignable (missing__block type specifier)</code>，如：</li>
</ol>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c=<span class="number">10</span>;</span><br><span class="line"><span class="comment">// Block的定义</span></span><br><span class="line"><span class="keyword">int</span> (^MySum)(<span class="keyword">int</span> ,<span class="keyword">int</span> )=^(<span class="keyword">int</span> a,<span class="keyword">int</span> b) &#123;</span><br><span class="line">   c=<span class="number">21</span>;</span><br><span class="line">   <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@"%i<span class="string">",MySum(10,20));</span></span><br></pre></td></tr></table></figure>
<p>如果硬是要修改：在局部变量前面加上<code>__block</code> ，如   <code>__block int c=21;</code>这时，便可以在block中修改局部变量了。</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">__block  <span class="keyword">int</span> c=<span class="number">10</span>;</span><br><span class="line"><span class="comment">// Block的定义</span></span><br><span class="line"><span class="keyword">int</span> (^MySum)(<span class="keyword">int</span> ,<span class="keyword">int</span> )=^(<span class="keyword">int</span> a,<span class="keyword">int</span> b) &#123;</span><br><span class="line">    c=<span class="number">21</span>;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@"%i<span class="string">",MySum(10,20));</span></span><br></pre></td></tr></table></figure>
<p>4 . block的调用，和函数一样，使用名称即可：<code>MySum(_形参列表);</code></p>
<p>5 . 如果block没有形参，则可以省略等号后面的()<br>如： <code>int (^SomeSum)()=^{return 25;};</code></p>
<p>但是等号前面的两对括号不可省略。</p>
<p>6 . 利用typedef声明类型</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">格式：<span class="keyword">typedef</span>  返回值类型 (^block块名称)(参数_类型列表)</span><br><span class="line">例如：<span class="keyword">typedef</span> <span class="keyword">int</span> (^MyBlock)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">    </span><br><span class="line">以后就可以用MyBlock这种类型定义Block变量</span><br><span class="line">MyBlock m=^(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line"><span class="keyword">int</span> c=m(<span class="number">15</span>,<span class="number">25</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(@”%i”,c);</span><br></pre></td></tr></table></figure>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/Objective-C/">Objective-C</a>
            <a href="/tags/笔记/">笔记</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2016/10/10/CocoaPods的安装与使用/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">CocoaPods的安装与使用</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        </div><div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  <span class="division"> </span>
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://chenyalun.com"></a>
  </span>

  <span class="copyright-year">&copy;2014 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
