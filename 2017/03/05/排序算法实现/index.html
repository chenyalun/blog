<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="排序算法实现"/>




  <meta name="keywords" content="Python,算法,排序," />




  <link rel="alternate" href="/atom.xml" title="Ya">






<link rel="canonical" href="http://blog.chenyalun.com/2017/03/05/排序算法实现/"/>


<meta name="description" content="2017.4.24 修改部分代码2017.4.21 完善2017.3.25 修改   排序算法。">
<meta name="keywords" content="Python,算法,排序">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法实现">
<meta property="og:url" content="http://blog.chenyalun.com/2017/03/05/排序算法实现/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="2017.4.24 修改部分代码2017.4.21 完善2017.3.25 修改   排序算法。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://static.chenyalun.com/2017/03/15/2017031501.gif">
<meta property="og:image" content="http://static.chenyalun.com/2017/03/15/2017031503.gif">
<meta property="og:image" content="http://static.chenyalun.com/2017/03/15/2017031502.gif">
<meta property="og:image" content="http://static.chenyalun.com/2017/03/15/2017031504.jpg">
<meta property="og:updated_time" content="2017-04-26T01:06:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序算法实现">
<meta name="twitter:description" content="2017.4.24 修改部分代码2017.4.21 完善2017.3.25 修改   排序算法。">
<meta name="twitter:image" content="http://static.chenyalun.com/2017/03/15/2017031501.gif">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=" />







<script>
  var CONFIG = {
    search: function search() { [native code] },
    searchPath: "/search.xml",
    fancybox: ,
    toc: ,
  }
</script>




  

  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-82867422-1', 'auto');
        ga('send', 'pageview');
  </script>



    <title> 排序算法实现 · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          排序算法实现
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017年3月5日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#排序的稳定性"><span class="toc-text">排序的稳定性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内排序与外排序"><span class="toc-text">内排序与外排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、冒泡排序"><span class="toc-text">一、冒泡排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、选择排序"><span class="toc-text">二、选择排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、直接插入排序"><span class="toc-text">三、直接插入排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、二分插入排序"><span class="toc-text">四、二分插入排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、希尔排序"><span class="toc-text">五、希尔排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、堆排序"><span class="toc-text">六、堆排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、归并排序"><span class="toc-text">七、归并排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八、快速排序"><span class="toc-text">八、快速排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#九、计数排序"><span class="toc-text">九、计数排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#十、总结"><span class="toc-text">十、总结</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <blockquote>
<p>2017.4.24 修改部分代码<br>2017.4.21 完善<br>2017.3.25 修改</p>
</blockquote>
<p align="center"> 排序算法。 </p>

<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为笔试使用的编译器语言为Python2.7，所以以下代码使用Python2实现并规定从小到大为目标顺序。</p>
<p>八大排序：<br>直接插入排序，希尔排序，简单选择排序，堆排序，冒泡排序，快速排序，归并排序，基数排序。</p>
<h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>假定n1 = n2,排序前n1位于n2前面,如果排序后n1扔领先于n2,则称排序算法稳定.</p>
<h2 id="内排序与外排序"><a href="#内排序与外排序" class="headerlink" title="内排序与外排序"></a>内排序与外排序</h2><p>内排序:排序的整个过程中,待排序的所有记录全部被放置在内存中.<br>外排序:由于排序的记录太多,排序的过程中,需要内外存之间多次交换才能进行.</p>
<h1 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h1><p>原理:通过相邻元素的比较和交换，把较大的数交换到后面，类似水泡向上面(数组的后面，所以总是靠后的数字有序)升，故称为冒泡排序。如果两数相等，不交换，所以稳定。</p>
<p>普通方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(tempList)</span>:</span></span><br><span class="line">	n = len(tempList)</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</span><br><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">1</span>, n - x):<span class="comment"># 索引n-x之后的数已经排序好了</span></span><br><span class="line">			<span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]:</span><br><span class="line">				tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y]</span><br><span class="line">	<span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> bubbleSort([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</span><br></pre></td></tr></table></figure>
<p>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，无需继续迭代。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#交换排序-冒泡排序优化1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort1</span><span class="params">(tempList)</span>:</span></span><br><span class="line">	n = len(tempList)</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</span><br><span class="line">		<span class="comment">#标志位,倘若没有交换,说明已经排序好了</span></span><br><span class="line">		flag = <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">1</span>, n - x):<span class="comment"># 索引n-x之后的数已经排序好了</span></span><br><span class="line">			<span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]:</span><br><span class="line">				tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y]</span><br><span class="line">				flag = <span class="keyword">False</span></span><br><span class="line">		<span class="keyword">if</span> flag: <span class="comment"># 发现并没有发生交换</span></span><br><span class="line">			<span class="keyword">return</span> tempList</span><br><span class="line">	<span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> bubbleSort1([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</span><br></pre></td></tr></table></figure>
<p>优化2：记录最后发生交换的位置，位置之后的数据已经井然有序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#交换排序-冒泡排序优化2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort2</span><span class="params">(tempList)</span>:</span></span><br><span class="line">	n = len(tempList)</span><br><span class="line">	<span class="comment"># 循环范围</span></span><br><span class="line">	m = n</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</span><br><span class="line">		<span class="comment">#标志位,倘若没有交换,说明已经排序好了</span></span><br><span class="line">		flag = <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">1</span>, m):<span class="comment"># 索引m之后的数已经排序好了</span></span><br><span class="line">			<span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]:</span><br><span class="line">				tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y]</span><br><span class="line">				m = y</span><br><span class="line">				flag = <span class="keyword">False</span></span><br><span class="line">		<span class="keyword">if</span> flag: <span class="comment"># 发现并没有发生交换</span></span><br><span class="line">			<span class="keyword">return</span> tempList</span><br><span class="line">	<span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> bubbleSort2([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong><br>最好情况:数据井然有序,根据优化后的代码,只需要迭代一次,即n-1次的比较,则时间复杂度为O(n)<br>最坏情况:数据逆序,需要比较的次数为1+2+3+4+…+(n-1)=n(n-1)/2次,时间复杂度为O(n^2)</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">假定有4个数,分别为4<span class="number"> 3 </span>2 1,排序过程为:</span><br><span class="line">原数据:<span class="number"> 4 </span>3<span class="number"> 2 </span>1</span><br><span class="line">第1次:<span class="number"> 3 </span>4<span class="number"> 2 </span>1</span><br><span class="line">第2次:<span class="number"> 3 </span>2<span class="number"> 4 </span>1</span><br><span class="line">第3次:<span class="number"> 3 </span>2<span class="number"> 1 </span>4</span><br><span class="line">第4次:<span class="number"> 2 </span>3<span class="number"> 1 </span>4</span><br><span class="line">第5次:<span class="number"> 2 </span>1<span class="number"> 3 </span>4</span><br><span class="line">第6次:<span class="number"> 1 </span>2<span class="number"> 3 </span>4</span><br><span class="line"></span><br><span class="line">归纳推理:n(n-1)/2次</span><br></pre></td></tr></table></figure>
<h1 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h1><p>在未排序序列中找到最小元素，存放到排序序列的起始位置(与第一个元素交换位置)，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾(与第二个元素交换位置)。以此类推，直到所有元素均排序完毕。</p>
<p>通过n-i次关键字间的比较,从n-i+1个记录中选出最小的记录,并和第i个记录交换之.</p>
<p>选择排序的交换操作介于 0 和 ( n − 1 )次之间。<br>选择排序的比较操作为 n ( n − 1 ) / 2次之间。<br>选择排序的赋值操作介于 0 和 3 ( n − 1 )次之间。</p>
<p>当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">def selectionSort(tempList):</span><br><span class="line">	n = len(tempList)</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</span><br><span class="line">		<span class="meta"># 假定索引x对应的是最小值</span></span><br><span class="line">		<span class="keyword">index</span> = x</span><br><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> xrange(x + <span class="number">1</span>,n):</span><br><span class="line">			<span class="meta"># 如果找到比索引index对应的值还要小的值,交换两者位置</span></span><br><span class="line">			<span class="keyword">if</span> tempList[<span class="keyword">index</span>] &gt; tempList[y]:</span><br><span class="line">				tempList[<span class="keyword">index</span>], tempList[y] = tempList[y], tempList[<span class="keyword">index</span>]</span><br><span class="line">	<span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print selectionSort([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong><br>特点:交换移动数据次数相当少<br>最好情况与最坏情况:比较次数一样多,为n(n-1)/2次,时间复杂度:O(n^2)</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">假定有4个数据,分别为<span class="number"> 4 </span>3<span class="number"> 2 </span>1</span><br><span class="line">原数据:<span class="number"> 4 </span>3<span class="number"> 2 </span>1</span><br><span class="line">第1次比较:<span class="number"> 4 </span>与 3</span><br><span class="line">第2次比较:<span class="number"> 4 </span>与 2</span><br><span class="line">第3次比较:<span class="number"> 4 </span>与<span class="number"> 1 </span>(此时数据为1<span class="number"> 3 </span>2 4)</span><br><span class="line">第4次比较:<span class="number"> 3 </span>与 2</span><br><span class="line">第5次比较:<span class="number"> 3 </span>与<span class="number"> 4 </span>(此时数据为<span class="number"> 1 </span>2<span class="number"> 3 </span>4)</span><br><span class="line">第6次比较:<span class="number"> 3 </span>与 4</span><br><span class="line"></span><br><span class="line">最终结果:<span class="number"> 1 </span>2<span class="number"> 3 </span>4</span><br><span class="line">比较次数:6次</span><br></pre></td></tr></table></figure>
<p>选择排序是不稳定的排序算法,比如<code>5 8 5 2 9</code>,显然第1个5最终落到第2个5的后面.</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">原数据:    5'<span class="number"> 8 </span>5<span class="number"> 2 </span>9</span><br><span class="line">第1次交换:<span class="number"> 2 </span>8<span class="number"> 5 </span>5' 9</span><br><span class="line">第2次交换:<span class="number"> 2 </span>5<span class="number"> 8 </span>5' 9</span><br><span class="line">第3次交换:<span class="number"> 2 </span>5 5'<span class="number"> 8 </span>9</span><br><span class="line">第4次交换:<span class="number"> 2 </span>5 5'<span class="number"> 8 </span>9</span><br><span class="line"></span><br><span class="line">最终 5'在<span class="number"> 5 </span>的前面.</span><br></pre></td></tr></table></figure>
<h1 id="三、直接插入排序"><a href="#三、直接插入排序" class="headerlink" title="三、直接插入排序"></a>三、直接插入排序</h1><p>原理:在一个已经有序的数据序列中插入一个数，在插入后此数据序列仍然有序。默认前1个数有序，第二个数与前一个数组成的有序数列比较并插入，第三个数与前两个数组成的有序数列比较并插入……所以总是靠前的数字有序。</p>
<p>遇到相等的数，插入到该数的后面，而不是前面，所以是稳定排序算法。</p>
<p><img src="http://static.chenyalun.com/2017/03/15/2017031501.gif" alt=""></p>
<p>最好情况：序列已经是升序排列了，需要进行的比较操作需(n-1)次,时间复杂度为O(n)。<br>最坏情况：序列是降序排列，那么此时需要进行的比较共有 n ( n − 1 ) / 2 次。<br>插入排序的赋值操作是比较操作的次数加上(n-1)次。<br>平均来说插入排序算法复杂度为 O ( n^2 )。<br>插入排序不适合对于数据量比较大的排序应用。<strong>用于少量元素的排序</strong>（通常为8个或以下）。</p>
<p>直接插入</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(tempList)</span></span><span class="symbol">:</span></span><br><span class="line">	<span class="comment"># 获取列表的长度</span></span><br><span class="line">	n = len(tempList)</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>,n): <span class="comment"># 从第1个元素而非第0个元素开始遍历</span></span><br><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> xrange(x, <span class="number">0</span>, -<span class="number">1</span>): <span class="comment"># 在已经排好序的列表中逐个扫描</span></span><br><span class="line">			<span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]: <span class="comment"># 如果当前元素比前面的小</span></span><br><span class="line">				tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y] <span class="comment"># 两者位置互换</span></span><br><span class="line">	<span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"><span class="comment"># print insertionSort([])</span></span><br><span class="line"><span class="comment"># print insertionSort([8])</span></span><br><span class="line"><span class="comment"># print insertionSort([5,2,7,0,1,5,9])</span></span><br></pre></td></tr></table></figure>
<h1 id="四、二分插入排序"><a href="#四、二分插入排序" class="headerlink" title="四、二分插入排序"></a>四、二分插入排序</h1><p>二分查找插入与希尔排序是直接插入排序的优化。</p>
<p>二分查找插入</p>
<p>使用Python模块实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bisect模块实现了一个算法, 用于向一个有序列表中插入一个元素,不改变列表的序列</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用这个模块的函数前先确保操作的列表是已排序的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">import bisect </span></span><br><span class="line">def insertionSortBisect(tempList):  </span><br><span class="line">    for i in xrange(1, len(tempList)):  </span><br><span class="line">        bisect.insort(tempList, tempList.pop(i), 0, i) # 排序列表,移除并插入元素,区间开始,区间结束</span><br><span class="line">    return tempList</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">print</span> insertionSortBisect([])</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">print</span> insertionSortBisect([8])</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">print</span> insertionSortBisect([5,2,7,0,1,5,9])</span></span><br></pre></td></tr></table></figure>
<p>手动实现</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二分查找的前提必须待查找的序列有序</span></span><br><span class="line"><span class="comment"># 在有序列表中,返回值m应该所在的索引</span></span><br><span class="line">def indexOfInsertionSort(tempList, m):</span><br><span class="line">	<span class="comment"># 获取列表的长度</span></span><br><span class="line">	n = <span class="built_in">len</span>(tempList)</span><br><span class="line">	left, <span class="literal">right</span> = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> left &lt;= <span class="literal">right</span>:</span><br><span class="line">		<span class="keyword">middle</span> = (left + <span class="literal">right</span>) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> tempList[<span class="keyword">middle</span>] &lt; m:<span class="comment"># 右半部分</span></span><br><span class="line">			left = <span class="keyword">middle</span> + <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>: <span class="comment">#左半部分,含相同元素</span></span><br><span class="line">			<span class="literal">right</span> = <span class="keyword">middle</span> <span class="number">-1</span></span><br><span class="line">	<span class="literal">return</span> <span class="literal">right</span> +<span class="number">1</span></span><br><span class="line">		</span><br><span class="line">def insertionSortbin(tempList):</span><br><span class="line">	<span class="comment"># 获取列表的长度</span></span><br><span class="line">	n = <span class="built_in">len</span>(tempList)</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>,n): <span class="comment"># 从头至尾遍历列表中的元素</span></span><br><span class="line">		m = tempList[x]</span><br><span class="line">		tempList.pop(x)</span><br><span class="line">		index = indexOfInsertionSort(tempList[<span class="number">0</span>:x],m)</span><br><span class="line">		tempList.insert(index , m) <span class="comment">#第一个参数是索引,第二个参数是数值</span></span><br><span class="line">	<span class="literal">return</span> tempList</span><br><span class="line">				</span><br><span class="line"><span class="comment">#print insertionSortbin([12,12,16,8,5,10,7])</span></span><br></pre></td></tr></table></figure>
<h1 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a>五、希尔排序</h1><p>先将待排记录序列分割为若干个子序列，分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序。</p>
<p>采用跳跃分割的策略:把相距某个”增量”的记录组成一个序列，保证在子序列内分别进行直接插入排序后得到的结果是基本有序的。</p>
<p>原始序列</p>
<blockquote>
<p>2 5 1 9 8 2 10 4</p>
</blockquote>
<p>4步长，分组，每列排序</p>
<blockquote>
<p>2 5 1 9<br>8 2 10 4</p>
</blockquote>
<p>排序后</p>
<blockquote>
<p>2 2 1 4<br>8 5 10 9</p>
</blockquote>
<p>也即</p>
<blockquote>
<p>2 2 1 4 8 5 10 9</p>
</blockquote>
<p>2步长，再分组</p>
<blockquote>
<p>2 2<br>1 4<br>8 5<br>10 9</p>
</blockquote>
<p>排序</p>
<blockquote>
<p>1 2<br>2 4<br>8 5<br>10 9</p>
</blockquote>
<p>也即：</p>
<blockquote>
<p>1 2 2 4 8 5 10 9</p>
</blockquote>
<p>最后以1步长进行排序（还是直接插入排序）。</p>
<p>一般插入</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def insertionSortShell(tempList):</span><br><span class="line">	n = len(tempList)</span><br><span class="line">	# 确定分组,假定n = 6</span><br><span class="line"><span class="built_in">	group </span>= n / 2 # 此时group = 3,分成3组,3组元素索引分别为3与3-3,4与4-3,5与5-3</span><br><span class="line">	<span class="keyword">while</span><span class="built_in"> group </span>&gt; 0:</span><br><span class="line">		#x从3到5</span><br><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> xrange(group,n):</span><br><span class="line">			# 每组元素:x,x-group,x-group-group <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>插入排序</span><br><span class="line">			temp = tempList[x]</span><br><span class="line">			y = x</span><br><span class="line">			# 这里使用简单的插入排序</span><br><span class="line">			<span class="keyword">while</span> y &gt;=<span class="built_in"> group </span><span class="keyword">and</span> tempList[y - group] &gt; temp:</span><br><span class="line">				tempList[y] = tempList[y - group]</span><br><span class="line">				y -= group</span><br><span class="line">			tempList[y] = temp</span><br><span class="line"></span><br><span class="line">	<span class="built_in">	group </span>/= 2</span><br><span class="line">	return tempList</span><br></pre></td></tr></table></figure>
<p>互换法</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def insertionSortShellExchange(tempList):</span><br><span class="line">	n = len(tempList)</span><br><span class="line">	# 确定分组,假定n = 6</span><br><span class="line"><span class="built_in">	group </span>= n / 2 # 此时group = 3,分成3组,3组元素索引分别为3与3-3,4与4-3,5与5-3</span><br><span class="line">	<span class="keyword">while</span><span class="built_in"> group </span>&gt; 0:</span><br><span class="line">		#x从3到5</span><br><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> xrange(group,n):</span><br><span class="line">			# 每组元素:x,x-group,x-group-group <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>插入排序</span><br><span class="line">			y = x</span><br><span class="line">			m = tempList[x]</span><br><span class="line">			<span class="keyword">while</span> y &gt;=<span class="built_in"> group </span><span class="keyword">and</span> tempList[y - group] &gt; m:</span><br><span class="line">				# 这里直接交换位置</span><br><span class="line">				tempList[y], tempList[y - group] = tempList[y - group], tempList[y]</span><br><span class="line">				y -= group</span><br><span class="line"></span><br><span class="line">	<span class="built_in">	group </span>/= 2</span><br><span class="line">	return tempList</span><br><span class="line"></span><br><span class="line"><span class="comment">#print insertionSortShell([1,8,10,2,4,0])</span></span><br><span class="line"><span class="comment">#print insertionSortShellExchange([1,8,10,2,4,0])</span></span><br></pre></td></tr></table></figure>
<p>由于记录是跳跃式的，希尔排序是不稳定的排序算法。</p>
<h1 id="六、堆排序"><a href="#六、堆排序" class="headerlink" title="六、堆排序"></a>六、堆排序</h1><p>堆排序是对简单选择排序的改进。</p>
<p>堆是具有以下性质的完全二叉树:<br>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。<br>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<p>性质:按层遍历的方式给结点编号，则有:</p>
<pre><code>k(i) &gt;= k(2i)
k(i) &gt;= k(2i+1)

或
k(i) &lt;= k(2i)
k(i) &lt;= k(2i+1)
</code></pre><p>堆排序就是利用堆进行排序的算法，基本思想是:将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根结点。把它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个值重新构造成一个堆，这样就会得到n个元素中的次小值，如此反复执行，便能得到一个有序序列了。</p>
<p>需要解决的两个问题:<br><strong>1. 如何由一个无序序列构建成一个堆</strong><br><strong>2. 如何在获取堆顶元素后，调整剩余元素成为一个新的堆</strong></p>
<p>所谓的将待排序的序列构建成一个大顶堆，其实就是从下往上、从右往左，将每个非叶结点当作根节点，将其和其子树调整成大顶堆。</p>
<p>在正式排序时，第i次取堆顶记录重建需要O(logi)的时间，并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为O(nlogn)。</p>
<p>堆排序对原始状态的排序不敏感，无论是最好最坏还是平均情况时间复杂度总是为O(nlogn)。</p>
<p>注意:由于初始构建堆所需的比较次数较多，因此，它并<strong>不适合待排序序列个数较少的情况</strong>。</p>
<p>实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start是当前需要调整最小堆的位置,end是调整边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapAdjust</span><span class="params">(tempList, start, end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        child = root * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> tempList[child] &lt; tempList[child + <span class="number">1</span>]:</span><br><span class="line">            child += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> tempList[root] &lt; tempList[child]:</span><br><span class="line">            tempList[root], tempList[child] = tempList[child], tempList[root]</span><br><span class="line">            root = child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(tempList)</span>:</span></span><br><span class="line">    n = len(tempList)</span><br><span class="line">    <span class="comment"># 构造小顶堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n / <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        heapAdjust(tempList, i, n - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 将堆顶记录和当前未排序子序列的最后一个记录交换</span></span><br><span class="line">        tempList[<span class="number">0</span>], tempList[i] = tempList[i], tempList[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 重新调整为小顶堆</span></span><br><span class="line">        heapAdjust(tempList, <span class="number">0</span>, i - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> heapSort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure>
<h1 id="七、归并排序"><a href="#七、归并排序" class="headerlink" title="七、归并排序"></a>七、归并排序</h1><p>归并排序就是利用归并的思想实现的排序算法。原理是:假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两合并，得到n/2的向上取整个长度为2或者为1的有序子序列，然后两两合并，如此重复，直到得到一个长度为n的有序序列。该方法也称为2路归并排序。</p>
<p>比较操作的次数介于 ( nlogn ) / 2 和 nlogn − n + 1。<br>赋值操作的次数是 ( 2 nlogn )。</p>
<p><img src="http://static.chenyalun.com/2017/03/15/2017031503.gif" alt=""></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment">#归并排序</span></span><br><span class="line">def mergeSort(tempList):</span><br><span class="line">	<span class="built_in">length</span> = <span class="built_in">len</span>(tempList)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">length</span> &lt;= <span class="number">1</span>:</span><br><span class="line">		<span class="literal">return</span> tempList</span><br><span class="line">	<span class="comment"># 二分列表</span></span><br><span class="line">	<span class="keyword">middle</span> = <span class="built_in">length</span> / <span class="number">2</span></span><br><span class="line">	leftList = mergeSort(tempList[:<span class="keyword">middle</span>])</span><br><span class="line">	rightList = mergeSort(tempList[<span class="keyword">middle</span>:])</span><br><span class="line"></span><br><span class="line">	<span class="literal">return</span> <span class="built_in">merge</span>(leftList,rightList)</span><br><span class="line"></span><br><span class="line">def <span class="built_in">merge</span>(leftList,rightList):</span><br><span class="line">	leftIndex,rightIndex = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="built_in">result</span> = []</span><br><span class="line">	<span class="keyword">while</span> leftIndex &lt; <span class="built_in">len</span>(leftList) <span class="keyword">and</span> rightIndex &lt; <span class="built_in">len</span>(rightList):</span><br><span class="line">		<span class="keyword">if</span> leftList[leftIndex] &lt; rightList[rightIndex]:</span><br><span class="line">			<span class="built_in">result</span>.append(leftList[leftIndex])</span><br><span class="line">			leftIndex += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="built_in">result</span>.append(rightList[rightIndex])</span><br><span class="line">			rightIndex += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">result</span> += leftList[leftIndex:]</span><br><span class="line">	<span class="built_in">result</span> += rightList[rightIndex:]</span><br><span class="line">	<span class="literal">return</span> <span class="built_in">result</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print mergeSort([<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>一趟归并需要耗费O(n)时间，由完全二叉树的深度可知，整个归并排序需要进行logn次，故，总的时间复杂度为O(logn)，并且最好/最坏/平均时间性能均是如此。</p>
<p>归并排序需要两两比较，不存在跳跃，因此稳定。</p>
<h1 id="八、快速排序"><a href="#八、快速排序" class="headerlink" title="八、快速排序"></a>八、快速排序</h1><p>20世纪十大算法之一。</p>
<p>关键词:基准 分组 递归</p>
<p>在平均状况下，排序n个项目要Ο(n log n)次比较。<br>在最坏状况下则需要Ο(n2)次比较。</p>
<p><img src="http://static.chenyalun.com/2017/03/15/2017031502.gif" alt=""></p>
<p>快速排序使用分治法策略来把一个序列分为两个子序列。</p>
<p>步骤为：</p>
<ol>
<li>从数列中挑出一个元素，作为基准数，</li>
<li>分区：把比基准大的放在右边，比基准小的放在左边，等于基准的放在基准列表中。</li>
<li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(tempList)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(tempList) &lt;= <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 基准列表</span></span><br><span class="line">	pivotList = []</span><br><span class="line">	<span class="comment"># 比基准小的列表</span></span><br><span class="line">	lessList = []</span><br><span class="line">	<span class="comment"># 比基准大的列表</span></span><br><span class="line">	moreList = []</span><br><span class="line">	<span class="comment">#将第一个值作为基准</span></span><br><span class="line">	pivot = tempList[<span class="number">0</span>]</span><br><span class="line">	<span class="comment"># 遍历tempList</span></span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> tempList:</span><br><span class="line">		<span class="comment"># 比基准大,放入moreList</span></span><br><span class="line">		<span class="keyword">if</span> x &gt; pivot:</span><br><span class="line">			moreList.append(x)</span><br><span class="line">		<span class="comment"># 比基准小,放入lessList</span></span><br><span class="line">		<span class="keyword">elif</span> x &lt; pivot:</span><br><span class="line">			lessList.append(x)</span><br><span class="line">		<span class="comment"># 与基准相等,放入基准列表中</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			pivotList.append(x)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 对lessList和moreList递归操作</span></span><br><span class="line">	lessList = quickSort(lessList)</span><br><span class="line">	moreList = quickSort(moreList)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 返回排序好的列表</span></span><br><span class="line">	<span class="keyword">return</span> lessList + pivotList + moreList</span><br></pre></td></tr></table></figure>
<p>甚至可以这么写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort1</span><span class="params">(tempList)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(tempList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> tempList</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = tempList[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> quickSort1([x <span class="keyword">for</span> x <span class="keyword">in</span> tempList[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; pivot])\</span><br><span class="line">         + [pivot] + \</span><br><span class="line">         quickSort1([x <span class="keyword">for</span> x <span class="keyword">in</span> tempList[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= pivot])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> quickSort1([<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p>快速排序的时间复杂度取决于快速排序递归的深度，在最优情况下时间复杂度为O(logn)。最坏情况下，待排序为正序或者逆序，时间复杂度为O(n^2)</p>
<p>由于关键字的比较和交换是跳跃进行的，因此快速排序不稳定。</p>
<p>快速排序的优化:</p>
<ol>
<li><strong>优化选取枢轴</strong><br>三数取中法:取三个关键字先进行排序，将中间数作为枢轴，一般取左端、右端和中间三个数，也可以随机选取，至少枢轴不是最大或者最小的数。</li>
</ol>
<h1 id="九、计数排序"><a href="#九、计数排序" class="headerlink" title="九、计数排序"></a>九、计数排序</h1><p>计数排序是用来排序0到100之间的数字的最好的算法。</p>
<p>步骤:</p>
<blockquote>
<p>找出待排序的数组中最大和最小的元素<br>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项<br>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p>
</blockquote>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计数排序</span></span><br><span class="line">def countsort(tempList):</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(tempList) &lt;= <span class="number">1</span>:</span><br><span class="line">		<span class="literal">return</span> tempList</span><br><span class="line">		</span><br><span class="line">	maxValue = <span class="built_in">max</span>(tempList)</span><br><span class="line">	minValue = <span class="built_in">min</span>(tempList)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 创建计数列表countList</span></span><br><span class="line">	countList = [<span class="number">0</span>] * (maxValue - minValue + <span class="number">1</span>)</span><br><span class="line">	<span class="comment"># 获取元素出现次数</span></span><br><span class="line">	<span class="keyword">for</span> e <span class="keyword">in</span> tempList:</span><br><span class="line">		countList[e - minValue] += <span class="number">1</span></span><br><span class="line">	index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 填值</span></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">a</span> <span class="keyword">in</span> xrange(maxValue - minValue + <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">for</span> c <span class="keyword">in</span> xrange(countList[<span class="keyword">a</span>]):</span><br><span class="line">			tempList[index] = <span class="keyword">a</span> + minValue</span><br><span class="line">			index += <span class="number">1</span></span><br><span class="line">	<span class="literal">return</span> tempList</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">print countsort([<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>那么,以1,6,3,2,3为例<br>最值<br>maxValue = 6<br>minValue = 1</p>
<p>计数列表<br>countList = [0, 0, 0, 0, 0, 0]</p>
<p>元素出现的次数<br>countList = [1, 1, 2, 0, 0, 1]</p>
<table>
<thead>
<tr>
<th>a</th>
<th>countList[a] 即遍历次数</th>
<th>tempList[index]</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>tempList[0] = 1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>tempList[1] = 2</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>tempList[2] = 3以及tempList[3] = 3</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>tempList[4] = 6</td>
</tr>
</tbody>
</table>
<p>排序成功:1, 2, 3, 3, 6</p>
<h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>算法分析：</p>
<p><img src="http://static.chenyalun.com/2017/03/15/2017031504.jpg" alt=""></p>
<p>代码保存在<a href="https://github.com/ChenYalun/YACode/tree/master/Blog" target="_blank" rel="noopener">GitHub</a>上。</p>
<p>参考资料：</p>
<blockquote>
<p>《大话数据结构》<br><a href="https://zh.wikipedia.org/zh-hans/" target="_blank" rel="noopener">维基百科</a><br><a href="https://segmentfault.com/a/1190000006546190#articleHeader17" target="_blank" rel="noopener">segmentfault</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="noopener">WuChong</a><br><a href="http://bubkoo.com/2014/01/13/sort-algorithm/selection-sort/" target="_blank" rel="noopener">bubkoo</a></p>
</blockquote>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Python/">Python</a>
            
              <a href="/tags/算法/">算法</a>
            
              <a href="/tags/排序/">排序</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/04/02/C提要/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">C提要</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2017/02/26/iOS自定义转场总结/">
        <span class="next-text nav-default">iOS自定义转场总结</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  




    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v="></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v="></script>

    
  <script type="text/html" id="search-result">
    <article class="post">
      <header class="post-header">
        <h1 class="post-title">
          <a href="$url$" class="post-link">
            $title$
          </a>
        </h1>
      </header>
      <div class="post-content">
        $content$
        <div class="read-more">
          <a href="$url$" class="read-more-link">
            ...阅读全文
          </a>
        </div>
      </div>
    </article>
  </script>
  <script type="text/html" id="no-search-result">
    <div class="no-result">
      <h2>No result found!</h2>
    </div>
  </script>
  <script type="text/javascript" src="/js/src/search.js?v="></script>

  </body>
</html>
