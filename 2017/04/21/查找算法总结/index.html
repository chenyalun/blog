<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="算法," />





  <link rel="alternate" href="/atom.xml" title="Ya" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="关于查找算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="查找算法总结">
<meta property="og:url" content="http://blog.chenyalun.com/2017/04/21/查找算法总结/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="关于查找算法。">
<meta property="og:image" content="http://static.chenyalun.com/2017/04/21/170421004.jpg">
<meta property="og:image" content="http://static.chenyalun.com/2017/04/21/170421005.jpg">
<meta property="og:image" content="http://static.chenyalun.com/2017/04/21/170421006.jpg">
<meta property="og:image" content="http://static.chenyalun.com/2017/04/21/170421002.png">
<meta property="og:image" content="http://static.chenyalun.com/2017/04/21/170421001.png">
<meta property="og:image" content="http://static.chenyalun.com/2017/04/21/170421007.png">
<meta property="og:updated_time" content="2017-04-21T12:13:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="查找算法总结">
<meta name="twitter:description" content="关于查找算法。">
<meta name="twitter:image" content="http://static.chenyalun.com/2017/04/21/170421004.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 11510108,
      author: 'YA'
    }
  };
</script>




  <link rel="canonical" href="http://blog.chenyalun.com/2017/04/21/查找算法总结/"/>

  <title> 查找算法总结 | Ya </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-82867422-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Ya</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />
            
            时间线
          </a>
        </li>
      
        
        <li class="menu-item menu-item-reading">
          <a href="/categories/阅读/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            阅读
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                查找算法总结
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-21T19:10:17+08:00" content="2017-04-21">
              2017-04-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p align="center"> 关于查找算法。 </p>

<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文”完全二叉树”的定义采用国内定义<br>B-树 即 B树,两者是相同概念,而非指二叉搜索树(百度百科)</p>
</blockquote>
<h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>1.国内早期教材中，满二叉树一般指 perfect binary tree，所以会有满二叉树是完全二叉树的一个特例的说法.</p>
<p>2.树的深度的定义，有的根结点从0开始计数，有的从1开始计数.</p>
<p>3.结点 与 节点 是对Node的翻译,可以看做等同.</p>
<h2 id="维基百科定义"><a href="#维基百科定义" class="headerlink" title="维基百科定义"></a>维基百科定义</h2><p>1.根二叉树(Rooted Binary Tree)：<br>有一个根结点，每个结点至多有两个孩子。</p>
<p>2.满二叉树(Full Binary Tree)：<br>要么是叶子结点(结点的度为0)，要么结点同时具有左右子树(结点的度为2)。</p>
<p>3.完全二叉树(Complete Binary Tree)：<br>每层结点都完全填满，在最后一层上如果不是满的，则只缺少右边的若干结点。</p>
<p>4.完美二叉树(Perfect Binary Tree)<br>所有的非叶子结点都有两个孩子，所有的叶子结点都在同一层。即每层结点都完全填满。</p>
<p>5.无限完全二叉树(Infinite Complete Binary Tree)：    每个结点都有两个孩子，结点的层数是无限的。</p>
<p>6.平衡二叉树(Balanced Binary Tree)：<br>也称为AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p><strong>满二叉树(Full Binary Tree)</strong><br>如果一棵二叉树的结点要么是叶子要么有两个孩子结点,则为满二叉树</p>
<p>性质:<br>1.总结点个数呈现个数为:0 1 3 7 15…满足2^(n) -1,其中n为树的深度(最大层)</p>
<p>2.第k层(k不为0)结点个数:1 2 4 8…满足2^(k - 1)</p>
<p>3.满二叉树是完全二叉树</p>
<p><strong>完全二叉树(Complete Binary Tree)</strong><br>若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<p>性质:完全二叉树中度为1的结点数只有两种可能0或1,那么:<br>总结点数为n,有  <strong>n0=n/2</strong> 或 <strong>n0=(n+1)/2</strong></p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>顺序存储的排序数组<br><img src="http://static.chenyalun.com/2017/04/21/170421004.jpg" alt=""><br>插入和删除的时候时间复杂度达到O(n),顺序存储结构不适于动态的情况</p>
<p>链式存储<br><img src="http://static.chenyalun.com/2017/04/21/170421005.jpg" alt=""><br>链表的查找需要O(n)</p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找表:由同一类型的数据元素构成的集合.<br>关键字:数据元素中某个数据项的值.<br>主关键字:可以唯一地标识一个记录.<br>次关键字:可以识别多个数据元素.<br>查找:根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素(或记录).<br>静态查找表:只作查找操作的查找表.<br>动态查找表:在查找过程中同时插入查找表中不存在的数据元素,或者从查找表中删除已经存在的某个数据元素.</p>
<h2 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h2><p>顺序查找(线性查找):从表中第一个记录开始,逐个进行记录的关键字和给定值的比较.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 顺序查找的实现</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequentialSearch</span><span class="params">(key, numbers)</span>:</span></div><div class="line">    length = len(numbers)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(length):</div><div class="line">        <span class="comment"># 查找成功返回索引</span></div><div class="line">        <span class="keyword">if</span> key == numbers[i]:</div><div class="line">            <span class="keyword">return</span> i</div><div class="line">    <span class="comment"># 查找失败返回-1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure>
<p>最好情况:在第一个位置找到,时间复杂度为O(1)<br>最坏情况:在最后一个位置找到,时间复杂度O(n)<br>查找不成功:时间复杂度O(n)<br>平均查找次数:(n+1)/2<br>平均时间复杂度:O(n)</p>
<h2 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h2><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><p> 折半查找(二分查找):在线性表中的记录有序的前提下进行查找.取中间元素作为比较对象,若给定值与中间元素相等,则查找成功,若给定值小于中间元素,则在中间元素的左半区继续查找,若给定值大于中间元素,则在中间元素的右半区继续查找,不断重复查找过程,直到查找成功,或查找失败.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 二分查找的实现</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(key, numbers)</span>:</span></div><div class="line">    <span class="comment"># 左边界</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    <span class="comment"># 右边界</span></div><div class="line">    high = len(numbers) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        <span class="comment"># 中间元素索引</span></div><div class="line">        mid = (low + high) / <span class="number">2</span></div><div class="line">        <span class="comment"># 查找成功</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] == key:</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">        <span class="comment"># 在左区间</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] &gt; key:</div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">        <span class="comment"># 在右区间</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] &lt; key:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">    <span class="comment"># 查找失败返回-1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure>
<p>最好情况:是中间元素,一次即可找到,时间复杂度O(1)<br>最坏情况:完全二叉树的深度加1,即floor(logn) + 1次,时间复杂度O(logn).(注意:logn这里指以2为底,floor表示向下取整)</p>
<h3 id="2-插值查找"><a href="#2-插值查找" class="headerlink" title="2.插值查找"></a>2.插值查找</h3><p>二分查找的优化版,核心是插值公式:<br>(key - numbers[low]) / (numbers[high] - numbers[low])</p>
<p>核心代码:</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 插值</span></div><div class="line">mid = low + <span class="comment">(high - low)</span> * <span class="comment">(key - numbers[low])</span> / <span class="comment">(numbers[high] - numbers[low])</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 插值查找的实现</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">interpolationSearch</span><span class="params">(key, numbers)</span>:</span></div><div class="line">    <span class="comment"># 左边界</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    <span class="comment"># 右边界</span></div><div class="line">    high = len(numbers) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        <span class="comment"># 核心代码</span></div><div class="line">        mid = low + (high - low) * (key - numbers[low]) / (numbers[high] - numbers[low])</div><div class="line">        <span class="comment"># 查找成功</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] == key:</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">        <span class="comment"># 在左区间</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] &gt; key:</div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">        <span class="comment"># 在右区间</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] &lt; key:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">    <span class="comment"># 查找失败返回-1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure>
<p>从时间复杂度上,依然是O(logn),但是对于表长较大,关键字分布比较均匀的查找表,性能相对二分查找更好.<br>但是,分布极不均匀的数据,不是很合适,比如[1,2,4,3000,3003…9988899,8988998]</p>
<p>插值查找在实际使用时，一般要满足两个假设条件：</p>
<p>(1)每一次对数据的访问与通常的指令相比，费用都是相当昂贵的。例如，待查找的表一定是在磁盘而非内存中，因而每一次比较都要进行磁盘访问。</p>
<p>(2)数据不仅是已被排好序的，而且呈现均匀分布特征。</p>
<h3 id="3-斐波那契查找"><a href="#3-斐波那契查找" class="headerlink" title="3.斐波那契查找"></a>3.斐波那契查找</h3><p>利用黄金分割原理实现,折半查找算法来进行修改和改进.<br>对于斐波那契数列,前后两个数字的比值随着数列的增加,越来越接近黄金比值:0.618</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line">0<span class="selector-class">.0</span></div><div class="line">1<span class="selector-class">.0</span></div><div class="line">0<span class="selector-class">.5</span></div><div class="line">0<span class="selector-class">.666666666667</span></div><div class="line">0<span class="selector-class">.6</span></div><div class="line">0<span class="selector-class">.625</span></div><div class="line">0<span class="selector-class">.615384615385</span></div><div class="line">0<span class="selector-class">.619047619048</span></div><div class="line">0<span class="selector-class">.617647058824</span></div><div class="line">0<span class="selector-class">.618181818182</span></div><div class="line">0<span class="selector-class">.61797752809</span></div><div class="line">0<span class="selector-class">.618055555556</span></div><div class="line">0<span class="selector-class">.618025751073</span></div><div class="line">0<span class="selector-class">.618037135279</span></div><div class="line">0<span class="selector-class">.618032786885</span></div><div class="line">0<span class="selector-class">.618034447822</span></div><div class="line">0<span class="selector-class">.6180338134</span></div><div class="line">0<span class="selector-class">.618034055728</span></div><div class="line">0<span class="selector-class">.618033963167</span></div><div class="line">0<span class="selector-class">.618033998522</span></div><div class="line">......</div></pre></td></tr></table></figure>
<p>对于斐波那契数列:<br>0 1 1 2 3 5 8 13 21 34 55 89 …</p>
<p><strong>原理:</strong><br>比如这里的89，假定它是整个有序表的元素个数，而89是由前面的两个数34和55相加之后的和，也即把元素个数为89的有序表分成由前55个数据元素组成的前半段和由后34个数据元素组成的后半段，那么前半段元素个数和整个有序表长度的比值就接近黄金比值0.618，假如要查找的元素在前半段，那么继续按照斐波那契数列来看，55 = 34 + 21，所以继续把前半段分成前34个数据元素的前半段和后21个元素的后半段，继续查找，如此反复，直到查找成功或失败.</p>
<p>当有序表的元素个数不是斐波那契数列中的某个数字时，需要把有序表的元素个数长度补齐，让它成为斐波那契数列中的一个数值,也即<strong>把需要补齐的的元素都赋值为有序表的最大值</strong>。</p>
<p><strong>核心:</strong><br>(1)当key == numbers[mid],查找成功<br>(2)当key &lt; numbers[mid],新范围是第low个到第mid-1个,范围个数是F(k-1) - 1个,即有序列表左边的长度<br>(3)当key &gt; numbers[mid]时,新范围是第mid+1到第high个,范围个数是F(k-2) - 1个,即有序列表右边的长度</p>
<p>k 表示列表的长度<br>k-1表示索引<br>F(k-1)表示列表最后一个元素</p>
<p>元素总个数 = 左区间个数 + 右区间个数 + 中间的一个元素,即:</p>
<pre><code>F(k)-1 = F(k-1)-1  +   F(k-2)-1    +     1
</code></pre><p>斐波那契查找算法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 斐波那契查找</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fbonacci</span><span class="params">(index)</span>:</span></div><div class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> </div><div class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(index):</div><div class="line">        a, b = b, a + b</div><div class="line">    <span class="keyword">return</span> a</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">FbonacciSearch</span><span class="params">(key, numbers)</span>:</span></div><div class="line">    <span class="comment"># 确定该序列在斐波那契数列中的位置</span></div><div class="line">    n, length = <span class="number">0</span>, len(numbers)</div><div class="line">    <span class="keyword">while</span> length &gt; Fbonacci(n) - <span class="number">1</span>:</div><div class="line">        n += <span class="number">1</span></div><div class="line">    <span class="comment"># 填满元素</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n,Fbonacci(n)):</div><div class="line">        numbers.append(numbers[<span class="number">-1</span>])</div><div class="line">    </div><div class="line">    low, high = <span class="number">0</span>, n - <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        <span class="comment"># 获取黄金分割下标</span></div><div class="line">        mid = low + Fbonacci(n - <span class="number">1</span>) - <span class="number">1</span></div><div class="line">        </div><div class="line">        <span class="comment"># 左区间</span></div><div class="line">        <span class="comment">#若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1</span></div><div class="line">        <span class="keyword">if</span> key &lt; numbers[mid]:</div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">            n -= <span class="number">1</span></div><div class="line">            </div><div class="line">        <span class="comment"># 右区间</span></div><div class="line">        <span class="comment">#若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1</span></div><div class="line">        <span class="keyword">if</span> key &gt; numbers[mid]:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">            n -= <span class="number">2</span></div><div class="line">        <span class="comment"># 相等</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 成功找到</span></div><div class="line">            <span class="keyword">if</span> mid &lt;= n:</div><div class="line">                <span class="keyword">return</span> mid</div><div class="line">            <span class="comment"># 补全的数,返回n</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> n</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure>
<h3 id="4-比较"><a href="#4-比较" class="headerlink" title="4.比较"></a>4.比较</h3><p>二分查找是加法与除法运算<br>插值查找是复杂的四则运算<br>斐波那契查找是加减法运算</p>
<h2 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h2><p>索引:把一个关键字与它对应的记录相关联的过程.<br>线性索引:把索引项集合组织为线性结构,也即索引表</p>
<h3 id="1-稠密索引"><a href="#1-稠密索引" class="headerlink" title="1.稠密索引"></a>1.稠密索引</h3><p>稠密索引:将数据集的每个记录对应一个索引项,且索引项一定按照关键码有序排列.</p>
<h3 id="2-分块索引"><a href="#2-分块索引" class="headerlink" title="2.分块索引"></a>2.分块索引</h3><p>对数据集进行分块,使分块有序,然后对每一块建立一个索引项,从而减少索引项的个数.</p>
<p>块需要满足的条件:<br>(1)块内无序:每一块的记录不要求有序.<br>(2)块间有序:比如,要求第二块所有记录的关键字均要大于第一块所有记录的关键字.第三块大于第二块…</p>
<p>分块索引的索引项结构:</p>
<ul>
<li>最大关键码:存储每一块中点最大关键字</li>
<li>存储块中记录的个数,便于循环</li>
<li>用于指向块首数据元素的指针,便于遍历</li>
</ul>
<p>查找分两步:<br>(1)在分块索引表中查找关键字所在的块.<br>(2)根据块首指针找到相应的块,并在块中顺序查找关键码.</p>
<p>设n个记录被平均分成m块,每个块t条记录,则n=mt<br>查找索引表的平均查找长度:(1+m)/2<br>查找记录的平均查找长度:(t+1)/2</p>
<p>则块中查找记录的平均查找长度:</p>
<pre><code>  (1+m)/2 + (t+1)/2 
= (m+t)/2+1 
= (n/t+t)/2+1
</code></pre><p>最佳情况:m与t相等,也即n = t^2 = m^2 ,则原式为:</p>
<pre><code>= (t*t/t+t)/2+1
= t+1
= n^0.5 + 1 (^ 表示次方)
</code></pre><p>由此分块索引比顺序查找O(n)提高不少.</p>
<h3 id="3-倒排索引"><a href="#3-倒排索引" class="headerlink" title="3.倒排索引"></a>3.倒排索引</h3><p>索引项的结构:次关键码与记录号表<br>根据属性(次关键码,字段)的值查找记录.<br>该索引表中的每一项包括一个属性值和具有该属性值的各记录的地址.<br>由于不是由记录确定属性值而是由属性值确定记录,因而称为倒排索引.</p>
<p>优点:生成索引表后不用读取记录就可知道结果,查找非常快<br>缺点:记录号不定长</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>如果查找的数据集是有序线性表,并且是顺序存储的,可以使用二分查找/插值查找/斐波那契查找,但是在插入删除操作上耗费大量时间,由此引出既可以使得插入删除效率不错又可以高效率查找的算法====&gt;使用二叉树数据结构:在创建集合时就考虑使用二叉树结果,而且是排好序的二叉树.构造二叉搜索树的目的不是为了排序,而是为了提高插入/删除的效率.</p>
<p>二叉查找树,也称(二叉搜索树,有序二叉树,排序二叉树,二叉排序树）,是指<strong>一棵空树</strong>或者具有下列性质的<strong>二叉树</strong>：</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ul>
<p>性质:<br>1.左小于根小于右<br>2.值不重复<br>3.”中序遍历“可以让结点有序</p>
<p>优势:<br>查找、插入的时间复杂度较低。为O(log n)<br>二叉查找树的最坏效率是O(n),此时退化为线性结构</p>
<p><img src="http://static.chenyalun.com/2017/04/21/170421006.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeNode</span><span class="params">()</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val = <span class="number">0</span>)</span>:</span></div><div class="line">		self.val = val</div><div class="line">		self.left = <span class="keyword">None</span></div><div class="line">		self.right = <span class="keyword">None</span></div><div class="line"></div><div class="line">	<span class="comment"># 寻找结点</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, data)</span>:</span></div><div class="line">		<span class="keyword">if</span> self.val == data:</div><div class="line">			<span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">		<span class="keyword">elif</span> data &lt; self.val <span class="keyword">and</span> self.left:</div><div class="line">			<span class="keyword">return</span> self.left.find(data)</div><div class="line">		<span class="keyword">elif</span> data &gt; self.val <span class="keyword">and</span> self.right:</div><div class="line">			<span class="keyword">return</span> self.right.find(data)</div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			<span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">	</div><div class="line">	<span class="comment"># 寻找最小结点</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">findMinData</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">if</span> self.left:</div><div class="line">			<span class="keyword">return</span> self.left.findMinData()</div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			<span class="keyword">return</span> self.val</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment"># 寻找最大结点</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">findMaxData</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">if</span> self.right:</div><div class="line">			<span class="keyword">return</span> self.right.findMaxData()</div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			<span class="keyword">return</span> self.val</div><div class="line">	</div><div class="line">	<span class="comment"># 插入结点</span></div><div class="line">	<span class="comment"># 当data与二叉搜索树中某结点val相等时不作处理</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">insertNode</span><span class="params">(self, data)</span>:</span></div><div class="line">		<span class="comment"># 在右子树上</span></div><div class="line">		<span class="keyword">if</span> self.val &lt; data:</div><div class="line">			<span class="keyword">if</span>  self.right:</div><div class="line">				self.right.insertNode(data)</div><div class="line">			<span class="keyword">else</span>:</div><div class="line">				self.right = BinarySearchTreeNode(data)</div><div class="line">		</div><div class="line">		<span class="comment"># 在左子树上</span></div><div class="line">		<span class="keyword">if</span> self.val &gt; data:</div><div class="line">			<span class="keyword">if</span>  self.left:</div><div class="line">				self.left.insertNode(data)</div><div class="line">			<span class="keyword">else</span>:</div><div class="line">				self.left = BinarySearchTreeNode(data)</div><div class="line"></div><div class="line">	<span class="comment"># 打印二叉搜索树</span></div><div class="line">	<span class="comment"># 左根右遍历</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">printTree</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">if</span> self.left:</div><div class="line">			self.left.printTree()</div><div class="line">		<span class="keyword">print</span> self.val,</div><div class="line">		<span class="keyword">if</span> self.right:</div><div class="line">			self.right.printTree()</div><div class="line"></div><div class="line">	<span class="comment"># 结点的删除</span></div><div class="line">	<span class="comment"># 当删除一个叶子结点时,直接删除即可</span></div><div class="line">	<span class="comment"># 当删除的结点只有一个孩子时,用该孩子替换</span></div><div class="line">	<span class="comment"># 当删除的结点有两个孩子时,寻找该结点右子树中的最小数据代替子节点</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">daleteNode</span><span class="params">(self, data)</span>:</span></div><div class="line">		<span class="comment"># 前提是该结点在二叉搜索树中能找到</span></div><div class="line">		<span class="keyword">if</span> <span class="keyword">not</span> self.find(data):</div><div class="line">			<span class="keyword">return</span> self</div><div class="line">		<span class="keyword">if</span> data &lt; self.val:</div><div class="line">			self.left = self.left.daleteNode(data)</div><div class="line">			<span class="keyword">return</span> self</div><div class="line">		<span class="keyword">elif</span> data &gt; self.val:</div><div class="line">			self.right = self.right.daleteNode(data)</div><div class="line">			<span class="keyword">return</span> self</div><div class="line">		<span class="keyword">elif</span> self.left <span class="keyword">and</span> self.right:</div><div class="line">			<span class="comment"># 找到右子树最小的结点,获取值</span></div><div class="line">			val = self.right.findMinData()</div><div class="line">			<span class="comment"># 把最小结点的值给自己</span></div><div class="line">			self.val = val</div><div class="line">			<span class="comment"># 删除右子树中的最小结点,使self.right指向右子树的根节点</span></div><div class="line">			<span class="comment"># self.right.daleteNode(val)最终返回右子树的根节点</span></div><div class="line">			self.right = self.right.daleteNode(val)</div><div class="line">			<span class="keyword">return</span> self</div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			<span class="comment"># 左结点存在</span></div><div class="line">			<span class="keyword">if</span> self.left:</div><div class="line">				<span class="comment"># 直接指向左结点</span></div><div class="line">				<span class="keyword">return</span> self.left</div><div class="line">			<span class="comment"># 右结点存在,或不存在结点</span></div><div class="line">			<span class="keyword">else</span>:</div><div class="line">				<span class="comment"># 直接指向右结点</span></div><div class="line">				<span class="keyword">return</span> self.right</div><div class="line"></div><div class="line"></div><div class="line">a = BinarySearchTreeNode(<span class="number">10</span>)</div><div class="line">a.insertNode(<span class="number">8</span>)</div><div class="line">a.insertNode(<span class="number">12</span>)</div><div class="line">a.insertNode(<span class="number">6</span>)</div><div class="line">a.insertNode(<span class="number">9</span>)</div><div class="line">a.insertNode(<span class="number">11</span>)</div><div class="line">a.insertNode(<span class="number">14</span>)</div><div class="line">a.insertNode(<span class="number">7</span>)</div><div class="line">a.insertNode(<span class="number">13</span>)</div><div class="line">a.insertNode(<span class="number">5</span>)</div><div class="line">a.insertNode(<span class="number">2</span>)</div><div class="line"></div><div class="line">a.printTree()</div><div class="line"><span class="keyword">print</span> <span class="string">"\n"</span></div><div class="line"><span class="keyword">print</span> a.find(<span class="number">11</span>)</div><div class="line"><span class="keyword">print</span> a.find(<span class="number">100000</span>)</div><div class="line"><span class="keyword">print</span> a.findMaxData()</div><div class="line"><span class="keyword">print</span> a.findMinData()</div><div class="line"></div><div class="line">a.daleteNode(<span class="number">1000000</span>)</div><div class="line">a.daleteNode(<span class="number">10</span>)</div><div class="line">a.daleteNode(<span class="number">14</span>)</div><div class="line">a.daleteNode(<span class="number">2</span>)</div><div class="line">a.printTree()</div></pre></td></tr></table></figure>
<p>二叉搜索树以链接的方式存储,保持了链接存储结构在执行插入或删除时的优越性.</p>
<p><img src="http://static.chenyalun.com/2017/04/21/170421002.png" alt=""></p>
<p>对于二叉搜索树的查找,比较次数等于给定值的结点在二叉搜索树的层数.最少为1次(为根节点),最多不超过树的深度(最差是极端的右斜树或左斜树).</p>
<p><img src="http://static.chenyalun.com/2017/04/21/170421001.png" alt=""></p>
<p>二叉排序树倘若是平衡的,其深度与完全二叉树相同,均为<code>floor(logn) + 1</code>,查找的时间复杂度为O(logn),近似与折半查找,若不是平衡的,甚至演化为极端的右斜树或左斜树,查找的时间复杂度为O(n),等同于顺序查找.</p>
<p>因此,平衡至关重要.</p>
<h2 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h2><p>平衡二叉搜索树是改进的二叉搜索树,也是二叉搜索树。</p>
<p>一般的二叉搜索树的查询复杂度是跟深度有关，因此当结点的深度普遍较大时，查询的均摊复杂度会上升，为了更高效的查询，平衡树应运而生了。</p>
<p>可以使查找树的高度为 O (log(n)) </p>
<p>定义:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>AVL树中的每个结点都有一个平衡因子（balance factor，BF），它表示这个结点的左、右子树的深度差，也就是左子树的深度减去右子树的深度的结果值。AVL树上所有结点的BF值只能是-1、0、1。反之，只要二叉树上一个结点的BF的绝对值大于1，则该二叉树就不是平衡二叉树。在进行插入和删除的时候找出失去平衡的节点，进行必要的旋转操作保证树的平衡。</p>
<p>查找、插入和删除在平均和最坏情况下都是O（log n）</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<p>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）每个红色节点必须有两个黑色的子节点。<br>（5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。  </p>
<p>一棵n个结点是红黑树始终保持了logn的高度,所以红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</p>
<p>红黑树之所以是平衡的二叉查找树，是因为每个节点都有表示其颜色的域值：红或黑，在插入和删除操作的时候依据节点的颜色向平衡的方向调整。</p>
<p><img src="http://static.chenyalun.com/2017/04/21/170421007.png" alt=""></p>
<p>“叶结点” 或”NULL结点”，它不包含数据而只充当树在此结束的指示，这些结点以及它们的父结点，在绘图中都会经常被省略。</p>
<p>当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。 为了继续保持红黑树的性质，我们可以通过对结点进行重新着色，以及对树进行相关的旋转操作</p>
<p>左旋:左右左<br>右旋:右左右</p>
<h2 id="多路查找树-B树"><a href="#多路查找树-B树" class="headerlink" title="多路查找树(B树)"></a>多路查找树(B树)</h2><p>B树即为B-树、B_树,又叫平衡多路查找树.<br>多路查找树:其每一个结点的孩子数可以多于两个,每一个结点处可以存储多个元素.</p>
<p>一个节点只能存储一个元素,在元素非常多的时候,就使得要么树的度非常大,要么树的高度非常大,甚至两者都必须足够大才可以,这使得内存存取外村次数非常多,造成了时间效率上的瓶颈,于是引入多路查找树.</p>
<p>树的高度越高，查找文件所需要的磁盘IO读写次数越多，所以为了减少磁盘的IO读写，要想办法进一步降低树的高度。 因此，具有多个孩子的B树便应运而生，因为B树每一个结点可以有几个到几千个孩子，使得在结点数目一定的情况下，树的高度会大大降低，从而有效减少磁盘IO读写消耗。</p>
<p>B+树、B树等的根结点和部分顶层数据存在内存中，大部分下层数据存在磁盘上。</p>
<h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>2-3树是这样一棵多路查找树:其中的每一个结点都具有两个孩子或三个孩子.</p>
<ol>
<li><p>一个2结点包含一个元素和两个孩子(或没有孩子),与二叉排序树类似,左子树包含的元素小于该元素,右子树包含的元素大于该元素,与二叉排序树不同的是,这个2结点要么没有孩子,要么就有两个,不能只有一个孩子.</p>
</li>
<li><p>一个3结点包含一小一大两个元素和三个孩子(或没有孩子),一个3结点要么没有孩子,要么具有3个孩子.如果具有3个孩子的话,左子树包含的元素小于较小元素的元素,右子树包含的元素大于较大元素的元素,中间子树包含介于两元素之间的元素.</p>
</li>
<li><p>并且2-3树中所有叶子都在同一层次上.</p>
</li>
</ol>
<p>2-3树的插入</p>
<p>2-3树的删除</p>
<h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p>2-3树的概念扩展,包括了4结点的使用.一个4结点包含小中大三个元素和四个孩子(或者没有孩子).</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树是一种平衡的多路查找树,2-3树和2-3-4树都是B树的特例.<br>结点最大的孩子数目称为B树的阶.<br>2-3树是3阶B树,2-3-4树是4阶B树.</p>
<p>A B-tree of order m is a tree which satisfies the following properties:</p>
<pre><code>Every node has at most m children.
Every non-leaf node (except root) has at least ⌈m/2⌉ children.
The root has at least two children if it is not a leaf node.
A non-leaf node with k children contains k−1 keys.
All leaves appear in the same level
</code></pre><p>一棵m阶的B树满足以下条件<br>1.每个结点至多有m棵子树<br>2.除根结点外,其他分支结点至少有ceil(m/2)棵子树(ceil()函数向上取整<br>3.根结点至少有两棵子树,除非树只包含一个结点<br>4.有k个孩子的非叶结点有k-1个关键码,关键码按递增次序排列<br>5.所有叶子结点在同一层</p>
<h4 id="B树如何做到减少访问外存次数"><a href="#B树如何做到减少访问外存次数" class="headerlink" title="B树如何做到减少访问外存次数"></a>B树如何做到减少访问外存次数</h4><p>硬盘将信息分割成相等大小的页面,每次硬盘读写都是一个或者多个完整的页面,对一个硬盘来说,一页的长度可能是211到214字节.</p>
<p>在一个典型的B树应用中,要处理的硬盘数据量很大,因此无法一次全部装入内存,因此需要对B树进行调整,使得B树的阶树与硬盘存储的页面大小相匹配.在有限内存的情况下,每一次磁盘的访问我们都可以获得最大量的数据,由于B树每节点可以具有比二叉树多得多的元素,所以减少了必须访问结点和数据块的数量,提高了性能.<br>B树的数据结构就是为内外存的数据交互准备的.</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+ 树是一种树数据结构，通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。</p>
<p>B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。</p>
<p>一棵m阶的B+树与B树的区别在于:</p>
<ol>
<li>有n棵子树的结点包含有n个关键字</li>
<li>所有的叶子节点包含全部的关键字信息,以及指向含这些关键字记录的指针,叶子节点本身依关键字的大小自小而大顺序链接</li>
<li>所有分支结点可以看成是索引,结点中仅含有其子树的最大(最小)关键字.</li>
</ol>
<p>好处:<br>如果要随机查找,就从根节点出发,与B树的查找方式相同,只不过即使在分支结点找到了待查找的关键字,它也只是用来索引的,不能提供实际记录的访问,还是需要到达包含此关键字的终端结点.</p>
<p>如果需要从最小关键字进行自小而大的顺序查找,可以从最左端的叶子结点出发,不经过分支结点,而是沿着指向下一叶子的指针就可遍历所有的关键字.</p>
<p>B+树适合有范围的查找(比如年龄18–22),从根节点出发找到18,再在叶子结点中按顺序找到符合要求的记录.</p>
<p>B+树的插入/删除与B树类似,只不过插入删除的元素都是在叶子结点上进行.</p>
<h2 id="散列表查找"><a href="#散列表查找" class="headerlink" title="散列表查找"></a>散列表查找</h2><p>存储位置 = f(关键字)</p>
<p>记录的存储位置和它的关键字之间建立的一个确定的对应关系.每个关键字key对应一个存储位置f(key),查找时根据这个确定的对应关系找到给定key的映射f(key).</p>
<p>f称为散列函数,又称哈希函数,采用散列技术将记录存储在一块连续的存储空间中,这块连续的存储空间称为散列表或哈希表,关键字对应的记录存储位置称为散列地址.</p>
<p>冲突:key1不等于key2,但是f(key1)=f(key2),key1和key2称为散列函数的同义词.</p>
<h3 id="常用的散列函数"><a href="#常用的散列函数" class="headerlink" title="常用的散列函数"></a>常用的散列函数</h3><h4 id="1-直接定址法"><a href="#1-直接定址法" class="headerlink" title="1.直接定址法"></a>1.直接定址法</h4><pre><code>f(key) = a * key + b  (a,b为常数)
</code></pre><ul>
<li>优点:简单均匀,不会产生冲突,但需要事先知道关键字的分布情况,适合查找表较小且连续的情况.</li>
</ul>
<h4 id="2-数字分析法"><a href="#2-数字分析法" class="headerlink" title="2.数字分析法"></a>2.数字分析法</h4><p>手机号码等,对数字进行抽取,反转,左环位移,右环位移等方式合理地将关键字分配到散列表的各位置.</p>
<ul>
<li>适合处理关键字位数比较大的情况,如果事先知道关键字的分布且关键字的若干位分布均匀,可以使用.</li>
</ul>
<h4 id="3-平方取中法"><a href="#3-平方取中法" class="headerlink" title="3.平方取中法"></a>3.平方取中法</h4><p>关键字1234—-&gt;平方后:1522756—–&gt;抽取中间的3位——&gt;227,用作散列地址.</p>
<ul>
<li>适合不知道关键字的分布,而位数又不是很大的情况</li>
</ul>
<h4 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="4.折叠法"></a>4.折叠法</h4><p>从左到右分割成位数相等的几部分,叠加求和,按照散列表长,取后几位作为散列地址.</p>
<p>9876543210—–&gt;987  654  321 0—–&gt;求和987+654+321+0=1962,求后三位:962</p>
<ul>
<li>适合不需要事先知道关键字的分布.适合关键字位数较多的情况.</li>
</ul>
<h4 id="5-除留余数法"><a href="#5-除留余数法" class="headerlink" title="5.除留余数法"></a>5.除留余数法</h4><p>最常用,散列表长为m的公式:</p>
<pre><code>f(key) = key mod p (p&lt;=m)
</code></pre><ul>
<li>若散列表表长m,通常p为小于或者等于表长的最小质数或不包含小于20质因子的合数.</li>
</ul>
<h4 id="6-随机数法"><a href="#6-随机数法" class="headerlink" title="6.随机数法"></a>6.随机数法</h4><pre><code>f(key) = random(key)
</code></pre><ul>
<li>当关键字的长度不等时,采用这个方法.</li>
</ul>
<h3 id="常用的处理冲突方法"><a href="#常用的处理冲突方法" class="headerlink" title="常用的处理冲突方法"></a>常用的处理冲突方法</h3><h4 id="1-开放定址法"><a href="#1-开放定址法" class="headerlink" title="1.开放定址法"></a>1.开放定址法</h4><p>线性探测法</p>
<pre><code>f(key) = (f(key) + d) mod m  (d = 1,2,3...)
</code></pre><p>二次探测法</p>
<pre><code>f(key) = (f(key) + d) mod m  (d = 1^2,-1^2,2^2,-2^2,3^2,-3^2...q^2,-q^2,其中q&lt;=m/2)
</code></pre><p>随机探测法</p>
<pre><code>f(key) = (f(key) + d) mod m  (d 是一个随机数列)
</code></pre><h4 id="2-再散列函数法"><a href="#2-再散列函数法" class="headerlink" title="2.再散列函数法"></a>2.再散列函数法</h4><pre><code>f(key) = RH(key)
</code></pre><p>每次发生散列冲突时,就换一个散列函数计算.</p>
<h4 id="3-链地址法"><a href="#3-链地址法" class="headerlink" title="3.链地址法"></a>3.链地址法</h4><p>提供绝不会找不到地址的保障,但是带来查找时需要遍历单链表的性能损耗.</p>
<h4 id="4-公共溢出区法"><a href="#4-公共溢出区法" class="headerlink" title="4.公共溢出区法"></a>4.公共溢出区法</h4><p>增添溢出表.<br>对给定值通过散列函数计算出散列地址后,先与基本表的相应位置进行比对,如果相等,成功,否则,到溢出表中进行<strong>顺序查找</strong>.    </p>
<blockquote>
<p>参考并致谢<br><a href="https://www.zhihu.com/question/19809666/answer/88158084" target="_blank" rel="external">知乎 灰杉树</a><br><a href="http://haiyangxu.github.io/posts/2014/2014-05-05-binary_search_tree.html" target="_blank" rel="external">HAIYANG XU</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="external">v_JULY_v</a></p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag">#算法</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/13/读《Objective-C高级编程》/" rel="next" title="读《Objective-C高级编程》">
                <i class="fa fa-chevron-left"></i> 读《Objective-C高级编程》
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://chenyaluncos-10005661.cos.myqcloud.com/touxiang.jpg"
               alt="Ya" />
          <p class="site-author-name" itemprop="name">Ya</p>
          <p class="site-description motion-element" itemprop="description">Being a Full Stack Developer</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">随笔</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/icqk" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/ChenYalun" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://stackoverflow.com/users/7026915/allen" target="_blank" title="SOF">
                  
                    <i class="fa fa-fw fa-stack-overflow"></i>
                  
                  SOF
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#争议"><span class="nav-number">1.1.</span> <span class="nav-text">争议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#维基百科定义"><span class="nav-number">1.2.</span> <span class="nav-text">维基百科定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储"><span class="nav-number">1.3.</span> <span class="nav-text">存储</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查找"><span class="nav-number">2.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序表查找"><span class="nav-number">2.1.</span> <span class="nav-text">顺序表查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序表查找"><span class="nav-number">2.2.</span> <span class="nav-text">有序表查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-二分查找"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-插值查找"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.插值查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-斐波那契查找"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.斐波那契查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-比较"><span class="nav-number">2.2.4.</span> <span class="nav-text">4.比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性索引查找"><span class="nav-number">2.3.</span> <span class="nav-text">线性索引查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-稠密索引"><span class="nav-number">2.3.1.</span> <span class="nav-text">1.稠密索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-分块索引"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.分块索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-倒排索引"><span class="nav-number">2.3.3.</span> <span class="nav-text">3.倒排索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉搜索树"><span class="nav-number">2.4.</span> <span class="nav-text">二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平衡二叉树-AVL树"><span class="nav-number">2.5.</span> <span class="nav-text">平衡二叉树(AVL树)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#红黑树"><span class="nav-number">2.6.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多路查找树-B树"><span class="nav-number">2.7.</span> <span class="nav-text">多路查找树(B树)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3树"><span class="nav-number">2.7.1.</span> <span class="nav-text">2-3树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4树"><span class="nav-number">2.7.2.</span> <span class="nav-text">2-3-4树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B树"><span class="nav-number">2.7.3.</span> <span class="nav-text">B树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B树如何做到减少访问外存次数"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">B树如何做到减少访问外存次数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树"><span class="nav-number">2.7.4.</span> <span class="nav-text">B+树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#散列表查找"><span class="nav-number">2.8.</span> <span class="nav-text">散列表查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的散列函数"><span class="nav-number">2.8.1.</span> <span class="nav-text">常用的散列函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-直接定址法"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">1.直接定址法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-数字分析法"><span class="nav-number">2.8.1.2.</span> <span class="nav-text">2.数字分析法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-平方取中法"><span class="nav-number">2.8.1.3.</span> <span class="nav-text">3.平方取中法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-折叠法"><span class="nav-number">2.8.1.4.</span> <span class="nav-text">4.折叠法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-除留余数法"><span class="nav-number">2.8.1.5.</span> <span class="nav-text">5.除留余数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-随机数法"><span class="nav-number">2.8.1.6.</span> <span class="nav-text">6.随机数法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的处理冲突方法"><span class="nav-number">2.8.2.</span> <span class="nav-text">常用的处理冲突方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-开放定址法"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">1.开放定址法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-再散列函数法"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">2.再散列函数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-链地址法"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">3.链地址法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-公共溢出区法"><span class="nav-number">2.8.2.4.</span> <span class="nav-text">4.公共溢出区法</span></a></li></ol></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ya</span>
</div>

<div class="powered-by">
  May Be Better
</div>

<div class="theme-info">
  心有猛虎，细嗅蔷薇。 
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
