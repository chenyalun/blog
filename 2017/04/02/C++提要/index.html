<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="C++提要">




  <meta name="keywords" content="C++提要,">




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x">



<link rel="canonical" href="http://blog.chenyalun.com/2017/04/02/C++提要/">


<meta name="description" content="不堪回首。">
<meta name="keywords" content="C++提要">
<meta property="og:type" content="article">
<meta property="og:title" content="C++提要">
<meta property="og:url" content="http://blog.chenyalun.com/2017/04/02/C++提要/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="不堪回首。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://static.chenyalun.com/2017/04/03/20170403002.jpg">
<meta property="og:updated_time" content="2019-03-29T03:03:05.516Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++提要">
<meta name="twitter:description" content="不堪回首。">
<meta name="twitter:image" content="http://static.chenyalun.com/2017/04/03/20170403002.jpg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> C++提要 · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          C++提要
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017年4月2日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#钩玄"><span class="toc-text">钩玄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-命名空间如何使用"><span class="toc-text">1.命名空间如何使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-C-现行标准库"><span class="toc-text">2.C++现行标准库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-cin与cout"><span class="toc-text">3.cin与cout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-C-中const的作用"><span class="toc-text">4.C++中const的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-动态分配内存"><span class="toc-text">5.动态分配内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-函数调用的流程"><span class="toc-text">6.函数调用的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-内联函数"><span class="toc-text">7.内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-函数的默认参数-重载"><span class="toc-text">8.函数的默认参数/重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-对象的创建"><span class="toc-text">9.对象的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-成员函数"><span class="toc-text">10.成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-构造函数"><span class="toc-text">11.构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-析构函数"><span class="toc-text">12.析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-this的本质"><span class="toc-text">13.this的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-静态成员变量"><span class="toc-text">14.静态成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-静态成员函数"><span class="toc-text">15.静态成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-常成员函数"><span class="toc-text">16.常成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-友元函数与友元类"><span class="toc-text">17.友元函数与友元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-struct与class比较"><span class="toc-text">18.struct与class比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-string的使用"><span class="toc-text">19.string的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-指针传递与引用传递的比较"><span class="toc-text">20.指针传递与引用传递的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-继承"><span class="toc-text">21.继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-多重继承"><span class="toc-text">22.多重继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-虚继承"><span class="toc-text">23.虚继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-C-向上转型"><span class="toc-text">24.C++向上转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-虚函数、纯虚函数与多态"><span class="toc-text">25.虚函数、纯虚函数与多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-运算符重载"><span class="toc-text">26.运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-模板"><span class="toc-text">27.模板</span></a></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p align="center"> 不堪回首。 </p>

<a id="more"></a>
<p>Java、前端、Android、iOS的笔试题涌现大量C++的内容，我和小伙伴们苦不堪言，于是特意抽大半天时间试着回忆一下。</p>
<h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><h2 id="1-命名空间如何使用"><a href="#1-命名空间如何使用" class="headerlink" title="1.命名空间如何使用"></a>1.命名空间如何使用</h2><p>防止出现变量或函数的命名冲突.</p>
<p>在 main() 函数中声明命名空间 std，它的作用范围就位于 main() 函数内部，如果在其他函数中又用到了 std，就需要重新声明</p>
<p>如果希望在所有函数中都使用命名空间 std，可以将它声明在全局范围中<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">namespace</span> YA &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">// 变量、类、函数、typedef、#define 等都可以出现在命名空间中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式一:域解析操作符</span></span><br><span class="line"><span class="comment">// :是域解析操作符,指明要使用的命名空间</span></span><br><span class="line">YA :: a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式二:针对变量</span></span><br><span class="line"><span class="comment">// 如果以后出现了未指明命名空间的a，就使用YA :: a</span></span><br><span class="line"><span class="keyword">using</span> YA :: a;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式三:针对命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> YA; <span class="comment">// 声明整个命名空间</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-C-现行标准库"><a href="#2-C-现行标准库" class="headerlink" title="2.C++现行标准库"></a>2.C++现行标准库</h2><p>对于不带.h的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；<br>对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>C语言的头文件在 C++ 中依然被支持，C++ 新增的库更加强大和灵活,例如 iostream、fstream、string 等</p>
<p>推荐:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-cin与cout"><a href="#3-cin与cout" class="headerlink" title="3.cin与cout"></a>3.cin与cout</h2><p>cout 和 cin 分别是 ostream 和 istream 类的对象,而不是关键字<br>使用:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a是"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b是"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中endl表示end of line,表示换行,可用\n代替</p>
<h2 id="4-C-中const的作用"><a href="#4-C-中const的作用" class="headerlink" title="4.C++中const的作用"></a>4.C++中const的作用</h2><p>1.定义常量<br><code>const int a = 10; // a不可修改</code></p>
<p>2.类型检查<br><code>void f(const int i){}
// 对传进来的参数进行类型检查,不匹配则提示</code></p>
<p>3.保护参数<br><code>void f(const int i){}
// i不可修改</code></p>
<p>4.节省空间<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换三次,分配三次内存空间</span></span><br><span class="line">#define pi <span class="number">3.14</span></span><br><span class="line"><span class="keyword">double</span> a = pi;</span><br><span class="line"><span class="keyword">double</span> b = pi;</span><br><span class="line"><span class="keyword">double</span> c = pi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> <span class="literal">PI</span> = <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 只分配一次内存空间</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="literal">PI</span>;</span><br><span class="line"><span class="comment">// 不再分配内存空间</span></span><br><span class="line"><span class="keyword">double</span> e = <span class="literal">PI</span>;</span><br></pre></td></tr></table></figure></p>
<p>混淆点:<br>指针本身是常量不可变,不可以指向其他</p>
<pre><code>char* const pContent;
</code></pre><p>指针所指向的内容是常量不可变</p>
<pre><code>const char *pContent;
</code></pre><p>两者都不可变</p>
<pre><code>const char* const pContent;
</code></pre><h2 id="5-动态分配内存"><a href="#5-动态分配内存" class="headerlink" title="5.动态分配内存"></a>5.动态分配内存</h2><p>在C中<br>分配</p>
<pre><code>int *p = (int *)malloc(sizeof(int) * 10);
</code></pre><p>释放</p>
<pre><code>free(p);
</code></pre><p>在C++中 new[]分配 delete[]释放</p>
<pre><code>int *p = new int;
delete p;

int *p = new int[10];  //分配10个int型的内存空间
delete[] p;
</code></pre><p>new 是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收<br>用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。</p>
<h2 id="6-函数调用的流程"><a href="#6-函数调用的流程" class="headerlink" title="6.函数调用的流程"></a>6.函数调用的流程</h2><p>函数调用是有时间和空间开销的(递归效率低下)。<br>程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。</p>
<h2 id="7-内联函数"><a href="#7-内联函数" class="headerlink" title="7.内联函数"></a>7.内联函数</h2><p>作用:为了消除函数调用的时空开销，在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数.</p>
<p>在<strong>函数定义处</strong>添加inline关键字,声明处添加无效.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"内联函数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意:</p>
<ol>
<li>当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以一般是将非常短小的函数声明为内联函数。</li>
<li>对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的。编译器有自己的判断能力，它会根据具体情况决定是否这样做。如何函数体非常大，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。</li>
</ol>
<p>缺点:编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大。</p>
<p>总结:小而短的函数声明为内联函数.</p>
<p>内联函数替代宏<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(a,b) (a+b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="8-函数的默认参数-重载"><a href="#8-函数的默认参数-重载" class="headerlink" title="8.函数的默认参数/重载"></a>8.函数的默认参数/重载</h2><p>默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">sum(<span class="number">12</span>,<span class="number">23</span>);</span><br><span class="line">sum(<span class="number">12</span>)</span><br></pre></td></tr></table></figure></p>
<p>重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。<br>重载的结果是让一个函数名拥有了多种用途，使得命名更加方便,调用更加灵活。<br>要求:函数名相同,参数列表不同,仅仅返回类型不同不足以成为函数的重载。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换 int 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换 float 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">float</span> *a, <span class="keyword">float</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重载的本质:<br>在编译时会根据参数列表对函数进行重命名,函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。</p>
<h2 id="9-对象的创建"><a href="#9-对象的创建" class="headerlink" title="9.对象的创建"></a>9.对象的创建</h2><p>类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。</p>
<p>成员变量大都以m_开头。</p>
<p>存储在栈上的对象</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Student stu<span class="comment">;</span></span><br><span class="line">Student *p = &amp;stu<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>存储在堆上的对象<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Student *stu = <span class="keyword">new</span> <span class="type">Student</span>;</span><br></pre></td></tr></table></figure></p>
<p>使用 new 在堆上创建出来的对象是匿名的，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</p>
<h2 id="10-成员函数"><a href="#10-成员函数" class="headerlink" title="10.成员函数"></a>10.成员函数</h2><p>在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以建议在类体内部对成员函数作声明，而在类体外部进行定义.</p>
<p>不使用内联函数:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> age;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;  <span class="comment">//内联函数声明</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//函数定义</span></span><br><span class="line"><span class="keyword">void</span> Student::say()&#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="11-构造函数"><a href="#11-构造函数" class="headerlink" title="11.构造函数"></a>11.构造函数</h2><p>构造函数必须是 public 属性的，否则创建对象时无法调用。<br>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。</p>
<p>一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成</p>
<p>调用没有参数的构造函数也可以省略括号。<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Student stu()<span class="comment">;</span></span><br><span class="line">Student stu<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Student *stu = new Student()<span class="comment">;</span></span><br><span class="line">Student *stu = new Student<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>参数初始化表可以用于全部成员变量，也可以只用于部分成员变量。<br>参数初始化顺序与初始化表列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。<br>初始化 const 成员变量的唯一方法就是使用参数初始化表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//采用参数初始化表</span></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-析构函数"><a href="#12-析构函数" class="headerlink" title="12.析构函数"></a>12.析构函数</h2><p>析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号。<br>析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。</p>
<h2 id="13-this的本质"><a href="#13-this的本质" class="headerlink" title="13.this的本质"></a>13.this的本质</h2><p>this 是 C++ 中的一个关键字，也是一个 <strong>const 指针</strong>，它指向当前对象，通过它可以访问当前对象的所有成员。</p>
<p>his 虽然用在类的内部，但是只有在对象被创建以后才会给 this 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给 this 赋值。</p>
<p>this的本质:<br>this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。<br>this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。</p>
<h2 id="14-静态成员变量"><a href="#14-静态成员变量" class="headerlink" title="14.静态成员变量"></a>14.静态成员变量</h2><p>static 成员变量属于类，不属于某个具体的对象，即使创建多个对象,也只分配一份内存.</p>
<p>static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用</p>
<p>static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 m_total 声明为静态成员变量</span></span><br><span class="line"><span class="comment">//通过类类访问 static 成员变量</span></span><br><span class="line">Student::m_total = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//通过对象来访问 static 成员变量</span></span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</span><br><span class="line">stu.m_total = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//通过对象指针来访问 static 成员变量</span></span><br><span class="line">Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李华"</span>, <span class="number">16</span>, <span class="number">96</span>);</span><br><span class="line">pstu -&gt; m_total = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
<p>静态成员变量必须初始化，而且只能在类体外进行</p>
<p>static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p>
<h2 id="15-静态成员函数"><a href="#15-静态成员函数" class="headerlink" title="15.静态成员函数"></a>15.静态成员函数</h2><p>普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。</p>
<p>普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。</p>
<p>普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。</p>
<p>静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</p>
<h2 id="16-常成员函数"><a href="#16-常成员函数" class="headerlink" title="16.常成员函数"></a>16.常成员函数</h2><p>const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的</p>
<p>常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明常成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义常成员函数</span></span><br><span class="line"><span class="keyword">int</span> Student::getage() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="17-友元函数与友元类"><a href="#17-友元函数与友元类" class="headerlink" title="17.友元函数与友元类"></a>17.友元函数与友元类</h2><p>借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。<br>在当前类以外定义的、不属于当前类的函数可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。</p>
<p>友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。</p>
<p>一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// 构造函数</span></span><br><span class="line">    Address(<span class="keyword">char</span> *province, <span class="keyword">char</span> *city, <span class="keyword">char</span> *district);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将Student类中的成员函数show()声明为友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Student::show(Address *addr);</span><br></pre></td></tr></table></figure></p>
<p>友元类中的所有成员函数都是另外一个类的友元函数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Address(<span class="keyword">char</span> *province, <span class="keyword">char</span> *city, <span class="keyword">char</span> *district);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//将Student类声明为Address类的友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。<br>友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。</p>
<h2 id="18-struct与class比较"><a href="#18-struct与class比较" class="headerlink" title="18.struct与class比较"></a>18.struct与class比较</h2><p>使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的</p>
<p>class 继承默认是 private 继承，而 struct 继承默认是 public 继承</p>
<p>class 可以使用模板，而 struct 不能</p>
<h2 id="19-string的使用"><a href="#19-string的使用" class="headerlink" title="19.string的使用"></a>19.string的使用</h2><p>前提:<code>#include &lt;string&gt;</code></p>
<p>1.输入输出</p>
<pre><code>string s;
cin&gt;&gt;s;
cou&lt;&lt;s&lt;&lt;endl;
</code></pre><p>2.通过下标访问</p>
<pre><code>string s = &quot;qwert&quot;;
s[3] = &apos;d&apos;;
couy&lt;&lt;s[2];    
</code></pre><p>3.拼接</p>
<pre><code>string s = &quot;i&quot;;
char *s1 = &quot;love&quot;;
char s2[] = &quot;you&quot;;
char s3 = &apos;!&apos;;

string rs = s + s1 + s2 + s3;
</code></pre><p>4.插入</p>
<pre><code>string s = &quot;sdf&quot;;
s.insert(1,&quot;sds&quot;); // 索引/内容
</code></pre><p>5.删除</p>
<pre><code>s1 = s2 = s3 = &quot;1234567890&quot;;
s2.erase(5);
s3.erase(5, 3); // 长度为3
</code></pre><p>6.提取</p>
<pre><code>s1.substr(6, 6); // 长度为6
</code></pre><p>7.查找</p>
<pre><code>s.find(&quot;,&quot;,1); // 从索引1开始查找逗号,返回索引
</code></pre><h2 id="20-指针传递与引用传递的比较"><a href="#20-指针传递与引用传递的比较" class="headerlink" title="20.指针传递与引用传递的比较"></a>20.指针传递与引用传递的比较</h2><p>引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。</p>
<p>引用的定义方式类似于指针，只是用&amp;取代了*</p>
<pre><code>type &amp;name = data;

// 指针传递
// 比如交换数据
swap(int *a, int *b) {
int temp = *a;
*a = *b;
*b = temp;    
}
// 使用
swap(&amp;a, &amp;b);


//引用传递
swap2(int &amp;a, int &amp;b) {
int temp = a;
a = b;
b = temp;
}
// 使用
swap2(a,b);
</code></pre><p>引用也可以作为函数的返回值,不过不能返回局部变量的引用,因为局部变量过了作用域就销毁了</p>
<h2 id="21-继承"><a href="#21-继承" class="headerlink" title="21.继承"></a>21.继承</h2><p>继承方式包括 public（公有的）、private（私有的）和 protected（受保护的），此项是可选的，如果不写，那么默认为 private。</p>
<pre><code>class 派生类名:［继承方式］ 基类名{
    派生类新增加的成员
};
</code></pre><p>不同的继承方式会影响基类成员在派生类中的访问权限。</p>
<p>1) public继承方式</p>
<pre><code>基类中所有 public 成员在派生类中为 public 属性；
基类中所有 protected 成员在派生类中为 protected 属性；
基类中所有 private 成员在派生类中不能使用。
</code></pre><p>2) protected继承方式</p>
<pre><code>基类中的所有 public 成员在派生类中为 protected 属性；
基类中的所有 protected 成员在派生类中为 protected 属性；
基类中的所有 private 成员在派生类中不能使用。
</code></pre><p>3) private继承方式</p>
<pre><code>基类中的所有 public 成员在派生类中均为 private 属性；
基类中的所有 protected 成员在派生类中均为 private 属性；
基类中的所有 private 成员在派生类中不能使用。
</code></pre><p>基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。</p>
<p>基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。</p>
<p>类的构造函数不能被继承<br>析构函数也不能被继承<br>派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</p>
<h2 id="22-多重继承"><a href="#22-多重继承" class="headerlink" title="22.多重继承"></a>22.多重继承</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C&#123;</span><br><span class="line">    <span class="comment">//类D新增加的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和<strong>声明派生类时基类出现的顺序</strong>相同。</p>
<h2 id="23-虚继承"><a href="#23-虚继承" class="headerlink" title="23.虚继承"></a>23.虚继承</h2><p><img src="http://static.chenyalun.com/2017/04/03/20170403002.jpg" alt><br>假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A –&gt;B–&gt;D 这条路径，还是来自 A–&gt;C–&gt;D 这条路径。因为类 B 和类 C 中都有成员变量 a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了错误。</p>
<p>消除歧义:使用域解析操作符</p>
<p>为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。<br>在继承方式前面加上 virtual 关键字就是虚继承<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//间接基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; m_a = a; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setb</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123; m_b = b; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setc</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123; m_c = c; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setd</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123; m_d = d; &#125;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p>
<p>虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。</p>
<p>在最终派生类 D 的构造函数中，除了调用 B 和 C 的构造函数，还调用了 A 的构造函数，这说明 D 不但要负责初始化直接基类 B 和 C，还要负责初始化间接基类 A。直接派生类 B 和 C 对 A 的构造函数的调用是无效的.而在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误。</p>
<p>在类被构造的时候，先执行<strong>虚拟继承的父类的构造函数</strong>，然后从<strong>左到右执行普通继承的父类的构造函数</strong>，然后按照<strong>定义的顺序执行数据成员的初始化</strong>，最后是<strong>自身的构造函数的调用</strong>。析构函数与之完全相反，互成镜像。<br>见:<a href="http://gaocegege.com/Blog/cpp/cppclass" target="_blank" rel="noopener">http://gaocegege.com/Blog/cpp/cppclass</a></p>
<h2 id="24-C-向上转型"><a href="#24-C-向上转型" class="headerlink" title="24.C++向上转型"></a>24.C++向上转型</h2><p>编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。<br>基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。</p>
<h2 id="25-虚函数、纯虚函数与多态"><a href="#25-虚函数、纯虚函数与多态" class="headerlink" title="25.虚函数、纯虚函数与多态"></a>25.虚函数、纯虚函数与多态</h2><p>目的:让基类指针能够访问派生类的成员函数,只需要在该成员函数声明前面增加 virtual 关键字(基类\派生类都要操作)</p>
<p>有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）</p>
<p>虚函数的唯一用处就是构成多态,如果没有多态，我们只能访问成员变量。</p>
<p>只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）</p>
<p>构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。</p>
<p>析构函数可以声明为虚函数，而且有时候必须要声明为虚函数</p>
<p>将虚函数声明为纯虚函数，纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数。 语法格式为：</p>
<pre><code>virtual 返回值类型 函数名 (函数参数) = 0;
</code></pre><p><strong>包含纯虚函数的类称为抽象类（Abstract Class）</strong><br>一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。</p>
<h2 id="26-运算符重载"><a href="#26-运算符重载" class="headerlink" title="26.运算符重载"></a>26.运算符重载</h2><p>运算符重载的格式为：</p>
<pre><code>返回值类型 operator 运算符名称 (形参表列){
//TODO:
}

// 如complex operator+(const complex &amp;A) const;
</code></pre><h2 id="27-模板"><a href="#27-模板" class="headerlink" title="27.模板"></a>27.模板</h2><p>函数模板<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , ...&gt; 返回值类型  函数名(形参列表)&#123;</span><br><span class="line"><span class="comment">//在函数体中可以使用类型参数</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">typename</span>关键字可使用<span class="class"><span class="keyword">class</span>代替</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"> // 如</span></span><br><span class="line"><span class="class"><span class="title">template</span>&lt;class T&gt; <span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>)&#123;</span></span><br><span class="line">   T temp = a;</span><br><span class="line">   a = b;</span><br><span class="line">   b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键在于函数定义前面加上 template<typename t, typename m></typename></p>
<p>类模板<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , …&gt; <span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;typename T1, typename T2&gt;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板使用时需要指明类型,函数模板不需要</span></span><br><span class="line">Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; *p1 = <span class="keyword">new</span> Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt;(<span class="number">10.6</span>, <span class="number">109.3</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>参考博客<br>C语言中文网:<a href="http://c.biancheng.net/cpp/biancheng/cpp/rumen/" target="_blank" rel="noopener">http://c.biancheng.net/cpp/biancheng/cpp/rumen/</a></p>
</blockquote>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/C-提要/">C++提要</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/04/05/读《Effective Objective-C 2.0》/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">读《Effective Objective-C 2.0》</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2017/03/05/排序算法实现/">
        <span class="next-text nav-default">排序算法实现</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
