<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="从C++到汇编">




  <meta name="keywords" content="C++,">




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x">



<link rel="canonical" href="http://blog.chenyalun.com/2017/04/02/从C++到汇编/">


<meta name="description" content="2019.08.18 补充汇编内容   C++和汇编。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="从C++到汇编">
<meta property="og:url" content="http://blog.chenyalun.com/2017/04/02/从C++到汇编/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="2019.08.18 补充汇编内容   C++和汇编。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://static.chenyalun.com/2017/04/03/20170403002.jpg">
<meta property="og:updated_time" content="2019-09-12T06:49:27.336Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从C++到汇编">
<meta name="twitter:description" content="2019.08.18 补充汇编内容   C++和汇编。">
<meta name="twitter:image" content="http://static.chenyalun.com/2017/04/03/20170403002.jpg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> 从C++到汇编 · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          从C++到汇编
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017年4月2日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、基本语法"><span class="toc-text">一、基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#命名空间"><span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义及使用"><span class="toc-text">定义及使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统的命名空间"><span class="toc-text">系统的命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局命名空间"><span class="toc-text">全局命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-“C”"><span class="toc-text">extern “C”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cin与cout"><span class="toc-text">cin与cout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用"><span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指针、引用、数组"><span class="toc-text">指针、引用、数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针、引用、const"><span class="toc-text">指针、引用、const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存布局"><span class="toc-text">内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的内存"><span class="toc-text">对象的内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的创建"><span class="toc-text">对象的创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态分配内存"><span class="toc-text">动态分配内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内联函数"><span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员函数"><span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的默认参数"><span class="toc-text">函数的默认参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的重载"><span class="toc-text">函数的重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct与class"><span class="toc-text">struct与class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#析构函数"><span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化列表"><span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数调用构造函数"><span class="toc-text">构造函数调用构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拷贝构造函数"><span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深复制与浅复制"><span class="toc-text">深复制与浅复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态成员变量"><span class="toc-text">静态成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态成员函数"><span class="toc-text">静态成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常成员函数"><span class="toc-text">常成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#友元函数与友元类"><span class="toc-text">友元函数与友元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多继承"><span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚继承"><span class="toc-text">虚继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#菱形继承"><span class="toc-text">菱形继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多态"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚函数"><span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#纯虚函数"><span class="toc-text">纯虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符重载"><span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内部类局部类"><span class="toc-text">内部类局部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象型参数和返回值"><span class="toc-text">对象型参数和返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#仿函数"><span class="toc-text">仿函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板"><span class="toc-text">模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型转换"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11新特性"><span class="toc-text">C++11新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#智能指针"><span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-ptr-已经废弃"><span class="toc-text">auto_ptr(已经废弃)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-text">shared_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-ptr"><span class="toc-text">weak_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr"><span class="toc-text">unique_ptr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、其他"><span class="toc-text">二、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数调用的流程"><span class="toc-text">函数调用的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量地址"><span class="toc-text">变量地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寄存器"><span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-嵌入汇编"><span class="toc-text">c++嵌入汇编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C语言中模拟面向对象"><span class="toc-text">C语言中模拟面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#声明与实现分离"><span class="toc-text">声明与实现分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string的使用"><span class="toc-text">string的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-中的单例"><span class="toc-text">C++中的单例</span></a></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <blockquote>
<p>2019.08.18 补充汇编内容</p>
</blockquote>
<p align="center"> C++和汇编。 </p>

<a id="more"></a>
<p>本文主要是复习C++时的笔记，主要是语法方面的内容。为加深理解，部分语法尝试使用汇编窥测其实现。</p>
<h1 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>作用：防止出现变量或函数的命名冲突。</p>
<h3 id="定义及使用"><a href="#定义及使用" class="headerlink" title="定义及使用"></a>定义及使用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">namespace</span> YA &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">// 变量、类、函数、typedef、#define 等都可以出现在命名空间中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式一:域解析操作符</span></span><br><span class="line"><span class="comment">// :是域解析操作符,指明要使用的命名空间</span></span><br><span class="line">YA :: a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式二:针对变量</span></span><br><span class="line"><span class="comment">// 如果以后出现了未指明命名空间的a，就使用YA :: a</span></span><br><span class="line"><span class="keyword">using</span> YA :: a;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式三:针对命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> YA; <span class="comment">// 声明整个命名空间</span></span><br></pre></td></tr></table></figure>
<h3 id="系统的命名空间"><a href="#系统的命名空间" class="headerlink" title="系统的命名空间"></a>系统的命名空间</h3><p>对于不带<code>.h</code>的头文件，所有的符号都位于命名空间 <code>std</code> 中，使用时需要声明命名空间<code>std</code>；<br>对于带<code>.h</code>的头文件，没有使用任何命名空间，所有符号都位于全局作用域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<h3 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h3><p>在 <code>main()</code> 函数中声明命名空间 <code>std</code>，它的作用范围就位于 <code>main()</code> 函数内部，如果在其他函数中又用到了 <code>std</code>，就需要重新声明。如果希望在所有函数中都使用命名空间 <code>std</code>，可以将它声明在全局范围中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> YA &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YA"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"YA"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> YA;</span><br><span class="line">    ::func();</span><br><span class="line">    YA::func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><p>在C++（.cpp）文件中编译C语言（.c）的函数，出现编译不过，需要用到<code>extern &quot;C&quot;</code>。被 <code>extern &quot;C&quot;</code> 修饰的代码，按照C语言的方式编译。可以放在函数声明前面，也可以使用大括号的形式：<code>extern &quot;C&quot; {/*  */}</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>  &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cMath.h"</span>  <span class="comment">// 对应cMath.c</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好在cMath.h中配合<code>__cplusplus</code>宏使用：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cMath.h:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __CMATH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CMATH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __cplusplus</span></span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 函数声明	</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __cplusplus</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !__CMATH_H</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>__CMATH_H</code>可以防止整个文件的内容被重复包含，新标准下<code>#pragma once</code>也可以。</p>
<h2 id="cin与cout"><a href="#cin与cout" class="headerlink" title="cin与cout"></a>cin与cout</h2><p><code>cout</code> 和 <code>cin</code> 分别是 <code>ostream</code> 和 <code>istream</code> 类的对象，而不是关键字。使用示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a是"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b是"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>endl</code>表示end of line。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const的作用主要有：<br>1.定义常量<br><code>const int a = 10; // a不可修改</code></p>
<p>2.类型检查<br><code>void f(const int i){}
// 对传进来的参数进行类型检查,不匹配则提示</code></p>
<p>3.保护参数<br><code>void f(const int i){}
// i不可修改</code></p>
<p>4.节省空间<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换三次,分配三次内存空间</span></span><br><span class="line">#define pi <span class="number">3.14</span></span><br><span class="line"><span class="keyword">double</span> a = pi;</span><br><span class="line"><span class="keyword">double</span> b = pi;</span><br><span class="line"><span class="keyword">double</span> c = pi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> <span class="literal">PI</span> = <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 只分配一次内存空间</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="literal">PI</span>;</span><br><span class="line"><span class="comment">// 不再分配内存空间</span></span><br><span class="line"><span class="keyword">double</span> e = <span class="literal">PI</span>;</span><br></pre></td></tr></table></figure></p>
<p>混淆点:<br>指针本身是常量不可变，不可以指向其他：<code>char* const pContent;</code><br>指针所指向的内容是常量不可变：<code>const char *pContent;</code><br>两者都不可变：<code>const char* const pContent;</code></p>
<p>示例如下：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    int mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p1 = &#123; <span class="number">5</span> &#125;;</span><br><span class="line">Person p2 = &#123; <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">const Person *ptr2 = &amp;p1;</span><br><span class="line">*ptr2 = p2; <span class="comment">//no</span></span><br><span class="line">ptr2-&gt;mAge = <span class="number">16</span>; <span class="comment">//no</span></span><br><span class="line">(*ptr2).mAge = <span class="number">13</span>; <span class="comment">//no</span></span><br><span class="line">ptr2 = &amp;p2; <span class="comment">//yes</span></span><br><span class="line"></span><br><span class="line">Person * const ptr3 = &amp;p1;</span><br><span class="line">*ptr3 = p2; <span class="comment">//yes</span></span><br><span class="line">ptr3-&gt;mAge = <span class="number">16</span>; <span class="comment">//yes</span></span><br><span class="line">(*ptr3).mAge = <span class="number">13</span>; <span class="comment">//yes</span></span><br><span class="line">ptr3 = &amp;p2; <span class="comment">//no</span></span><br></pre></td></tr></table></figure></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在C++中，使用引用(Reference)可以起到与指针类似的功能。引用相当于是变量的别名(基本数据类型、枚举、结构体、类、指针、数组等，都可以有引用)，对引用做计算，就是对引用所指向的变量做计算。在定义的时候就必须初始化，一旦指向了某个变量，就不可以再改变。可以利用引用初始化另一个引用，相当于某个变量的多个别名。但是不存在引用的引用、指向引用的指针、引用数组。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">int age = <span class="number">10</span>;</span><br><span class="line">int &amp;<span class="keyword">new</span><span class="type">Age</span> = age; <span class="comment">// newAge与age等价，相当于别名</span></span><br><span class="line">age = <span class="number">20</span>; <span class="comment">// age、newAge都是20</span></span><br><span class="line"><span class="keyword">new</span><span class="type">Age</span> = <span class="number">30</span>; <span class="comment">// age、newAge都是30</span></span><br></pre></td></tr></table></figure>
<p>引用比指针更安全、函数返回值可以被赋值。一个引用占用一个指针的大小（64位8个字节或者32位4个字节），引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是弱化了的指针。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span><span class="comment">;</span></span><br><span class="line"><span class="number">01171010</span>  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>],<span class="number">0Ah</span>  </span><br><span class="line"><span class="keyword">int</span> *pAge = &amp;age<span class="comment">; // 指针</span></span><br><span class="line"><span class="number">01171017</span>  <span class="keyword">lea</span>         <span class="built_in">eax</span>,[<span class="built_in">ebp</span>-<span class="number">8</span>]  </span><br><span class="line">0117101A  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">0Ch</span>],<span class="built_in">eax</span>  </span><br><span class="line"><span class="keyword">int</span> &amp;newAge = age<span class="comment">; // 引用</span></span><br><span class="line"><span class="number">0117101D</span>  <span class="keyword">lea</span>         <span class="built_in">ecx</span>,[<span class="built_in">ebp</span>-<span class="number">8</span>]  </span><br><span class="line"><span class="number">01171020</span>  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">10h</span>],<span class="built_in">ecx</span></span><br></pre></td></tr></table></figure>
<p>从汇编看，效果是一样的：ebp-8是变量age的地址，之后都是把这个地址ebp-8存储到一个指针指向的空间中。</p>
<h3 id="指针、引用、数组"><a href="#指针、引用、数组" class="headerlink" title="指针、引用、数组"></a>指针、引用、数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 指针数组，数组中的元素是指针类型 int *</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *arr1[<span class="number">3</span>] = &#123;p, p, p&#125;;</span><br><span class="line"><span class="comment">// 指向数组的指针</span></span><br><span class="line"><span class="keyword">int</span> (*arr2)[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 数组的引用</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arr3)[<span class="number">3</span>] = <span class="built_in">array</span>;</span><br></pre></td></tr></table></figure>
<h3 id="指针、引用、const"><a href="#指针、引用、const" class="headerlink" title="指针、引用、const"></a>指针、引用、const</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> age2 = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ref1指向不可修改，ref1指向的内容可以修改</span></span><br><span class="line"><span class="keyword">int</span> &amp; <span class="keyword">const</span> ref1 = age; <span class="comment">// 等价于int &amp;ref1 = age;</span></span><br><span class="line">ref1 = <span class="number">13</span>; <span class="comment">//yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p1指向不可修改， p1指向的内容可以修改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p1 = &amp;age;</span><br><span class="line">p1 = &amp;age2; <span class="comment">//no</span></span><br><span class="line">*p1 = <span class="number">13</span>; <span class="comment">//yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ref1指向不可修改，ref1指向的内容不可以修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref2 = age;</span><br><span class="line">ref2 = <span class="number">13</span>; <span class="comment">//no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p2指向可以修改， p2指向的内容不可以修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;age;</span><br><span class="line">p2 = &amp;age2; <span class="comment">//yes</span></span><br><span class="line">*p2 = <span class="number">13</span>; <span class="comment">//no</span></span><br></pre></td></tr></table></figure>
<p><strong>常引用的临时数据</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;age1 = <span class="number">20</span>; <span class="comment">//直接赋值临时变量</span></span><br><span class="line"><span class="keyword">int</span> &amp;age1 = <span class="number">20</span>;<span class="comment">//no</span></span><br><span class="line"><span class="keyword">int</span> &amp;age2 = age;<span class="comment">//yes</span></span><br></pre></td></tr></table></figure>
<p><strong>函数参数是引用类型时，接受const与非const实参</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受各种类型的参数</span></span><br><span class="line">sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">sum(a, b);</span><br></pre></td></tr></table></figure>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>每个应用都有自己独立的内存空间，其内存空间一般有以下几大区域 ：</p>
<ol>
<li>代码段(代码区)：用于存放代码（只读）。</li>
<li>数据段(全局区)：用于存放全局变量等。</li>
<li>栈空间：每调用一个函数就会给它分配一段连续的栈空间，等函数调用完毕后会自动回收这段栈空间。会自动分配和回收。</li>
<li>堆空间：需要主动去申请和释放。</li>
</ol>
<p><strong>函数代码存放在代码段，局部变量存放在栈空间。</strong></p>
<h3 id="对象的内存"><a href="#对象的内存" class="headerlink" title="对象的内存"></a>对象的内存</h3><p>对象的内存可以存在于3种地方：</p>
<ul>
<li>全局区(数据段)：全局变量 </li>
<li>栈空间：函数里面的局部变量 </li>
<li>堆空间：动态申请内存(malloc、new等)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局区</span></span><br><span class="line">Person gPer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈空间</span></span><br><span class="line">    Person per;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 堆空间</span></span><br><span class="line">    Person *p = <span class="keyword">new</span> Person;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。</p>
<p>存储在栈上的对象</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Student stu<span class="comment">;</span></span><br><span class="line">Student *p = &amp;stu<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>存储在堆上的对象<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Student *stu = <span class="keyword">new</span> <span class="type">Student</span>;</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>new</code> 在堆上创建出来的对象是匿名的，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</p>
<h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>在程序运行过程，为了能够自由控制内存的生命周期、大小，会经常使用堆空间的内存。</p>
<p>堆空间的申请\释放：</p>
<ul>
<li><p>malloc \ free </p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>);</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>); <span class="comment">// 从p地址开始，每一个字节都设值为0；   </span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>
</li>
<li><p>new \ delete</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>; <span class="comment">// 未初始化</span></span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>(); <span class="comment">// 将默认初始化</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
</li>
<li><p>new [] \ delete []</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span> <span class="comment">// 未初始化</span></span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">6</span>] <span class="comment">// 将默认初始化</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>申请堆空间成功后，会返回那一段内存空间的地址。申请和释放必须是1对1的关系，不然可能会存在内存泄露。</p>
<p><strong>memset函数是将较大的数据结构(比如对象、数组等)内存清零的比较快的方法。</strong><br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Person per;</span><br><span class="line">per.age = <span class="number">1</span>;</span><br><span class="line">per.num = <span class="number">2</span>;</span><br><span class="line">per.id = <span class="number">3</span>;</span><br><span class="line">memset(&amp;per, <span class="number">0</span>, sizeof(per));</span><br><span class="line"></span><br><span class="line">Person persons[] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">memset(&amp;persons, <span class="number">0</span>, sizeof(persons));</span><br></pre></td></tr></table></figure></p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>为了消除函数调用的时空开销，在<strong>编译</strong>时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数。使用inline修饰函数的声明或者实现，将<strong>建议</strong>编译器使其成为内联函数，在函数定义处添加inline关键字，声明处添加无效，最好声明和实现都增加inline修饰。</p>
<p>若编译器使得函数成为内联函数，编译器会将函数调用直接展开为函数体代码，可以减少函数调用的开销，但是会增大代码体积。编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大。一些函数即使声明为inline，也不一定会被编译器内联，比如递归函数。尽量不要内联超过10行代码的函数。</p>
<p>内联函数和宏，都可以减少函数调用的开销，对比宏，内联函数多了语法检测和函数特性。<br>以func函数为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span> a)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有使用内联时：<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = func(<span class="number">5</span>)<span class="comment">;</span></span><br><span class="line"><span class="number">01321016</span>  <span class="keyword">push</span>        <span class="number">5</span>  </span><br><span class="line"><span class="number">01321018</span>  <span class="keyword">call</span>        func (<span class="number">01321000h</span>)  </span><br><span class="line"><span class="number">0132101D</span>  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">4</span>  </span><br><span class="line"><span class="number">01321020</span>  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [a],<span class="built_in">eax</span></span><br></pre></td></tr></table></figure></p>
<p>使用内联时：<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = func(<span class="number">5</span>)<span class="comment">;</span></span><br><span class="line"><span class="number">00291006</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="number">5</span>  </span><br><span class="line">0029100B  <span class="keyword">add</span>         <span class="built_in">eax</span>,<span class="number">3</span>  </span><br><span class="line">0029100E  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [a],<span class="built_in">eax</span></span><br></pre></td></tr></table></figure></p>
<p>可见函数调用<code>call func (01321000h)</code>确实是直接被替换成了函数体的内容：<code>add eax,3</code>。</p>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p><strong>在类体中定义的成员函数会自动成为内联函数</strong>，在类体外定义的不会。内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以建议在类体内部对成员函数作声明，而在类体外部进行定义。</p>
<p>不使用内联函数:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;  <span class="comment">//内联函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="keyword">void</span> Student::say()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h2><p>默认参数需要按照从右到左的顺序（与函数参数压栈顺序一致）设置。如果函数同时有声明、实现，默认参数只能放在函数声明中，默认参数的值可以是常量、全局符号(全局变量、函数名)。</p>
<p><strong>本质：编译器隐式传入默认参数，调用函数时依旧是将所有参数压栈。</strong></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">int func(int a, int b = <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span> a * b + a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">2</span>);</span><br><span class="line"><span class="number">010B1998</span>  <span class="built_in">push</span>        <span class="number">7</span>  </span><br><span class="line"><span class="number">010B199A</span>  <span class="built_in">push</span>        <span class="number">2</span>  </span><br><span class="line"><span class="number">010B199C</span>  call        func (<span class="number">010B1438h</span>)  </span><br><span class="line"><span class="number">010B19A1</span>  add         esp,<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>虽然调用时只传入一个参数，实际上编译器还是会传递默认参数进行调用：<code>push 7</code>。默认参数并不是包含在函数体中的。</p>
<p>注意：C与C++都可以将函数作为函数参数传递。<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span>(<span class="params"><span class="keyword">int</span> a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span>(*p</span>)(<span class="params"><span class="keyword">int</span></span>)) </span>&#123;</span><br><span class="line">    p(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h2><p>重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。重载的结果是让一个函数名拥有了多种用途，使得命名更加方便，调用更加灵活。<br>要求：函数名相同且参数列表不同。<strong>仅仅返回类型不同不足以成为函数的重载</strong>。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换 int 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换 float 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">float</span> *a, <span class="keyword">float</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重载的本质：在编译时会根据参数列表对函数进行重命名，采用了name mangling或者叫name decoration技术，函数重载仅仅是语法层面的，本质上它们还是<strong>不同的函数</strong>，占用不同的内存，入口地址也不一样。<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="function"><span class="keyword">func</span><span class="params">(int a)</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> a * a + a<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="function"><span class="keyword">func</span><span class="params">(int a, int b)</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> a * b + a + b<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="number">12</span>)</span>;</span></span><br><span class="line"><span class="number">003</span>A18C8  push        <span class="number">0</span>Ch</span><br><span class="line"><span class="number">003</span>A18CA  <span class="built_in">call</span>        <span class="function"><span class="keyword">func</span> <span class="params">(<span class="number">03</span>A1433h)</span></span></span><br><span class="line"><span class="number">003</span>A18CF  add         esp, <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>;</span></span><br><span class="line"><span class="number">003</span>A18D2  push        <span class="number">2</span></span><br><span class="line"><span class="number">003</span>A18D4  push        <span class="number">1</span></span><br><span class="line"><span class="number">003</span>A18D6  <span class="built_in">call</span>        <span class="function"><span class="keyword">func</span> <span class="params">(<span class="number">03</span>A1438h)</span></span></span><br><span class="line"><span class="number">003</span>A18DB  add         esp, <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>func()函数的重载，最终根据不同的参数类型生成不同的函数：<code>func (03A1433h)</code>、<code>func (03A1438h)</code>。<br>注意：调用函数时，实参的隐式类型转换可能会产生二义性。</p>
<h2 id="struct与class"><a href="#struct与class" class="headerlink" title="struct与class"></a>struct与class</h2><p>C++中可以使用struct、class来定义一个类。struct与class的区别：</p>
<ol>
<li>使用 <code>class</code> 时，类中的成员默认都是 <code>private</code> 属性的；而使用 <code>struct</code> 时，结构体中的成员默认都是 <code>public</code> 属性的</li>
<li><code>class</code> 继承默认是 <code>private</code> 继承，而 <code>struct</code> 继承默认是 <code>public</code> 继承。</li>
<li><code>class</code> 可以使用模板，而 <code>struct</code> 不能。</li>
</ol>
<p><strong>struct</strong></p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    <span class="keyword">int</span> mAge<span class="comment">;</span></span><br><span class="line">    <span class="keyword">int</span> mNum<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Person per<span class="comment">;</span></span><br><span class="line">per.mAge = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">00811A02  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">10h</span>],<span class="number">0Ah</span>  </span><br><span class="line">per.mNum = <span class="number">101</span><span class="comment">;</span></span><br><span class="line">00811A09  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">0Ch</span>],<span class="number">65h</span></span><br></pre></td></tr></table></figure>
<p><strong>class</strong><br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    <span class="keyword">int</span> mAge<span class="comment">;</span></span><br><span class="line">    <span class="keyword">int</span> mNum<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Person per<span class="comment">;</span></span><br><span class="line">per.mAge = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">012D1A02  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">ebp</span> - <span class="number">10h</span>], <span class="number">0Ah</span></span><br><span class="line">per.mNum = <span class="number">101</span><span class="comment">;</span></span><br><span class="line">012D1A09  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">ebp</span> - <span class="number">0Ch</span>], <span class="number">65h</span></span><br></pre></td></tr></table></figure></p>
<p>对比发现，struct与class在汇编层面（本质上）是一致的。区别主要体现在权限上。</p>
<p>变量名规范参考：</p>
<ul>
<li>全局变量：gName </li>
<li>成员变量：mName </li>
<li>静态变量：sName</li>
<li>常量：cName</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><strong>怎么实现C++中函数访问成员变量？</strong><br>函数在代码区，访问其他区的对象（栈、堆、静态区）。可以试着传递对象的地址。比如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">(Person *per)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法中访问成员变量</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; per-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person per;</span><br><span class="line">per.mAge = <span class="number">10</span>;</span><br><span class="line">per.showAge(&amp;per);</span><br></pre></td></tr></table></figure></p>
<p>由这个思路，便产生了this。this是 C++ 中的一个关键字，也是一个 <strong>const 指针</strong>，它指向当前对象，通过它可以访问当前对象的所有成员。this虽然用在类的内部，但是只有在对象被创建以后才会给this赋值，并且这个赋值的过程是<strong>编译器自动完成的</strong>，不需要用户干预，用户也不能显式地给this赋值。</p>
<p>本质上<strong><code>this</code> 是成员函数的一个形参</strong>，存储着函数调用者（对象）的地址。<code>this</code> 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。<code>this</code> 作为隐式形参，<strong>是成员函数的局部变量</strong>，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 <code>this</code> 赋值。</p>
<p>窥测其实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">configAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person per;</span><br><span class="line">per.configAge();</span><br></pre></td></tr></table></figure></p>
<p>转成汇编后：<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">Person per<span class="comment">;</span></span><br><span class="line">per.configAge()<span class="comment">;</span></span><br><span class="line">01001A12  <span class="keyword">lea</span>         <span class="built_in">ecx</span>,[<span class="built_in">ebp</span>-<span class="number">0Ch</span>]  </span><br><span class="line">01001A15  <span class="keyword">call</span>        <span class="number">01001460</span> </span><br><span class="line"></span><br><span class="line">void configAge() &#123;</span><br><span class="line">....</span><br><span class="line">010019A0  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>],<span class="built_in">ecx</span>  </span><br><span class="line">.... </span><br><span class="line">this-&gt;mAge = <span class="number">5</span><span class="comment">;</span></span><br><span class="line">010019AD  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>]  </span><br><span class="line">010019B0  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>],<span class="number">5</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把per对象的地址（ebp-0Ch）存储在ecx中，调用per.configAge()函数。在该函数执行过程中，把ecx存储的值（per对象的地址）放到ebp-8指向的内存空间中，也即ebp-8是this指针的地址，这个地址指向的空间存储着per对象的地址。再把ebp-8存储的内容赋值到eax中，那么eax存储的即是per对象的地址，也即per.mAge的地址。赋值即可。</p>
<p>this是指针，<code>this-&gt;</code>表示访问this指针指向的对象。在开发中可以省略<code>this-&gt;</code>，直接使用<code>mAge = 5</code>赋值。实际上是语法糖。编译器会帮我们加上<code>this-&gt;</code>。</p>
<p>利用指针间接访问所指对象的成员变量，先从指针中取出对象的地址，利用对象的地址加上成员变量的偏移量计算出成员变量的地址。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数(也叫构造器)，在对象创建的时候自动调用，一般用于完成对象的初始化工作。函数名与类同名，无返回值，可以有参数，可以重载，可以有多个构造函数。一旦自定义了构造函数，必须用其中一个自定义的构造函数来初始化对象。通过malloc分配的对象不会调用构造函数。</p>
<p><strong>调用没有参数的构造函数可以省略括号</strong>。<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Student stu()<span class="comment">;</span></span><br><span class="line">Student stu<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Student *stu = new Student()<span class="comment">;</span></span><br><span class="line">Student *stu = new Student<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>构造函数中初始化</strong><br>如果自定义了构造函数，除了全局区，其他内存空间的成员变量默认都不会被初始化，需要开发人员手动初始化。可以理解，自定义构造函数的大多数原因是为了初始化。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(Person));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>易混淆点</strong><br><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span> <span class="keyword">person</span>; // 创建<span class="keyword">person</span>对象</span><br><span class="line"><span class="keyword">Person</span> <span class="keyword">person</span>(); // 返回<span class="keyword">Person</span>类型的函数声明</span><br><span class="line"><span class="keyword">Person</span> <span class="keyword">person</span>(2); // 创建<span class="keyword">person</span>对象，自定义构造函数</span><br></pre></td></tr></table></figure></p>
<p><code>Person *p = new Person();</code>创建出来的Car对象在堆空间。<br><code>Person p;</code>创建出来的Car对象在栈空间。</p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数(也叫析构器)，在对象销毁的时候自动调用，一般用于完成对象的清理工作。函数名以~开头，与类同名，无返回值，无参，不可以重载，有且只有一个析构函数。通过malloc分配的对象free的时候不会调用析构函数。构造函数、析构函数要声明为public，才能被外界正常使用。</p>
<figure class="highlight pony"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span>() &#123;</span><br><span class="line">    car = <span class="function"><span class="keyword">new</span> <span class="title">Car</span>();</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">~<span class="title">Person</span>() &#123;</span></span><br><span class="line"><span class="function">    <span class="title">delete</span> <span class="title">car</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>析构函数清理未被回收的堆空间对象。</p>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Person(<span class="keyword">int</span> age, <span class="keyword">int</span> id) &#123;</span><br><span class="line">    mAge = age;</span><br><span class="line">    mId = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全等价于</span></span><br><span class="line">Person(<span class="keyword">int</span> age, <span class="keyword">int</span> id) :mAge(age), mId(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以传入函数</span></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">return</span> <span class="number">10</span>;&#125;</span><br><span class="line">Person(<span class="keyword">int</span> age, <span class="keyword">int</span> id) :mAge(<span class="function"><span class="keyword">func</span><span class="params">()</span>), <span class="title">mId</span><span class="params">(id)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>初始化列表的初始化顺序<strong>与成员变量声明顺序有关</strong>。</p>
<p>带默认参数的初始化列表：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 也可以传入函数</span></span><br><span class="line">Person(<span class="keyword">int</span> age = <span class="number">0</span>, <span class="keyword">int</span> <span class="keyword">id</span> = <span class="number">0</span>) :mAge(age), mId(<span class="keyword">id</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果函数声明和实现是分离的，初始化列表只能写在函数的实现中。默认参数只能写在函数的声明中。</p>
<h2 id="构造函数调用构造函数"><a href="#构造函数调用构造函数" class="headerlink" title="构造函数调用构造函数"></a>构造函数调用构造函数</h2><p>子类的构造函数默认会调用父类的无参构造函数。如果子类的构造函数显式地调用了父类的有参构造函数，就不会再去默认调用父类的无参构造函数。如果父类缺少无参构造函数，子类的构造函数必须显式调用父类的有参构造函数。</p>
<p>构造函数调用构造函数必须放到初始化列表中。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Person(<span class="keyword">int</span> age, <span class="keyword">int</span> <span class="keyword">id</span>) &#123;</span><br><span class="line">    mAge = age;</span><br><span class="line">    mId = <span class="keyword">id</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数调用构造函数</span></span><br><span class="line">Person() :Person(<span class="number">10</span>,<span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不能像下面这样调用。这样相当于创建一个临时的对象。<br><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span>() &#123;</span><br><span class="line">    <span class="keyword">Person</span>(10,2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在C++中也不能这样调用。<br><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span>() &#123;</span><br><span class="line">    this-&gt;<span class="keyword">Person</span>(1, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造函数是构造函数的一种。当利用已存在的对象创建一个新对象时(类似于拷贝)，就会调用新对象的拷贝构造函数进行初始化。拷贝构造函数的格式是固定的，接收一个const引用作为参数(使用const修饰，则可以接收非const对象和const对象；使用引用，可以避免产生死循环)。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mID;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认参数与初始化列表</span></span><br><span class="line">    Person(<span class="keyword">int</span> id = <span class="number">0</span>, <span class="keyword">int</span> age = <span class="number">0</span>) :mID(id), mAge(age) &#123;&#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;per) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mID = per.mID;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = per.mAge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; mID &lt;&lt; <span class="built_in">endl</span> &lt;&lt; mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用拷贝<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Person</span> <span class="selector-tag">per</span>(<span class="number">1</span>,<span class="number">12</span>);</span><br><span class="line"><span class="selector-tag">per</span><span class="selector-class">.show</span>();</span><br><span class="line"><span class="selector-tag">Person</span> <span class="selector-tag">per2</span>(per);</span><br><span class="line"><span class="selector-tag">per2</span><span class="selector-class">.show</span>();</span><br></pre></td></tr></table></figure></p>
<p>当完全省略拷贝构造函数时，x86下汇编为：<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">Person per2(per)<span class="comment">;</span></span><br><span class="line">009E2076  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [per]  </span><br><span class="line">009E2079  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [per2],<span class="built_in">eax</span>  </span><br><span class="line">009E207C  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">0Ch</span>]  </span><br><span class="line">009E207F  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">1Ch</span>],<span class="built_in">ecx</span></span><br></pre></td></tr></table></figure></p>
<p>x64下汇编为：<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">Person per2(per)<span class="comment">;</span></span><br><span class="line">00007FF669AD1AF8  <span class="keyword">mov</span>         <span class="built_in">rax</span>,<span class="built_in">qword</span> <span class="built_in">ptr</span> [per]  </span><br><span class="line">00007FF669AD1AFC  <span class="keyword">mov</span>         <span class="built_in">qword</span> <span class="built_in">ptr</span> [per2],<span class="built_in">rax</span></span><br></pre></td></tr></table></figure></p>
<p>可见，默认实现即是把per指向的内存空间中的8个字节拷贝到per2指向的内存空间中。与<code>this-&gt;mID = per.mID; this-&gt;mAge = per.mAge;</code>相同。x86下，一次操作拷贝4个字节（dword），x64下，一次操作拷贝8个字节（qword）。</p>
<p>调用父类的拷贝构造函数<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Student</span> : <span class="type">Person</span> &#123;</span></span><br><span class="line"><span class="class">    int mSchoolID;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">    <span class="type">Student</span>(<span class="title">int</span> <span class="type">ID</span> = 0, <span class="title">int</span> <span class="title">age</span> = 0, <span class="title">int</span> <span class="title">schoolID</span> = 0) :<span class="type">Person</span>(<span class="type">ID</span>, <span class="title">age</span>), mSchoolID(<span class="title">schoolID</span>) &#123;&#125;</span></span><br><span class="line"><span class="class">    // 调用父类的拷贝构造函数</span></span><br><span class="line"><span class="class">    <span class="type">Student</span>(<span class="title">const</span> <span class="type">Student</span> &amp;<span class="title">stu</span>) : <span class="type">Person</span>(<span class="title">stu</span>), mSchoolID(<span class="title">stu</span>.<span class="title">mSchoolID</span>) &#123;&#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>注意：<code>Person per2(per);</code>与<code>Person per2 = per;</code>完全等价，都是拷贝构造。</p>
<p>区分拷贝操作：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Person per<span class="comment">;</span></span><br><span class="line">Person per2<span class="comment">;</span></span><br><span class="line">// 仅仅是拷贝</span><br><span class="line"><span class="attribute">per2</span> = per<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="深复制与浅复制"><a href="#深复制与浅复制" class="headerlink" title="深复制与浅复制"></a>深复制与浅复制</h2><p>编译器默认的提供的拷贝是浅拷贝(shallow copy)。将一个对象中所有成员变量的值拷贝到另一个对象。如果某个成员变量是个指针，只会拷贝指针中存储的地址值，并不会拷贝指针指向的内存空间。可能会导致堆空间多次free的问题。如果需要实现深拷贝(deep copy)，就需要自定义拷贝构造函数。将指针类型的成员变量所指向的内存空间，拷贝到新的内存空间。</p>
<p>危险的堆空间指针指向栈空间：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doge</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">    <span class="keyword">char</span> *mName;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Doge(<span class="keyword">int</span> age, <span class="keyword">const</span> <span class="keyword">char</span>* name) :mAge(age), mName(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Doge *doge;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> name[] = &#123; <span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>, <span class="string">'\0'</span> &#125;;</span><br><span class="line">    doge = <span class="keyword">new</span> Doge(<span class="number">3</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>name过了作用域会被回收，此时doge中的mName就很危险。需要重写构造函数，将mName存储到堆空间上：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Doge(<span class="keyword">int</span> age, <span class="keyword">const</span> <span class="keyword">char</span>* name) :mAge(age) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 申请堆空间 &#123;&#125;是清零操作</span></span><br><span class="line">    mName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>] &#123;&#125;;</span><br><span class="line">    <span class="comment">// 拷贝</span></span><br><span class="line">    <span class="built_in">strcpy</span>(mName, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重写析构函数，清除mName：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~Dog() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mName == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] mName;</span><br><span class="line">    mName = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>深拷贝：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Doge(<span class="keyword">const</span> Doge&amp; doge) : mAge(doge.mAge) &#123;</span><br><span class="line">    <span class="keyword">if</span> (doge.mName == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 申请堆空间 &#123;&#125;是清零操作</span></span><br><span class="line">    mName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(doge.mName) + <span class="number">1</span>]&#123;&#125;;</span><br><span class="line">    <span class="comment">// 拷贝</span></span><br><span class="line">    <span class="built_in">strcpy</span>(mName, doge.mName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p><code>static</code> 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只分配一份内存。<code>static</code> 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 <code>static</code> 成员变量不能使用。</p>
<p>static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 mTotal 声明为静态成员变量</span></span><br><span class="line"><span class="comment">//通过类类访问 static 成员变量</span></span><br><span class="line">Student::mTotal = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//通过对象来访问 static 成员变量</span></span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</span><br><span class="line">stu.mTotal = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//通过对象指针来访问 static 成员变量</span></span><br><span class="line">Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李华"</span>, <span class="number">16</span>, <span class="number">96</span>);</span><br><span class="line">pstu -&gt; mTotal = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
<p>静态成员变量必须初始化，而且只能在类体外进行。</p>
<p><code>static</code> 成员变量和普通 <code>static</code> 变量一样，都在内存分区中的<strong>全局数据区</strong>分配内存，到程序结束时才释放。这就意味着，<code>static</code> 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p>
<h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。普通成员变量占用对象的内存，静态成员函数没有 <code>this</code> 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。<br>普通成员函数必须通过对象才能调用，而静态成员函数没有 <code>this</code> 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。</p>
<p>静态成员函数与普通成员函数的根本区别在于：普通成员函数有 <code>this</code> 指针，可以访问类中的任意成员；而静态成员函数没有 <code>this</code> 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</p>
<h2 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h2><p><code>const</code> 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。</p>
<p>常成员函数需要在声明和定义的时候在函数头部的结尾加上 <code>const</code> 关键字：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">//声明常成员函数</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//定义常成员函数</span></span><br><span class="line"><span class="keyword">int</span> Student::getage() <span class="keyword">const</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> m_age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="友元函数与友元类"><a href="#友元函数与友元类" class="headerlink" title="友元函数与友元类"></a>友元函数与友元类</h2><p>借助友元（friend），可以<strong>使得其他类中的成员函数以及全局范围内的函数访问当前类的 <code>private</code> 成员</strong>。在当前类以外定义的、不属于当前类的函数可以在类中声明，但要在前面加 <code>friend</code> 关键字，这样就构成了友元函数。友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。</p>
<p>一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 <code>private</code> 成员。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// 构造函数</span></span><br><span class="line">    Address(<span class="keyword">char</span> *province, <span class="keyword">char</span> *city, <span class="keyword">char</span> *district);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将Student类中的成员函数show()声明为友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Student::show(Address *addr);</span><br></pre></td></tr></table></figure></p>
<p>友元类中的所有成员函数都是另外一个类的友元函数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Address(<span class="keyword">char</span> *province, <span class="keyword">char</span> *city, <span class="keyword">char</span> *district);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//将Student类声明为Address类的友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 <code>private</code> 成员。友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承方式包括 <code>public</code>（公有的）、<code>private</code>（私有的）和 <code>protected</code>（受保护的），此项是可选的，如果不写，那么默认为 <code>private</code>。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:<span class="type">［继承方式］ 基类名&#123;</span></span></span><br><span class="line">   派生类新增加的成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>不同的继承方式会影响基类成员在派生类中的访问权限。</p>
<p>1) public继承方式</p>
<ul>
<li>基类中所有 public 成员在派生类中为 public 属性；</li>
<li>基类中所有 protected 成员在派生类中为 protected 属性；</li>
<li>基类中所有 private 成员在派生类中不能使用。</li>
</ul>
<p>2) protected继承方式</p>
<ul>
<li>基类中的所有 public 成员在派生类中为 protected 属性；</li>
<li>基类中的所有 protected 成员在派生类中为 protected 属性；</li>
<li>基类中的所有 private 成员在派生类中不能使用。</li>
</ul>
<p>3) private继承方式</p>
<ul>
<li>基类中的所有 public 成员在派生类中均为 private 属性；</li>
<li>基类中的所有 protected 成员在派生类中均为 private 属性；</li>
<li>基类中的所有 private 成员在派生类中不能使用。</li>
</ul>
<p>基类的 <code>private</code> 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。对象的内存布局：父类的成员变量在前，子类的成员变量在后。</p>
<ol>
<li>类的构造函数不能被继承；</li>
<li>析构函数也不能被继承；</li>
<li>派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</li>
</ol>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>C++允许一个类可以有多个父类。<br><strong>同名成员变量访问</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> A, B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line">C c;</span><br><span class="line">c.mAge = <span class="number">10</span>;</span><br><span class="line">c.B::mAge = <span class="number">12</span>;</span><br><span class="line">c.A::mAge = <span class="number">13</span>;</span><br></pre></td></tr></table></figure>
<p><strong>多继承的场景主要是应用在继承协议遵从接口。</strong></p>
<h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p><img src="http://static.chenyalun.com/2017/04/03/20170403002.jpg" alt><br>假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A –&gt;B–&gt;D 这条路径，还是来自 A–&gt;C–&gt;D 这条路径。因为类 B 和类 C 中都有成员变量 a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了错误。</p>
<p>菱形继承带来的问题：最底下子类从基类继承的成员变量冗余、重复；最底下子类无法访问基类的成员，有二义性。为了解决这个问题，便有了虚继承。</p>
<p>在继承方式前面加上 virtual 关键字就是虚继承：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//间接基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;  <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;  <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; m_a = a; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setb</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123; m_b = b; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setc</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; m_c = c; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setd</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123; m_d = d; &#125;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在类被构造的时候，先执行<strong>虚拟继承的父类的构造函数</strong>，然后从<strong>左到右执行普通继承的父类的构造函数</strong>，然后按照<strong>定义的顺序执行数据成员的初始化</strong>，最后是<strong>自身的构造函数的调用</strong>。析构函数与之完全相反，互成镜像。<a href="http://gaocegege.com/Blog/cpp/cppclass" target="_blank" rel="noopener">more</a>。</p>
<p><strong>虚继承解决菱形继承问题。虚函数解决多态问题。纯虚函数解决协议问题。</strong></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>默认情况下，编译器只会根据指针类型调用对应的函数，不存在多态。</strong>C++中的多态通过虚函数实现。</p>
<p>多态的要素：</p>
<ul>
<li>子类重写父类的成员函数(override) </li>
<li>父类指针指向子类对象 </li>
<li>利用父类指针调用重写的成员函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object::show"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person子类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> :</span> Object &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"Person::show"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student子类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> :</span> Object &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student::show"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Object *p1 = <span class="keyword">new</span> Student();</span><br><span class="line">p1-&gt;show();</span><br><span class="line">Object*p2 = <span class="keyword">new</span> Person();</span><br><span class="line">p2-&gt;show();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">Object::show</span><br><span class="line">Object::show</span><br></pre></td></tr></table></figure>
<p>默认没有实现多态。使用虚函数后：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object::show"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">Student::show</span><br><span class="line">Person::show</span><br></pre></td></tr></table></figure>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>父类添加virtual，声明为虚函数，子类的这些函数将自动成为虚函数。</p>
<p>没有添加virtual关键字时：<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">p2-&gt;show()<span class="comment">;</span></span><br><span class="line">00AD2AF4  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [p2]  </span><br><span class="line">00AD2AF7  <span class="keyword">call</span>        Object::show (<span class="number">0AD14CEh</span>)</span><br></pre></td></tr></table></figure></p>
<p>添加virtual关键字时：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">p2-&gt;show()<span class="comment">;</span></span><br><span class="line">// 取出p2所指对象的地址给<span class="built_in">eax</span></span><br><span class="line">000666EF  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [p2]  </span><br><span class="line">// 取出对象最前面的<span class="number">4</span>个字节给<span class="built_in">edx</span></span><br><span class="line">000666F2  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>] </span><br><span class="line">// 取出虚表的最前面的<span class="number">4</span>个字节给<span class="built_in">eax</span></span><br><span class="line">000666F9  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>]</span><br><span class="line">// 调用函数  </span><br><span class="line">000666FB  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>
<p>虚函数的实现原理是虚表，这个虚表里面存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表。同一个基类的所有实例共用一份虚表。父类中的函数有virtual修饰，则子类中的该函数也会有virtual修饰，可省略。</p>
<p>重写后调用父类方法：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Person</span>::<span class="function"><span class="keyword">func</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果存在父类类型指针指向子类对象，应该将析构函数声明为虚函数(虚析构函数)。这样delete父类指针时，才会调用子类的析构函数，保证析构的完整性。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>纯虚函数：没有函数体且初始化为0的虚函数，用来定义接口规范。抽象类(Abstract Class)：含有纯虚函数的类，不可以实例化(不可以创建对象) 。抽象类也可以包含非纯虚函数，如果父类是抽象类，子类没有完全实现纯虚函数，那么这个子类依然是抽象类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载(操作符重载):可以为运算符增加一些新的功能。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">CGPoint</span> &#123;</span><br><span class="line">    <span class="keyword">float</span> mX;</span><br><span class="line">    <span class="keyword">float</span> mY;</span><br><span class="line">    Person(<span class="keyword">int</span> x, <span class="keyword">int</span> y) :mX(x), mY(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// 左边的const防止返回值被赋值，如 (p2 + p2) = p;</span></span><br><span class="line">    <span class="comment">// 右边的const保证返回值能再次调用operator+， 如 p = p1 + p2 + p3;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">CGPoint</span> operator+(<span class="keyword">const</span> <span class="built_in">CGPoint</span> &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGPoint</span>(mX + p.mX, mY + p.mY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGPoint</span> operator+(<span class="keyword">const</span> <span class="built_in">CGPoint</span> &amp;p1, <span class="keyword">const</span> <span class="built_in">CGPoint</span> &amp;p2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGPoint</span>(p1.mX + p2.mX, p1.mY + p2.mY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGPoint</span> per = <span class="built_in">CGPoint</span>(<span class="number">2</span>, <span class="number">3</span>) + <span class="built_in">CGPoint</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h2 id="内部类局部类"><a href="#内部类局部类" class="headerlink" title="内部类局部类"></a>内部类局部类</h2><p>如果将类A定义在类C的内部，那么类A就是一个内部类(嵌套类)。<br>内部类的特点</p>
<ul>
<li>支持public、protected、private权限 </li>
<li>成员函数可以直接访问其外部类对象的所有成员(反过来则不行) </li>
<li>成员函数可以直接不带类名、对象名访问其外部类的static成员 </li>
<li>不会影响外部类的内存布局 </li>
<li>可以在外部类内部声明，在外部类外面进行定义</li>
</ul>
<p>在一个函数内部定义的类，称为局部类。<br>局部类的特点：</p>
<ul>
<li>作用域仅限于所在的函数内部 </li>
<li>其所有的成员必须定义在类内部，不允许定义static成员变量 </li>
<li>成员函数不能直接访问函数的局部变量(static变量除外)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> mAge;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person::show();<span class="comment">// 函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象型参数和返回值"><a href="#对象型参数和返回值" class="headerlink" title="对象型参数和返回值"></a>对象型参数和返回值</h2><p>使用对象类型作为函数的参数或者返回值，可能会产生一些不必要的中间对象。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()&#123;&#125; <span class="comment">// 构造</span></span><br><span class="line">    Person(<span class="keyword">int</span> age) :mAge(age)&#123;&#125; <span class="comment">// 初始化列表</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;per) :mAge(per.age)&#123;&#125; <span class="comment">// 拷贝构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(Person per)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为返回值</span></span><br><span class="line"><span class="function">Person <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">per</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> per;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function">Person <span class="title">per1</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">func1(per1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">Person per2;</span><br><span class="line">per2 = func2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">Person per3 = func2();</span><br></pre></td></tr></table></figure></p>
<p>对于<code>Person per1(12); func1(per1);</code>，当对象作为参数传递到另一个函数栈空间时，调用拷贝构造函数，创建出一个新的临时对象。<br>对于<code>Person per2; per2 = func2();</code>，当对象作为返回值传递到另一个函数栈时，也会调用拷贝构造函数，创建出新的临时对象。<br>对于<code>Person per3 = func2();</code>，原则上也应该调用拷贝构造函数，创建出新的对象。实际上编译器做了优化，在return之前，预先把结果对象的地址传递给函数，函数创建完对象就把该对象放到该地址对象的空间上。</p>
<p>对象作为参数或者返回值时尽量使用引用：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(Person &amp;p)</span></span> &#123;&#125;</span><br><span class="line">Person &amp;<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 返回对象而不是指针</span></span><br></pre></td></tr></table></figure></p>
<p><strong>匿名对象</strong><br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">Person</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>隐式构造</strong><br>某些情况下，会隐式调用单参数的构造函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Person <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span>; <span class="comment">// 隐式构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person per = <span class="number">22</span>; <span class="comment">// 隐式构造，一次构造</span></span><br><span class="line"></span><br><span class="line">Person per2;  <span class="comment">// 构造</span></span><br><span class="line">per2 = <span class="number">23</span>; <span class="comment">// 拷贝构造</span></span><br></pre></td></tr></table></figure>
<p>使用关键字explicit禁用掉隐式构造。</p>
<h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载运算符: ()</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Sum sum;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>使用成员函数，可以使用仿函数。对比普通函数，可以作为对象保存状态。</p>
<p>有些运算符不可以被重载，比如：</p>
<ul>
<li>对象成员访问运算符：<code>.</code></li>
<li>域运算符：<code>::</code></li>
<li>三目运算符：<code>?:</code></li>
<li><code>sizeof</code></li>
</ul>
<p>有些运算符只能重载为成员函数，比如：</p>
<ul>
<li>赋值运算符：<code>=</code></li>
<li>下标运算符：<code>[]</code></li>
<li>函数运算符：<code>()</code></li>
<li>指针访问成员：<code>-&gt;</code></li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>泛型，是一种将类型参数化以达到代码复用的技术，C++中使用模板来实现泛型。模板的使用格式如下：<br><code>template &lt;typename\class T&gt;</code>，其中typename和class是等价的。</p>
<p><strong>模板没有被使用时，是不会被实例化出来的。</strong><br>模板的声明和实现如果分离到.h和.cpp中，会导致链接错误。原因是，实现文件不知道外界究竟怎么使用模板，不知道该怎么生成具体的实现，这就导致了多个目标文件链接的时候，无法找到具体的函数实现地址。一般将模板的声明和实现统一放到一个.hpp文件中。这样，使用了哪些函数，编译器就生成哪些实现。</p>
<p><strong>函数模板</strong><br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">void <span class="keyword">swap(T </span>&amp;a, T &amp;<span class="keyword">b) </span>&#123;</span><br><span class="line">    T tmp = a<span class="comment">;</span></span><br><span class="line">    a = <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">b </span>= tmp<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>多参数模板</strong><br><figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span><br><span class="line"><span class="keyword">void</span> show(<span class="keyword">const</span> T1 &amp;a, <span class="keyword">const</span> T2 &amp;b) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>类模板</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> &lt;&gt;show(T &amp;t); <span class="comment">// 类模板中的友元函数</span></span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>C语言风格的类型转换符 </p>
<ul>
<li>(type)expression</li>
<li>type(expression)</li>
</ul>
<p>C++中有4个类型转换符 </p>
<ul>
<li>static_cast</li>
<li>dynamic_cast</li>
<li>reinterpret_cast</li>
<li>const_cast </li>
</ul>
<p>使用格式：<code>xx_cast&lt;type&gt;(expression)</code></p>
<p><strong>const_cast</strong><br>一般用于去除const属性，将const转换成非const。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person *p = <span class="keyword">new</span> Person();</span><br><span class="line">Person *p2 = <span class="keyword">const_cast</span>&lt;Person *&gt;(p);</span><br><span class="line"><span class="comment">// 等价于 Person *p2 = (Person *)p;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>dynamic_cast</strong><br>一般用于多态类型的转换，有运行时安全检测。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person *p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person *p2 = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相比较 Student *s = (Student *)p;，多了安全检测, s1会为空</span></span><br><span class="line">Student *s1 = <span class="keyword">dynamic_cast</span>&lt;Student *&gt;(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// s2正常</span></span><br><span class="line">Student *s2 = <span class="keyword">dynamic_cast</span>&lt;Student *&gt;(p2);</span><br></pre></td></tr></table></figure></p>
<p><strong>static_cast</strong><br>对比dynamic_cast，缺乏运行时安全检测</p>
<ul>
<li>不能交叉转换(不是同一继承体系的，无法转换) </li>
<li>常用于基本数据类型的转换、非const转成const </li>
<li>适用范围较广</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 等价于 const Person *p2 = p1;</span></span><br><span class="line">Person p2 = <span class="keyword">static_cast</span>&lt;Student *&gt;(p1);</span><br></pre></td></tr></table></figure>
<p><strong>reinterpret_cast</strong><br>属于比较底层的强制转换，没有任何类型检查和格式转换，仅仅是简单的二进制数据拷贝。<br>可以交叉转换，可以将指针和整数互相转换。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">一个字节为<span class="number">8</span>位。一个十六进制位等于<span class="number">4</span>个二进制位。</span><br><span class="line">int a = <span class="number">10</span>;</span><br><span class="line">在计算机存储（小端模式）：</span><br><span class="line">二进制： <span class="number">0000</span> <span class="number">1010</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">十六进制：<span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"></span><br><span class="line">double b = a; <span class="comment">//按照8个字节来说</span></span><br><span class="line">浮点数的存储于整数存储大不相同：</span><br><span class="line">十六进制：<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">24</span> <span class="number">40</span></span><br><span class="line">浮点数存储不是简单把二进制数据拷贝存储。</span><br></pre></td></tr></table></figure>
<p>数据拷贝存储：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span>&amp;&gt;(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(p);</span><br></pre></td></tr></table></figure>
<h2 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">auto a</span> = 5;</span><br></pre></td></tr></table></figure>
<p>可以从初始化表达式中推断出变量的类型。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">int <span class="keyword">b </span>= <span class="number">5</span><span class="comment">;</span></span><br><span class="line">decltype(<span class="keyword">b) </span>c = <span class="number">6</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以获取变量的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;b;</span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>指针置为空。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">int <span class="keyword">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (int <span class="literal">item</span> : <span class="keyword">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速遍历。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">int array[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>) = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> exec(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>(*<span class="function"><span class="keyword">func</span>)<span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="function"><span class="keyword">func</span> == <span class="title">nullptr</span>) <span class="title">return</span> 0;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">func</span><span class="params">(a, b)</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">exec</span><span class="params">(1, 2, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a + b;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值捕获与引用捕获</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">auto <span class="function"><span class="keyword">func</span> = [&amp;<span class="title">a</span>, <span class="title">b</span>]</span> &#123;</span><br><span class="line">    <span class="comment">// a是引用捕获， b是值捕获</span></span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutable</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">auto func2 = [c]() mutable &#123;</span><br><span class="line">    c += <span class="number">1</span>; <span class="comment">// c是11</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl; <span class="comment">//c为10</span></span><br></pre></td></tr></table></figure>
<p>Lambda表达式。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="auto-ptr-已经废弃"><a href="#auto-ptr-已经废弃" class="headerlink" title="auto_ptr(已经废弃)"></a>auto_ptr(已经废弃)</h3><figure class="highlight pony"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    auto_ptr&lt;<span class="type">Person</span>&gt; p(<span class="function"><span class="keyword">new</span> <span class="title">Person</span>(<span class="number">1</span>));</span></span><br><span class="line"><span class="function">    <span class="title">p</span>-&gt;<span class="title">show</span>();</span></span><br><span class="line"><span class="function">&#125; <span class="comment">// 不需要调用delete函数</span></span></span><br></pre></td></tr></table></figure>
<p>自实现：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SP</span> </span>&#123;</span><br><span class="line">    T *mPointer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SP(T *pointer) :mPointer(pointer) &#123;&#125;</span><br><span class="line">    ~SP() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPointer == nullptr) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 指针销毁， 释放对象</span></span><br><span class="line">        delete mPointer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -&gt;运算符重载</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> mPointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>auto_ptr不支持数组：<br><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">auto_ptr&lt;<span class="keyword">Person</span><span class="comment">[]</span>&gt; p(new <span class="keyword">Person</span><span class="comment">[3]</span>&#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>多个shared_ptr可以指向同一个对象，当最后一个shared_ptr在作用域范围内结束时，对象才会被自动释放。<br>原理：<br>一个shared_ptr会对一个对象产生强引用(strong reference)。每个对象都有个与之对应的强引用计数，记录着当前对象被多少个shared_ptr强引用着，可以通过shared_ptr的use_count函数获得强引用计数。当有一个新的shared_ptr指向对象时，对象的强引用计数就会+1，当有一个shared_ptr销毁时(比如作用域结束)，对象的强引用计数就会-1，当一个对象的强引用计数为0时(没有任何shared_ptr指向对象时)，对象就会自动销毁(析构)。</p>
<p>可以支持数组：<br><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">Person</span><span class="comment">[]</span>&gt; ptr(new <span class="keyword">Person</span><span class="comment">[5]</span>&#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以多个指针：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">shared_ptr&lt;Person&gt; </span>ptr(new Person(<span class="number">2</span>))<span class="comment">;</span></span><br><span class="line"><span class="keyword">shared_ptr&lt;Person&gt; </span>ptr2 = ptr<span class="comment">;</span></span><br><span class="line"><span class="keyword">shared_ptr&lt;Person&gt; </span>ptr3 = ptr<span class="comment">;</span></span><br><span class="line">cout &lt;&lt; ptr.use_count &lt;&lt; endl<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p> weak_ptr会对一个对象产生弱引用，可以指向对象解决shared_ptr的循环引用问题。<br> 循环引用问题：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Person&gt; mPerson;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Car&gt; mCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Person&gt; per(<span class="keyword">new</span> Person());</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Car&gt; car(<span class="keyword">new</span> Car());</span><br><span class="line">per-&gt;mCar = car;</span><br><span class="line">car-&gt;mPer = per;</span><br></pre></td></tr></table></figure></p>
<p>解决循环引用：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Car</span> &#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">    weak_ptr&lt;Person&gt; mPerson;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Person</span> &#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">    shared_ptr&lt;Car&gt; mCar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr也会对一个对象产生强引用，它可以确保同一时间只有1个指针指向对象当unique_ptr销毁时(作用域结束时)，其指向的对象也就自动销毁了。可以使用<code>std::move</code>函数转移unique_ptr的所有权。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Person&gt; ptr1(<span class="keyword">new</span> Person());</span><br><span class="line"><span class="comment">// 转移</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;person&gt; ptr2 = <span class="built_in">std</span>::move(ptr1);</span><br></pre></td></tr></table></figure></p>
<h1 id="二、其他"><a href="#二、其他" class="headerlink" title="二、其他"></a>二、其他</h1><h2 id="函数调用的流程"><a href="#函数调用的流程" class="headerlink" title="函数调用的流程"></a>函数调用的流程</h2><p>创建函数栈空间后，全部填充0xCCCCCCCC，即中断指令。起到断点的作用。<br>函数调用是有时间和空间开销的(递归效率低下)。<br>程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。</p>
<h2 id="变量地址"><a href="#变量地址" class="headerlink" title="变量地址"></a>变量地址</h2><p>每一个字节都有自己的内存地址。一个变量的地址值，是它所有字节地址中的最小的那个地址值。CPU大小端模式，大多数是小端，即地址值低的位置优先（存储）读，高字节放高地址，低字节放低地址。</p>
<p>例：4个字节存储int类型的整数3：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>进制： <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span>H</span><br><span class="line"><span class="number">2</span>进制： <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span></span><br></pre></td></tr></table></figure></p>
<p>例：<code>int age = 9;</code>的存储实现：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// age地址是0x0113FD40</span></span><br><span class="line">int age = <span class="number">9</span>; </span><br><span class="line"><span class="number">0x0113FD40</span>  <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> cc cc cc </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从低到高吞并4个字节 由于是小端，则从右向左读取</span></span><br><span class="line"><span class="number">0x0113FD40</span>  <span class="number">09</span></span><br><span class="line"><span class="number">0x0113FD41</span>  <span class="number">00</span></span><br><span class="line"><span class="number">0x0113FD42</span>  <span class="number">00</span></span><br><span class="line"><span class="number">0x0113FD43</span>  <span class="number">00</span></span><br></pre></td></tr></table></figure>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>x64汇编兼容x86汇编<br>64位，一个寄存器存8个字节。32位，一个寄存器存4个字节。</p>
<p>64位<br>RAX\RBX\RCX\RDX 通用寄存器<br>32位<br>EAX\EBX\ECX\EDX 通用寄存器</p>
<p>RAX的低4个字节就是EAX。EAX的低2个字节就是AX。AX的低1个字节就是AL，AX的高1个字节就是AH。</p>
<h2 id="c-嵌入汇编"><a href="#c-嵌入汇编" class="headerlink" title="c++嵌入汇编"></a>c++嵌入汇编</h2><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">__asm &#123;</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">8</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">12345678H</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mov dest, src</code>：将src的内容赋值给dest，类似于dest = src。</p>
<p>[地址值] 中括号[ ]里面放的都是内存地址。word是2字节，dword是4字节(double word)，qword是8字节(quad word) 。</p>
<p><code>mov eax, dword ptr [1234h]</code>：从1234h开始取出4个字节（往高字节）的内容给eax寄存器。</p>
<p><code>mov [1234h], 6</code>：表示把6赋值到<code>1234h</code>地址所在的内存空间。</p>
<p><code>call 函数地址</code>：调用函数。</p>
<p><code>lea dest, [地址值]</code>：将地址值赋值给dest，类似于dest = 地址值。</p>
<p><code>ret</code>：函数返回。</p>
<p><code>xor op1, op2</code>：将op1和op2异或的结果赋值给op1，类似于op1 = op1 ^ op2。</p>
<p><code>add op1, op2</code>：类似于op1 = op1 + op2。</p>
<p><code>sub op1, op2</code>：类似于op1 = op1 - op2。</p>
<p><code>inc op</code>：自增，类似于op = op + 1。</p>
<p><code>dec op</code>：自减，类似于op = op – 1。</p>
<p><code>jmp 内存地址</code>：跳转到某个内存地址去执行代码。j开头的一般都是跳转，大多数是带条件的跳转，一般跟test、cmp等指令配合使用。</p>
<p>eax一般存储函数返回值。jne不相等跳转。je相等跳转。<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">8</span><span class="comment">;</span></span><br><span class="line">012E18C8  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>],<span class="number">8</span>  </span><br><span class="line"><span class="keyword">int</span> n = m<span class="comment">;</span></span><br><span class="line">012E18CF  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>]  </span><br><span class="line">012E18D2  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">14h</span>],<span class="built_in">eax</span></span><br></pre></td></tr></table></figure></p>
<h2 id="C语言中模拟面向对象"><a href="#C语言中模拟面向对象" class="headerlink" title="C语言中模拟面向对象"></a>C语言中模拟面向对象</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"func show\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 方法（指向函数的指针）</span></span><br><span class="line">    <span class="keyword">void</span> (*show)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span></span><br><span class="line">    stu.age = <span class="number">10</span>;</span><br><span class="line">    stu.show = show;</span><br><span class="line">    stu.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="声明与实现分离"><a href="#声明与实现分离" class="headerlink" title="声明与实现分离"></a>声明与实现分离</h2><p>头文件<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">    Person();</span><br><span class="line">    ~Person();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>实现文件<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Person::setAge(<span class="keyword">int</span> age) &#123;</span><br><span class="line">    mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> mAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::Person() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::~Person() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="string的使用"><a href="#string的使用" class="headerlink" title="string的使用"></a>string的使用</h2><p>前提:<code>#include &lt;string&gt;</code></p>
<p>1.输入输出</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">string s<span class="comment">;</span></span><br><span class="line">cin &gt;&gt; s<span class="comment">;</span></span><br><span class="line">cou &lt;&lt; s &lt;&lt; endl<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>2.通过下标访问<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span> s = <span class="string">"qwert"</span>;</span><br><span class="line">s[<span class="number">3</span>] = 'd';</span><br><span class="line">couy &lt;&lt; s[<span class="number">2</span>];</span><br></pre></td></tr></table></figure></p>
<p>3.拼接<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">"i"</span><span class="comment">;</span></span><br><span class="line">char *<span class="built_in">s1</span> = <span class="string">"love"</span><span class="comment">;</span></span><br><span class="line">char <span class="built_in">s2</span>[] = <span class="string">"you"</span><span class="comment">;</span></span><br><span class="line">char <span class="built_in">s3</span> = <span class="string">'!'</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">string rs = s + <span class="built_in">s1</span> + <span class="built_in">s2</span> + <span class="built_in">s3</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>4.插入<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span> s = <span class="string">"sdf"</span>;</span><br><span class="line">s.insert(<span class="number">1</span>,<span class="string">"sds"</span>); <span class="comment">// 索引/内容</span></span><br></pre></td></tr></table></figure></p>
<p>5.删除<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">s1</span> = <span class="built_in">s2</span> = <span class="built_in">s3</span> = <span class="string">"1234567890"</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">s2</span>.erase(<span class="number">5</span>)<span class="comment">;</span></span><br><span class="line"><span class="built_in">s3</span>.erase(<span class="number">5</span>, <span class="number">3</span>)<span class="comment">; // 长度为3</span></span><br></pre></td></tr></table></figure></p>
<p>6.提取</p>
<p><code>s1.substr(6, 6); // 长度为6</code></p>
<p>7.查找</p>
<p><code>s.find(&quot;,&quot;,1); // 从索引1开始查找逗号,返回索引</code></p>
<h2 id="C-中的单例"><a href="#C-中的单例" class="headerlink" title="C++中的单例"></a>C++中的单例</h2><p>1.构造函数、拷贝构造函数以及析构函数私有。<br>2.定义一个私有的static静态成员变量。<br>3.提供公开访问接口。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="keyword">App</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    static <span class="keyword">App</span> *sharedApp() &#123;</span><br><span class="line">        <span class="comment">// 考虑加锁...</span></span><br><span class="line">        <span class="keyword">if</span> (gApp == NULL) &#123;</span><br><span class="line">            gApp = new <span class="keyword">App</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑解锁...</span></span><br><span class="line">        <span class="keyword">return</span> gApp;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="keyword">App</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">App</span>(<span class="keyword">const</span> <span class="keyword">App</span> &amp;<span class="keyword">app</span>) &#123;&#125;</span><br><span class="line">    ~<span class="keyword">App</span>() &#123;&#125;</span><br><span class="line">    static <span class="keyword">App</span>*gApp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">App</span> *<span class="keyword">App</span>::gApp = NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建单例</span></span><br><span class="line"><span class="keyword">App</span> *<span class="keyword">app</span> = <span class="keyword">App</span>::sharedApp();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考博客：<br><a href="http://c.biancheng.net/cpp/biancheng/cpp/rumen/" target="_blank" rel="noopener">C语言中文网</a></p>
</blockquote>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/C/">C++</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/04/05/读《Effective Objective-C 2.0》/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">读《Effective Objective-C 2.0》</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2017/03/05/排序算法实现/">
        <span class="next-text nav-default">排序算法实现</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
