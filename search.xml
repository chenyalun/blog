<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读「YYCache」]]></title>
    <url>%2F2019%2F01%2F02%2F%E8%AF%BB%E3%80%8CYYCache%E3%80%8D%2F</url>
    <content type="text"><![CDATA[关于YYCache的简单总结。 阅读YYCache源码有3遍了，自我感觉“需要理解”的部分掌握的差不多了，做个记录。 使用API 类似字典，比较容易理解。 初始化@property (copy, readonly) NSString *name;@property (strong, readonly) YYMemoryCache *memoryCache;@property (strong, readonly) YYDiskCache *diskCache;- (nullable instancetype)initWithName:(NSString *)name;- (nullable instancetype)initWithPath:(NSString *)path NS_DESIGNATED_INITIALIZER;+ (nullable instancetype)cacheWithName:(NSString *)name;+ (nullable instancetype)cacheWithPath:(NSString *)path;- (instancetype)init UNAVAILABLE_ATTRIBUTE;+ (instancetype)new UNAVAILABLE_ATTRIBUTE; 是否存在- (BOOL)containsObjectForKey:(NSString *)key;- (void)containsObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, BOOL contains))block; 查询- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;- (void)objectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, id&lt;NSCoding&gt; object))block; 设值- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(nullable void(^)(void))block; 移除- (void)removeObjectForKey:(NSString *)key;- (void)removeObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key))block;- (void)removeAllObjects;- (void)removeAllObjectsWithBlock:(void(^)(void))block;- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end; YYCache 实现@implementation YYCache- (instancetype) init &#123; NSLog(@"Use \"initWithName\" or \"initWithPath\" to create YYCache instance."); return [self initWithPath:@""];&#125;- (instancetype)initWithName:(NSString *)name &#123; if (name.length == 0) return nil; NSString *cacheFolder = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]; NSString *path = [cacheFolder stringByAppendingPathComponent:name]; return [self initWithPath:path];&#125;- (instancetype)initWithPath:(NSString *)path &#123; if (path.length == 0) return nil; YYDiskCache *diskCache = [[YYDiskCache alloc] initWithPath:path]; if (!diskCache) return nil; NSString *name = [path lastPathComponent]; YYMemoryCache *memoryCache = [YYMemoryCache new]; memoryCache.name = name; self = [super init]; _name = name; _diskCache = diskCache; _memoryCache = memoryCache; return self;&#125;+ (instancetype)cacheWithName:(NSString *)name &#123; return [[self alloc] initWithName:name];&#125;+ (instancetype)cacheWithPath:(NSString *)path &#123; return [[self alloc] initWithPath:path];&#125;- (BOOL)containsObjectForKey:(NSString *)key &#123; return [_memoryCache containsObjectForKey:key] || [_diskCache containsObjectForKey:key];&#125;- (void)containsObjectForKey:(NSString *)key withBlock:(void (^)(NSString *key, BOOL contains))block &#123; if (!block) return; if ([_memoryCache containsObjectForKey:key]) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; block(key, YES); &#125;); &#125; else &#123; [_diskCache containsObjectForKey:key withBlock:block]; &#125;&#125;- (id&lt;NSCoding&gt;)objectForKey:(NSString *)key &#123; id&lt;NSCoding&gt; object = [_memoryCache objectForKey:key]; if (!object) &#123; object = [_diskCache objectForKey:key]; if (object) &#123; [_memoryCache setObject:object forKey:key]; &#125; &#125; return object;&#125;- (void)objectForKey:(NSString *)key withBlock:(void (^)(NSString *key, id&lt;NSCoding&gt; object))block &#123; if (!block) return; id&lt;NSCoding&gt; object = [_memoryCache objectForKey:key]; if (object) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; block(key, object); &#125;); &#125; else &#123; [_diskCache objectForKey:key withBlock:^(NSString *key, id&lt;NSCoding&gt; object) &#123; if (object &amp;&amp; ![_memoryCache objectForKey:key]) &#123; [_memoryCache setObject:object forKey:key]; &#125; block(key, object); &#125;]; &#125;&#125;- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key &#123; [_memoryCache setObject:object forKey:key]; [_diskCache setObject:object forKey:key];&#125;- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(void (^)(void))block &#123; [_memoryCache setObject:object forKey:key]; [_diskCache setObject:object forKey:key withBlock:block];&#125;- (void)removeObjectForKey:(NSString *)key &#123; [_memoryCache removeObjectForKey:key]; [_diskCache removeObjectForKey:key];&#125;- (void)removeObjectForKey:(NSString *)key withBlock:(void (^)(NSString *key))block &#123; [_memoryCache removeObjectForKey:key]; [_diskCache removeObjectForKey:key withBlock:block];&#125;- (void)removeAllObjects &#123; [_memoryCache removeAllObjects]; [_diskCache removeAllObjects];&#125;- (void)removeAllObjectsWithBlock:(void(^)(void))block &#123; [_memoryCache removeAllObjects]; [_diskCache removeAllObjectsWithBlock:block];&#125;- (void)removeAllObjectsWithProgressBlock:(void(^)(int removedCount, int totalCount))progress endBlock:(void(^)(BOOL error))end &#123; [_memoryCache removeAllObjects]; [_diskCache removeAllObjectsWithProgressBlock:progress endBlock:end]; &#125;- (NSString *)description &#123; if (_name) return [NSString stringWithFormat:@"&lt;%@: %p&gt; (%@)", self.class, self, _name]; else return [NSString stringWithFormat:@"&lt;%@: %p&gt;", self.class, self];&#125;@end 整体来看还是比较容易理解的，YYCache 整合了内存缓存和磁盘缓存，主要做了这些事： 初始化YYCache实例，要求缓存路径要合理。 查询缓存对象先从内存缓存中查找，如果没有，再从磁盘缓存中查找。当磁盘缓存中有而内存缓存中没有的时候，把取得的缓存对象保存在内存缓存中。 缓存对象的存取和移除，内存缓存和磁盘缓存两者保持同步。 YYMemoryCache 实现基本属性@property (nullable, copy) NSString *name;@property (readonly) NSUInteger totalCount;@property (readonly) NSUInteger totalCost;#pragma mark - Limit@property NSUInteger countLimit;@property NSUInteger costLimit;@property NSTimeInterval ageLimit;@property NSTimeInterval autoTrimInterval;@property BOOL shouldRemoveAllObjectsOnMemoryWarning;@property BOOL shouldRemoveAllObjectsWhenEnteringBackground;@property (nullable, copy) void(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);@property (nullable, copy) void(^didEnterBackgroundBlock)(YYMemoryCache *cache);@property BOOL releaseOnMainThread;@property BOOL releaseAsynchronously; 类似于NSCache，提供包括缓存数量、缓存花费、缓存时间的管理。除此之外，当接收到内存警告时(shouldRemoveAllObjectsOnMemoryWarning)或者 App 进入到后台时(shouldRemoveAllObjectsWhenEnteringBackground)可以选择释放缓存对象。而对缓存对象释放也可以进行控制，比如可以选择在主线程释放(releaseOnMainThread)或者异步释放(releaseAsynchronously)。 存取接口- (BOOL)containsObjectForKey:(id)key;- (nullable id)objectForKey:(id)key;- (void)setObject:(nullable id)object forKey:(id)key;- (void)setObject:(nullable id)object forKey:(id)key withCost:(NSUInteger)cost;- (void)removeObjectForKey:(id)key;- (void)removeAllObjects;- (void)trimToCount:(NSUInteger)count;- (void)trimToCost:(NSUInteger)cost;- (void)trimToAge:(NSTimeInterval)age; 除了基本的存取方法之外，YYMemoryCache 还暴露了三个移除缓存对象的方法。 trimToCount：根据限制的数量(countLimit)进行移除缓存对象操作，直到满足数量限制要求。 trimToCost：根据限制的花费(costLimit)进行移除缓存对象操作，直到满足花费限制要求。 trimToAge：根据缓存对象的过期时间(ageLimit)进行移除缓存对象操作，直到满足要求。 具体实现在具体实现中，作者考虑了以下要求: 缓存对象的存取。要保证效率就要求存取时间复杂度最好是O(1)。 缓存对象的移除。要保证能按照 cost、age、count 等条件对所有不符合要求的对象进行移除。 线程安全。需要加锁。第一条：要求时间复杂度是 O(1)，那就可以采用哈希表、字典等。作者使用了字典，且是效率更高的CFMutableDictionaryRef。第二条：记录 cost、age、count等属性，肯定需要对缓存对象进行包装。再者需要考虑LRU(Least Recently Used)，就需要保证顺序。而要使得字典中的对象(value)有顺序，必须有一个指向其他对象的指针(属性）。可以使用双向链表包装缓存对象。第三条：存取的线程安全，使用GCD线程锁。 结点@interface _YYLinkedMapNode : NSObject &#123; @package __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic id _key; id _value; NSUInteger _cost; NSTimeInterval _time;&#125;@end 链表的结点中保存着key 和 value，这是对缓存对象的包装。_cost和_time记录着缓存对象的花费和过期时间。而使用unsafe_unretained修饰的_prev和_next则分别指向前一个对象和后一个对象。由于这些结点已经被字典持有了，所以直接使用unsafe_unretained修饰，不必再增加它的引用计数，提高效率。 链表 @interface _YYLinkedMap : NSObject &#123; @package CFMutableDictionaryRef _dic; // do not set object directly NSUInteger _totalCost; NSUInteger _totalCount; _YYLinkedMapNode *_head; // MRU, do not change it directly _YYLinkedMapNode *_tail; // LRU, do not change it directly BOOL _releaseOnMainThread; BOOL _releaseAsynchronously;&#125;- (void)insertNodeAtHead:(_YYLinkedMapNode *)node;- (void)bringNodeToHead:(_YYLinkedMapNode *)node;- (void)removeNode:(_YYLinkedMapNode *)node;- (_YYLinkedMapNode *)removeTailNode;- (void)removeAll;@end 一个 YYMemoryCache 对象有一个链表。这个链表使用_dic保存着所有包装好的缓存对象(_YYLinkedMapNode)，记录着总的花费(_totalCost)和总的数量(_totalCount)。当然，还使用_head指着链表的头指针，使用_tail指着链表的尾指针。_releaseOnMainThread和_releaseAsynchronously用于设置对缓存对象释放操作的选项:主线程释放或者异步释放。 _YYLinkedMap暴露出的五个方法很清晰地表明它的作用：每次当缓存取到某个对象时，把它置在头结点的位置。这样随着时间的推移，很轻松地使得那些不经常使用的对象处在链表的后端，经常使用的对象处在链表的前端，这样就实现了 LRU。 操作- (void)insertNodeAtHead:(_YYLinkedMapNode *)node &#123; CFDictionarySetValue(_dic, (__bridge const void *)(node-&gt;_key), (__bridge const void *)(node)); _totalCost += node-&gt;_cost; _totalCount++; if (_head) &#123; node-&gt;_next = _head; _head-&gt;_prev = node; _head = node; &#125; else &#123; _head = _tail = node; &#125;&#125;- (void)bringNodeToHead:(_YYLinkedMapNode *)node &#123; if (_head == node) return; if (_tail == node) &#123; _tail = node-&gt;_prev; _tail-&gt;_next = nil; &#125; else &#123; node-&gt;_next-&gt;_prev = node-&gt;_prev; node-&gt;_prev-&gt;_next = node-&gt;_next; &#125; node-&gt;_next = _head; node-&gt;_prev = nil; _head-&gt;_prev = node; _head = node;&#125;- (void)removeNode:(_YYLinkedMapNode *)node &#123; CFDictionaryRemoveValue(_dic, (__bridge const void *)(node-&gt;_key)); _totalCost -= node-&gt;_cost; _totalCount--; if (node-&gt;_next) node-&gt;_next-&gt;_prev = node-&gt;_prev; if (node-&gt;_prev) node-&gt;_prev-&gt;_next = node-&gt;_next; if (_head == node) _head = node-&gt;_next; if (_tail == node) _tail = node-&gt;_prev;&#125;- (_YYLinkedMapNode *)removeTailNode &#123; if (!_tail) return nil; _YYLinkedMapNode *tail = _tail; CFDictionaryRemoveValue(_dic, (__bridge const void *)(_tail-&gt;_key)); _totalCost -= _tail-&gt;_cost; _totalCount--; if (_head == _tail) &#123; _head = _tail = nil; &#125; else &#123; _tail = _tail-&gt;_prev; _tail-&gt;_next = nil; &#125; return tail;&#125; 对结点的插入、移除、调整位置，是数据结构的基础操作。令人怀念！ _releaseOnMainThread和_releaseAsynchronously这两个选项的实现也很简单。作者自己维护了一个队列: static inline dispatch_queue_t YYMemoryCacheGetReleaseQueue() &#123; return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);&#125; 移除的时候有所判断： CFMutableDictionaryRef holder = _dic; _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); if (_releaseAsynchronously) &#123; dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; CFRelease(holder); // hold and release in specified queue &#125;); &#125; else if (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; CFRelease(holder); // hold and release in specified queue &#125;); &#125; else &#123; CFRelease(holder); &#125; 要求异步要求主线程：那就在主线程异步释放holder。关于这里使用一个holder的原因，下文有解释。 核心操作@implementation YYMemoryCache &#123; pthread_mutex_t _lock; _YYLinkedMap *_lru; dispatch_queue_t _queue;&#125; 从这里可以看出YYMemoryCache使用pthread_mutex_t保证线程安全。 最关键的还是对无效缓存对象的释放，以 count 为例，当缓存的对象数量超过了 count 限制，就需要对链表后端不常使用的缓存对象进行移除操作，直到满足 count 限制。 - (void)_trimToCount:(NSUInteger)countLimit &#123; BOOL finish = NO; pthread_mutex_lock(&amp;_lock); if (countLimit == 0) &#123; [_lru removeAll]; finish = YES; &#125; else if (_lru-&gt;_totalCount &lt;= countLimit) &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); if (finish) return; NSMutableArray *holder = [NSMutableArray new]; while (!finish) &#123; if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; if (_lru-&gt;_totalCount &gt; countLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (node) [holder addObject:node]; &#125; else &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); &#125; else &#123; usleep(10 * 1000); //10 ms &#125; &#125; if (holder.count) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [holder count]; // release in queue &#125;); &#125;&#125; 这个方法做了什么？ 使用pthread_mutex_lock(&amp;_lock);pthread_mutex_unlock(&amp;_lock);对操作加锁解锁来保证线程安全。 对参数 countLimit 判断：如果countLimit为0，也就是说缓存数量限制为0，那移除所有缓存对象就是了。如果当前所缓存的对象数量小于countLimit，那说明满足数量限制要求，就不需要移除操作了。 作者创建一个可变字典holder，当不满足countLimit限制要求的时候，对链表尾结点进行移除操作，并把这个尾结点添加到holder中持有。当然，这里有加锁操作。这个 while 循环结束，所有多余的缓存对象就在holder中了。4.对holder中所有元素进行 release 操作。其他的如: - (void)_trimToAge:(NSTimeInterval)ageLimit; - (void)_trimToCost:(NSUInteger)costLimit 操作同理。 内存警告内存警告语 App 进入后台时释放缓存对象的操作，作者接受了系统通知，直接处理即可。 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appDidReceiveMemoryWarningNotification) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appDidEnterBackgroundNotification) name:UIApplicationDidEnterBackgroundNotification object:nil]; 存取实现- (BOOL)containsObjectForKey:(id)key &#123; if (!key) return NO; pthread_mutex_lock(&amp;_lock); BOOL contains = CFDictionaryContainsKey(_lru-&gt;_dic, (__bridge const void *)(key)); pthread_mutex_unlock(&amp;_lock); return contains;&#125;- (id)objectForKey:(id)key &#123; if (!key) return nil; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; node-&gt;_time = CACurrentMediaTime(); [_lru bringNodeToHead:node]; &#125; pthread_mutex_unlock(&amp;_lock); return node ? node-&gt;_value : nil;&#125;- (void)setObject:(id)object forKey:(id)key &#123; [self setObject:object forKey:key withCost:0];&#125; 对缓存对象的读取自然是根据 key 读取到字典中对应的 value，这个 value 是个结点(_YYLinkedMapNode)，再取出这个结点的value 属性，便是最原始的缓存对象了:node-&gt;_value。 YYMemoryCache关键点1.字典 声明: CFMutableDictionaryRef _dic;创建: _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);设值: CFDictionarySetValue(_dic, (__bridge const void *)(node-&gt;_key), (__bridge const void *)(node));取值: CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key));移除: CFDictionaryRemoveValue(_dic, (__bridge const void *)(node-&gt;_key));获取数量: CFDictionaryGetCount(_dic);是否存在: CFDictionaryContainsKey(_lru-&gt;_dic, (__bridge const void *)(key));释放: CFRelease(_dic); 2.容器中对象销毁控制 “对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去…” - (void)demo &#123;// 对象销毁和移除容器中元素两件事隔离开&#123; // 数组中的所有元素在子线程释放 NSArray *holder = tmp; tmp = [NSMutableArray array]; if (holder.count &gt; 0) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [holder count]; &#125;); &#125;&#125; &#123; // 数组中的某个元素在子线程释放 id obj = tmp[2]; NSMutableArray *holder = [NSMutableArray array]; [holder addObject:obj]; [tmp removeObject:obj]; if (holder.count &gt; 0) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [holder count]; &#125;); &#125;&#125;&#125; 3.线程安全的实现 &#123; // 取值线程安全pthread_mutex_lock(&amp;_lock);BOOL releaseAsynchronously = _lru-&gt;_releaseAsynchronously;pthread_mutex_unlock(&amp;_lock);return releaseAsynchronously;&#125;&#123; // 设值线程安全pthread_mutex_lock(&amp;_lock);_lru-&gt;_releaseAsynchronously = releaseAsynchronously;pthread_mutex_unlock(&amp;_lock);&#125; 4.pthread_mutex_lock使用 声明锁: pthread_mutex_t _lock;创建锁: pthread_mutex_init(&amp;_lock, NULL);加锁: pthread_mutex_lock(&amp;_lock);解锁: pthread_mutex_unlock(&amp;_lock);尝试加锁:if (pthread_mutex_trylock(&amp;_lock) == 0) &#123;pthread_mutex_unlock(&amp;_lock);&#125; else &#123;usleep(10 * 1000); //10 ms&#125;销毁锁: pthread_mutex_destroy(&amp;_lock); 5.if-else 单句 if (_name) return nil;else return nil; YYDiskCache 实现YYDiskCache主要调用了YYKVStorage的接口，并提供对外 API。 五个函数/// Free disk space in bytes.static int64_t _YYDiskSpaceFree() &#123; NSError *error = nil; NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error]; if (error) return -1; int64_t space = [[attrs objectForKey:NSFileSystemFreeSize] longLongValue]; if (space &lt; 0) space = -1; return space;&#125;/// String's md5 hash.static NSString *_YYNSStringMD5(NSString *string) &#123; if (!string) return nil; NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(data.bytes, (CC_LONG)data.length, result); return [NSString stringWithFormat: @"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7], result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15] ];&#125;static void _YYDiskCacheInitGlobal() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _globalInstancesLock = dispatch_semaphore_create(1); _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; &#125;);&#125;static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123; if (path.length == 0) return nil; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); id cache = [_globalInstances objectForKey:path]; dispatch_semaphore_signal(_globalInstancesLock); return cache;&#125;static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123; if (cache.path.length == 0) return; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); [_globalInstances setObject:cache forKey:cache.path]; dispatch_semaphore_signal(_globalInstancesLock);&#125; _YYDiskSpaceFree()提供剩余磁盘空间的查询。_YYNSStringMD5(NSString *string)提供字符串转 md5。 _YYDiskCacheInitGlobal()用于初始化一个强-弱的NSMapTable，保存YYDiskCache对象。_YYDiskCacheGetGlobal(NSString *path)用于根据路径 path 获取对应的YYDiskCache对象。_YYDiskCacheSetGlobal(YYDiskCache *cache)用于根据路径 path 在NSMapTable保存一个YYDiskCache对象。 主要实现YYDiskCache的功能比如移除过期的对象、移除超过数量限制的对象等，主要通过YYKVStorage实现。作者把保存类型分为三种： typedef NS_ENUM(NSUInteger, YYKVStorageType) &#123; /// file system. YYKVStorageTypeFile = 0, /// in sqlite. YYKVStorageTypeSQLite = 1, /// based on your choice. YYKVStorageTypeMixed = 2,&#125;; 作者指明了原因：Typically, write data to sqlite is faster than extern file, but reading performance is dependent on data size. In my test (on iPhone 6 64G), read data from extern file is faster than from sqlite when the data is larger than 20KB. If you want to store large number of small datas (such as contacts cache),use YYKVStorageTypeSQLite to get better performance. If you want to store large files (such as image cache),use YYKVStorageTypeFile to get better performance. You can use YYKVStorageTypeMixed and choice your storage type for each item. 20kb 以下的持久化，放到文件中。 20kb 以上的持久化，放到数据库sqlite中。也可以选择混合存储。 关键点1.弱引用+强引用 __weak typeof(self) _self = self;dispatch_async(_queue, ^&#123; __strong typeof(_self) self = _self; BOOL contains = [self containsObjectForKey:key];// self 应该是局部变量&#125;); 2, 快速生成时间戳(10位数) long timestamp = time(NULL); 3.init构造&#123; self = [super init]; if (!self) return nil; //.... return self;&#125; 抛出异常 @throw [NSException exceptionWithName:@"name" reason:@"YYDiskCache must be initialized with a path. Use 'initWithPath:' or 'initWithPath:inlineThreshold:' instead." userInfo:nil]; 5.尝试捕获异常@try &#123; object = [NSKeyedUnarchiver unarchiveObjectWithData:item.value];&#125;@catch (NSException *exception) &#123; // nothing to do...&#125; YYKVStorageYYKVStorage没有阅读。乍一看是许多琐碎的 SQL 操作和文件操作，没有纳入阅读计划。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读「YYModel」]]></title>
    <url>%2F2018%2F12%2F20%2F%E8%AF%BB%E3%80%8CYYModel%E3%80%8D%2F</url>
    <content type="text"><![CDATA[关于YYModel的简单总结。 尝试阅读YYModel源码，发现有一些细节并不能十分透彻地理解清楚，只能略微窥探到其中主要原理。这里就当做第一遍阅读笔记😂😂😂。 使用分类@interface NSObject (YYModel)+ (nullable instancetype)yy_modelWithJSON:(id)json;+ (nullable instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary;- (BOOL)yy_modelSetWithJSON:(id)json;- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic;- (nullable id)yy_modelToJSONObject;- (nullable NSData *)yy_modelToJSONData;- (nullable NSString *)yy_modelToJSONString;// 自定义- (nullable id)yy_modelCopy;- (void)yy_modelEncodeWithCoder:(NSCoder *)aCoder;- (id)yy_modelInitWithCoder:(NSCoder *)aDecoder;- (NSUInteger)yy_modelHash;- (BOOL)yy_modelIsEqual:(id)model;- (NSString *)yy_modelDescription;@end@interface NSArray (YYModel)// json到模型数组+ (nullable NSArray *)yy_modelArrayWithClass:(Class)cls json:(id)json;@end@interface NSDictionary (YYModel)// json到字典+ (nullable NSDictionary *)yy_modelDictionaryWithClass:(Class)cls json:(id)json;@end 拓展@protocol YYModel &lt;NSObject&gt;@optional// 自定义模型属性与json's key的映射+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelCustomPropertyMapper;+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123; @"name" : @"n", @"count" : @"ext.c", @"desc1" : @"ext.d", @"desc4" : @".ext", @"modelID" : @[@"ID", @"Id", @"id", @"ext.id"]&#125;;&#125;// 黑名单, 若实现该方法, 黑名单之内的key均不作处理+ (nullable NSArray&lt;NSString *&gt; *)modelPropertyBlacklist;+ (NSArray *)modelPropertyBlacklist &#123; return @[@"name", @"age"];&#125;// 白名单, 若实现该方法, 白名单之外的key均不作处理+ (nullable NSArray&lt;NSString *&gt; *)modelPropertyWhitelist;+ (NSArray *)modelPropertyWhitelist &#123; return @[@"name"];&#125;// 1.要在JSON转Model的过程中根据情况创建不同类型的实例+ (nullable Class)modelCustomClassForDictionary:(NSDictionary *)dictionary;+ (Class)modelCustomClassForDictionary:(NSDictionary*)dictionary &#123; if (dictionary[@"localName"]) &#123; return [YYLocalUser class]; &#125; else if (dictionary[@"remoteName"]) &#123; return [YYRemoteUser class]; &#125; return [YYBaseUser class];&#125;// 2.该方法发生在字典转模型之前, 最后对字典做一次处理- (NSDictionary *)modelCustomWillTransformFromDictionary:(NSDictionary *)dic;//- (NSDictionary *)modelCustomWillTransformFromDictionary:(NSDictionary *)dic&#123; if ([dic[@"sex"] isEqualToString:@"Man"]) &#123; return nil; &#125; return dic;&#125;// 3.JSON转为Model后, 进行数据校验- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic;- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic &#123; NSNumber *timestamp = dic[@"timestamp"]; if (![timestamp isKindOfClass:[NSNumber class]]) return NO; _createdAt = [NSDate dateWithTimeIntervalSince1970:timestamp.floatValue]; return YES;&#125;// 模型容器属性中的所需要存放的数据类型+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelContainerPropertyGenericClass;+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@"shadows" : [Shadow class], @"borders" : Border.class, @"attachments" : @"Attachment" &#125;;&#125;// Model转为JSON后, 进行数据校验- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic;- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic &#123; if (!_createdAt) return NO; dic[@"timestamp"] = @(_createdAt.timeIntervalSince1970); return YES;&#125;@end 函数// 函数1: 根据class信息获取其对应的类型static force_inline YYEncodingNSType YYClassGetNSType(Class cls) &#123; if (!cls) return YYEncodingTypeNSUnknown; if ([cls isSubclassOfClass:[NSMutableString class]]) return YYEncodingTypeNSMutableString; if ([cls isSubclassOfClass:[NSString class]]) return YYEncodingTypeNSString; if ([cls isSubclassOfClass:[NSDecimalNumber class]]) return YYEncodingTypeNSDecimalNumber; if ([cls isSubclassOfClass:[NSNumber class]]) return YYEncodingTypeNSNumber; if ([cls isSubclassOfClass:[NSValue class]]) return YYEncodingTypeNSValue; if ([cls isSubclassOfClass:[NSMutableData class]]) return YYEncodingTypeNSMutableData; if ([cls isSubclassOfClass:[NSData class]]) return YYEncodingTypeNSData; if ([cls isSubclassOfClass:[NSDate class]]) return YYEncodingTypeNSDate; if ([cls isSubclassOfClass:[NSURL class]]) return YYEncodingTypeNSURL; if ([cls isSubclassOfClass:[NSMutableArray class]]) return YYEncodingTypeNSMutableArray; if ([cls isSubclassOfClass:[NSArray class]]) return YYEncodingTypeNSArray; if ([cls isSubclassOfClass:[NSMutableDictionary class]]) return YYEncodingTypeNSMutableDictionary; if ([cls isSubclassOfClass:[NSDictionary class]]) return YYEncodingTypeNSDictionary; if ([cls isSubclassOfClass:[NSMutableSet class]]) return YYEncodingTypeNSMutableSet; if ([cls isSubclassOfClass:[NSSet class]]) return YYEncodingTypeNSSet; return YYEncodingTypeNSUnknown;&#125;// 函数2: 判断YYEncodingType是不是一个数字(整形\长整型\浮点型等)static force_inline BOOL YYEncodingTypeIsCNumber(YYEncodingType type) &#123; switch (type &amp; YYEncodingTypeMask) &#123; case YYEncodingTypeBool: case YYEncodingTypeInt8: case YYEncodingTypeUInt8: case YYEncodingTypeInt16: case YYEncodingTypeUInt16: case YYEncodingTypeInt32: case YYEncodingTypeUInt32: case YYEncodingTypeInt64: case YYEncodingTypeUInt64: case YYEncodingTypeFloat: case YYEncodingTypeDouble: case YYEncodingTypeLongDouble: return YES; default: return NO; &#125;&#125;// 函数3: 根据一个id类型的对象创建一个NSNumber类型的对象static force_inline NSNumber *YYNSNumberCreateFromID(__unsafe_unretained id value) &#123; static NSCharacterSet *dot; static NSDictionary *dic; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; dot = [NSCharacterSet characterSetWithRange:NSMakeRange('.', 1)]; dic = @&#123;@"TRUE" : @(YES), @"True" : @(YES), @"true" : @(YES), @"FALSE" : @(NO), @"False" : @(NO), @"false" : @(NO), @"YES" : @(YES), @"Yes" : @(YES), @"yes" : @(YES), @"NO" : @(NO), @"No" : @(NO), @"no" : @(NO), @"NIL" : (id)kCFNull, @"Nil" : (id)kCFNull, @"nil" : (id)kCFNull, @"NULL" : (id)kCFNull, @"Null" : (id)kCFNull, @"null" : (id)kCFNull, @"(NULL)" : (id)kCFNull, @"(Null)" : (id)kCFNull, @"(null)" : (id)kCFNull, @"&lt;NULL&gt;" : (id)kCFNull, @"&lt;Null&gt;" : (id)kCFNull, @"&lt;null&gt;" : (id)kCFNull&#125;; &#125;); // kCFNull单例 if (!value || value == (id)kCFNull) return nil; // NSNumber直接返回 if ([value isKindOfClass:[NSNumber class]]) return value; // NSString, 取出dic中对应的值 if ([value isKindOfClass:[NSString class]]) &#123; NSNumber *num = dic[value]; if (num) &#123; if (num == (id)kCFNull) return nil; return num; &#125; // 这个字符串中含有 ".", 例如 @"12.344" if ([(NSString *)value rangeOfCharacterFromSet:dot].location != NSNotFound) &#123; const char *cstring = ((NSString *)value).UTF8String; if (!cstring) return nil; double num = atof(cstring); // isfinite()测试某个浮点数是不是有限的数 // isinf()测试某个浮点数是否是无限大 // isnan()测试某个浮点数是否是 非数字 if (isnan(num) || isinf(num)) return nil; // num是否是无限大或者是否是非数字 return @(num); // return @(12.344); &#125; else &#123; // 字符串中没有".", 例如 @"1323" const char *cstring = ((NSString *)value).UTF8String;// 转化为C字符串"1323" if (!cstring) return nil; // atoi函数：将字符串转化为int类型变量. atol函数：将字符串转化为long类型变量. // atoll函数：将字符串转化为long long类型变量.atof函数：将字符串转化为double类型变量 return @(atoll(cstring)); // 转换为long long类型变量 &#125; &#125; return nil;&#125;// 函数4: 将字符串转化为日期NSDate// 根据string的length判断需要调用哪一个block, 为了避免效率较低的if-else, 采用block数组的形式, string的length正好对应blocks数组的索引, 即查表法, 效率得到提升.// YYNSDateParseBlock parser = blocks[string.length];static force_inline NSDate *YYNSDateFromString(__unsafe_unretained NSString *string) &#123; typedef NSDate* (^YYNSDateParseBlock)(NSString *string); #define kParserNum 34 // 定义一个block数组, 数组是C数组 static YYNSDateParseBlock blocks[kParserNum + 1] = &#123;0&#125;; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; &#123; /* 2014-01-20 // Google , 10个字符, 对应blocks[10] */ NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter.dateFormat = @"yyyy-MM-dd"; blocks[10] = ^(NSString *string) &#123; return [formatter dateFromString:string]; &#125;; &#125; &#123; /* 2014-01-20 12:24:48 // 19个字符, 对应blocks[19] 2014-01-20T12:24:48 // Google, 19个字符, 对应blocks[19] 2014-01-20 12:24:48.000 // 23个字符, 对应blocks[23] 2014-01-20T12:24:48.000 // 23个字符, 对应blocks[23] */ NSDateFormatter *formatter1 = [[NSDateFormatter alloc] init]; formatter1.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter1.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter1.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss"; NSDateFormatter *formatter2 = [[NSDateFormatter alloc] init]; formatter2.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter2.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter2.dateFormat = @"yyyy-MM-dd HH:mm:ss"; NSDateFormatter *formatter3 = [[NSDateFormatter alloc] init]; formatter3.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter3.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter3.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss.SSS"; NSDateFormatter *formatter4 = [[NSDateFormatter alloc] init]; formatter4.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter4.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter4.dateFormat = @"yyyy-MM-dd HH:mm:ss.SSS"; blocks[19] = ^(NSString *string) &#123; if ([string characterAtIndex:10] == 'T') &#123;// 2014-01-20T12:24:48 return [formatter1 dateFromString:string]; &#125; else &#123;// 2014-01-20 12:24:48 return [formatter2 dateFromString:string]; &#125; &#125;; blocks[23] = ^(NSString *string) &#123; if ([string characterAtIndex:10] == 'T') &#123;// 2014-01-20T12:24:48.000 return [formatter3 dateFromString:string]; &#125; else &#123;// 2014-01-20 12:24:48.000 return [formatter4 dateFromString:string]; &#125; &#125;; &#125; &#123; /* 2014-01-20T12:24:48Z // Github, Apple 2014-01-20T12:24:48+0800 // Facebook 2014-01-20T12:24:48+12:00 // Google 2014-01-20T12:24:48.000Z 2014-01-20T12:24:48.000+0800 2014-01-20T12:24:48.000+12:00 */ NSDateFormatter *formatter = [NSDateFormatter new]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ssZ"; NSDateFormatter *formatter2 = [NSDateFormatter new]; formatter2.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter2.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss.SSSZ"; blocks[20] = ^(NSString *string) &#123; return [formatter dateFromString:string]; &#125;; blocks[24] = ^(NSString *string) &#123; return [formatter dateFromString:string]?: [formatter2 dateFromString:string]; &#125;; blocks[25] = ^(NSString *string) &#123; return [formatter dateFromString:string]; &#125;; blocks[28] = ^(NSString *string) &#123; return [formatter2 dateFromString:string]; &#125;; blocks[29] = ^(NSString *string) &#123; return [formatter2 dateFromString:string]; &#125;; &#125; &#123; /* Fri Sep 04 00:12:21 +0800 2015 // Weibo, Twitter Fri Sep 04 00:12:21.000 +0800 2015 */ NSDateFormatter *formatter = [NSDateFormatter new]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter.dateFormat = @"EEE MMM dd HH:mm:ss Z yyyy"; NSDateFormatter *formatter2 = [NSDateFormatter new]; formatter2.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter2.dateFormat = @"EEE MMM dd HH:mm:ss.SSS Z yyyy"; blocks[30] = ^(NSString *string) &#123; return [formatter dateFromString:string]; &#125;; blocks[34] = ^(NSString *string) &#123; return [formatter2 dateFromString:string]; &#125;; &#125; &#125;); if (!string) return nil; if (string.length &gt; kParserNum) return nil; YYNSDateParseBlock parser = blocks[string.length]; if (!parser) return nil; return parser(string); #undef kParserNum&#125;// 函数5: 获取NSBlock类static force_inline Class YYNSBlockClass() &#123; static Class cls; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; void (^block)(void) = ^&#123;&#125;; cls = ((NSObject *)block).class; while (class_getSuperclass(cls) != [NSObject class]) &#123; cls = class_getSuperclass(cls); &#125; &#125;); return cls; // current is "NSBlock"&#125;// 函数6: 获取ISO NSDateFormatter/** example: 2010-07-09T16:13:30+12:00 2011-01-11T11:11:11+0000 2011-01-26T19:06:43Z length: 20/24/25 */static force_inline NSDateFormatter *YYISODateFormatter() &#123; static NSDateFormatter *formatter = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; formatter = [[NSDateFormatter alloc] init]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ssZ"; &#125;); return formatter;&#125;/*&#123; "version": "1.1", "object": &#123; "data": &#123; "phone": "12332123" &#125; &#125;&#125; */// 函数7: 根据keypath从字典中获取对应的值(这个值是id类型)// keyPaths: @[@"object", @"data", @"phone"] 对应的值是 @"12332123"// keyPaths: @[@"object", @"data"] 对应的值是 @&#123;@"phone": @"12332123"&#125;static force_inline id YYValueForKeyPath(__unsafe_unretained NSDictionary *dic, __unsafe_unretained NSArray *keyPaths) &#123; id value = nil; for (NSUInteger i = 0, max = keyPaths.count; i &lt; max; i++) &#123; value = dic[keyPaths[i]]; if (i + 1 &lt; max) &#123; if ([value isKindOfClass:[NSDictionary class]]) &#123; dic = value; &#125; else &#123; return nil; &#125; &#125; &#125; return value;&#125;// 函数8: 根据可变的keypath从字典中获取对应的值(这个值是id类型)// multiKeys: @[ @[@"object", @"data"], @"phone"] 对应的值是 @&#123;@"phone": @"12332123"&#125;// multiKeys: @[@"object", @"data"] 对应的值是 @&#123;@"data": @&#123;@"phone": @"12332123"&#125;&#125;static force_inline id YYValueForMultiKeys(__unsafe_unretained NSDictionary *dic, __unsafe_unretained NSArray *multiKeys) &#123; id value = nil; for (NSString *key in multiKeys) &#123; if ([key isKindOfClass:[NSString class]]) &#123; value = dic[key]; if (value) break; &#125; else &#123; value = YYValueForKeyPath(dic, (NSArray *)key); if (value) break; &#125; &#125; return value;&#125;// 函数9: 从模型中的属性(_YYModelPropertyMeta类型)中获取NSNumberstatic force_inline NSNumber *ModelCreateNumberFromProperty(__unsafe_unretained id model, __unsafe_unretained _YYModelPropertyMeta *meta) &#123; switch (meta-&gt;_type &amp; YYEncodingTypeMask) &#123; case YYEncodingTypeBool: &#123; return @(((bool (*)(id, SEL))(void *) objc_msgSend)((id)model, meta-&gt;_getter));&#125; //...... &#125;&#125;// 函数10: 对模型中的属性(_YYModelPropertyMeta类型)设值. 和函数9类似static force_inline void ModelSetNumberToProperty(__unsafe_unretained id model, __unsafe_unretained NSNumber *num, __unsafe_unretained _YYModelPropertyMeta *meta) &#123; switch (meta-&gt;_type &amp; YYEncodingTypeMask) &#123; case YYEncodingTypeBool: &#123; ((void (*)(id, SEL, bool))(void *) objc_msgSend)((id)model, meta-&gt;_setter, num.boolValue); &#125; break; // ...... &#125;&#125;// 函数11: 对模型中的属性(_YYModelPropertyMeta类型)设值static void ModelSetValueForProperty(__unsafe_unretained id model, __unsafe_unretained id value, __unsafe_unretained _YYModelPropertyMeta *meta) &#123; //......&#125;typedef struct &#123; void *modelMeta; ///&lt; _YYModelMeta void *model; ///&lt; id (self) void *dictionary; ///&lt; NSDictionary (json)&#125; ModelSetContext;// 函数12: 对模型(_context.modelMeta and _context.model)设置 key-value键值对static void ModelSetWithDictionaryFunction(const void *_key, const void *_value, void *_context) &#123; ModelSetContext *context = _context; __unsafe_unretained _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta); __unsafe_unretained _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge id)(_key)]; __unsafe_unretained id model = (__bridge id)(context-&gt;model); while (propertyMeta) &#123; if (propertyMeta-&gt;_setter) &#123; ModelSetValueForProperty(model, (__bridge __unsafe_unretained id)_value, propertyMeta); &#125; // 有多个属性映射到同一个 key 则指向下一个模型属性元 propertyMeta = propertyMeta-&gt;_next; &#125;;&#125;/** Apply function for model property meta, to set dictionary to model. @param _propertyMeta should not be nil, _YYModelPropertyMeta. @param _context _context.model and _context.dictionary should not be nil. */// 函数13:static void ModelSetWithPropertyMetaArrayFunction(const void *_propertyMeta, void *_context) &#123; ModelSetContext *context = _context; __unsafe_unretained NSDictionary *dictionary = (__bridge NSDictionary *)(context-&gt;dictionary); __unsafe_unretained _YYModelPropertyMeta *propertyMeta = (__bridge _YYModelPropertyMeta *)(_propertyMeta); if (!propertyMeta-&gt;_setter) return; id value = nil; if (propertyMeta-&gt;_mappedToKeyArray) &#123; value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;_mappedToKeyArray); &#125; else if (propertyMeta-&gt;_mappedToKeyPath) &#123; value = YYValueForKeyPath(dictionary, propertyMeta-&gt;_mappedToKeyPath); &#125; else &#123; value = [dictionary objectForKey:propertyMeta-&gt;_mappedToKey]; &#125; if (value) &#123; __unsafe_unretained id model = (__bridge id)(context-&gt;model); ModelSetValueForProperty(model, value, propertyMeta); &#125;&#125;/** Returns a valid JSON object (NSArray/NSDictionary/NSString/NSNumber/NSNull), or nil if an error occurs. @param model Model, can be nil. @return JSON object, nil if an error occurs. */// 函数14: 模型转 jsonstatic id ModelToJSONObjectRecursive(NSObject *model) &#123; if (!model || model == (id)kCFNull) return model; if ([model isKindOfClass:[NSString class]]) return model; if ([model isKindOfClass:[NSNumber class]]) return model; if ([model isKindOfClass:[NSDictionary class]]) &#123; if ([NSJSONSerialization isValidJSONObject:model]) return model; NSMutableDictionary *newDic = [NSMutableDictionary new]; [((NSDictionary *)model) enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) &#123; NSString *stringKey = [key isKindOfClass:[NSString class]] ? key : key.description; if (!stringKey) return; id jsonObj = ModelToJSONObjectRecursive(obj); if (!jsonObj) jsonObj = (id)kCFNull; newDic[stringKey] = jsonObj; &#125;]; return newDic; &#125; if ([model isKindOfClass:[NSSet class]]) &#123; NSArray *array = ((NSSet *)model).allObjects; if ([NSJSONSerialization isValidJSONObject:array]) return array; NSMutableArray *newArray = [NSMutableArray new]; for (id obj in array) &#123; if ([obj isKindOfClass:[NSString class]] || [obj isKindOfClass:[NSNumber class]]) &#123; [newArray addObject:obj]; &#125; else &#123; id jsonObj = ModelToJSONObjectRecursive(obj); if (jsonObj &amp;&amp; jsonObj != (id)kCFNull) [newArray addObject:jsonObj]; &#125; &#125; return newArray; &#125; if ([model isKindOfClass:[NSArray class]]) &#123; if ([NSJSONSerialization isValidJSONObject:model]) return model; NSMutableArray *newArray = [NSMutableArray new]; for (id obj in (NSArray *)model) &#123; if ([obj isKindOfClass:[NSString class]] || [obj isKindOfClass:[NSNumber class]]) &#123; [newArray addObject:obj]; &#125; else &#123; id jsonObj = ModelToJSONObjectRecursive(obj); if (jsonObj &amp;&amp; jsonObj != (id)kCFNull) [newArray addObject:jsonObj]; &#125; &#125; return newArray; &#125; if ([model isKindOfClass:[NSURL class]]) return ((NSURL *)model).absoluteString; if ([model isKindOfClass:[NSAttributedString class]]) return ((NSAttributedString *)model).string; if ([model isKindOfClass:[NSDate class]]) return [YYISODateFormatter() stringFromDate:(id)model]; if ([model isKindOfClass:[NSData class]]) return nil; _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model class]]; if (!modelMeta || modelMeta-&gt;_keyMappedCount == 0) return nil; NSMutableDictionary *result = [[NSMutableDictionary alloc] initWithCapacity:64]; __unsafe_unretained NSMutableDictionary *dic = result; // avoid retain and release in block [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123; if (!propertyMeta-&gt;_getter) return; id value = nil; if (propertyMeta-&gt;_isCNumber) &#123; value = ModelCreateNumberFromProperty(model, propertyMeta); &#125; else if (propertyMeta-&gt;_nsType) &#123; id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = ModelToJSONObjectRecursive(v); &#125; else &#123; switch (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123; case YYEncodingTypeObject: &#123; id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = ModelToJSONObjectRecursive(v); if (value == (id)kCFNull) value = nil; &#125; break; case YYEncodingTypeClass: &#123; Class v = ((Class (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = v ? NSStringFromClass(v) : nil; &#125; break; case YYEncodingTypeSEL: &#123; SEL v = ((SEL (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = v ? NSStringFromSelector(v) : nil; &#125; break; default: break; &#125; &#125; if (!value) return; if (propertyMeta-&gt;_mappedToKeyPath) &#123; NSMutableDictionary *superDic = dic; NSMutableDictionary *subDic = nil; for (NSUInteger i = 0, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123; NSString *key = propertyMeta-&gt;_mappedToKeyPath[i]; if (i + 1 == max) &#123; // end if (!superDic[key]) superDic[key] = value; break; &#125; subDic = superDic[key]; if (subDic) &#123; if ([subDic isKindOfClass:[NSDictionary class]]) &#123; subDic = subDic.mutableCopy; superDic[key] = subDic; &#125; else &#123; break; &#125; &#125; else &#123; subDic = [NSMutableDictionary new]; superDic[key] = subDic; &#125; superDic = subDic; subDic = nil; &#125; &#125; else &#123; if (!dic[propertyMeta-&gt;_mappedToKey]) &#123; dic[propertyMeta-&gt;_mappedToKey] = value; &#125; &#125; &#125;]; if (modelMeta-&gt;_hasCustomTransformToDictionary) &#123; // 当 Model 转为 JSON 完成后，该方法会被调用。 // 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。 // 你也可以在这里做一些自动转换不能完成的工作。 BOOL suc = [((id&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic]; if (!suc) return nil; &#125; return result;&#125;/// 函数15: Add indent to string (exclude first line)static NSMutableString *ModelDescriptionAddIndent(NSMutableString *desc, NSUInteger indent) &#123; for (NSUInteger i = 0, max = desc.length; i &lt; max; i++) &#123; unichar c = [desc characterAtIndex:i]; if (c == '\n') &#123; for (NSUInteger j = 0; j &lt; indent; j++) &#123; [desc insertString:@" " atIndex:i + 1]; &#125; i += indent * 4; max += indent * 4; &#125; &#125; return desc;&#125;/// 函数16: 根据model生成一个描述字符串static NSString *ModelDescription(NSObject *model) &#123; static const int kDescMaxLength = 100; if (!model) return @"&lt;nil&gt;"; if (model == (id)kCFNull) return @"&lt;null&gt;"; if (![model isKindOfClass:[NSObject class]]) return [NSString stringWithFormat:@"%@",model]; _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:model.class]; switch (modelMeta-&gt;_nsType) &#123; case YYEncodingTypeNSString: case YYEncodingTypeNSMutableString: &#123; return [NSString stringWithFormat:@"\"%@\"",model]; &#125; case YYEncodingTypeNSValue: case YYEncodingTypeNSData: case YYEncodingTypeNSMutableData: &#123; NSString *tmp = model.description; if (tmp.length &gt; kDescMaxLength) &#123; tmp = [tmp substringToIndex:kDescMaxLength]; tmp = [tmp stringByAppendingString:@"..."]; &#125; return tmp; &#125; case YYEncodingTypeNSNumber: case YYEncodingTypeNSDecimalNumber: case YYEncodingTypeNSDate: case YYEncodingTypeNSURL: &#123; return [NSString stringWithFormat:@"%@",model]; &#125; case YYEncodingTypeNSSet: case YYEncodingTypeNSMutableSet: &#123; model = ((NSSet *)model).allObjects; &#125; // no break case YYEncodingTypeNSArray: case YYEncodingTypeNSMutableArray: &#123; NSArray *array = (id)model; NSMutableString *desc = [NSMutableString new]; if (array.count == 0) &#123; return [desc stringByAppendingString:@"[]"]; &#125; else &#123; [desc appendFormat:@"[\n"]; for (NSUInteger i = 0, max = array.count; i &lt; max; i++) &#123; NSObject *obj = array[i]; [desc appendString:@" "]; [desc appendString:ModelDescriptionAddIndent(ModelDescription(obj).mutableCopy, 1)]; [desc appendString:(i + 1 == max) ? @"\n" : @";\n"]; &#125; [desc appendString:@"]"]; return desc; &#125; &#125; case YYEncodingTypeNSDictionary: case YYEncodingTypeNSMutableDictionary: &#123; NSDictionary *dic = (id)model; NSMutableString *desc = [NSMutableString new]; if (dic.count == 0) &#123; return [desc stringByAppendingString:@"&#123;&#125;"]; &#125; else &#123; NSArray *keys = dic.allKeys; [desc appendFormat:@"&#123;\n"]; for (NSUInteger i = 0, max = keys.count; i &lt; max; i++) &#123; NSString *key = keys[i]; NSObject *value = dic[key]; [desc appendString:@" "]; [desc appendFormat:@"%@ = %@",key, ModelDescriptionAddIndent(ModelDescription(value).mutableCopy, 1)]; [desc appendString:(i + 1 == max) ? @"\n" : @";\n"]; &#125; [desc appendString:@"&#125;"]; &#125; return desc; &#125; default: &#123; NSMutableString *desc = [NSMutableString new]; [desc appendFormat:@"&lt;%@: %p&gt;", model.class, model]; if (modelMeta-&gt;_allPropertyMetas.count == 0) return desc; // sort property names NSArray *properties = [modelMeta-&gt;_allPropertyMetas sortedArrayUsingComparator:^NSComparisonResult(_YYModelPropertyMeta *p1, _YYModelPropertyMeta *p2) &#123; return [p1-&gt;_name compare:p2-&gt;_name]; &#125;]; [desc appendFormat:@" &#123;\n"]; for (NSUInteger i = 0, max = properties.count; i &lt; max; i++) &#123; _YYModelPropertyMeta *property = properties[i]; NSString *propertyDesc; if (property-&gt;_isCNumber) &#123; NSNumber *num = ModelCreateNumberFromProperty(model, property); propertyDesc = num.stringValue; &#125; else &#123; switch (property-&gt;_type &amp; YYEncodingTypeMask) &#123; case YYEncodingTypeObject: &#123; id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, property-&gt;_getter); propertyDesc = ModelDescription(v); if (!propertyDesc) propertyDesc = @"&lt;nil&gt;"; &#125; break; case YYEncodingTypeClass: &#123; id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, property-&gt;_getter); propertyDesc = ((NSObject *)v).description; if (!propertyDesc) propertyDesc = @"&lt;nil&gt;"; &#125; break; case YYEncodingTypeSEL: &#123; SEL sel = ((SEL (*)(id, SEL))(void *) objc_msgSend)((id)model, property-&gt;_getter); if (sel) propertyDesc = NSStringFromSelector(sel); else propertyDesc = @"&lt;NULL&gt;"; &#125; break; case YYEncodingTypeBlock: &#123; id block = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, property-&gt;_getter); propertyDesc = block ? ((NSObject *)block).description : @"&lt;nil&gt;"; &#125; break; case YYEncodingTypeCArray: case YYEncodingTypeCString: case YYEncodingTypePointer: &#123; void *pointer = ((void* (*)(id, SEL))(void *) objc_msgSend)((id)model, property-&gt;_getter); propertyDesc = [NSString stringWithFormat:@"%p",pointer]; &#125; break; case YYEncodingTypeStruct: case YYEncodingTypeUnion: &#123; NSValue *value = [model valueForKey:property-&gt;_name]; propertyDesc = value ? value.description : @"&#123;unknown&#125;"; &#125; break; default: propertyDesc = @"&lt;unknown&gt;"; &#125; &#125; propertyDesc = ModelDescriptionAddIndent(propertyDesc.mutableCopy, 1); [desc appendFormat:@" %@ = %@",property-&gt;_name, propertyDesc]; [desc appendString:(i + 1 == max) ? @"\n" : @";\n"]; &#125; [desc appendFormat:@"&#125;"]; return desc; &#125; &#125;&#125; 关键点 1.强制内联 #define force_inline __inline__ __attribute__((always_inline)) 2.使用代码块, 节省许多变量名 &#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init];&#125;&#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init];&#125; 3.使用block数组 typedef NSDate* (^YYNSDateParseBlock)(NSString *string);// 定义一个block数组static YYNSDateParseBlock blocks[35] = &#123;0&#125;; 4.获取NSBlock类 void (^block)(void) = ^&#123;&#125;;cls = ((NSObject *)block).class;while (class_getSuperclass(cls) != [NSObject class]) &#123; cls = class_getSuperclass(cls);&#125; 5.函数参数使用__unsafe_unretained 在 ARC 条件下，默认声明的对象是 __strong 类型的，赋值时有可能会产生retain/release调用，如果一个变量在其生命周期内不会被释放，则使用__unsafe_unretained `会节省很大的开销。 访问具有 __weak属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 __weak属性。 创建和使用对象时，要尽量避免对象进入autoreleasepool，以避免额外的资源开销。 6.for循环中定义变量, 使用unsigned for (unsigned i = 0, max = keyPaths.count; i &lt; max; i++) &#123;&#125; 7.可变量创建静态不变量, 静态常量配合dispatch_once使用 static NSSet *types = nil;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;NSMutableSet *set = [NSMutableSet new]; types = set;&#125;); 8.线程安全的缓存字典 static id cacheWithKey(NSString *key) &#123; if (!key) return nil; static CFMutableDictionaryRef cache; static dispatch_once_t onceToken; static dispatch_semaphore_t lock; dispatch_once(&amp;onceToken, ^&#123; cache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); lock = dispatch_semaphore_create(1); &#125;); dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); id obj = CFDictionaryGetValue(cache, (__bridge const void *)(key)); dispatch_semaphore_signal(lock); if (!obj) &#123; obj = [NSObject new]; // Other operation. if (obj) &#123; dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); CFDictionarySetValue(cache, (__bridge const void *)(key), (__bridge const void *)(obj)); dispatch_semaphore_signal(lock); &#125; &#125; return obj;&#125; 9.消息发送调用格式 ((int32_t (*)(id, SEL))(void *) objc_msgSend)((id)model, meta-&gt;_getter) 10.NSNull的单例kCFNull, 推荐使用, 而不是创建[NSNull null] NSNull *null1 = (id)kCFNull;NSNull *null2 = [NSNull null];Class class = Nil;NSDate *date = nil;char *p = NULL; 11.YYClassIvarInfo中的 name 和 typeEncoding 属性都用 strong 修饰。NSString 这类属性在确定其不会在初始化之后被修改的情况下，使用 strong 做一次单纯的强引用在性能上讲比 copy 要高一些。 12.NSString转C字符串 const char *cstring = ((NSString *)value).UTF8String; 实践 YYModel 最核心的便是通过遍历模型的所有属性，根据字典值来调用属性的 setter 方法。没有使用效率低下的 KVC（效率低下的原因可能是需要对方法进行搜索吧，有空深究）。鉴于此，用了300行代码简单写了一个字典转模型的玩具，权当做是读完 YYModel 的实践吧。试了一下，效果还可以😂。 @protocol YAModelProtocol &lt;NSObject&gt;@optional;+ (NSDictionary &lt;NSString *, NSString *&gt; *)customPropertyKey;+ (NSDictionary &lt;NSString *, Class&gt;*)classInArray;@end@interface NSObject (YAModel)+ (instancetype)ya_modelWithDictionary:(NSDictionary *)dict;+ (instancetype)ya_modelWithJSON:(NSData *)data;+ (NSArray *)ya_modelArrayWithKeyValuesArray:(NSArray &lt;NSDictionary *&gt;*)dictArray;@end // 编码类型typedef NS_OPTIONS(NSUInteger, YAType) &#123; YATypeMask = 0xFF, YATypeUnknown = 0, YATypeBOOL = 1, YATypeNSInteger = 2, YATypeNSUInteger = 3, YATypeCGFloat = 4, YATypeObject = 5, YATypeDate = 6, YATypeClass = 7, YATypeSEL = 8, YATypeArray = 9, YATypeMutableArray = 10, YATypeDictionary = 11, YATypeMutableDictionary = 12, YATypeSet = 13, YATypeMutableSet = 14, YATypeString = 15, YATypeMutableString = 16, YATypeData = 17, YATypeNumber = 18, YATypeDecimalNumber = 19,&#125;;@implementation NSObject (YAModel)static NSDictionary *classArrayDict = nil;+ (instancetype)ya_modelWithDictionary:(NSDictionary *)dict &#123; if (!dict || ![dict isKindOfClass:NSDictionary.class]) return nil; NSDictionary *propertyList = PropertyList(self); id obj = [self new]; ObjSetWithKeyValueList(obj, propertyList, dict); classArrayDict = nil; // Clean memory. return obj;&#125;+ (instancetype)ya_modelWithJSON:(NSData *)data &#123; if (!data || ![data isKindOfClass:NSData.class]) return nil; id json = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]; if ([json isKindOfClass:NSDictionary.class]) &#123; return [self ya_modelWithDictionary:json]; &#125; return nil;&#125;+ (NSArray *)ya_modelArrayWithKeyValuesArray:(NSArray&lt;NSDictionary *&gt; *)dictArray &#123; if (!dictArray || ![dictArray isKindOfClass:NSArray.class]) return nil; NSMutableArray *tmp = [NSMutableArray arrayWithCapacity:dictArray.count]; [dictArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([obj isKindOfClass:NSDictionary.class]) &#123; id model = [[self class] ya_modelWithDictionary:obj]; [tmp addObject:model]; &#125; &#125;]; return [NSArray arrayWithArray:tmp] ?: nil;&#125;// 获取属性列表 key:属性名 value: 属性类型static NSDictionary *PropertyList(Class cls) &#123; if (!cls) return nil; unsigned int count; objc_property_t *properties = class_copyPropertyList(cls, &amp;count); NSMutableDictionary *tempDict = [NSMutableDictionary new]; for(int i = 0; i &lt; count; i++) &#123; objc_property_t property = properties[i]; NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)]; NSString *propertyAttr = [NSString stringWithUTF8String:property_getAttributes(property)]; NSString *type = [propertyAttr substringWithRange:NSMakeRange(1, 1)]; if ([type isEqualToString:@"@"]) &#123; NSArray *components = [propertyAttr componentsSeparatedByString:@"\""]; if (components.count &gt; 2) &#123; Class propCls = NSClassFromString(components[1]); if (propCls == NSDate.class) &#123; type = @"1"; &#125; else if (propCls == NSArray.class) &#123; type = @"2"; &#125; else if (propCls == NSMutableArray.class) &#123; type = @"3"; &#125; else if (propCls == NSDictionary.class) &#123; type = @"4"; &#125; else if (propCls == NSMutableDictionary.class) &#123; type = @"5"; &#125; else if (propCls == NSSet.class) &#123; type = @"6"; &#125; else if (propCls == NSMutableSet.class) &#123; type = @"7"; &#125; else if (propCls == NSString.class) &#123; type = @"8"; &#125; else if (propCls == NSMutableString.class) &#123; type = @"9"; &#125; else if (propCls == NSData.class) &#123; type = @"10"; &#125; else if (propCls == NSNumber.class) &#123; type = @"11"; &#125; else if (propCls == NSDecimalNumber.class) &#123; type = @"12"; &#125; else if (propCls == NSObject.class) &#123; type = @"@"; &#125; else &#123; type = components[1]; &#125; &#125; &#125; NSNumber *myType = TypeForProperty(type); [tempDict setObject:myType forKey:propertyName]; if (myType.integerValue == 0) &#123; [tempDict setObject:type forKey:propertyName]; &#125; &#125; free(properties); return [NSDictionary dictionaryWithDictionary:tempDict];&#125;static NSNumber *TypeForProperty(NSString *type) &#123; static NSDictionary *_SELDictionary = nil;; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _SELDictionary = @&#123; @"B": @(YATypeBOOL), @"q": @(YATypeNSInteger), @"Q": @(YATypeNSUInteger), @"d": @(YATypeCGFloat), @"#": @(YATypeClass), @":": @(YATypeSEL), @"@": @(YATypeObject), @"1": @(YATypeDate), @"2": @(YATypeArray), @"3": @(YATypeMutableArray), @"4": @(YATypeDictionary), @"5": @(YATypeMutableDictionary), @"6": @(YATypeSet), @"7": @(YATypeMutableSet), @"8": @(YATypeString), @"9": @(YATypeMutableString), @"10": @(YATypeData), @"11": @(YATypeNumber), @"12": @(YATypeDecimalNumber), &#125;; &#125;); return _SELDictionary[type] ?: @(YATypeUnknown);&#125;static void ObjSetWithArray(Class cls, NSDictionary *propertyDict, NSArray **keyValueArray) &#123; NSMutableArray *tmpArray = [NSMutableArray array]; [*keyValueArray enumerateObjectsUsingBlock:^(id keyValue, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([keyValue isKindOfClass:NSDictionary.class]) &#123; id obj = [cls new]; ObjSetWithKeyValueList(obj, PropertyList([obj class]), keyValue); [tmpArray addObject:obj]; &#125; &#125;]; *keyValueArray = [NSArray arrayWithArray:tmpArray];&#125;static void ObjSetWithKeyValueList(id obj, NSDictionary *propertyDict, NSDictionary *dict) &#123; Class cls = [obj class]; NSDictionary *customPropertyKeyDict = nil; if ([cls respondsToSelector:@selector(customPropertyKey)]) &#123; customPropertyKeyDict = [cls customPropertyKey]; &#125; if ([cls respondsToSelector:@selector(classInArray)] &amp;&amp; !classArrayDict) &#123; classArrayDict = [cls classInArray]; &#125; [propertyDict.allKeys enumerateObjectsUsingBlock:^(NSString *name, NSUInteger idx, BOOL * _Nonnull stop) &#123; SEL setter = SetterSelectorFromString(name); id value = nil; if (customPropertyKeyDict[name]) &#123; value = customPropertyKeyDict[name]; &#125; else &#123; value = dict[name]; &#125; id propType = propertyDict[name]; YAType type = [propType integerValue]; if (value) &#123; switch (type &amp; YATypeMask) &#123; case YATypeBOOL: &#123; ((void (*)(id, SEL, bool))(void *) objc_msgSend)((id)obj, setter, [value boolValue]); &#125; break; case YATypeNSInteger: &#123; ((void (*)(id, SEL, int64_t))(void *) objc_msgSend)((id)obj, setter, (int64_t)[value longLongValue]); &#125; break; case YATypeNSUInteger: &#123; ((void (*)(id, SEL, uint64_t))(void *) objc_msgSend)((id)obj, setter, (uint64_t)[value unsignedLongLongValue]); &#125; break; case YATypeCGFloat: &#123; long double d = [value doubleValue]; if (isnan(d) || isinf(d)) d = 0; ((void (*)(id, SEL, long double))(void *) objc_msgSend)((id)obj, setter, (long double)d); &#125; break; case YATypeDecimalNumber: &#123; if ([value isKindOfClass:NSNumber.class]) &#123; NSDecimalNumber *decNum = [NSDecimalNumber decimalNumberWithDecimal:[value decimalValue]]; ((void (*)(id, SEL, NSDecimalNumber *))(void *) objc_msgSend)((id)obj, setter, decNum); &#125; &#125; break; case YATypeClass: &#123; ((void (*)(id, SEL, Class))(void *) objc_msgSend)((id)obj, setter, NSClassFromString(value)); &#125; break; case YATypeSEL:&#123; ((void (*)(id, SEL, SEL))(void *) objc_msgSend)((id)obj, setter, NSSelectorFromString(value)); &#125; break; case YATypeDate:&#123; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, DateFromString(value)); &#125; break; case YATypeArray: &#123; Class cls = classArrayDict[name]; if (cls) &#123; ObjSetWithArray(cls, PropertyList(cls), &amp;value); &#125; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; case YATypeMutableArray: &#123; NSString *clsStr = classArrayDict[name]; if (clsStr) &#123; Class cls = NSClassFromString(clsStr); ObjSetWithArray(cls, PropertyList(cls), &amp;value); &#125; value = [NSMutableArray arrayWithArray:value]; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; case YATypeSet: &#123; value = [NSSet setWithArray:value]; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; case YATypeMutableSet: &#123; value = [NSMutableSet setWithArray:value]; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; case YATypeMutableString: case YATypeMutableDictionary: &#123; value = [value mutableCopy]; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; case YATypeString: case YATypeDictionary: case YATypeNumber: case YATypeUnknown: case YATypeObject: &#123; if (type == YATypeUnknown &amp;&amp; [propType isKindOfClass:NSString.class]) &#123; // 嵌套模型 Class cls = NSClassFromString(propType); if (cls &amp;&amp; [value isKindOfClass:NSDictionary.class]) &#123; id obj = [cls new]; ObjSetWithKeyValueList(obj, PropertyList(cls), value); value = obj; &#125; &#125; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; default: break; &#125; &#125; &#125;];&#125;// name ==&gt; setName:static SEL SetterSelectorFromString(NSString *str) &#123; if (!str || str.length &lt;= 0) return nil; NSString *result = [NSString stringWithFormat:@"set%@%@:", [str substringToIndex:1].uppercaseString, [str substringFromIndex:1]]; return NSSelectorFromString(result);&#125;// date string ==&gt; data // @"2016-7-16 09:33:22"static NSDate *DateFromString(NSString *string) &#123; typedef NSDate* (^DateParseBlock)(NSString *string); static DateParseBlock blocks[20] = &#123;0&#125;; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // @"2016-07-16 09:33:22" // 19个字符, 对应blocks[19] NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter.dateFormat = @"yyyy-MM-dd HH:mm:ss"; blocks[19] = ^(NSString *string) &#123; return [formatter dateFromString:string]; &#125;; &#125;); if (!string || string.length &gt; 19) return nil; DateParseBlock parser = blocks[string.length]; if (!parser) return nil; return parser(string);&#125;@end 具体源码放在了我的代码工具库里，YAKit：https://github.com/ChenYalun/YAKit/tree/master/Util/Model 参考资料 https://juejin.im/post/5a097435f265da431769a49c https://juejin.im/post/5a1296e36fb9a044fb075d5e https://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/ https://blog.csdn.net/game3108/article/details/52416868]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解performSelector]]></title>
    <url>%2F2018%2F09%2F30%2F%E8%AF%A6%E8%A7%A3performSelector%2F</url>
    <content type="text"><![CDATA[performSelector相关知识。 基本- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2; 代码: // 无参- (id)printString &#123; NSString *str = NSStringFromSelector(_cmd); NSLog(@"%@", str); return str;&#125;// 一个参数- (id)printString:(NSString *)str &#123; NSLog(@"%@", str); return str;&#125;// 两个参数- (id)printString:(NSString *)str1 str2:(id)obj &#123; NSLog(@"%@, %@", str1, obj[@"key"]); return str1;&#125; id obj1 = [self performSelector:@selector(printString)];id obj2 = [self performSelector:@selector(printString:) withObject:@"string"];id obj3 = [self performSelector:@selector(printString:str2:) withObject:@"string" withObject:@&#123;@"key": @(3)&#125;]; 实现方式: - (id) performSelector: (SEL)aSelector withObject: (id) object1 withObject: (id) object2&#123; IMP msg; if (aSelector == 0) [NSException raise: NSInvalidArgumentException format: @"%@ null selector given", NSStringFromSelector(_cmd)]; msg = objc_msg_lookup(self, aSelector); if (!msg) &#123; [NSException raise: NSGenericException format: @"invalid selector '%s' passed to %s", sel_getName(aSelector), sel_getName(_cmd)]; return nil; &#125; return (*msg)(self, aSelector, object1, object2);&#125; 使用Runtime中的APIobjc_msg_lookup()，根据方法名获取到函数指针IMP，进而进行间接调用。在这其中还包括了方法名和函数指针的容错处理。主要就是这样: // 获取函数指针IMP imp = [self methodForSelector:@selector(printString:)];// 类型转换void (*func)(id, SEL, id) = (void *)imp;// 调用func(self, @selector(printString:), @"string"); 内存泄露 调用alloc, copy, init, mutableCopy, new等方法出现内存泄露。 调用以alloc, new, copy, mutableCopy开头的方法出现内存泄露。You create an object using a method whose name begins with “alloc”, “new”, “copy”, or “mutableCopy” (for example, alloc, newObject, or mutableCopy). 有内存泄露 NSMutableString *str = [NSMutableString stringWithFormat:@"mutableString"];// 显示调用出现Error: PerformSelector names a selector which retains the object[str performSelector:@selector(copy)];[self performSelector:@selector(newObject)];// 隐式调用无法分析出错误: 出现内存泄露id obj4 = [str performSelector:NSSelectorFromString(@"copy")];[str performSelector:NSSelectorFromString(@"mutableCopy")];id newObject = [[NSObject class] performSelector:NSSelectorFromString(@"new")]; 没有内存泄露 // 没有内存泄露- (id)createNewObject &#123; return @"string";&#125;id newObject = [self performSelector:NSSelectorFromString(@"createNewObject")]; 有内存泄露 // 有内存泄露- (id)newObject &#123; return [NSObject new];&#125;id newObject = [self performSelector:NSSelectorFromString(@"newObject")]; There are really only 4 things that ARC would consider for the return value:4 Ignore non-object types (void, int, etc) Retain object value, then release when it is no longer used (standard assumption) Release new object values when no longer used (methods in the init/ copy family or attributed with ns_returns_retained) Do nothing &amp; assume returned object value will be valid in local scope (until inner most release pool is drained, attributed with ns_returns_autoreleased) The call to methodForSelector: assumes that the return value of the method it’s calling is an object, but does not retain/release it. So you could end up creating a leak if your object is supposed to be released as in #3 above (that is, the method you’re calling returns a new object). 内存泄露的原因: 调用performSelector:编译器会假设调用方法的返回值是一个对象，且不会对返回值进行retain/release。 如果调用的方法是alloc, new, copy, mutableCopy家族中的方法(包含以它们开头)，方法调用的结果是开辟了一块内存空间，但是系统仍然按照非retain/release处理，内存空间无法释放，故而产生内存泄露。 解决办法下面的是为了消除警告而列出的方法。 方式一: methodForSelector(没有解决内存泄露)if (!person) return;// 获取函数指针IMP imp = [person methodForSelector:selector];// 类型转换void (*func)(id, SEL) = (void *)imp;// 调用func(person, selector); 方式二: methodForSelector简化版(没有解决内存泄露)((void (*)(id, SEL))[person methodForSelector:selector])(self, selector); 方式三: 消除警告(没有解决内存泄露)_Pragma("clang diagnostic push")_Pragma("clang diagnostic ignored \"-Warc-performSelector-leaks\"")[person performSelector:selector]; // 插入需要消除警告的代码_Pragma("clang diagnostic pop") // 使用#pragm(与以上无异)#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks"YAPerson *person = [[YAPerson alloc] init];[person performSelector:selector];#pragma clang diagnostic pop 方式四: 使用objc_msgSend(没有解决内存泄露)((void *(*)(id, SEL))objc_msgSend)((id)self, NSSelectorFromString(@"newObject")); 方式五: objc_msgSend手动释放内存(解决内存泄露)// 就是方式二, 只不过添加了Release Bridgeid obj = CFBridgingRelease(((void *(*)(id, SEL))objc_msgSend)(self, NSSelectorFromString(@"newObject"))); 方式六: methodForSelector手动释放内存(解决内存泄露)id obj = CFBridgingRelease(((void *(*)(id, SEL))[self methodForSelector:NSSelectorFromString(@"newObject")])(self, NSSelectorFromString(@"newObject"))); 方式七: NSInvocation(没有解决内存泄露)SEL selector = NSSelectorFromString(@"newObject");NSMethodSignature *methodSig = [[self class] instanceMethodSignatureForSelector:selector];NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig];[invocation setSelector:selector];[invocation setTarget:self];[invocation invoke]; 方式八: sendAction(没有解决内存泄露)[UIApplication.sharedApplication sendAction:NSSelectorFromString(@"newObject") to:self from:nil forEvent:nil]; 除此之外，还有许多许多，并没有全部列出来。尤其是一些看似一顿操作猛如虎却没有解决实质问题的方法。总结以上方法，既能消除警告，又能避免内存泄露，还不会丢掉动态调用的便利，三全其美的便是方法五和方法六，尤其是方法五。当然，两者本质上是一样的，只不过一个看着顺眼些。核心还是CFBridgingRelease: 把遗漏的对象释放掉。(注: 笔者目前没有在网上看到有人使用类似的方法，但是，亲自实验过后发现其确实可以解决内存泄露问题。若有不妥，请指正:iChenYalun@gmail.com) 延迟- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget; performSelector:withObject:afterDelay:源码实现: - (void)performSelector: (SEL)aSelector withObject: (id)argument afterDelay: (NSTimeInterval)seconds &#123; NSRunLoop *loop = [NSRunLoop currentRunLoop]; GSTimedPerformer *item; // item引用计数+1 item = [[GSTimedPerformer alloc] initWithSelector: aSelector target: self argument: argument delay: seconds]; // 持有item [[loop _timedPerformers] addObject: item]; // item引用计数-1 RELEASE(item); // 持有timer [loop addTimer: item-&gt;timer forMode: NSDefaultRunLoopMode];&#125; 这个方法主要做了这些事: 获取当前线程的Runloop对象。 根据方法名、方法参数、方法调用者及延迟时间等信息创建一个GSTimedPerformer对象，把该对象添加到Runloop的_timedPerformers数组中保存。 把GSTimedPerformer中的定时器timer添加到Runloop中。 如官方文档所说:This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode. 看看GSTimedPerformer做了什么: @interface GSTimedPerformer: NSObject &#123;@public SEL selector; id target; id argument; NSTimer *timer;&#125;- (void)fire;- (id)initWithSelector: (SEL)aSelector target: (id)target argument: (id)argument delay: (NSTimeInterval)delay;- (void)invalidate;@end@implementation GSTimedPerformer- (void) dealloc &#123; [self finalize]; TEST_RELEASE(timer); // 释放target对象 RELEASE(target); RELEASE(argument); [super dealloc];&#125;- (void) finalize &#123; [self invalidate];&#125;- (void) fire &#123; DESTROY(timer); [target performSelector: selector withObject: argument]; [[[NSRunLoop currentRunLoop] _timedPerformers] removeObjectIdenticalTo: self];&#125;- (id)initWithSelector:(SEL)aSelector target:(id)aTarget argument:(id)anArgument delay:(NSTimeInterval)delay &#123; self = [super init]; if (self != nil) &#123; selector = aSelector; // 持有target target = RETAIN(aTarget); argument = RETAIN(anArgument); timer = [[NSTimer allocWithZone: NSDefaultMallocZone()] initWithFireDate: nil interval: delay target: self selector: @selector(fire) userInfo: nil repeats: NO]; &#125; return self;&#125;- (void)invalidate &#123; if (timer != nil) &#123; [timer invalidate]; DESTROY(timer); &#125;&#125;@end The GSTimedPerformer class is used to hold information about messages which are due to be sent to objects at a particular time. 由此可见，GSTimedPerformer作用就是保存关于消息的信息，具体方法的延迟和调用主要还是依靠其内部的定时器。综上，Runloop的_timedPerformers数组持有了GSTimedPerformer，Runloop还持有GSTimedPerformer内部的定时器timer。GSTimedPerformer持有了target(self)。GSTimedPerformer销毁的时候释放掉target(self)。GSTimedPerformer什么时候销毁? Runloop运行在NSDefaultRunLoopMode模式下并顺利调用该方法。也即，GSTimedPerformer在定时器时间截止时调用fire方法，之后GSTimedPerformer不再持有timer，接着Runloop不再持有GSTimedPerformer，于是GSTimedPerformer销毁，它对target的强引用也不复存在。 如图: 这也是网上许多文章所称的”Runloop强持有target对象(self)”。 当延迟方法因种种原因没有执行就可能出现内存泄露，网上有一篇文章是这样描述的: performSelector关于内存管理的执行原理是这样的执行 [self performSelector:@selector(method1:) withObject:self afterDelay:3]; 的时候，系统会将self的引用计数加1，执行完这个方法时，还会将self的引用计数减1，当方法还没有执行的时候，要返回父视图释放当前视图的时候，self的计数没有减少到0，而导致无法调用dealloc方法，出现了内存泄露。 最简单的例子: 从A控制器push到B控制器，B控制器此时执行一个方法:[self performSelector:@selector(printInfo) withObject:nil afterDelay:100];。此时从B控制器pop到A控制器，很明显B控制器并没有销毁，因为Runloop还强引用着它，可以理解为出现了内存泄露(尽管100s后printInfo方法得到执行，B控制器会销毁)。 比较好的做法是取消掉之前的延迟调用:cancelPreviousPerformRequestsWithTarget: selector:object:，那么cancelPreviousPerformRequestsWithTarget: selector:object:做了什么呢? cancelPreviousPerformRequestsWithTarget: selector:object:[NSObject cancelPreviousPerformRequestsWithTarget:self];[NSObject cancelPreviousPerformRequestsWithTarget:self selector:NSSelectorFromString(@"printString:") object:@"str"]; 这两个方法可以取消perform延迟调用，它们内部做了什么？ + (void)cancelPreviousPerformRequestsWithTarget:(id)target selector:(SEL)aSelector object:(id)arg &#123; NSMutableArray *perf = [[NSRunLoop currentRunLoop] _timedPerformers]; unsigned count = [perf count]; if (count &gt; 0) &#123; GSTimedPerformer *array[count]; IF_NO_GC(RETAIN(target)); IF_NO_GC(RETAIN(arg)); [perf getObjects: array]; while (count-- &gt; 0) &#123; GSTimedPerformer *p = array[count]; if (p-&gt;target == target &amp;&amp; sel_isEqual(p-&gt;selector, aSelector) &amp;&amp; (p-&gt;argument == arg || [p-&gt;argument isEqual: arg])) &#123; [p invalidate]; [perf removeObjectAtIndex: count]; &#125; &#125; RELEASE(arg); RELEASE(target); &#125;&#125; 获取Runloop内部持有的_timedPerformers数组(数组中的是GSTimedPerformer对象)。 创建一个C语言数组，并把_timedPerformers数组中的内容copy到这个C语言数组array。 遍历该C语言数组array: 如果给定参数中的target、argument、selector均一一对应，那么销毁GSTimedPerformer对象中的定时器，并根据当前的索引移除_timedPerformers数组的GSTimedPerformer对象。 换句话说，如果target、argument、selector中有一个参数没有对应，那么便不会执行销毁定时器操作和移除操作。那么，判定target、argument、selector均一一对应的标准是:Matching of the argument may be either by pointer equality or by use of the [NSObject-isEqual:] method.就是指针和isEqual方法。 if(p-&gt;target == target &amp;&amp; sel_isEqual(p-&gt;selector, aSelector)&amp;&amp; (p-&gt;argument == arg || [p-&gt;argument isEqual: arg])) &#123;&#125; 其实这里的sel_isEqual就等价于==，这样的话如果我们自己需要预先判断参数是否一一对应不妨就按照它这么写。 同理，+ (void)cancelPreviousPerformRequestsWithTarget:(id)target方法执行原理与上面的方法类似，只是不用比较参数，把所有定时器都销毁，并把所有GSTimedPerformer对象都从_timedPerformers数组中移除。 如上文所述: GSTimedPerformer在定时器时间截止时调用fire方法，之后GSTimedPerformer不再持有timer，接着Runloop不再持有GSTimedPerformer，于是GSTimedPerformer销毁，它对target的强引用也不复存在。 当手动销毁定时器并把GSTimedPerformer从Runloop从移除时，GSTimedPerformer销毁，GSTimedPerformer对target的强引用不存在，这样，内存泄露问题解决了。这也是为什么使用cancelPreviousPerformRequestsWithTarget取消还没有执行的perform就可以解决target无法释放掉的原因。 线程performSelector:onThread:withObject:waitUntilDone:modes:- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait; 要求perform在指定的线程执行。具体的实现如下所示: - (void)performSelector:(SEL)aSelector onThread:(NSThread*)aThread withObject:(id)anObject waitUntilDone:(BOOL)aFlag modes:(NSArray*)anArray &#123; GSRunLoopThreadInfo *info; NSThread *t; if ([anArray count] == 0) return; t = GSCurrentThread(); if (aThread == nil) aThread = t; info = GSRunLoopInfoForThread(aThread); if (t == aThread) &#123; // Perform in current thread. if (aFlag == YES || info-&gt;loop == nil) &#123; // Wait until done or no run loop. [self performSelector: aSelector withObject: anObject]; &#125; else &#123; // Don't wait ... schedule operation in run loop. [info-&gt;loop performSelector: aSelector target: self argument: anObject order: 0 modes: anArray]; &#125; &#125; else &#123; GSPerformHolder *h; NSConditionLock *l = nil; // 线程Finished判断 if ([aThread isFinished] == YES) &#123; [NSException raise: NSInternalInconsistencyException format: @"perform on finished thread"]; &#125; // 阻塞等待加锁 if (aFlag == YES) &#123; l = [[NSConditionLock alloc] init]; &#125; h = [GSPerformHolder newForReceiver:self argument:anObject selector:aSelector modes:anArray lock:l]; [info addPerformer: h]; // 条件锁创建成功(也即参数aFlag为YES) if (l != nil) &#123; [l lockWhenCondition: 1]; // 当条件为1时加锁 [l unlock]; RELEASE(l); // holder已经失效则抛出异常 if ([h isInvalidated] == YES) &#123; RELEASE(h); [NSException raise: NSInternalInconsistencyException format: @"perform on finished thread"]; &#125; // holder自身就产生exception了, 那么再次抛出异常 // If we have an exception passed back from the remote thread, re-raise it. if (nil != h-&gt;exception) &#123; NSException *e = AUTORELEASE(RETAIN(h-&gt;exception)); RELEASE(h); [e raise]; &#125; &#125; RELEASE(h); &#125;&#125; 这个方法主要做了这些什么? 首先对传进来的modes(Runloop模式数组)个数进行判断，如果为0，则直接return。 获取该方法执行上下文中的线程: t，并把它与作为参数传进来的线程aThread进行比较，看是否一致。当然，如果传进来的aThread为空，那么执行aThread = t;，简单粗暴地假定传进来的线程和上下文中的线程一致。 当两个线程一致时，如果参数aFlag为YES或者线程对应的Runloop为空，说明需要等待，也即这个方法应该等到selector被执行完毕后再return。这就好办了，直接调用[self performSelector: aSelector withObject: anObject];方法，同步执行即可。如果不需要等待呢? 把selector、argument、modes等信息交给线程对应的Runloop再进一步处理。 当两个线程不一致时，首先判断aThread有没有finished，线程死了自然selector无法执行，抛出异常。再者判断是否需要阻塞等待，如果需要的话就创建一个条件锁。接着把selector、argument、modes及条件锁等信息封装成一个GSPerformHolder对象，并把它交给封装线程信息的GSRunLoopThreadInfo对象。之后是一些收尾工作:设置条件锁的condition及以下异常判断。 需要着重说明的是参数aFlag: 是否立即返回。如果参数aFlag为YES，则这个方法应该等到selector被执行完毕后再return。那么就有一个问题，这个方法本身并不会触发aThread对应的Runloop运行，换句话说，如果aThread对应的Runloop一直不运行那么这个方法也一直不会return，咦，如果aThread和当前线程一致，Runloop要是一直没运行，那整个程序不就锁在这段代码了吗。 所以，针对这个特殊情况:参数aFlag为YES且aThread和当前线程一致，那modes将会被忽略，这个selector会立刻执行(因此上面的方法实现中直接调用performSelector:withObject而不是走到条件锁那段代码)。这就巧妙地避免了由于当前线程的Runloop没运行而线程被一个永远无法执行的perform阻塞的问题。 两个线程一致时问题一: 两个线程一致时，”把selector、argument、modes等信息交给线程对应的Runloop再进一步处理。”，具体怎么做的呢? - (void)performSelector:(SEL)aSelector target:(id)target argument:(id)argument order:(NSUInteger)order modes:(NSArray*)modes; Sets up sending of aSelector to target with argument. The selector is sent before the next runloop iteration (unless cancelled before then) in any of the specified modes.The target and argument objects are retained.The order value is used to determine the order in which messages are sent if multiple messages have been set up. Messages with a lower order value are sent first.If the modes array is empty, this method has no effect.说的很明白了，就是在指定模式的Runloop下一次迭代之前把selector、argument等信息丢给target，以便调用。这里的order指定了这个调用的优先级。 - (void)performSelector:(SEL)aSelector target:(id)target argument:(id)argument order:(NSUInteger)order modes:(NSArray*)modes &#123; unsigned count = [modes count]; if (count &gt; 0) &#123; NSString *array[count]; GSRunLoopPerformer *item; item = [[GSRunLoopPerformer alloc] initWithSelector:aSelector target: target argument: argument order: order]; // 把modes中的内容copy到array if ([modes isProxy]) &#123; unsigned i; for (i = 0; i &lt; count; i++) &#123; array[i] = [modes objectAtIndex: i]; &#125; &#125; else &#123; [modes getObjects: array]; &#125; while (count-- &gt; 0) &#123; NSString *mode = array[count]; unsigned end; unsigned i; GSRunLoopCtxt *context; GSIArray performers; context = NSMapGet(_contextMap, mode); if (context == nil) &#123; context = [[GSRunLoopCtxt alloc] initWithMode: mode extra: _extra]; NSMapInsert(_contextMap, context-&gt;mode, context); RELEASE(context); &#125; performers = context-&gt;performers; end = GSIArrayCount(performers); for (i = 0; i &lt; end; i++) &#123; GSRunLoopPerformer *p; p = GSIArrayItemAtIndex(performers, i).obj; if (p-&gt;order &gt; order) &#123; GSIArrayInsertItem(performers, (GSIArrayItem)((id)item), i); break; &#125; &#125; if (i == end) &#123; GSIArrayInsertItem(performers, (GSIArrayItem)((id)item), i); &#125; i = GSIArrayCount(performers); if (i % 1000 == 0 &amp;&amp; i &gt; context-&gt;maxPerformers) &#123; context-&gt;maxPerformers = i; NSLog(@"WARNING ... there are %u performers scheduled" @" in mode %@ of %@\n(Latest: [%@ %@])", i, mode, self, NSStringFromClass([target class]), NSStringFromSelector(aSelector)); &#125; &#125; RELEASE(item); &#125;&#125; 根据方法实现来看，这个方法做了这些事: 如果数组modes中没有内容就直接return。 把target、argument、selector、order等信息包装成一个对象GSRunLoopPerformer。 创建一个字符串数组array，把modes中的内容copy到array。 遍历array。根据array中的模式mode(NSString类型)找到_contextMap(NSMapTable类型)表中对应的context(GSRunLoopCtxt类型)，获得context中需要执行的performers(GSIArray类型)。 把第2步中包装好的GSRunLoopPerformer对象放到performers中。遍历performers，根据order确定优先级，调整performers中的索引。 总而言之，就是把target、argument、selector、order等信息包装成一个GSRunLoopPerformer对象，并把该对象交给Runloop(中的_contextMap中的performers)，供其在合适的时机调用。具体啥时候调用呢?官方文档说是Runloop的下一次迭代的时候。 两个线程不一致时问题二: 两个线程不一致时，”把selector、argument、modes及条件锁等信息封装成一个GSPerformHolder对象，并把它交给封装线程信息的GSRunLoopThreadInfo对象”又是怎么做的呢? (GSPerformHolder *)h = [GSPerformHolder newForReceiver:self argument:anObject selector:aSelector modes:anArray lock:l];[(GSRunLoopThreadInfo *)info addPerformer: h]; newForReceiver:argument:selector:modes:lock: 这个方法就是做一些信息封装，无需多言。主要是这个addPerformer，删除#if defined(_WIN32)的代码后具体实现如下: - (void)addPerformer:(id)performer &#123; BOOL signalled = NO; // NSLock加锁 [lock lock]; NSTimeInterval start = 0.0; // 使用write函数向 outputFd 中写入 1 字节数据，数据为: "0"。 while (outputFd &gt;= 0 &amp;&amp; NO == (signalled = (write(outputFd, "0", 1) == 1) ? YES : NO)) &#123; NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate]; if (0.0 == start) &#123; start = now; &#125; else if (now - start &gt;= 1.0) &#123; NSLog(@"Unable to signal %@ within a second; blocked?", self); break; &#125; [lock unlock]; [lock lock]; &#125; // 写入数据成功，把performer添加到GSRunLoopThreadInfo数组中 if (signalled) [performers addObject: performer]; // NSLock解锁 [lock unlock]; // 写入数据失败，销毁performer if (!signalled) [performer invalidate];&#125; 补充write函数知识点: /* * write函数 * ssize_t write(int __fd, const void * __buf, size_t __nbyte) __DARWIN_ALIAS_C(write); * write 函数向 __fd 中写入 __nbyte 字节数据，数据来源为 __buf 。返回值一般总是等于 __nbyte * 返回值如果不是等于__nbyte，就是出错了。常见的出错原因是磁盘空间满了或者超过了文件大小限制。 *//* The write could concievably fail if the pipe is full. * In that case we need to release the lock temporarily to allow the other * thread to consume data from the pipe. It's possible that the thread * and its runloop might stop during that ... so we need to check that * outputFd is still valid. */ 不是十分理解write函数在这里的作用，根据一些异常信息&quot;Failed to set non block flag for perform in thread&quot; &quot;Failed to create event to handle perform in thread&quot;，可能是向文件中写入一些flag表示线程指定事件对象的信号状态吧。 如果信号状态设置成功，就把这个perform对象(GSPerformHolder类型)添加到GSRunLoopThreadInfo的performers数组中。 这个GSRunLoopThreadInfo对象把GSPerformHolder对象添加到自己数组中后，具体最原先的perform什么时候执行呢? 是在调用GSRunLoopThreadInfo对象的fire方法时逐个执行: GSRunLoopThreadInfo对象的fire方法部分实现: for (i = 0; i &lt; c; i++) &#123; GSPerformHolder *h = [toDo objectAtIndex: i]; [loop performSelector: @selector(fire) target: h argument: nil order: 0 modes: [h modes]]; &#125; 可见是逐个取出数组中的GSPerformHolder对象，一个接一个地调用GSPerformHolder的fire方法，这也是个fire方法，它内部做了什么?就是[receiver performSelector: selector withObject: argument];。 捋一捋: 两个线程不一致时，把selector、argument、modes及条件锁等信息封装成一个GSPerformHolder对象，并把它添加到GSRunLoopThreadInfo对象的performers数组中。当调用GSRunLoopThreadInfo对象的fair方法时会遍历performers数组，然后逐个调用数组中每一个元素的fair方法，而这个fair方法内部就是调用performSelector:withObject方法。 最最关键的一个问题: 什么时候调用GSRunLoopThreadInfo对象的fair方法? 官方文档说: May only be called from the runloop when the event/descriptor is triggered.我在Runloop的+(BOOL)awakenedBefore:和 -(BOOL)pollUntil:within:方法中找到了调用痕迹。 相关方法- (void) performSelector:(SEL)aSelector onThread:(NSThread*)aThread withObject:(id)anObject waitUntilDone:(BOOL)aFlag &#123; [self performSelector:aSelector onThread:aThread withObject:anObject waitUntilDone:aFlag modes:commonModes()];&#125; Runloop的五种mode分别是:NSDefaultRunLoopMode，NSConnectionReplyMode，NSModalPanelRunLoopMode，NSEventTrackingRunLoopMode，NSRunLoopCommonModes。这个方法省略了modes参数，内部使用common mode，也即NSDefaultRunLoopMode和NSConnectionReplyMode(不是NSEventTrackingRunLoopMode)。所以如果有鼠标或者手势事件需要处理，省略modes参数可能不是个好做法。 - (void) performSelectorOnMainThread:(SEL)aSelector withObject:(id)anObject waitUntilDone:(BOOL)aFlag modes:(NSArray*)anArray &#123; if (defaultThread == nil) [NSThread mainThread]; [self performSelector:aSelector onThread:defaultThread withObject:anObject waitUntilDone:aFlag modes:anArray];&#125;- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)anObject waitUntilDone:(BOOL)aFlag &#123; [self performSelectorOnMainThread:aSelector withObject:anObject waitUntilDone:aFlag modes:commonModes()];&#125; 这两个方法指定了主线程。一: 如果参数aFlag是YES且方法调用的当前线程就是主线程，那么modes参数会被忽略。与上文所说的”参数aFlag为YES且aThread和当前线程一致，那modes将会被忽略，这个selector会立刻执行”一致。 后台执行: - (void) performSelectorInBackground:(SEL)aSelector withObject:(id)anObject &#123; [NSThread detachNewThreadSelector:aSelector toTarget:self withObject:anObject];&#125; 就是随意创建一个线程执行selector方法。 一些题目printInfo方法会执行吗GCD调用dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self performSelector:@selector(printInfo) withObject:nil afterDelay:1]; &#125;); 很明显是不会的。因为performSelector具体实现中并没有主动触发线程对应Runloop运行。子线程对应的Runloop没有run。怎么让它执行?启动Runloop: dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self performSelector:@selector(printInfo) withObject:nil afterDelay:1]; [[NSRunLoop currentRunLoop] run];&#125;); NSThread调用NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; [self performSelector:@selector(printInfo) withObject:nil afterDelay:1];&#125;];[thread start]; 同理: NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; [self performSelector:@selector(printInfo) withObject:nil afterDelay:1]; [[NSRunLoop currentRunLoop] run];&#125;];[thread start]; 这就有一个问题了。在GCD中[[NSRunLoop currentRunLoop] run];放在performSelector前面或者后面貌似都是可以的，但是在NSThread中[[NSRunLoop currentRunLoop] run];只能放在performSelector的后面。 在NSThread方法中: 因为run方法只是尝试想要开启当前线程中的runloop，但是如果该线程中并没有任何事件(source、timer、observer)的话，并不会成功的开启。 为什么GCD中即使[[NSRunLoop currentRunLoop] run];放在前面printInfo方法还是调用了呢? 代码实际测试，延迟效果没有了，并且有时方法执行，有时方法没有执行。 综上，在子线程中使用performSelector的延迟方法是，需要加上[[NSRunLoop currentRunLoop] run];使得Runloop能够运行，并且该方法要放在performSelector的后面来保证正确成功地开启。 NSThread无效NSThread *thread = [[NSThread alloc] initWithBlock:^&#123;&#125;];[thread start];[self performSelector:@selector(printMainInfo) onThread:thread withObject:nil waitUntilDone:NO]; 上面这段代码为什么没有执行printMainInfo方法? NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; // 执行一次而已 NSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop]; [currentRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];&#125;];[thread start];[self performSelector:@selector(printMainInfo) onThread:thread withObject:nil waitUntilDone:NO]; 子线程执行完操作之后就会立即释放，即使我们使用强引用引用子线程使子线程不被释放，也不能给子线程再次添加操作，或者再次开启。这里可以使用Runloop。子线程获取其对应的Runloop对象并使之运行。一般使用常驻子线程。 参考资料https://zhongwuzw.github.io/2017/01/19/Objective-C之performSelector编译器内存泄露警告/ https://blog.csdn.net/dean19900504/article/details/8067679https://www.jianshu.com/p/4f5566125148 https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html https://blog.csdn.net/wei371522/article/details/81216853 https://blog.csdn.net/king16304/article/details/52192259]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime基础]]></title>
    <url>%2F2018%2F07%2F10%2FRuntime%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[2018.8.26 更新Class定义 关于Runtime的简单总结。 代码中省略OBJC2_UNAVAILABLE,也即不可直接访问结构体中的成员. 一、RuntimeClassObjective-C2.0之前Class的定义struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ // 父类 Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; // 方法缓存 struct objc_cache *cache; struct objc_protocol_list *protocols;#endif&#125;;struct objc_cache &#123; unsigned int mask /* total = mask + 1 */; unsigned int occupied; Method buckets[1];&#125;;根据源码，最新定义大致如下:struct objc_class : objc_object &#123; // Class ISA; Class isa; Class superclass; cache_t cache;// 方法缓存 class_data_bits_t bits; // 用于获取具体的类信息&#125;; YAPerson *person = [[YAPerson alloc] init]; Class cls = [person class]; // 获取实例对象对应的Class Class class1 = object_getClass(person); // 获取指定名称的类对象 Class class3 = objc_getClass("YAPerson"); Class class2 = objc_getRequiredClass("YAPerson"); // 获取指定名称的元类对象 Class class4 = objc_getMetaClass("YAPerson"); // 找到指定名称的类对象 Class class5 = objc_lookUpClass("NSObject"); NSLog(@"%@%@%@%@%@",class1,class2,class3,class4,class5); // 设置对象对应的Class,返回原先的class Class oriClass = object_setClass(person, [NSObject class]); // 是否是类对象或元类对象 BOOL isClass = object_isClass(person); // 是否是元类对象 BOOL isMetaClass = class_isMetaClass(class4); // 获取父类 Class superClass = class_getSuperclass(cls); // 获取类的版本 int version = class_getVersion(cls); // 设置类的版本 class_setVersion(cls, 88); // 获取实例大小 typedef __SIZE_TYPE__ size_t; size_t size = class_getInstanceSize(cls); // int objc_getClassList(Class *buffer, int bufferCount)// // Class *objc_copyClassList(unsigned int *outCount)// // 获取类的名称 const char *name = class_getName(cls); // 动态创建类 //Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes) //void objc_registerClassPair(Class cls) // 动态废弃类 //Class objc_duplicateClass(Class original, const char *name, size_t extraBytes) //void objc_disposeClassPair(Class cls) //id o = objc_storeWeak(&amp;weakObject, weakObject); //id result = objc_loadWeak(&amp;weakObject); Block给block创建一个关联的函数指针IMP imp_implementationWithBlock(id block)获取函数指针关联的blockid imp_getBlock(IMP anImp)移除函数指针对应的blockBOOL imp_removeBlock(IMP anImp) 实例演练 // 声明blocktypedef void (^Block) ();// 定义blockBlock block = ^() &#123; NSLog(@"哈哈哈");&#125;;// 给block创建一个关联的函数指针IMP imp = imp_implementationWithBlock(block);// 调用block(*imp)();// 获取函数指针关联的blockid blockObject = imp_getBlock(imp);NSLog(@"%@",blockObject);// 移除函数指针对应的blockBOOL isRemoveBlock = imp_removeBlock(imp);if (isRemoveBlock) &#123; NSLog(@"成功移除");&#125; SEL获取SEL的名称(char *类型)const char *sel_getName(SEL sel)注册SELSEL sel_registerName(const char *str)比较SELBOOL sel_isEqual(SEL lhs, SEL rhs) 实例演练 // 获取SEL的名称(char *类型)const char *selName = sel_getName(@selector(viewWillAppear:));printf("%s",selName);// 注册SELSEL newSel = sel_registerName("haha");// 比较SELBOOL isEqual = sel_isEqual(@selector(viewWillAppear:), newSel);NSLog(@"%d",isEqual); Ivar定义一个objc_ivar结构体指针Ivartypedef struct objc_ivar *Ivar;struct objc_ivar &#123; 成员变量名称 char *ivar_name; 成员变量类型 char *ivar_type; 偏移量 int ivar_offset; #ifdef __LP64__ int space; #endif&#125; 关于偏移量的定义(就是整型)#if defined(__PTRDIFF_TYPE__) typedef __PTRDIFF_TYPE__ __darwin_ptrdiff_t; /* ptr1 - ptr2 */#elif defined(__LP64__) typedef long __darwin_ptrdiff_t; /* ptr1 - ptr2 */#else typedef int __darwin_ptrdiff_t; /* ptr1 - ptr2 */#endif /* __GNUC__ */ #ifndef _PTRDIFF_T#define _PTRDIFF_T typedef __darwin_ptrdiff_t ptrdiff_t;#endif /* _PTRDIFF_T */成员变量列表struct objc_ivar_list &#123; 成员变量数量 int ivar_count;#ifdef __LP64__ int space;#endif /* variable length structure */ struct objc_ivar ivar_list[1];&#125; 获取实例变量Ivar class_getInstanceVariable(Class cls, const char *name) //获取类变量//Ivar class_getClassVariable(Class cls, const char *name) 获取成员变量列表Ivar *class_copyIvarList(Class cls, unsigned int *outCount) 获取Ivar变量的名称const char *ivar_getName(Ivar v) 获取Ivar变量的偏移量ptrdiff_t ivar_getOffset(Ivar v) 获取Ivar变量的编码const char *ivar_getTypeEncoding(Ivar v) 设置成员变量的值void object_setIvarWithStrongDefault(id obj, Ivar ivar, id value)设置成员变量的值void object_setIvar(id obj, Ivar ivar, id value)获取Ivar对应的成员变量对象id object_getIvar(id obj, Ivar ivar)IvarLayout相关const uint8_t *class_getIvarLayout(Class cls)const uint8_t *class_getWeakIvarLayout(Class cls)void class_setIvarLayout(Class cls, const uint8_t *layout)void class_setWeakIvarLayout(Class cls, const uint8_t *layout) 添加成员变量BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types) 实例演示 - (void)viewDidLoad &#123; YAPerson *person = [[YAPerson alloc] init]; Class cls = [person class]; // 获取实例变量 Ivar ivar_num = class_getInstanceVariable(cls, "num"); Ivar ivar_name = class_getInstanceVariable(cls, "name"); //获取类变量 //Ivar class_getClassVariable(Class cls, const char *name) // 获取Ivar变量的名称 const char *name = ivar_getName(ivar_name); printf("%s\n",name); // 获取Ivar变量的偏移量 ptrdiff_t p = ivar_getOffset(ivar_num); printf("%td",p); // 打印16 // 获取Ivar变量的编码 const char *typeEncoding = ivar_getTypeEncoding(ivar_name); printf("%s\n",typeEncoding); // 打印 @"NSString" // 设置成员变量的值 object_setIvarWithStrongDefault(person, ivar_name, @"haha"); NSLog(@"%@",person-&gt;name); // 设置成员变量对应的值 object_setIvar(person, ivar_name, @"hahaaaaaa"); NSLog(@"%@",person-&gt;name); //获取Ivar对应的成员变量对象 id object = object_getIvar(person, ivar_name); NSLog(@"%@",object); // 动态添加成员变量 // 必须在 objc_allocateClassPair 之后 和 在objc_registerClassPair之前调用 // 不能给一个已经存在的类添加成员变量 Class peopleClass = objc_allocateClassPair(cls, "YAPeople", 0); class_addIvar(peopleClass, "_gayFriend", sizeof(id), log2(sizeof(id)), @encode(id)); class_addIvar(peopleClass, "_girlFriend", sizeof(id), log2(sizeof(id)), @encode(id)); class_addIvar(peopleClass, "_company", sizeof(id), log2(sizeof(id)), @encode(id)); objc_registerClassPair(peopleClass); // 打印成员变量列表 NSLog(@"%@", [self ya_getIvarList:peopleClass]); // IvarLayout相关 // ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型 const uint8_t *ivarLayoutArray= class_getIvarLayout(cls); const uint8_t *weakIvarLayoutArray = class_getWeakIvarLayout(cls); if (ivarLayoutArray) &#123; int i = 0; uint8_t value_s = ivarLayoutArray[i]; while (value_s != 0x0) &#123; printf("\\x%02x\n", value_s); value_s = ivarLayoutArray[++i]; &#125; &#125; //void class_setIvarLayout(Class cls, const uint8_t *layout) //void class_setWeakIvarLayout(Class cls, const uint8_t *layout) &#125;/** 根据class获取成员变量列表 @param class 类 @return 成员变量字典(名称:类型) */- (NSDictionary *)ya_getIvarList:(Class)class &#123; // 成员变量数量 unsigned int count = 0; // 获取成员变量列表 Ivar *ivarList = class_copyIvarList(class, &amp;count); // 存储成员变量 NSMutableDictionary *dict = [NSMutableDictionary dictionary]; // 获取成员变量类型与成员变量名称 for (unsigned int i = 0; i &lt; count; i++) &#123; // 成员变量类型 const char *c_ivarType = ivar_getTypeEncoding(ivarList[i]); // 成员变量名称 const char *c_ivarName = ivar_getName(ivarList[i]); // 利用字典存储,格式为 成员变量名称:对应的成员变量类型 NSString *ivarName = [NSString stringWithUTF8String:c_ivarName]; dict[ivarName] = [NSString stringWithUTF8String:c_ivarType]; &#125; // 需要手动free free(ivarList); return [NSDictionary dictionaryWithDictionary:dict];&#125; Method值得一提的是方法编码和类型编码: #define _C_ID '@'#define _C_CLASS '#'#define _C_SEL ':'#define _C_CHR 'c'#define _C_UCHR 'C'#define _C_SHT 's'#define _C_USHT 'S'#define _C_INT 'i'#define _C_UINT 'I'#define _C_LNG 'l'#define _C_ULNG 'L'#define _C_LNG_LNG 'q'#define _C_ULNG_LNG 'Q'#define _C_FLT 'f'#define _C_DBL 'd'#define _C_BFLD 'b'#define _C_BOOL 'B'#define _C_VOID 'v'#define _C_UNDEF '?'#define _C_PTR '^'#define _C_CHARPTR '*'#define _C_ATOM '%'#define _C_ARY_B '['#define _C_ARY_E ']'#define _C_UNION_B '('#define _C_UNION_E ')'#define _C_STRUCT_B '&#123;'#define _C_STRUCT_E '&#125;'#define _C_VECTOR '!'#define _C_CONST 'r' Code Meaning r const n in N inout o out O bycopy R byref V oneway 以上信息在具体应用时,可以自定义一个枚举获取. typedef struct objc_method *Method;struct objc_method &#123; // 方法的名称 SEL method_name; // 方法的参数类型 char *method_types; // 方法的实现(函数指针) IMP method_imp; &#125; 根据方法名称获取MethodMethod class_getInstanceMethod(Class cls, SEL name)Method class_getClassMethod(Class cls, SEL name)获取Method的方法名称SEL method_getName(Method m)获取Method的方法实现IMP method_getImplementation(Method m) IMP class_getMethodImplementation(Class cls, SEL name) 获取Method的返回值类型(需手动释放)char *method_copyReturnType(Method m)//void method_getReturnType(Method m, char *dst, size_t dst_len)获取指定Method的类型const char *method_getTypeEncoding(Method m) 获取Method的参数数量unsigned int method_getNumberOfArguments(Method m)获取Method中第i个参数的类型(Char *类型)(需手动释放)char *method_copyArgumentType(Method m, unsigned int index) 获取方法列表Method *class_copyMethodList(Class cls, unsigned int *outCount) 设置IMPIMP method_setImplementation(Method m, IMP imp)交换方法实现void method_exchangeImplementations(Method m1, Method m2) 添加方法BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) 替换方法 IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) 标明需要手动释放的动态内存(如返回值类型/参数类型)// 及时释放if (argumentType) free(argumentType); 实例演示 - (void)viewDidLoad &#123; [super viewDidLoad]; YAPerson *person = [[YAPerson alloc] init]; // 获取Method Method method = class_getInstanceMethod([person class] , NSSelectorFromString(@"nameWithArg:arg:arg:arg:arg:")); // 获取Method的方法名称 SEL sel = method_getName(method); NSLog(@"%@",NSStringFromSelector(sel)); // 获取Method的方法实现 IMP imp1 = method_getImplementation(method); IMP imp2 = class_getMethodImplementation([person class],sel); // 获取Method的返回值类型(需手动释放) char *returnType = method_copyReturnType(method); if (returnType) &#123; NSLog(@"%@",[NSString stringWithUTF8String:returnType]); free(returnType); &#125; // 获取指定Method的类型 const char *typeEncoding = method_getTypeEncoding(method); if (typeEncoding) &#123; NSLog(@"%@",[NSString stringWithUTF8String:typeEncoding]); &#125; // 获取Method的参数数量 unsigned int arguementCount = method_getNumberOfArguments(method); if (arguementCount &gt; 0) &#123; for (unsigned int i = 0; i &lt; arguementCount; i++) &#123; //获取Method中第i个参数的类型(Char *类型)(需手动释放) char *arguementType = method_copyArgumentType(method, i); NSLog(@"%@",[NSString stringWithUTF8String:arguementType]); // 手动释放 if (arguementType) &#123; free(arguementType); &#125; &#125; &#125; // 设置新的方法实现IMP,并返回原先的IMP IMP imp3 = method_setImplementation(method, imp2);&#125;/** Method Swizzling 一般放在load方法中,并且使用dispatch_once,需要调用 class_addMethod 方法 */+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class cls = [self class]; SEL oldSelector = NSSelectorFromString(@"XXXX"); SEL newSelector = NSSelectorFromString(@"XXXXXXXX"); Method oldMethod = class_getInstanceMethod(cls, oldSelector); Method newMethod = class_getInstanceMethod(cls, newSelector); // 尝试给旧的方法oldSelector添加新的方法newSelectot的实现,如果已经存在方法实现,则添加失败 BOOL isSuccess = class_addMethod(cls, oldSelector, method_getImplementation(newMethod), method_getTypeEncoding(newMethod)); if (isSuccess) &#123; // 添加成功,那么用旧的方法实现替换新的方法实现 class_replaceMethod(cls, newSelector, method_getImplementation(oldMethod), method_getTypeEncoding(oldMethod)); &#125; else &#123; // 旧的方法已经有了实现,直接交换即可 method_exchangeImplementations(newMethod, oldMethod); &#125; &#125;); /* 使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全地替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现。Swizzling应该总是在+load中执行在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证–事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。Swizzling应该总是在dispatch_once中执行与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。*/&#125;/** 根据class获取方法列表 @param class 类 @return 方法名称数组 */+ (NSArray *)ya_getMethodList:(Class)class &#123; // 方法列表数量 unsigned int methodCount = 0; // 获取方法列表 Method *methodList = class_copyMethodList(class, &amp;methodCount); // 存储方法名称 NSMutableArray *array = [NSMutableArray array]; if (methodList) &#123; for (unsigned int i = 0; i &lt; methodCount; i ++) &#123; // 获取方法 Method method = methodList[i]; // 获取方法名称 SEL sel = method_getName(method); [array addObject:NSStringFromSelector(sel)]; &#125; // 手动释放 free(methodList); &#125; return [NSArray arrayWithArray:array];&#125;/** 交换实例方法实现 @param class 类 @param aSEL 方法一的名称 @param bSEL 方法二的名称 */+ (void)ya_exchangeInstanceMethod:(Class)class firstMethod:(SEL)aSEL secondMethod:(SEL)bSEL &#123; Method aMethad = class_getInstanceMethod(class, aSEL); Method bMethod = class_getInstanceMethod(class, bSEL); // 交换方法实现 method_exchangeImplementations(aMethad, bMethod);&#125;/** 交换类方法实现 @param class 类 @param aSEL 方法一的名称 @param bSEL 方法二的名称 */+ (void)ya_exchangeClassMethod:(Class)class firstMethod:(SEL)aSEL secondMethod:(SEL)bSEL &#123; Method aMethad = class_getClassMethod(class, aSEL); Method bMethod = class_getClassMethod(class, bSEL); // 交换方法实现 method_exchangeImplementations(aMethad, bMethod);&#125;/** 为类添加名为newSEL的(实例)方法 @param class 类 @param aSEL 新的方法名称 @param bSEL 已经存在的方法名称 @return 是否添加成功 */+ (BOOL)ya_addMethod:(Class)class newSEL:(SEL)aSEL existSEL:(SEL)bSEL &#123; // 获取已经存在的方法 Method method = class_getInstanceMethod(class, bSEL); // 获取已经存在的方法的实现 IMP imp = class_getMethodImplementation(class, bSEL); // 获取type const char *type = method_getTypeEncoding(method); // 给class添加名称为aSEL的方法实现 return class_addMethod(class, aSEL, imp, type); /* 如果父类中已经有该名称的方法,那么调用后将重写该方法 如果本类中已经有了该名称的方法实现,那么将添加失败 */&#125; Propertytypedef struct objc_property *objc_property_t;属性相关信息typedef struct &#123; const char *name; const char *value; &#125; objc_property_attribute_t;获取属性objc_property_t class_getProperty(Class cls, const char *name)获取属性列表objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)获取属性信息列表objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)获取属性信息中某个Valuechar *property_copyAttributeValue(objc_property_t property, const char *attributeName)添加属性BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)替换属性void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)获取属性名称const char *property_getName(objc_property_t property) 获取属性相关信息const char *property_getAttributes(objc_property_t property) 实例演示 - (void)viewDidLoad &#123;YAPerson *person = [[YAPerson alloc] init]; Class cls = [person class]; // 获取属性 objc_property_t property = class_getProperty(cls, "school"); // 获取属性名称 const char *propertyName = property_getName(property); printf("%s\n",propertyName); // 获取属性信息列表 // objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount) // 获取属性相关信息 const char *propertyAttributes = property_getAttributes(property); printf("%s\n",propertyAttributes); // 打印 T@"NSObject",W,N,V_school // 根据获取属性信息中的name获取对应的Value char *propertyValue = property_copyAttributeValue(property, "T"); // 类型 printf("%s\n",propertyValue); /* T 类型 例如:NSObject V 值(成员变量) 例如 _school C copy N nonatommic */ // 添加属性 objc_property_attribute_t type = &#123; "T", [[NSString stringWithFormat:@"@\"%@\"",NSStringFromClass([NSString class])] UTF8String] &#125;; //type objc_property_attribute_t ownership0 = &#123; "C", "" &#125;; // C = copy objc_property_attribute_t ownership = &#123; "N", "" &#125;; //N = nonatomic objc_property_attribute_t backingivar = &#123; "V", [[NSString stringWithFormat:@"_%s", "propertyName"] UTF8String] &#125;; //variable name objc_property_attribute_t attrs[] = &#123; type, ownership0, ownership, backingivar &#125;; if (class_addProperty(cls, "propertyName", attrs, 4)) &#123; NSLog(@"添加成功"); &#125; // 替换属性 //void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount) &#125;/** 根据class获取类的属性列表 @param class 类 @return 属性列表数组 */+ (NSArray *)ya_getPropertyList:(Class)class &#123; // 私有/公有/类扩展中的所有属性数量 unsigned int count = 0; // 获取属性列表 objc_property_t *propertyList = class_copyPropertyList(class, &amp;count); // 存储属性名称 NSMutableArray *array = [NSMutableArray array]; for (unsigned int i = 0; i &lt; count; i ++) &#123; const char* c_propertyName = property_getName(propertyList[i]); [array addObject:[NSString stringWithUTF8String:c_propertyName]]; &#125; // 手动释放 free(propertyList); return [NSArray arrayWithArray:array];&#125; Protocol本部分应用较少,未做详细实践. struct objc_protocol_list &#123; struct objc_protocol_list *next; long count; __unsafe_unretained Protocol *list[1];&#125;;是否遵循协议BOOL class_conformsToProtocol(Class cls, Protocol *protocol)协议列表Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount)Protocol * __unsafe_unretained *objc_copyProtocolList(unsigned int *outCount)Protocol * __unsafe_unretained *protocol_copyProtocolList(Protocol *proto, unsigned int *outCount)动态添加协议BOOL class_addProtocol(Class cls, Protocol *protocol) 获取指定名称的协议Protocol *objc_getProtocol(const char *name)协议A是否遵循协议BBOOL protocol_conformsToProtocol(Protocol *proto, Protocol *other)两个协议是否相等BOOL protocol_isEqual(Protocol *proto, Protocol *other)获取某个协议的名称const char *protocol_getName(Protocol *p)动态生成协议Protocol *objc_allocateProtocol(const char *name)void objc_registerProtocol(Protocol *proto) 给协议添加方法void protocol_addMethodDescription(Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod) 给协议添加协议void protocol_addProtocol(Protocol *proto, Protocol *addition) 给协议添加属性void protocol_addProperty(Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)/** 根据class获取遵循的协议列表 @param class 类 @return 协议名称列表 */+ (NSArray *)ya_getProtocolList:(Class)class &#123; // 协议列表数量 unsigned int count = 0; // 获取协议列表 __unsafe_unretained Protocol **protocolList = class_copyProtocolList(class, &amp;count); // 存储协议 NSMutableArray *array = [NSMutableArray array]; for (NSInteger i = 0; i &lt; count; i ++) &#123; // 获取协议 Protocol *protocol = protocolList[i]; // 获取协议名称 const char *c_protocolName = protocol_getName(protocol); [array addObject:[NSString stringWithUTF8String:c_protocolName]]; &#125; // 手动释放 free(protocolList); return [NSArray arrayWithArray:array];&#125; 二、技能消息转发+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel_isEqual(sel, NSSelectorFromString(@"ss"))) &#123; // 要求参数要匹配 [YARuntime ya_addMethod:[self class] newSEL:sel existSEL:@selector(printPersonalInfo)]; return YES; &#125; return [super resolveInstanceMethod:sel]; &#125; - (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (sel_isEqual(aSelector, NSSelectorFromString(@"ss"))) &#123; // 转发给已经存在的对象 return [[YAPerson alloc] init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; // 没有找到signature(方法签名),只能手动提供 if (signature == nil) &#123; signature = [NSMethodSignature signatureWithObjCTypes:"@@:"]; &#125; return signature;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; YAPerson *personClass = [[YAPerson alloc] init]; SEL sel = anInvocation.selector; if ([personClass respondsToSelector:sel]) &#123; // 最后一次机会 [anInvocation invokeWithTarget:personClass]; &#125; else &#123; // 回天乏力 [self doesNotRecognizeSelector:sel]; &#125;&#125; 多重继承 不会做菜的程序员不是好男人。 YADeveloper 继承自 YAMan,想让YADeveloper实例对象同时具备响应 YAMan方法和 YACook方法的能力。 YAMan: @interface YAMan : NSObject- (void)printMan;@end@implementation YAMan- (void)printMan &#123; NSLog(@"我是一个男人");&#125;@end YACook: @interface YACook : NSObject - (void)printCook;@end@implementation YACook- (void)printCook &#123; NSLog(@"我是个会做菜的人");&#125;@end YADeveloper: @class YACook;@interface YADeveloper : YAMan@property (nonatomic,strong) YACook *cook;- (void)printDev;// 声明YACook的方法,使编译通过- (void)printCook;@end@implementation YADeveloper- (void)printDev &#123; NSLog(@"我是个会写程序的人");&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (sel_isEqual(aSelector, NSSelectorFromString(@"printCook"))) &#123; // 需要预先对self.cook初始化 return self.cook; // 或者直接创建 // return [[YACook alloc] init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125;@end 关联引用注意点: objc_removeAssociatedObjects 函数一般不可手动调用，因为这个函数会移除一个对象的所有关联对象，将该对象恢复成“原始”状态。这样做就很有可能把别人添加的关联对象也一并移除，这并不是我们所希望的。所以一般的做法是通过给 objc_setAssociatedObject 函数传入 nil 来移除某个已有的关联对象。 关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的。给分类添加weak属性 给任意对象A 添加 weak属性 B 问题关键点:在属性销毁的时候，将其置为空(或者说在关联对象销毁的时候，使objc_getAssociatedObject得到的是nil)。 方法一通过继承关联对象B ，重写其dealloc方法即可适时把A中的关联对象返回值设置为nil，达到自动置空的目的，这也是最本能的方法。 给NSObject添加分类，也即任何继承自NSObject的对象都可以有weak属性。 @interface NSObject (YAWeakProperty)@property (nonatomic, weak) YAProperty *property;@end@implementation NSObject (YAWeakProperty)// const static char *key = "key";- (id)property &#123; return objc_getAssociatedObject(self, @selector(property));&#125;- (void)setProperty:(YAProperty *)property &#123; objc_setAssociatedObject(self, @selector(property), property, OBJC_ASSOCIATION_ASSIGN); [property setAssociate:self selector:@selector(setProperty:)];&#125;@end 关联引用的key一般使用getter方法的selector，此时get方法中的key也可使用_cmd，二者等效。 属性的实现: @interface YAProperty : NSObject- (void)setAssociate:(NSObject *)associatedObject selector:(SEL)sel;@end// 类扩展@interface YAProperty()&#123; __weak id _associatedObject; SEL _sel;&#125;@end@implementation YAProperty- (void)setAssociate:(NSObject *)associatedObject selector:(SEL)sel &#123; _associatedObject = associatedObject; _sel = sel;&#125;- (void)dealloc &#123; ((void (*)(id, SEL,id)) objc_msgSend)(_associatedObject, _sel, nil);&#125;@end 然而有个问题:添加的属性继承自NSObject时非常完美，但是实际项目中不可能给任意对象添加的属性都是NSObject，有可能是NSString/NSArray/NSDictionary/NSSet等等。那么就只能继承自NSString/NSArray/NSDictionary/NSSet等系统类，这样会出现一系列一系列一系列问题，苹果并不建议我们使用NSString/NSArray/NSDictionary/NSSet等的派生类(这些类已经足够好了，不需要画蛇添足)。 方法二 用一个NSPointerArray（弱引用类型的数组）包一层就可以了。虽然关联属性的policy不支持weak，但是你可以把要关联的对象放入一个弱引用数组里面，然后把这个弱引用数组设置为关联对象，每次取值的时候，只需要从这个弱引用数组里面取就可以了。一样可以达到关联弱引用对象的效果。 方法三A 关联 CB 关联 CC 销毁 通知BB 再告诉 A 三、要点free()free() 函数用来释放动态分配的内存空间，其原型为： void free (void* ptr);free() 可以释放由 malloc()、calloc()、realloc() 分配的内存空间，以便其他程序再次使用。// 及时释放字符串常量if (argumentType) free(argumentType); NONNULLNS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。在这两个宏之间的代码，所有简单指针对象都被假定为 nonnull#define NS_ASSUME_NONNULL_BEGIN _Pragma("clang assume_nonnull begin")#define NS_ASSUME_NONNULL_END _Pragma("clang assume_nonnull end") __covariant__covariant - 协变性，子类型可以强转到父类型（里氏替换原则）__contravariant - 逆变性，父类型可以强转到子类型（WTF） __kindof 内联__attribute__((always_inline)) 的意思是强制内联 参考并感谢青玉伏案南峰子]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找算法总结]]></title>
    <url>%2F2017%2F04%2F21%2F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于查找算法。 前言 本文”完全二叉树”的定义采用国内定义B-树 即 B树,两者是相同概念,而非指二叉搜索树(百度百科) 争议1.国内早期教材中，满二叉树一般指 perfect binary tree，所以会有满二叉树是完全二叉树的一个特例的说法. 2.树的深度的定义，有的根结点从0开始计数，有的从1开始计数. 3.结点 与 节点 是对Node的翻译,可以看做等同. 维基百科定义1.根二叉树(Rooted Binary Tree)：有一个根结点，每个结点至多有两个孩子。 2.满二叉树(Full Binary Tree)：要么是叶子结点(结点的度为0)，要么结点同时具有左右子树(结点的度为2)。 3.完全二叉树(Complete Binary Tree)：每层结点都完全填满，在最后一层上如果不是满的，则只缺少右边的若干结点。 4.完美二叉树(Perfect Binary Tree)所有的非叶子结点都有两个孩子，所有的叶子结点都在同一层。即每层结点都完全填满。 5.无限完全二叉树(Infinite Complete Binary Tree)： 每个结点都有两个孩子，结点的层数是无限的。 6.平衡二叉树(Balanced Binary Tree)：也称为AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 满二叉树(Full Binary Tree)如果一棵二叉树的结点要么是叶子要么有两个孩子结点,则为满二叉树 性质:1.总结点个数呈现个数为:0 1 3 7 15…满足2^(n) -1,其中n为树的深度(最大层) 2.第k层(k不为0)结点个数:1 2 4 8…满足2^(k - 1) 3.满二叉树是完全二叉树 完全二叉树(Complete Binary Tree)若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。 性质:完全二叉树中度为1的结点数只有两种可能0或1,那么:总结点数为n,有 n0=n/2 或 n0=(n+1)/2 存储顺序存储的排序数组插入和删除的时候时间复杂度达到O(n),顺序存储结构不适于动态的情况 链式存储链表的查找需要O(n) 查找查找表:由同一类型的数据元素构成的集合.关键字:数据元素中某个数据项的值.主关键字:可以唯一地标识一个记录.次关键字:可以识别多个数据元素.查找:根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素(或记录).静态查找表:只作查找操作的查找表.动态查找表:在查找过程中同时插入查找表中不存在的数据元素,或者从查找表中删除已经存在的某个数据元素. 顺序表查找顺序查找(线性查找):从表中第一个记录开始,逐个进行记录的关键字和给定值的比较. # 顺序查找的实现def sequentialSearch(key, numbers): length = len(numbers) for i in xrange(length): # 查找成功返回索引 if key == numbers[i]: return i # 查找失败返回-1 return -1 最好情况:在第一个位置找到,时间复杂度为O(1)最坏情况:在最后一个位置找到,时间复杂度O(n)查找不成功:时间复杂度O(n)平均查找次数:(n+1)/2平均时间复杂度:O(n) 有序表查找1.二分查找 折半查找(二分查找):在线性表中的记录有序的前提下进行查找.取中间元素作为比较对象,若给定值与中间元素相等,则查找成功,若给定值小于中间元素,则在中间元素的左半区继续查找,若给定值大于中间元素,则在中间元素的右半区继续查找,不断重复查找过程,直到查找成功,或查找失败. # 二分查找的实现def binarySearch(key, numbers): # 左边界 low = 0 # 右边界 high = len(numbers) - 1 while low &lt;= high: # 中间元素索引 mid = (low + high) / 2 # 查找成功 if numbers[mid] == key: return mid # 在左区间 if numbers[mid] &gt; key: high = mid - 1 # 在右区间 if numbers[mid] &lt; key: low = mid + 1 # 查找失败返回-1 return -1 最好情况:是中间元素,一次即可找到,时间复杂度O(1)最坏情况:完全二叉树的深度加1,即floor(logn) + 1次,时间复杂度O(logn).(注意:logn这里指以2为底,floor表示向下取整) 2.插值查找二分查找的优化版,核心是插值公式:(key - numbers[low]) / (numbers[high] - numbers[low]) 核心代码: // 插值mid = low + (high - low) * (key - numbers[low]) / (numbers[high] - numbers[low]) # 插值查找的实现def interpolationSearch(key, numbers): # 左边界 low = 0 # 右边界 high = len(numbers) - 1 while low &lt;= high: # 核心代码 mid = low + (high - low) * (key - numbers[low]) / (numbers[high] - numbers[low]) # 查找成功 if numbers[mid] == key: return mid # 在左区间 if numbers[mid] &gt; key: high = mid - 1 # 在右区间 if numbers[mid] &lt; key: low = mid + 1 # 查找失败返回-1 return -1 从时间复杂度上,依然是O(logn),但是对于表长较大,关键字分布比较均匀的查找表,性能相对二分查找更好.但是,分布极不均匀的数据,不是很合适,比如[1,2,4,3000,3003…9988899,8988998] 插值查找在实际使用时，一般要满足两个假设条件： (1)每一次对数据的访问与通常的指令相比，费用都是相当昂贵的。例如，待查找的表一定是在磁盘而非内存中，因而每一次比较都要进行磁盘访问。 (2)数据不仅是已被排好序的，而且呈现均匀分布特征。 3.斐波那契查找利用黄金分割原理实现,折半查找算法来进行修改和改进.对于斐波那契数列,前后两个数字的比值随着数列的增加,越来越接近黄金比值:0.618 0.01.00.50.6666666666670.60.6250.6153846153850.6190476190480.6176470588240.6181818181820.617977528090.6180555555560.6180257510730.6180371352790.6180327868850.6180344478220.61803381340.6180340557280.6180339631670.618033998522...... 对于斐波那契数列:0 1 1 2 3 5 8 13 21 34 55 89 … 原理:比如这里的89，假定它是整个有序表的元素个数，而89是由前面的两个数34和55相加之后的和，也即把元素个数为89的有序表分成由前55个数据元素组成的前半段和由后34个数据元素组成的后半段，那么前半段元素个数和整个有序表长度的比值就接近黄金比值0.618，假如要查找的元素在前半段，那么继续按照斐波那契数列来看，55 = 34 + 21，所以继续把前半段分成前34个数据元素的前半段和后21个元素的后半段，继续查找，如此反复，直到查找成功或失败. 当有序表的元素个数不是斐波那契数列中的某个数字时，需要把有序表的元素个数长度补齐，让它成为斐波那契数列中的一个数值,也即把需要补齐的的元素都赋值为有序表的最大值。 核心:(1)当key == numbers[mid],查找成功(2)当key &lt; numbers[mid],新范围是第low个到第mid-1个,范围个数是F(k-1) - 1个,即有序列表左边的长度(3)当key &gt; numbers[mid]时,新范围是第mid+1到第high个,范围个数是F(k-2) - 1个,即有序列表右边的长度 k 表示列表的长度k-1表示索引F(k-1)表示列表最后一个元素 元素总个数 = 左区间个数 + 右区间个数 + 中间的一个元素,即: F(k)-1 = F(k-1)-1 + F(k-2)-1 + 1 斐波那契查找算法如下： # 斐波那契查找def Fbonacci(index): if index &lt; 0: return a, b = 0, 1 for i in range(index): a, b = b, a + b return a def FbonacciSearch(key, numbers): # 确定该序列在斐波那契数列中的位置 n, length = 0, len(numbers) while length &gt; Fbonacci(n) - 1: n += 1 # 填满元素 for i in xrange(n,Fbonacci(n)): numbers.append(numbers[-1]) low, high = 0, n - 1 while low &lt;= high: # 获取黄金分割下标 mid = low + Fbonacci(n - 1) - 1 # 左区间 #若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1 if key &lt; numbers[mid]: high = mid - 1 n -= 1 # 右区间 #若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1 if key &gt; numbers[mid]: low = mid + 1 n -= 2 # 相等 else: # 成功找到 if mid &lt;= n: return mid # 补全的数,返回n else: return n return -1 4.比较二分查找是加法与除法运算插值查找是复杂的四则运算斐波那契查找是加减法运算 线性索引查找索引:把一个关键字与它对应的记录相关联的过程.线性索引:把索引项集合组织为线性结构,也即索引表 1.稠密索引稠密索引:将数据集的每个记录对应一个索引项,且索引项一定按照关键码有序排列. 2.分块索引对数据集进行分块,使分块有序,然后对每一块建立一个索引项,从而减少索引项的个数. 块需要满足的条件:(1)块内无序:每一块的记录不要求有序.(2)块间有序:比如,要求第二块所有记录的关键字均要大于第一块所有记录的关键字.第三块大于第二块… 分块索引的索引项结构: 最大关键码:存储每一块中点最大关键字 存储块中记录的个数,便于循环 用于指向块首数据元素的指针,便于遍历 查找分两步:(1)在分块索引表中查找关键字所在的块.(2)根据块首指针找到相应的块,并在块中顺序查找关键码. 设n个记录被平均分成m块,每个块t条记录,则n=mt查找索引表的平均查找长度:(1+m)/2查找记录的平均查找长度:(t+1)/2 则块中查找记录的平均查找长度: (1+m)/2 + (t+1)/2 = (m+t)/2+1 = (n/t+t)/2+1 最佳情况:m与t相等,也即n = t^2 = m^2 ,则原式为: = (t*t/t+t)/2+1 = t+1 = n^0.5 + 1 (^ 表示次方) 由此分块索引比顺序查找O(n)提高不少. 3.倒排索引索引项的结构:次关键码与记录号表根据属性(次关键码,字段)的值查找记录.该索引表中的每一项包括一个属性值和具有该属性值的各记录的地址.由于不是由记录确定属性值而是由属性值确定记录,因而称为倒排索引. 优点:生成索引表后不用读取记录就可知道结果,查找非常快缺点:记录号不定长 二叉搜索树如果查找的数据集是有序线性表,并且是顺序存储的,可以使用二分查找/插值查找/斐波那契查找,但是在插入删除操作上耗费大量时间,由此引出既可以使得插入删除效率不错又可以高效率查找的算法====&gt;使用二叉树数据结构:在创建集合时就考虑使用二叉树结果,而且是排好序的二叉树.构造二叉搜索树的目的不是为了排序,而是为了提高插入/删除的效率. 二叉查找树,也称(二叉搜索树,有序二叉树,排序二叉树,二叉排序树）,是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 性质:1.左小于根小于右2.值不重复3.”中序遍历“可以让结点有序4.二叉搜索树有两种结点删除方式:取被删除结点的右子树中的最小元素替代或者取被删除结点的左子树中的最大元素替代 优势:查找、插入的时间复杂度较低。为O(log n)二叉查找树的最坏效率是O(n),此时退化为线性结构 # -*- coding:utf-8 -*-class BinarySearchTreeNode(): def __init__(self,val = 0): self.val = val self.left = None self.right = None # 寻找结点 def find(self, data): if self.val == data: return True elif data &lt; self.val and self.left: return self.left.find(data) elif data &gt; self.val and self.right: return self.right.find(data) else: return False # 寻找最小结点 def findMinData(self): if self.left: return self.left.findMinData() else: return self.val # 寻找最大结点 def findMaxData(self): if self.right: return self.right.findMaxData() else: return self.val # 插入结点 # 当data与二叉搜索树中某结点val相等时不作处理 def insertNode(self, data): # 在右子树上 if self.val &lt; data: if self.right: self.right.insertNode(data) else: self.right = BinarySearchTreeNode(data) # 在左子树上 if self.val &gt; data: if self.left: self.left.insertNode(data) else: self.left = BinarySearchTreeNode(data) # 打印二叉搜索树 # 左根右遍历 def printTree(self): if self.left: self.left.printTree() print self.val, if self.right: self.right.printTree() # 结点的删除 # 当删除一个叶子结点时,直接删除即可 # 当删除的结点只有一个孩子时,用该孩子替换 # 当删除的结点有两个孩子时,寻找该结点右子树中的最小数据代替子节点 def daleteNode(self, data): # 前提是该结点在二叉搜索树中能找到 if not self.find(data): return self if data &lt; self.val: self.left = self.left.daleteNode(data) return self elif data &gt; self.val: self.right = self.right.daleteNode(data) return self elif self.left and self.right: # 找到右子树最小的结点,获取值 val = self.right.findMinData() # 把最小结点的值给自己 self.val = val # 删除右子树中的最小结点,使self.right指向右子树的根节点 # self.right.daleteNode(val)最终返回右子树的根节点 self.right = self.right.daleteNode(val) return self else: # 左结点存在 if self.left: # 直接指向左结点 return self.left # 右结点存在,或不存在结点 else: # 直接指向右结点 return self.righta = BinarySearchTreeNode(10)a.insertNode(8)a.insertNode(12)a.insertNode(6)a.insertNode(9)a.insertNode(11)a.insertNode(14)a.insertNode(7)a.insertNode(13)a.insertNode(5)a.insertNode(2)a.printTree()print "\n"print a.find(11)print a.find(100000)print a.findMaxData()print a.findMinData()a.daleteNode(1000000)a.daleteNode(10)a.daleteNode(14)a.daleteNode(2)a.printTree() 二叉搜索树以链接的方式存储,保持了链接存储结构在执行插入或删除时的优越性. 对于二叉搜索树的查找,比较次数等于给定值的结点在二叉搜索树的层数.最少为1次(为根节点),最多不超过树的深度(最差是极端的右斜树或左斜树). 二叉排序树倘若是平衡的,其深度与完全二叉树相同,均为floor(logn) + 1,查找的时间复杂度为O(logn),近似与折半查找,若不是平衡的,甚至演化为极端的右斜树或左斜树,查找的时间复杂度为O(n),等同于顺序查找. 因此,平衡至关重要. 平衡二叉树(AVL树)平衡二叉搜索树是改进的二叉搜索树,也是二叉搜索树。 一般的二叉搜索树的查询复杂度是跟深度有关，因此当结点的深度普遍较大时，查询的均摊复杂度会上升，为了更高效的查询，平衡树应运而生了。 可以使查找树的高度为 O (log(n)) 定义:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 AVL树中的每个结点都有一个平衡因子（balance factor，BF），它表示这个结点的左、右子树的深度差，也就是左子树的深度减去右子树的深度的结果值。AVL树上所有结点的BF值只能是-1、0、1。反之，只要二叉树上一个结点的BF的绝对值大于1，则该二叉树就不是平衡二叉树。在进行插入和删除的时候找出失去平衡的节点，进行必要的旋转操作保证树的平衡。 查找、插入和删除在平均和最坏情况下都是O（log n） 最少结点设n(h)是高度为h的AVL树，则结点数最少时有:n(h) = n(h-1) + n(h-2) + 1 h(VAL树的高度) 最少结点数 0 1 1 2 2 4 3 7 4 12 5 20 … … 显而易见，满足的关系为:高度为h的AVL树，其最少结点数量为F(h+2) - 1，其中F(x)为斐波那契数列逗号且规定从1开始，即F(0) = 1，F(1) = 2 调整RR(右单旋):麻烦结点在发现结点的右子树的右子树上 RL():麻烦结点在发现结点的右子树的左子树上 LL(左单旋):麻烦结点在发现结点的左子树的左子树上 LR():麻烦结点在发现结点的左子树的右子树上 堆堆:用数组表示的完全二叉树有序性:任一结点的关键字是其子树所有结点的最大值(或者最小值)，从根结点到任意结点路径上结点序列的有序性。最大堆,也称为大顶堆:最大值最小堆,也称为小顶堆:最小值 最大堆的建立:方法一:自底向上调整堆，首先将n个节点按输入顺序存入，使其满足完全二叉树的结构特性，然后调整各节点的位置。 方法二:通过插入操作，将n个元素一个个地相继插入到一个初始为空的堆中，其时间代价最大为O(nlogn)。 堆顶元素的删除元素的插入 哈夫曼树带权路径长度:设二叉树有n个叶子节点，每个叶子节点带有权值W，从根节点到每个叶子节点的长度为L，则每个叶子节点的带权路径长度之和为WPL=∑WL。哈夫曼树即是最优二叉树:WPL最小的二叉树。 性质: 没有度为1的结点(按照构造哈夫曼树的规则，显而易见)。 n个叶子节点的哈夫曼树共有 2 * n - 1个结点。 哈夫曼树的任意非叶子结点的左右子树交换后仍是哈夫曼树。 对同一组权值的，可能存在不同结构的几棵哈夫曼树，但是它们的WPL是相同的。 性质2推导:根据哈夫曼树没有度为1的结点，则 n1 = 0，又根据 n0 = n2 + 1，sum = n0 + n1 + n2，则有: sum = n0 + n1 + n2 = n0 + n2 = n0 + n0 - 1 = 2 * n0 - 1 = 2 * n - 1 // n即n0 图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片 图a的WPL为 5 2 + 7 2 + 2 2 + 13 2 = 54图b的WPL为 13 1 + 7 2 + 2 3 + 5 3 = 48PL的计算方式为:该节点的权值 * 从根节点到该节点的树枝数量 哈夫曼树的构造:每次把权值最小的两个二叉树合并，参照最大堆的调整。 红黑树红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求： （1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]（4）每个红色节点必须有两个黑色的子节点。（5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。 一棵n个结点是红黑树始终保持了logn的高度,所以红黑树的查找、插入、删除的时间复杂度最坏为O(log n) 红黑树之所以是平衡的二叉查找树，是因为每个节点都有表示其颜色的域值：红或黑，在插入和删除操作的时候依据节点的颜色向平衡的方向调整。 “叶结点” 或”NULL结点”，它不包含数据而只充当树在此结束的指示，这些结点以及它们的父结点，在绘图中都会经常被省略。 当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。 为了继续保持红黑树的性质，我们可以通过对结点进行重新着色，以及对树进行相关的旋转操作 左旋:左右左右旋:右左右 多路查找树(B树)B树即为B-树、B_树,又叫平衡多路查找树.多路查找树:其每一个结点的孩子数可以多于两个,每一个结点处可以存储多个元素. 一个节点只能存储一个元素,在元素非常多的时候,就使得要么树的度非常大,要么树的高度非常大,甚至两者都必须足够大才可以,这使得内存存取外村次数非常多,造成了时间效率上的瓶颈,于是引入多路查找树. 树的高度越高，查找文件所需要的磁盘IO读写次数越多，所以为了减少磁盘的IO读写，要想办法进一步降低树的高度。 因此，具有多个孩子的B树便应运而生，因为B树每一个结点可以有几个到几千个孩子，使得在结点数目一定的情况下，树的高度会大大降低，从而有效减少磁盘IO读写消耗。 B+树、B树等的根结点和部分顶层数据存在内存中，大部分下层数据存在磁盘上。 2-3树2-3树是这样一棵多路查找树:其中的每一个结点都具有两个孩子或三个孩子. 一个2结点包含一个元素和两个孩子(或没有孩子),与二叉排序树类似,左子树包含的元素小于该元素,右子树包含的元素大于该元素,与二叉排序树不同的是,这个2结点要么没有孩子,要么就有两个,不能只有一个孩子. 一个3结点包含一小一大两个元素和三个孩子(或没有孩子),一个3结点要么没有孩子,要么具有3个孩子.如果具有3个孩子的话,左子树包含的元素小于较小元素的元素,右子树包含的元素大于较大元素的元素,中间子树包含介于两元素之间的元素. 并且2-3树中所有叶子都在同一层次上. 2-3树的插入 2-3树的删除 2-3-4树2-3树的概念扩展,包括了4结点的使用.一个4结点包含小中大三个元素和四个孩子(或者没有孩子). B树B树是一种平衡的多路查找树,2-3树和2-3-4树都是B树的特例.结点最大的孩子数目称为B树的阶.2-3树是3阶B树,2-3-4树是4阶B树. A B-tree of order m is a tree which satisfies the following properties: Every node has at most m children. Every non-leaf node (except root) has at least ⌈m/2⌉ children. The root has at least two children if it is not a leaf node. A non-leaf node with k children contains k−1 keys. All leaves appear in the same level 一棵m阶的B树满足以下条件1.每个结点至多有m棵子树2.除根结点外,其他分支结点至少有ceil(m/2)棵子树(ceil()函数向上取整3.根结点至少有两棵子树,除非树只包含一个结点4.有k个孩子的非叶结点有k-1个关键码,关键码按递增次序排列5.所有叶子结点在同一层 B树如何做到减少访问外存次数硬盘将信息分割成相等大小的页面,每次硬盘读写都是一个或者多个完整的页面,对一个硬盘来说,一页的长度可能是211到214字节. 在一个典型的B树应用中,要处理的硬盘数据量很大,因此无法一次全部装入内存,因此需要对B树进行调整,使得B树的阶树与硬盘存储的页面大小相匹配.在有限内存的情况下,每一次磁盘的访问我们都可以获得最大量的数据,由于B树每节点可以具有比二叉树多得多的元素,所以减少了必须访问结点和数据块的数量,提高了性能.B树的数据结构就是为内外存的数据交互准备的. B+树B+ 树是一种树数据结构，通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。 B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。 一棵m阶的B+树与B树的区别在于: 有n棵子树的结点包含有n个关键字 所有的叶子节点包含全部的关键字信息,以及指向含这些关键字记录的指针,叶子节点本身依关键字的大小自小而大顺序链接 所有分支结点可以看成是索引,结点中仅含有其子树的最大(最小)关键字. 好处:如果要随机查找,就从根节点出发,与B树的查找方式相同,只不过即使在分支结点找到了待查找的关键字,它也只是用来索引的,不能提供实际记录的访问,还是需要到达包含此关键字的终端结点. 如果需要从最小关键字进行自小而大的顺序查找,可以从最左端的叶子结点出发,不经过分支结点,而是沿着指向下一叶子的指针就可遍历所有的关键字. B+树适合有范围的查找(比如年龄18–22),从根节点出发找到18,再在叶子结点中按顺序找到符合要求的记录. B+树的插入/删除与B树类似,只不过插入删除的元素都是在叶子结点上进行. 散列表查找存储位置 = f(关键字) 记录的存储位置和它的关键字之间建立的一个确定的对应关系.每个关键字key对应一个存储位置f(key),查找时根据这个确定的对应关系找到给定key的映射f(key). f称为散列函数,又称哈希函数,采用散列技术将记录存储在一块连续的存储空间中,这块连续的存储空间称为散列表或哈希表,关键字对应的记录存储位置称为散列地址. 冲突:key1不等于key2,但是f(key1)=f(key2),key1和key2称为散列函数的同义词. 常用的散列函数1.直接定址法f(key) = a * key + b (a,b为常数) 优点:简单均匀,不会产生冲突,但需要事先知道关键字的分布情况,适合查找表较小且连续的情况. 2.数字分析法手机号码等,对数字进行抽取,反转,左环位移,右环位移等方式合理地将关键字分配到散列表的各位置. 适合处理关键字位数比较大的情况,如果事先知道关键字的分布且关键字的若干位分布均匀,可以使用. 3.平方取中法关键字1234—-&gt;平方后:1522756—–&gt;抽取中间的3位——&gt;227,用作散列地址. 适合不知道关键字的分布,而位数又不是很大的情况 4.折叠法从左到右分割成位数相等的几部分,叠加求和,按照散列表长,取后几位作为散列地址. 9876543210—–&gt;987 654 321 0—–&gt;求和987+654+321+0=1962,求后三位:962 适合不需要事先知道关键字的分布.适合关键字位数较多的情况. 5.除留余数法最常用,散列表长为m的公式: f(key) = key mod p (p&lt;=m) 若散列表表长m,通常p为小于或者等于表长的最小质数或不包含小于20质因子的合数. 6.随机数法f(key) = random(key) 当关键字的长度不等时,采用这个方法. 常用的处理冲突方法1.开放定址法线性探测法 f(key) = (f(key) + d) mod m (d = 1,2,3...) 二次探测法 f(key) = (f(key) + d) mod m (d = 1^2,-1^2,2^2,-2^2,3^2,-3^2...q^2,-q^2,其中q&lt;=m/2) 随机探测法 f(key) = (f(key) + d) mod m (d 是一个随机数列) 2.再散列函数法f(key) = RH(key) 每次发生散列冲突时,就换一个散列函数计算. 3.链地址法提供绝不会找不到地址的保障,但是带来查找时需要遍历单链表的性能损耗. 4.公共溢出区法增添溢出表.对给定值通过散列函数计算出散列地址后,先与基本表的相应位置进行比对,如果相等,成功,否则,到溢出表中进行顺序查找. 参考并致谢知乎 灰杉树HAIYANG XUv_JULY_v]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《Objective-C高级编程》]]></title>
    <url>%2F2017%2F04%2F13%2F%E8%AF%BB%E3%80%8AObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[关于ARC/Block/GCD。 读感寒假里就大致看了一遍，但是吸收的不完全，尤其是block部分。这两三天又赶紧从图书馆借来翻一翻，还是收获满满。不过C++不够扎实，很多源码还是看不明白(摊手)。这里把一些重点问题整理出来，以问答的形式进行总结，所有代码都尝试验证一下，没毛病。 问题一.为什么苹果主要采用散列表管理引用计数GNUstep将引用计数保存在对象占用内存块头部的变量中。优点： 只需少量代码。 能统一管理引用计数用内存块与对象用内存块。 苹果采用散列表（引用计数表，DenseMap 类实现）管理引用计数。优点： 对象用内存块的分配无需考虑内存块头部。 引用计数表记录中存有内存块地址，可追溯各对象的内存块。有助于检测对象的持有者是否存在，可检测内存泄漏。 注:如果设备是 64 位环境并且使用 Objective-C 2.0，那么“一些”对象会使用其 isa 指针的一部分空间来存储它的引用计数。 苹果为什么不采用垃圾回收（GC）？ 苹果曾在OS X 10.5 尝试使用，不过在 10.7 的时候把 GC 换成了 ARC。GC 有个问题让苹果不能忍：垃圾回收的时候，整个程序需要暂停，英文把这个过程叫做：Stop the World。所有的对象都需要一起回收时，造成用户体验不好。 ARC相对于GC所具有的优点： ARC工作在编译期，在运行时没有额外开销。 ARC的内存回收是平稳进行的，对象不被使用时会立即被回收。而GC的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。 简单介绍GC的原理基于事实：大部分的对象的生命期都很短。 GC 将内存中的对象主要分成两个区域：Young 区和 Old 区。对象先在 Young 区被创建，然后如果经过一段时间还存活着，则被移动到Old 区。（其实还有一个Perm区，但是内存回收算法通常不涉及这个区域） Young区的对象因为大部分生命期都很短，每次回收之后只有少部分能够存活，所以采用的算法叫Copying算法，简单说来就是直接把活着的对象复制到另一个地方。Young 区内部又分成了三块区域：Eden区 ,From区 ,To区。每次执行 Copying 算法时，即将存活的对象从 Eden 区和 From 区复制到To区，然后交换 From 区和To区的名字（即From 区变成 To 区，To区变成From区）。 Old区的回收算法叫 Mark-Sweep 算法。简单来说，就是只是把不用的对象先标记（Mark）出来，然后回收（Sweep），活着的对象就不动它了。因为大部分对象都活着，所以回收下来的对象并不多。但是这个算法会有一个问题：它会产生内存碎片，所以它一般还会带有整理内存碎片的逻辑，在算法中叫做 Compact。 二.如何提高Objective-C方法的速度采用IMP Caching。一般而言速度是其他方法的两倍。 id autorelease_class = [NSAutoreleasePool class];SEL autorelease_sel = @selector(addObject:);IMP autorelease_imp = [autorelease_class methodForSelector:autorelease_sel];- (id) autorelease&#123; (* autorelease_imp)(autorelease_class,autorelease_sel,self);&#125;- (id)autorelease&#123; [NSAutoreleasePool addObject:self];&#125; IMP的使用:实例方法+有参数+有返回值 IMP默认是无参数，无返回值类型，且自带_cmd和selector。如果要使用带参数或者带返回值的IMP有两种方法。方式一：关闭Xcode中的编译选项。 方式二：重新定义一个“IMP”，但不能同名，否则会报错，显示 Typedef redefinition with different types (&#39;id (*)(__strong id, SEL, ...)&#39; vs &#39;void (*)(void)&#39;) 这里统一采取第二种方式，即重新定义函数指针_IMP。 typedef id (*_IMP)(id, SEL,...); // .h文件- (NSString *)print:(NSString *)name; // .m文件- (NSString *)print:(NSString *)name &#123; NSLog(@"%@",name); NSLog(@"因为我刚好遇见你"); return name;&#125; // 调用// 创建对象YAUser *user = [[YAUser alloc] init];user.name = @"张无忌";// 获取SELSEL sel = @selector(print:);// 获取函数指针_IMP instanceIMP1 = (_IMP)[YAUser instanceMethodForSelector:sel];_IMP instanceIMP2 = (_IMP)[user methodForSelector:sel];// 调用方法并返回字符串NSString *name1 = (*instanceIMP1)(user, sel, user.name);NSString *name2 = (*instanceIMP2)(user, sel, user.name);NSLog(@"%@--%@",name1, name2); IMP的使用:类方法+有参数+有返回值 + (NSString *)printClassName:(Class)className; + (NSString *)printClassName:(Class)className &#123; NSLog(@"%@",className); NSLog(@"原谅我这一生不羁放纵爱自由"); return NSStringFromClass(className);&#125; // 调用// 创建对象YAUser *user = [[YAUser alloc] init];// 获取SELSEL sel = @selector(printClassName:);// 获取函数指针_IMP classIMP = (_IMP)[[YAUser class] methodForSelector:sel];// 调用方法并返回字符串NSString *name = (*classIMP)(user, sel, [user class]);NSLog(@"%@",name); 实例方法/类方法+无参数+无返回值 - (void)print;+ (void)printName; - (void)print&#123; NSLog(@"留下足迹才美丽");&#125;+ (void)printName &#123; NSLog(@"风吹花落美如玉");&#125; // 获取SELSEL sel1 = @selector(print);SEL sel2 = @selector(printName);// 获取函数指针IMP instanceIMP = [[YAUser class] instanceMethodForSelector:sel1];IMP classIMP = [YAUser methodForSelector:sel2];// 调用方法(*instanceIMP)();(*classIMP)(); 三.非显式使用__autoreleasing的场景有哪些场景一:@autoreleasepool。 编译器会检查@autoreleasepool块中的方法,如果不是以alloc/new/copy/mutableCopy开头，则自动把方法返回值的对象注册到autoreleasepool中。 @autoreleasepool &#123; NSObject *object = [[NSObject alloc] init]; // ==&gt;NSObject __strong *object = [[NSObject alloc] init]; NSArray *array = [NSArray array]; // ==&gt;NSArray __autoreleasing *array = [NSArray array]; &#125; 场景二:方法的返回值。 没有显式指定所有权修饰符，所以默认为__strong。由于return使得变量array超出作用域，强引用对应持有的对象会释放。但是该对象作为方法的返回值，编译器自动将其注册到自动释放池中，延缓释放(否则如果立即释放，那返回值就没有意义了)。 - (id)array &#123; NSArray *array = [NSArray array]; // ==&gt;NSArray __strong *array = [NSArray array]; return array;&#125; 场景三:__weak修饰的变量。__weak修饰的变量会被自动注册到自动释放池中。由于__weak不持有对象的强引用，在访问该对象的时候，该对象有可能已经释放，但是要保证能访问到该对象，所以把它注册到自动释放池中，确保@autoreleasepool块结束之前该对象存在。 id __weak object; 场景四:指向对象的指针的指针。指向对象的指针默认strong修饰。指向对象的指针的指针默认autoreleasing修饰。 NSObject *o;// ==&gt;NSObject __strong *o;NSObject **o;// ==&gt;NSObject* __autoreleasing *o; 为什么要使用指向对象的指针的指针?通常是回传值。在C函数中，无法返回多个值，借助指针可以回传值。 // 求两个数的和 积NSInteger sum(NSInteger a, NSInteger b, NSInteger *product) &#123; // 计算乘积 *product = a * b; // 返回求和 return a + b;&#125;// 使用 NSInteger a = 3, b = 32, summation, product; summation = sum(a,b,&amp;product); NSLog(@"%ld--%ld",summation,product); 在Objective-C中常用于NSError对象。 NSError *error = nil;NSURL *url = [NSURL URLWithString:@"这里是URL"];[NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; stringWithContentsOfURL:encoding:error:方法返回字符串，但是在获取字符串的时候可能发生错误，于是传入指向NSError对象的指针的指针，用于回传值(error是指向对象的指针，*error是该对象，&amp;error是指向对象的指针的指针)。 赋给对象指针时，变量所有权修饰符必须保持一致，否则会出错。修饰error的是strong，而这里要求传入的指针的类型是autoreleasing:(NSError * _Nullable __autoreleasing * _Nullable)，修饰符不一致，不符合规则，但是编译器做了转换。 // 转换所有权修饰符NSError *error = nil;NSError __autoreleasing *tmp = error;BOOL result = [obj performOperationWithError:&amp;tmp];error = tmp; 可是为什么要使用__autoreleasing呢? 实际上不注册到自动释放池也能传(返回)值，就像C函数中的回传乘积值一样。但是这样做不符合内存管理原则，只有作为alloc/new/copy/mutableCopy 开头的方法，能够自己生成并持有。也即其他方法的返回值取得对象(就像场景二中的返回值取得对象一样)需要注册到自动释放池，这便是原则。 如这种不符合内存管理原则的代码: while (CFGetRetainCount(object) != 1) &#123; CFRelease(object);&#125;while (_objc_rootRetainCount(object) != 1) &#123; _objc_rootRelease(object); &#125; 四.内存泄漏的场景有哪些1. Core Fundation的类型转换CFMutableArrayRef array = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);// 引用计数为1printf("%ld\n",CFGetRetainCount(array));id obj = (__bridge id)array;// 引用计数为2printf("%ld\n",CFGetRetainCount(array));// 不要使用_objc_rootRetainCount(),很不准很不准很不准//NSLog(@"%d",_objc_rootRetainCount(fontRef));// 如果不使用CFRelease()就会造成内存泄漏CFRelease(array);printf("%ld\n",CFGetRetainCount(array)); 主要原因是获取到CF对象后没有对其引用计数做出合适的处理。 2. 使用calloc函数创建动态数组// 声明动态数组// 默认为__autoreleasing修饰,需显式指明为__strongid __strong *array = nil;// 使用calloc分配内存array = (id __strong *)calloc(10, sizeof(id));// 使用array[0] = @"Aaren";// 简单释放内存,造成内存泄漏// 实际上对象array[0]还存在free(array); 正确做法: // 声明动态数组// 默认为__autoreleasing修饰,需显式指明为__strongid __strong *array = nil;// 声明容量NSInteger num = 10;// 使用calloc分配内存array = (id __strong *)calloc(num, sizeof(id));// 使用array[0] = @"Aaren";for (NSInteger i = 0;i &lt; num; i ++)&#123; array[i] = nil;&#125;// 释放内存free(array); 注意:1.不要使用malloc函数分配内存，malloc函数分配内存区域没有被初始化为0，可能产生随机访问导致错误，所以还需要使用memset()函数将内存填充为0。 2.对于NSMutableSet/NSMutableArray/NSMutableDictionary等容器，不需要人为手动管理。 3. MRC下的匿名对象[[NSObject alloc] init]; 匿名对象在MRC下会造成内存泄漏(C++中的匿名对象创建完毕后立即调用析构函数做销毁处理)。 但是在ARC环境下，不会造成内存泄漏。 id temp = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(temp,@selector(init));objc_release(temp); 创建完毕立即销毁，这也解释了为什么使用__weak修饰将要创建的对象会有警告。 NSObject * __weak object = [[NSObject alloc] init];// 或者id __weak object = [[NSObject alloc] init]; 警告:Assigning retained object to weak variable; object will be released after assignment 4. block的循环引用@interface YAUser ()&#123; block _block;&#125;- (void)func &#123; // 循环引用 _block = ^() &#123; NSLog(@"%p",self); &#125;; &#125; 五.__weak如何实现weak 表的作用是在对象执行 dealloc 的时候将所有指向该对象的 weak 指针的值设为 nil，避免悬空指针。苹果使用一个全局的 weak 表来保存所有的 weak 引用。并将对象作为键，weak_entry_t 作为值。weak_entry_t 中保存了所有指向该对象的 weak 指针。 struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;&#125;; 六.Core Fundation 与 Foundation如何转换1.__bridge只做类型转换，不修改相关对象的引用计数，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。 CFMutableArrayRef array = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);// 引用计数为1printf("%ld\n",CFGetRetainCount(array));// obj强引用该对象(默认为__strong)id obj = (__bridge id)array;// 引用计数为2printf("%ld\n",CFGetRetainCount(array));// 如果不使用CFRelease()就会造成内存泄漏CFRelease(array);printf("%ld\n",CFGetRetainCount(array)); 2.__bridge_transfer常用在CF对象转化成OC对象时，将CF对象的所有权交给OC对象，此时ARC就能自动管理该内存,作用同CFBridgingRelease() CFMutableArrayRef array = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);// 引用计数为1printf("%ld\n",CFGetRetainCount(array));// obj持有对象 array放弃持有对象,相当于做了CFRelease() id obj = (__bridge_transfer id)array; 3.bridge_retained与bridge_transfer 相反，常用在将OC对象转化成CF对象，且OC对象的所有权也交给CF对象来管理，即OC对象转化成CF对象时，涉及到对象类型和对象所有权的转化，作用同CFBridgingRetain() NSMutableArray *obj = [NSMutableArray array];CFMutableArrayRef array2 = (__bridge_retained CFMutableArrayRef)obj;// 引用计数为2,obj持有对象,array2也持有对象printf("%ld\n",CFGetRetainCount(array2));// 使用完毕,手动release,否则内存泄漏CFRelease((array2)); 七.简单介绍blockblock是能持有作用域变量的匿名函数，本质上是Objective-C对象。语法格式:^ 返回值类型 参数列表 表达式,其中返回值类型可省略，无参数时参数列表可省略。声明block与声明函数指针类似，执行block与调用函数类似。 // 返回值类型 (*f) 参数类型int (*f)(int) = &amp;func;// 声明blockint (^blk)(int);// 赋值int (^blk2)(int) = ^(int a)&#123; return 0;&#125;;// 起别名typedef int (^block) (int); block的三种类型 如果block没有访问外部的局部变量，或者访问的局部变量被static修饰，block存储在静态区，是NSConcreteGlobalBlock。 其他情况下，语法生成的block存放在栈中，是NSConcreteStackBlock。 当把栈中的block复制到堆上时，是NSConcreteMallocBlock。 block复制到堆上的情况大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上，只有当 block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法； 编译器或者方法内部已经实现copy代码的情况: block作为函数返回值 赋值给 __strong id 类型的对象或 block 的成员变量 Cocoa框架方法名含有usingBlock GCD中的API 其他情况需要手动复制: // 程序异常:栈上的block被废弃 typedef void(^block) (void); - (id)getBlockArray&#123; int val = 10; return [[NSArray alloc] initWithObjects: ^&#123;NSLog(@"blk0:%d", val);&#125;, ^&#123;NSLog(@"blk1:%d", val);&#125;, nil];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; block b = [self getBlockArray][0]; b(); &#125; 手动将block 复制到堆上: typedef void(^block) (void);- (id)getBlockArray&#123; int val = 10; return [[NSArray alloc] initWithObjects: [^&#123;NSLog(@"blk0:%d", val);&#125; copy], [^&#123;NSLog(@"blk1:%d", val);&#125; copy], nil];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; block b = [self getBlockArray][0]; b(); &#125; block捕获变量1.对于实例变量、静态全局变量、静态局部变量，全局变量，无论其为基本类型还是对象类型，在block中可读可写。 定义在函数内部的变量称为局部变量（Local Variable）。在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域默认是整个程序，也就是所有的源文件。 // 静态全局变量static NSInteger globalAge = 10;static NSString *globalName = @"Aaren";@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 局部变量 NSInteger age = 12; // 静态局部变量 static NSInteger staticAge = 17; static NSString *staticName = @"Bob"; YAUser *user = [[YAUser alloc] init]; void (^func)() = ^() &#123; // 修改实例变量 user.age = 18; user.name = @"Jack"; NSLog(@"%ld",user.age); NSLog(@"%@",user.name); // 修改静态局部变量 staticAge = 22; staticName = @"Lucy"; NSLog(@"%ld",staticAge); NSLog(@"%@",staticName); // 修改静态全局变量 globalAge = 14; globalName = @"Allen"; NSLog(@"%ld",globalAge); NSLog(@"%@",globalName); &#125;; func(); NSLog(@"%ld",user.age); NSLog(@"%@",user.name); NSLog(@"%ld",staticAge); NSLog(@"%@",staticName); NSLog(@"%ld",globalAge); NSLog(@"%@",globalName);&#125;@end 2.对于局部变量，无论其是基本类型还是对象类型，在block中为只读，当使用block修饰时，变量可读可写。block修饰的对象类型变量，在ARC环境下，block对其强引用。在非ARC环境下，block不会对其retain。 - (void)viewDidLoad &#123; [super viewDidLoad]; // 局部变量 __block NSInteger age = 17; __block NSString *name = @"Bob"; void (^func)() = ^() &#123; // 修改局部变量 age = 18; name = @"Jack"; NSLog(@"%ld",age); NSLog(@"%@",name); &#125;; func(); // 修改局部变量 age = 22; name = @"Aaren"; NSLog(@"%ld",age); NSLog(@"%@",name);&#125; block的循环引用Capturing ‘self’ strongly in this block is likely to lead to a retain cycle. .h文件 @interface YAUser : NSObject@property (nonatomic, strong) NSObject *object;- (void)func;@end .m文件 typedef void (^block) ();@interface YAUser ()&#123; block _block;&#125;@end@implementation YAUser- (void)func &#123; // 循环引用 self.object = [[NSObject alloc] init]; _block = ^() &#123; NSLog(@"%@",self.object); &#125;; _block();&#125;@end 由于block语法赋值给了成员变量，所以在栈上生成的block被复制到堆上。而block强引用了self的成员变量object，实际上是持有了self，self持有block的同时block持有self，于是self和block循环引用。 解决方案一:采用__weak修饰。 - (void)func &#123; // __weak解决循环引用 self.name = @"Aaren"; __weak NSString *weakName = self.name; // ---此时weakName和self.name是同一个变量 _block = ^() &#123; NSLog(@"%@",weakName); &#125;; _block(); // ---此时weakName和self.name是同一个变量 self.name = @"Jack"; // ---此时weakName和self.name不是同一个变量 // 结果依然是@"Aaren" _block();&#125; - (void)func &#123; // __weak解决循环引用 self.object = [[NSObject alloc] init]; // 声明了一个self类型的weak指针，名字叫做weakSelf. __weak typeof(self) weakSelf = self; _block = ^() &#123; NSLog(@"%@",weakSelf.object); &#125;; _block();&#125; 更改一方的强引用为弱引用打破了循环引用。但是有瑕疵:block内部可能捕获到空值。 - (void)func &#123; // __weak解决循环引用 self.object = [[NSObject alloc] init]; __weak typeof(self) weakSelf = self; _block = ^() &#123; // 现在立即使用weakSelf.object NSLog(@"%@",weakSelf.object); // 需要异步执行,但是却无法保证weakSelf.object一定存在 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"%@",weakSelf.object); &#125;); &#125;; // 调用block _block(); // 自以为block调用完毕,不再需要self.object的值了,大胆地将self.object改为其他值 self.object = nil;&#125; 这种情况就造成block内部正在使用持有变量的时候，变量的值却意外地改变了，甚至为nil，极易引发问题。最佳方案:弱引用加强引用: - (void)func &#123; // __weak解决循环引用 self.object = [[NSObject alloc] init]; __weak typeof(self) weakSelf = self; _block = ^() &#123; // __strong可以不加,默认为__strong,但最好加上,更醒目 __strong NSObject *strongObject = weakSelf.object; // 最好加上判断,保证strongObject不为空 if (strongObject) &#123; // 现在立即使用weakSelf.object NSLog(@"%@",strongObject); // 需要异步执行,可以保证weakSelf.object的值不改变 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"%@",strongObject); &#125;); &#125; &#125;; // 调用block _block(); // 放心地将self.object改为其他值 self.object = nil;&#125; 这么做可以保证在block执行期间持有的变量不改变。但如果在block执行之前该变量已经为nil，那回天乏力。 评价:这种方式不会造成循环引用:block弱引用的方式持有self.object，即不会影响self.object的释放。在block中是通过局部变量强引用self.object，作用域结束，局部变量销毁，不再强引用，从此你我是路人。 注意事项:1.除了使用typeof()之外，还可以直接声明与self相同类型的变量，但依然需要使用__weak修饰。 __weak YAUser *weakSelf = self; 2.循环引用的本质是block强引用了self。但是如果以 以上代码为例:block持有了self的成员变量，完全可以通过以下方式解决。 - (void)func &#123; // 循环引用 self.object = [[NSObject alloc] init]; NSObject *weakObject = self.object; _block = ^() &#123; NSLog(@"%@",weakObject); &#125;; _block();&#125; 3.如果可以放宽要求，那么不把block设置为成员变量、把block中调用的代码抽取出来等都可以解决循环引用。- (void)func &#123; // 循环引用 self.object = [[NSObject alloc] init]; __weak typeof(self) weakSelf = self; _block = ^() &#123; [weakSelf log]; &#125;; _block();&#125;// 把方法抽取出来- (void)log &#123; NSLog(@"%@",self.object);&#125; 使用场景:不需要对block中持有的变量进行写入操作，也即仅仅读取变量。当block异步使用持有的变量时，注意弱引用+强引用配合使用。建议统一采用 typeof(self) + 弱引用 + 强引用的形式。 解决方案二:采用__block修饰。 产生循环引用的代码: - (void)func &#123; // 循环引用 _block = ^() &#123; NSLog(@"%p",self); &#125;; &#125;- (void)execBlock &#123; _block();&#125; 解决循环引用: - (void)func &#123; // 解决循环引用 __block id tmp = self; _block = ^() &#123; NSLog(@"%p",tmp); // 关键所在 tmp = nil; &#125;; &#125;- (void)execBlock &#123; _block();&#125; 评价:block本身不能解决循环引用，关键在于 在block中将block修饰的变量置为空。当需要对持有的变量进行写入操作时可以使用。 注意事项:block必须执行，否则仍然不会解决循环引用。如下面代码: - (void)func &#123; // 解决循环引用 __block id tmp = self; _block = ^() &#123; NSLog(@"%p",tmp); tmp = nil; &#125;; &#125;- (void)execBlock &#123; // block没有执行,扔不能解决循环引用 // _block();&#125; 为什么block没有执行就无法解决循环引用呢?在block中出现tmp的那刻起，block就已经持有了self，即产生了循环引用，如: _block = ^() &#123;tmp;&#125;; 而只有通过执行block才能把nil赋给tmp，才能打破循环引用。因此，执行block的目的是把nil赋予tmp，而把nil赋予tmp便能解决循环引用的原因是打破了self对block的强引用(self已经不存在了)。 八.简要介绍GCD常用API1.dispatch_async与dispatch_sync// 异步执行dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;);// 同步执行dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;); 2.dispatch_queue_t使用系统提供的queue // 主队列:串行队列dispatch_queue_t mainQueue = dispatch_get_main_queue();// 全局队列:并行队列dispatch_queue_t globalQueue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);dispatch_queue_t globalQueue2 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_queue_t globalQueue3 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);dispatch_queue_t globalQueue4 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0); 自己创建queue // 一般指定这两种类型// DISPATCH_QUEUE_SERIAL// DISPATCH_QUEUE_CONCURRENTdispatch_queue_t createQueue = dispatch_queue_create("com.chenyalun.gcd.createQueue", DISPATCH_QUEUE_SERIAL);dispatch_async(createQueue, ^&#123; NSLog(@" ");&#125;);// If your deployment target is iOS 6.0 or Mac OS X 10.8 or later//dispatch_release(createQueue);// 指定创建的队列与globalQueue享有同一优先级// 不可指定系统的队列dispatch_set_target_queue(createQueue, globalQueue); 注意: 现在适配的版本一般大于iOS6,因此不必也不能对自己创建的queue进行dispatch_release，不会造成内存泄漏。 自己创建的队列严格按照格式来，尤其是作为第一个参数的queue的名称:”com.chenyalun.gcd.createQueue” 第二个参数设置为NULL，则为串行队列。specify DISPATCH_QUEUE_SERIAL (or NULL) to create a serial queue or specify DISPATCH_QUEUE_CONCURRENT to create a concurrent queue. In earlier versions, you must specify NULL for this parameter. 3.dispatch_resume/dispatch_suspend队列的挂起与恢复 // 全局队列:并行队列dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);dispatch_async(globalQueue, ^&#123; NSLog(@"你在何方 眼看天亮");&#125;);// 挂起dispatch_suspend(globalQueue);NSLog(@"都怪这夜色 撩人的疯狂");// 恢复执行dispatch_resume(globalQueue); 4.dispatch_apply// 指定迭代的次数NSArray *array = @[@1, @2, @3, @4, @5, @6, @7];dispatch_apply(array.count, globalQueue, ^(size_t index) &#123; NSLog(@"%@", [array objectAtIndex:index]);&#125;); 5.dispatch_groupdispatch_group_t group = dispatch_group_create();dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"这夜的风儿吹");&#125;);dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"我要 美丽的衣裳");&#125;);dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"为你 对镜贴花黄");&#125;);// 保证以上三个任务执行完毕再执行下面的任务dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@"这夜色太紧张");&#125;); dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"这夜的风儿吹");&#125;);dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"我要 美丽的衣裳");&#125;);dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"为你 对镜贴花黄");&#125;);// 保证以上三个任务执行完毕再执行下面的任务// DISPATCH_TIME_NOW 不等待// DISPATCH_TIME_FOREVER 永久等待NSInteger result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);if (result == 0) &#123; // group中的任务全部执行完毕 NSLog(@"这夜色太紧张");&#125; else &#123; // 任务没有执行完毕&#125; 6.dispatch_barrierdispatch_async(globalQueue, ^&#123; NSLog(@"第一个任务");&#125;);dispatch_async(globalQueue, ^&#123; NSLog(@"第二个任务");&#125;);// 栅栏函数dispatch_barrier_async(globalQueue, ^&#123; NSLog(@"英雄之所以被称为英雄，可能只是第一枪打中了而已。");&#125;);dispatch_async(globalQueue, ^&#123; NSLog(@"第四个任务。");&#125;);dispatch_async(globalQueue, ^&#123; NSLog(@"第五个任务");&#125;); 7.dispatch_once// typedef long dispatch_once_t;// static long onceToken;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; NSLog(@"仅仅执行一次");&#125;); 8.dispatch_afterdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@"你在何方 眼看天亮"); &#125;); 指定3秒之后把要执行的任务追加到主队列中。最早3.0秒后执行，最迟3+1/60秒后执行，若主线程有延迟，时间会更长。 // DISPATCH_TIME_NOW// DISPATCH_TIME_FOREVER// 时间的单位为毫微秒dispatch_time_t time = dispatch_time(DISPATCH_TIME_FOREVER, 3000000); 7.dispatch_semaphore更细粒度的排他控制// 全局队列:并行队列dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 设置信号量为1,也即保证同时访问的数量为1dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);NSMutableArray *array = [NSMutableArray array];// 迭代添加对象dispatch_apply(100, globalQueue, ^(size_t index) &#123; // 将要添加元素前一直等待信号量为1 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 放心地给数组添加元素 [array addObject:[NSNumber numberWithInt:(int)index]]; // 添加完成后释放信号量 dispatch_semaphore_signal(semaphore);&#125;);]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《SQL必知必会》]]></title>
    <url>%2F2017%2F04%2F09%2F%E8%AF%BB%E3%80%8ASQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%2F</url>
    <content type="text"><![CDATA[关于SQLite数据库。 采用 SQLite 数据库所有命令都敲了一遍，没毛病。 一、提要1.语言 数据定义语言CREATE 创建表/视图/其他对象ALTER 修改对象DROP 删除表/视图/其他对象 数据操纵语言SELECT 检索数据INSERT 创建记录UPDATE 修改记录DELETE 删除记录 数据控制语言GRANT 赋予用户特权REVOKE 收回用户特权 2.概念表:某种特定类型数据的结构化清单字段:限定数据中的列(名)记录:水平排列的数据的实体列:表中的一个字段模式:数据库和表的布局及特性NULL值:表中以空白形式出现的值，表示没有设值主键值:不重复，不为空，不能修改，不能重用 3.类型SQLite无类型，在表声明中明确了字段类型，仍然可以在该字段中存储其它类型的数据。 NULL: 表示该值为NULL值。INTEGER: 无符号整型值。REAL: 浮点值。TEXT: 文本字符串，存储使用的编码方式为UTF-8、UTF-16BE、UTF-16LE。BLOB: 存储Blob数据，该类型数据和输入数据完全相同。布尔数据类型：SQLite并没有提供专门的布尔存储类型，取而代之的是存储整型1表示true，0表示false。日期和时间数据类型：以TEXT、REAL和INTEGER类型分别不同的格式表示该类型，如： TEXT: &quot;YYYY-MM-DD HH:MM:SS.SSS&quot; REAL: 以Julian日期格式存储 INTEGER: 以Unix时间形式保存数据值， 即从1970-01-01 00:00:00到当前时间所流经的秒数。 4.注释 正行注释 # 注释内容 多行注释 /* 注释内容 */ 行尾注释 --注释内容 5.提示 多条语句必须以分号分隔。 SQL语句不区分大小写。 空格会被忽略，可以写成多行。 6.约束 NOT NULL:非空约束，不能有NULL值。 ID INTEGER NOT NULL DEFAULT:默认值，数据未指定的默认值，如默认时间:date(&#39;now&#39;)。 SALARY REAL DEFAULT 5000.0 -- 删除默认约束-- 在SQLite中不可用ALTER TABLE tALTER COLUMN SALARY DROP DEFAULT UNIQUE:唯一,列中所有数据各不相同。 AGE INTEGER UNIQUE 主键:唯一标识数据表中的记录，不为空。 PRIMARY KEY(ID,name) -- 增加主键(前提列已经声明为非空)-- 在SQLite中不可用ALTER TABLE t ADD PRIMARY KEY(ID)-- 删除主键-- 在SQLite中不可用ALTER TABLE t DROP PRIMARY KEY 外键:唯一标识其他表中的一条记录。 FOREIGN KEY(name) REFERENCES q(name) -- 增加外键-- 在SQLite中不可用ALTER TABLE tADD FOREIGN KEY (C_ID) REFERENCES USER (ID)-- 删除外键-- 在SQLite中不可用ALTER TABLE t DROP FOREIGN KEY CHECK:保证列中所有值满足某一条件。 AGE INT NOT NULL CHECK(AGE&lt;=18) 增加CHECK -- 在SQLite中不可用 ALTER TABLE t MODIFY AGE INT NOT NULL CHECK(AGE&gt;=18) 或者 ALTER TABLE t ADD CONSTRAINT checkConstraint CHECK(AGE&gt;=18) -- 删除CHECK -- 在SQLite中不可用 ALTER TABLE t DROP CONSTRAINT checkConstraint 7.范式第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列,如”地址”可以细分为:”省,市”。 第二范式（2NF）：首先是 1NF，其次一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 第三范式（3NF）：首先是 2NF，其次非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 8.函数 传送门：http://www.cnblogs.com/stephen-liu74/archive/2012/02/15/2322027.html 字符串处理:UPPER() 大写转换LENGTH() 字符串长度LOWER() 小写转换LTRIM() 去掉字符串左边的空格RTRIM() 去掉字符串右边的空格 日期时间处理date(‘now’) 返回当前日期。 date(&#39;now&#39;,&#39;start of month&#39;,&#39;1 month&#39;,&#39;-1 day&#39;)返回当前月的最后一天。 数值处理函数ABS() 绝对值COS() 角度的余弦EXP() 数的指数值PI() 返回圆周率SIN() 角度的正弦值SQRT() 平方根TAN() 角度的正切 聚集函数AVG() 平均值,忽略NULL值 COUNT() 某列的行数,若指定列名则会忽略NULL值,而COUNT(*)对表中行的数目进行计数,无论是否为NULL都计数,DISTINCT不能用于COUNT(*),如COUNT(DISTINCT *)为错误写法 MAX() 某列的最大值,忽略NULL值MIN() 某列的最小值,忽略NULL值SUM() 某列值的和,忽略NULL值 其他查看版本 select sqlite_version(); 9.视图视图只不过是通过相关的名称存储在数据库中的一个 SQLite 语句。视图实际上是一个以预定义的 SQLite 查询形式存在的表的组合。 SQLite仅支持只读视图，所以视图可以创建，可以读，但其内容不能更改。 视图的作用:视图是一种虚表，允许用户实现以下几点： 用户或用户组查找结构数据的方式更自然或直观。 限制数据访问，用户只能看到有限的数据，而不是完整的表。 汇总各种表中的数据，用于生成报告。 10.事务事务是一个对数据库执行工作单元,是以逻辑顺序完成的工作单位或序列。 事务是指一个或多个更改数据库的扩展。例如，如果正在创建一个记录或者更新一个记录或者从表中删除一个记录，那么正在该表上执行事务。重要的是要控制事务以确保数据的完整性和处理数据库错误。 可以把许多的 SQLite 查询联合成一组，把所有这些放在一起作为事务的一部分进行执行。 事务具有以下四个标准属性，通常根据首字母缩写为 ACID： Atomicity（原子性）原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。 Consistency（一致性）一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 Isolation（隔离性）多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。 Durability（持久性）持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 撤销ROLLBACK 命令是用于撤消尚未保存到数据库的事务的事务命令。ROLLBACK 命令只能用于撤销自上次发出 COMMIT 或 ROLLBACK 命令以来的事务。 BEGIN TRANSACTION; DELETE FROM t WHERE ID = 6; ROLLBACK; 提交 BEGIN TRANSACTION; DELETE FROM t WHERE ID = 5; -- 要做的事 END TRANSACTION; -- 或者使用以下语法 BEGIN; DELETE FROM t WHERE ID = 6; COMMIt; 注意:保存点在 SQLite (≥ 3.6.8)支持保留点,保留点越多越好 SAVEPOINT delRow; ROLLBACK TO delRow; 11.索引索引是一种特殊的查找表，数据库搜索引擎用来加快数据检索，简单地说，索引是一个指向表中数据的指针。 创建索引 CREATE INDEX in_name_age ON t(name, age); 删除索引 DROP INDEX in_name; 12.顺序 子句 说明 是否必须使用 SELECT 返回列 是 FROM 检索的表 从表中选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组 按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序 否 妙记: SELECT kindID, COUNT(*) FROM table WHERE PRICE &gt; 10 GROUP BY kindID HAVING COUNT(*) &gt;=2 ORDER BY kindID; 二、命令1.SELECT检索单个列 -- SELECT 列名 FROM 表名 SELECT age FROM t; 检索多个列 SELECT name, age, groupID FROM t; 检索所有列 SELECT * FROM t; -- 检索不必要的列会降低检索和应用程序的性能 检索并返回不同的值 SELECT DISTINCT name, age FROM t; -- DISTINCT作用于所有的列,如 SELECT DISTINCT groupID, age FROM t; -- 作用于groupID, age两列 -- 当groupID, age双双重复,只会返回一个结果 限制结果 -- 不超过5行 SELECT name, age FROM t LIMIT 5; -- 从第10行开始检索,不超过7行 SELECT name, age FROM t LIMIT 5 OFFSET 3; 1.LIMIT限制返回的行数，OFFSET指定从哪开始。2.行数指的是索引行，即从第0行开始。 2.ORDEY BYORDEY BY子句要保证放到最后 单个列排序 -- 以age值的字母顺序/大小排列 SELECT name FROM t ORDER BY age; 多个列排序 -- 首先按照age,在age中按照name SELECT name, age FROM t ORDER BY age, name; 按列位置排序 -- 首先按照age,在age中按照name -- 3对应age, 1对应ID SELECT ID, name, age FROM t ORDER BY 3, 1; 按降序排序 -- DESC 只作用在它前面的列 SELECT ID, name, age FROM t ORDER BY 3 DESC; SELECT ID, name, age FROM t ORDER BY 1 DESC,3 DESC; 3.WHERE常用操作符:一般:= ! = &lt; &gt; &gt;= &lt;=介于之间:BETWEEN AND为空值:IS NULL 一般使用 SELECT age, name FROM table WHERE age &lt; 10; -- 单引号用来限定字符串 -- 将值与字符串类型的列比较需要限定引号 -- 将值与数值列进行比较不用引号 SELECT ID, name, age FROM t WHERE age = 18; SELECT ID, name, age FROM t WHERE name = &apos;张无忌&apos;; 范围筛选 SELECT ID, name, age FROM t WHERE age BETWEEN 18 AND 22; 空值检查 SELECT ID, name, age FROM t WHERE sex IS NULL; 4.AND ORAND 优先级大于OR组合使用注意加括号 SELECT ID, name, age FROM t WHERE age = 18 AND name = &apos;唐僧&apos;; SELECT ID, name, age FROM t WHERE age = 18 OR groupID = 1; 组合使用 SELECT ID, name, age FROM t WHERE (age = 18 OR ID &lt; 12) AND groupID = 1; 5.IN关键字匹配 -- 18,19岁 SELECT ID, name, age FROM t WHERE age IN (18, 19); 6.NOT否定其后的限定条件 SELECT ID, name, age FROM t WHERE age NOT IN (18, 19); SELECT ID, name, age FROM t WHERE NOT age &lt; 22; 7.LIKE% 通配符表示任何字符出现任意次数,不会匹配NULL SELECT ID, name, age FROM t WHERE name LIKE &apos;张%&apos;; SELECT ID, name, age FROM t WHERE name LIKE &apos;%六&apos;; _ 通配符匹配单个字符,注意LIKE后的值使用字符串 SELECT ID, name, age FROM t WHERE age LIKE &apos;2_&apos;; 注意:SQLite 不支持[] 通配符[] 通配符指定一系列的字符,只要满足这些字符其中之一,且位置出现在“[]”通配符的位置的字符串就满足查询条件 SELECT ID, name, age FROM t WHERE name LIKE &apos;[牛]%&apos;; -- 否定 SELECT ID, name, age FROM t WHERE name LIKE &apos;[^牛]%&apos;; 注意:少使用通配符,尽量不要把通配符置于开始处 8.拼接使用 || 拼接多个列 SELECT age || &apos;(&apos; || name || &apos;)&apos; FROM t; -- 结果: 23(牛魔王) 使用RTRIM去除填充列宽的文本值 SELECT age || &apos;(&apos; || RTRIM(name) || &apos;)&apos; FROM t; RTRIM() 去掉字符串右边的空格 LTRIM() 去掉字符串左边的空格 TRIM() 去掉字符串左右两边的空格 使用别名AS 要求得到的是一列 SELECT age || &apos;(&apos; || RTRIM(name) || &apos;)&apos; AS Results FROM t; 执行计算 SELECT age + 3, name FROM t; 9.GROUP BYGROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前 SELECT groupID, COUNT(*) FROM t GROUP BY groupID; /* 含有COUNT(*)的分组的结果不该包含每列独有的字段,如name,ID等, 而应该是共性的字段,如分组ID等,因为目的是得知某组的COUNT */ SELECT name FROM t GROUP BY name; 10.HAVING1.WHERE过滤行，而HAVING过滤分组,HAVING支持所有WHERE操作符2.WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤 SELECT groupID, COUNT(*) FROM t GROUP BY groupID HAVING COUNT(*) &gt; 5; -- 筛选每组数量大于5 11.ORDER BY排序HAVING常与GROUP BY连用 SELECT groupID, COUNT(*) FROM t WHERE age &gt; 18 GROUP BY groupID HAVING COUNT(*) &gt; 2 ORDER BY groupID DESC; 12.子查询在SELECT语句中，子查询总是从内向外处理。作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误。 SELECT name, age FROM t WHERE age IN (SELECT age FROM t WHERE age &gt; 10 AND sex IS NULL); 13.连接内连接是据根据每个表共有的列的值匹配两个表中的行 SELECT t.name, age FROM t INNER JOIN q ON t.ID = q.ID; SELECT t.name, t.age FROM t, q WHERE t.name = q.name; -- 注意表的名称要匹配 自连接,查询中需要的两个表实际上是相同的表 SELECT a.name, a.age FROM t AS a, t AS b WHERE a.name = b.name AND b.ID = 10; 外连接1.外连接可以是左向外连接、右向外连接或完整外部连接2.在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表(RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表)。3.左向外连接的结果集包括LEFT OUTER子句中指定的左表的所有行，而不仅仅是连接列所匹配的行。4.右向外连接是左向外连接的反向连接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 SQLite支持左外连接LEFT OUTER JOIN，但不支持RIGHT OUTER JOIN 和 FULL OUTER JOIN语法。 SELECT t.*, q.* FROM t LEFt JOIN q ON t.ID = q.ID; 交叉连接。交叉连接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉连接也称作笛卡尔积。 总结:左外连接显示左表所有行+匹配行右外连接显示右表所有行+匹配行完整外部连接显示左表和右表中的所有行内连接显示根据比较运算符匹配两个表中的行自连接需要的两个表实际上是相同的表交叉连接显示左表所有行+左表每一行与右表所有行的组合连接不匹配时显示空值 14.UNION将结果组合成一个结果集1.UNION中的每个查询必须包含相同的列、表达式或聚集函数2.UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔3.列数据类型必须兼容 SELECT name, age FROM t WHERE name LIKE &apos;张%&apos; UNION SELECT name, age FROM t WHERE age &gt; 22; -- 相当于 &quot;并&quot;在一起 15.INSERT插入记录 INSERT INTO t VALUES(13, &apos;白骨精&apos;, &apos;1543&apos;, 1, NULL, 19, 1.68); INSERT INTO t(ID, name, phone, groupID, sex, age, height) VALUES(14, &apos;白龙马&apos;, &apos;1323&apos;, 0, NULL, 20, 1.69); VALUES必须以其指定的次序匹配指定的列名,更推荐这种方式省略列:允许NULL或者有默认值 16.CREATE AS复制表 CREATE TABLE c AS SELECT * FROM t; 17.UPDATE更新行 UPDATE t SET height = 1.66 WHERE name = &apos;白龙马&apos;; -- 删除某列的值 UPDATE t SET height = NULL WHERE name = &apos;韦小宝&apos;; 更新多列,注意逗号 UPDATE t SET height = 1.55, phone = &apos;1888&apos;, groupID = 0 WHERE name = &apos;唐僧&apos;; 18.DELETE删除行 DELETE FROM t WHERE name = &apos;白龙马&apos;; 19.CREATE创建表 CREATE TABLE d ( ID INTEGER NOT NULL UNIQUE, name TEXT NOT NULL, sex INTEGER DEFAULT 0, height REAL CHECK(height &gt; 0), PRIMARY KEY(&apos;ID&apos;) FOREIGN KEY(name) REFERENCES q(name) ); 主键单独标明。 20.ALTER给表增加一列 ALTER TABLE b ADD place TEXT; 重命名表 ALTER TABLE b RENAME TO bbb; 在 SQLite 中，除了重命名表和在已有的表中添加列，ALTER TABLE 命令不支持其他操作,包括删除列,定义主键和外键等. SQLite不支持删除列 ALTER TABLE t DROP COLUMN vend_phone; 21.DROP删除表 DROP TABLE t; 22.视图创建视图 CREATE VIEW view_b AS SELECT name, age FROM t; 查看视图 SELECT * FROM view_b; 删除视图 DROP VIEW view_b; 参考感谢：http://zhiwei.li/text/2010/08/23/sqlite%E5%A4%96%E9%94%AE/http://www.cnblogs.com/stephen-liu74/archive/2012/02/22/2325258.htmlhttp://www.runoob.com/sqlite/sqlite-syntax.html]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《Effective Objective-C 2.0》]]></title>
    <url>%2F2017%2F04%2F05%2F%E8%AF%BB%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[许多小技巧。 读感一晚上加一早上时间读了一遍,很多技巧都屡有耳闻,不过还是收获许多. 钩玄 .h文件中使用@class声明类,.m文件中使用import导入其他头文件,而不是只在.h文件中import头文件 常量使用static const,其他情况(如[NSNotificationCenter defaultCenter])使用宏 不需要位或运算的枚举使用NS_ENUM,需要使用位或运算的枚举使用NS_OPTIONS,避免C语言中的enum switch状态机下避免default分支(确保switch正确处理已知情况,往后增加新的的枚举值会有警告) 问题1.属性声明为@dynamic后该怎么做.h文件暴露属性 @property (nonatomic, copy) NSString *name; .m文件动态添加方法 @interface YAHeader ()&#123; NSString *_name;&#125;@end@implementation YAHeader@dynamic name;// 添加set方法,要传入参数void dynamicSetMethodIMP(YAHeader *self, SEL _cmd, NSString *prame) &#123; self-&gt;_name = prame;&#125;// 添加get方法,要返回NSString *类型NSString *dynamicGetMethodIMP(YAHeader *self, SEL _cmd) &#123; return self-&gt;_name;&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(setName:)) &#123; class_addMethod([self class], sel, (IMP)dynamicSetMethodIMP, "v@:@"); return YES; &#125; if (sel == @selector(name)) &#123; class_addMethod([self class], sel, (IMP)dynamicGetMethodIMP, "v@:"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;@end 注意:1.按照本书所说,使用@dynamic将仅仅生成get/set方法的声明,不会生成get/set方法的实现,也不会合成成员变量 2.由于没有合成成员变量,所以手动添加 3.使用@property但是却没有合成成员变量的情景有:(1):同时使用@property和@dynamic(2):set和get方法均手动实现(3):分类中@property值得一提的是,当使用@synthesize num;时,将不会生成成员变量_num,而是生成成员变量num 2.关联对象中为什么使用static修饰的指针static的作用之一便是使变量在内存中只有一份拷贝,由于需要objc_setAssociatedObject和objc_getAssociatedObject中的两个键(void *key)需要匹配同一个值(关联的对象),所以需要两者是完全相同的指针,故而使用静态全局变量做键 3.简述Objective-C在发送消息时的动态性静态绑定:将在运行期间调用的函数在编译期间已经确定动态绑定:发送的消息部分转化为objc_msgSend函数,传入将要调用函数的对象、将要调用的函数以及将要调用的函数的参数,具体调用哪个函数,通过快速映射表、方法列表亦或是消息转发确定objc_msgSend_stret:消息返回结构体调用objc_msgSend_fpret:消息返回浮点数调用objc_msgSendSuper:给超类发送消息调用 4.如何解决unrecognized selector send to instance消息转发的三个流程1.对象收到无法识别的消息,根据使类方法还是对象方法调用+ (BOOL)resolveInstanceMethod:(SEL)selector+ (BOOL)resolveClassMethod:(SEL)selector前提:相关方法的实现代码已经写好使用:根据类方法还是对象方法,在resolveMethod中为无法响应的selector动态添加方法实现(提供函数指针IMP)class_addMethod(self, selector, (IMP)methodImplemention,"v@:@"); 若没有做出处理,返回NO 2.倘若没有相关方法实现,进入- (id)forwardingTargetForSelector:(SEL)selector将消息转发给其他对象,若找不到,返回nil 3.完整的消息转发,调用对象方法- (void)forwardInvocation:(NSInvocation *)invocation首先发送-methodSignatureForSelector:获取函数的参数和返回值类型,若返回nil,直接挂掉,否则Runtime创建一个NSInvocation对象,发送forwardInvocation消息给目标对象 5.如何实现多重继承C类 继承自 A类,想让C类对象同时具备A类方法和 B类方法的能力使C类对象中拥有B类对象(组合),在C类对象中实现对象方法forwardingTargetForSelect:方法,将发送来的B类方法转发给所拥有的B类对象处理 6.怎么实现方法实现的交换// 获取通过SEL获取一个方法class_getInstanceMethod// 获取一个方法的实现method_getImplementation// 获取一个OC实现的编码类型method_getTypeEncoding// 給方法添加实现class_addMethod// 用一个方法的实现替换另一个方法的实现class_replaceMethod// 交换两个方法的实现method_exchangeImplementations 获取Method+ (void)load &#123; Method lowercaseString = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method uppercaseString = class_getInstanceMethod([NSString class], @selector(uppercaseString)); method_exchangeImplementations(lowercaseString, uppercaseString);&#125; 表面上看是死循环: - (NSString *)lowercaseString &#123; return self.lowercaseString;&#125;- (NSString *)uppercaseString &#123; return self.uppercaseString;&#125; 7.简述为代码加锁的方式同步块: @synchronized(self) {//...} 滥用@synchronized(self)很危险,所有的块都会彼此抢夺同一个锁. 锁对象:_lock = [[NSLock alloc] init];[_lock lock];// ...[_lock unlock]; 8.原子性一定安全吗,如何确保属性的线程安全不一定.原子性能保证存取方法的线程安全,也即读写操作是原子性的,在读或者写发生的时候,其他读或者写操作必须等待.然而同一个线程上多次调用get方法,每一次获取到的值未必相同,多次访问期间,其他线程可能会写入新的值.比如当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全. 线程安全:不会出现数据不一致或者数据污染。 使用串行同步队列,将读取以及写入操作都安排在同一个队列中,即可保证数据同步. 方式一:同步派发(在set方法简单的时候使用) .h文件@property (nonatomic, copy) NSString *name; .m文件1.创建串行队列@interface YAHeader ()&#123; dispatch_queue_t _serialQueue;&#125;char * const label = "label"; _serialQueue = dispatch_queue_create(label, NULL); 2.合成属性(由于需要重写get/set方法,编译器已取消自动合成)@implementation YAHeader@synthesize name = _name;char * const label = "label";- (void)setName:(NSString *)name &#123; dispatch_sync(_serialQueue, ^&#123; _name = name; &#125;);&#125;- (NSString *)name &#123; __block NSString *localName; dispatch_sync(_serialQueue, ^&#123; localName = _name; &#125;); return localName;&#125;@end 方式二:异步派发(在set方法复杂的时候使用)改动set方法 - (void)setName:(NSString *)name &#123; dispatch_async(_serialQueue, ^&#123; _name = name; // ...(还有许多操作) &#125;);&#125; 在异步派发的时候需要拷贝block,需要消耗一定时间,所以在set方法更复杂的场景下使用 9.performSelector的局限性有哪些1.由于无法确定将要执行的selector具体是什么,ARC无法将其纳入合适的内存管理方法中,可能有内存泄漏2.selector的返回值类型和参数个数、类型受到限制建议使用GCD中的dispatch_async/dispatch_after等代替相应的performSelector - (void)fetchSelector:(NSInteger)condition &#123; SEL selector; if (condition == 0) &#123; selector = @selector(dismiss); &#125; else if (condition == 1)&#123; selector = @selector(miss:); &#125; else &#123; selector = @selector(love); &#125; [self performSelector:selector];&#125; 警告:/Users/chenyalun/Desktop/iOS/program/Demo170404/Demo170404/YAHeader.m:70:11: PerformSelector may cause a leak because its selector is unknown 10.bridge、bridge_retained与__bridge_transfer的区别NSArray *array = @[@10, @11, @12];CFArrayRef cfarray = (__bridge CFArrayRef)array;CFArrayRef cfarray2 = (__bridge_retained CFArrayRef)array;CFRelease(cfarray2);NSArray *array2 = (__bridge_transfer NSArray *)cfarray; __bridge表示ARC仍然具备该对象的所有权 __bridge_retained表示ARC交出该对象的所有权(需手动release) __bridge_transfer:表示反向转换,同时ARC获取对象所有权 11.NSCache相较NSDictionary的优点1.在系统发出低内存通知时,NSCache自动删减缓存,并且先行删减最久未使用的对象2.增加键的引用计数而不是拷贝它3.NSCache线程安全,可以多线程访问而不出错4.NSPurgeableData是NSMutableData的子类,将它与NSCache搭配使用,当NSPurgeableData对象所占内存为系统所丢弃时,该对象自动从NSCache缓存中清除 访问NSPurgeableData对象 NSCache *cache = [[NSCache alloc] init];NSPurgeableData *purgeableData = [NSPurgeableData dataWithBytes:@"ILOVEYOU" length:10];[cache setObject:purgeableData forKey:@00];// 访问NSPurgeableDataif (purgeableData) &#123; // 开始访问,现在还不应该丢弃自己所占用的内存 [purgeableData beginContentAccess]; [self useData:purgeableData]; // 结束访问,现在可以丢弃自己所占用的内存啦 [purgeableData endContentAccess];&#125; 参考资料: 乞力马扎罗的雪的博客: blog.csdn.net/chenyufeng1991/article/details/49687215]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C提要]]></title>
    <url>%2F2017%2F04%2F02%2FC%E6%8F%90%E8%A6%81%2F</url>
    <content type="text"><![CDATA[不堪回首。 Java、前端、Android、iOS的笔试题涌现大量C++的内容，我和小伙伴们苦不堪言，于是特意抽大半天时间试着回忆一下。 钩玄1.命名空间如何使用防止出现变量或函数的命名冲突. 在 main() 函数中声明命名空间 std，它的作用范围就位于 main() 函数内部，如果在其他函数中又用到了 std，就需要重新声明 如果希望在所有函数中都使用命名空间 std，可以将它声明在全局范围中// 定义namespace YA &#123;int a;// 变量、类、函数、typedef、#define 等都可以出现在命名空间中&#125;// 使用方式一:域解析操作符// :是域解析操作符,指明要使用的命名空间YA :: a = 20;// 使用方式二:针对变量// 如果以后出现了未指明命名空间的a，就使用YA :: ausing YA :: a;a = 20;// 使用方式三:针对命名空间using namespace YA; // 声明整个命名空间 2.C++现行标准库对于不带.h的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域 #include &lt;cstdio&gt;using namespace std;//... C语言的头文件在 C++ 中依然被支持，C++ 新增的库更加强大和灵活,例如 iostream、fstream、string 等 推荐:#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//... 3.cin与coutcout 和 cin 分别是 ostream 和 istream 类的对象,而不是关键字使用:int a,b;cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;"a是"&lt;&lt;a&lt;&lt;endl;cout&lt;&lt;"b是"&lt;&lt;b&lt;&lt;endl; 其中endl表示end of line,表示换行,可用\n代替 4.C++中const的作用1.定义常量const int a = 10; // a不可修改 2.类型检查void f(const int i){} // 对传进来的参数进行类型检查,不匹配则提示 3.保护参数void f(const int i){} // i不可修改 4.节省空间// 替换三次,分配三次内存空间#define pi 3.14double a = pi;double b = pi;double c = pi;const double PI = 3.14// 只分配一次内存空间double d = PI;// 不再分配内存空间double e = PI; 混淆点:指针本身是常量不可变,不可以指向其他 char* const pContent; 指针所指向的内容是常量不可变 const char *pContent; 两者都不可变 const char* const pContent; 5.动态分配内存在C中分配 int *p = (int *)malloc(sizeof(int) * 10); 释放 free(p); 在C++中 new[]分配 delete[]释放 int *p = new int; delete p; int *p = new int[10]; //分配10个int型的内存空间 delete[] p; new 是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。 6.函数调用的流程函数调用是有时间和空间开销的(递归效率低下)。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。 7.内联函数作用:为了消除函数调用的时空开销，在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数. 在函数定义处添加inline关键字,声明处添加无效.inline p() &#123; printf("内联函数");&#125; 注意: 当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以一般是将非常短小的函数声明为内联函数。 对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的。编译器有自己的判断能力，它会根据具体情况决定是否这样做。如何函数体非常大，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。 缺点:编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大。 总结:小而短的函数声明为内联函数. 内联函数替代宏#define sum(a,b) (a+b)inline int sum(int a, int b) &#123; return a+b;&#125; 8.函数的默认参数/重载默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。void sum(int a, int b = 10) &#123;cout&lt;&lt;a+b&lt;&lt;endl;&#125;// 调用sum(12,23);sum(12) 重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。重载的结果是让一个函数名拥有了多种用途，使得命名更加方便,调用更加灵活。要求:函数名相同,参数列表不同,仅仅返回类型不同不足以成为函数的重载。//交换 int 变量的值void Swap(int *a, int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;//交换 float 变量的值void Swap(float *a, float *b)&#123; float temp = *a; *a = *b; *b = temp;&#125; 重载的本质:在编译时会根据参数列表对函数进行重命名,函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。 9.对象的创建类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。 成员变量大都以m_开头。 存储在栈上的对象 Student stu;Student *p = &amp;stu; 存储在堆上的对象Student *stu = new Student; 使用 new 在堆上创建出来的对象是匿名的，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。 10.成员函数在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以建议在类体内部对成员函数作声明，而在类体外部进行定义. 不使用内联函数: class Student&#123; public: int age; void say(); //内联函数声明 &#125;; //函数定义void Student::say()&#123; &#125; 11.构造函数构造函数必须是 public 属性的，否则创建对象时无法调用。构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。 一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成 调用没有参数的构造函数也可以省略括号。Student stu();Student stu;Student *stu = new Student();Student *stu = new Student; 参数初始化表可以用于全部成员变量，也可以只用于部分成员变量。参数初始化顺序与初始化表列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。初始化 const 成员变量的唯一方法就是使用参数初始化表。 //采用参数初始化表Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; //TODO:&#125; 12.析构函数析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号。析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。 13.this的本质this 是 C++ 中的一个关键字，也是一个 const 指针，它指向当前对象，通过它可以访问当前对象的所有成员。 his 虽然用在类的内部，但是只有在对象被创建以后才会给 this 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给 this 赋值。 this的本质:this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。 14.静态成员变量static 成员变量属于类，不属于某个具体的对象，即使创建多个对象,也只分配一份内存. static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用 static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。// 将 m_total 声明为静态成员变量//通过类类访问 static 成员变量Student::m_total = 10; //通过对象来访问 static 成员变量Student stu("小明", 15, 92.5f);stu.m_total = 20; //通过对象指针来访问 static 成员变量Student *pstu = new Student("李华", 16, 96);pstu -&gt; m_total = 20; 静态成员变量必须初始化，而且只能在类体外进行 static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。 15.静态成员函数普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。 普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。 普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。 静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。 16.常成员函数const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的 常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字class Student&#123;public: //声明常成员函数 int getage() const;private: int m_age;&#125;;//定义常成员函数int Student::getage() const&#123; return m_age;&#125; 17.友元函数与友元类借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。在当前类以外定义的、不属于当前类的函数可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。 友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。 一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。public: // 构造函数 Address(char *province, char *city, char *district); //将Student类中的成员函数show()声明为友元函数 friend void Student::show(Address *addr); 友元类中的所有成员函数都是另外一个类的友元函数。public: // 构造函数 Address(char *province, char *city, char *district); public: //将Student类声明为Address类的友元类 friend class Student; 友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。 18.struct与class比较使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的 class 继承默认是 private 继承，而 struct 继承默认是 public 继承 class 可以使用模板，而 struct 不能 19.string的使用前提:#include &lt;string&gt; 1.输入输出 string s; cin&gt;&gt;s; cou&lt;&lt;s&lt;&lt;endl; 2.通过下标访问 string s = &quot;qwert&quot;; s[3] = &apos;d&apos;; couy&lt;&lt;s[2]; 3.拼接 string s = &quot;i&quot;; char *s1 = &quot;love&quot;; char s2[] = &quot;you&quot;; char s3 = &apos;!&apos;; string rs = s + s1 + s2 + s3; 4.插入 string s = &quot;sdf&quot;; s.insert(1,&quot;sds&quot;); // 索引/内容 5.删除 s1 = s2 = s3 = &quot;1234567890&quot;; s2.erase(5); s3.erase(5, 3); // 长度为3 6.提取 s1.substr(6, 6); // 长度为6 7.查找 s.find(&quot;,&quot;,1); // 从索引1开始查找逗号,返回索引 20.指针传递与引用传递的比较引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。 引用的定义方式类似于指针，只是用&amp;取代了* type &amp;name = data; // 指针传递 // 比如交换数据 swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } // 使用 swap(&amp;a, &amp;b); //引用传递 swap2(int &amp;a, int &amp;b) { int temp = a; a = b; b = temp; } // 使用 swap2(a,b); 引用也可以作为函数的返回值,不过不能返回局部变量的引用,因为局部变量过了作用域就销毁了 21.继承继承方式包括 public（公有的）、private（私有的）和 protected（受保护的），此项是可选的，如果不写，那么默认为 private。 class 派生类名:［继承方式］ 基类名{ 派生类新增加的成员 }; 不同的继承方式会影响基类成员在派生类中的访问权限。 1) public继承方式 基类中所有 public 成员在派生类中为 public 属性； 基类中所有 protected 成员在派生类中为 protected 属性； 基类中所有 private 成员在派生类中不能使用。 2) protected继承方式 基类中的所有 public 成员在派生类中为 protected 属性； 基类中的所有 protected 成员在派生类中为 protected 属性； 基类中的所有 private 成员在派生类中不能使用。 3) private继承方式 基类中的所有 public 成员在派生类中均为 private 属性； 基类中的所有 protected 成员在派生类中均为 private 属性； 基类中的所有 private 成员在派生类中不能使用。 基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。 基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。 类的构造函数不能被继承析构函数也不能被继承派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。 22.多重继承class D: public A, private B, protected C&#123; //类D新增加的成员&#125; 基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序相同。 23.虚继承假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A –&gt;B–&gt;D 这条路径，还是来自 A–&gt;C–&gt;D 这条路径。因为类 B 和类 C 中都有成员变量 a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了错误。 消除歧义:使用域解析操作符 为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。在继承方式前面加上 virtual 关键字就是虚继承//间接基类Aclass A&#123;protected: int m_a;&#125;;//直接基类Bclass B: virtual public A&#123; //虚继承protected: int m_b;&#125;;//直接基类Cclass C: virtual public A&#123; //虚继承protected: int m_c;&#125;;//派生类Dclass D: public B, public C&#123;public: void seta(int a)&#123; m_a = a; &#125; //正确 void setb(int b)&#123; m_b = b; &#125; //正确 void setc(int c)&#123; m_c = c; &#125; //正确 void setd(int d)&#123; m_d = d; &#125; //正确private: int m_d;&#125;;&#125; 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。 在最终派生类 D 的构造函数中，除了调用 B 和 C 的构造函数，还调用了 A 的构造函数，这说明 D 不但要负责初始化直接基类 B 和 C，还要负责初始化间接基类 A。直接派生类 B 和 C 对 A 的构造函数的调用是无效的.而在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误。 在类被构造的时候，先执行虚拟继承的父类的构造函数，然后从左到右执行普通继承的父类的构造函数，然后按照定义的顺序执行数据成员的初始化，最后是自身的构造函数的调用。析构函数与之完全相反，互成镜像。见:http://gaocegege.com/Blog/cpp/cppclass 24.C++向上转型编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。 25.虚函数、纯虚函数与多态目的:让基类指针能够访问派生类的成员函数,只需要在该成员函数声明前面增加 virtual 关键字(基类\派生类都要操作) 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism） 虚函数的唯一用处就是构成多态,如果没有多态，我们只能访问成员变量。 只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数） 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。 析构函数可以声明为虚函数，而且有时候必须要声明为虚函数 将虚函数声明为纯虚函数，纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数。 语法格式为： virtual 返回值类型 函数名 (函数参数) = 0; 包含纯虚函数的类称为抽象类（Abstract Class）一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。 26.运算符重载运算符重载的格式为： 返回值类型 operator 运算符名称 (形参表列){ //TODO: } // 如complex operator+(const complex &amp;A) const; 27.模板函数模板template &lt;typename 类型参数1 , typename 类型参数2 , ...&gt; 返回值类型 函数名(形参列表)&#123;//在函数体中可以使用类型参数&#125; typename关键字可使用class代替 // 如template&lt;class T&gt; void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125; 关键在于函数定义前面加上 template 类模板template&lt;typename 类型参数1 , typename 类型参数2 , …&gt; class 类名&#123; //TODO:&#125;;// template&lt;typename T1, typename T2&gt; // 类模板使用时需要指明类型,函数模板不需要Point&lt;float, float&gt; *p1 = new Point&lt;float, float&gt;(10.6, 109.3); 参考博客C语言中文网:http://c.biancheng.net/cpp/biancheng/cpp/rumen/]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法实现]]></title>
    <url>%2F2017%2F03%2F05%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[2017.4.24 修改部分代码2017.4.21 完善2017.3.25 修改 排序算法。 前言因为笔试使用的编译器语言为Python2.7，所以以下代码使用Python2实现并规定从小到大为目标顺序。 八大排序：直接插入排序，希尔排序，简单选择排序，堆排序，冒泡排序，快速排序，归并排序，基数排序。 排序的稳定性假定n1 = n2,排序前n1位于n2前面,如果排序后n1扔领先于n2,则称排序算法稳定. 内排序与外排序内排序:排序的整个过程中,待排序的所有记录全部被放置在内存中.外排序:由于排序的记录太多,排序的过程中,需要内外存之间多次交换才能进行. 一、冒泡排序原理:通过相邻元素的比较和交换，把较大的数交换到后面，类似水泡向上面(数组的后面，所以总是靠后的数字有序)升，故称为冒泡排序。如果两数相等，不交换，所以稳定。 普通方式 def bubbleSort(tempList): n = len(tempList) for x in xrange(n): for y in xrange(1, n - x):# 索引n-x之后的数已经排序好了 if tempList[y - 1] &gt; tempList[y]: tempList[y], tempList[y - 1] = tempList[y - 1], tempList[y] return tempListprint bubbleSort([5,10,2,7,0,30]) 优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，无需继续迭代。 #交换排序-冒泡排序优化1def bubbleSort1(tempList): n = len(tempList) for x in xrange(n): #标志位,倘若没有交换,说明已经排序好了 flag = True for y in xrange(1, n - x):# 索引n-x之后的数已经排序好了 if tempList[y - 1] &gt; tempList[y]: tempList[y], tempList[y - 1] = tempList[y - 1], tempList[y] flag = False if flag: # 发现并没有发生交换 return tempList return tempListprint bubbleSort1([5,10,2,7,0,30]) 优化2：记录最后发生交换的位置，位置之后的数据已经井然有序。 #交换排序-冒泡排序优化2def bubbleSort2(tempList): n = len(tempList) # 循环范围 m = n for x in xrange(n): #标志位,倘若没有交换,说明已经排序好了 flag = True for y in xrange(1, m):# 索引m之后的数已经排序好了 if tempList[y - 1] &gt; tempList[y]: tempList[y], tempList[y - 1] = tempList[y - 1], tempList[y] m = y flag = False if flag: # 发现并没有发生交换 return tempList return tempListprint bubbleSort2([5,10,2,7,0,30]) 分析最好情况:数据井然有序,根据优化后的代码,只需要迭代一次,即n-1次的比较,则时间复杂度为O(n)最坏情况:数据逆序,需要比较的次数为1+2+3+4+…+(n-1)=n(n-1)/2次,时间复杂度为O(n^2) 假定有4个数,分别为4 3 2 1,排序过程为:原数据: 4 3 2 1第1次: 3 4 2 1第2次: 3 2 4 1第3次: 3 2 1 4第4次: 2 3 1 4第5次: 2 1 3 4第6次: 1 2 3 4归纳推理:n(n-1)/2次 二、选择排序在未排序序列中找到最小元素，存放到排序序列的起始位置(与第一个元素交换位置)，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾(与第二个元素交换位置)。以此类推，直到所有元素均排序完毕。 通过n-i次关键字间的比较,从n-i+1个记录中选出最小的记录,并和第i个记录交换之. 选择排序的交换操作介于 0 和 ( n − 1 )次之间。选择排序的比较操作为 n ( n − 1 ) / 2次之间。选择排序的赋值操作介于 0 和 3 ( n − 1 )次之间。 当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。 def selectionSort(tempList): n = len(tempList) for x in xrange(n): # 假定索引x对应的是最小值 index = x for y in xrange(x + 1,n): # 如果找到比索引index对应的值还要小的值,交换两者位置 if tempList[index] &gt; tempList[y]: tempList[index], tempList[y] = tempList[y], tempList[index] return tempListprint selectionSort([5,10,2,7,0,30]) 分析特点:交换移动数据次数相当少最好情况与最坏情况:比较次数一样多,为n(n-1)/2次,时间复杂度:O(n^2) 假定有4个数据,分别为 4 3 2 1原数据: 4 3 2 1第1次比较: 4 与 3第2次比较: 4 与 2第3次比较: 4 与 1 (此时数据为1 3 2 4)第4次比较: 3 与 2第5次比较: 3 与 4 (此时数据为 1 2 3 4)第6次比较: 3 与 4最终结果: 1 2 3 4比较次数:6次 选择排序是不稳定的排序算法,比如5 8 5 2 9,显然第1个5最终落到第2个5的后面. 原数据: 5' 8 5 2 9第1次交换: 2 8 5 5' 9第2次交换: 2 5 8 5' 9第3次交换: 2 5 5' 8 9第4次交换: 2 5 5' 8 9最终 5'在 5 的前面. 三、直接插入排序原理:在一个已经有序的数据序列中插入一个数，在插入后此数据序列仍然有序。默认前1个数有序，第二个数与前一个数组成的有序数列比较并插入，第三个数与前两个数组成的有序数列比较并插入……所以总是靠前的数字有序。 遇到相等的数，插入到该数的后面，而不是前面，所以是稳定排序算法。 最好情况：序列已经是升序排列了，需要进行的比较操作需(n-1)次,时间复杂度为O(n)。最坏情况：序列是降序排列，那么此时需要进行的比较共有 n ( n − 1 ) / 2 次。插入排序的赋值操作是比较操作的次数加上(n-1)次。平均来说插入排序算法复杂度为 O ( n^2 )。插入排序不适合对于数据量比较大的排序应用。用于少量元素的排序（通常为8个或以下）。 直接插入 def insertionSort(tempList): # 获取列表的长度 n = len(tempList) for x in xrange(1,n): # 从第1个元素而非第0个元素开始遍历 for y in xrange(x, 0, -1): # 在已经排好序的列表中逐个扫描 if tempList[y - 1] &gt; tempList[y]: # 如果当前元素比前面的小 tempList[y], tempList[y - 1] = tempList[y - 1], tempList[y] # 两者位置互换 return tempList# print insertionSort([])# print insertionSort([8])# print insertionSort([5,2,7,0,1,5,9]) 四、二分插入排序二分查找插入与希尔排序是直接插入排序的优化。 二分查找插入 使用Python模块实现 # bisect模块实现了一个算法, 用于向一个有序列表中插入一个元素,不改变列表的序列# 使用这个模块的函数前先确保操作的列表是已排序的#import bisect def insertionSortBisect(tempList): for i in xrange(1, len(tempList)): bisect.insort(tempList, tempList.pop(i), 0, i) # 排序列表,移除并插入元素,区间开始,区间结束 return tempList# print insertionSortBisect([])# print insertionSortBisect([8])# print insertionSortBisect([5,2,7,0,1,5,9]) 手动实现 #二分查找的前提必须待查找的序列有序# 在有序列表中,返回值m应该所在的索引def indexOfInsertionSort(tempList, m): # 获取列表的长度 n = len(tempList) left, right = 0, n - 1 while left &lt;= right: middle = (left + right) / 2 if tempList[middle] &lt; m:# 右半部分 left = middle + 1 else: #左半部分,含相同元素 right = middle -1 return right +1 def insertionSortbin(tempList): # 获取列表的长度 n = len(tempList) for x in xrange(0,n): # 从头至尾遍历列表中的元素 m = tempList[x] tempList.pop(x) index = indexOfInsertionSort(tempList[0:x],m) tempList.insert(index , m) #第一个参数是索引,第二个参数是数值 return tempList #print insertionSortbin([12,12,16,8,5,10,7]) 五、希尔排序先将待排记录序列分割为若干个子序列，分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序。 采用跳跃分割的策略:把相距某个”增量”的记录组成一个序列，保证在子序列内分别进行直接插入排序后得到的结果是基本有序的。 原始序列 2 5 1 9 8 2 10 4 4步长，分组，每列排序 2 5 1 98 2 10 4 排序后 2 2 1 48 5 10 9 也即 2 2 1 4 8 5 10 9 2步长，再分组 2 21 48 510 9 排序 1 22 48 510 9 也即： 1 2 2 4 8 5 10 9 最后以1步长进行排序（还是直接插入排序）。 一般插入 def insertionSortShell(tempList): n = len(tempList) # 确定分组,假定n = 6 group = n / 2 # 此时group = 3,分成3组,3组元素索引分别为3与3-3,4与4-3,5与5-3 while group &gt; 0: #x从3到5 for x in xrange(group,n): # 每组元素:x,x-group,x-group-group ......插入排序 temp = tempList[x] y = x # 这里使用简单的插入排序 while y &gt;= group and tempList[y - group] &gt; temp: tempList[y] = tempList[y - group] y -= group tempList[y] = temp group /= 2 return tempList 互换法 def insertionSortShellExchange(tempList): n = len(tempList) # 确定分组,假定n = 6 group = n / 2 # 此时group = 3,分成3组,3组元素索引分别为3与3-3,4与4-3,5与5-3 while group &gt; 0: #x从3到5 for x in xrange(group,n): # 每组元素:x,x-group,x-group-group ......插入排序 y = x m = tempList[x] while y &gt;= group and tempList[y - group] &gt; m: # 这里直接交换位置 tempList[y], tempList[y - group] = tempList[y - group], tempList[y] y -= group group /= 2 return tempList#print insertionSortShell([1,8,10,2,4,0])#print insertionSortShellExchange([1,8,10,2,4,0]) 由于记录是跳跃式的，希尔排序是不稳定的排序算法。 六、堆排序堆排序是对简单选择排序的改进。 堆是具有以下性质的完全二叉树:每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 性质:按层遍历的方式给结点编号，则有: k(i) &gt;= k(2i) k(i) &gt;= k(2i+1) 或 k(i) &lt;= k(2i) k(i) &lt;= k(2i+1) 堆排序就是利用堆进行排序的算法，基本思想是:将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根结点。把它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个值重新构造成一个堆，这样就会得到n个元素中的次小值，如此反复执行，便能得到一个有序序列了。 需要解决的两个问题:1. 如何由一个无序序列构建成一个堆2. 如何在获取堆顶元素后，调整剩余元素成为一个新的堆 所谓的将待排序的序列构建成一个大顶堆，其实就是从下往上、从右往左，将每个非叶结点当作根节点，将其和其子树调整成大顶堆。 在正式排序时，第i次取堆顶记录重建需要O(logi)的时间，并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为O(nlogn)。 堆排序对原始状态的排序不敏感，无论是最好最坏还是平均情况时间复杂度总是为O(nlogn)。 注意:由于初始构建堆所需的比较次数较多，因此，它并不适合待排序序列个数较少的情况。 实现 # start是当前需要调整最小堆的位置,end是调整边界def heapAdjust(tempList, start, end): root = start while True: child = root * 2 + 1 if child &gt; end: break if child + 1 &lt;= end and tempList[child] &lt; tempList[child + 1]: child += 1 if tempList[root] &lt; tempList[child]: tempList[root], tempList[child] = tempList[child], tempList[root] root = child else: break def heapSort(tempList): n = len(tempList) # 构造小顶堆 for i in xrange(n / 2, -1, -1): heapAdjust(tempList, i, n - 1) for i in xrange(n - 1, 0, -1): # 将堆顶记录和当前未排序子序列的最后一个记录交换 tempList[0], tempList[i] = tempList[i], tempList[0] # 重新调整为小顶堆 heapAdjust(tempList, 0, i - 1) return tempListprint heapSort([2,4,3,1,6,7,4,2,8]) 七、归并排序归并排序就是利用归并的思想实现的排序算法。原理是:假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两合并，得到n/2的向上取整个长度为2或者为1的有序子序列，然后两两合并，如此重复，直到得到一个长度为n的有序序列。该方法也称为2路归并排序。 比较操作的次数介于 ( nlogn ) / 2 和 nlogn − n + 1。赋值操作的次数是 ( 2 nlogn )。 #归并排序def mergeSort(tempList): length = len(tempList) if length &lt;= 1: return tempList # 二分列表 middle = length / 2 leftList = mergeSort(tempList[:middle]) rightList = mergeSort(tempList[middle:]) return merge(leftList,rightList)def merge(leftList,rightList): leftIndex,rightIndex = 0, 0 result = [] while leftIndex &lt; len(leftList) and rightIndex &lt; len(rightList): if leftList[leftIndex] &lt; rightList[rightIndex]: result.append(leftList[leftIndex]) leftIndex += 1 else: result.append(rightList[rightIndex]) rightIndex += 1 result += leftList[leftIndex:] result += rightList[rightIndex:] return resultprint mergeSort([2,5,1,2,0,6,3]) 一趟归并需要耗费O(n)时间，由完全二叉树的深度可知，整个归并排序需要进行logn次，故，总的时间复杂度为O(logn)，并且最好/最坏/平均时间性能均是如此。 归并排序需要两两比较，不存在跳跃，因此稳定。 八、快速排序20世纪十大算法之一。 关键词:基准 分组 递归 在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较。 快速排序使用分治法策略来把一个序列分为两个子序列。 步骤为： 从数列中挑出一个元素，作为基准数， 分区：把比基准大的放在右边，比基准小的放在左边，等于基准的放在基准列表中。 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 def quickSort(tempList): if len(tempList) &lt;= 1: return tempList # 基准列表 pivotList = [] # 比基准小的列表 lessList = [] # 比基准大的列表 moreList = [] #将第一个值作为基准 pivot = tempList[0] # 遍历tempList for x in tempList: # 比基准大,放入moreList if x &gt; pivot: moreList.append(x) # 比基准小,放入lessList elif x &lt; pivot: lessList.append(x) # 与基准相等,放入基准列表中 else: pivotList.append(x) # 对lessList和moreList递归操作 lessList = quickSort(lessList) moreList = quickSort(moreList) # 返回排序好的列表 return lessList + pivotList + moreList 甚至可以这么写 def quickSort1(tempList): if len(tempList) &lt;= 1: return tempList else: pivot = tempList[0] return quickSort1([x for x in tempList[1:] if x &lt; pivot])\ + [pivot] + \ quickSort1([x for x in tempList[1:] if x &gt;= pivot])print quickSort1([5,7,8,2,6,8,0,5]) 快速排序的时间复杂度取决于快速排序递归的深度，在最优情况下时间复杂度为O(logn)。最坏情况下，待排序为正序或者逆序，时间复杂度为O(n^2) 由于关键字的比较和交换是跳跃进行的，因此快速排序不稳定。 快速排序的优化: 优化选取枢轴三数取中法:取三个关键字先进行排序，将中间数作为枢轴，一般取左端、右端和中间三个数，也可以随机选取，至少枢轴不是最大或者最小的数。 九、计数排序计数排序是用来排序0到100之间的数字的最好的算法。 步骤: 找出待排序的数组中最大和最小的元素统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 #计数排序def countsort(tempList): if len(tempList) &lt;= 1: return tempList maxValue = max(tempList) minValue = min(tempList) # 创建计数列表countList countList = [0] * (maxValue - minValue + 1) # 获取元素出现次数 for e in tempList: countList[e - minValue] += 1 index = 0 # 填值 for a in xrange(maxValue - minValue + 1): for c in xrange(countList[a]): tempList[index] = a + minValue index += 1 return tempList print countsort([1,6,3,2,3]) 那么,以1,6,3,2,3为例最值maxValue = 6minValue = 1 计数列表countList = [0, 0, 0, 0, 0, 0] 元素出现的次数countList = [1, 1, 2, 0, 0, 1] a countList[a] 即遍历次数 tempList[index] 0 1 tempList[0] = 1 1 1 tempList[1] = 2 2 2 tempList[2] = 3以及tempList[3] = 3 3 0 4 0 5 1 tempList[4] = 6 排序成功:1, 2, 3, 3, 6 十、总结算法分析： 代码保存在GitHub上。 参考资料： 《大话数据结构》维基百科segmentfaultWuChongbubkoo]]></content>
      <categories>
        <category>Python</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自定义转场总结]]></title>
    <url>%2F2017%2F02%2F26%2FiOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[自定义转场总结。 一、勾弦转场的本质是下一场景的视图替换当前场景的视图以及相应的控制器的替换，表现为当前视图消失和下一视图出现。容器类 VC 的转场里 fromView 和 toView 是 containerView 的子层次的视图，而 Modal 转场里 presentingView 与ontainerView 是同层次的视图，只有 presentedView 是 containerView 的子层次视图。Custom 模式下 Modal 转场结束时 fromView 并未从视图结构中移除；FullScreen 模式的 Modal 转场结束后 fromView 主动被从视图结构中移除了。Custom 模式下，在 dismissal 中，不要像其他转场中那样将 toView加入 containerView 中，否则 dismiss 结束后本来可见的 presentingView 将会随着 containerView 一起被移除。 在 Modal 转场中，presentingView 并非 containerView 的子视图，这时通过viewForKey:方法来获取presentingView 得到的是 nil，必须通过viewControllerForKey:得到presentingVC 后来获取。当 UIViewController 的modalPresentationStyle属性为.Custom 或.FullScreen时，就有机会定制转场效果，此时modalTransitionStyle指定的转场动画将会被忽略。 容器 VC 的转场的代理由容器 VC 自身的代理提供不同，Modal 转场的代理由 presentedVC(目标控制器) 提供。Modal 转场在 Custom 模式下必须区分 presentation 和 dismissal 转场，而在 FullScreen 模式下可以不用这么做，因为 UIKit 会在 dismissal 转场结束后自动将 presentingView 放置到原来的位置。转场代理（Transitioning Delegate）根据不同的转场类型提供其所需要的动画控制类和交互控制类。 动画控制类(器)（Animation Controller）遵从UIViewControllerAnimatedTransitioning协议，并且负责执行实际的动画。交互控制类(器)（Interaction Controller）遵从UIViewControllerInteractiveTransition协议来控制可交互的转场动画。转场上下文（Transitioning Context）定义了转场时需要的元数据（比如转场所参与了的视图控制器和视图的属性），其遵从UIViewControllerContextTransitioning协议，并且这是由系统负责生成和提供。 转场协调器（Transition Coordinators）可以在运行转场动画时，并行的运行其他动画。转场协调器遵从UIViewControllerTransitionCoordinator协议。转场动画交互方式分两种，第一种是属于非交互式：必须要实现动画控制类，第二种交互式：必须要实现动画控制类和交互控制类（例如可以通过手势的滑动距离来控制转场动画的一个进度，一般应用中都可以通过手势的滑动来推出一个视图控制器)。 二、简单转场基本类型 UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。UIViewAnimationOptionRepeat：重复运行动画。UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场 动画）。 UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。 动画速度控制（可从其中选择一个设置） UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。UIViewAnimationOptionCurveEaseOut：动画逐渐加速。UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。 转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置） UIViewAnimationOptionTransitionNone：没有转场动画效果。UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。 简单使用 作用于fromView的父视图，切换两个view，将formView从其父视图上移除，将toView重新粘在其父视图上，展现一个动画效果。 [UIView transitionFromView:self.view toView:redView duration:5.0 options:UIViewAnimationOptionCurveLinear completion:^(BOOL finished) &#123; kLog(@"转场动画完成");&#125;]; 重绘View视图，任何其子视图的改变或者其自身的改变都会触发转场动画的效果。 [UIView transitionWithView:self.view duration:2.0 options:UIViewAnimationOptionCurveLinear animations:^&#123; self.view.alpha = 0.1;&#125; completion:^(BOOL finished) &#123; kLog(@"动画完成");&#125;]; 三、模态转场源控制器A–&gt;目标控制器B (1) 提要可以只使用一个动画控制器Animator，但是要对Present/Dismiss分别实现。模态的类型默认为FullScreen，即在Present时，会移除fromView，而类型设置为Custom时，就会使fromView与toView共存。present时，要把toView加入到container的视图层级，dismiss时，要把fromView从container的视图层级中移除。非交互式转场，需要在动画执行完毕声明complete[transitionContext completeTransition:YES];交互式转场，需要判断转场完成或者取消。 BOOL isCancelled = transitionContext.transitionWasCancelled;// 考虑到转场中途可能取消的情况，转场结束后，恢复视图状态。fromView.transform = CGAffineTransformIdentity;toView.transform = CGAffineTransformIdentity; 在模态中，设置将要跳转到的视图控制器(presentedViewController)的transitioningDelegate。充当代理的对象可以是源视图控制器(presentingViewController)，也可以是自己创建的对象，它需要为转场动画提供一个animator对象。animator对象的animateTransition是整个动画的核心逻辑。 (2) 无交互设置目标控制器B的代理(可以是A，也可以是B)以及模态动画类型(常用UIModalPresentationCustom或UIModalPresentationFullScreen)。 YAShareViewController *shareViewController = [[YAShareViewController alloc] init]; // 设置转场代理shareViewController.transitioningDelegate = self;// 设置转场动画类型shareViewController.modalPresentationStyle = UIModalPresentationCustom;[self presentViewController:shareViewController animated:YES completion:nil]; // 目标控制器的代理遵守UIViewControllerTransitioningDelegate协议并相关实现方法#pragma mark - Transitioning Delegate// 无交互出现动画- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123; YATransitionAnimator *animator = [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPresent]; return animator;&#125; // 无交互消失动画- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed &#123; YATransitionAnimator *animator = [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorDismiss]; return animator;&#125; 代理方法中的动画管理者Animator独立存在，可以新建一继承自NSObject且遵守UIViewControllerAnimatedTransitioning协议的对象担任(仅仅遵守协议实现方法即可，不需设置代理)。 #pragma mark – Life Cycle + (instancetype)transitionAnimatorWithType:(TransitionAnimatorType)transitionAnimatorType &#123; YATransitionAnimator *animator = [[YATransitionAnimator alloc] init]; animator.transitionAnimatorType = transitionAnimatorType; return animator;&#125; #pragma mark - AnimatedTransitioning delegate //返回动画时间- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; return 5.0;&#125; //执行动画的地方- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; // 1.获取动画必要元素 UIView *containerView = [transitionContext containerView]; UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey]; UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey]; toView.origin = CGPointMake(0， kScreenHeight); // 2.动画 // 出场 if (self.transitionAnimatorType == TransitionAnimatorPresent) &#123; // 2.添加toView，不一定是addSubview方式 [containerView addSubview:toView]; [UIView animateWithDuration:2.5 animations:^&#123; toView.origin = CGPointMake(0， 0); &#125; completion:^(BOOL finished) &#123; // 完成 [transitionContext completeTransition:YES]; &#125;]; &#125; // 消失 if (self.transitionAnimatorType == TransitionAnimatorDismiss) &#123; [UIView animateWithDuration:2.5 animations:^&#123; fromView.origin = CGPointMake(0， kScreenHeight); &#125; completion:^(BOOL finished) &#123; // 2.添加toView，不一定是addSubview方式 [fromView removeFromSuperview]; // 完成 [transitionContext completeTransition:YES]; &#125;];&#125;&#125; (3) 交互(坑多，所以一般不用下列方式，取而代之使用UIPresentationController。) 在目标控制器的代理方法中，实现交互式代理方法: // 2.交互出现动画- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123; return [[YAInteractiveTransition alloc] init];&#125;// 2.交互消失动画- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123; return [[YAInteractiveTransition alloc] init];&#125; 新建一继承自UIPercentDrivenInteractiveTransition的交互组件类(最好这么做，也可以自定义类遵守UIViewControllerInteractiveTransitioning协议，但极不推荐)，实现必须的startInteractiveTransition方法。 - (void)startInteractiveTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;&#125; (4) UIPresentationControlleriOS8后的新API，极其方便。把管理权限交给UIPresentationController.设置模态动画类型后，只需要在目标控制器的代理方法中实现: - (nullable UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(nullable UIViewController *)presenting sourceViewController:(UIViewController *)source &#123; return [[YAPresentationController alloc] initWithPresentedViewController:presented presentingViewController:presenting];&#125; 那么所有的工作就在YAPresentationController控制器中了。实现相应的方法: //在呈现过渡即将开始的时候被调用的- (void)presentationTransitionWillBegin&#123; // 源控制器的View [self.containerView addSubview:self.presentingViewController.view]; // 背景View [self.containerView addSubview:self.backgroundView]; // 目标控制器View [self.containerView addSubview:self.presentedView]; &#125; //在呈现过渡结束时被调用的- (void)presentationTransitionDidEnd:(BOOL)completed&#123; &#125; //在退出过渡即将开始的时候被调用的- (void)dismissalTransitionWillBegin&#123; &#125; //在退出的过渡结束时被调用的- (void)dismissalTransitionDidEnd:(BOOL)completed&#123; &#125; // 调整呈现的View的frame- (CGRect)frameOfPresentedViewInContainerView&#123; &#125; 四、NavigationController转场设置源控制器的导航控制器的代理，遵守UINavigationControllerDelegate协议，根据交互式或者非交互式实现相应方法.在方法中根据Push或者Pop返回相应的自定义动画控制器(或者交互控制器)。 // 交互式- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController &#123; &#125; // 非交互式- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; // Push情况下 if (operation == UINavigationControllerOperationPush) &#123; return [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPush]; &#125; else if (operation == UINavigationControllerOperationPop) &#123; // Pop情况下 return [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPop]; &#125; else &#123; return nil; &#125; &#125; 五、TabBarController转场与导航控制器类似，设置源控制器的tabBarController的代理，遵循UITabBarControllerDelegate，实现相应的方法，只不过它既没有模态的Present和Dismiss，也没有导航控制器的Push和Pop，只有一种方式，更加简单，同样，在方法中返回自定义的动画控制器(或者交互控制器)。 - (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)tabBarController: UITabBarController *)tabBarControllerinteractionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController &#123;&#125; - (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController animationControllerForTransitionFromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123;&#125;]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git/LLDB/Linux等常用命令]]></title>
    <url>%2F2017%2F02%2F20%2FGit%3ALLDB%3ALinux%E7%AD%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[2017.4.3 补充Clang指令2017.4.2 补充 Git/SVN/Linux/Vim/LLDB等常用、快忘记的命令总结。 CocoaPodspod install --verbose --no-repo-update Git源代码管理工具能追踪一个项目从诞生一直到定案的过程，记录一个项目的所有内容变化，方便地查阅特定版本的修订情况。 Git与SVN的对比:1.Git是分布式，有本地分支，SVN是集中式，无本地分支。2.git合并操作保留原有的提交过程（即保留了合并来源的作者、提交次数、分离提交的内容）。svn合并操作把来源多个提交合并成了一个合并提交。3.git：可以修正提交(在自己的分支)。svn：一旦提交就到服务器上，实际使用中就是不能修改。4.SVN没有tag和真正意义的分支(它的分支是一个完整的目录。且这个目录拥有完整的实际文件)，Git支持。5.Git有暂存区，提交速度快。 开始1.清除本地以及远程的.DS_Store文件(修复后添加.gitignore) find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch 2.克隆仓库到本地 git clone https://github.com/ChenYalun/a.git 3.添加忽略文件 git add .gitignore 4.提交修改 git commit -m &quot;注释&quot; 5.推送到远程仓库 git push YAKit(仓库名称) origin(分支名称) 初步在git中，版本号是一个由SHA1生成的哈希值。 查看git所有命令的帮助 $ git help 子命令 # 要退出帮助信息，按&quot;q&quot; # 翻看下页，按&quot;空格&quot; # 翻看上页，按&quot;CTRL+B&quot; # 要搜索相关文字，按&quot;/&quot;然后输入&quot;相关文字&quot; 配置以及全局配置 git config user.name &quot;chenyalun&quot; git config user.email iChenYalun@gmail.com git config --global user.name &quot;chenyalun&quot; git config --global user.email iChenYalun@gmail.com 查看当前所有配置 git config -l 编辑(全局)配置文件 git config -e [--global] 在当前目录下初始化仓库 git init 新建一个目录，将其初始化为Git代码库 git init [目录] 添加所有的文件/指定的文件到暂存区 git add . git add a.h，a.m 添加目录到暂存区 git add [dir] 删除工作区文件 git rm a.h a.m 停止追踪指定文件,但是文件会保存在工作区 git rm --cached a.h 改名,并且将这个改名放入暂存区 git mv old.h new.h 提交文件，添加注释，要使用 -m 参数指定修改的备注信息 git commit -m &quot;初始化仓库&quot; 使用git时，每一次修改都需要添加(add)再提交(commit)，这一点是与svn不一样 查询代码库当前状态(已加载，未加载等) git status 查看所有版本库日志 git log 查看指定文件(a.m)的版本库日志 git log a.m 追加提交 git commit -m &apos;initial commit&apos; git add forgotten_file git commit --amend 撤销某次提交 git revert commitId 提交时显示所有diff信息 git commit -v 使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化 git commit --amend a.h a.m 版本恢复暂存区的指定文件到工作区 git checkout a.h 恢复某个commit的指定文件到暂存区和工作区 git checkout [commit] [file] 恢复暂存区的所有文件到工作区 git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 git reset a.h 重置暂存区与工作区，与上一次commit保持一致 git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git reset --keep [commit] 新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支 git revert [commit] 暂时将未提交的变化移除，稍后再移入 git stash git stash pop 查看git的总提交次数 git rev-list head | sort | wc -l 分支列出所有本地分支 git branch 列出所有远程分支 git branch -r 列出所有本地分支和远程分支 git branch -a 新建一个分支，但依然停留在当前分支 git branch [branch-name] 新建一个分支，并切换到该分支 git checkout -b [branch] 新建一个分支，指向指定commit git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区 git checkout [branch-name] 切换到上一个分支 git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch] [remote-branch] 如:git branch --set-upstream dev remotes/origin/dev,名字保持一致 合并指定分支到当前分支 git merge [branch] // 通常使用下面这条: git merge --no-ff [branch] 选择一个commit，合并进当前分支 git cherry-pick [commit] 删除分支 git branch -d [branch-name] 删除远程分支 git push origin --delete [branch-name] git branch -dr [remote/branch] 仓库添加新的远程仓库 git remote add &lt;name&gt; &lt;url&gt; 拉取远程仓库的内容 git fetch &lt;name&gt; [branchName] //不会合并，只拉取 git pull &lt;name&gt; [branchName] //拉取并且合并 移除某个远程仓库 git remote rm &lt;name&gt; 重命名远程仓库 git remote rename oldShortName newShortName 查看远程仓库的url git remote -v 标签列出所有tag git tag 新建一个tag在当前commit git tag [tag] 新建一个tag在指定commit git tag [tag] [commit] 删除本地tag git tag -d [tag] 删除远程tag git push origin :refs/tags/[tagName] 查看tag信息 git show [tag] 提交指定tag git push [remote] [tag] 提交所有tag git push [remote] --tags 新建一个分支，指向某个tag git checkout -b [branch] [tag] 远程下载远程仓库的所有变动 git fetch [remote] 显示所有远程仓库 git remote -v 显示某个远程仓库的信息 git remote show [remote] 增加一个新的远程仓库，并命名 git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 git pull [remote] [branch] 上传本地指定分支到远程仓库 git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --force 推送所有分支到远程仓库 git push [remote] --all 其他设置git别名 git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status git config --global alias.unstage &apos;reset HEAD --&apos; 文件权限不纳入版本管理 git config core.filemode false SVN初步checkout将服务器上最新的代码仓库下载到本地，”只需要做一次” update从服务器上将其他人所做的修改下载到本地 commit将工作提交到服务器 将文件添加到本地版本库中 svn add main.c 将文件提交到服务器的版本库中 svn ci -m &quot;添加了main.c文件&quot; 删除文件 svn rm Person.h 提交删除 svn ci -m &quot;删除了文件&quot; 注意：不要使用文件管理器直接删除文件 撤销文件的修改 svn revert Person.m 恢复到之前的某个版本 svn update -r 5 svn up svn help (查看svn所有命令的帮助) checkoutsvn co http://192.168.1.188/svn/weibo --username=manager --password=manager checkout(co)之后，命令行会记录用户名和密码，后续操作不用再另行指定 基本命令行格式： svn &lt;subcommand&gt; [options] [args] 说明 svn 子命令 [选项] [参数] 提示： [中括号]中包含的内容是可选的 (子命令缩写) 状态查看svn日志 svn log 查看某一个文件的日志 svn log filename 查看某一个文件某个版本的日志 svn log filename@1 查看工作目录状态 svn st SVN st状态说明：描述文件被添加、删除或其他修改 &apos; &apos; 没有修改 &apos;A&apos; 被添加到本地代码仓库 &apos;C&apos; 冲突 &apos;D&apos; 被删除 &apos;I&apos; 被忽略 &apos;M&apos; 被修改 &apos;R&apos; 被替换 &apos;X&apos; 外部定义创建的版本目录 &apos;?&apos; 文件没有被添加到本地版本库内，不在SVN的管理之下 &apos;!&apos; 文件丢失或者不完整(不识别该文件) &apos;~&apos; 受控文件被其他文件阻隔 &apos;U&apos; 更新最新的代码到本地(本地有文件的情况下) &apos;G&apos; 产生冲突后，更新操作去解决冲突，相当于进行合并 目录Trunk目前项目正在开发的版本 Tags存放已经上线的重大版本 Branches当发生重大bug或者有新需求时 Linux文件 读权限（r）写权限（w) 可执行权限（x）。 第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。 文件类型+所有者+用户组+其他用户。 空格:下一屏 回车:一行 q:退出 /word:搜索word (以及tab的自动补全) 初步最基本(不阐述) cd clear pwd mkdir rmdir who whoami exit ping 查看 ls -a(所有) -l(列表) -h(显示大小) 重定向(结果重定向到一个文件，不存在创建，存在覆盖) ls &gt; a.txt 分屏 more 管道(一个命令的结果作为另一个命令的输入) ls -a | more 删除 rm Dir/ -r 递归地删除，删除文件夹必带 rm a.txt -f 强制删除，忽略不存在的文件，无需提示 rm b -i 交互式 链接软链接:软链接不占用磁盘空间，源文件删除则软链接失效。(快捷方式)硬链接:硬链接只能链接普通文件，不能链接目录。两个文件占用相同大小的硬盘空间，不常用。 ln 源文件 链接文件 (硬链接) ln -s 源文件 链接文件 查看或合并 cat q.txt cat 1.txt 2.txt &gt; 3.txt (重定向) 文本搜索可正则 grep -v(选项) &apos;app&apos;(匹配字符串) a.txt(文件名) -v 显示不包含匹配文本的所有行 -n 显示匹配行及行号 -i 忽略大小写 查找 find ./ -name a.txt find ./ -name &apos;*.txt&apos; find ./ -size +10M(大于10M) 拷贝 cp -a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。 -f 强制 -i 交互 -r 递归 -v 进度 移动(重命名) mv -f -v -i 归档与压缩 tar [参数] 打包文件名 文件 gzip [选项] 被压缩文件 切换用户 su 不切换目录 su - 切换目录 su root 到root su -root 到root，同时到/root目录 系统日历 cal 时间 date 网卡 ifconfig 进程 ps -a 所有 -u 详细状态 -x 显示没有控制终端的进程 -w 显示加宽 -r 正在运行 动态进程 top M 内存使用量 排序 P CPU占有率 排序 T 运行时间 排序 U 可以根据后面输入的用户名来筛选进程 K 可以根据后面输入的PID来杀死进程。kill pid q 退出 h 获得帮助 关机重启 reboot 重启 shutdown –r now 重新启动 shutdown -h now 立刻关机 shutdown -h 20:25 在今天的20:25会关机 shutdown -h +10 过十分钟后自动关机 init 0 关机 init 6 重启 磁盘空间 df -a 所有 -m 以1024字节为单位显示 -t 显示各指定文件系统的磁盘空间使用情况 -T 显示文件系统 目录所占磁盘空间 du -a 递归 -s 显示指定文件或目录占用的数据块 -b 以字节为单位显示磁盘占用情况 -l 计算所有文件大小，对硬链接文件计算多次 Vim初步i: 插入光标前一个字符 I: 插入行首 a: 插入光标后一个字符 A: 插入行未 o: 向下新开一行，插入行首 O: 向上新开一行，插入行首 ESC:从插入模式或末行模式进入命令模式 移动光标: h: 左移 j: 下移 k: 上移 l: 右移 M: 光标移动到中间行 L: 光标移动到屏幕最后一行行首 G: 移动到指定行，行号 -G w: 向后一次移动一个字 b: 向前一次移动一个字 {: 按段移动，上移 }: 按段移动，下移 Ctr-d: 向下翻半屏 Ctr-u: 向上翻半屏 Ctr-f: 向下翻一屏 Ctr-b: 向上翻一屏 gg: 光标移动文件开头 G: 光标移动到文件末尾 删除命令: x: 删除光标后一个字符，相当于 Del X: 删除光标前一个字符，相当于 Backspace dd: 删除光标所在行，n dd 删除指定的行数 D: 删除光标后本行所有内容，包含光标所在字符 d0: 删除光标前本行所有内容，不包含光标所在字符 dw: 删除光标开始位置的字，包含光标所在字符 撤销命令: u: 一步一步撤销 Ctr-r: 反撤销 重复命令: .: 重复上一次操作的命令 文本行移动: &gt;&gt;:文本行右移动 &lt;&lt;:文本行左移动 复制粘贴: yy: 复制当前行，n yy 复制 n 行 p: 在光标所在位置向下新开辟一行，粘贴 可视模式: v: 按字符移动，选中文本 V: 按行移动，选中文本可视模式可以配合 d， y， &gt;&gt;， &lt;&lt; 实现对文本块的删除，复制，左右移动 替换操作: r: 替换当前字符 R: 替换当前行光标后的字符 查找命令: /: str查找 n: 下一个 N：上一个 替换命令： 把abc全部替换成123 末行模式下，将光标所在行的abc替换成123 :%s/abc/123/g 末行模式下，将第一行至第10行之间的abc替换成123 :1， 10s/abc/123/g vim里执行 shell 下命令: 末行模式里输入!，后面跟命令 LLDB初步help 输出 p (int)self.view.subviews.count 基本类型 po self.view 对象 修改 expr a = 3 expr int $c = 10 声明一个新变量 调用 call self.view.backgroundColor = [UIColor redColor] 方法无返回值时使用call 堆栈 bt 加all可打印所有thread的堆栈 寻址 image lookup --address 0x0000000103aca1e1 寻找栈地址对应的代码位置 Clang初步 编译单个c源文件，并产生一个目标文件 cc -c one.c 编译多个c源文件，并为每个文件产生一个目标文件 cc -c one.c two.c three.c 链接单个目标文件产生一个名为a.out的可执行文件 cc one.o 链接多个目标文件 cc one.o two.o three.o 编译并链接一个c源文件 cc one.c 编译并链接多个c源文件 cc one.c two.c three.c 编译一个c源文件，并把它和现存的目标文件链接在一起 cc one.o two.o three.c 可执行文件重命名加上“-o name”这个选项 cc -o abc one.c 执行可执行文件 ./a.out 编译C++文件 clang++ -Wall -g -std=c++11 -stdlib=libc++ fileName.cpp -o targetFileName]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>SVN</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用优化总结]]></title>
    <url>%2F2017%2F02%2F14%2FiOS%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一些优化的Tips。 内存 UITableView采用注册的方式使用reuseIdentifierstatic NSString *CellIdentifier = @&quot;Cell&quot;;复用 Cell 与各个 Section 的 Header 和 Footer。复用 Cell 时， storyboard 中的 cell 设置 reuseIdentifier 完毕即可，无需注册，xib 与 class 自定义的cell 需要设置 reuseIdentifier 而且要注册。 使用UITableView+FDTemplateLayoutCell优点:预缓存机制/自动的缓存失效机制/根据 autolayout 约束自动计算高度。注意:cacheByKey比cacheByIndexPath 更为高效。 return [tableView fd_heightForCellWithIdentifier:reuseIdentifier cacheByIndexPath:indexPath configuration:^(YACommentTableViewCell *cell) &#123; cell.comment = self.comments[indexPath.section][indexPath.row]; &#125;]; 使用 // 不缓存高度return [tableView fd_heightForCellWithIdentifier:reuseIdentifier configuration:^(YACommentTableViewCell *cell)&#123; cell.comment = self.comments[indexPath.section][indexPath.row]; &#125;]; // 更高效，但是当高度变化时，需要手动清除缓存YACommentModel *model = self.comments[indexPath.section][indexPath.row];return [tableView fd_heightForCellWithIdentifier:reuseIdentifier cacheByKey:model.ID configuration:^(id cell) &#123; cell.comment = self.comments[indexPath.section][indexPath.row];&#125;]; // 移除 key 对应的高度缓存[tableView.fd_keyedHeightCache invalidateHeightForKey:key];// 移除所有高度缓存[tableView.fd_keyedHeightCache invalidateAllHeightCache]; 设置 opaque 为YES，尽量把 view 设置为透明。 尽量不使用cellForRowAtIndexPath:，用一次然后缓存结果。 尝试缓存。 保证XIB文件的小巧灵活。 预处理懒加载。 处理内存警告。 单一固定的情况下，使用rowHeight， sectionFooterHeight和 sectionHeaderHeight来设定固定的高，而不是请求delegate。 使用 shadowPath，view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath]; // 而不是: view.layer.shadowOffset = CGSizeMake(-1， 1); view.layer.shadowRadius = 1.0f; view.layer.shadowOpacity = 0.1; 优化 合理开线程，主线程占1M，子线程占512K。UI 操作和 DataSource 的操作一定在主线程。DB 操作、日志记录、网络回调都在各自的固定线程。 选择合适的容器，减少subviews的数量。NSArrayi:有序的。能搞按照索引快速查找元素。按照值查找很慢，插入和删除很慢。NSDictionary:无序的。键值对存储。按照key可以快速查找。NSSet: 无序的。按照值可以快速查找，插入和删除很快。 正确使用 imageNamed: 与 imageWithContentsOfFile:，imageNamed:的优点是当加载时会缓存图片，所以当图片会频繁的使用时，用imageNamed:。imageWithContentsOfFile：仅加载图片，图像数据不会缓存，对于较大的图片以及使用情况较少时，就可以用该方法，降低内存消耗。 慎用 NSDateFormatter和NSCalendar，缓存 NSDateFormatter 的结果。Creating a date formatter is not a cheap operation. If you are likely to use a formatter frequently， it is typically more efficient to cache a single instance than to create and dispose of multiple instances. One approach is to use a static variable. 在iOS 7、macOS 10.9及以上系统版本，NSDateFormatter都是线程安全的。 @property (nonatomic， strong) NSDateFormatter *formatter; - (NSDateFormatter *)formatter &#123; static NSDateFormatter *formatter; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken， ^&#123; _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @"EEE MMM dd HH:mm:ss Z yyyy"; // twitter date format &#125;); return formatter;&#125; 寻找 (NSDate *)dateFromString:(NSString )string 的替换品。下面是ISO8601 转成 NSDate 的 NSDateFormatter 的最著名替代品，也可以使用开源作品:NSDate+SSToolkitAdditions。 //#include &lt;time.h&gt;time_t t;struct tm tm;strptime([iso8601String cStringUsingEncoding:NSUTF8StringEncoding]， "%Y-%m-%dT%H:%M:%S%z"， &amp;tm);tm.tm_isdst = -1;t = mktime(&amp;tm);[NSDate dateWithTimeIntervalSince1970:t + [[NSTimeZone localTimeZone] secondsFromGMT]]; 不要随意使用 NSLog()。 #ifdef DEBUG// Only log when attached to the debugger# define DLog(...) NSLog(__VA_ARGS__)#else# define DLog(...) /* */#endif// Always log， even in production#define ALog(...) NSLog(__VA_ARGS__) 当试图获取磁盘中一个文件的属性信息时，使用 [NSFileManager attributesOfItemAtPath:error:]会浪费大量时间读取可能根本不需要的附加属性。这时可以使用 stat 代替 NSFileManager，直接获取文件属性： #import &lt;sys/stat.h&gt; struct stat statbuf; const char *cpath = [filePath fileSystemRepresentation]; if (cpath &amp;&amp; stat(cpath， &amp;statbuf) == 0) &#123; NSNumber *fileSize = [NSNumber numberWithUnsignedLongLong:statbuf.st_size]; NSDate *modificationDate = [NSDate dateWithTimeIntervalSince1970:statbuf.st_mtime]; NSDate *creationDate = [NSDate dateWithTimeIntervalSince1970:statbuf.st_ctime]; // etc &#125; MLeakFinder 能在开发阶段，把内存泄露问题暴露无遗，减少了很多潜在的性能问题. 原理:在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 view，view 的 subviews 等等是否还存在。 接入bugly。 创造圆形图片避免使用以下方式(会造成离屏渲染): view.layer.cornerRadius = view.width * 0.5; view.layer.masksToBounds = true 圆形图片 UIBezierPath *clipPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0， 0， image.size.width， image.size.height)] ; [clipPath addClip] ; [image drawAtPoint:CGPointZero] ; image = UIGraphicsGetImageFromCurrentImageContext() ; UIGraphicsEndImageContext() ; return image ; 设置Label的圆角。 // 不要这么做：label.backgroundColor = aColor // 以及不要在 IB 里为 label 设置背景色label.layer.backgroundColor = aColorlabel.layer.cornerRadius = 5 指定图片的宽高为整数，否则造成离屏渲染。 cell当中不要动态的添加子控件，选中适时地显示与隐藏。 当控件非常多时，把不需要与用户进行交互的控件.通过异步绘制成一张图片，把图片添加到cell当中。 将 UIView 的属性 clearsContextBeforeDrawing 设置为 NO 在多数情况下可以提高绘制性能，尤其是在用绘制代码实现了一个定制 view 的时候。 设置阴影。 view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath]; // 而不是view.layer.shadowOffset = CGSizeMake(-1.0f， 1.0f);view.layer.shadowRadius = 5.0f;view.layer.shadowOpacity = 0.6; 通常图层的以下属性将会触发离屏渲染： 阴影（UIView.layer.shadowOffset/shadowRadius/…）圆角（当 UIView.layer.cornerRadius 和 UIView.layer.maskToBounds 一起使用时）图层蒙板 使用 Autorelease Pool，当需要在代码中创建许多临时对象时，可以显式的使用 Autorelease Pool。 使用IMP。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS常用设计模式]]></title>
    <url>%2F2017%2F02%2F11%2FiOS%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[关于设计模式。 原型 原型模式是通过克隆已有的对象来创建新的对象，已有的对象即为原型。(Objective-C中的深复制) 优点:将创建对象的代码隐藏，屏蔽初始化的具体细节，避免重复耗时的过程。 当需要创建一个新的实例，但不想依赖初始化器，使用此模式。 注意:深复制与浅复制的问题。浅复制:复制对象的引用，深复制:复制对象本身。不可变对象的copy操作是浅复制，其他情况是深复制，但是集合类对象即便是深复制，也是复制集合类对象自身，里面的元素并未复制，或者说是单层深复制，而要对集合类对象进行完全彻底的复制，归档可以解决。 应用:实现NSCopying协议并保证类的基类是NSObject。 实现方法: 根类遵循NSCopying协议，重写copyWithZone方法，创建一个复制方法Operation，方便自身以及增加属性的子类再次复制。 YAObject担当根类，遵循NSCopying协议，重写copyWithZone方法，提供复制接口copyWithObject，方便自身以及子类复制.YAPerson增加两个属性，且类型是集合类。 @interface YAObject : NSObject &lt;NSCopying&gt;/** 年龄 */@property (nonatomic，assign) NSInteger age;/** 姓名 */@property (nonatomic，copy) NSString *name; /** 复制操作 */- (void)copyWithObject:(NSObject *)object;@end @interface YAPerson : YAObject/** 书籍 */@property (nonatomic，strong) NSArray *books;/** 朋友 */@property (nonatomic，strong) NSMutableArray *friends;@end copyWithZone操作中，[self class]使子类也能调用此方法，子类中，重写copyWithObject操作，当有集合类元素的时候，不能单纯的[array copy]，这样仅是复制了集合元素自身，却没有复制集合中的元素，是单层深复制，要copyItems。 @implementation YAObject// 实现的时候用copyWithZone，调用的时候用copy，最顶层的根类重写该方法，子类调用但不得重写- (id)copyWithZone:(NSZone *)zone &#123; YAObject *object = [[[self class] allocWithZone:zone] init]; // 把自己copy后赋予object [self copyWithObject:object]; return object;&#125;// 自身以及子类实现该方法以赋值给object- (void)copyWithObject:(YAObject *)object &#123; object.name = self.name; object.age = self.age;&#125;@end@implementation YAPerson// 又增加了属性// 自身以及子类实现该方法以赋值给object- (void)copyWithObject:(YAPerson *)object &#123; [super copyWithObject:object]; object.books = [[NSArray alloc] initWithArray:self.books copyItems:YES]; object.friends = [[NSMutableArray alloc] initWithArray:self.friends copyItems:YES];&#125;@end 测试 YAObject *object = [[YAObject alloc] init];object.name = @"Aaron";object.age = 22;kLog(@"%@--%ld"，object.name， object.age); YAObject *objectB = [object copy];kLog(@"%@--%ld"，objectB.name， objectB.age); YAPerson *person = [[YAPerson alloc] init];person.name = @"A";person.age = 25;person.books = @[@"V"，@"T"，@"N"];person.friends = [NSMutableArray arrayWithObjects:@"QQ"，@"WeChat"， nil]; YAPerson *personB = [person copy];kLog(@"%@-%ld-%@-%@"，personB.name， personB.age， personB.books， personB.friends); 单例 单例模式保证某个类型的对象在应用中只存在一个实例。 封装共享资源，管理代表现实世界资源的对象。 当进一步创建对象却不能增加现实中的可用资源，或者希望对象只存在一个实例时使用。 要求该实例无法真正意义上被复制克隆。 实现:考虑多线程，重写alloc init方法。 考虑调用copy等方法，不遵循NSCopying协议，重写Copy等方法。 @interface YASingleton : NSObject // 接口 + (instancetype)sharedSingleton; @end @implementation YASingleton // 重写alloc init static YASingleton *singleton = nil; + (instancetype)allocWithZone:(struct _NSZone *)zone &#123; if (singleton == nil) &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken， ^&#123; singleton = [super allocWithZone:zone]; &#125;); &#125; return singleton; &#125; - (instancetype)init &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken， ^&#123; singleton = [super init]; &#125;); return singleton; &#125; // 考虑复制的情况 /* 不建议 - (id)mutableCopyWithZone:(struct _NSZone *)zone &#123; return singleton; &#125; - (id)copyWithZone:(struct _NSZone *)zone &#123; return singleton; &#125; */ - (id)copy &#123; return singleton; &#125; - (id)mutableCopy &#123; return singleton; &#125; // 接口 + (instancetype)sharedSingleton &#123; return [[self alloc] init]; &#125; @end 除了使用GCD，也可以使用互斥锁。 // 互斥锁的形式+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123; if (singleton == nil) &#123; @synchronized (self) &#123; singleton = [super allocWithZone:zone]; &#125; &#125; return singleton;&#125; 打印地址，验证： YASingleton *sing = [YASingleton sharedSingleton];YASingleton *singB = [sing copy];YASingleton *singC = [sing mutableCopy];YASingleton *singD = [[YASingleton alloc] init];kLog(@"%p-%p-%p-%p"，sing， singB， singC， singD); 似乎封装成宏更好一点： // 单例#define YASingH(Name) + (instancetype)shared##Name; #define YASingM(Name) \static id _instace = nil; \+ (id)allocWithZone:(struct _NSZone *)zone \&#123; \if (_instace == nil) &#123; \static dispatch_once_t onceToken; \dispatch_once(&amp;onceToken， ^&#123; \_instace = [super allocWithZone:zone]; \&#125;); \&#125; \return _instace; \&#125; \\- (id)init \&#123; \static dispatch_once_t onceToken; \dispatch_once(&amp;onceToken， ^&#123; \_instace = [super init]; \&#125;); \return _instace; \&#125; \\+ (instancetype)shared##Name \&#123; \return [[self alloc] init]; \&#125; \- (instancetype)copy \&#123; \return _instace; \&#125; \\- (instancetype)mutableCopy \&#123; \return _instace; \&#125; 适配器 适配器使得两个不兼容的API组件协同工作，用于连接两种不同种类的对象。 解决无法修改或者不修改源代码的组件的兼容性问题。 类适配器:适配器继承主功能组件，遵循适配接口协议。 对象适配器:适配器持有主功能组件(作为成员变量)，遵循适配接口协议。 类适配器的实现 @interface YAMac : NSObject// Mac自带显示接口- (void)show;@end // 一般显示器DVI接口@protocol YADVI &lt;NSObject&gt;- (void)dvi;@end // 适配器:继承自Mac，有显示的功能，遵循YADVI协议，可以显示到一般显示器上@interface YAMacDVIAdapter : YAMac &lt;YADVI&gt;@end @implementation YAMac- (void)show &#123; kLog(@"Mac自带显示接口");&#125;@end // 适配器实现@implementation YAMacDVIAdapter - (void)dvi &#123; [super show]; // 可以显示内容 kLog(@"可以连接到一般的显示器");&#125;@end // 具体使用，调用接口即可YAMacDVIAdapter *adapter = [[YAMacDVIAdapter alloc] init];[adapter dvi]; 当不再继承主功能组件，而是把它作为属性持有的时候，便是对象适配器。 @interface YAMac : NSObject// Mac自带显示接口- (void)show;@end // 一般显示器DVI接口@protocol YADVI &lt;NSObject&gt;- (void)dvi;@end // 适配器:遵循YADVI协议，可以显示到一般显示器上，拥有Mac属性，有显示的功能@interface YAMacDVIAdapter : NSObject &lt;YADVI&gt;@property (nonatomic，strong) YAMac *mac;@end @implementation YAMac- (void)show &#123; kLog(@"Mac自带显示接口");&#125;@end // 适配器实现@implementation YAMacDVIAdapter - (void)dvi &#123; self.mac = [[YAMac alloc] init]; [self.mac show]; kLog(@"可以连接到一般的显示器");&#125; @end // 然而.使用方式没有改变YAMacDVIAdapter *adapter = [[YAMacDVIAdapter alloc] init];[adapter dvi]; MVC MVC 能使整个应用结构化，使应用的各个部分更易开发测试维护。 M是指数据模型，V是指用户界面，C则是控制器。 模型对象封装了应用程序的数据，并定义操控和处理该数据的逻辑和运算.视图对象是应用程序中用户可以看见的对象.控制器对象解释在视图对象中进行的用户操作，并将新的或更改过的数据传达给模型对象。 Model 和 View 永远不能相互通信，只能通过Controller传递。 Controller 与 Model 的通信: Notification 和 KVO。 Controller 与 View 的通信:outlet， action， 数据源，代理等。 MVVM MVC升级版 ViewController 从 ViewModel 层中读取数据然后显示在View上。 ViewController与ViewModel的通信:Block回调和ReactiveCocoa。 ….// 待补充 代理 一个代理对象可以代表其他资源。 当A对象要监听B对象的一些行为时，A成为B的代理.当B对象要通知A对象一些事情时(消息传递)，A成为B的代理。 遵守协议，设置代理，实现方法。 实现: // 定义协议@protocol YACodeDelegate &lt;NSObject&gt;@required- (void)code;@end @interface YAMan : NSObject// 代理属性@property (nonatomic， weak) id delegate;@end @interface YACoder : NSObject &lt;YACodeDelegate&gt;@end @implementation YAMan- (void)setup &#123; if ([self.delegate respondsToSelector:@selector(code)]) &#123; // 告诉代理要做的事 &#125;&#125; @end @implementation YACoder- (void)code &#123; // 实现必须实现的方法&#125; @end // 具体使用时，设置代理YAMan *man = [[YAMan alloc] init];YACoder *coder = [[YACoder alloc] init];man.delegate = coder; 观察者 观察者模式定义了一种一对多的依赖关系，让一个或者多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 一个对象需要在不依赖另一个对象的情况下，接收到另一个对象的通知。 实现:通知中心.假定A是观察者，B是被观察者。 // 在A中// 添加自己为观察者，通知产生执行show方法[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(show) name:@"show" object:nil];// 在自己即将销毁的那刻移除通知- (void)dealloc &#123;[[NSNotificationCenter defaultCenter] removeObserver:self]; &#125; // 在B中，负责适时发送通知// 发出通知[[NSNotificationCenter defaultCenter] postNotificationName:@"show" object:nil userInfo:nil]; 键值观察(某个属性值改变时通知被观察者) // 为view的alpha属性添加自己为观察者UIView *view = [[UIView alloc] init];[view addObserver:self forKeyPath:@"alpha" options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil];// 当自身销毁时为view移除观察- (void)dealloc &#123; [self.view removeObserver:self forKeyPath:@"alpha"];&#125;// 当alpha属性改变，就会进入- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey，id&gt; *)change context:(void *)context &#123;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树与二叉树]]></title>
    <url>%2F2017%2F01%2F24%2F%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[2017.04.21 更正错误 二叉树。 钩玄树形结构是由节点和节点间的联系构成，最重要的特征是:每个节点都只有一个前驱，一个节点可以有多个后继。从一个树形结构里的任意两个节点出发，通过后继关系可达的节点集合:相互之间或者互不相交，或者有子集关系。 树(tree)是具有递归性质的结构，所以树的定义也是递归的。一棵树是 n (n≥0) 个节点的有限集 T(可为空)，T 非空时满足:有且仅有一个特殊的称为根的节点 r， 根节点外的其余节点划分为m(m ≥ 0)个互不相交的非空有限集。节点个数为 0 的树称为空树。一棵树可以只有根但没有子树(m = 0)，这是一棵单节点的树。 二叉树是一种树形结构，特点是与每个节点关联的子节点至多有两个(可为 0, 1, 2)。每个节点的子节点关联有位置关系，二叉树的两棵子树分别称作它的(其根的)左子树和右子树。二叉树不是树的特殊情形:1.其子树分左子树和右子树，即使只有 一棵子树也要明确说明是左还是右。2.树中结点的最大度数没有限制，而二叉树结点的最大度数为2。3.树的结点个数至少为 1，而二叉树的结点个数可以为 0 完全二叉树:除最下两层外，其余节点度数都是 2(显然都不是叶节点)，如果最底层的节点不满，则所有空位都在右边，左边没有空位。 满二叉树:树中每个分支节点(非叶节点)都有两棵非空子树。扩充二叉树(由已有非空二叉树生成的一种二叉树): 是原二叉树的最小节点扩充，使原树中所有节点的度数都变成 2。扩充二叉树新增节点(称为其外部节点)的个数比原树节点(称为其内 部节点)的个数多 1。 深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。 边:从父节点到子节点的连线(注意，边有方向) 兄弟节点:父节点相同的节点互为兄弟节点 树叶、分支节点:没有子节点的节点称为树叶，树中的其余节点称为分支节点 度数:一个节点的子节点个数称为该节点的度数，显然树叶的度数为 0 一棵树的度数就是它里面度数最大的节点的度数 从一个祖先节点到其子孙节点的一系列边称为树中一条路径 路径中边的条数称为路径长度，认为每个节点到自身有长 0 的路径 树根到节点的路径长度是该节点的层数 ~~树的高度或深度是树中节点的最大层数(最长路径的长度)加 1(或者说是节点有多少排) ~~ 树的高度定义为层数最大的叶结点的层数加1 树的深度定义为层数最大的叶结点的层数(或者说是节点有多少排,深度=层数) 部分教材定义不同. 重要! 一棵深度为k，且有 2^k -1 个节点称之为满二叉树 一棵深度为k的完全二叉树，最少有 2^(k-1) 个节点，最多有2^k - 1个节点 对任何一棵二叉树T，如果其终端节点数为 n0 ，度为2的节点数为 n2 ，则 n0 = n2 + 1 二叉树的性质 非空二叉树第 i 层上至多有 2i 个节点(i ≥ 0) 高度为 k 的二叉树至多有 2k-1 个节点(k ≥ 0) 对任何非空二叉树 T，若其叶节点个数为 n0，度数为 2 的节点 个数为 n2，则n0 = n2 + 1 n个节点的完全二叉树的高度k=⎡log2(n+1)⎤ 满二叉树里的叶节点比分支节点多一个 二叉树的list实现def BTree(data,left,right): return [data,left,right]#判断为空def isEmpty(btree): return btree == []#返回根(父)节点def root(btree): return btree[0]#返回左节点def left(btree): return btree[1]#返回右节点def right(btree): return btree[2]#设置根节点def setRoot(btree,data): btree[0] = data#设置左节点def setLeft(btree,data): btree[1] = data#设置右节点def setRight(btree,data): btree[2] = data btree = BTree(1,BTree(2,[],[]),BTree(4,[],[])) 二叉树的类实现class TreeNode(): def __init__(self,data = 0,left = 0,right = 0): self.data = data #数据域 self.left = left #左节点 self.right = right #右节点class BinTree(): def __init__(self,root = 0): self.root = root def isEmpty(self): return self.root == 0 #先序遍历:根左右 def preorder(self,treeRoot): if treeRoot == 0: return print(treeRoot.data) self.preorder(treeRoot.left) self.preorder(treeRoot.right) #中序遍历:左根右 def inorder(self,treeRoot): if treeRoot == 0: return self.inorder(treeRoot.left) print(treeRoot.data) self.inorder(treeRoot.right) #后序遍历:左右根 def postorder(self,treeRoot): if treeRoot == 0: return self.postorder(treeRoot.left) self.postorder(treeRoot.right) print(treeRoot.data)tree1 = TreeNode(10)tree2 = TreeNode(11)tree3 = TreeNode(13,tree1,tree2)tree4 = TreeNode(14,tree3)tree5 = TreeNode(15,tree4)root = TreeNode(17,tree5)btree2 = BinTree(root)btree2.preorder(btree2.root)btree2.inorder(btree2.root)btree2.postorder(btree2.root)]]></content>
      <categories>
        <category>Python</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈与队列的实现]]></title>
    <url>%2F2017%2F01%2F22%2F%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[栈与队列。 栈(stack)，又称堆栈，是一种容器，可存入数据元素、 访问元素、删除元素。 栈保证任何时刻可以访问、删除的元素都是在此之前最后存入的那个 元素。 list实现栈#自定义异常class StackUnderFlow(ValueError): pass #list开头设置为栈底 list结尾设置为栈顶class Stack(): #初始化 def __init__(self): self.elems = [] #判断为空 def isEmpty(self): return self.elems == [] #返回栈顶元素 def top(self): if self.isEmpty(): raise StackUnderFlow return self.elems[len(self.elems) - 1] #将元素压入栈中 def push(self,data): self.elems.append(data) #弹出栈顶元素 def pop(self): if self.isEmpty(): raise StackUnderFlow return self.elems.pop() 链表实现栈#链表头部设为栈顶,链表尾部设为栈底#定义结点:数据域+指针域class Node: def __init__(self,data,nextNode=None):#缺省函数,指向的下一个结点默认为None self.data = data #当前结点的数据域 self.next = nextNode #指向下一个结点class LinkStack(): #初始化 def __init__(self): self.topNode = None #判断为空 def isEmpty(self): return self.topNode == None #返回栈顶元素 def top(self): if self.isEmpty(): raise StackUnderFlow return self.topNode.data #将元素压入栈中 def push(self,data): self.topNode = Node(data,self.topNode) #弹出栈顶元素 def pop(self): if self.isEmpty(): raise StackUnderFlow pnode = self.topNode self.topNode = pnode.next return pnode.data#演练stack1 = Stack()#返回栈顶元素#print(stack1.top())#将元素压入栈中stack1.push(12)stack1.push(11)print(stack1.top())#弹出栈顶元素stack1.pop()print(stack1.top())#判断为空print(stack1.isEmpty())stack2 = LinkStack()#返回栈顶元素#print(stack2.top())#将元素压入栈中stack2.push(12)stack2.push(11)print(stack2.top())#弹出栈顶元素stack2.pop()print(stack2.top())#判断为空print(stack2.isEmpty()) 细节:当LinkStack类中含有self.top()方法时,不要再设置self.top重名属性否则报错:object is not callable 队列队列(queue)，或称为队，也是一种容器可存入数据元素、访问元素、删除元素 出队操作的一端称为队头 入队操作的一端称为队尾 链接表队列的实现，使用链接表即可 顺序表队列的实现,入队在表尾,出队在表头 考虑首元素出队后元素不前移，记住新队头位置。这一设计也有问题: 反复入队出队，如果元素存储区固定，一定会在某次入队时出现队尾溢出表尾(表满)的情况出现这种溢出时，顺序表前部通常会有一些空闲位置 这是“假性溢出”，并不是真的用完了整个元素区如果元素存储区自动增长(如 list)，首端将留下越来越大的空区。 而且这片空区永远也不会用到(完全浪费了) 使用环形队列(把数组看作环形)可以解决这个问题 q.rear 是最后元素之后空位的下标q.head 是首元素的下标[q.head, q.rear) 是队列中所有元 素(看作按照环形排列)入队时，先存入，后移位当队列空: q.head == q.rear 当队列满:(q.rear + 1) % q.len == q.head入队出队时的下标更新语句q.head = (q.head+1) % q.len q.rear = (q.rear + 1) % q.len 队列的实现 elems引用着队列的元素存储区，是一个list 对象 len是这个存储区的有效容量(我们并不知道该 list 对象的实际大小) head 是队列首元素(当时在队列里的存入最早的那个元素)的下标 elemNum始终记录着队列中元素的个数 队列里的元素在 elems 里连续存放，但需要在下标 len 存入元素时，操作改在下标 0 的位置存入 在 elemNum == len 的情况下，入队列操作将自动扩张存储区 class QueueUnderFlow(ValueError): pass class Queue(): def __init__(self,length = 10): self.length = length #存储区容量 self.elems = [0] * self.length #存储数据元素 self.head = 0 #队列首元素 self.elemNum = 0 #队列中元素个数 def isEmpty(self): return self.elemNum == 0 def firstElem(self): #获取队头元素 if self.isEmpty(): raise QueueUnderFlow return self.elems[self.head] #出队 def dequeue(self): if self.isEmpty(): raise QueueUnderFlow e = self.elems[self.head] self.head = (self.head + 1) % self.length self.elemNum -= 1 return e #入队 def enqueue(self,data): #检验队列是否已满 if self.elemNum == self.length: self.extend() #扩张存储区 self.elems[(self.head + self.elemNum) % self.length] = data self.elemNum += 1 def extend(self): oldLen = self.length self.length *= 2 newElems = [0] * (self.length) for i in range(oldLen): newElems[i] = self.elems[(self.head + i) % oldLen] self.elems = newElems self.head = 0 # 演练queue = Queue() queue.enqueue(11)queue.enqueue(12)queue.enqueue(13) print(queue.firstElem()) queue.dequeue()print(queue.firstElem())]]></content>
      <categories>
        <category>Python</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素算法和KMP算法实现串匹配]]></title>
    <url>%2F2017%2F01%2F21%2F%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95%E5%92%8CKMP%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%B2%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[串匹配。 钩玄 长度为 0 的串称为空串 串中字符的个数称为串的长度 s1 和 s2 相等:其长度相等，且对应位置的各字符分别相同 子串是原串中连续的一段字符序列形成的串 空串是任何字符串的子串,任何字符串 s 也都是该串本身的子串 如果存在 s’ 使 s2 = s1 + s’，称 s1 为 s2 的一个前缀 如果存在 s 使得 s2 = s + s1，称 s1 为 s2 的一个后缀 前缀就是该串开头的一段字符构成的子串 后缀就是该串后的一段字符构成的子串 空串既是 s 的前缀，也是 s 的后缀 串s的n次幂是连续n个s拼接而成的串（在Python语言里用s * n表示） &quot;==&quot; 与 &quot;is&quot;的区别：&quot;==&quot;是比较内容相当，如变量值相等;&quot;is&quot;是比较对象的id是否相等 or是从左到有计算表达式，返回第一个为真的值 and从左到右计算表达式，若所有值均为真，则返回最后一个值，若存在假，返回第一个假值 在集合中:&amp;求交集 |求并集 -求差集 在数值中:&amp;按位与 |按位或 ^按位异或 ~按位取反 pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 朴素匹配算法逐个字符匹配t为目标串 p为匹配串 def naiveMatch1(t,p): n,m = len(t),len(p) i,j = 0,0 while i &lt; n and j &lt; m: if t[i] == p[j]: #该字符匹配成功,匹配下一个字符 i += 1 j += 1 else: i = i - j + 1 #将j恢复至原位置加1 j = 0 #将匹配串复位 if j == m: print("匹配成功") return i - j #返回匹配成功的首字符的索引(从0开始) print("匹配失败") return -1 整个串匹配(时间复杂度:O(n*m))def naiveMatch2(t,p): n = len(t) m = len(p) for i in range(n-m+1): #实际上最多移动n-m+1次,而不是n次 if t[i:i+m] == p: #t串中从i位置开始的连续m个字符与p串比较 print("匹配成功") return i #返回匹配成功的首字符的索引(从0开始) print("匹配失败") return -1 演练 t = "abcdefghijklmnopqrst"p = "opq"p2 = "opqw"naiveMatch1(t,p)naiveMatch1(t,p2)naiveMatch2(t,p)naiveMatch2(t,p2) 串p从左端对齐,依次向右边移动一位,直至目标串与匹配串完全匹配 朴素匹配算法简单但是效率低下,主要原因是: 一旦比较到两个串中有字符不匹配,直接将匹配串整体向右移动一位 不管不顾前面已经成功匹配的字符 KMP算法设法利用已匹配的字符数信息，根据部分匹配表移动多位而不是1位,提高效率 部分匹配表 前缀:指除了最后一个字符以外，一个字符串的全部头部组合 后缀:指除了第一个字符以外，一个字符串的全部尾部组合 部分匹配值:前缀和后缀的’最长的’共有元素的长度 如”ABCDAB”的前缀为:[A AB ABC ABCD ABCDA] 后缀:[BCDAB CDAB DAB AB B] 共有元素为AB 长度为2 假定求取匹配串ABCA的部分匹配值 A的前缀后缀都为空集,共有元素长度为0 AB的前缀为[A],后缀为[B],共有元素长度为0 ABC的前缀为[A AB],后缀为[BC C],共有元素长度为0 ABCA的前缀为[A AB ABC],后缀为[BCA CA A],共有元素A长度为1 部分匹配表为: A B C A 0 0 0 1 移动位数 = 已匹配的字符数 - 对应的部分匹配值 部分匹配表算法实现方法一:#1.拆分匹配串def getPart(p): part = [] for i in range(1,len(p)+1): part.append(p[:i]) return part #2.根据某串获取其前缀后缀最长共有元素长度def getLength(p): prefix = set() suffix = set() for i in range(1,len(p)): prefix.add(p[:i]) suffix.add(p[i:]) #如果交集为空,则返回空串集合&#123;""&#125;的长度0 #如果交集不为空,则返回交集中最后一个元素(也即最长元素)的长度 return len((prefix &amp; suffix or &#123;""&#125;).pop()) #3.获取部分匹配表def partialTable1(p): result = [] for elem in getPart(p): result.append(getLength(elem)) return result 方法二:#部分匹配表 def partialTable2(p): prefix = set() suffix = set() ret = [0] #第一个字符的前缀后缀都为空,共有元素长度是0 for i in range(1,len(p)): prefix.add(p[:i]) suffix = &#123;p[j:i+1] for j in range(1,i+1)&#125; ret.append(len((prefix &amp; suffix or &#123;""&#125;).pop())) return ret print(partialTable1("ABCDABDABCDABDABCDABDABCDABDABCDABDABCDABD"))print(partialTable2("ABCDABDABCDABDABCDABDABCDABDABCDABDABCDABD")) KMP核心算法必须使用逐个字符匹配,不能使用整个串匹配def kmpMatch(t,p): n,m = len(t),len(p) table = partialTable2(p) #获取匹配串的部分匹配表 cur = 0 while cur &lt;= n - m: for i in range(m): if t[i + cur] != p[i]: cur += max(i - table[i - 1],1) break else: print("匹配成功") return True print("匹配失败") return False kmpMatch("BBC ABCDAB ABCDABCDABDE","ABCDABD")]]></content>
      <categories>
        <category>Python</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3实现线性表链式存储]]></title>
    <url>%2F2017%2F01%2F13%2FPython3%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[2017.1.20完善 链表。 线性表之单链表 线性表的链式存储结构是用一组任意的存储单元存储线性表的元素. 结点:由指针域和数据域组成 链表必须从头指针开始存取,头指针指向链表中的第一个结点 如果头指针指向空(None)则表示链表为空 一般常用头结点的指针域存储链表中的第一个结点的指针 线性链表中最后一个结点指向空(None) 单链表的第一个结点\首结点:self.head.next 单链表的头结点:self.head 在range(a,b)中,a与b相等,如 for i in range(0,0),循环体不会执行 基本实现#定义结点:数据域+指针域class Node: def __init__(self,data,nextNode=None):#缺省函数,指向的下一个结点默认为None self.data = data #当前结点的数据域 self.next = nextNode #指向下一个结点#结点的创建if __name__ == '__main__': linklist = Node(10) pnode = linklist #使pnode和linklist指向的内容一致,都为第一个结点(非头结点) for i in range(11,18):#依次创建结点 pnode.next = Node(i) pnode = pnode.next pnode = linklist #获取第一个结点,依次遍历数据 while pnode != None:#结点不为空时,打印数据 print(pnode.data) pnode = pnode.next#定义单链表:定义头结点head,指向的第一个结点默认为Noneclass LinkList: def __init__(self): self.head = Node(None)#创建头结点 self.head.next = None #指向的第一个结点为空 #判断链表是否为空 def isEmpty(self): return self.head.next == None #获取链表中结点个数(不含头结点) def getLength(self): i = 0 pnode = self.head while pnode.next != None: i += 1 pnode = pnode.next return i #在链表首部插入结点 def prepend(self,data): #创建一个结点,使其指向链表中第一个结点(原先头结点所指) #再使头结点指向这个新创建的结点 self.head.next = Node(data,self.head.next) #在链表尾部插入结点 def append(self,data): #若链表为空 if self.head.next == None: self.head.next = Node(data) return #如若链表非空 pnode = self.head #获取头结点 while pnode.next != None: pnode = pnode.next pnode.next = Node(data) #此时pnode为最后一个结点 #在第i个位置插入数据data(从第一个结点算起,不含头结点) def insert(self,data,i): if self.isEmpty(): self.head.next = Node(data) return elif i &lt; 1 or i &gt; self.getLength()+1: print("插入位置不合法") return pnode = self.head for index in range(1,i): pnode = pnode.next #创建新结点 newNode = Node(data) #此时pnode指向第i-1个位置上的结点 #新结点的next指向第i个位置上的结点 newNode.next = pnode.next #第i-1个位置上的结点指向新结点 pnode.next = newNode #删除首结点 def delFirst(self): self.head.next = self.head.next.next#头结点指向第二个结点即可 #删除尾结点 def delLast(self): if self.head.next == None: print("链表为空") return pnode = self.head #获取头结点 while pnode.next.next != None: pnode = pnode.next pnode.next = None #将倒数第二个结点的next置空 #在第i个位置删除节点 def delNodeAtIndex(self,i): if self.isEmpty() or i &lt; 1 or i &gt; self.getLength(): print("删除位置不合法") return elif i == 1: #i等于1的情况 self.delFirst() return pnode = self.head for index in range(1,i): pnode = pnode.next pnode.next = pnode.next.next #获取首结点数据 def pop(self): if self.head.next == None: print("链表为空") return return self.head.next.data #获取尾结点数据 def popLast(self): if self.head.next == None: print("链表为空") return pnode = self.head #获取头结点 while pnode.next != None: pnode = pnode.next return pnode.data #获取表中所有元素 def printAllData(self): pnode = self.head.next while pnode != None: print(pnode.data) pnode = pnode.next #查找是否存在数据 def find(self,data): if self.isEmpty(): return pnode = self.head while pnode.next != None: pnode = pnode.next if pnode.data == data: print("存在这样的数据") return print("不存在这样的数据") return #演练 #创建单链表linklist2 = LinkList()print(linklist2.getLength())#首端插入结点linklist2.prepend(23)linklist2.prepend(22)linklist2.prepend(21)linklist2.printAllData()print("*"*20)#拼接结点linklist2.append(24)linklist2.append(25)linklist2.append(26)linklist2.printAllData()#获取首结点数据print(linklist2.pop())#获取尾结点数据print(linklist2.popLast())print("*"*20)#获取结点数量print(linklist2.getLength())print("*"*20)#删除首结点linklist2.delFirst()linklist2.delFirst()linklist2.printAllData()print("*"*20)#删除尾节点linklist2.delLast()linklist2.delLast()linklist2.printAllData()print(linklist2.getLength())print("*"*20)#插入结点linklist2.insert(32,1)linklist2.insert(31,1)linklist2.insert(35,5)#linklist2.insert(310,10) #非法数据linklist2.printAllData()print(linklist2.getLength())print("*"*20)#在第i个位置删除linklist2.delNodeAtIndex(1)linklist2.delNodeAtIndex(4)linklist2.delNodeAtIndex(10) #非法数据linklist2.printAllData()#查找数据linklist2.find(24)linklist2.find(88)#非法数据]]></content>
      <categories>
        <category>Python</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3实现线性表顺序存储]]></title>
    <url>%2F2017%2F01%2F12%2FPython3%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[2017.1.13补充时间复杂度 顺序表。 数据结构 数据结构是相互之间存在一种或者多种特定关系的数据元素的集合. 按照逻辑结构分为:集合结构/线性结构/树形结构/图形结构. 按照物理结构可分为:顺序存储结构和链式存储结构. 算法 输入/输出/确定/有穷/可行. 解决特定问题求解步骤的描述. 算法时间复杂度是算法的时间量度,表示随问题规模n的增大,算法执行时间的增长率和f(n)问题规模的某个函数的增长率相同,称作算法的渐近时间复杂度,简称时间复杂度.没有最高阶项,问题的大小与n无关,执行时间恒定的算法为O(1),单纯的分支结构时间复杂度也是O(1). 常数阶O(1),线性阶O(n),对数阶,平方阶O(m*n) 循环的时间复杂度 = 循环体的复杂度 * 循环次数 O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n n)&lt;O(n n*n)&lt;O(2的n次)&lt;O(n!)&lt;O(n的n次方) int i,j; for(i = 0;i &lt; m;i++) { for(j = 0;j &lt; n; j++) { /* 时间复杂度为O(1)的程序步骤序列 */ } } // 时间复杂度为O(m * n) int i,j; for(i = 0;i &lt; n;i++) { for(j = i;j &lt; n; j++) { /* 时间复杂度为O(1)的程序步骤序列 */ } } // 总的执行次数n(n+1)/2,时间复杂度为O(n*n) int count = 1; while (count &lt; n) { count = count * 2; /* 时间复杂度为O(1)的程序步骤序列 */ } // 时间复杂度为O(logN) 线性表之顺序表 线性表中元素的个数n定义为线性表的长度,n=0时为空表,其长度可以根据需要增长或缩短 特点:存在唯一的一个被称作”第一个”的数据元素存在唯一的一个被称作”最后一个”的数据元素除第一个外,集合中的每一个元素均只有一个前驱除最后一个外,集合中的每一个元素均只有一个后继 顺序表:用一组连续的存储单元依次存储线性表的数据元素 顺序表中当前元素的个数:length 在Python中,数据元素存放在列表中:data[length]其中,len(data) == length 可以使用表中最后一个数据元素的下标获取当前表长 也可以直接使用length标记表长 顺序表的第一个元素的下标为1，数组的下标为0 在 n 个元素的顺序表里下标 i 处加入元素，需要移动 n - i 个元素;删 除下标为 i 的元素需要移动 n - i - 1个元素 基本实现#定义顺序表class SqList: # 1.创建一个指定存储容量的顺序表 newList : int -&gt; List def __init__(self,size): self.maxSize = size #指定的存储容量 self.data = list(range(size))#数组存储的初始范围 self.length = 0 #顺序表的当前长度(元素的个数) # 2.判断表空?emptyList : List -&gt; bool def isEmpty(self): #表中没有元素 return self.length == 0 # 3.判断表满?fullList : List -&gt; bool def isFull(self): #表中元素个数与指定存储容量一致 return self.length == self.maxSize # 4.返回表中元素的个数length : List -&gt; integer def getLength(self): return self.length # 5.查找元素在表中首次出现的位置locate : List * Data -&gt; integer def getLocation(self,element): #判断表是否为空 if self.isEmpty(): print("错误!顺序表为空") return -1 for i in range(4): if self.data[i] == element: return i+1 return -1 #找不到返回-1 # 6.取得指定位置的元素getElem : List * int -&gt; Data def getElementAtIndex(self,index):#index表示位置而不是索引 #首先判断表空 if self.isEmpty(): print("错误!顺序表为空") return #其次判断位置是否越界 elif index &gt; self.length or index &lt; 1: print("错误!位置越界") else: return self.data[index-1] # 5.首端插入prepend : List * Data -&gt; List def prependElement(self,element): #首先判断顺序表是否已满 if self.isFull(): print("错误!顺序表已满") return #将所有元素往后移动一位,从最后一位开始,到第一个元素 for i in range(self.length-1,-1,-1): self.data[i+1] = self.data[i] self.data[0] = element self.length += 1 # 6.尾端插入append : List * Data -&gt; List def appendElement(self,element): #首先判断顺序表是否已满 if self.isFull(): print("错误!顺序表已满") return self.data[self.length] = element self.length += 1 # 7.定位插入insert : List * int * Data -&gt; List def insertElement(self,index,element):#在index位置上插入元素 #首先判断顺序表是否已满 if self.isFull(): print("错误!顺序表已满") return #其次判断插入位置是否合理 elif index &lt; 1 or index &gt; self.length: print("错误!插入位置不合理") return else: for i in range(self.length-1,index-2,-1): self.data[i+1] = self.data[i] self.data[index-1] = element self.length += 1 # 8.删除首个元素delFront : List -&gt; List def delFront(self): #判断是否为空表 if self.isEmpty(): print("错误!顺序表为空") return for i in range(0,self.length-1): self.data[i] = self.data[i+1] del self.data[self.length-1] self.length -= 1 # 9.删除末尾元素delEnd : List -&gt; List def delEnd(self): #判断是否为空表 if self.isEmpty(): print("错误!顺序表为空") return del self.data[self.length-1] self.length -= 1 # 10.定位删除元素delete : List * int -&gt; List def delete(self,index): #判断是否为空表 if self.isEmpty(): print("错误!顺序表为空") return #过滤将要删除元素的位置 elif index &lt; 1 or index &gt; self.length: print("错误!插入位置不合理") return for i in range(index-1,self.length): self.data[i] = self.data[i+1] self.length -= 1 # 11.删除一个数据delElem : List * Data -&gt; List def delElem(self,element): #判断是否为空表 if self.isEmpty(): print("错误!顺序表为空") return else: index = self.getLocation(element) -1 if index == -2: print("没有找到") return else: del self.data[index] self.length -= 1 # 12.删除所有数据delAllElem : List * Data -&gt; List def clear(self): self.length = 0#演练:s = SqList(8)#表是否为空print(s.data)print(s.isEmpty())print(s.isFull())#末尾追加元素s.appendElement(12)print(s.data)print(s.isEmpty())print(s.isFull())#首端追加元素s.prependElement(13)print(s.data)#插入元素s.insertElement(1,11)s.insertElement(2,12)s.insertElement(4,14)print(s.data)#获取表中元素个数print(s.length)#获取元素12出现的位置print(s.getLocation(12))#获取第3个位置上的元素print(s.getElementAtIndex(3))#删除首个元素s.delFront()print(s.data)#删除末尾元素s.delEnd()print(s.data)#定位删除元素s.delete(21) #错误数据s.delete(2)print(s.data)#删除数据s.delElem(121) #错误数据s.delElem(12)print(s.data)#删除全部元素s.clear()print(s.isEmpty()) 针对Python3Python中已经内置list类型,具备顺序表的特点,拥有的常见函数或者方法可以轻易实现顺序表的相关操作 列表包含的函数:len(list) 方法返回列表元素个数。max(list) 方法返回列表元素中的最大值。min(list) 返回列表元素最小值list(seq) 方法用于将元组转换为列表。列表包含的方法:list.append(obj) 在列表末尾添加新的对象list.count(obj) 统计某个元素在列表中出现的次数list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值list.index(obj) 从列表中找出某个值第一个匹配项的索引位置list.insert(index, obj) 将对象插入列表中的指定位置,index指索引list.pop(index)移除列表中的一个元素（默认最后一个元素），并且返回该元素的值list.remove(obj)移除列表中某个值的第一个匹配项list.reverse()反向列表中元素list.sort([func])对原列表进行排序list.clear()清空列表list.copy()复制列表 值得注意的是,Python2与Python3的区别 python2中的range返回的是一个列表 python3中的range返回的是一个迭代值 for i in range(1,10)在python2和python3中都可以使用，但是要生成1-10的列表，就需要用list(range(1,10)) 结合内置方法#coding=utf-8#定义顺序表class SqList: # 1.创建一个指定存储容量的顺序表 newList : int -&gt; List def __init__(self,size): self.maxSize = size #指定的存储容量 self.data = list(range(size)) #数组存储的初始范围 self.length = 0 #顺序表的当前长度(元素的个数) # 2.判断表空?emptyList : List -&gt; bool def isEmpty(self): #表中没有元素 return self.length == 0 # 3.判断表满?fullList : List -&gt; bool def isFull(self): #表中元素个数与指定存储容量一致 return self.length == self.maxSize # 4.返回表中元素的个数length : List -&gt; integer def getLength(self): return self.length # 5.查找元素在表中首次出现的位置locate : List * Data -&gt; integer def getLocation(self,element): #判断表是否为空 if self.isEmpty(): print("错误!顺序表为空") return -1 return self.data.index(element) + 1 # 6.取得指定位置的元素getElem : List * int -&gt; Data def getElementAtIndex(self,index):#index表示位置而不是索引 #首先判断表空 if self.isEmpty(): print("错误!顺序表为空") return #其次判断位置是否越界 elif index &gt; self.length or index &lt; 1: print("错误!位置越界") else: return self.data[index-1] # 5.首端插入prepend : List * Data -&gt; List def prependElement(self,element): #首先判断顺序表是否已满 if self.isFull(): print("错误!顺序表已满") return self.data.insert(0,element) self.length += 1 # 6.尾端插入append : List * Data -&gt; List def appendElement(self,element): #首先判断顺序表是否已满 if self.isFull(): print("错误!顺序表已满") return self.data.append(element) self.length += 1 # 7.定位插入insert : List * int * Data -&gt; List def insertElement(self,index,element):#在index位置上插入元素 #首先判断顺序表是否已满 if self.isFull(): print("错误!顺序表已满") return #其次判断插入位置是否合理 elif index &lt; 1 or index &gt; self.length: print("错误!插入位置不合理") return else: self.data.insert(index-1,element) self.length += 1 # 8.删除首个元素delFront : List -&gt; List def delFront(self): #判断是否为空表 if self.isEmpty(): print("错误!顺序表为空") return self.data.pop(0) self.length -= 1 # 9.删除末尾元素delEnd : List -&gt; List def delEnd(self): #判断是否为空表 if self.isEmpty(): print("错误!顺序表为空") return self.data.pop() self.length -= 1 # 10.定位删除元素delete : List * int -&gt; List def delete(self,index): #判断是否为空表 if self.isEmpty(): print("错误!顺序表为空") return #过滤将要删除元素的位置 elif index &lt; 1 or index &gt; self.length: print("错误!删除位置不合理") return self.data.pop(index-1) self.length -= 1 # 11.删除一个数据delElem : List * Data -&gt; List def delElem(self,element): #判断是否为空表 if self.isEmpty(): print("错误!顺序表为空") return else: self.data.remove(element) # 12.删除所有数据delAllElem : List * Data -&gt; List def clear(self): self.length = 0 总结 使用内置方法实现,结合前辈经验,使用list(range(size))初始化列表,初始化后,列表中元素已经成为顺序表的一部分 顺序表访问元素极其方便,通过索引即可实现,然而插入删除元素却十分费心费力,时间主要耗费在移动元素上面 含有n个元素的顺序表中,在第i个元素之前,插入一个元素所需要移动元素次数的期望是 n/2 推导: 假定当前表长为n,在第1个位置插入需要移动n个元素, 第二个位置插入需要移动n-1个元素,以此类推, 第n个位置插入需要移动1个元素, 第n+1个位置插入需要移动0个元素, 一共需要移动的次数为 (0+n)*(1+n)/2 表长为n 则移动元素次数的期望为 (0+n)*(1+n)/2/(n+1)==&gt;n/2 含有n个元素的顺序表中,删除第i个元素需要移动元素次数的期望是 (n-1)/2 推导: 假定当前表长为n,删除第一个元素需要移动元素次数为n-1, 删除第二个元素需要移动次数为n-2,以此类推, 删除第n-1个元素需要移动元素次数为1, 删除第n个元素需要移动元素次数为0, 一共需要移动的次数为(0+n-1)n/2 表长为n 则移动元素次数的期望为 (0+n-1)/2/n==&gt;(n-1)/2 顺序表实现插入\删除元素的时间复杂度为O(n)]]></content>
      <categories>
        <category>Python</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3入门笔记]]></title>
    <url>%2F2016%2F12%2F20%2FPython3%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2017.1.11修改 人生苦短,我用Python。 钩玄 让Python打印出指定的文字，可以用print()函数，然后把希望打印的文字用单引号或者双引号括起来，但不能混用单引号和双引号 用exit()退出Python 在Python交互式命令行下，可以直接输入代码，然后执行，并立刻得到结果。 直接输入python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。 print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出,会依次打印每个字符串，遇到逗号“,”会输出一个空格 Python提供了一个input(“提示文本,可以为空”)，可以让用户输入字符串，并存放到一个变量里。 以#开头的语句是注释,Python程序是大小写敏感的 当语句以冒号:结尾时，缩进的语句视为代码块。Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。 Python还允许用r’’表示’’内部的字符串默认不转义:print(r&#39;\\\n&#39;) Python允许用’’’…’’’的格式表示多行内容 一个布尔值只有True、False两种值 布尔值可以用and、or和not运算。 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 在Python中，通常用全部大写的变量名表示常量,事实上仍然是一个变量，Python根本没有任何机制保证不会被改变 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数,//称为地板除，两个整数的除法仍然是整数 Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。 ASCII编码是1个字节，而Unicode编码通常是2个字节。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示x = b&#39;ABC&#39; bytes的每个字符都只占用一个字节,以Unicode表示的str通过encode()方法可以编码为指定的bytes,&#39;中文&#39;.encode(&#39;utf-8&#39;),含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错 在bytes中，无法显示为ASCII字符的字节，用\x##显示 如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法 计算str包含多少个字符，可以用len()函数,len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数,len(&#39;中文&#39;) #!/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个% 实练'''1,代码中有中文必须设置utf-8'''#coding=utf-8#2,单行注释,以#开头import time #引入时间模块import randomimport calendar,osimport math#爬取数据import urllib.request#指定math模块中的sqrt函数from math import sqrt'''当你导入一个模块，Python解析器对模块位置的搜索顺序是：1.当前目录2.如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。3.如果都找不到，Python会查看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/4.模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。 创建text.py文件,定义相关函数,import text 即可引用自己的模块 注意,倘若在text.py中定义并执行相关函数,其他文件引用之后,并不会执行 测试函数代码，应该是单独执行text.py文件时才会执行 from math import * 可以根据__name__变量的结果能够判断出，是直接执行的python脚本还是被引入执行的， 从而能够有选择性的执行测试代码 ''' #区分文件是主动执行的，还是被调用执行的。如果当前文件是主动执行的，__name__ 变量的值就是：__main__，如果是被导入执行的，则是被导入的文件名if __name__ == "__main__": print("是直接执行的py脚本,而非引入")#3,多行注释,使用3个单引号#3,输出,使用print函数,字符串格式化]'''%c %s %i %d %u无符号十进制整数%o %x十六进制小写 %X十六进制大写 %f'''print("hello world")a = 12b = 58c = "swe"print("hello %s 这孩子 %s 啊啊啊 %s"%(a,b,c))print("sss",a)#4,输入inputs = input("请输入数字")print("您的数字是:%s"%inputs)if inputs == 12: print("哈哈哈哈") print("嘻嘻嘻嘻")if inputs != 12: print("哦哦哦哦")#5,数据类型'''在python中，只要定义了一个变量，而且它有数据，那么它的类型就已经确定了可以使用type(变量的名字)，来查看变量的类型:type(a)常用的数据类型:* Numbers(包括int long float complex)* 布尔 True/False* String * List* Tuple(元组)* Dictionary'''#6,标识符# 标识符由字符数字下划线组成,没有美元符号,且区分大小写# 命名规则:驼峰式或者下划线连接#7,运算符'''* %取余 3%2* **幂 3**2 3的2次方* // 取整除* / 正常除法,可有余数* //= **/ '''#8,逻辑运算 and or not# 与if inputs == 15 and a == 12: print("and")# 或if inputs == 15 or b == 58: print("or")# 非if not a == 12: print("not")#9,多重判断 if 与 elifscore = 99if score &lt; 60: print("不及格")elif score &lt;80: print("良好")elif score &lt; 90: print("不错")else: print("优秀")#10,if嵌套if a == 12: print("a==12") if a &gt; 12: print("a&gt;12") else: print("a&lt;=12")else: print("a!=12")#11,while循环与循环嵌套while a == 12: print("你不好") a = 13 while b == 58: print("哈哈哈哈") b = 59#12,for循环:i从0开始,每次自增1for i in range(12): if i == 5: continue#跳过i==5这次 print('i=%s'%i) if i == 10: print("停止break") break#13,定义函数 print1def print1(): print("函数") print("函数") print("函数")#调用函数print1print1()#14,常用函数#时间函数import timet = time.time()#取出当前时间,以秒为单位的浮点小数t2 = time.localtime(t)#取出本地时间t3 = time.asctime(t2) #标准格式Fri Jun 10 10:58:53 2016print(t3)#日历函数 import calendarcal = calendar.month(2016,8)print(cal) #打印日历#随机数函数 import randomr = random.randint(1,3)#从1到3范围内的整数,包括1和3print(r)r2 = random.randrange(1,25,5)#从1开始到25结束递增基数为5print(r2)r3 = random.uniform(1,5) #最小值1最大值5,返回浮点数print(r3)random.random() #生成0&lt;=n&lt;=1的浮点数#15,字符串,相当于字符数组,可以通过下标取出字符,ss = "qwertyu"print(ss[1])#取出下标从1到3 的字符,包括上边界,不包括下边界print(ss[1:3])#从下标2开始 取到最后print(ss[2:])#从下标2开始到下标-2,不包括下标-2print(ss[2:-2])#取出最后4个字符print(ss[-4:])#16,字符串常见操作sub = "my"s = "itismyapple"#查找:检测sub是否在s中:s.find(sub, start=0, end=len(mystr))#查找成功返回开始的索引,否则返回-1s.find(sub)re = s.find(sub,1,8)#从下标1开始查找,到下标为8结束print(re)s.index(sub)#与find相同,只不过没有找到会抛出异常#返回 在start和end之间(包括) 在 s里面出现的次数c = s.count("i", 0,8)print(c)#把 s 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次.s.replace("t","d",2)#以 " " 为分隔符切片 s，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串s.split(" ",5)#把字符串的第一个字符大写s.capitalize()#检查字符串是否是以 obj 开头, 是则返回 True，否则返回 Falses.startswith("i")#检查字符串是否以obj结束，如果是返回True,否则返回 False.s.endswith("d")#转换 s 中所有大写字符为小写s.lower()#转换 s 中的小写字母为大写s.upper()#返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串s.ljust(5) #返回 "itismyapple "#返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串s.rjust(5) #返回" itismyapple"#返回一个原字符串居中,并使用空格填充至长度 width 的新字符串"s".center(10) #" s "#删除 s 左边的空格s.lstrip()#删除 s 字符串末尾的空格s.rstrip()#类似于 find()函数，不过是从右边开始查找."sieiess".rfind("ie") #返回3# 类似于 index()，不过是从右边开始.s.rindex("s")#把"asdeeeads"以str分割成三部分,str前，str和str后"asdeeeads".partition("eee")#类似于 partition()函数,不过是从右边开始."asdeeeads".rpartition("eee")#按照行分隔，返回一个包含各行作为元素的列表"asas\nds".splitlines()#如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False"ssd".isalnum()#如果 mystr 所有字符都是字母 则返回 True,否则返回 False"ssd".isalpha()#如果 mystr 只包含数字则返回 True 否则返回 False."232".isdigit()#如果 mystr 中只包含空格，则返回 True，否则返回 False." ".isspace()#如果 mystr 所有字符都是大写，则返回 True，否则返回 False"sd".isupper()#mystr 中每个字符后面插入str,构造出一个新的字符串"sasd".join("s")#17,列表A = ["ds3s","ds4s","a4sd"]print(A[0])for a in A: print(a)#打印每一个元素#18,列表增加元素A.append("asasdad")for a in A: print(a)#打印每一个元素#19,修改A[0] = "1"#20,查找if "1" in A: print("1存在于a中")if "1" not in A: print("1不存在与a中")#21,删除元素''' del：根据下标进行删除 pop：删除最后一个元素 remove：根据元素的值进行删除'''del A[0]A.pop()A.remove("ds4s")for a in A: print(a)#打印每一个元素#21,统计字符个数cstr = input("请输入字符")for c in cstr: print("%c:%d"%(c,cstr.count(c)))#22,字典info = &#123;"name":"zhangsan","age":12&#125;print(info["name"])#增加键值对info["sex"] = "man"#删除元素del info["age"]#清空字典info.clear()#删除整个字典del info#注意删除字典和清空字典的区别#字典常用操作info2 = &#123;"name":"zhangsan","age":12&#125;#测量字典中，键值对的个数len(info2)#返回一个包含字典所有KEY的列表info2.keys()#返回一个包含字典所有value的列表info2.values()#返回一个包含所有（键，值）元组的列表info2.items()#if "name" in info2如果key在字典中，返回True，否则返回Falseif "name" in info2: print("存在")#遍历键/值/键值对for key,value in info2.items(): print(key,value)#23,Python的元组与列表类似，不同之处在于元组的元素不能修改。也可进行分片 和 连接操作. 元组使用小括号，列表使用方括号。atuple = ("as",121,True,False,0)atuple2 = ("a",121,True,False,40)print(atuple[1])#合成新元组atuple3 = atuple + atuple2#删除元素#元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组del atuple3#24,元组运算符#与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。(1, 2, 3) + (4, 5, 6)['Hi!'] * 4 #['Hi!', 'Hi!', 'Hi!', 'Hi!']3 in (1, 2, 3) #True#25,元组索引截取#因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素#比较两个元组元素。#cmp(tuple1, tuple2)tuple2 = (12,234,546,56)tuple2s = [12,23]#计算元组元素个数。len(tuple2)#返回元组中元素最大值。max(tuple2)#返回元组中元素最小值。min(tuple2)#将列表转换为元组。tuple(tuple2s)#25,多维元组tuple3 = [(2,4,5,4),(2,5,6)]tuple3[1] #(2,5,6)tuple3[1][0] #2#26,带有参数和有返回值的函数def sum(a,b): return a+bprint(sum(45,1))#27,缺省函数def sum2(a,b = 25): return a+bprint(sum2(232))print(sum2(232,1))#28,不定长参数#加了星号（*）的变量名会存放所有未命名的变量参数。#参数以一个＊号开头的代表着一个任意长度的元组(tuple)，可以接收连续一串参数def printinfo(a,b,*cs): print(a,b) for c in cs: print(c)printinfo(23,3,34,4,6,2)#29,函数的嵌套使用def print3(a,b): print(a,b) print(sum(a,b))print3(2,23)#30,打印指定条横线def printline(): print("-"*20)def printlinewithnum(a): for i in range(a): printline() print("\n")printlinewithnum(5)#31,变量#局部变量,是在函数内部定义的变量#全局变量,能在某一函数中使用,也能在其他函数中使用#全局变量能够在所有的函数中进行访问#如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错gol = 12def chnum(): global gol #声明此处的gol是特指全局变量,而非重名的局部变量 gol = 13 print(gol)chnum()print(gol)#32,递归函数,一个函数在内部调用自己#示例:计算n的阶乘def calnum(n): i = 1 result = 1 while i &lt;= n: result *= i i += 1 return resultprint(calnum(1))print(calnum(0))def calnum2(n): if n &gt;= 1: return n * calnum2(n-1) else: return 1print(calnum2(1))print(calnum2(0))#33,匿名函数#用lambda关键词能创建小型匿名函数。#Lambda函数能接收任何数量的参数但只能返回一个表达式的值#匿名函数不能直接调用print，因为lambda需要一个表达式sum4 = lambda a,b,c,d:a + b + c + dprint(sum4(1,3,4,6))#34,位运算:直接操作二进制数'''&amp; 按位与 只有对应的两个二进位均为1时,结果位才为1| 按位或 只要对应的二个二进位有一个为1时,结果位就为1,否则为0^ 按位异或 不同为1 当对应的二进位相异(不相同)时,结果为1,否则为0~ 按位取反&lt;&lt; 按位左移:左移一位即乘以2,可能改变一个数的正负&gt;&gt; 按位右移::右移一位即除以2'''0b1011 &amp; 0b10010101100b1000110 | 0b100100b11101 ^ 0b110000011~132print(12&lt;&lt;3)print(1024&gt;&gt;4)#进制书写0o377 #八进制0xFF #十六进制0b010010110 #二进制#进制转换print(type(oct(25))) #转八进制字符串hex(25) #转十六进制字符串bin(25) #转二进制字符串#35,数据类型转换int("123") #字符串转数值float("2324.3") #将字符串转换为浮点数print(complex(1.2,3.2)) #创建一个复数,在 Python 中，复数的虚部被表示为 jprint(3.2+1.4j)print(str(23)) #将23转换为字符串print(repr(124)) #转换为表达式字符串tuple([23,3])list((23,234))chr(2)ord("d")#35,实现乘法表def print6(): i = 1 while i &lt;= 9: j = i while j &lt;= 9: print("%d*%d=%d"%(i,j,i*j)) j += 1 i += 1print6() #36,打开文件#使用open函数，可以打开一个已经存在的文件，或者创建一个新文件#open(文件名，访问模式) 返回文件句柄f = open("s.txt","w")f.close()#关闭文件'''r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。r+ 打开一个文件用于读写。文件指针将会放在文件的开头。w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。'''#37,写数据到文件f = open("s1","w")f.write("hello world")f.close()#38,读数据f = open("s1")content = f.read(5) #读取数据长度,字节为单位print(content)f.close()#readlines按照行的方式把整个文件中的内容进行一次性读取，返回的是一个列表，每一行的数据为一个元素f = open("s")content2 = f.readlines()print(content2[2])f.close()#38,获取当前读写的位置f = open("222.txt", "r+")f.write("123243454566")str12 = f.read(3)print("读取的数据是 : ",str12)# 查找当前位置position = f.tell()print("当前文件位置 : ", position)f.close()#如果在读写文件的过程中，需要从另外一个位置进行操作的话，可以使用seek()'''seek(offset, from)有2个参数 offset:偏移量 from:方向 0:表示文件开头 1:表示当前位置 2:表示文件末尾'''f = open("s", "r")str33 = f.read(30)print("读取的数据是 : ", str33)# 查找当前位置position = f.tell()print("当前文件位置 : ", position)# 重新设置位置f.seek(5,0)f.close()#39,文件操作#文件重命名#需要import os'''#os模块中的rename()可以完成对文件的重命名操作os.rename("s1","s111")#删除文件os.remove("s111")#创建文件夹os.mkdir("haha")#获取当前目录print(os.getcwd())#改变默认目录os.chdir("../")#获取目录中内容列表,返回数组os.listdir("./")#删除文件夹os.rmdir("haha")#判断是否是目录os.path.isdir("./react")#判断是否是文件os.path.isfile("./s")'''#40,捕获异常try: open("ssss","r")#指定异常类型 定义异常变量except IOError as errmsg: print("捕获到异常",errmsg) print("-"*10)#多个异常try: open("ssss","r")#指定异常类型 定义异常变量except (IOError,NameError) as errmsg: print("捕获到异常",errmsg) print("-"*10)#不指定异常try: open("ssss","r")#指定异常类型 定义异常变量except : print("捕获到异常") print("-"*10)'''常见异常：Exception 所有异常的基类AttributeError 特性应用或赋值失败时引发IOError 试图打开不存在的文件时引发IndexError 在使用序列中不存在的索引时引发KeyError 在使用映射不存在的键时引发NameError 在找不到名字（变量）时引发SyntaxError 在代码为错误形式时引发TypeError 在内建操作或者函数应用于错误类型的对象是引发ValueError: 在内建操作或者函数应用于正确类型的对象，但是该对象使用不合适的值时引发ZeroDivisionError 在除法或者模除操作的第二个参数为0时引发'''#finally语句try: open("ssss","r")#指定异常类型 定义异常变量except : print("捕获到异常") print("-"*10)finally: print("一定执行的语句")#else应用try: num = 100 print(num)except NameError as errorMsg: print('产生错误了:%s'%errorMsg)else: print('没有捕获到异常，真高兴')finally: print('我一定会执行的哦')#41,定义类class Person: #属性列表 #公有属性 name = "AB" #私有属性,私有属性是不能够在类外通过对象名来进行访问的 __age = 20 #在类中定义的方法至少会有一个参数，，一般以名为self的变量作为该参数，而且需要作为第一个参数。 #公有方法列表 def getName(self): print(self.name) #私有方法 def __getAge(self): print(self.__age) #def get():报错 # print("无参数方法") #构造器方法:在创建对象后执行 #def __init__(): # self.name = "QWE" #传递参数的构造器方法 def __init__(self,name): self.name = name #析构方法 def __del__(self): print("析构方法被调用")#创建对象p = Person("zhangsan")print(p.name)p.getName()# 提示找不到该属性p.__age# 提示找不到该方法p.__getAge()#self是对象自身的意思，在用某个对象调用该方法时，就将该对象作为第一个参数传递给self。del p#42,继承class Student(Person): def setName(self,name): self.name = name def print(self): print("学生的姓名是",self.name)stu = Student("zhangsan")stu.setName("李四")stu.print()# python中是可以多继承的# 父类中的方法、属性，子类会继承# 多继承:class HighStudent(Student,Worker)# 假设A,B中都有方法test()#若C继承A与B class C(A,B) 则调用A中的方法#若C继承A与B class C(B,A) 则调用B中的方法#若C继承A与B class C(A,B) 且C中也有test()方法,则调用C中重写的方法#43,重写class Ani: def print(self): print("调用Ani的方法")class Dog(Ani): def print(self): print("调用Dog的方法") dog = Dog()dog.print() #调用自己的方法#44,多态class A: passclass A1(A): def show(self): print("A1")class A2(A): def show(self): print("A2")a1 = A1()a2 = A2()def showFunc(a): a.show() showFunc(a1)showFunc(a2)#45,类属性#类属性就是类对象所拥有的属性，它被所有类对象的实例对象所共有，#内存中只存在一个副本，对于公有的类属性，在类外可以通过类对象和实例对象访问class object: name = "object"obj1 = object()obj2 = object()print(obj1.name) #实例没有name,会查找类的name,结果:objectobject.name = "lisi"print(obj2.name) #显示 lisiprint(obj1.name) #显示 lisi#给实例obj1增加实例属性obj1.name = "ads"print(obj1.name) #屏蔽掉类属性,显示adsprint(object.name) #显示 lisi#结论:#相同名称的实例属性将屏蔽掉类属性#但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。#Python是动态语言,可以动态增加属性#想要修改类属性，如果在类外，可以通过类对象修改，如果在类里面，只有在类方法中进行修改。#46,类方法'''是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数当然可以用其他名称的变量作为其第一个参数.但是大部分人都习惯以'cls'作为第一个参数的名字，就最好用'cls'了能够通过实例对象和类对象去访问。'''class people: country = 'china' #类方法，用classmethod来进行修饰 @classmethod def getCountry(cls): return cls.countryclass Car: #类属性 price = "1000" #类方法 @classmethod def getPrice(cls,price): cls.price = price return cls.pricecar1 = Car()print(car1.getPrice(200))#47,静态方法#通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数class Cat: name = "Tom" @staticmethod #静态方法 def getName(): print(Cat.name)Cat.getName()#48,爬取数据response = urllib.request.urlopen("http://acm.hit.edu.cn")html = response.read()#中文转码htmlC = html.decode("utf-8")print(htmlC)#将网页存入文本f = open("t.html","wb")#python是types格式，得用二进制读写. f.write(html) #写入原始文件,不需要解码f.close()#49,get参数拼接query = &#123;&#125;query["key"] = "python3"queryURL = urllib.parse.urlencode(query) #得到key=python3url = "http://chenyalun.com/s?" + queryURLprint(url)#50,使用BeautifulSouphtml = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and &lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;; and they lived at the bottom of a well.&lt;/p&gt; &lt;p class="story"&gt;...&lt;/p&gt; """from bs4 import BeautifulSoupsoup = BeautifulSoup(html)print(soup.prettify())#打印标签print("标题是:",soup.title)print("头部是",soup.head)print("第一个a标签",soup.a)print("第一个p标签",soup.p)#它查找的是在所有内容中的第一个符合要求的标签#标签的两个重要的属性:name 和 attrsprint(soup.a.name)print(soup.p.attrs)#属性的值print("属性的值",soup.p.attrs["name"]) print("属性的值",soup.p["name"])#attrs可以省略#用 .string获取文字print(soup.p.string)#利用"CSS选择器"查找标签#通过标签名查找print(soup.select("title"))#通过类名查找print(soup.select(".sister"))#通过id查找print(soup.select("#link1"))#组合查找print(soup.select("p #link1")) #格式同CSS#直接子标签查找print(soup.select("head &gt; title"))#属性查找#属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格print(soup.select('a[class="sister"]'))print(soup.select('a[href="http://example.com/elsie"]'))print(soup.select('p a[href="http://example.com/elsie"]'))# select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容for title in soup.select("title"): print(title.get_text)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML/CSS/JavaScript学习笔记]]></title>
    <url>%2F2016%2F12%2F06%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%2F</url>
    <content type="text"><![CDATA[大前端时代。 HTML &lt;html&gt;&lt;/html&gt;是根标签,&lt;heal&gt;定义文档的头部,常包含&lt;title&gt; &lt;script&gt; &lt;style&gt; &lt;meta&gt; &lt;link&gt; &lt;em&gt;表示强调，&lt;strong&gt; 表示更强烈的强调。并且在浏览器中&lt;em&gt; 默认用斜体表示，&lt;strong&gt;用粗体表示。 &lt;span&gt;标签是没有语义的，它的作用就是为了设置单独的样式用的。 用&lt;q&gt;标签引用别人的语句,是对简短文本的引用:加上双引号 &lt;blockquote是长文本引用:整体缩进 空标签现在一般使用 xhtml1.0 的版本的写法,如&lt;br/&gt; &lt;img/&gt; &lt;hr/&gt; 在html代码中输入空格、回车都是没有作用的。要想输入空格，必须写入&amp;nbsp;。 &lt;adress&gt;标签,添加地址:显示为斜体 &lt;code&gt;标签:添加一行代码,&lt;pre&gt;预显示格式标签,被包围在 pre 元素中的文本通常会保留空格和换行符:添加一段代码(会转换其中的&lt;br/&gt;等) ul-li是没有前后顺序的信息列表:每项li前都自带一个圆点 ol-li是有前后顺序的信息列表:每项li前都自带一个序号,序号默认从1开始 容器标签&lt;div&gt;,为网页划分独立的版块,给div命名:添加唯一的id属性，使逻辑更加清晰创建表格的五个元素：`table、tr(一行)、th(表格表头)、td(一个单元格,有几个说明就有几列,表格中列的个数，取决于一行中数据单元格的个数。), 注意tbody:当表格内容非常多时，表格会下载一点显示一点，但如果加上标签后，这个表格就要等表格内容全部下载完才会显示。注意1、table表格在没有添加css样式之前，在浏览器中显示是没有表格线的 2、表头，也就是th标签中的文本默认为粗体并且居中显示 &lt;table summary=&quot;表格简介文本&quot;&gt;添加表格摘要,表格摘要并不会显示,&lt;caption&gt;标题文本&lt;/caption&gt;添加表格标题,显示在表格上方居中,需要包含在table标签中 &lt;a href=&quot;目标网址&quot; title=&quot;鼠标滑过显示的文本&quot;&gt;链接显示的文本&lt;/a&gt;,title属性的作用，鼠标滑过链接文字时会显示这个属性的文本内容。加入a标签后，文字的颜色就会自动变为蓝色（被点击过的文本颜色为紫色） 新窗口打开超链接&lt;a href=&quot;目标网址&quot; target=&quot;_blank&quot;&gt;click here!&lt;/a&gt; 使用mailto协议发送电子邮件,mailto://abc@qq.com?&amp;cc=abcd@qq.com&amp;bcc=ab@qq.com&amp;subject=主题&amp;body=邮件内容,其中,cc表示抄送,bcc表示密件抄送 插入图片语法&lt;img src=&quot;图片地址&quot; alt=&quot;下载失败时的替换文本&quot; title = &quot;提示文本&quot;&gt; 表单是可以把浏览者输入的数据传送到服务器端,语法:&lt;form method=&quot;传送方式&quot; action=&quot;服务器文件&quot;&gt;,action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。method ： 数据传送的方式（get/post） 文本输入框input的类型:text：文本框 password：密码框 raido：单选按钮 checkbox：复选框 file：文件选择框 submit：提交按钮,reset:重置 &lt;form&gt; &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt; &lt;/form&gt;`其中name为文本框命名,方便后台使用,value为文本框设置默认值,一般起提示作用 文本输入域`&lt;textarea rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt;`,在&lt;textarea&gt;&lt;/textarea&gt;标签之间可以输入默认值。注意这两个属性可用css样式的width和height来代替：col用width、row用height来代替。 单选框与复选框:注意:同一组的单选按钮，name 取值一定要一致 下拉列表: &lt;select&gt; &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt; &lt;option value=&quot;旅游&quot;&gt;旅游&lt;/option&gt; &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt; &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt; &lt;/select&gt;` value为向服务器提交的值,设置selected=“selected”属性,则默认选中. 下拉列表也可以进行多选操作，在&lt;select&gt;标签中设置multiple=”multiple”属性，就可以实现多选功能，在 windows 操作系统下，进行多选时按下Ctrl键同时进行单击（在 Mac下使用 Command +单击），可以选择多个选项。 form表单中的label标签:用于显示提示文本,并且当用户点击label时,将焦点转移到与之对应的控件(常用输入框)上,但是标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。 &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt; CSS css 样式由选择符和声明组成，而声明又由属性和值组成,属性和值之间用英文冒号“：”分隔。当有多条声明时，中间可以英文分号“;”分隔,最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号。 CSS中有注释语句：用/*注释语句*/来标明,（Html中使用&lt;!--注释语句--&gt;) 内联式css样式表就是把css代码直接写在现有的HTML标签中，注意要写在元素的开始标签里,css样式代码要写在style=””双引号中，如果有多条css样式代码设置可以写在一起，中间用分号隔开 嵌入式css样式，写在当前的文件中.嵌入式css样式必须写在&lt;style&gt;&lt;/style&gt;之间，并且一般情况下嵌入式css样式写在&lt;head&gt;&lt;/head&gt;之间。注意设置style的type属性. &lt;style type=&quot;text/css&quot;&gt; span{ color:blue; } &lt;/style&gt; 外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以“.css”为扩展名，在&lt;head&gt;内（不是在&lt;style&gt;标签内）使用&lt;link&gt;标签将css样式文件链接到HTML文件内,&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;,rel=&quot;stylesheet&quot; type=&quot;text/css&quot;是固定写法不可修改。&lt;link&gt;标签位置一般写在&lt;head&gt;标签之内。 标签选择器; 标签名称{css样式代码;} 类选择器:.类选器名称{css样式代码;} ID选择器:#id名称{css样式代码;} 子选择器:即大于符号(&gt;),用于选择指定标签元素的第一代子元素(只能是孩子)。.food&gt;li{border:1px solid red;} 包含选择器:加入空格,用于选择指定标签元素下的后辈元素。.first span{color:red;} 通用选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素 伪类选择符:a:hover{color:red;} 分组选择符:为html中多个标签元素设置同一个样式（，)h1,span{color:red;} 类选择器和ID选择器的区别:1.ID选择器只能在文档中使用一次,类选择器可以使用多次,也即id选择器(名称)具有唯一性;2.可以使用类选择器词列表方法为一个元素同时设置多个样式。也即一个元素可以具有多个类,但只能有一个id:&lt;span class=&quot;stress bigsize&quot;&gt;三年级&lt;/span&gt; border:1px solid red;相当于border-width:1px;//边框宽度 border-style:solid; //边框风格 border-color:red; //边框颜色 继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。border:1px solid red;无法继承. 标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于最后面的css样式会被应用。 继承是指标签的样式可以由子代继承，但有些标签是不能继承的，eg：border。特殊性指用用权重来确定最后起作用的样式，id=100，class=10，标签=1，继承=0.1；层叠指当权重相同时，后面的样式覆盖前面的样式。important的使用。 浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式，但记住!important优先级样式是个例外，权值高于用户自己设置的样式。p{color:red !important;}注意分号放在!important的后面 任意浏览器的默认字体高度16px（16像素）。所有未经调整的浏览器都符合:1em=16px。为了简化font-size的换算，需要在css中的body选择器中声明font-size=62.5%，这就使em值变为16px*62.5%=10px,这样12px=1.2em,10px=1em,也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。注：建议不要使用em作为中文站点的文字单位，会导致文字变形十分严重的。em的值并不是固定的； em会继承父级元素的字体大小。 图片居中，不能直接对img标签使用text-align:center;而是对该img标签所在的div或者其他块级元素使用才会达到这种效果。 字体:`font-family:”Microsoft Yahei”;` 文字颜色,字号:`font-size:12px;color:#666` 文字粗体:`font-weight:bold;` 文字斜体:`font-style:italic;` 文字下划线;`text-decoration:underline;` 文字删除线:`text-decoration:line-through;` 文本缩进:`text-indent:2em;`两个空格 行间距(行高):`line-height:2em;` 设置文字间隔或者字母间隔:`letter-spacing:50px;`注意：这个样式使用在英文单词时，是设置字母与字母之间的间距。 单词间距:`word-spacing:50px;` 为块状元素中的文本、图片设置居中样式:`text-align:center;` 常用的块状元素有：`&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;` 常用的内联元素有：`&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;` 常用的内联块状元素有：`&lt;img&gt;、&lt;input&gt;` 块状元素都自带换行效果；内联元素都是定义行内小区域且不换行，但如果没有内容就没有意义，不占空间；内联块状元素除了不换行，即使没有内容也会占空间。 在html中&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;就是块级元素。设置display:block就是将元素显示为块级元素。 将内联元素转换为块级元素:a{display:block;} 块级元素特点：1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）2、元素的高度、宽度、行高以及顶和底边距都可设置。3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 在html中，&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;就是典型的内联元素（行内元素）（inline）元素。当然块状元素也可以通过代码display:inline将元素设置为内联元素。display:inline; 内联元素特点：1、和其他元素都在一行上；2、元素的高度、宽度及顶部和底部边距不可设置；3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码display:inline-block就是将元素设置为内联块状元素。(css2.1新增)，&lt;img&gt;、&lt;input&gt;标签就是这种内联块状标签。 inline-block 元素特点：1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置。 边框:border:2px solid red;对应:border-width:2px;border-style:solid;border-color:red;border-style（边框样式）常见样式有：dashed（虚线）| dotted（点线）| solid（实线）。border-width（边框宽度）中的宽度也可以设置为：thin | medium | thick（但不是很常用），最常还是用像素（px） 单独设置下边框:border-bottom:1px solid red; top right left bottom css内定义的宽（width）和高（height），指的是填充以里的内容范围。因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 元素与其它元素之间的距离可以使用边界（margin）来设置。 元素内容与边框之间是可以设置距离的，称之为“填充”padding-top。 顺时针:上 右 下 左 或者 上下 左右 或者 上下左右 CSS包含3种基本的布局模型，用英文概括为：Flow、Layer 和 Float。在网页中，元素有三种布局模型：1、流动模型（Flow）2、浮动模型 (Float)3、层模型（Layer） 流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。流动布局模型具有2个比较典型的特征：第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行） 块状元素这么霸道都是独占一行，设置元素浮动就可以实现让两个块状元素并排显示。任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动.float:left; 层布局模型就像是图像软件PhotoShop中非常流行的图层编辑功能一样，每个图层能够精确定位操作.CSS定义了一组定位（positioning）属性来支持层布局模型。层模型有三种形式：1、绝对定位(position: absolute)2、相对定位(position: relative)3、固定定位(position: fixed) 设置position:absolute(表示绝对定位)，作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。对于以前位置(右上角）向左移动100像素，向下移动20像素。right:100px; top:20px;right的是让right的margin变为100px，同理top是让top的margin变为20px，所以要向右和向下移。 如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。position:relative; left:100px; top:50px;（相对于以前位置左上角）向右移动100像素，向下移动50像素。 absolute表里如一，移动了就是移动了。relative只是表面显示移动了，但实际还在文档流中原有位置，别的元素无法占据。 fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。 使用position:relative,相对于其它元素进行定位,参照定位的元素必须是相对定位元素的前辈元素;参照定位的元素必须加入position:relative;定位元素加入position:absolute，便可以使用top、bottom、left、right来进行偏移定位了 参照物不是浏览器 #box1{ width:200px; height:200px; position:relative; } #box2{ position:absolute; top:20px; left:30px; } //box2就可以相对于父元素box1定位 设置的颜色是16进制的色彩值时，如果每两位的值相同，可以缩写一半。p{color:#000000;} == p{color:#000;} p{color: #336699;}==p{color: #369;} 字体的缩写body{ font:12px/1.5em &quot;宋体&quot;,sans-serif;}1、使用这一简写方式你至少要指定 font-size 和 font-family 属性，其他的属性(如 font-weight、font-style、font-varient、line-height)如未指定将自动使用默认值。2、在缩写时 font-size 与 line-height 中间要加入“/”斜扛。 设置颜色值的三种方式:1,英文命令.2.RGB p{color:rgb(133,45,200);}每一项在0-255之间,也可以是百分数p{color:rgb(20%,33%,25%);}.3.十六进制(较普遍)p{color:#00ffff;} 长度单位 目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。 1、像素 像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS规范中假设“90像素=1英寸”）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。 2、em 就是本元素给定字体的 **font-size 值**，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。如下代码： p{font-size:12px;text-indent:2em;} 上面代码就是可以实现段落首行缩进 24px（也就是两个字体大小的距离）。 下面注意一个特殊情况： 但当给 font-size 设置单位为 em 时，此时计算的标准以 p 的父元素的 font-size 为基础。如下代码： html: &lt;p&gt;以这个&lt;span&gt;例子&lt;/span&gt;为例。&lt;/p&gt; css: p{font-size:14px} span{font-size:0.8em;} 结果 span 中的字体“例子”字体大小就为 11.2px（14 * 0.8 = 11.2px）。 3、百分比 p{font-size:12px;line-height:130%} 设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。 水平居中设置-行内元素:如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center来实现的。 水平居中设置-定宽块状元素:当被设置元素为 块状元素 时用 text-align：center就不起作用了，这时也分两种情况：定宽块状元素和不定宽块状元素。定宽块状元素：块状元素的宽度width为固定值。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。 水平居中设置-不定宽块状元素方法（一）:(不定宽块状元素：块状元素的宽度width不固定。)不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）:1.加入 table 标签,为这个 table 设置“左右 margin 居中”（这个和定宽块状元素的方法一样,利用table标签的长度自适应性,可以看做一个定宽度块元素)2.设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置3.设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的 &lt;table&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt; &lt;ul&gt; &lt;li&gt;我是第一行文本&lt;/li&gt; &lt;li&gt;我是第二行文本&lt;/li&gt; &lt;li&gt;我是第三行文本&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; 或者直接设置`display:table; margin:0 auto; `也即 .wrap{background:#ccc;display:table;margin:0 auto; } 水平居中设置-不定宽块状元素方法（二）:改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。它将块状元素的 display 类型改为 inline，变成了行内元素，所以少了一些功能，比如设定长度值。 水平居中设置-不定宽块状元素方法（三）:通过给父元素设置 float值为left，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。 垂直居中-父元素高度确定的单行文本:设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。这种文字行高与块高一致带来了一个弊端：当文字内容的长度大于块的宽时，就有内容脱离了块。 垂直居中-父元素高度确定的多行文本（方法一）:插入 table标签，同时设置 vertical-align：middle。 垂直居中-父元素高度确定的多行文本（方法二）:设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式, 兼容性比较差。 display:table-cell;/*IE8以上及Chrome、Firefox*/ vertical-align:middle;/*IE8以上及Chrome、Firefox*/ 隐性改变display类型:有一个有趣的现象就是当为元素（不论之前是什么类型元素，display:none 除外）设置以下 2 个句之一： 1. position : absolute 2. float : left 或 float:right 简单来说，只要html代码中出现以上两句之一，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。 JavaScript 我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。放在部分最常用的方式是在页面中head部分放置script&gt;元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。 放在部分JavaScript代码在网页读取到该语句的时候就会执行。注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;I love JS&quot;) &lt;/script&gt; 单行注释，在注释内容前加符号 “//”。多行注释以”/“开始，以”/“结束。 1.变量必须使用字母、下划线()或者美元符($)开始。2.然后可以使用任意多个英文字母、数字、下划线()或者美元符($)组成。 3.不能使用JavaScript关键词与JavaScript保留字。变量要先声明再赋值，JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。 document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。第一种:输出内容用””括起，直接输出””号内的内容。第二种:通过变量，输出内容.第三种:输出多项内容，内容之间用+号连接。第四种:输出HTML标签，并起作用，标签使用&quot;&quot;括起来。document.write(mystr+&quot;&lt;br&gt;&quot;); js输出空格:&quot;&amp;nbsp;”或者document.write(&quot;&lt;span style=&#39;white-space:pre;&#39;&gt;&quot;+&quot; 1 2 3 &quot;+&quot;&lt;/span&gt;”);输出时添加“white-space:pre;”样式属性。这个样式表示”空白会被浏览器保留” JavaScript-警告（alert 消息对话框） JavaScript-确认（confirm 消息对话框）弹出对话框(包括一个确定按钮和一个取消按钮)。 confirm(str);当用户点击”确定”按钮时，返回true当用户点击”取消”按钮时，返回false function rec(){ var mymessage=confirm(&quot;你好棒&quot;) ; if(mymessage==true) { document.write(&quot;你是女士!&quot;); } else { document.write(&quot;你是男士!&quot;); } } JavaScript-提问（prompt 消息对话框）弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。prompt(str1, str2);str1: 要显示在消息对话框中的文本，不可修改,str2：文本框中的内容，可以修改.1. 点击确定按钮，文本框中的内容将作为函数返回值2. 点击取消按钮，将返回null.注:在用户点击对话框的按钮前，不能进行任何其它操作。 score = prompt(&quot;哈喽哈&quot;,&quot;默认值&quot;); if(score&gt;=90) { document.write(&quot;你很棒!&quot;); } JavaScript-打开新窗口（window.open）window.open([URL], [窗口名称], [参数字符串]) URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。 窗口名称：可选参数，被打开窗口的名称。 1.该名称由字母、数字和下划线字符组成。 2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 4.name 不能包含有空格。 参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。toolbar工具栏,scrollbars滚动条,status状态栏menubar菜单栏 值为yes/no 窗口宽高度width/height以及窗口顶部/左端距离屏幕顶部的像素数top/left &lt;script type=&quot;text/javascript&quot;&gt; window.open(&apos;http://www.imooc.com&apos;, &apos;_blank&apos;,&apos;width=300,height=200, menubar=no,toolbar=no, status=no,scrollbars=yes’) &lt;/script&gt; JavaScript-关闭窗口（window.close） window.close(); //关闭本窗口 &lt;窗口对象&gt;.close(); //关闭指定的窗口 &lt;script type=&quot;text/javascript&quot;&gt; var mywin=window.open(&apos;http://www.imooc.com&apos;); //将新打的窗口对象，存储在变量mywin中 mywin.close(); &lt;/script&gt; 文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。 HTML文档可以说由节点构成的集合，三种常见的DOM节点:1. 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。2. 文本节点:向用户展示的内容，如&lt;li&gt;...&lt;/li&gt;中的JavaScript、DOM、CSS等文本。3. 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=&quot;http://www.chenyalun.com&quot;。 通过ID获取元素:document.getElementById(“id”),返回[object HTMLParagraphElement] ,注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。用document.getELementById().innerHTML;才可以获取到其中的内容. innerHTML 属性用于获取或替换 HTML 元素的内容。Object.innerHTML,1.Object是获取的元素对象，如通过document.getElementById(“ID”)获取的元素。2.注意书写，innerHTML区分大小写。 改变 HTML 样式:Object.style.property=new style;例如:mychar.style.color=red; 显示和隐藏（display属性）Object.style.display = value,其中value为none隐藏,value为block块级元素显示.其中none与block要加上引号 控制类名（className 属性）className 属性设置或返回元素的class 属性。object.className = classname作用:1.获取元素的class 属性2. 为网页内的某个元素指定一个css样式来更改该元素的外观 删除修改的样式:document.getElementById(&quot;txt&quot;).removeAttribute(&quot;style&quot;); 外部引入JS &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 变量:字母数字下划线美元符,变量名区分大小写,不允许使用关键字保留字 变量也可以不声明，直接使用，但为了规范，需要先声明，后使用。 “+”连接字符串时,符号两边不能有空格 jq1=numa + 30 &gt;10 &amp;&amp; numb * 3&lt;20;算术操作符 → 比较操作符 → 逻辑操作符 → “=”赋值符号 定义数组: var myarr=new Array(); myarr[0]=80;实际上数组都是变长的,即使指定了长度为8，仍然可以将元素存储在规定长度以外。 创建数组:var myarr = new Array(11,25,35); var myarr = [12,25,416]; 只需使用下一个未用的索引，任何时刻可以不断向数组增加新元素。myarray[5]=88; //使用一个新索引，为数组增加一个新元素 数组的属性:length长度 二维数组的表示:myarray[ ][ ],简单定义:var Myarr = [[0 , 1 , 2 ],[1 , 2 , 3]],也可以使用循环,myarr[0][1]=5; //将5的值传入到数组中，覆盖原有值。 ==先转换类型再比较，===先判断类型，如果不是同一类型直接为false。 函数调用的两种情况:1.script标签中直接调用,2.点击按钮调用onClick事件 有参数的函数:function 函数名(参数1,参数2){ 函数代码},参数不要声明类型 function add2(x,y){ sum = x + y; return sum; //返回函数值,return后面的值叫做返回值。} 事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。 常用JS事件: onclick鼠标单击事件 onmouseover鼠标经过事件 onmouseout鼠标移开事件 onchange文本框**内容**改变事件,一般是textarea onselect文本框**内容**选中事件,一般是textarea onfocus光标聚焦 onblur光标移开 onload网页加载后,事件会在页面加载完成后，立即发生，同时执行被调用的程序。 加载页面时，触发onload事件，**事件写在&lt;body&gt;标签内**。 onunload卸载事件,当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件， 同时执行被调用的程序。该事件目前只对IE起作用。 使用parseInt()函数可解析一个字符串,并返回一个整数。 JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。对象的属性：反映该对象某些特定的性质的，如：字符串的长度、图像的长宽等；对象的方法：能够在对象上执行的动作。例如，表单的“提交”(Submit)，时间的“获取”(getYear)等； Date日期对象 日期对象,使用关键字new，Date()的首字母必须大写。 // 日期的相关属性与方法 get/setDate() 返回设置日期 get/setFullYear() 返回设置年份,用四位数表示 get/setYear() 返回/设置年份 get/setMonth() 返回/设置月份 get/setHours() 返回/设置小时,24小时制 get/setMinutes() 返回/设置分钟数 get/setSeconds() 返回/设置秒钟数 get/setTime() 返回/设置时间(毫秒为单位) getDay() 返回星期，返回的是0-6的数字，0 表示星期天。 使用 String 对象的 toUpperCase() 方法来将字符串小写字母转换为大写.使用toLowerCase()方法，将字符串所有大写字母都变成小写的字符串 charAt() 方法可返回指定位置的字符。返回的字符是长度为 1 的字符串。 注意：1.字符串中第一个字符的下标是 0。最后一个字符的下标为字符串长度减一（string.length-1）。2.如果参数 index 不在 0 与 string.length-1 之间，该方法将返回一个空字符串。 indexOf(,) 方法可返回某个指定的字符串值在字符串中首次出现的位置。1.该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 substring。2.可选参数，从stringObject的startpos位置开始查找substring，如果没有此参数将从stringObject的开始位置查找。3.如果找到一个 substring，则返回 substring 的第一次出现的位置。stringObject 中的字符位置是从 0 开始的。 split(separator,limit) 方法将字符串分割为字符串数组，并返回此数组。注意：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。separator必须,从该参数指定的地方分割stringObject,limite,可选参数,分割的次数,如果设置该参数,则返回的子串不会多于这个参数指定的数组,如果无参数,则不限定次数 substring(起始位置,可选的结束位置(不包含该位置的字符)) 方法用于提取字符串中介于两个指定下标之间的字符。注意：1. 返回的内容是从 start开始(包含start位置的字符)到 stop-1 处的所有字符，其长度为 stop 减start。2. 如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。3. 如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。 substr() 方法从字符串中提取从 startPos位置开始的指定数目的字符串。stringObject.substr(startPos,length) 注意：如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。如果startPos为负数且绝对值大于字符串长度，startPos为0。 string.substring( 起点 ， 终点 ) string.substr( 起点 ，长度 ) Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。 MATH常用属性方法 MATH E 返回算数常量e(约为2.71828) LN2 返回2的自然对数 LN10 返回10的自然对数 LOG2E 返回以2为底的e的对数 LOG10E 返回以10为底的e的对数 PI 圆周率 SQRT1_2 返回2的平方根的倒数 SQRT2 返回2 的平方根 MATH常用方法 abs(x) 返回数的绝对值 acos(x) 返回数的反余弦值 asin(x) 返回数的反正弦值 atan(x) 返回数的反正切值 atan2(y,x)返回由x轴到点(x,y)的角度(以弧度为单位) ceil(x)对数进行上舍入 cos(x) 返回数的余弦 exp(x) 返回e的指数 floor(x)对数进行下舍入 log(x) 返回数的自然对数 max(x,y) 返回最高值 min(x,y) 返回最小值 pow(x,y) 返回x的y 次方 random() 返回0--1之间的随机数 round(x) 把数四舍五入最为接近的数 sin(x) 正弦 cos(x) 余弦 tan(x) 正切 sqrt(x) 平方根 toSourse() 返回该对象的源代码 value() 返回MATH对象的原始值 数组常用方法 数组 concat() 连接两个或更多的数组,并返回结果 join() 把数组的所有元素放入一个字符串,元素通过指定的分隔符分割 pop() 删除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素,并返回新的长度 reverse() 颠倒数组元素的顺序 shift() 删除并返回数组的第一个元素 slice(start,可选的end) 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素,并向数组添加新元素 toSource() 返回该对象的源代码 toString() 把数组转换为字符串,并返回结果 toLocalString() 把数组转化为本地数组,并返回结果 unshift() 向数组的开头添加一个或者更多元素,并返回新的长度() valueOf() 返回数组对象的原始值 window对象方法 window alert() 显示带有一段消息和一个确定按钮的警告框 prompt() 显示可以提示用户输入的对话框 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 open() 打开一个新的浏览器窗口或者查找一个已命名的窗口 close() 关闭浏览器窗口 print() 打印当前窗口的内容 focus() 把键盘焦点给予一个窗口 blur() 把键盘焦点从顶层窗口移开 moveBy() 相对窗口的当前坐标移动指定的像素 moveTo() 把窗口的左上角移动一个指定的坐标 resizeBy() 按照指定的像素调整窗口的大小 resizeTo() 把窗口的大小调整到指定的宽度和高度 scrollBy() 按照指定的像素滚动内容 scrollTo() 把内容滚动到指定的坐标 setInterval(代码,间隔时间) 每隔一定时间执行代码(间隔性触发计时器),在执行时,从载入页面后每隔指定的时间执行代码。代码:函数或代码串,如”clock()”或者clock,交互时间:以毫秒为单位.返回该定时器 setTimeout() 在指定的时间延迟后指定代码(一次性计时器) clearInterval() 取消setInterval() 的设置,传入定时器 clearTimeout() 取消setTimeout() 的设置 history对象 history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。window.history.[属性|方法] length 返回浏览器历史列表的URL数量 back() 加载history列表中前一个URL forward() 加载history列表下一个URL go(number) 加载history列表某一个具体的页面,0:当前页面 back()相当于go(-1),forward()相当于go(1) location对象 location用于获取或设置窗体的URL，并且可以用于解析URL。location.[属性|方法] hash 设置或返回从#开始的URL(锚点) host 设置或返回主机名和当前URL的端口号 hostname 设置或返回当前URL的主机名 href 设置或返回完成的URL pathname 设置或返回当前URL的路径部分 port 设置或返回当前URL的端口号 protocol 设置或返回当前URL的协议 search 设置或者返回从?开始的URL(查询部分) assign() 加载新的文档 reload() 重新加载当前文档 replace() 用新的文档替换当前文档 navigator对象 navigator 对* navigator 对象包含有关浏览器的信息 appCodeName 浏览器代码名的字符串表示 appName 浏览器的名称 appVersion 浏览器平台以及版本 platform 运行浏览器的操作系统平台 userAgent 返回user-agent头部的值 window中的screen 对象 window.screen 对象在编写时可以不使用 window 这个前缀。 screen对象用于获取用户的屏幕信息。window.screen.属性 height 屏幕的高度,单位像素 width 屏幕的宽度,单位像素 availHeight 窗口可用的屏幕高度,单位像素,减去界面特性，比如任务栏。 availWidth 窗口可用的屏幕宽度,单位像素,减去界面特性，比如任务栏。 colorDepth 用户浏览器表示的颜色位数,通常32位(每像素的位数) pixelDepth 浏览器颜色位数,通常32位(每像素的位数)(IE不支持) 文档对象模型 节点属性与方法 nodeName 返回一个字符串,其内容是给定节点的名字 nodeType 返回一个整数,这个数值代表给定节点的类型 nodeValue 返回给定节点的当前值 innerHTML 节点内置文本 childNodes 返回一个数组,这个数组由给定元素节点的子节点构成 firstChild 返回第一个子节点 lastChild 返回最后一个子节点 parentNode 返回一个给定节点的父节点 nextSibling返回给定节点的下一个子节点 previousSibling 返回给定节点的上一个子节点 document.createElement(&quot;elementType&quot;) 创建一个新的元素节点 document.cr document.createTextNode(&quot;text&quot;) 创建一个包含着给定文本的新文本节点,text为文本 appendChild(node) 指定节点的最后一个子节点列表后添加一个新的子节点 insertBefore(newnode,node) 将一个给定节点插入到一个给定元素节点的给定节点前面 removeChild(node) 从一个给定元素中删除一个子节点 replaceChild(newnode,oldnew) 把一个给定元素里的一个子节点替换为另外一个节点 docuument常用方法 document.getElementsByName(name) 返回带有指定名称的节点对象的集合。与getElementById() 方法不同的是，通过元素的 name 属性查询元素，而不是通过 id 属性 document.getElementsByTagName(Tagname) Tagname是标签的名称，如p、a、img等标签名。和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。 elementNode.getAttribute(name),其中elementNode：使用getElementById()、getElementsByTagName()等方法，获取到的元素节点.name：要想查询的元素节点的属性名字. elementNode.setAttribute(name,value),name: 要设置的属性名。value: 要设置的属性值。把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。 在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：nodeName : 节点的名称,nodeValue ：节点的值,nodeType ：节点的类型 nodeName 属性: 节点的名称，是只读的。 1. 元素节点的 nodeName 与标签名相同 2. 属性节点的 nodeName 是属性的名称 3. 文本节点的 nodeName 永远是 #text 4. 文档节点的 nodeName 永远是 #document nodeValue 属性：节点的值 1. 元素节点的 nodeValue 是 undefined 或 null 2. 文本节点的 nodeValue 是文本自身 3. 属性节点的 nodeValue 是属性的值 nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型: 元素类型 节点类型 元素 1 属性 2 文本 3 注释 8 文档 9 elementNode.childNodes,访问子节点. node.firstChild,node.lastChild,访问子节点的第一项,最后一项,如果选定的节点没有子节点，则该属性返回 NULL。 elementNode.parentNode,获取指定节点的父节点,父节点只能有一个。览器兼容问题，chrome、firefox等浏览器标签之间的空白也算是一个文本节点。 nodeObject.nextSibling,nodeObject.previousSibling,访问兄弟节点 appendChild(newnode),在指定节点的最后一个子节点列表之后添加一个新的子节点。 removeChild(),把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。如果要完全删除对象，给 x 赋 null 值 document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。,window.innerHeight- 浏览器窗口的内部高度,document.body.clientHeight,Document对象的body属性对应HTML文档的标签 通用解决方案: var w=document.documentElement.scrollWidth || document.body.scrollWidth; var h=document.documentElement.scrollHeight || document.body.scrollHeight; 网页尺寸:scrollHeight和scrollWidth，获取网页内容高度和宽度。scrollHeight 是网页内容实际高度，可以小于 clientHeight。scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。 通用解决方案: var w=document.documentElement.scrollWidth || document.body.scrollWidt h; var h=document.documentElement.scrollHeight || document.body.scrollHeight; offsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。 通用解决方案 var w= document.documentElement.offsetWidth || document.body.offsetWidth; var h= document.documentElement.offsetHeight || document.body.offsetHeight; scrollLeft:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。 scrollTop:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。 offsetLeft:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。 offsetTop:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。 offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。 clientHeight,大家对 clientHeight 都没有什么异议，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个工具条以下到状态栏以上的这个区域，与页面内容无关。 offsetHeight,IE、Opera 认为 offsetHeight = clientHeight + 滚动条 + 边框。,NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。 scrollHeight,IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。,NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。 浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上; JavaScript不区分整数和浮点数，统一用Number表示 NaN;NaN表示Not a Number，当无法计算结果时用NaN表示.Infinity;Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity ==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。始终坚持使用===比较 NaN这个特殊的Number与所有其他值都不相等，包括它自己,唯一能判断NaN的方法是通过isNaN()函数,isNaN(NaN); // true Swift用nil，Python用None表示,JavaScript用null JavaScript的数组可以包括任意数据类型。 JavaScript的对象是一组由键-值组成的无序集合,JavaScript对象的键都是字符串类型，值可以是任意数据类型。 变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。 如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量,在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误,启用strict模式的方法是在JavaScript代码的第一行写上：&#39;use strict&#39;; 你好, ${name}, 你今年${age}岁了!;注意不是单引号 直接给Array的length赋一个新的值会导致Array大小的变化,如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化 空数组继续pop不会报错，而是返回undefined,如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉 空数组继续shift不会报错，而是返回undefined splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素,从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook’); concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里 unshift()和push()对应,头部添加若干元素,shift()和pop()对应删除末尾元素. 声明对象 var person = { name : “AA”, age : 12, &apos;m-s&apos;: &apos;No&apos;,// 非有效变量 sex : true }; // 访问:person.name; person[&apos;m-s&apos;]; person.a; // 访问不存在的属性不报错，而是返回undefined // 自由增加属性:person.b = 12; // 删除属性 delete person.age; // 检测对象以及父类具有某属性 &apos;name&apos; in person 返回布尔 // 检测某对象具有某属性 person.hasOwnProperty(&apos;name&apos;); 返回布尔 JavaScript把null、undefined、0、NaN和空字符串’’视为false，其他值一概视为true for (var index in array) {// 此处的index是索引而非array中的元素} Map是一组键值对的结构，具有极快的查找速度。var m = new Map([[&#39;Michael&#39;, 95], [&#39;Bob&#39;, 75], [&#39;Tracy&#39;, 85]]); m.get(&#39;Michael&#39;); // 95常用操作: var m = new Map(); // 空Map m.set(&apos;Adam&apos;, 67); // 添加新的key-value m.set(&apos;Bob&apos;, 59); m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: true m.get(&apos;Adam&apos;); // 67 m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos; m.get(&apos;Adam&apos;); // undefined Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。var s2 = new Set([1, 2, 3]); // 含1, 2, 3.通过add(key)方法可以添加元素到Set中,通过delete(key)方法可以删除元素 遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for … of循环来遍历。 for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。索引+属性 for … of循环则完全修复了这些问题，它只循环集合本身的元素,元素本身 forEach遍历 var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; a.forEach(function (element, index, array) { // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 alert(element); }); var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]); s.forEach(function (element, sameElement, set) { alert(element); }); var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]); m.forEach(function (value, key, map) { alert(value); }); JavaScript允许传入任意个参数而不影响调用,传入的参数比定义的少也没有问题 JavaScript还有一个关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。类似数组不是数组 不在任何函数内定义的变量就具有全局作用域。全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。 // 唯一的全局变量MYAPP: var MYAPP = {}; // 其他变量: MYAPP.name = &apos;myapp&apos;; MYAPP.version = 1.0; // 其他函数: MYAPP.foo = function () { return &apos;foo&apos;; }; JavaScript的变量作用域实际上是函数内部,用let替代var可以申明一个块级作用域的变量,const来定义常量，const与let都具有块级作用域 绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字 非strict环境下:直接使用this没毛病,strict环境下:函数内部首先写上var that = this;之后使用that 据是否是strict模式，this指向undefined或window apply()把参数打包成Array再传入； call()把参数按顺序传入。 简单的高阶函数:一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数 map():对数组中的每一个且仅是单独的元素执行操作, // 把每一个元素转化为字符串 ,得到的仍是数组 array.map(String) // 执行pow() function pow(x) { return x * x; } array.map(pow),得到的仍是数组 reduce():对数组中的最开始两个元素进行操作,将结果与第三个元素操作,以此类推 // 数组求和 arr.reduce(function (x, y) { return x + y; }); filter():根据传入的函数,作用于每一个元素,返回true或false,把数组中的某些元素过滤掉,返回剩余的元素 var r = arr.filter(function (s) { return x % 2 !== 0; }); arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] sort():排序,默认把所有元素先转换为String再排序,传入的排序函数,根据返回-1进行排序 箭头函数:在箭头函数中,可以直接使用this,而非that x =&gt; x*x // 相当于 function (x) { return x*x; } // 含有多条语句,多个参数时 (x,y) =&gt; { if (x &gt;0 ) { return 0; } return x*y; } // 不能省略{} // 特别注意返回一个对象: x =&gt; ({ foo: x }) generator和函数不同的是，generator由function*定义,除了return语句，还可以用yield返回多次。调用generator对象有两个方法，一是不断地调用generator对象的next()方法,第二个方法是直接用for … of循环迭代generator对象 用typeof操作符获取对象的类型，它总是返回一个字符串:’number’,’boolean’,’string’,’function’,’object’,’undefined’,特别注意null的类型是object，Array的类型也是object 包装对象:var n = new Number(123);,返回object JavaScript的月份范围用整数表示是0~11，0表示一月，1表示二月 RegExp中:在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字,.可以匹配任意字符，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符,\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格 更精确的匹配,[]表示范围:[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线,[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串,[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）,A|B可以匹配A或B,^表示行的开头，^\d表示必须以数字开头。$表示行的结束，\d$表示必须以数字结束。js也可以匹配&#39;jsp&#39;，但是加上^js$就变成了整行匹配，就只能匹配&#39;js&#39;了 JavaScript有两种方式创建一个正则表达式：第一种方式是直接通过/正则表达式/写出来，第二种方式是通过new RegExp(‘正则表达式’)创建一个RegExp对象。 var re1 = /as\_32/; // 最好,不用考虑转义问题 var re2 = new RegExp(“as\\_32”); // 如果使用第二种写法，因为字符串的转义问题，字符串的两个\\实际上是一个\ //RegExp对象的test()方法用于测试给定的字符串是否符合条件 re1.test(&apos;sfdf&apos;);// 返回false 用()表示的就是要提取的分组（Group）,exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。exec()方法在匹配失败时返回null var re = /^(\d{3})-(\d{3,8})$/; re.exec(&apos;010-12345&apos;); // [&apos;010-12345&apos;, &apos;010&apos;, &apos;12345&apos;] 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符,加个?就可以让\d+采用非贪婪匹配 g表示全局匹配,var r1 = /test/g;// 等价于:var r2 = new RegExp(&#39;test&#39;, &#39;g&#39;);指定i标志，表示忽略大小写，m标志，表示执行多行匹配 注意,在范围匹配[]中,字符要加上反斜杠\,在一般匹配中不需要 [a-zA-Z_]其实就是\w JSON序列化:JSON.stringify(object,[propertyName:value],’ ‘); 第二个参数用于控制如何筛选对象的键值，标明指定属性可以输出指定的属性,也可以传入函数进行处理,可以不写,第三个参数是缩进 反序列化:JSON.parse()把它变成一个JavaScript对象 JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。xiaoming.__proto__ = Student; JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。 如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this; 造函数首字母应当大写，而普通函数首字母应当小写 花了一个周末学习一下前端方面的知识,笔记略微粗糙,复习时再做修正.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读博客之笔记二]]></title>
    <url>%2F2016%2F11%2F10%2F%E8%AF%BB%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[许多鞭辟入里的文章。 读感零零碎碎花了一个多星期才把王中周前辈的博客看完,文章比较详细,许多底层的东西我读了好几遍才理解,受益匪浅,把重要的知识点记下来,作复习之用. 知识self 是类的隐藏的参数，指向当前调用方法的类，另一个隐藏参数是 _cmd，代表当前类方法的 selector。super 只是一个“编译器指示符”(编译器特性)，它和 self 指向的是相同的消息接收者。不同的是，super 告诉编译器，要去调用父类的方法，而不是本类里的。当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法。 消息发送id objc_msgSend(id theReceiver, SEL theSelector, ...) 以[self setName:] 为例，编译器会替换成调用objc_msgSend 的函数调用，其中 theReceiver 是 self，theSelector 是 @selector(setName:)，这个 selector 是从当前 self 的 class 的方法列表开始找的 setName，当找到后把对应的 selector 传递过去。 id objc_msgSendSuper(struct objc_super *super, SEL op, ...) struct objc_super { id receiver; Class superClass; }; 而当使用[super setName] 调用时，会使用 objc_msgSendSuper 函数，结构体包含了两个成员，一个是 receiver，这个类似objc_msgSend 的第一个参数 receiver，第二个成员是记录所谓的“父类”。从 objc_super 结构体指向的 superClass 的方法列表开始找 setName 的 selector，找到后再以 objc_super-&gt;receiver 去调用这个 selector。 通知NSNotification使用的是同步操作，如果想让NSNotification的post处和observer处异步执行，可以通过NSNotificationQueue实现。对于同一个通知，如果注册了多个观察者，则这多个观察者的执行顺序和他们的注册顺序是保持一致的。observer的回调方法执行线程和post的线程保持一致，如果想让post的线程和转发的线程不同，可以通过NSNotification重定向技术实现。addObserver和removeObserver必须成对出现，或者说添加了Observer必须适时移除Observer。因为通知中心并不retain Observer，若不移除，会极易给释放的对象发送消息。 屏幕普屏中1点 = 1像素，Retina屏：1点 = 2像素。人手指的最小点击范围是44pixels，所以在iPhone的很多细节上都是44 pixels。使用图片资源时，方法：[UIImage imageNamed:@&quot;adflower.png&quot;]]，在实际运行时，如果发现当前的设备是Retina屏，会自动寻找图片”adflower@2x.png“。 [UIScreen mainScreen].applicationFrame获取app尺寸(去掉状态栏)，[ UIScreen mainScreen].bounds获取屏幕尺寸，[[UIApplicationsharedApplication] statusBarFrame]状态栏尺寸。 程序启动在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是类对象(class object),它是一个单例(singleton),这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。任何直接或间接继承了NSObject的类，它的实例对象(instance objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个 实例对象(instace object) 所属的类的定义的一切：包括变量，方法，遵守的协议等等。 类对象并不是类的实例本身。它没有自己的实例变量，也不能执行类的实例的方法。类对象是一个功能完整的对象，也能被动态识别（dynamically typed），接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量），只是在运行时产生实例的代理。类对象是元类对象的一个实例，元类是根元类(root class’s metaclass)的实例,而根元类是其自身的实例，即根元类的isa指针指向自身。 一个消息发送给任何一个对象， 方法的检查 从对象的 isa 指针开始，然后是父类。实例方法在类中定义， 类方法 在元类和根类中定义。（根类的元类就是根类自己）。类对象(class object)中包含了类的实例变量、实例方法的定义，而元类对象(metaclass object)中包括了类的类方法的定义。类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。 ①object_getClass跟随实例的isa指针，返回此实例所属的类，对于实例对象(instance)返回的是类(class),对于类(class)则返回的是元类(metaclass),②- class方法对于实例对象(instance)会返回类(class),但对于类(class)则不会返回元类(metaclass),而只会返回类本身。③class_isMetaClass可判断某类是否为元类.④使用objc_allocateClassPair可在运行时创建新的类与元类对，使用class_addMethod和class_addIvar可向类中增加方法和实例变量，最后使用objc_registerClassPair注册后，就可以使用此类了。 alloc方法通过alloc或allocWithZone方法创建对象时， cocoa会遍历该对象所有的成员变量，通过成员变量的类型来计算所需占用的内存返回一个未”初使化“过的对象。 将该新对象的引用计数(Retain Count)设置成1。 该新对象的isa成员变量指向它的类对象。 将该新对象的所有其它成员变量的值设置成零。（根据成员变量类型的不同，零有可能是指nil或0） 返回指向该对象的一个指针。 init方法大部分情况下，我们都不希望所有成员变量都是零，所以①init方法做初使化工作，让对象的成员变量的值符合我们程序逻辑中的初始化状态。②返回真正可以使用的指向该对象的指针某些情况下，init会造成alloc的原本空间不够用，而进行第二次分配内存空间。所以下面的写法是错的： NSString *s=[NSString alloc]; [s init];// 这儿init返回的地址可能会变。s原本的指针地址可能是无效的地址。 正确的写法是NSString *s=[[NSString alloc] init];new简单地等价于 alloc + init，但不能指定init的参数，很少用。NSInteger是一个有符号型int，它与int的区别就在于NSInteger可以自动识别机器是32位还是64位。NSInteger的无符号版本是NSUInteger。 运行时消息只有到运行时才会和函数实现绑定起来，而不是按照编译好的逻辑一成不变的执行。编译阶段只是确定了要去向receiver对象发送message消息，但是却没有发送，真正发送是等到运行的时候进行。NSObject 类定义了description方法,返回该类内容的字符串表示。某些 NSObject 的方法只是简单地从运行时系统中获得信息,从而允许对象进行一定程度的自我检查。例如,class 返回对象的类;isKindOfClass:和 isMemberOfClass:则检查对象是否在指定的 类继承体系中;respondsToSelector:检查对象能否响应指定的消息;conformsToProtocol: 检查对象是否实现了指定协议类的方法;methodForSelector:则返回指定方法实现的地址。 ①message（消息）message 是一种抽象，包括了函数名+参数列表，并没有实际的实体存在。②method（方法）method是真正的存在的代码。如：- (int)meaning { return 42; }③selector（方法选择器）selector 通过SEL类型存在，描述一个特定的method 或者说 message。在实际编程中，可以通过selector进行检索方法等操作。 方法选择器它是一个char *指针，仅仅表示它所代表的方法名字。 typedef struct objc_selector *SEL; SEL selector = @selector(message); //@selector不是函数调用，只是给编译器的一个提示 NSLog (@&quot;%s&quot;, (char *)selector); //print message Objective-C在编译的时候，会根据方法的名字，生成一个用来区分这个方法的唯一的一个ID，这个ID就是SEL类型的（生成唯一的SEL）。只要方法的名字相同，那么它们的ID都是相同的。编译器会根据每个方法的方法名为那个方法生成唯一的SEL，这些SEL组成了一个Set集合，这个Set简单的说就是一个经过了优化过的hash表。SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，从而加快方法的查询速度。 IMPtypedef id (*IMP)(id, SEL, ...);由于每个方法都对应唯一的SEL，可以通过SEL方便、快速、准确的获得它所对应的IMP（也就是函数指针），而在取得了函数指针之后，也就意味着取得了执行这段方法的代码的入口，这样就可以像普通的C语言函数调用一样使用这个函数指针。 void (* performMessage)(id,SEL);//定义一个IMP（函数指针） performMessage = (void (*)(id,SEL)) [self methodForSelector:@selector(message)]; //通过methodForSelector方法根据SEL获取对应的函数指针 performMessage(self,@selector(message)); //通过取到的IMP（函数指针）跳过runtime消息传递机制，直接执行message方法。 用IMP 的方式，省去了runtime消息传递过程中所做的一系列动作，比直接向对象发送消息高效一些。 消息调用流程消息表达式[receiver message]在被转换成objc_msgSend(receiver, SEL)后，在运行时，runtime system会做以下事情： 1、检查忽略的Selector（比如将会忽略retain和release消息）。 2、检查receiver是否为nil。（如果receiver为空，则会将 selector也设置为空，并且直接返回到消息调用的地方。）如果对象非空，就继续下一步。 3、根据SEL到当前类中查找对应的IMP，首先会在cache中检索它，如果找到了就根据函数指针跳转到这个函数执行，否则进行下一步。 4、检索当前类对象中的方法表（method list），如果找到了，加入cache中，并且就跳转到这个函数执行，否则进行下一步。 5、从父类中寻找,直到根类：NSObject类。找到了就将方法加入对应类的cache表中，如果仍未找到，则要进入动态方法决议。 6、如果动态方法决议仍不能解决问题，只能进行最后一次尝试，进入消息转发流程。 注意：cache的原则就是缓存那些可能要执行的函数地址，下次调用的时候，速度就可以快速很多。 类方法和实例方法中，都可以访问self和_cmd这两个属性，因为它们都不属于类的实例变量，而是形参。objc_msgSend找到方法对应的实现时,将直接调用该方法实现,并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:接收消息的对象（也就是self指向的内容），方法选标（_cmd指向的内容） ”隐藏“：因为它们并没有在定义方法的源代码中声明,而是在代码编译时是插入方法的实现中的。在方法中可以通过 self 来引用消息接收者对象,通过选标_cmd 来引用方法本身。 - (void)message { self.name = @&quot;James&quot;;//通过self关键字给当前对象的属性赋值 SEL currentSel = _cmd;//通过_cmd关键字取到当前函数对应的SEL NSLog(@&quot;currentSel is :%s&quot;,(char *)currentSel); } 当被调用的方法实现部分没有找到，而消息转发机制启动之前的这个中间时刻(动态添加方法)。+(BOOL) resolveInstanceMethod:(SEL) sel将被调用。这是NSObject根类提供的类方法。 @dynamic关键字的作用:①告诉编译器不要创建实现属性所用的实例变量；②告诉编译器不要创建该属性的get和setter方法。让编译器相信存取方法会在运行时找到。 // 声明文件中 @property(nonatomic,retain) NSString *name; // 实现文件中 @dynamic name; 变量默认情况下，编译器会为当前类自动生成一个NSString _name的实例变量（如果想改变实例变量的名称可以用@synthesize关键字），同时会生成两个名为` - (NSString )name和- (void)setName:(NSString *)aName`的存取方法。 void dynamicMethodIMP(id self, SEL _cmd) { // implementation .... } + (BOOL)resolveInstanceMethod:(SEL)sel { NSLog(@&quot;sel is %@&quot;, NSStringFromSelector(sel)); if(sel == @selector(setName:)){ class_addMethod([self class],sel,(IMP)dynamicMethodIMP,&quot;v@:&quot;); return YES; } return [super resolveInstanceMethod:sel]; } 消息转发外部调用的某个方法对象没有实现，而且resolveInstanceMethod方法中也没有做重定向处理时，就会触发- (void)forwardInvocation:(NSInvocation *)anInvocation方法。这个方法通常用来将不能处理的消息转发给其它的对象。 -(void)forwardInvocation:(NSInvocation *)invocation { SEL invSEL = invocation.selector; if ([someOtherObject respondsToSelector:invSEL]) [anInvocation invokeWithTarget:someOtherObject]; } else { [self doesNotRecognizeSelector:invSEL]; } } Cocoa它是一个面向对象的软件组件——类的集成套件，它使开发者可以快速创建强壮和全功能的 Mac OS X （IOS）应用程序。Cocoa包含了很多框架，其中最最核心的是Foundation框架和Application Kit（AppKit）框架（Cocoa Touch中叫UIKit框架）。 imageNamed的优点在于可以缓存已经加载的图片。这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回.imageWithContentsOfFile方法只是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到程序。当不需要重用该图像，或者需要将图像以数据方式存储到数据库，又或者要通过网络下载一个很大的图像时，可以使用这种方式。 run loop它是为了线程而生,是线程的基础架构部分，每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。主线程的run loop默认是启动的。UIApplicationMain()函数，会为main thread设置一个NSRunLoop对象.NSRunLoop类并不是线程安全的,不能在一个线程中去操作另外一个线程的run loop对象,CFRunLoopRef是线程安全的.获取到当前线程的run loop:[NSRunLoop currentRunLoop];获取对应的CFRunLoopRef类- (CFRunLoopRef)getCFRunLoop;一个run loop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。对消息处理过程进行了更好的抽象和封装，在NSRunLoop中每一个消息就被打包在input source或者是timer source中了。使用run loop可以使线程在有工作的时候工作，没有工作的时候休眠，这可以大大节省系统资源。创建输入源的时候，需要将其分配给run loop中的一个或多个模式.定时源在预设的时间点同步方式传递消息，这些消息都会发生在特定时间或者重复的时间间隔。定时源则直接传递消息给处理例程，不会立即退出run loop。 创建NSTimer// 方式一:自动把timer加入MainRunloop的NSDefaultRunLoopMode中 NSTimer *timer = [NSTimer scheduledTimerWithTimeInteral:1.0 target:self selector:@selector(action:) userInfo:ni] repeat:NO]; // 停止 [timer invalidate]; // 方式二(需手动加到run loop中) NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self seletor:@selector(timerAction) userInfo:nil repeats:YES]; [[NSRunloop mainRunloop] addTimer:timer forMode:NSDefaultRunloopMode]; 特点:调用创建方法后,target对象的引用计数会+1,直到执行完毕,自动-1.如果RunLoop正在执行一个连续的运算,timer就会被延迟触发 响应者对象（Responder Object）指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。 响应者链通常是由视图（UIView）构成的； 一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）； 视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图； 单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者. 单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent: 方法的处理流程首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；若返回NO,则hitTest:withEvent:返回nil;若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。 非正式协议通常定义为NSObject的类别。 类别与类扩展的区别：①类别中只能增加方法；②类扩展不仅可以增加方法，还可以增加实例变量（或者合成属性），只是该实例变量默认是@private类型的；③类扩展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中。④类扩展所声明的方法必须依托对应类的实现部分来实现。⑤定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。 KVC全称是Key-value coding，翻译成键值编码。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。KVO全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。KVO机制很适合实现model和controller类之间的通讯。KVC是不会自动调用键值验证方法的，我们需要手动验证。- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;KVC可以自动的将数值或结构体型的数据打包或解包成NSNumber或NSValue对象，以达到适配的目的。代码片段存放路径~/Library/Developer/Xcode/UserData/CodeSnippetsARC的英文全名是：Automatic Reference Counting，是编译器提供的管理Objective-C对象内存的一个机制。它并不是像垃圾回收机制那样，有一个负责内存回收的系统，而是仍然以引用计数为基础：在编译阶段，编译器会在需要retain或release对象的地方自动为我们加上对应的代码。 内存管理规则一个Object-C对象存在strong类型的指针指向时，该对象就不会被释放。①strong该属性值对应 __strong关键字，即该属性所声明的指针变量将成为对象的持有者。strong是指向Objective-C对象指针的默认属性。②weak该属性对应__weak关键字，与__weak定义的变量一致，该属性所声明的变量将没有对象的所有权，并且当对象被破弃之后，对象将被自动赋值nil。④copy也是对象的所有者，与strong的区别是声明的指针变量是拷贝对象的持有者。⑤assign一般数值型变量用该属性声明，比如,int, BOOL，但无需显示写出，因为数值型变量的默认属性类型就是assign 使用关键字声明指针类型规范写法: //规范的写法 MyClass * __weak myWeakReference; weak和assign的异同相同点：指向的对象都是随时有可能被释放，即不拥有指向的对象不同点：①weak只能用来声明Objective-C对象，assign既可以用来声明对象，也可以用来声明数值型变量；②很关键的一点区别，当一个weak关键字声明的指针指向的对象被释放掉得时候，该指针会自动的被指向nil而assign不存在该特性. 使用@property声明或作为普通实例变量声明的指向Objective-C对象的指针属性默认都是strong；而使用@property声明的数值型变量属性默认的是assign，普通的数值型变量的属性是__unsafe_unretaind。 属性 关键字 所有权 strong __strong 有 copy __strong 有 retain __strong 有 weak __weak 无 assign __unsafe_unretained 无 unsafe_unretained __unsafe_unretained 无 使用ARC需要遵守的新规则①不要在dealloc方法中调用[super dealloc];②不能使用 retain/release/retainCount/autorelease③不能使用 NSAllocateObject/NSDeallocateObject④不能使用 NSZone⑤Objective-C 对象不能作为C语言结构体（struct/union）的成员 instancetype表示某个方法返回的未知类型的Objective-C对象,instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型,能够确定对象的类型.有利于开发者在编译阶段发现错误。关联返回类型（related result types）1、类方法中，以alloc或new开头2、实例方法中，以autorelease，init，retain或self开头.instancetype和id的异同: 1、相同点:都可以作为方法的返回类型2、不同点①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；②instancetype只能作为返回值，不能像id那样作为参数 沙盒目录：1、MyApp.app存放应用程序本身的数据,整个目录是只读的,不能被iTunes同步2、Documents存放不可再生的的数据文件,会被iTunes同步.3、Library存放默认设置或其它状态信息。除了Caches子目录外,会被iTunes同步.4、Library/Caches存放缓存文件，保存那些可再生的文件,不会被iTunes同步5、Library/Preferences存放应用程序的偏好设置文件。我们使用NSUserDefaults写的设置数据都会保存到该目录下的一个plist文件中，会被iTunes同步6、tmp存放各种临时文件,不会被iTunes同步 runtime采用散列表来管理引用计数,统一存储所有对象的引用计数,不用考虑每个对象内存块中引用计数所占的内存,在引用计数表中存储各个对象的内存地址.NULL本质上是：(void)0,表示C指针为空,如`charchar string = NULL; nil本质上是：(void *)0,表示指向Objective-C中对象的指针为空 Nil本质上也是：(void *)0,表示Objective-C中Class类型的变量值为空,Class anyClass = Nil; ` NSNull是一个Objective-C类,该类通常用于在集合对象中保存一个空的占位对象 // 遇到nil截断 NSArray *arr = [NSArray arrayWithObjects:@&quot;wang&quot;,@&quot;zz&quot;,nil,@&quot;foogry&quot;]; // 存储空的占位对象 NSArray *arr = [NSArray arrayWithObjects:@&quot;wang&quot;,@&quot;zz&quot;,[NSNull null],@&quot;foogry&quot;]; 向作者致谢!王中周的个人博客:http://blog.csdn.net/wzzvictory]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读博客之笔记一]]></title>
    <url>%2F2016%2F10%2F28%2F%E8%AF%BB%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[2017.4.3 修改2016.12.4 修改 C语言方面。 读感这次零零碎碎花了一周时间拜读李明杰老师的博客,很多知识点理解地更透彻了,尤其是C语言方面的.不太熟悉或将近遗忘的知识点记录下来,做复习巩固之用.起初使用笔记的方式记录,但是达不到我想要的效果,于是尝试以问答的形式记录,而且以后的笔记也采用这种方式 钩玄1.C语言中怎么控制输入与输出格式printf("My height is %8.1f", 179.95f);// 左对齐,小数点后1位 printf("My height is %-4d", 60); // 左对齐，右边填空格scanf("%d-%d-%d", &amp;a, &amp;b, &amp;c);scanf("%d %d %d", &amp;a, &amp;b, &amp;c);// putchar一次只能输出一个字符，而printf可以同时输出多个字符int a = 65;putchar(a); 2.getchar/scanf/gets的区别1.gets和getchar函数可以读入空格、TAB，直到遇到回车为止。scanf则不能读入空格和TAB。 2.gets一次只能读取一个字符串,getchar一次只能读入一个字符。scanf则可以同时接收多个字符。 3.getchar还能读入回车换行符，这时候要敲2次回车键。第1次敲的回车换行符被getchar读入，第2次敲的回车键代表输入结束。 3.puts/prints/putchar的区别1.putchar一次只能输出一个字符,puts函数一次只能输出一个字符串，printf函数则可以同时输出多个字符串 2.printf与puts函数会首地址开始输出字符，一直到\0字符为止。 4.介绍指针1.计算机中的内存是以字节为单位的存储空间,内存的每一个字节都有一个唯一的编号，这个编号就称为地址.2.凡存放在内存中的程序和数据都有一个地址，也就是说，一个函数也有自己的内存地址。变量存储单元的第一个字节的地址就是该变量的地址.3.通过变量名引用变量，由系统自动完成变量名和其存储地址之间的转换，称为变量的”直接引用”方式.首先将变量a的地址存放在另一个变量中，比如存放在变量b中，然后通过变量b来间接引用变量a，间接读写变量a的值。这就是”间接引用”. 4.在指针变量没有指向确定地址之前，不要对它所指的内容赋值。int *p; *p = 10; //这是错误的// 正确做法int a = 10;// 也可以int *b = &amp;a;int *b; //b是指针变量b = &amp;a;// 通过*b间接修改a的值*b = 15; // 根据b地址访问对应的存储值 5.指针操作中,数组名a是个常量,不能进行赋值运算 char s[10]; s = &quot;mj&quot;;// 错误! s是常量 5.常见字符串处理函数的用法包含string.h头文件后,strlen\strcpy\strcat\strcmp函数的用法// 测量字符串的字符个数，不包括\0// 长度为7int size = strlen("abcdefg");// 长度为2char s[] = &#123;'a', 'b', '\0','c'&#125;; // 右边拷贝到左边,char s[10];strcpy(s, "abcdefg");// 遇到\0截断char c[] = &#123;'a', 'b', '\0','c'&#125;;strcpy(s,c);// 结果ab// 右边拼接到左边,遇到\0截断char s1[30] = &#123;'a', 'b', '\0', 'd'&#125;;strcat(s1, "OC");// 结果abOC// 左减右,逐字符比较ASCII码差值,直到字符不相同或者遇见'\0'为止strcmp(s1, s2); 注意:strcpy中若数组长度不足以容纳整个字符串，则程序运行崩溃 6.如何使一个函数有多个返回值int test(int a, int b,int *c) &#123; // 赋值给指针指向的变量 *c = a + b; return a * b;&#125;int main(int argc, const char * argv[]) &#123; int m = 2,n = 4,s1,s2; s1 = test(m, n, &amp;s2); printf("%d---%d",s1,s2); return 0;&#125; 7.字符串常量与字符串变量char *s = &quot;mj&quot;;3 *s = &quot;like&quot;;两个错误:1,s指向的是”mj”的首字符’m’,只有一个字节,要”like”存进1个字节的空间内，肯定内存溢出.2,s指向的是字符串常量”mj”,不能再通过指针来修改字符串内容(字符数组可以修改). char a[] = &quot;lmj&quot;;定义的是一个字符串变量 char *p2 = &quot;lmj&quot;;定义的是一个字符串常量 8.返回指针的函数 // 将字符串str中的小写字母变成大写字母，并返回改变后的字符串 // 注意的是：这里的参数要传字符串变量，不能传字符串常量 char * upper(char *str) &#123; // 先保留最初的地址。因为等会str指向的位置会变来变去的。 char *dest = str; // 如果还不是空字符 while (*str != '\0') &#123; // 如果是小写字母 if (*str &gt;= 'a' &amp;&amp; *str &lt;= 'z') &#123; // 变为大写字母。小写和大写字母的ASCII值有个固定的差值 *str -= 'a' - 'A'; &#125; // 遍历下一个字符 str++; &#125; // 返回字符串 return dest;&#125; // 调用: int main() &#123; // 定义一个字符串变量 char str[] = "lmj"; // 调用函数 char *dest = upper(str); printf("%s", dest); return 0; &#125; 9.指向函数的指针函数名的本质就是函数的地址.假定函数名为func,返回一个整型int *a = func; // 指针a与指针func一致 调用的三种方式:func(); // 原先的调用方式:通过指针func调用*a(); // *a指向函数本身a(); // 相当于func(); 实例: int sum(int a, int b) &#123; return a + b;&#125;int main()&#123; // 定义一个指针变量p，指向sum函数 // 把函数名替换为(*p)即可,*p就相当于sum int (*p)(int a, int b) = sum; // 或者 int (*p)(int, int) = sum; // 或者 int (*p)() = sum; // *p就相当于sum int result = (*p)(1, 3); // 或者 int result = p(1, 3); printf("%d", result); return 0;&#125; 10.将函数作为参数在函数间传递// 减法运算int minus(int a, int b) &#123; return a - b;&#125; // 加法运算int sum(int a, int b) &#123; return a + b;&#125; // 这个counting函数是用来做a和b之间的计算，至于做加法还是减法运算，由函数的第1个参数决定void counting( int (*p)(int, int) , int a, int b) &#123; int result = p(a, b); printf("计算结果为：%d\n", result);&#125; int main()&#123; // 进行加法运算,传进来函数指针sum counting(sum, 6, 4); // 进行减法运算 counting(minus, 6, 4); return 0;&#125; 11.宏的使用1.所有预处理指令都以符号”#”开头，并且结尾不用分号,作用范围是从它出现的位置到文件尾,主要有：宏定义、文件包含、条件编译. 2.使用带参数的宏定义,最好将参数和结果都用括号括起来. 3.宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题,宏替换只在编译预处理阶段进行,带参数的宏比函数具有更高的执行效率. 4.条件编译#if 条件1 ...code1...#elif 条件2 ...code2...#else ...code3...#endif#if defined(MAX) ...code...#endif#if !defined(MAX) ...code...#endif 12.include中&lt;&gt;与””的区别#include &lt;文件名&gt;到C语言库函数头文件所在的目录中寻找文件#include &quot;文件名&quot;系统会先在源程序当前目录下寻找，若找不到，再到操作系统的path路径中查找，最后才到C语言库函数头文件所在目录中查找. 13.如何避免#include重复包含同一个头文件使用条件编译#ifndef _ONE_H_#define _ONE_H_ void one(); #endif 14.变量的作用域1.在函数内部定义的变量，称为局部变量。形式参数也属于局部变量,在所有函数外部定义的变量，称为全局变量. 2.所有的局部变量在默认情况下都是自动变量,是存储在堆栈中的.所有的全局变量和被关键字static修饰的局部变量都是静态变量,是存储在静态内存中的，也就是不属于堆栈. 3.静态变量在程序运行之前创建，在程序的整个运行期间始终存在，直到程序结束。在程序执行到声明自动变量的代码块(函数)时，自动变量才被创建；当自动变量所在的代码块(函数)执行完毕后，这些自动变量就会自行销毁. 4.被关键字register修饰的自动变量都是寄存器变量,是存储在硬件寄存器中的,其生命周期即是自动变量的生命周期.寄存器变量只限于int、char和指针类型变量使用,将一些频繁使用的自动变量定义为寄存器变量，这样程序尽可能地为它分配寄存器存放，而不用内存. register int a;register char b;register int *c; 15.编译链接流程1.如果一个程序中有多个源文件(.c)，编译成功会生成对应的多个目标文件(.obj)，这些目标文件不能单独运行，因为这些目标文件之间可能会有关联。将这些相关联的目标文件链接在一起后才能生成可执行文件。 2.所谓编译，就是单独检查每个源文件的语法是否合理，并不会检查每个源文件之间的关联关系，一个源文件编译成功就生成一个目标文件。所谓链接，就是检查目标文件的关联关系，将相关联的目标文件组合在一起，生成可执行文件。 3.根据在当前文件中定义的函数是否允许其他文件访问,可将函数分为内部函数和外部函数.默认情况下，所有的函数都是外部函数,不允许重复定义同一个外部函数. 16.extern与static关键字的作用使用extern关键字，表示引用其他文件的”外部函数”: extern void test();,然而extern可以省略,故直接声明即可.正规的项目里面，把”外部函数”的声明另写到一个头文件中,使用时直接包含头文件即可. 在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数),不允许其他文件访问.不同的文件中有同名的内部函数，则互不干扰。 默认情况下，一个函数不可以访问在它后面定义的全局变量.不同源文件中的同名全局变量代表着同一个变量 // a文件int ss =10; // b文件extern int ss ;printf("%d", ss);// 是10 在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰 17.如何定义结构体定义结构体的三种形式(枚举变量的定义与之类似) struct Student &#123; char *name; int age;&#125;;// 利用上面结构体定义结构体变量stustruct Student stu;// 直接定义结构体变量stustruct Student &#123; char *name; int age;&#125; stu;// 定义结构体变量stu后,此结构体永不再用struct &#123; char *name; int age;&#125; stu;// 特殊:struct前放置typedef表示声明此"匿名"结构体的名字为Studenttypedef struct &#123; char *name; int age;&#125; Student; 注意:1.定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间 2.将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参. 18.结构体指针的使用结构体指针变量的定义形式：struct 结构体名称 *指针变量名,三种访问方式: 结构体变量名.成员名 (*指针变量名).成员名 指针变量名-&gt;成员名 19.typedef的主要使用1.typedef给指针起别名:// 相当于char *str = "This is a string!";String str = "This is a string!"; 2.typedef给结构体起别名struct CGRect &#123;CGPoint origin;CGSize size;&#125;;typedef struct CGRect CGRect;// 为 struct CGRect 起别名叫作 CGRect 3.typedef给指向结构体的指针起别名 #include &lt;stdio.h&gt;// 定义一个结构体并起别名typedef struct &#123; float x; float y;&#125; Point;// 给Point *起别名PPtypedef Point *PP;int main(int argc, const char * argv[]) &#123; // 定义结构体变量 Point point = &#123;10, 20&#125;; // 定义指针变量Point *p = &amp;point; PP p = &amp;point; // 利用指针变量访问结构体成员 printf("x=%f，y=%f", p-&gt;x, p-&gt;y); return 0; &#125; 4.typedef与枚举类型// 定义枚举类型 enum Season &#123;spring, summer, autumn, winter&#125;; // 给枚举类型enum Season起别名为Season typedef enum Season Season; int main(int argc, const char * argv[]) &#123; // 定义枚举变量 Season s = spring; return 0; &#125; 5.typedef给指向函数的指针类型起别名#include &lt;stdio.h&gt;// 定义一个sum函数，计算a跟b的和int sum(int a, int b) &#123; int c = a + b; printf("%d + %d = %d", a, b, c); return c;&#125;typedef int (*MySum)(int, int);int main(int argc, const char * argv[]) &#123; // 定义一个指向sum函数的指针变量p MySum p = sum; // 利用指针变量p调用sum函数 (*p)(4, 5); return 0; &#125; 6.typedef与#define,给类型起别名，最好使用typedef，而不是使用#define. typedef char *String1;#define String2 char *// 相当于char *str1;char *str2;String1 str1, str2;// 相当于char *str3;char str4;产生误会String2 str3, str4; 20.import与include的区别 #import是一个预处理指令，作用跟C语言的#include类似，都是 包含(拷贝)某个文件的内容 到 预处理指令所在的位置。在OC中，使用#import来包含头文件，可以自动防止同一个头文件被包含多次。#import &lt;...&gt;表示包含系统自带的文件，#import &quot;...&quot;表示包含开发人员自己创建的文件. 21.UIView显示的过程UIView之所以能显示在屏幕上，完全是因为它内部的一个层(CALayer对象)。当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了UIView的显示。当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法. 22.position与anchorPointposition可以用来设置CALayer在父层中的位置，它是以父层的左上角为坐标原点(0, 0);anchorPoint称为”定位点”，它决定着CALayer身上的哪个点会在position属性所指的位置。它的x、y取值范围都是0~1，默认值为(0.5, 0.5). 23.Core Animation会阻塞主线程吗Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程,而且是直接作用在CALayer上的，并非UIView. 24.空指针没有存储任何内存地址的指针就称为空指针(NULL指针,指向nil),空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。可以给空指针发送消息,但消息发送不出去.”野指针”不是NULL指针，是指向”垃圾”内存（不可用内存）的指针. 25.不同编译器下各类型所占字节 向作者致谢!M了个J:http://www.cnblogs.com/mjios/ 参考博客C语言中文网:http://c.biancheng.net/cpp/html/88.html]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言交换两个数值的八种方法]]></title>
    <url>%2F2016%2F10%2F23%2FC%E8%AF%AD%E8%A8%80%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%80%BC%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在回顾C语言的时候,偶遇此题,因曾被其深虐,特意搜寻多种解决办法,以鞭笞岁月。 编译器:XCode8.0 异或int main(int argc, const char * argv[]) &#123; int m = 5, n = 3; m = m ^ n; n = m ^ n; m = m ^ n; printf("m:%d---n:%d",m,n); return 0;&#125; 异或一般是针对二进制数. 两数异或,相同则得0,不同则得1 x ^ x = 0,x ^ 0 = x第二行: m:0101 n:0011第三行: m:0110 n:0011第四行: n:0101 m:0110第五行: m:0011 n:0101此时,已完成交换. 运算符int main(int argc, const char * argv[]) { int m = 2147483648, n = 2147483647; m = m + n - (n = m); printf(&quot;m:%d---n:%d&quot;,m,n); return 0; } 从左向右依次进行,首先获取m与n的和,接着利用()运算符直接将m的值赋予n,此时n完成交换 同时()内的值是m的值,两数之和减去m值便是n的值,再将n的值赋予m,到这里m完成交换 位运算int main(int argc, const char * argv[]) { int m = 5, n = 3; n = (long)((long)m &lt;&lt; 32 | (m = n)) &gt;&gt; 32; printf(&quot;m:%d---n:%d&quot;,m,n); return 0; } 注:__int64表示64位整型变量,Xcode中用long代替,VC6.0可直接使用__int64,即: b = (__int64)((__int64)a &lt;&lt; 32 | (a = b)) &gt;&gt; 32； (m = n):完成m的交换,()的值是n (long)((long)m &lt;&lt; 32 | n):得到的结果是 00...0 0101 00...0 11第一部分28个0,第三部分30个0 ((long)((long)m &lt;&lt; 32 ) &gt;&gt; 32:得到的结果:把第三第四部分去掉,即00...0 0101 正好32位,且此值为m的值,再将其赋予n,完成n的交换. 宏定义#define swap(x, y, z) ((z) = (x), (x) = (y), (y) = (z)) int main(int argc, const char * argv[]) { int m = 5, n = 3,t = 0; swap(m, n, t); printf(&quot;m:%d---n:%d&quot;,m,n); return 0; } 比较巧妙,把中间变量放在宏中. 两数之和int main(int argc, char *argv[]) { int m = 5, n = 3; m = m + n; n = m - n; m = m - n; printf(&quot;m:%d---n:%d&quot;,m,n); return 0; } 算是一种数学方法吧,但可能溢出. 两数之积int main(int argc, const char * argv[]) { int m = 5, n = 3; m = m * n; n = m / n; m = m / n; printf(&quot;m:%d---n:%d&quot;,m,n); return 0; } 两数之和方法的变形,n不能为0,m更可能溢出. 经典的交换函数void swap(int *a, int *b) { int temp = 0; temp = *a; *a = *b; *b = temp; } int main(int argc, const char * argv[]) { int m = 2147483648, n = 2147483647; swap(&amp;m,&amp;n); printf(&quot;m:%d---n:%d&quot;,m,n); return 0; } 直接添加变量int main(int argc, const char * argv[]) { int m = 2147483648, n = 2147483647,temp = 0; temp = m; m = n; n = temp; printf(&quot;m:%d---n:%d&quot;,m,n); return 0; } 知识int最大值，根据编译器类型不同而变化。1 对于16位编译器，int占16位(2字节)。int的最大值为32767.2 对于32位和64位编译器，int占32位(4字节)。int的最大值为2147483647 3 可以通过打印sizeof(int)查看平台对应的int占用字节数。乘8后即为位数。最高位为符号位，如位数为n，则最大值为2^(n-1)即2的n-1次幂。 printf(&quot;%lu&quot;,sizeof(int)); int a = 2147483648; 参考并致谢:http://blog.csdn.net/ljx_5489464/article/details/50042571http://kiya.space/2013/07/26/c%E8%AF%AD%E8%A8%80swap(a,b)%E5%80%BC%E4%BA%A4%E6%8D%A2%E7%9A%844%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E2%80%A6/http://www.itdadao.com/articles/c15a428576p0.htmlhttp://www.cnblogs.com/kubixuesheng/p/4104800.htmlhttps://www.byvoid.com/blog/c-int64]]></content>
      <categories>
        <category>ios开发</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods的安装与使用]]></title>
    <url>%2F2016%2F10%2F10%2FCocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CocoaPods是非常好用的第三方库管理工具。 升级Gemsudo gem update --system 切换CocoaPods的数据源# 1.删除 gem sources --remove https://rubygems.org/ # 2.添加淘宝数据源 gem sources -a https://ruby.taobao.org/ # 3.查看 gem sources -l 安装CocoaPodssudo gem install CocoaPods 或者（如10.11系统） sudo gem install -n /usr/local/bin CocoaPods 报错解决Error installing pods:activesupport requires Ruby version &gt;= 2.2.2 解决方式: 安装 RVMcurl -L get.rvm.io | bash -s stable 等待。 source ~/.bashrc source ~/.bash_profile 测试是否安装成功。 rvm -v 用RVM升级Ruby# 1.查看当前ruby版本 ruby -v # 显示 ruby 1.8.7 # 2.列出已知的ruby版本 rvm list known # 3.安装ruby 2.3 rvm install 2.3 安装完成之后ruby -v查看是否安装成功。 更换托管地址 将Podspec文件托管地址从github切换到国内的oschina或者coding。 注意:如果pod setup 可以将github的代码下载得动，那就不用去更换托管地址了。 # 1.先移除 pod repo remove master # 2.再添加 pod repo add master https://git.coding.net/CocoaPods/Specs.git # 3.再更新 pod repo update 设置pod仓库(初始化CocoaPods)pod setup # 会将Specs.git的代码下载到~/.CocoaPods/repo/master,自己前往查看是否有文件 # 如果还是太慢，尝试下 pod install --verbose 报错解决[!] To setup the master specs repo, please run `pod setup`. 手动下载代码解决: # 1.手动克隆文件至该目录 git clone https://git.coding.net/CocoaPods/Specs.git ~/.CocoaPods/repos/master # 2.初始化,完成后显示Setup completed pod setup 测试# 如果有版本号，则说明已经pod安装成功 pod --version # 如果~/.CocoaPods/repo/master目录下有文件,说明文件下载成功 使用介绍利用CocoaPods来安装第三方框架 进入要安装框架的项目的.xcodeproj同级文件夹 在该文件夹中新建一个文件podfile 在文件中告诉CocoaPods需要安装的框架信息 a.该框架支持的平台b.适用的iOS版本c.框架的名称d.框架的版本 Podfile文件格式platform :ios, &apos;9.0&apos; target &apos;你的项目名称&apos; do pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos; end 创建Podfile文件进入.xcodeproj同级文件夹下 # 初始化:会生成模板的Podfile文件 pod init # 或者手动创建Podfile文件 touch Podfile 添加自己需要的第三方库pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos; # If you are using Swift, be sure to add use_frameworks! and set your target to iOS 8+: pod &apos;SDWebImage&apos;, &apos;~&gt;3.8&apos; use_frameworks! pod &apos;Masonry&apos; pod &apos;MBProgressHUD&apos;, &apos;~&gt; 1.0.0&apos; pod &apos;MJExtension&apos; pod &apos;MJRefresh&apos; pod &apos;SVProgressHUD&apos; 开始安装pod install --verbose --no-repo-update # 显示 # Pod installation complete! There is 1 dependency from the Podfile and 1 total pod installed. Start!以后打开项目点击xcworksapce后缀的文件，不要点击原来的项目文件。导入头文件应该使用: #import &lt;&lt;#header#&gt;&gt; 说明platform :ios, ‘9.0’ 用来设置所有第三方库所支持的iOS最低版本pod ‘SDWebImage’,’~&gt;2.6’ 设置框架的名称和版本号 版本号的规则：‘&gt;1.0’ 可以安装任何高于1.0的版本‘&gt;=1.0’ 可以安装任何高于或等于1.0的版本‘&lt;1.0’ 任何低于1.0的版本‘&lt;=1.0’ 任何低于或等于1.0的版本‘~&gt;0.1’ 任何高于或等于0.1的版本，但是不包含高于1.0的版本‘~&gt;0’ 任何版本，相当于不指定版本，默认采用最新版本号 pod install过程 分析依赖:该步骤会分析Podfile,查看不同类库之间的依赖情况。如果有多个类库依赖于同一个类库，但是依赖于不同的版本，那么CocoaPods会自动设置一个兼容的版本。 下载依赖:根据分析依赖的结果，下载指定版本的类库到本地项目中。 生成Pods项目：创建一个Pods项目专门用来编译和管理第三方框架，CocoaPods会将所需的框架，库等内容添加到项目中，并且进行相应的配置。 整合Pods项目：将Pods和项目整合到一个工作空间中，并且设置文件链接。 补充Mac显示隐藏的文件 defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder Mac取消显示隐藏文件 defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder 参考并致谢:http://blog.csdn.net/lissdy/article/details/9191351http://www.cnblogs.com/yan520/p/5583362.htmlhttp://www.jianshu.com/p/32d9cfb91471]]></content>
      <categories>
        <category>ios开发</category>
      </categories>
      <tags>
        <tag>ios开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C学习笔记四：分类与代理]]></title>
    <url>%2F2016%2F05%2F30%2FObjective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9A%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[2016.10.16更正部分错别字 一些琐碎的笔记,关于分类、代理和block。 分类场合：在不修改原来类模型的情况下，给类扩充一些方法，且仅是方法，不扩充成员变量。可以给系统自带的类添加分类，扩充方法。（注意引入分类文件）当添加分类的方法是重写原来类中的方法时,不需要引入分类文件。声明文件的命名方式 【类+分类.h】 @interface 类名 (分类名) @end 实现文件的命名方式 【类+分类.m】 @implementation 类名 (分类名) @end 特征：用括号括住添加的分类好处：一个庞大的类可以分模块开发、由多个人编写，有利于团队合作。 注意点1，分类可以访问原来类中的成员变量，但不能增加成员变量。（若要增加成员变量，可以使用继承） 2，分类的优先级最高，当调用类中的一个方法时，优先去分类中查找，再去原类中查找，最后去父类中查找。也即，倘若在分类中重写了原类中的方法，会覆盖掉原来的方法，导致原来的方法无法使用。（不建议重写原来类中的方法）重写会出现警告：Category is implementing a method which will also be implemented by its primary class. 3，如果多个分类中有相同（方法签名相同，但不一样）的方法，则调用的是最后编译的方法。 类的私有方法 方式1，直接在.m文件中写方法实现，不要在.h文件中进行方法声明 方式2，在.m文件中定义一个category，然后在category中声明一些方法，最后在@implementation和@end之间作方法实现。 类的本质类也是一个对象，是Class类型的对象，简称类对象，类对象就是类。class类型的定义:typedef struct objc_class *Class;类名代表着类对象，每个类只有一个类对象。 +load在程序启动的时候，就会加载所有的类和分类，并调用一次所有类和分类的+load方法； 先加载父类，再加载子类，也即先调用父类的+load方法，再调用子类的+load方法; 先加载原始类，再加载分类（顺序也即父类——父类的分类——子类）。 不管程序运行过程中有没有用到这个类，都会调用+load加载。 +initialize在第一次使用某个类时（比如创建对象），就会调用一次+initialize方法一个类只会调用一次+initialize方法，先调用父类的，再调用子类的获取类对象的两种方式 Class c = [Person class];//类方法 或者 Person *p = [Person new]; Class c = [p class];//对象方法 很明显，[p class]和[Person class]方法返回的都是是class类型类对象调用类方法： Class c=[Person class]; Person *p2=[c new]; description方法类似其他语言的ToString方法，NSObject自带的方法。返回值类型是NSString ＊默认情况下，使用NSLog和%@打印一个对象，输出的是&lt;类名:内存地址&gt;如：&lt;Person: 0x1002070a0&gt;而NSLog(@”%@”,p)会调用-description方法 -description方法使用NSLog和%@输出某个对象时，会调用对象的-description方法 +description方法使用NSLog和%@输出某个类对象时，会调用类对象的+description方法 可以重写+description和-description方法修改NSLog的默认输出注意：如果在-description方法中使用NSLog打印self，会造成死循环。 // 重写-description方法 -(NSString *)description { return [NSString stringWithFormat:@”%@”, self]; } 编译无警告，无报错，运行出错。真正重写：假设属性为 // 重写-description方法 -(NSString *)description { return [NSString stringWithFormat:@”姓名：%@ 年龄：%d”, _name,_age]; } SEL每个类的方法列表都存储在类对象中,每个方法都有一个与之对应的SEL类型的对象根据一个SEL对象就可以找到方法的地址，进而调用方法SEL类型定义 typedef struct objc_selector *SEL; SEL对象的创建： SEL s=@selector(test); SEL s2=NSSelectorFromString(@”test”); 将SEL对象转换为NSString对象 NSString *s3=NSStringFromSelector(s); 调用对象p的show方法： // 创建p对象 Person *p=[[Person alloc] init]; // 将show方法封装为SEL类型数据的s SEL s=@selector(show); // 调用s间接调用show方法 [p performSelector:s]; [p test]原理解释 把test包装成SEL类型的数据 根据SEL数据找到对应的方法地址 根据方法地址调用相应的方法消息就是SEL。 NSLog方法总结 打印对象的内存地址 NSLog(@”%p”,p); 打印指针的内存地址（&amp;p取出地址） NSLog(@”%p”,&amp;p); 打印某一对象（默认返回类名+内存地址，可以通过重写-description方法改变输出内容） NSLog(@”%@”,p); 打印代码行号 NSLog(@”%d”,__LINE__); 打印文件路径 NSLog(@”%d”,__FILE__); 注意：如果文件路径中存在中文，则无法输出这时可以使用： printf(“%s\n”__FILE__);输出包含中文字符的路径（\n只是为了观看清晰） 打印当前函数名称 NSLog(@”%s”,__func__); 代理 一系列方法的列表（不能增加成员变量）。其中声明的方法可以被任何类实现，这种模式一般称作代理（delegation）。如果一些类之间没有继承的关系，但是有某些相同的行为，这时要考虑使用代理。代理的定义：当一代理只针对某个类中，代理最好放在一个类的.h文件中，使用时引入即可。（假定在Person.h文件中） #import &lt;Foundation/Foundation.h&gt; @interface Person : NSObject @end // 要在@interface之外设置代理 @protocol MyProtocol &lt;NSObject&gt; // 必须实现的方法 @required -(void)show; -(void)myShow; // 可选实现的方法 @optional +(void)herShow; @end 在Dog.h文件中遵守协议： #import &lt;Foundation/Foundation.h&gt; // 声明协议@protocol MyProtocol; @protocol MyProtocol; @interface Dog : NSObject&lt;MyProtocol&gt; // 遵守某个协议 // 注意导入协议文件#import &quot;Person.h&quot;或者声明协议@protocol MyProtocol; -(void)show; -(void)myShow; @end 当某一代理用在多个类中，协议需要放在单独创建的.h文件中此时创建的只有一个名为BigProtocol的.h文件。 #import &lt;Foundation/Foundation.h&gt; @protocol BigProtocol &lt;NSObject&gt; @required -(void)bigShow; @optional -(void)bigShow2; @end 在Cat.h文件中遵守协议 #import &lt;Foundation/Foundation.h&gt; //@protocol BigProtocol; #import &quot;BigProtocol.h&quot; @interface Cat : NSObject&lt;BigProtocol&gt; -(void)bigShow; @end 在Dog.h文件中遵守协议 #import &lt;Foundation/Foundation.h&gt; //@protocol BigProtocol; #import &quot;BigProtocol.h&quot; @interface _Dog : NSObject&lt;BigProtocol&gt; -(void)bigShow; -(void)bigShow2; @end 注意点 在遵守协议时，如果使用@protocol BigProtocol;编译器会警告：无法找到协议的定义而使用#import “BigProtocol.h“，则完全没有问题。 如果某个类遵守多个协议，协议之间用逗号分隔： @interface Cat : NSObject&lt;BigProtocol,MyProtocol&gt; 一个协议本身可以遵守其他协议，如遵守名字叫NSObject的协议（默认是这种情况，基协议NSObject）如果A协议遵守B协议，这时A协议就能拥有B协议的所有方法声明。 @protocol BigProtocol &lt;NSObject&gt; @end BigProtocol拥有NSObject协议的所有方法声明。 约定框架中后缀为Delegate的都是协议。（协议类似其他语言的接口，就像C#中默认以I开头的都是接口 ） 要求某个对象必须遵守某个协议（如要求obj保存的对象遵守协议MyProtocol，并且继承Person） Person&lt;MyProtocol&gt; *obj=[[Person alloc] init]; 利用conformsToProtocol:判断某个类是否实现了某个协议 Cat *c=[[Cat alloc] init ]; bool result= [c conformsToProtocol:@protocol(BigProtocol)]; NSLog(@&quot;%@&quot;,result?@&quot;YES&quot;:@&quot;NO&quot;); [c conformsToProtocol:@protocol(BigProtocol)];返回的是bool类型。 block块。有返回值（void也可以）、有形参。block封装了一段代码，可以在任何时候执行。block可以作为函数参数或者函数返回值，而其本身又可以带输入参数和返回值。在多线程，异步任务，集合遍历，集合排序，动画专场使用较多。 定义返回值类型 (^+block名称)(参数类型列表)=^(参数列表){ 代码内容 }; 注意大括号后面有分号 对比函数 int (^MySum)(int ,int )=^(int a,int b){ return a+b;}; int MySum (int a,int b){return a+b;} block可以访问局部变量，但不能更改局部变量。如果更改则报错：Variable is not assignable (missing__block type specifier)，如： int c=10; // Block的定义 int (^MySum)(int ,int )=^(int a,int b) { c=21; return a+b+c; }; NSLog(@&quot;%i&quot;,MySum(10,20)); 如果硬是要修改：在局部变量前面加上__block ，如 __block int c=21;这时，便可以在block中修改局部变量了。 __block int c=10; // Block的定义 int (^MySum)(int ,int )=^(int a,int b) { c=21; return a+b+c; }; NSLog(@&quot;%i&quot;,MySum(10,20)); 4 . block的调用，和函数一样，使用名称即可：MySum(_形参列表); 5 . 如果block没有形参，则可以省略等号后面的()如： int (^SomeSum)()=^{return 25;}; 但是等号前面的两对括号不可省略。 6 . 利用typedef声明类型 格式：typedef 返回值类型 (^block块名称)(参数_类型列表) 例如：typedef int (^MyBlock)(int,int); 以后就可以用MyBlock这种类型定义Block变量 MyBlock m=^(int a,int b){return a+b;}; int c=m(15,25); NSLog(@”%i”,c);]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C学习笔记三：点语法与自动属性]]></title>
    <url>%2F2016%2F05%2F18%2FObjective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E7%82%B9%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[2016.10.16更正部分错别字2016.05.24更正@private相关错误 点语法和自动属性的一些笔记。 点语法本质是方法调用，不访问成员变量。前提是已经存在get和set方法(否则报错：Property ‘age’ not found on object of type ‘Person *’)。 [p setAge:50]; int result=[p age]; NSLog(@”result的结果是：%i”,result); 相当于： p.age=50; int result=p.age; NSLog(@”result的结果是：%i”,result); 注意：此处的result未必等于50，因为在set方法中，age的值可能改变。 方法的展开原理：[p setAge : 50]; 对应 p . age= 50; 而int result=[p age]; 对应int result=p . age; 死循环1，set方法中 -(void)setAge:(int)a { self.age=a; } 实际上是在set方法中调用set方法。 -(int)age { return self.age; } 在get方法中调用get方法。以上编译链接均无警告、无错误，但是运行会报错。 成员变量的作用域@private私有。只能在当前类的对象方法中直接访问（当前类的对象方法的@implementation中访问），子类虽然继承（内存中存在），但无权限访问（感觉貌似没有继承，一层网给过滤掉。 @protected保护（默认是保护，不是私有）。可以在当前类和子类的对象方法中直接访问（当前类和子类的@implementation中访问）。假设父类Person有保护的成员变量_number，子类继承，什么变量都不增加，那么子类对象方法中访问的是父类的_number。 -(void)show { self-&gt;_number=1000; int result=self-&gt;_number; _number=5000; int result2= _number; NSLog(@”self-&gt;_number的值是：%i”,result); NSLog(@”_number的值是：%i”,result2); } @public公开。任何地方都可以访问。一般用不到。 @package同一个框架内可以访问，介于@public和@private之间。 注意点1,在类方法中不可能访问成员变量。2,也可以在@implementation中声明成员变量。 @implementation Student:NSObject { @public int age; @private int number; @protected int no; } @end 然而.m文件一般不会被包含，也即一般没有必要访问，故而一般不把成员变量放在实现文件中。 @property和@synthesize属性合成@property用在@interface中，代替get和set方法如：@property int age;等价于 -(int)age; -(void)setAge:(int)age; 即便是@property int _age;那也会生成 -(int)_age; -(void)setAge:(int)_age; 而@synthesize用在@implementation实现中：@synthesize age=成员变量名; 不允许对成员变量进行条件过滤，如@synthesize age=_age+100; @synthesize age=_age; 等价于 -(int)age { return _age; } -(void)setAge:(int)age { _age=age; } 总结 1，如果.h文件中没有这个_age成员变量。那么，利用@property可以自动生成私有@private的_age。而默认的_age却是@protected的。 2，@synthesize age将会访问age这个成员变量而非_age。 3，若手动实现getter方法，编译器只会自动生成setter方法；若手动实现setter方法，编译器只会自动生成getter方法。 新特性@property已经独揽@synthesize的实现了，也即 @synthesize age=_age;可以省略。只用写@property int age就好了。（当然，前提是不对参数进行过滤，直接传到成员变量中，如果要过滤，还是要自己生成相应的方法。） 4，默认情况下，getter和setter方法中的实现会访问下划线开头的成员变量。 id相当于NSObject * ，是万能指针。 id类型的定义typedef struct objc_object { Class isa; }*id; 构造方法用来初始化对象的方法，完整地创建一个可用对象。 Person *p=[Person alloc];+alloc方法分配存储空间，返回对象。 p=[p init];-init方法初始化 init方法的重写目的：在对象创建完毕之后，使成员变量就有了一些默认的值。注意：一定要先调用父类的构造方法，再进行子类内部成员变量的初始化在@implementation中进行重写： -(id)init { // 一定要先调用super的init方法，这是为了初始化父类的一些成员变量和其他属性 self=[super init]; // 判断对象是否初始化成功，如果对象初始化成功，再进行接下来的自定义初始化 if(self!=nil) { _age=10086; } // 返回一个已经初始化完毕的对象 return self; } 上面代码不够简化，一般用下面代码。 -(id)init { // 简化版 if([super init]) { _age=10086; } return self; } 自定义构造方法要求：是对象方法（对象的初始化），返回值是id类型，方法名以initWith开头。注意：-init方法重写不需要在@interface中声明，因为已经声明过了，而自定义的构造方法需要在@interface中显式声明。 // 声明 -(id)initWithAge:(int)age; // 实现 -(id)initWithAge:(int)age { if([super init]) { _age=age+100; } return self; } 调用示例： Person *p=[Person alloc]; p=[p init]; int r=p.age; NSLog(@”r的值是%i”,r); p= [p initWithAge:110]; int r2=p.age; NSLog(@”r2的值是%i”,r2); 显而易见一个对象可以初始化多次。 含有多个参数的构造方法：-(id)initWithAge:(int)age andNumber:(int)number; .h文件和.m文件每个类分布在不同的文件中类的声明放在.h文件中，类的实现放在.m文件中若想使用某个类，就包含某个类的.h文件即可。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C学习笔记二：继承与属性]]></title>
    <url>%2F2016%2F05%2F16%2FObjective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[2016.10.25 修改 关于继承与属性的笔记。 封装优点：过滤不合理的值，屏蔽内部的赋值过程，让外界不必关注内部的细节。 成员变量的命名：以下划线开头。用于区分get方法名称和局部变量名称。尽量不设置为@public公有属性 { int _speed; } set方法：设置成员变量，过滤一些不符合要求的值。以set开头，返回类型为void，后面跟上成员变量名，形参不与成员变量重名，形参类型与成员变量相同，成员变量的首字母大写。在set方法中设置行为，监听属性的改变。 -(void)setSpeed:(int)s; -(void)setSpeed:(int)s { _speed=s+20; } get方法：获取对象内部的成员变量，不接收参数，返回类型与成员变量类型相同，方法名称与成员变量名称相同（不含下划线）。不推荐以get开头。 -(int)speed; -(int)speed { return _speed; } 只读：只提供get方法。可读可写：提供get和set方法。 OC的弱语法调用未声明、未实现的对象方法编译 报错 No visible @interface for ‘Dog’ declares the selector ‘ssss’，链接运行 报错。 reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1002014a0’ 给Dog对象发送不能识别的消息。 调用已声明、未实现的对象方法编译警告：Method definition for ‘ssss’ not found 未实现方法 链接正常，运行报错 reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1001002a0’ 调用未声明、已实现的对象方法编译 链接运行 错误 No visible @interface for ‘Dog’ declares the selector ‘ssss’ 在Dog的@interface中，对于ssss的声明是不可见的。 类方法类本身在内存中占据存储空间，里面有类\对象方法列表。直接通过类名执行的方法。 以+开头，只能由类名调用，类方法中不能访问成员变量（实例变量）。允许类方法与对象方法重名。(执行者不同，当然可以重名！) 使用场合：当不需要访问成员变量的时候，尽量使用类方法，提升效率。 输出类的名称： +(void)showClassName; +(void)showClassName { NSLog(@”类的名称是：%@”,NSStringFromClass([self class])); } 调用：[Dog showClassName]; self关键字self是指针，指向当前对象或类的调用者。出现在对象方法中，代表当前对象，出现在类方法中，代表当前类。不能出现在函数中（会报错：Use of undeclared identifier ‘self’使用未声明的标识符）。 用途： self-&gt;成员变量名 在对象方法中访问当前方法调用的成员变量，也即当成员变量与局部变量同名时，用来区分同名的局部变量。 -(void)showSelfOfObject; -(void)showSelfOfObject { NSLog(@”showSelfOfObject方法被调用”); int _speed; self-&gt;_speed=200; _speed+=1000; int result= self-&gt;_speed+10; NSLog(@”result的值是：%i”,result); NSLog(@”_speed的值是：%i”,_speed); } 当成员变量与局部变量同名时（编译警告Local declaration of ‘_speed’ hides the instance variable局部变量隐藏了成员变量），采用就近原则，访问局部变量。因此需要用self访问成员变量。 方法的调用:在对象方法中调用当前对象的对象方法以及在类方法中调用当前类的类方法 在对象方法中调用当前对象的对象方法 -(void)showSelfOfObject; -(void)showTestObject; -(void)showSelfOfObject { NSLog(@”showSelfOfObject方法被调用”); } -(void)showTestObject { [self showSelfOfObject]; } 在类方法中调用当前类的类方法 +(void)showSelfOfClass; +(void)showTestClass; +(void)showSelfOfClass { NSLog(@”showSelfOfClass方法被调用”); } +(void)showTestClass { [self showSelfOfClass]; } 常见错误： 在对象方法中调用类方法（编译错误No visible @interface for ‘Dog’ declares the selector ‘showSelfOfClass‘）错误相当于未声明未定义却调用这个方法。 在类方法中调用对象方法（编译错误No known class method for selector ‘showSelfOfObject‘）未知的类方法 3，self的死循环:调用本身 -(void)showSelfOfObject { NSLog(@”showSelfOfObject方法被调用”); [self showSelfOfObject]; } 4，调用函数 函数不依赖对象。void f(); [self f] 错误 继承场景：当两个类拥有相同的属性和方法时，将相同的内容抽取到父类中。当A类完全拥有B类的部分属性或方法时，考虑A类作为父类。 父类必须声明在子类前面。 不允许子类和父类拥有相同的成员变量（如果子类有和父类拥有相同的成员变量，意味着，同一成员变量声明定义两次，编译错误 Duplicute member ‘_age’，哪怕成员变量的访问属性不同，子类公开父类私有，或者父类公开子类私有，都不行！） 子类方法和属性的访问过程：如果子类没有，再访问父类。即由子类开始。 Objective-C中只有单继承（与C＋＋不同） 方法的重写:父类和子类拥有相同签名的类方法或者对象方法（子类重新实现了父类中的方法），则优先调用子类的同名方法。 父类Person： -(void)show { NSLog(@”调用了Person的show方法”); } 子类Student： -(void)show { //[super show]; NSLog(@”调用了Student的show方法”); } 调用： Student *p=[[Student alloc] init]; [p show]; 很明显，调用的是重写的子类Student的show方法。 super场景：子类重写父类的方法时，想调用父类的方法（包括类方法和对象方法）。 效果与self类似，super在对象方法中就调用父类的对象方法，在类方法中就调用父类的类方法。 继承可以在不改变原来模型的基础上拓充方法，抽取公共代码，建立类与类之间的联系，减少代码的冗余性，但是，会增加耦合性。 多态某一种事物的多种形态。在实现继承的前提下，父类类型指针指向子类对象（右边是左边），指向子类对象的父类指针可以调用子类中重写父类的方法，但是指向子类对象的父类指针不能调用子类中拓展的方法（父类中没有的方法）。 Person *p=[[Student alloc] init]; [p show]; Student是Person，show方法在子类和父类中都有，这里调用的是子类的show方法。 当子类拓展了一个showStudent对象方法，如果还想调用，则强制转换：将指向子类对象的父类指针强制转化为子类指针。 Person *p=[[Student alloc] init]; Student p2=(Student )p; [p2 showStudent]; 将父类指针p强制转换为子类指针，使它可以调用子类Student拓展的showStudent方法。 如果不做强制转换，而直接调用子类拓展的方法 Person *p=[[Student alloc] init]; [p showStudent]; 编译报错： No visible @interface for ‘Person’ declares the selector ‘showStudent’ 转换语法： { 相应子类名 p=(父类名 )指向子类对象的父类指针；} 主要应用：动态绑定如果参数使用父类类型，可以传入父类、子类对象，调用相应的方法（如将子类对象传递给参数，调用子类的方法；将父类对象传递给参数，则调用父类的方法） 例如，Person和Student中都有同名show对象方法，可以通过test函数传入的参数判断调用哪个方法。 #import &lt;Foundation/Foundation.h&gt; #import “Person.h” #import “Student.h” void test(Person * p) { [p show]; } int main(int argc, const char * argv[]) { @autoreleasepool { Person *p=[[Person alloc] init]; Student *s=[[Student alloc] init]; test(p); test(s); } return 0; } NSString的使用 创建字符串与输出字符串 NSString *s=@”Sometimes”; NSLog(@”%@”,s); 格式化字符串 int age=85; NSString *s=[NSString stringWithFormat:@”传入的年龄参数是%d”,age]; NSLog(@”%@”,s); 调用NSString类方法。length返回字数（不是字符数） NSString *s=@”123 456”; NSLog(@”%@”,s); NSUInteger size=[s length]; NSLog(@”%lu”,(unsigned long)size); 返回的是7，包括空格。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C学习笔记一：类]]></title>
    <url>%2F2016%2F05%2F12%2FObjective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[2016.10.28 修改 万物皆是对象。 类的设计三要素：事物名称（类名）；属性；行为（功能） 具有相同（或者类似）属性和行为的对象可以抽象出一个类。 类的声明类名1，首字母大写；2，不能有下划线；3，多个英文单词，使用驼峰标识 行为哪个对象最清楚行为怎么做，就把行为设计在哪个对象身上 @interface Person : NSObject { @public int _age; bool _sex; } -(void)print; @end 大括号内用来声明对象属性（成员变量也即实例变量）,@public让外界指针可以间接访问对象内部的成员变量。成员变量默认会初始化为0. : NSObject（继承基类）使声明的类具有创建对象的能力。 类的实现@implementation Person -(void)print { NSLog(@”输出内容”); } @end 已经导入声明文件#import “Person.h”类的实现即方法的实现。 创建对象Person *p=[[Person alloc] init]; [p print]; 对象的本质是结构体，对象需要通过指针操纵。 类在内存中也占据存储空间，在创建对象之前为类分配一份内存空间，将类加载进内存。而且只存储方法列表，其中由类产生的对象，都有一个isa指针指向类。 方法调用：[行为执行者 行为名称]; [Person new]执行Person这个类的new行为创建对象，返回对象地址。 Person *p=[Person new];定义一个Person 类型的指针变量p，指向Person类型的对象。指针的类型是Person *，指针指向的类型是Person。 [p print];表示给p指向的对象发送一条print消息。 Person p=[Person new];等价于 Person p;p=[Person new];另外Person *p2=p;表示p2、p指向同一个内容。p=p2:将p2存储的指针交给p，使p存储的也是p2存储的内容。 方法与函数的区别以及注意 OC方法只能声明在@interface和@end之间，只能实现在@implementation和@end之间。也就是说OC方法不能独立于类存在 C函数不属于类，跟类没有联系，C函数只归定义函数的文件所有 C函数不能访问OC对象的成员 对象方法归类／对象所有，函数属于整个文件所有，任何地方都可以放置函数（如果放在@interface与@end之间，将会忽略掉函数，即未定义） 方法只有声明，没有实现（经典错误） 方法没有声明，只有实现（编译器警告，但是能调用，OC的弱语法） 编译的时候：访问没有的成员变量直接报错，访问没有的方法，只是警告 同一个类中不允许两个对象方法同名 匿名对象属性访问 [Car new]-&gt;speed = 200; 方法调用[ [Car new] run]; 对象方法不带参数的对象方法： -(void)print; 方法名print 带一个参数的对象方法： -(void)print:(int) a; 方法名print : 带多个参数的对象方法： -(void)print:(int) a WithOther:(int) b;方法名 print : WithOther: 枚举typedef enum｛ SexMan, SexWoman ｝Sex; 结构体typedef struct{ int year; int month; int day; } Date; 访问枚举：s-&gt;sex=SexMan; 访问结构体：s-&gt;birthday.year=2016; 定义结构体： Date d={2016,4,30}; 访问结构体： s-&gt;birthday.year=2016; s-&gt;birthday.month=4; s-&gt;birthday.day=16; 等价于： Date d={2016,4,16}; s-&gt;birthday=d; 注意 打印函数中注意％与%的区别 定义枚举、结构体等必需放在@interface的前面方可使用 OC方法中一个参数一个冒号 对象中有对象 @interface Student : NSObject { @public //狗 Dog *dog; } -(void)letDogRun { [dog run]; } // main.m文件 Student *stu=[Student new]; Dog *dog=[Dog new]; stu-&gt;dog=dog; [stu letDogRun];]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛谈单链表的插入与删除]]></title>
    <url>%2F2015%2F11%2F04%2F%E6%B3%9B%E8%B0%88%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[简单探讨单链表的插入与删除。 其实单链表也是比较有意思的，可惜我弄了好久才些微明白些。在顺序表中，一个数组就将近定义一个结构，但在单链表中，却又要和指针扯上关系了。 定义： typedef struct LNode{ int data; struct LNode next; }LNode; 江湖传言LNode *p等价于LinkList p，不知道有木有人认同呢？ #include&lt;stdio.h&gt; #include&lt;malloc.h&gt; //定义并初始化单链表 typedef struct LNode{ int data; struct LNode *next; }LNode; //单链表的创建与初始化，设定共n个节点（不含头节点） void CreateLinkList(LNode a,int n) { LNode p,q; p=a; while(n–){ q=(LNode )malloc(sizeof(LNode *)); scanf(“%d”,&amp;q-&gt;data); q-&gt;next=NULL; p-&gt;next=q; p=q; } } //查找是否存在一个值为x的节点，若存在，删之，并返回OK，否则返回NOT FOUND char SearchAndDelete(LNode c,int x){ LNode p,q; p=c; //开始查找 while(p-&gt;next!=NULL) { if(p-&gt;next-&gt;data==x) break; p=p-&gt;next; } //若找到则开始删除 if(p-&gt;next==NULL) return “NOT FOUND”; else { q=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; free(q); return “OK”; } } //在链表c中第n个节点位置插入元素e void Insert(LNode c,int n,int e){ LNode p=( LNode )malloc(sizeof(LNode )), q=( LNode )malloc(sizeof(LNode ));//插入的节点 p=c; q-&gt;data=e; //找到要插入节点的位置 for(int i=1;i&lt;n;i++){ p=p-&gt;next; } //插入节点 q-&gt;next=p-&gt;next; p-&gt;next=q; } //打印单链表 void Print(LNode a){ LNode p=( LNode )malloc(sizeof(LNode *)); p=a-&gt;next; while(p!=NULL){ printf(“%d\n”,p-&gt;data); p=p-&gt;next; } } int main(){ LNode a=( LNode )malloc(sizeof(LNode *)); CreateLinkList(a,5); Insert(a,3,10086);//假定在第3个位置插入数值为10086的节点 Print(a); printf(“—————-\n”); SearchAndDelete(a,13);//查找并执行删除数值为13的节点 Print(a); return 0; } 说明如下： 1，假定输入的是11 12 13 14 15五个数值。在第三个位置（13的位置）插入一个数据域为10086的节点。此时原来的数值已经变成了11 12 10086 13 14 15 2，完事后，我为了方便不再另写代码，在11 12 10086 13 14 15的基础上假定查找并删除数据域为13的节点。 当然还有值得体会的是，把节点的内存分配放在主函数里. 像这样： LNode a=( LNode )malloc(sizeof(LNode *)); 当然，清晰一点就是 LNode a; a=( LNode )malloc(sizeof(LNode *)); 两者效果一样。 void Print(LNode *a){ } 和 void Print(LNode &amp;a){ a=( LNode )malloc(sizeof(LNode *)); } 这才是重点，和小伙伴研究一下，决定采取有违伦理惨无人道的第一种方式。最后在主函数中再调用malloc觉得还是蛮灵活轻便的。 当然，上面的代码不是为了解题，只是提供一个思路，具体可视情况修改。]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[泛谈顺序表的插入与删除]]></title>
    <url>%2F2015%2F11%2F02%2F%E6%B3%9B%E8%B0%88%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[简单探讨顺序表的插入与删除。 所谓的顺序表，在严版的书中，定义的异常专业巧妙。存储空间基址、当前长度、分配的存储容量，这三部分融合而成线性表之顺序表。 typedef struct{ Elemtype *elem; int length; int listsize; }SqList; 翻翻资料。发现还有一种更巧妙而且容易理解的方式： typedef struct{ int data[Max]; int length; }SqList; 这样一来，整个顺序表就与数组特别特别相似啦。 那么，声明一个很长很长但是彼此知道的Max长度数组，作为默认“表长”（其实不是表长），再给它一个长度length，如此，顺序表横空出世了。 既然如此，那关于什么插入、删除操作就不在话下了。 1 已知顺序表的所有元素值（自行输入），在元素e的位置插入元素m 题目很清楚，插入元素m后，后面的元素自然往后移动啦。 #include&lt;stdio.h&gt; //#include&lt;malloc.h&gt; //#include&lt;stdlib.h&gt; //一般这两个是需要的 #define Max 200 //定义并初始化顺序表 typedef struct{ int data[Max]; int length=10; }SqList; //顺序表l中查找元素e的位置 int LocatElem(SqList l,int e){ int i=0; for(;i&lt;l.length;++i) if(l.data[i]==e) return i+1; } //在元素e的位置插入元素m void Insert(SqList &amp;l,int e,int m) { int i=l.length,p=LocatElem(l,e); for(;i&gt;=p;–i){ l.data[i]=l.data[i-1]; } l.data[i]=m; l.length++; } int main(){ int i=0,e=18,m=200; SqList a; for(;i&lt;a.length;++i) scanf(“%d”,&amp;a.data[i]); Insert(a,e,m); for(int i=0;i&lt;a.length;++i) printf(“%d\n”,a.data[i]); return 0; } 这里假设我们输入从11，12一直到20的整数值，首先查找元素e=18的值的位置，插入m的值200。 原来：11 12 13 14 15 16 17 18 19 20 run后：11 12 13 14 15 16 17 200 18 19 20 2 已知顺序表所有元素的值（自行输入），删除顺序表中值为e的元素 #include&lt;stdio.h&gt; //#include&lt;malloc.h&gt; //#include&lt;stdlib.h&gt; #define Max 200 //定义并初始化顺序表 typedef struct{ int data[Max]; int length=10; }SqList; //顺序表l中查找元素e的位置 int LocatElem(SqList l,int e){ int i=0; for(;i&lt;l.length;++i) if(l.data[i]==e) return i+1; } //删除顺序表中值为e的元素 void Delete(SqList &amp;l,int e){ int i=LocatElem(l,e); for(;i&lt;=l.length;++i) l.data[i-1]=l.data[i]; l.length–; } int main(){ int i=0, e=15;//e的值自己说了算 SqList a; for(;i&lt;a.length;++i) scanf(“%d”,&amp;a.data[i]); Delete(a,e); for(int i=0;i&lt;a.length;++i) printf(“%d\n”,a.data[i]); return 0; } 改动不大，添加个函数而已。这里删除的是15，具体题目具体分析。 原来：11 12 13 14 15 16 17 18 19 20 run后：11 12 13 14 16 17 18 19 20]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
  </entry>
</search>
