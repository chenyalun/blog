<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[iOS学习笔记一：UIView与UIButton]]></title>
      <url>http://yoursite.com/2016/07/28/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9AUIView%E4%B8%8EUIButton/</url>
      <content type="html"><![CDATA[<h2 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h2><p>UIView:<span class="s1">看到的控件</span></p>
<p>UIViewController<span class="s1">：管理控制界面。</span></p>
<p><span class="s1">一般情况下，每一个</span>“<span class="s1">满屏</span>”<span class="s1">的</span>UIView<span class="s1">都交给对应的</span>UIViewController<span class="s1">管理，</span>UIViewController<span class="s1">内部有个</span>UIView<span class="s1">属性，就是它负责管理</span>UIView<span class="s1">对象。负责创建、销毁自己的</span>UIView<span class="s1">，显示隐藏</span>UIView<span class="s1">，处理</span>UIView<span class="s1">和用户之间的交互（事件处理）。</span>UIViewController<span class="s1">是</span>UIView<span class="s1">的大管家</span></p>
<p><span class="s1">创建一个</span>UIViewController<span class="s1">，再由</span>UIViewController<span class="s1">创建自己的</span>UIview<span class="s1">，最后把</span>UIView<span class="s1">显示到用户眼前。并且由</span>UIViewcontroller<span class="s1">处理</span>UIView<span class="s1">的事件。</span></p>
<p><span class="s1">使方法可被连接：</span>IBAction<span class="s1">相当于</span>void</p>
<p>使属性可被连接：<span class="s2">IBOutlet</span>，能够使属性显示到<span class="s2">storyboard</span>的右击列表中</p>
<p><span class="s3">//<span class="Apple-converted-space">  </span></span>声明两个属性保存文本框</p>
<p>@property<span class="Apple-converted-space">  </span>(nonatomic,weak) IBOutlet UITextField *t1;</p>
<p>注意命名</p>
<pre class="lang:default decode:true ">-(IBAction)btnClick

{

    // 获取成员变量的两种方式

    // 下划线方式  self方式

   // _t1;

   NSString *st1= self.t1.text;

    NSString *st2=self.t2.text;

    int n1=[st1 intValue];

    int n2=[st2 intValue];

    int  r=n1+n2;

    self.l.text=[NSString stringWithFormat:@"%d",r];    

}</pre>

<p>连线的两种方式：</p>
<p><span class="s5">1</span>，<span class="s5">.h</span>文件与<span class="s5">ib</span>控件连线</p>
<p><span class="s5">2</span>，<span class="s5">il</span>中，<span class="s5">viewcontrol</span>与<span class="s5">ib</span>控件相连，将选择控件的事件，直接与<span class="s5">View<span class="Apple-converted-space">  </span>Controler</span>相连，便可以快速看到具备连接能力的属性或方法。<a id="more"></a> </p>
<p><strong>程序启动过程：</strong></p>
<p>1<span class="s6">，加载最主要的</span>storyboard<span class="s6">文件</span></p>
<p><span class="s5">2</span>，创建白色箭头所指的控制器对象</p>
<p><span class="s5">3</span>，创建控制器内部的<span class="s5">view</span>，显示到用户眼前</p>
<p>UIViewController<span class="s1">内部有个</span>UIView<span class="s1">属性，就是它负责管理的</span>UIView<span class="s1">对象：</span></p>
<p>UIView *_view;</p>
<p>@property (monatomic,retain)<span class="Apple-converted-space">  </span>UIView *view;</p>
<h4 id="UIView的常见属性"><a href="#UIView的常见属性" class="headerlink" title="UIView的常见属性"></a><strong>UIView<span class="s7">的常见属性</span></strong></h4><pre class="lang:default decode:true">@property(nullable, nonatomic,readonly) UIView  *superview;获得自己的父控件对象

@property(nonatomic,readonly,copy) NSArray&lt;__kindof UIView *&gt; *subviews;获得自己所有的子控件对象（新添加的子控件会在subviews数组的最后面）

 NSLog(@"%ld个子控件",self.view.subviews.count);

@property(nonatomic)  NSInteger tag;  控件的ID标识，父控件可以通过tag找到对应的子控件，默认为0，尽量保持唯一

@property(nonatomic) CGRect  frame; 描述控件的位置和尺寸，以父控件左上角位置为原点（0，0）

@property(nonatomic) CGRect  bounds; 
与frame的不同是，以控件本身的左上角位置为原点（0，0），因此，默认point为（0，0），只有bounds是以自己左上角为原点，其他都是父控件左上角

@property(nonatomic) CGPoint center; 表示控件中心点的坐标（以父控件左上角为（0，0））

@property(nonatomic) CGAffineTransform transform; 控件的形变属性（可以设置旋转角度、比例缩放、平移等属性）

struct CGAffineTransform {

 CGFloat a, b, c, d;
CGFloat tx, ty;

};</pre>

<p><strong>UIButton<span class="Apple-converted-space">  </span><span class="s4">状态</span></strong></p>
<p>normal <span class="s4">普通（默认）</span></p>
<p>highlight <span class="s4">高亮状态</span><span class="Apple-converted-space">  </span><span class="s4">按下去的时候</span></p>
<p>常见错误：</p>
<p>1<span class="s4">，</span><strong>setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key shuixng.’</strong></p>
<p>删除了已经连接的属性，却没有取消控件中的属性连接线</p>
<p>2<span class="s4">，</span><strong>unrecognized selector sent to instance 0x78633f00</strong></p>
<p>未识别的方法：删除了已经连接的方法，但是没有取消控件中的方法连接线</p>
<p><span class="s3">OC</span>语法中，不允许直接修改<strong><span class="s3"> <span class="Apple-converted-space">  </span></span>某个对象</strong><span class="s3"><span class="Apple-converted-space"><strong> </strong>   </span></span>中结构体属性的成员</p>
<p><span class="s4">报错：</span>Expression is not<span class="Apple-converted-space">  </span>assignable</p>
<p>解决：</p>
<p><span class="s3">OC</span>语法中，不允许直接<span class="Apple-converted-space">  </span>修改<span class="s3"> <span class="Apple-converted-space">  </span></span>某个对象<span class="s3"><span class="Apple-converted-space">    </span></span>中结构体属性的成员。意味着可以直接赋值，可以直接修改成员变量的结构体属性成员</p>
<pre class="lang:default decode:true">   // 取出按钮控件的属性

    CGRect frame=_btn.frame;

    //设置局部变量frame的值

    frame.origin.x-=10;

    // 重新赋值

    _btn.frame=frame;

</pre>
<pre class="lang:default decode:true ">设置动画：

- (IBAction)up:(id)sender {

    // 设置动画：动画开头，参数一般为空。把需要的内容放在开头结尾中间

    [UIView beginAnimations:nil context:nil];

    // 设置动画持续时间，默认0.2秒

    [UIView setAnimationDuration:2.0];</pre>

<p><span class="Apple-converted-space">    </span></p>
<p><span class="Apple-converted-space"> </span>方法二：修改中点实现位置移动</p>
<pre class="lang:default decode:true ">    CGPoint center=_btn.center;

    switch ([sender tag]) {

        case 1:center.y-=krun;break;

        case 2:center.x+=krun;break;

        case 3:center.y+=krun;break;

        case 4:center.x-=krun;break;

        default: break;

    }

    _btn.center=center;</pre>

<p><span class="Apple-converted-space"> </span></p>
<p><strong>代码重构：</strong></p>
<pre class="lang:default decode:true">- (IBAction)run:(id)sender {

    // 设置动画：动画开头，参数一般为空。把需要的内容放在开头结尾中间

    [UIView beginAnimations:nil context:nil];

    // 设置动画持续时间，默认0.2秒

    [UIView setAnimationDuration:1.0];

    // OC语法中，不允许直接修改   某个对象    中结构体属性的成员

    // 取出按钮控件的属性

    CGRect frame=_btn.frame;

    // id类型不允许点语法

    switch ([sender tag]) {

        case 1:frame.origin.y-=krun;break;

        case 2:frame.origin.x+=krun;break;

        case 3:frame.origin.y+=krun;break;

        case 4:frame.origin.x-=krun;break;

        default: break;

    }

    // 重新赋值

    _btn.frame=frame;

    // 动画结尾，提交动画

    [UIView commitAnimations];

}

左旋转动画：

#pragma mark 左旋转

/*

* -  逆时针方向  + 顺时针方向

* 持续旋转方法CGAffineTransformRotate

* 一次设值CGAffineTransformMakeRotation

* M_PI_4是数学宏定义 45°，也即1/4PI弧度

*/

- (IBAction)leftRotate:(id)sender {

    [UIView beginAnimations:nil context:nil];

    [UIView setAnimationDuration:1.0];

    _btn.transform=CGAffineTransformRotate(_btn.transform, -M_PI_4);

       [UIView commitAnimations];

}

放大动画：

/*

* 放大要求倍数大于1，缩小要求倍数小于1

* 持续放大CGAffineTransformScale

* 一次设值CGAffineTransformMakeScale

*/

- (IBAction)big:(id)sender {

    [UIView beginAnimations:nil context:nil];

    [UIView setAnimationDuration:1.0];

    _btn.transform=CGAffineTransformScale(_btn.transform, 1.5, 1.5);

    [UIView commitAnimations];

}

代码重构：

#pragma mark 左右旋转放大缩小

- (IBAction)transfer:(id)sender {

    [UIView beginAnimations:nil context:nil];

    [UIView setAnimationDuration:1.0];

    switch ([sender tag])

    {

        case 1:_btn.transform= CGAffineTransformScale(_btn.transform, 1.5, 1.5);break;

        case 2:_btn.transform= CGAffineTransformScale(_btn.transform, 0.5, 0.5);break;

        case 3 :_btn.transform=CGAffineTransformRotate(_btn.transform, +M_PI_4);break;

        case 4 :_btn.transform=CGAffineTransformRotate(_btn.transform, -M_PI_4);break;

        default:  break;

    }

    [UIView commitAnimations];

}

transform重置

#pragma mark 重置transform

- (IBAction)reset:(id)sender {

    // 将清空对其所作的变换，恢复原始形变属性，位置不能恢复

    [UIView beginAnimations:nil context:nil];

    [UIView setAnimationDuration:1.0  ];

    _btn.transform=CGAffineTransformIdentity;

    [UIView commitAnimations];

}</pre>

<h3 id="使用Block重构代码"><a href="#使用Block重构代码" class="headerlink" title="使用Block重构代码"></a><strong>使用Block<span class="s4">重构代码</span></strong></h3><pre class="lang:default decode:true ">#pragma 代码重构用block调用

-(void)btnClick:(id)sender andBlock: (void (^) ()  )blockArgument

{

    // 开始动画

    [UIView beginAnimations:nil context:nil];

    // 设置动画持续时间

    [UIView setAnimationDuration:1.0];

    blockArgument();

    // 结束动画

    [UIView commitAnimations];

}

#pragma 左右旋转功能的实现

- (IBAction)leftOrRightRotate:(UIButton *)sender

{

    [self btnClick:sender andBlock:^

    {

        CGFloat r=sender.tag==6?M_PI_4:-M_PI_4;

        _photo.transform=CGAffineTransformRotate(_photo.transform, r);

    }

     ] ;

}</pre>

<p><span class="s4">定义参数：要传入的</span>block<span class="s4">名称</span>block <span class="Apple-converted-space">  </span>(void)(^)()blockName</p>
<p><span class="s3"><span class="Apple-converted-space">  </span></span>传入参数：直接封装好的代码块<span class="s3"> ^{}</span></p>
<p><span class="s4">获取某方法的</span>sel<span class="s4">：</span>@selector(<span class="s4">方法名</span>)</p>
<h3 id="通过代码设置控件"><a href="#通过代码设置控件" class="headerlink" title="通过代码设置控件"></a><strong>通过代码设置控件</strong></h3><p><span class="s4">在</span>viewDidLoad <span class="s4">方法中通过代码设置控件</span></p>
<p>代码创建按钮：</p>
<pre class="lang:default decode:true ">- (void)viewDidLoad {

    [super viewDidLoad];

    // Do any additional setup after loading the view, typically from a nib.

    // 创建按钮

    UIButton *btn=[[UIButton alloc]init ];

    btn.frame=CGRectMake(20, 50, 100, 200);

    // 普通状态下的按钮

    [btn setBackgroundImage:[UIImage imageNamed:@"btn_01.png"] forState:UIControlStateNormal];

    [btn setTitle:@"normal" forState:UIControlStateNormal];

    [btn setTitleColor:[UIColor greenColor] forState:UIControlStateNormal];

    // 高亮状态下的按钮

    [btn setBackgroundImage:[UIImage imageNamed:@"btn_02.png"] forState:UIControlStateHighlighted];

    [btn setTitle:@"normal" forState:UIControlStateHighlighted];

    [btn setTitleColor:[UIColor greenColor] forState:UIControlStateHighlighted];

    // 点击事件

    [btn addTarget:self action:@selector(btnClick) forControlEvents:UIControlEventTouchUpInside];

    // 添加按钮控件到view中

    [self.view addSubview:btn];

}

-(void)btnClick

{

    NSLog(@"按钮已被点击");

}

代码创建文本框：

// 创建文本框并设置相关属性

    UITextField *field=[[UITextField alloc]init];

    CGFloat centerX=self.view.frame.size.width*0.5;

    CGFloat centerY=self.view.frame.size.height*0.5;

    field.frame=CGRectMake(centerX, centerY, 100, 50);

    field.font=[UIFont systemFontOfSize:20];

    field.backgroundColor=[UIColor purpleColor];

    // 将文本框添加到view中

    [self.view addSubview:field];</pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C学习笔记三：点语法与自动属性]]></title>
      <url>http://yoursite.com/2016/05/18/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E7%82%B9%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<blockquote>
<p>2016.05.24更正@private相关错误</p>
</blockquote>
<p>### </p>
<h3 id="点语法"><a href="#点语法" class="headerlink" title="点语法"></a>点语法</h3><p>本质是方法调用，不访问成员变量。前提是已经存在get和set方法(否则报错：Property ‘age’ not found on object of type ‘Person *’)。</p>
<p><span class="s1">         [p </span><span class="s2">setAge</span><span class="s1">:</span><span class="s3">50</span><span class="s1">];</span></p>
<p><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">int</span><span class="s1"> result=[p </span><span class="s2">age</span><span class="s1">];</span></p>
<p><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s5">NSLog</span><span class="s1">(</span><span class="s6">@”result的结果是：%i”</span><span class="s1">,result);</span></p>
<p>相当于：</p>
<p><span class="s1">        p.</span><span class="s2">age</span><span class="s1">=</span><span class="s3">50</span><span class="s1">;</span></p>
<p><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">int</span><span class="s1"> result=p.</span><span class="s2">age</span><span class="s1">;</span></p>
<p><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s5">NSLog</span><span class="s1">(</span><span class="s6">@”result的结果是：%i”</span><span class="s1">,result);</span></p>
<p>注意：此处的result未必等于50，因为在set方法中，age的值可能改变。</p>
<h4 id="方法的展开原理："><a href="#方法的展开原理：" class="headerlink" title="方法的展开原理："></a>方法的展开原理：</h4><p><span class="s1"> [p        setAge   :      50];</span></p>
<p>对应</p>
<p><span class="s1">p     .     </span><span class="s2">age</span><span class="s1">=        </span><span class="s3">50</span><span class="s1">;</span></p>
<p>而</p>
<p><span class="s1">int result=[p       age];</span></p>
<p>对应</p>
<p><span class="s2">int</span><span class="s1"> result=p       .       </span><span class="s3">age</span><span class="s1">;</span></p>
<h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>1，set方法中</p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)setAge:(</span><span class="s2">int</span><span class="s1">)a</span></p>
<p><span class="s1">{</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">self</span><span class="s1">.</span><span class="s3">age</span><span class="s1">=a;</span></p>
<p><span class="s1">}</span></p>
<p>实际上是在set方法中调用set方法。</p>
<p><span class="s1">-(</span><span class="s2">int</span><span class="s1">)age</span></p>
<p><span class="s1">{</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s1">return</span> <span class="s1">self</span><span class="s3">.</span><span class="s4">age</span><span class="s3">;</span></p>
<p><span class="s1">}</span></p>
<p>在get方法中调用get方法。</p>
<p>以上编译链接均无警告、无错误，但是运行会报错。<a id="more"></a> </p>
<h3 id="成员变量的作用域"><a href="#成员变量的作用域" class="headerlink" title="成员变量的作用域"></a>成员变量的作用域</h3><p>@private</p>
<p>私有。只能在当前类的对象方法中直接访问（当前类的对象方法的@implementation中访问），子类虽然继承（内存中存在），但无权限访问（感觉貌似没有继承，一层网给过滤掉了，当然，除非再次在子类中声明一个同名的私有成员变量，这时情况就变了,编译器报错  Duplicute member ‘_age’，意味着重复声明）。因此，声明为@private的成员变量，只准当前类的对象方法访问。</p>
<p>@protected</p>
<p>保护（<strong>默认是保护，不是私有</strong>）。可以在当前类和子类的对象方法中直接访问（当前类和子类的@implementation中访问）。</p>
<p>假设父类Person有保护的成员变量_number，子类继承，什么变量都不增加，那么子类对象方法中访问的是父类的_number。</p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)show</span></p>
<p><span class="s1">{</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">self</span><span class="s1">-&gt;</span><span class="s3">_number</span><span class="s1">=</span><span class="s4">1000</span><span class="s1">;</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">int</span><span class="s1"> result=</span><span class="s2">self</span><span class="s1">-&gt;</span><span class="s3">_number</span><span class="s1">;</span></p>
<p><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">_number</span><span class="s5">=</span><span class="s4">5000</span><span class="s5">;</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">int</span><span class="s1"> result2= </span><span class="s3">_number</span><span class="s1">;</span></p>
<p><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s6">NSLog</span><span class="s5">(</span><span class="s1">@”self-&gt;_number的值是：%i”</span><span class="s5">,result);</span></p>
<p><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s6">NSLog</span><span class="s5">(</span><span class="s1">@”_number的值是：%i”</span><span class="s5">,result2);</span></p>
<p><span class="s1">}</span></p>
<p>@public</p>
<p>公开。任何地方都可以访问。一般用不到。</p>
<p>@package</p>
<p>同一个框架内可以访问，介于@public和@private之间。</p>
<p>注意：类方法不可能访问成员变量。也可以在@implementation中声明成员变量。</p>
<p>@implementation Student:NSObject</p>
<p>{</p>
<p>@public int age;</p>
<p>@private int number;</p>
<p>@protected int no;</p>
<p>}</p>
<p>@end</p>
<p><span class="s1">.m</span>文件一般不会被包含，也即一般没有必要访问，故而一般不把成员变量放在实现文件中。</p>
<h3 id="property和-synthesize属性合成"><a href="#property和-synthesize属性合成" class="headerlink" title="@property和@synthesize属性合成"></a>@property和@synthesize属性合成</h3><p>@property用在@interface中，代替get和set方法</p>
<p>如：@property int age;</p>
<p>等价于</p>
<p><span class="s1">-(</span><span class="s2">int</span><span class="s1">)age;</span></p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)setAge:(</span><span class="s2">int</span><span class="s1">)age;</span></p>
<p>即便是@property int _age;那也会生成-(int)_age;-(void)setAge:(int)_age;</p>
<p>而@synthesize用在@implementation实现中：<strong>@synthesize<span class="Apple-converted-space">  </span>age=<span class="s1">成员变量名</span>; 不允许对成员变量进行条件过滤，如<span class="s1">@synthesize</span><span class="s2"> age=</span><span class="s3">_age+100</span><span class="s2">;</span></strong></p>
<p><span class="s1">@synthesize</span><span class="s2"> age=</span><span class="s3">_age</span><span class="s2">;</span></p>
<p>等价于</p>
<p><span class="s1">-(</span><span class="s2">int</span><span class="s1">)age</span></p>
<p><span class="s1">{</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">return</span><span class="s1"> _age;</span></p>
<p><span class="s1">}</span></p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)setAge:(</span><span class="s2">int</span><span class="s1">)age</span></p>
<p><span class="s1">{</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s3">_age</span><span class="s1">=age</span><span class="s1">;</span></p>
<p><span class="s1">}</span></p>
<p>注意：</p>
<p>1，如果.h文件中没有这个_age成员变量。那么，利用@property可以自动生成私有@private的_age。而默认的_age却是@protected的。</p>
<p>2，@synthesize age将会访问age这个成员变量而非_age。</p>
<p>3，若手动实现getter方法，编译器只会自动生成setter方法；若手动实现setter方法，编译器只会自动生成getter方法。</p>
<p>新特性：@property已经独揽@synthesize的实现了，也即</p>
<p><span class="s1">@synthesize age=_age;可以省略。只用写@property int  age就好了。（当然，前提是不对参数进行过滤，直接传到成员变量中，如果要过滤，还是要自己生成相应的方法。）</span></p>
<p><span class="s1">{</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">int</span><span class="s1"> _age;</span></p>
<p><span class="s1">}</span></p>
<p><span class="s1">@property</span> <span class="s1">int</span><span class="s3"> age;</span></p>
<p>完美解决！</p>
<p>另外，默认情况下，getter和setter方法中的实现会访问下划线开头的成员变量。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>相当于NSObject  *  万能指针。</p>
<p>id类型的定义：</p>
<p>typedef struct objc_object {</p>
<p>Class isa;</p>
<p>}*id;</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>用来初始化对象的方法，完整地创建一个可用对象。</p>
<p><span class="s1"><span class="Apple-converted-space">     </span></span><span class="s2">Person</span><span class="s1"> *p=[</span><span class="s2">Person</span> <span class="s3">alloc</span><span class="s1">];            +alloc方法分配存储空间，返回对象。</span></p>
<p><span class="s1"><span class="Apple-converted-space">     </span>p=[p </span><span class="s3">init</span><span class="s1">];                    -init方法初始化</span></p>
<h3 id="init方法的重写"><a href="#init方法的重写" class="headerlink" title="init方法的重写"></a>init方法的重写</h3><p>目的：在对象创建完毕之后，成员变量就有了一些默认的值。</p>
<p>注意：先调用父类的构造方法，再进行子类内部成员变量的初始化</p>
<p>在@implementation中进行重写：</p>
<p><span class="s1">-(</span><span class="s2">id</span><span class="s1">)init</span></p>
<p><span class="s1">{</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s1">// 一定要先调用super的init方法，这是为了初始化父类的一些成员变量和其他属性</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">self</span><span class="s1">=[</span><span class="s2">super</span> <span class="s4">init</span><span class="s1">];</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s1">// 判断对象是否初始化成功，如果对象初始化成功，再进行接下来的自定义初始化</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s1">if</span><span class="s3">(</span><span class="s1">self</span><span class="s3">!=</span><span class="s1">nil</span><span class="s3">)</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span>{</span></p>
<p><span class="s1"><span class="Apple-converted-space">           </span></span><span class="s5">_age</span><span class="s1">=</span><span class="s6">10086</span><span class="s1">;</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s1">// 返回一个已经初始化完毕的对象</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s1">return</span> <span class="s1">self</span><span class="s3">;</span></p>
<p><span class="s1">}</span></p>
<p>上面代码不够简化，一般用下面代码。</p>
<p><span class="s1">-(</span><span class="s2">id</span><span class="s1">)init</span></p>
<p><span class="s1">{</span></p>
<p><span class="s1"><span class="Apple-converted-space">   </span></span><span class="s4"><span class="Apple-converted-space">    </span></span><span class="s1">// 简化版</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">if</span><span class="s1">([</span><span class="s2">super</span> <span class="s5">init</span><span class="s1">])</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span>{</span></p>
<p><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s6">_age</span><span class="s1">=</span><span class="s7">10086</span><span class="s1">;</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p><span class="s4"><span class="Apple-converted-space">    </span></span><span class="s1">return</span> <span class="s1">self</span><span class="s4">;</span></p>
<p><span class="s1">}</span></p>
<h3 id="自定义构造方法"><a href="#自定义构造方法" class="headerlink" title="自定义构造方法"></a>自定义构造方法</h3><p>要求：是对象方法（对象的初始化），返回值是id类型，方法名以initWith开头。</p>
<p>注意：-init方法重写不需要在@interface中声明，因为已经声明过了，而自定义的构造方法需要在@interface中显示声明。</p>
<p><span class="s1">-(</span><span class="s2">id</span><span class="s1">)initWithAge:(</span><span class="s2">int</span><span class="s1">)age;</span></p>
<p><span class="s1">-(</span><span class="s2">id</span><span class="s1">)initWithAge:(</span><span class="s2">int</span><span class="s1">)age</span></p>
<p><span class="s1">{</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">if</span><span class="s1">([</span><span class="s2">super</span> <span class="s3">init</span><span class="s1">])</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span>{</span></p>
<p><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">_age</span><span class="s1">=age+</span><span class="s5">100</span><span class="s1">;</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">return</span> <span class="s1">self</span><span class="s6">;</span></p>
<p><span class="s1">}</span></p>
<p>调用如下：</p>
<p><span class="s2">        Person</span><span class="s1"> *p=[</span><span class="s2">Person</span> <span class="s3">alloc</span><span class="s1">];</span></p>
<p><span class="s2"><span class="Apple-converted-space">        </span>p=[p </span><span class="s3">init</span><span class="s2">];</span></p>
<p><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s4">int</span><span class="s2"> r=p.</span><span class="s5">age</span><span class="s2">;</span></p>
<p><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s3">NSLog</span><span class="s2">(</span><span class="s6">@”r的值是%i”</span><span class="s2">,r);</span></p>
<p><span class="s2"><span class="Apple-converted-space">       </span>p= [p </span><span class="s5">initWithAge</span><span class="s2">:</span><span class="s7">110</span><span class="s2">];</span></p>
<p><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s4">int</span><span class="s2"> r2=p.</span><span class="s5">age</span><span class="s2">;</span></p>
<p><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s3">NSLog</span><span class="s2">(</span><span class="s6">@”r2的值是%i”</span><span class="s2">,r2);</span></p>
<p>说明，可以初始化多次。</p>
<p>多个参数的构造方法也可以：</p>
<p><span class="s1">-(</span><span class="s2">id</span><span class="s1">)initWithAge:(</span><span class="s2">int</span><span class="s1">)age andNumber:(</span><span class="s2">int</span><span class="s1">)number;</span></p>
<h3 id="h和-m文件"><a href="#h和-m文件" class="headerlink" title=".h和.m文件"></a>.h和.m文件</h3><p>每个类分布在不同的文件中</p>
<p>类的声明放在.h文件中，类的实现放在.m文件中</p>
<p><strong>若想使用某个类，就包含某个类的.h文件即可。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C学习笔记二：继承与属性]]></title>
      <url>http://yoursite.com/2016/05/16/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>优点：过滤不合理的值，屏蔽内部的赋值过程，让外界不必关注内部的细节。</p>
<p>成员变量的命名：以下划线开头。用于区分get方法名称和局部变量名称。尽量不设置为@public公有属性。</p>
<p><span class="s1">{</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">int</span><span class="s1"> _speed;</span></p>
<p><span class="s1">}</span></p>
<p><strong>set方法</strong>：设置成员变量，过滤一些不符合要求的值。以set开头，返回类型为void，后面跟上成员变量名，形参不与成员变量重名，形参类型与成员变量相同，成员变量的首字母大写。在set方法中设置行为，监听属性的改变。</p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)setSpeed:(</span><span class="s2">int</span><span class="s1">)s;</span></p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)setSpeed:(</span><span class="s2">int</span><span class="s1">)s</span></p>
<p><span class="s1">{</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s3">_speed</span><span class="s1">=</span><span class="s1">s+</span><span class="s2">20</span><span class="s1">;</span></p>
<p><span class="s1">}</span></p>
<p><strong>get方法</strong>：获取对象内部的成员变量，不接收参数，返回类型与成员变量类型相同，方法名称与成员变量名称相同（不含下划线）。不推荐以get开头。</p>
<p><span class="s1">-(</span><span class="s2">int</span><span class="s1">)speed;</span></p>
<p><span class="s1">-(</span><span class="s2">int</span><span class="s1">)speed</span></p>
<p><span class="s1">{</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">return</span> <span class="s3">_speed</span><span class="s1">;</span></p>
<p><span class="s1">}</span></p>
<p>只读：只提供get方法。可读可写：提供get和set方法。</p>
<h3 id="OC的弱语法"><a href="#OC的弱语法" class="headerlink" title="OC的弱语法"></a>OC的弱语法</h3><p>1，调用未声明、未实现的对象方法</p>
<p>编译 报错 No visible @interface for ‘Dog’ declares the selector ‘ssss’，链接运行 报错。</p>
<p><span class="s1"><strong>reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1002014a0’</strong></span></p>
<p>给Dog对象发送不能识别的消息。</p>
<p>2，调用已声明、未实现的对象方法</p>
<p>编译警告：Method definition for ‘ssss’ not found   未实现方法  链接正常，运行报错</p>
<p><span class="s1"><strong>reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1001002a0’</strong></span></p>
<p>3,调用未声明、已实现的对象方法</p>
<p>编译 链接运行  错误  No visible @interface for ‘Dog’ declares the selector ‘ssss’</p>
<p>在Dog的@interface中，对于ssss的声明是不可见的。<a id="more"></a> </p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>类本身在内存中占据存储空间，里面有类\对象方法列表。直接通过类名执行的方法。</p>
<p>以+开头，只能由类名调用，类方法中不能访问成员变量（实例变量）。<strong>允许类方法与对象方法重名。</strong>(执行者不同，当然可以重名！)</p>
<p>使用场合：当不需要访问成员变量的时候，尽量使用类方法，提升效率。</p>
<p>输出类的名称：</p>
<p><span class="s1">+(</span><span class="s2">void</span><span class="s1">)showClassName;</span></p>
<p><span class="s1">+(</span><span class="s2">void</span><span class="s1">)showClassName</span></p>
<p><span class="s1">{</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s1">NSLog</span><span class="s3">(</span><span class="s4">@”类的名称是：%@”</span><span class="s3">,</span><span class="s1">NSStringFromClass</span><span class="s3">([</span><span class="s2">self</span> <span class="s1">class</span><span class="s3">]));</span></p>
<p><span class="s1">}</span></p>
<p>调用：<span class="s1">[</span><span class="s2">Dog</span> <span class="s2">showClassName</span><span class="s1">];</span></p>
<h3 id="self关键字"><a href="#self关键字" class="headerlink" title="self关键字"></a>self关键字</h3><p>self是指针，指向当前对象或类的调用者。出现在对象方法中，代表当前对象，出现在类方法中，代表当前类。不能出现在函数中（会报错：Use of undeclared identifier ‘self’使用未声明的标识符）。</p>
<p>用途：</p>
<p>1， self-&gt;<span class="s1">成员变量名  在对象方法中访问当前方法调用的成员变量，也即当成员变量与局部变量同名时，用来区分同名的局部变量。</span></p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)showSelfOfObject;</span></p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)showSelfOfObject</span></p>
<p><span class="s1">{</span></p>
<p><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s3">NSLog</span><span class="s2">(</span><span class="s1">@”showSelfOfObject方法被调用”</span><span class="s2">);</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">int</span><span class="s1"> _speed;</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">self</span><span class="s1">-&gt;</span><span class="s5">_speed</span><span class="s1">=</span><span class="s6">200</span><span class="s1">;</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span>_speed+=</span><span class="s6">1000</span><span class="s1">;</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">int</span><span class="s1"><span class="Apple-converted-space">  </span>result= </span><span class="s4">self</span><span class="s1">-&gt;</span><span class="s5">_speed</span><span class="s1">+</span><span class="s6">10</span><span class="s1">;</span></p>
<p><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s3">NSLog</span><span class="s2">(</span><span class="s1">@”result的值是：%i”</span><span class="s2">,result);</span></p>
<p><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s3">NSLog</span><span class="s2">(</span><span class="s1">@”_speed的值是：%i”</span><span class="s2">,_speed);</span></p>
<p><span class="s1">}</span></p>
<p>当成员变量与局部变量同名时（编译警告Local declaration of ‘_speed’ hides the instance variable局部变量隐藏了成员变量），采用就近原则，访问局部变量。因此需要用self访问成员变量。</p>
<p>2，方法的调用 :在对象方法中调用当前对象的对象方法以及在类方法中调用当前类的类方法</p>
<p>在对象方法中调用当前对象的对象方法</p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)showSelfOfObject;</span></p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)showTestObject;</span></p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)showSelfOfObject</span></p>
<p><span class="s1">{</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s4">NSLog</span><span class="s3">(</span><span class="s1">@”showSelfOfObject方法被调用”</span><span class="s3">);</span></p>
<p><span class="s1">}</span></p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)showTestObject</span></p>
<p><span class="s1">{</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span>[</span><span class="s2">self</span> <span class="s1">showSelfOfObject</span><span class="s3">];</span></p>
<p><span class="s1">}</span></p>
<p>在类方法中调用当前类的类方法</p>
<p><span class="s1">+(</span><span class="s2">void</span><span class="s1">)showSelfOfClass;</span></p>
<p><span class="s1">+(</span><span class="s2">void</span><span class="s1">)showTestClass;</span></p>
<p><span class="s1">+(</span><span class="s2">void</span><span class="s1">)showSelfOfClass</span></p>
<p><span class="s1">{</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s4">NSLog</span><span class="s3">(</span><span class="s1">@”showSelfOfClass方法被调用”</span><span class="s3">);</span></p>
<p><span class="s1">}</span></p>
<p><span class="s1">+(</span><span class="s2">void</span><span class="s1">)showTestClass</span></p>
<p><span class="s1">{</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span>[</span><span class="s2">self</span> <span class="s1">showSelfOfClass</span><span class="s3">];</span></p>
<p><span class="s1">}</span></p>
<p><strong>常见错误：</strong></p>
<p>1，在对象方法中调用类方法（编译错误No visible @interface for ‘Dog’ declares the selector ‘<span class="s1">showSelfOfClass</span>‘）错误相当于未声明未定义却调用这个方法。</p>
<p>2，在类方法中调用对象方法（编译错误No known class method for selector ‘<span class="s1">showSelfOfObject</span>‘）未知的类方法</p>
<p>3，self的死循环:调用本身</p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)showSelfOfObject</span></p>
<p><span class="s1">{</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s4">NSLog</span><span class="s3">(</span><span class="s1">@”showSelfOfObject方法被调用”</span><span class="s3">);</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span>[</span><span class="s2">self</span> <span class="s1">showSelfOfObject</span><span class="s3">];</span></p>
<p><span class="s1">}</span></p>
<p>4，调用函数</p>
<p>函数不依赖对象。void f();  [self f]<span class="Apple-converted-space">  </span><span class="s1">错误</span></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>场景：当两个类拥有相同的属性和方法时，将相同的内容抽取到父类中。当A类完全拥有B类的部分属性或方法时，考虑A类作为父类。</p>
<p>1，父类必须声明在子类前面。</p>
<p>2，不允许子类和父类拥有相同的成员变量（如果子类有和父类相同的成员变量，意味着，同一成员变量声明定义两次，编译错误 Duplicute member <span class="s1">‘_age’  ，哪怕成员变量的访问属性不同，子类公开父类私有，或者父类公开子类私有，都不行！</span>）</p>
<p>3，子类方法和属性的访问过程：如果子类没有，再访问父类。即由子类开始。</p>
<p>4，Objective-C中只有单继承（与C＋＋不同）</p>
<p><strong>方法的重写</strong>:父类和子类拥有相同签名的类方法或者对象方法（子类重新实现了父类中的方法），则优先调用子类的同名方法。</p>
<p>父类Person：</p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)show</span></p>
<p><span class="s1">{</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s4">NSLog</span><span class="s3">(</span><span class="s1">@”调用了Person的show方法”</span><span class="s3">);</span></p>
<p><span class="s1">}</span></p>
<p>子类Student：</p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)show</span></p>
<p><span class="s1">{</span></p>
<p><span class="s1">     //[</span><span class="s2">super</span> <span class="s3">show</span><span class="s1">];</span></p>
<p><span class="s3"><span class="Apple-converted-space">    </span></span><span class="s4">NSLog</span><span class="s3">(</span><span class="s1">@”调用了Student的show方法”</span><span class="s3">);</span></p>
<p><span class="s1">}</span></p>
<p>调用：</p>
<p><span class="s1">Student</span><span class="s2"> *p=[[</span><span class="s1">Student</span> <span class="s3">alloc</span><span class="s2">] </span><span class="s3">init</span><span class="s2">];   </span><span class="s1">[p </span><span class="s4">show</span><span class="s1">];</span></p>
<p>很明显，调用的是重写的子类Student的show方法。</p>
<p>super</p>
<p>场景：子类重写父类的方法时，想调用父类的方法（包括类方法和对象方法）。</p>
<p>效果与self类似，super在对象方法中就调用父类的对象方法，在类方法中就调用父类的类方法。</p>
<p>继承可以在不改变原来模型的基础上拓充方法，抽取公共代码，建立类与类之间的联系，减少代码的冗余性，但是，会增加耦合性。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>某一种事物的多种形态。在实现继承的前提下，<strong>父类类型指针指向子类对象</strong>（右边是左边），指向子类对象的父类指针可以调用子类中重写父类的方法，但是指向子类对象的父类指针不能调用子类中拓展的方法（父类中没有的方法）。</p>
<p><span class="s2">Person</span><span class="s1"> *p=[[</span><span class="s2">Student</span> <span class="s3">alloc</span><span class="s1">] </span><span class="s3">init</span><span class="s1">];</span></p>
<p><span class="s2"><span class="Apple-converted-space">        </span>[p </span><span class="s4">show</span><span class="s2">];</span></p>
<p>Student是Person，show方法在子类和父类中都有，这里调用的是子类的show方法。</p>
<p>当子类拓展了一个<span class="s1">showStudent对象方法，如果还想调用，则强制转换：将指向子类对象的父类指针强制转化为子类指针。</span></p>
<p><span class="s1">Person</span><span class="s2"> *p=[[</span><span class="s1">Student</span> <span class="s3">alloc</span><span class="s2">] </span><span class="s3">init</span><span class="s2">];</span></p>
<p><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">Student</span><span class="s1"> <em> p2=(</em></span><span class="s4">Student</span><span class="s1"> )p;</span></p>
<p><span class="s1"><span class="Apple-converted-space">        </span>[p2 </span><span class="s4">showStudent</span><span class="s1">];</span></p>
<p>将父类指针p强制转换为子类指针，使它可以调用子类Student拓展的showStudent方法。</p>
<p>如果不做强制转换，而直接调用子类拓展的方法</p>
<p><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s2">Person</span><span class="s1"> *p=[[</span><span class="s2">Student</span> <span class="s3">alloc</span><span class="s1">] </span><span class="s3">init</span><span class="s1">];</span></p>
<p><span class="s4"><span class="Apple-converted-space">     </span></span><span class="s1"><span class="Apple-converted-space">       </span>[p showStudent];</span></p>
<p>编译报错： No visible @interface for ‘Person’ declares the selector ‘showStudent’</p>
<p>转换语法： { 相应子类名 <em>   p=(父类名 </em>)指向子类对象的父类指针；}</p>
<p>主要应用：[动态绑定]如果参数使用父类类型，可以传入父类、子类对象，调用相应的方法（如将子类对象传递给参数，调用子类的方法；将父类对象传递给参数，则调用父类的方法）</p>
<p>例如，Person和Student中都有同名show对象方法，可以通过test函数传入的参数判断调用哪个方法。</p>
<p><span class="s1">#import </span><span class="s2">&lt;Foundation/Foundation.h&gt;</span></p>
<p><span class="s1">#import </span><span class="s2">“Person.h”</span></p>
<p><span class="s1">#import </span><span class="s2">“Student.h”</span></p>
<p><span class="s3">void</span><span class="s2"> test(</span><span class="s4">Person</span><span class="s2"> * p)</span></p>
<p><span class="s2">{</span></p>
<p><span class="s2"><span class="Apple-converted-space">    </span>[p </span><span class="s4">show</span><span class="s2">];</span></p>
<p><span class="s2">}</span></p>
<p><span class="s3">int</span><span class="s2"> main(</span><span class="s3">int</span><span class="s2"> argc, </span><span class="s3">const</span> <span class="s3">char</span><span class="s2"> * argv[]) {</span></p>
<p><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s2">@autoreleasepool</span><span class="s5"> {</span></p>
<p><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s4">Person</span><span class="s2"> *p=[[</span><span class="s4">Person</span> <span class="s6">alloc</span><span class="s2">] </span><span class="s6">init</span><span class="s2">];</span></p>
<p><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s4">Student</span><span class="s2"> *s=[[</span><span class="s4">Student</span> <span class="s6">alloc</span><span class="s2">] </span><span class="s6">init</span><span class="s2">];</span></p>
<p><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s4">test</span><span class="s2">(p);</span></p>
<p><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s4">test</span><span class="s2">(s);</span></p>
<p><span class="s2"><span class="Apple-converted-space">            </span>}</span></p>
<p><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s3">return</span> <span class="s7">0</span><span class="s2">;</span></p>
<p><span class="s2">}</span></p>
<h3 id="NSString的使用"><a href="#NSString的使用" class="headerlink" title="NSString的使用"></a>NSString的使用</h3><h4 id="创建字符串与输出字符串"><a href="#创建字符串与输出字符串" class="headerlink" title="创建字符串与输出字符串"></a><strong>创建字符串与输出字符串</strong></h4><p><span class="s2">NSString</span><span class="s1"> *s=</span><span class="s3">@”Sometimes”</span><span class="s1">;</span></p>
<p><span class="s3"><span class="Apple-converted-space">        </span></span><span class="s2">NSLog</span><span class="s3">(</span><span class="s4">@”%@”</span><span class="s3">,s);</span></p>
<h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a><strong>格式化字符串</strong></h4><p><span class="s1">int</span><span class="s2"> age=</span><span class="s3">85</span><span class="s2">;</span></p>
<p><span class="s4"><span class="Apple-converted-space">        </span></span><span class="s2">NSString</span><span class="s4"> *s=[</span><span class="s2">NSString</span> <span class="s2">stringWithFormat</span><span class="s4">:</span><span class="s5">@”传入的年龄参数是%d”</span><span class="s4">,age];</span></p>
<p><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s6">NSLog</span><span class="s2">(</span><span class="s5">@”%@”</span><span class="s2">,s);</span></p>
<p>调用<span class="s2">NSString类方法。</span></p>
<h4 id="length返回字数（不是字符数）"><a href="#length返回字数（不是字符数）" class="headerlink" title="length返回字数（不是字符数）"></a><strong>length返回字数（不是字符数）</strong></h4><p><span class="s1">NSString</span><span class="s2"> *s=</span><span class="s3">@”123 456”</span><span class="s2">;</span></p>
<p><span class="s3"><span class="Apple-converted-space">        </span></span><span class="s1">NSLog</span><span class="s3">(</span><span class="s4">@”%@”</span><span class="s3">,s);</span></p>
<p><span class="s3"><span class="Apple-converted-space">        </span></span><span class="s1">NSUInteger</span><span class="s3"> size=[s </span><span class="s1">length</span><span class="s3">];</span></p>
<p><span class="s3"><span class="Apple-converted-space">        </span></span><span class="s1">NSLog</span><span class="s3">(</span><span class="s4">@”%lu”</span><span class="s3">,(</span><span class="s5">unsigned</span> <span class="s5">long</span><span class="s3">)size);</span></p>
<p>返回的是7，包括空格。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C学习笔记一：类]]></title>
      <url>http://yoursite.com/2016/05/12/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h3 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h3><p>三要素：事物名称（类名）；属性；行为（功能）</p>
<p>具有相同（或者类似）属性和行为的对象可以抽象出一个类。</p>
<h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><p>类名   1，首字母大写；2，不能有下划线；3，多个英文单词，使用驼峰标识</p>
<p>行为   哪个对象最清楚行为怎么做，就把行为设计在哪个对象身上</p>
<p><span class="s1">#import </span><span class="s2">&lt;Foundation/Foundation.h&gt;框架包含很多头文件，开发OC、iOS、Mac的必备框架，具有许多API。</span></p>
<p><span class="s1">#import </span><span class="s2">用来拷贝某个文件的内容，与#include的区别：自动防止文件内容被拷贝多次</span></p>
<p><span class="s1">@interface</span><span class="s2"> Person : </span><span class="s3">NSObject</span></p>
<p><span class="s2">{</span></p>
<p><span class="s2">@public</span></p>
<p><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">int</span><span class="s2"> _age;</span></p>
<p><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">bool</span><span class="s2"> _sex;</span></p>
<p><span class="s2">}</span></p>
<p><span class="s2">-(</span><span class="s1">void</span><span class="s2">)print;</span></p>
<p><span class="s2">@end</span></p>
<p>大括号内用来声明对象属性（成员变量也即实例变量）,@public让外界指针可以间接访问对象内部的成员变量。成员变量默认会初始化为0.</p>
<p><span class="s1">: </span><span class="s2">NSObject（继承基类）使声明的类具有创建对象的能力。</span></p>
<h3 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h3><p><span class="s1">@implementation</span><span class="s2"> Person</span></p>
<p><span class="s1">-(</span><span class="s3">void</span><span class="s1">)print</span></p>
<p><span class="s1">{</span></p>
<p><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">NSLog</span><span class="s1">(</span><span class="s5">@”输出内容”</span><span class="s1">);</span></p>
<p><span class="s1">}</span></p>
<p><span class="s1">@end</span></p>
<p>已经导入声明文件<span class="s1">#import </span><span class="s2">“Person.h” 类的实现即方法的实现。<a id="more"></a> </span></p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p><span class="s2">Person</span><span class="s1"> *p=[[</span><span class="s2">Person</span> <span class="s3">alloc</span><span class="s1">] </span><span class="s3">init</span><span class="s1">];</span></p>
<p><span class="s1">[p </span><span class="s2">print</span><span class="s1">];</span></p>
<p>对象的本质是结构体，对象需要通过指针操纵。</p>
<p>类在内存中也占据存储空间，在创建对象之前为类分配一份内存空间，将类加载进内存。而且只存储方法列表，其中由类产生的对象，都有一个isa指针指向类。</p>
<p>方法调用：[行为执行者   行为名称];</p>
<p>[Person new]执行Person这个类的new行为创建对象，返回对象地址。</p>
<p>Person  <em>p=[Person new];定义一个Person </em>类型的指针变量p，指向Person类型的对象。指针的类型是Person *，指针指向的类型是Person。</p>
<p><span class="s1">[p </span><span class="s2">print</span><span class="s1">]表示给p指向的对象发送一条print消息。</span></p>
<p>Person  <em>p=[Person new];等价于 Person </em>p;p=[Person new];另外Person *p2=p;表示p2、p指向同一个内容。p=p2:将p2存储的指针交给p，使p存储的也是p2存储的内容。</p>
<h3 id="方法与函数的区别以及注意"><a href="#方法与函数的区别以及注意" class="headerlink" title="方法与函数的区别以及注意"></a>方法与函数的区别以及注意</h3><ul>
<li><span class="s2">OC方法只能声明在@interface和@end之间，只能实现在@implementation和@end之间。也就是说OC方法不能独立于类存在</span></li>
<li><span class="s2">C函数不属于类，跟类没有联系，C函数只归定义函数的文件所有</span></li>
<li><span class="s2">C函数不能访问OC对象的成员</span></li>
<li><p>对象方法归类／对象所有，函数属于整个文件所有，任何地方都可以放置函数（如果放在<span class="s1">@interface</span>与<span class="s1">@end</span>之间，将会忽略掉函数，即未定义）</p>
</li>
<li><p><span class="s2">方法只有声明，没有实现（经典错误）</span></p>
</li>
<li><span class="s2">方法没有声明，只有实现（编译器警告，但是能调用，OC的弱语法）</span></li>
<li><span class="s2">编译的时候：访问没有的成员变量直接报错，访问没有的方法，只是警告</span></li>
<li><span class="s2">同一个类中不允许两个对象方法同名</span></li>
</ul>
<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><ul>
<li><p><span class="s2">属性访问  </span>[Car  new]-&gt;speed = 200;</p>
</li>
<li><p><span class="s2">方法调用    </span>[ [Car  new]  run];</p>
</li>
</ul>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>不带参数的对象方法：</p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)print;  方法名print</span></p>
<p>带一个参数的对象方法：</p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)print:(</span><span class="s2">int</span><span class="s1">) a; 方法名print :</span></p>
<p>带多个参数的对象方法：</p>
<p><span class="s1">-(</span><span class="s2">void</span><span class="s1">)print:(</span><span class="s2">int</span><span class="s1">) a WithOther:(</span><span class="s2">int</span><span class="s1">) b; 方法名</span></p>
<p><span class="s1">print</span><span class="s1"> : WithOther:</span></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>typedef enum<span class="s1">｛</span></p>
<p><span class="Apple-converted-space">          </span>SexMan,</p>
<p><span class="Apple-converted-space">          </span>SexWoman</p>
<p><span class="s1">｝</span>Sex;</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>typedef struct{</p>
<p><span class="Apple-converted-space">   </span>int year;</p>
<p><span class="Apple-converted-space">   </span>int month;</p>
<p><span class="Apple-converted-space">   </span>int day;</p>
<p>} Date;</p>
<p>访问枚举：s-&gt;sex=SexMan;</p>
<p>访问结构体：s-&gt;birthday.year=2016;</p>
<p>定义结构体：</p>
<p>Date d={2016,4,30};</p>
<p>访问结构体：</p>
<p>s-&gt;birthday.year=2016;</p>
<p>s-&gt;birthday.month=4;</p>
<p>s-&gt;birthday.day=16;</p>
<p>等价于：</p>
<p>Date d={2016,4,16};</p>
<p>s-&gt;birthday=d;</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>打印函数中注意％与<span class="s1">%</span>的区别</li>
<li>定义枚举、结构体等必需放在<span class="s1">@interface</span>的前面方可使用</li>
<li><span class="s1">OC</span>方法中一个参数一个冒号</li>
<li>对象中有对象</li>
</ul>
<p>@interface Student : NSObject</p>
<p>{</p>
<p><span class="Apple-converted-space">    </span>@public</p>
<p><span class="Apple-converted-space">    </span>//<span class="s1">狗</span></p>
<p><span class="Apple-converted-space">    </span>Dog *dog;</p>
<p>}</p>
<p>-(void)letDogRun</p>
<p>{</p>
<p><span class="Apple-converted-space">    </span>[dog run];</p>
<p>}</p>
<p>main.m</p>
<p>Student *stu=[Student new];</p>
<p><span class="Apple-converted-space">        </span>Dog *dog=[Dog new];</p>
<p><span class="Apple-converted-space">            </span>stu-&gt;dog=dog;</p>
<p><span class="Apple-converted-space">        </span>[stu letDogRun];</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅谈负债哲学]]></title>
      <url>http://yoursite.com/2016/05/06/%E6%B5%85%E8%B0%88%E8%B4%9F%E5%80%BA%E5%93%B2%E5%AD%A6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文刊自某信用卡论坛。某年某日拜读之后，收获巨大，特此转载。感谢作者。</p>
</blockquote>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p><span style="color: #000000;">首先抛出一个问题，银行放贷最关心的是什么？<br>并不是还贷的能力，而是抽贷的时机。</span></p>
<p>即使资不抵债，银行照样敢放出贷款，如果您不能理解，那么请往下看：</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">“信用卡体系的根基并非持卡人的信用，而是银行的不守信用”，这是我最初接触到信用卡时的第一想法。说来奇怪，当我第一次接触到信用卡的时候，并没有任何信用卡，甚至没有申请信用卡的想法；那年我大三，或者说大四，总之暑假还没有开学。</span></p>
<p><span style="color: #000000;">本来，作为一名实习生只能担任一些非核心的岗位，但因为父亲的原因，免除了基础性的工作，直接进入了能够接触到信用逻辑的技术部门；那是我最初接触到银行的信贷逻辑，并使我后来决定远离银行体系的原因。银行只是一台冷血的机器，这里只有利益的竞逐和赤裸裸的博弈，银行与用户，银行与银行，而没有理解与帮助。<a id="more"></a> </span></p>
<table class="t_table" cellspacing="0"><br><tbody><br><tr><br><td><br><br><span style="color: #000000;">银行客户分类服务标准：</span><br><br><span style="font-size: small; color: #000000;">贵宾客户：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供周到满意的全方位服务</span></span><br><br><span style="font-size: small; color: #000000;">高值客户：</span><br><div align="right"><span style="color: #000000;"><span style="font-size: xx-small;">提供周到满意的品质服务</span></span></div><br><span style="font-size: small; color: #000000;">金卡客户：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供客户满意的便捷服务</span></span><br><br><span style="color: #000000;"><span style="font-size: small;">基础客户</span><span style="font-size: xx-small;">：</span></span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供便捷舒适的基础业务</span></span><br><br><span style="font-size: small; color: #000000;">政策客户：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供政策要求的服务质量</span></span><br><br></td><br><td><br><br><span style="color: #000000;">银行关于不同类型投诉的处理方式：</span><br><br><span style="font-size: small; color: #000000;">重大过失投诉：</span><br><br><span style="font-size: xx-small; color: #000000;">指银监会可能亲审的投诉(比如身份冒用、账务冲正等)，由实权部门优先受理</span><br><br><span style="font-size: small; color: #000000;">终止合作投诉：</span><br><br><span style="font-size: xx-small; color: #000000;">指客户要求与银行互相拉黑，并按合同依法索赔的投诉，由实权部门直接受理</span><br><br><span style="color: #000000;"><span style="font-size: small;">贵宾客户</span><span style="font-size: small;">投诉：</span><span style="font-size: small;"><br></span></span><br><br><span style="font-size: xx-small; color: #000000;">指贵宾卡达标客户的各类(合理或无理的)投诉，由实权贵宾投诉部门特殊受理</span><br><br><span style="font-size: small; color: #000000;">一般类别投诉：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">指普通投诉(</span><span style="font-size: xx-small;">包括</span><span style="font-size: xx-small;">客户执意要求管理层受理的投诉)，</span><span style="font-size: xx-small;">转回</span><span style="font-size: xx-small;">直接管理部门</span><span style="font-size: xx-small;">自行处理</span></span><br><br><span style="color: #000000;"><span style="font-size: small;">反复多次</span><span style="font-size: small;">投诉：</span><span style="font-size: small;"><br></span></span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">指针对同一情节投诉3次及以上的客户，转由兼职大学生</span><span style="font-size: xx-small;">接听投</span><span style="font-size: xx-small;">诉(只许说套话)</span></span><br><br></td><br></tr><br><tr><br><td colspan="2"><br><div align="left"><span style="color: #000000;">垃圾客户：提供便捷的存取款业务<span style="font-size: xx-small;">(即:个人储蓄账户业务)</span>，并避免该客户影响其他储户的客户体验</span></div></td><br></tr><br></tbody><br></table><br><div align="left"><span style="color: #000000;"><span style="font-size: xx-small;">其中低保户、</span><span style="font-size: xx-small;">五保户</span><span style="font-size: xx-small;">等属于政策客户</span><span style="font-size: xx-small;">，</span>除政策客户外，行内资产在15K以下的属于垃圾客户，</span></div><br><span style="color: #000000;">除重大过错外，垃圾客户所有投诉均属于无效投诉，包括柜员态度和拒绝服务。简而言之，银行对这类客户的态度是<span style="font-family: 宋体;"><span style="font-size: xx-small;">：(</span></span><span style="font-size: xx-small;">淘汰低端客户是目的，不属于客户流失，特别是垃圾客户)</span></span><br><br><span style="color: #000000;"><span style="font-size: medium;">要么忍着，要么滚，爱存不存，这点存款的盈利还挣不回服务成本。</span>另一方面，</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">银监对于</span>非重大过失是转回银行<span style="font-size: xx-small;">(投诉转申诉)</span>自行处理的<span style="font-size: xx-small;">，</span><span style="font-size: xx-small;">银行并</span>不害怕<span style="font-size: xx-small;">垃圾</span><span style="font-size: xx-small;">客户</span>投诉到银监会</span><br><div id="code_dc1"><br><br>1.  <span style="color: #000000;">注：关于日均存款，银行一般有两种计算方式：账面日均(一般24:00结算)和公允日均(一般22:00结算)</span><br>2.  <span style="color: #000000;">账面日均：每日某时刻的行内资产/行内负债作为数据单位，计算平均数。</span><br>3.  <span style="color: #000000;">公允日均：每日某时刻及之前42小时内，行内资产最低值/行内负债最高值作为数据单位，计算平均数。</span><br>4.  <span style="color: #000000;">借记类业务一般采用前一种，贷记类业务一般采用后一种（但支行签字承担责任的业务可以采用前一种）</span><br></div><br><br># 二<br><br>银行的收益不是柜员的：即使大闹银行，那帮人也没什么损失，只要高柜玻璃不碎根本不算事故，撑死算个意外<br><br>无效投诉，一只三不：只道歉(不认错)，不处罚，不整改，不赔偿(所有不反馈处罚决定的投诉,都是无效投诉)<br><div align="right"><br><br>无法理解”一只三不”?体会一下这句话:”对不起,先生,我们已经打烊了.”道歉是因为造成了不便(包括自身没有任何过错)<br><br></div><br><br>一方面，引入更多债权方，可以稀释已发卡行的资金风险，而逾期记录会阻碍其他债权方的加入或追加额度；<br>另一方面，持卡人一而再的利用逾期宽容策略是银行更加不能容忍的，没有银行能容忍自己成为风险转嫁终端。<br><br>银行不会(因为不愿意)上报持卡人的短期逾期，除非持卡人预见到银行不会上报该笔逾期。<br><br>与逾期记录相对的另一个扣分项是信报查询记录：<br>其中比较常见的是信用卡审批、本人查询、贷款审批和贷后管理。<br>其中扣分最严重的依次是：<br><br><table class="t_table" cellspacing="0"><br><tbody><br><tr><br><td><span style="color: #000000;">1.不知名机构的贷款审批<span style="font-size: xx-small;">(尤其是没有贷款记录的)</span></span></td><br><td><span style="color: #000000;">3.未持卡机构的信用卡审批</span></td><br></tr><br><tr><br><td><span style="color: #000000;">2.非冷冻机构的贷后管理</span></td><br><td><span style="color: #000000;">4.个人明细版的本人查询</span></td><br></tr><br></tbody><br></table>

<p>四大行或者其他著名银行的贷款审批是不会扣分的，而已持卡行的信用卡审批记录也是根本无所谓的。<br>特别需要注意的是：（贷后管理是不需要持卡人主动申请的，而银行方面为了防止贷后管理被投诉，）<br>银行卡部对贷后管理统一口径(不影响系统评分)，但实际执行中贷后管理比(已持卡行)信用卡审批扣分更多</p>
<p><span style="color: #000000;">对于明知资不抵债的人，银行依旧敢于放款，并不是信任持卡人或者贷款人的还款能力，而是豪赌其他贷款方像自己一样认为持卡人还有榨取空间而不会抢先抽贷。银行对于自己的批卡或者放款有自信（或者说盲目自信的相信）自己不会成为击鼓传花的最后一棒；换言之，银行有自信在用户可用资金不足之前及时抽贷或者停卡，而把坏账留给其他债权人。越没有信用的银行越敢于放贷，同样也是这些银行更急于抽贷。</span></p>
<p><span style="color: #000000;">说到抽贷，就不得不提到催收。</span><br><span style="color: #000000;">首先，催收的威逼利诱是不需要害怕的，没有打工者会为了那点提成冒着自己违法的风险。</span><br><span style="color: #000000;">但是同样的，催收也不害怕你的强硬威胁，同样因为大部分人不敢把狠话付诸行动。</span><br><span style="color: #000000;">记住关于催收的三个基本：</span><br><span style="color: #000000;">1.催收的利诱不能信，即使如约先还部分款，后续仍会一如既往的强硬。</span><br><span style="color: #000000;">2.催收总是试图诱导你对他动用武力，因为你的打手被认定共同受益，可以追究欠款的连带赔偿。</span><br><span style="color: #000000;">3.有资格做某事的人数超过总人口的8%，以这种行为做威胁必定没用；除非你有足够的专业背景。</span><br><span style="color: #000000;">简而言之：</span><br><span style="color: #000000;">催收不过是不敢付诸行动的苍蝇，不过你对他的强硬同样没用<span style="font-size: xx-small;">，除非你是土豪、律师或者暴力犯罪在逃犯</span></span><br><span style="color: #000000;"><span style="font-size: xx-small;">以上是常见的外包催收，还有一种连催收人员都鲜有耳闻的催收队伍：污点催收。<br>这类催收一般是对付那些想为家人保住财产的逾期者(或者说是想一人做事一人当的汉子)；<br>一言以蔽之：</span>直系亲属(及配偶)无钱可出则采用外包催收，而直系亲属不愿倾其所有的采用污点催收。</span><br><span style="color: #000000;">污点催收人是银行招安的一部分逾期特别巨大且确实走投无路的铤而走险者，一般具备以下协议：</span></p>
<div class="blockcode" style="text-align: justify;"><br><div id="code_DYg"><br><br>1.  <span style="color: #000000;">协议禁止催收时使用违法手段，否则造成的一切后果及法律责任自负，与银行无关；</span><br>2.  <span style="color: #000000;">不能达到签约的催收指标则视为违约，银行将继续依法对信用卡诈骗报案追究刑事责任；</span><br>3.  <span style="color: #000000;">达到催收指标满XX年后，可以不再追究刑事及民事责任，并发放一定金额的奖励；</span><br>4.  <span style="color: #000000;">因催收冲突或暴力袭击原因导致死亡的，向其子女发放优厚的死亡赔偿金(不属于死者的遗产)</span><br></div><br></div>

<p><span style="color: #000000;">但是，实际执行中：由于逾期者的亲属不存在法律上的连带责任，</span></p>
<div style="text-align: justify;" align="right"><span style="color: #000000;">银行摊派给污点催收的一定是通过合法手段<span style="font-size: xx-small;">(含法律渠道)</span>不可能回收的债务。</span></div>

<p><span style="color: #000000;">此种关系模式下：银行把自己最大的威胁<span style="font-size: xx-small;">(包括暴力压力和舆论压力)</span>变成了自己最锋利的刀，</span></p>
<div style="text-align: justify;" align="right"><span style="color: #000000;">催收和被催收的关系是：除非被催收者的父母妻儿倾家荡产，否则污点催收人必定家破人亡。</span></div>

<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p><span style="color: #000000;">进场自由，愿赌服输，<u>希望回本的赌徒永远都是loser</u>。</span></p>
<p><span style="color: #000000;">  所谓进场自由，当被抢先抽贷或者资金断流，信用卡所谓催收不过是迫使持卡人把烂账转嫁到亲友或其他债权方，而非让你尽早赚回本金，不要说什么没有钱，银行之所以催收恰是因为你没有资金，银行试图引入更多的债权人使自己完成抽贷全身而退。</span></p>
<p><span style="color: #000000;">  所谓愿赌服输，如果短期内无法全身而退，银行唯一要做的就是甩掉黑锅，把自己塑造成受害者，而隐藏面具下的魔鬼；作为赌局的输家，银行并不是妄图回本的loser，根本不在乎收回本金（沉没成本的收益期望小于风险成本+机会成本），让持卡人背负欺骗银行的黑锅，这才是信用卡刑事庭的本质。</span></p>
<p><span style="color: #000000;">关于刑事，插入一句：</span><span style="color: #000000;">A.还款优先抵扣滞纳金，判定是否存在持续还款</span><span style="color: #000000;">B.还款优先抵扣本金后，判定刑事判决具体刑期</span><span style="color: #000000;"><span style="font-size: xx-small;">同一笔还款在AB两个阶段，优先偿还的优先级不同，A阶段在B阶段之前结算。</span></span></p>
<div class="blockcode"><br><div id="code_K1F"><br><br>1.  <span style="color: #000000;">以5%滞纳金+利息为例，如果每月还款不超过本金的5%视为没有还款。</span><br>2.  <span style="color: #000000;">如果每月偿还5%，那么20个月后停止偿还，也仅仅是民事问题。</span><br>3.  <span style="color: #000000;">举例：欠款10万，</span><br>4.  <span style="color: #000000;">第2~5个月还款5000.01，第6~15个月偿还3K，则有且仅有第6~15个月视为没有还款。</span><br>5.  <span style="color: #000000;">量刑金额：49,999.96 (即100K-5000.01<em>4-3K</em>10)，利息及滞纳金部分不作为量刑标准。                                                    </span><br>6.  <span style="color: #000000;">数额较大：数额在5000元以上不满5万元的；</span><br>7.  <span style="color: #000000;">数额巨大：数额在5万元以上不满50万元的。</span><br></div><br></div>

<p><span style="color: #000000;">上述数据可以看出逾期还款的基准点是：两年结清本金，利息、罚金不免。</span></p>
<p>由此引出了逾期协商的本质：<strong>双方退而求其次</strong>。<br><span style="color: #000000;">所谓谈判的过错不过是时间（容忍期）与空间（资金关系）的利益交换。</span><br><span style="color: #000000;">银行拒绝与持卡人协商的原因仅仅是由于持卡人没有任何谈判的诚意。</span></p>
<p><span style="color: #000000;">谈判（或者说协商）的本质无非是：时间换空间，或者空间换时间；</span><br><span style="color: #000000;">逾期者的协商如果基于时空双降，这注定是失败的，除非你爸是李刚。</span></p>
<p><span style="color: #000000;">空间换时间（典型案例）：持卡人通过另有约定同意<span style="font-size: xx-small;">(刑期意义上)</span>还款优先冲抵滞纳金；</span><br><span style="color: #000000;">银行接受较长的约定还款期限并降低最低还款标准，但不降低滞纳金收取标准。</span><br><span style="color: #000000;">时间换空间（典型案例）：持卡人于15个工作日内从其他债权方<span style="font-size: xx-small;">(特别是直系亲属)</span>借到本金；</span><br><span style="color: #000000;">银行确认本金偿清后，免除全部利息与滞纳金，并永久拒绝持卡人的信贷业务。</span></p>
<p><span style="color: #000000;">想要延长还款期，并减免利息的，洗洗睡吧：银行相对于默认规则没有降低任何风险。</span><br><span style="color: #000000;">至于自首，只要你的供述事实构不成犯罪，一定会被经侦赶出来，立不了案，哪来的自首？</span></p>
<p><span style="color: #000000;">注意：判刑后银行仍有对债务的民事权力，可以申请法院强制执行，也就是说：坐牢也得还。</span><br>但是，在某些极端情况下，银行一定会免除债务的，比如因负债压力过大而自杀(不含劝离/解救成功，含抢救成功):<br>因自杀导致的病危通知书，仅一张，或因其他原因而起，因而银行不承担责任，所以没卵用。<br>两张因自杀导致的(三甲医院出具的)病危通知书，免利息、滞纳金。<br>三张以上因自杀导致的(三甲医院出具的)病危通知书，连本金都免。<br>无论最后是否抢救成功，但上述病危通知书必须是持卡人本人、直系亲属或配偶。<br><span style="color: #000000;">不想像上述那样极端？成为特殊人群也可以享受减免且免于刑事，比如<span style="font-size: xx-small;">(政府部门确认的)</span>地震受灾户。</span></p>
<h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p><span style="color: #000000;">没有一家银行能承受挤兑，同样没有任何股票能承受抛售，但仍有很多人安然的持有着存款或股票；从这个意义上来说，银行与这些投资者其实并没有本质区别，盲目的信任其他投资者会继续持有，而成功者总是踩着失败者的尸体在攀登；如同股票一样，庄家与散户不会同时获益，所谓双赢无非是找第三方作为失败者，金融的本质是<strong>零和博弈</strong>：你、中介与银行总有一方是失败者，而这三者中绝对强势的银行注定不败。</span></p>
<p><span style="color: #000000;">说到第三方，普及一个反常识的常识：</span></p>
<div style="text-align: justify;" align="right"><strong><span style="color: #000000;">除非你套的行为一定（must）会被银行发现，否则这个行为总是（always）会导致降额或封卡</span></strong></div>

<p>之所以原谅你说谎，是因为自始就看透了你的谎言；<br>如果被你成功欺骗了，会害怕你欺骗的能力，所以不会原谅你。<br>局外人认为：只有银行发现不了的路子，才能活的长久；这样的路子不会被银行发现是在套。<br>事实的真相是：银行把所有经此消费均认定为套的路子，才能活的长久；因为他是永远的说谎者。<br>被记录在案的“永远说谎者”在某种意义上就是诚实者，当然银行不会承认有一份永久说谎者名单。<br>无论跳码还是套码，银行永远不是吃亏者，只有交足了保护费的说谎者（商户）才有开绿灯的资格。<br>这条食物链里银行拿的是大头，才能保持长期稳定的平衡，虽然银行装受害者，让第三方支付机构背黑锅。</p>
<p>如果你套的行为成功骗过银行电脑系统，那么银行会害怕你的反监控能力，于是就不和你玩了。<br>换句话说，如果你骗过了银行电脑系统，那么一旦被发现，100%被降额封卡，零宽容，零容忍</p>
<p>能长期稳定的路子没有能骗过银行电脑系统的评估和风控的，<br>或者说是已经和银行报备过自己被用来套的路子才能长期存活。<br>当然，丰富账单也是必要的，主要是给银监看的，只要别太过分，银监也装傻；不过，丰富账单对系统评分没卵用</p>
<p>关于代还的认定，这里一般采用池缓冲的概念（最低标准一天两夜，即一晚上加一白天再加一晚上）：<br>任意一笔金额入账时刻止，之前的48/72小时内的总消费入账和总还款入账是银行判定代还的标准：<br>该笔入账及之前48小时内，总消费入账超过额度的70%且总还款入账超过额度的70%则视为代还；<br>该笔入账及之前72小时内，总消费入账超过额度的90%且总还款入账超过额度的90%则视为代还。<br>单笔消费金额/还款金额不作为代还判定要件，相邻两笔消费/还款间的时间间隔不作为代还认定标准</p>
<h1 id="五"><a href="#五" class="headerlink" title="五"></a>五</h1><p><span style="color: #000000;">那年，又到了事业编制的招考，一心想要脱离银行业的我毅然决然的决定备考。幸运地，我考上了，虽然面临着30万的违约金与保密赔偿款<span style="font-size: xx-small;">(已挣回并偿清)</span>，前景也不如在银行那样明朗。但是人没有梦想和咸鱼有什么区别，帮助银行助纣为虐并不是我的理想，从那一刻起，我决定利用银行间的博弈均衡彻底玩弄银行的授信体系，这也许当年的年少轻狂，虽然现在也并不怎么成熟。</span></p>
<p><span style="color: #000000;">不过，这并不是天朝国情决定的，而是资本的本质决定的。</span><br><span style="color: #000000;">即使是传说中刷卡能拒付的美国，拒付其实也没有那么容易成功。</span><br><span style="color: #000000;">在美国（以及大部分资本主义国家）</span><br><span style="color: #000000;">商户分为三类，可信商户、合作商户、普通商户。</span><br><span style="color: #000000;">用户分为三类，受邀用户、高值用户、普通用户。</span><br><span style="color: #000000;">当然，分类标准并不是商户的口碑，而仅仅是商户缴纳的年费，或者说保护费。</span></p>
<p><span style="color: #000000;">当用户等级高于或等于商户等级时，拒付轻松加愉快。</span><br><span style="color: #000000;"> 当用户等级低于          商户等级时，拒付永远失败。</span><br><span style="color: #000000;"> 例如只有受邀用户可以拒付可信商户，受邀用户指银行主动邀请才能办理的高端卡用户，比如运通黑、花旗主席卡</span></p>
<div align="center"><span style="color: #000000;">注意：美国拒付是商户承担资金损失（财货两空）；并不是银行负责赔付</span></div>

<p><span style="color: #000000;">附花旗信用卡协议：</span><br><span style="color: #000000;"> 您不得以未凭密交易、单据上无签名或无交易单据等为由否认交易或拒绝还款。</span></p>
<p><span style="color: #000000;">这里不能不说一下中国的盗刷立案制度，受害人报案制，也就是说：谁的过失谁负责，谁负责谁报案，</span></p>
<div align="center"><span style="color: #000000;">如果是银行的错必须由银行负责报案，如果持卡人泄露的信息则是持卡人进行报案。</span></div>

<p><span style="color: #000000;">如果被盗刷到派出所报案时，一口咬定不是亲友作案，自己也从没泄露过信息，那么肯定立不了案。</span><br><span style="color: #000000;"> 这并非派出所不作为，而是必须提供盗刷信息的泄露途径才能立案；否则，必须银行方面进行报案。</span><br><span style="color: #000000;"> 另一方面，</span><br><span style="color: #000000;"> 除非提供立案材料，否则银行要承担泄露支付信息的刑事风险，(相比于这个风险)钱根本不是问题。</span><br><span style="color: #000000;"> 所有表示银行承认存在可疑交易但拒绝赔付的所谓个人经历一定是软文，银行即使明知也根本不可能承认这一点：</span><br><span style="color: #000000;"> 负责受理盗刷投诉的客服人员只有耍官腔的权力，负责交流细节的只有法务部，律师知道有些真话不能说。</span><br><span style="color: #000000;"> 如果持卡人坚持自己没有泄露过支付信息，但无法提供银行泄露(故意或漏洞)持卡人支付信息的证据：</span><br><span style="color: #000000;"> 那么就会出现银行必须等待立案材料，而派出所表示必须银行方面报案的（伪）踢皮球，形成死锁。</span><br><span style="color: #000000;"> 国内银行赔付信用卡盗刷(名义上)是因为信用卡附赠的保险，但银行不会承认在盗刷事件中存在过错。</span></p>
<h1 id="六"><a href="#六" class="headerlink" title="六"></a>六</h1><p><span style="color: #000000;">说来讽刺，我第一家申请的是单位的工资行——中国银行，然而时至今日仍然没有能够攻略中行白金卡的方法，即使依赖于存款也无济于事，甚至不知道问题出在哪里，或许距离才能产生美。</span></p>
<p><span style="color: #000000;">我得到毕业证的两周后获得了人生中的第一张，不，准确地说是两张校友信用卡，15K的招行，以及半个月之后的建行，只有12K的金卡。</span></p>
<p><span style="color: #000000;">这是一个很讽刺的开局，只有不到3万的额度，却想要玩弄银行的授信体系，这与儿童的妄语其实并没有什么不同。当时，我一度放弃了轻狂的想法；但是讽刺的，成也萧何败也萧何，花旗竟然批复了一张高于当前总额度两倍的卡，即由此，我开始了信用卡的提额之路。</span></p>
<p><table class="t_table" cellspacing="0" bgcolor="#fcfcfc"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td><span style="color: #000000;">退款能否视为还款的通用规则：</span><br><span style="color: #000000;">   账单日之后的退款优先冲抵未出账单； </span><br><span style="color: #000000;">   冲抵未出后余款可用来冲抵已出账单。</span><br><span style="font-size: xx-small; color: #000000;"><br>余款（退款冲抵已出账单部分）：</span><br><span style="color: #000000;">   如果不小于上期账单，视为全额还款；<br>如果小于上期账单，不视为最低还款。</span><br><span style="font-size: xx-small; color: #000000;"><br>当余款小于上期账单时，以下二选一：</span><br><span style="color: #000000;">   ①另行存入达到最低还款额的现金金额</span><br><span style="color: #000000;">   ②补足余款和上期账单全额还款的差额</span></td></p>
<p><td><span style="color: #000000;"><span style="font-size: large;">当天消费入账时刻分节点：</span><span style="font-size: medium;"><br>招商银行：00:00<br>工商银行：06:00【以步步为赢到账为准】<br>中国银行：08:00【中行未持卡，未验证】<br>建设银行：17:00【银联单币：19:00】<br>花旗银行：21:00（浦发银行）【纽约8:00】<br>农业银行：22:00<br>邮储银行：24:00（上海银行）</span></span></td><br><br><br><br>也许是上天眷顾，恰逢建行的清华提额活动，凭借一张清华龙卡和事业单位的工牌从12K直接保送到了100K。而在建行提额的不久，花旗也随之提升了额度，到达了119K，而招商作为我的第一张卡并没有任何变化，此时已经过了2015年的春节，看着手里这三家银行的卡，我决定在将国有银行攻略之前，不再申请其他商业银行的卡，当然交通银行作为股份制重组的银行，并没有在我的日程表之中，取而代之的是出身邮局系统的邮政储蓄银行。</p>
<p>也许是首卡的情怀，或者是对额度的偏执，在申请中行期间，一直不忘关心招行的额度，在第8个多月的时候，招行终于分娩了，奇迹的从15K直接提到了43K，然而这依然是额度最低的一张卡。显然，如果一直保持着低位，必定拉低平均授信额度。最低单行额度反应了你对金融波动承受的幅度，越低的额度意味着你对越低的资金波动反应敏感，银行更关心你的最低单行(含正式销户不足一年)额度，其次才是最高单行(不含已销户)额度。说到信报，顺便提一句：个人明细版和银行打印版信报在信贷交易信息明细后紧接着是查询记录，但是：<br>银行数据版在这两个大类之间还有一个：信贷机构信息明细，这在个人版及银行打印版不体现。<br>包括进行过信用卡审批的所有银行/机构(包括未批卡机构)的列表以及相关数据，此大类下包含：<br>额度使用量峰值(概念类似单月股票最高点)和日均额度占用(概念类似借记卡日均存款)等按机构上报的数据；<br>以及未批卡机构的未批卡原因（一般是”其他原因”，但”进件不实”、”仿真流水”等会以代码形式高亮体现）；<br>以及已销户机构的销整户原因（一般是“个人原因”，但”信贷逾期”、”虚假交易”等会以代码形式高亮体现）。<br>显然，账单日前还款来降低负债(除了自我安慰之外)对银行并没有什么卵用。<br>不过，用来骗小贷公司还是绰绰有余的。</p>
<p>需要特别说明的一点是：即使消掉的账户也不会消失(包括额度)，但是：<br>银行只关心法人机构数，你的信报有多少个账户根本无所谓。</p>
<div class="blockcode"><br><div id="code_kJ4"><br><br>1.  比如建行北京分行发了一张双币卡，建行上海分行发了一张银联单币卡，招行发了一个双币卡。<br>2.  那么你的：<br>3.  账户数是5个。<br>4.  机构数是三个（建行北京分行、建行上海分行、招商银行）<br>5.  法人机构数是两个（建设银行、招商银行）<br></div><br></div>

<p><span style="color: #000000;">接触客户的柜员/客服是看不见具体的拒绝理由的，客服告知的拒批原因都是一本正经的胡说八道。</span><br><span style="color: #000000;">即使你是因为进件身份无法核实真实性，你的理财经理也会在查询之后告诉你是总授信额度过高。</span></p>
<p><span style="color: #000000;">明显的，招行拉低了最低单行的额度，这是有着明确目标的人所不能容忍的；即使现金分期毕业，仍然无法摆脱最低单行的命运；但作为第一张信用卡有一种情怀在里面，所以并没有销卡，而是决定直接申请白金卡；来到支行要了一张白金卡的申请表，也许长相过得去，前台客服并没有为难，轻松地填了银联白的申请表，甚至连信用卡都没有复印，说是查的到；过程很愉快，结局很扯淡，被拒绝了。</span></p>
<p><span style="color: #000000;">这时我才意识到小昭成为了额度的短板，既然柜台不行，那就邮寄；个人邮寄肯定不如柜台，于是另辟蹊径，走了公对公的挂号信邮寄，速度很缓慢，结局很愉快。银联白成功下卡，而且不是起步的6万，直接给了7万。更诡调的是，之后的某一天这张7万的卡被意外的刷空了，竟然还有额度外的现金分期，而这次分期之后的某个周六，恰逢招行大赦天下，又出现了一次分期，此时小昭在一个月之内，额度成为了最高的155K。</span></p>
<h1 id="七"><a href="#七" class="headerlink" title="七"></a>七</h1><p><span style="color: #000000;">关于羊毛或腿毛的性质，内在原理是发卡行对持卡人的定额补偿：</span><br><span style="font-size: medium; color: #000000;">薅羊毛的重点不在于撸没撸，而在于程度是否超过官方福利的阈值标准</span><br><span style="color: #000000;">以招商腿毛卡为例：</span><br>招商金卡正常封顶额度是5万，20元一积分。则50000/20=2500；<br>按每张腿毛卡5000取现计算，可得积分5000/20=250；<br>城市卡每张享有1.5倍积分，两张城市卡相对于3张腿毛卡；<br>因此相对于两张城市卡+7张卡，其中ATM最多取10K单笔，相对于两笔网络，即：<br>每月的标准操作是：两张城市卡+1次ATM取现+5次网络取现；<br><span style="color: #000000;">此时需要，2张城市卡+6张标准腿毛卡，恰为招行推荐的工作地+户籍地城市卡。</span><br><span style="color: #000000;">所以，不难看出：腿毛卡的每月定额补偿积分是以2500分为安全阈值的；</span><br><span style="color: #000000;">无论怎么撸，每月腿毛总收益不超过2500积分就是安全的官方福利；</span><br><span style="color: #000000;">而超过2500分/月就会带来各种各样的评分下降，月撸几十张城市卡的也就呵呵了。</span></p>
<p><span style="color: #000000;">招行达到最高额度之后，我彷徨了；是去申请工商还是先搞定中行？犹豫中，老农来单位推自己的尊然白金卡，只要持卡行在2~5行，单行额度不低于10万的在职职工都能保送尊然白，而且返还首年年费，恰好低空飞过标准线，蒙蒙的填了表，但意外的批了卡，这时我才知道这张没听说过的精粹白是什么卡种。</span></p>
<p><span style="color: #000000;">拿到精粹白的时候，信心嫉妒膨胀，传说中的邮储白成为了奋斗的目标，便无视了中行和工商。当时邮储还没有小白金，邮储白的逼格令我心驰神往，恰逢正式成为副主任科员，当然这在我们单位内算是比较常见的级别，也还属于小兵的范畴。</span></p>
<p><span style="color: #000000;">但是，年轻嘛，不试试怎么行？于是壮着胆子就去了，由于招商成功的经验，我自认为毫无问题，然而连申请表都没有拿到，就被赶了出来。这能忍？当然不能，于是尝试了各种网点，得到的结果都是一样的：白金信用卡没有申请表。</span></p>
<p><span style="color: #000000;">邮储碰壁后，就又开始了工商和中行的申请，恰逢大妈推广大来白金卡，于是工商的大来白成功填了表，当然只是试试看根本没报多大希望，毕竟工行连储蓄账户都没有，而中行那也屡战屡败。结果出乎意料，大来白金卡批了（初始额度不高，后来在和电话客服扯淡时，意外的发现能提额，这是后话）；而中国银行一如既往的坚定，申请失败。</span></p>
<p><span style="color: #000000;">这里说明一下刷卡与费率的问题：</span><br><span style="color: #000000;"><span style="font-size: medium;">如果某档费率的月消费金额不超过月总消费金额的5%，则该费率不计评分</span>。</span><br><span style="color: #000000;">以某月刷卡消费66K<span style="font-size: xx-small;">（注意：不是账单金额）</span>为例：</span><br><span style="color: #000000;">某费率下的总消费金额低于3.3K，则这些消费不会增加评分，更不会减分。</span><br><span style="color: #000000;">对于月消费6万多的持卡人，总额两三千的几笔消费，1.25与刷封顶的效果是完全一样的。</span><br><span style="color: #000000;">所以，不必对偶尔遇到的小额套码耿耿于怀，因为根本无所谓（即使是三农或者封顶）。</span><br><span style="color: #000000;">同样，对于月消费数万元的账户，用小额多笔高费率来美化账单其实也并没有什么卵用。</span></p>
<div class="blockcode"><br><div id="code_BAn"><br><br>1.  <span style="color: #000000;">注：66K和3.3K这两个数值很熟悉吧，提醒一下：</span><br>2.  <span style="color: #000000;">建行：45K<em>(1+50%)=67.5K（你懂得）</em></span><br>3.  <span style="color: #000000;">中行：50K(1+30%)=65K（搬砖办卡）</span><br>4.  <span style="color: #000000;">招行：60K+5K=65K（现金分期）</span><br>5.  <span style="color: #000000;">封顶：26/0.78%=3.333K</span><br></div><br></div><br><span style="color: #000000;">元旦左右，坐飞机回北京，想着15号线比机场线换乘走的路要少（13号线的步行距离你懂的），于是乘坐了空港3路，诡吊的是在天竺村附近车抛锚了，地图上看附近有家邮储支行就又去试了试，结果意外的凭工牌和精粹白填了一张表（虽然没要精粹白的复印件），更意外的是竟然批卡了，虽然是所有银行额度最低的一张卡，但总归里离集齐国有行更近了一步。</span><br><br><span style="color: #000000;">虽然，第一家申请的信用卡，到现在还没有攻略成功……</span><br><br># 八<br><br><span style="color: #000000;">最后，告诫诸位：</span><br><br><span style="color: #000000;">信用卡套出来锦上添花，会成为卡神；套出来用于苟延残喘，则更加卡奴。</span><br><br><span style="color: #000000;">当不用也过得去，就放心大胆的用，不用来生钱的钱不过是一堆废纸。</span><br><span style="color: #000000;">当不用就过不去，请千万别用，否则不过是饮鸩止渴。</span><br><br><span style="color: #000000;">卡神与卡奴的核心不在于奇技淫巧，而在于是否有额度外的存款使之活盘。</span><br><br><span style="color: #000000;">如果已经负资产，同样也有成为卡神的机会，但请确保手上的闲置存款不要低于总负债的20%。</span><br><span style="color: #000000;">看起来这样的闲置负债将加大利息成本，但请记住只有资金是活盘的总还有希望。</span><br><br><strong><span style="color: #000000;">当闲置存款低于负债的16.5%这条活盘警戒线超过7日，终会被债务拖垮，万劫不复。</span></strong><br><br><span style="color: #000000;">注：闲置存款不限于定活期：<br>余额宝、招行朝朝盈等能实时取现的都算闲置存款，但不包括各种封闭期禁止取款的理财产品。</span><br><br><span style="color: #000000;">建行看重代发收入<span style="font-size: xx-small;">(象征国家建设的贡献)           </span>中行看重行内存款<span style="font-size: xx-small;">(象征国库保障的需要)</span></span><br><br><span style="color: #000000;">工商看重理财贡献<span style="font-size: xx-small;">(象征以钱生钱的能力</span><span style="font-size: xx-small;">)           </span>农行看重单位性质<span style="font-size: xx-small;">(象征术业专攻的特性)</span></span><br><br><span style="font-size: large; color: #000000;">附录：销卡威胁处理流程</span><br><br><div class="blockcode"><br><br>1.  <span style="color: #000000;">销卡不销户？是，下一步；否，转第3步；</span><br>2.  <span style="color: #000000;">销卡成功，结束。</span><br>3.  <span style="color: #000000;">确认用户诉求并挽留？无需销户，下一步；销户，转第5步；</span><br>4.  <span style="color: #000000;">客户是否有其他诉求（如：提额、年费优惠）？是，下一步；否，转第2步；</span><br>5.  <span style="color: #000000;">不可逆确认？是，下一步；否，转第2步；</span><br>6.  <span style="color: #000000;">系统评测是否通过客户诉求？是，下一步；否，转第8步；</span><br>7.  <span style="color: #000000;">客户同意系统评测结果？是，调整后结束；否，下一步；</span><br>8.  <span style="color: #000000;">系统评测客户综合评分？高，下一步；一般或较低，转第10步；</span><br>9.  <span style="color: #000000;">客户是否反悔销户请求？是，结束；否，下一步；</span><br>10.  <span style="color: #000000;">销户成功，不可恢复，结束。</span><br></div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UWP开发笔记八：简单的RSS阅读器]]></title>
      <url>http://yoursite.com/2016/05/04/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%85%AB%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84RSS%E9%98%85%E8%AF%BB%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>一个简单的RSS阅读器，实现任意开启RSS网站内容订阅，不过，只能在阅读器中搜集到标题、日期。后期再补充。</p>
<p>这次起，把所有功能代码放在类中，MainPage不能再那么随便了。</p>
<p>新建RSSClass类：</p>
<pre class="lang:default decode:true ">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
// ItemsControl
using Windows.UI.Xaml.Controls;
// KeyRoutedEventArgs 
using Windows.UI.Xaml.Input;
// SyndicationClient 
using Windows.Web.Syndication;

namespace RSS阅读器
{
  public   class RssClass
    {
        // 下载指定url的feed条目，逐一将其整合到集合控件ItemsControl中
        private async void Load(ItemsControl list,Uri url)
        {
            // 从URL异步检索源
            SyndicationClient client = new SyndicationClient();
            // 开始一个异步操作以下载从给定的URI的聚合feed。
            SyndicationFeed feed =await client.RetrieveFeedAsync(url);
            // 遍历feed中的所有item，将其添加到list中
            foreach (var item in feed.Items)
            {
                list.Items.Add(item);
            }
        }

        // 
        public void Start(ref ItemsControl list,string url,KeyRoutedEventArgs args)
        {
            // 当按下回车键时
            if (args.Key== Windows.System.VirtualKey.Enter)
            {
                try
                {
                    Load(list, new Uri(url));
                }
                catch (Exception)
                {

                    throw;
                }
                // 设置控件的焦点
                list.Focus(Windows.UI.Xaml.FocusState.Keyboard);
            }
        }
    }
}
</pre>
页面代码：
<pre class="lang:default decode:true "> &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height="Auto"/&gt;
            &lt;RowDefinition Height="*"/&gt;
        &lt;/Grid.RowDefinitions&gt;
        &lt;TextBox Name="URLTextBox"
                 Margin="10"
                 KeyDown="URLTextBox_KeyDown"
                 PlaceholderText="请输入RSS地址"/&gt;
        &lt;ScrollViewer VerticalScrollBarVisibility="Auto"
                      HorizontalScrollBarVisibility="Auto"
                      Margin="20"
                      Grid.Row="1"&gt;

            &lt;ItemsControl Name="ListItemsControl"&gt;
                    &lt;ItemsControl.ItemTemplate&gt;
                        &lt;!--数据模板--&gt;
                        &lt;DataTemplate&gt;
                        &lt;StackPanel&gt;
                            &lt;!--超链接--&gt;
                            &lt;HyperlinkButton NavigateUri="{Binding Path=Links[0].Uri}"&gt;
                                &lt;!--超链接标题--&gt;
                                &lt;HyperlinkButton.Content&gt;
                                    &lt;TextBlock Text="{Binding Path=Title.Text}"/&gt;
                                &lt;/HyperlinkButton.Content&gt;
                            &lt;/HyperlinkButton&gt;

                            &lt;!--文章日期--&gt;
                            &lt;TextBlock Text="{Binding Path=PublishedDate}"/&gt;
                        &lt;/StackPanel&gt;
                        &lt;/DataTemplate&gt;
                    &lt;/ItemsControl.ItemTemplate&gt;
                &lt;/ItemsControl&gt;

        &lt;/ScrollViewer&gt;
</pre>
cs逻辑代码：
<pre class="lang:default decode:true "> private RssClass rss = new RssClass();
        private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
        {
            rss.Start(ref ListItemsControl, URLTextBox.Text, e);
        }</pre>
明显清晰许多。![](http://images.chenyalun.cn/2016/04/23/005.png)

原谅我又无耻地用了自己网站的RSS源做示例。

* * *

* * *

* * *

## &gt;&gt;笔记

*   #### ItemsControl的数据绑定：
<pre class="lang:default decode:true">&lt;ItemsControl Name="ListItemsControl"&gt;
            &lt;ItemsControl.ItemTemplate&gt;
                             &lt;DataTemplate&gt;

                              &lt;/DataTemplate&gt;
             &lt;/ItemsControl.ItemTemplate&gt;
&lt;/ItemsControl&gt;</pre>

<ul>
<li><h4 id="ScrollViewer的两个属性："><a href="#ScrollViewer的两个属性：" class="headerlink" title="ScrollViewer的两个属性："></a>ScrollViewer的两个属性：</h4><p>VerticalScrollBarVisibility=”Auto”<br>HorizontalScrollBarVisibility=”Auto”</p>
</li>
<li><h4 id="绑定RSS内容："><a href="#绑定RSS内容：" class="headerlink" title="绑定RSS内容："></a>绑定RSS内容：</h4><p>链接：<strong> </strong>&lt;HyperlinkButton NavigateUri=”{Binding Path=<strong>Links[0].Uri</strong>}”&gt;</p>
</li>
</ul>
<p>链接标题：&lt;TextBlock Text=”{Binding Path=<strong>Title.Text</strong>}”/&gt;</p>
<p>文章日期：&lt;TextBlock Text=”{Binding Path=<strong>PublishedDate</strong>}”/&gt;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UWP开发笔记七：WebView与简单浏览器]]></title>
      <url>http://yoursite.com/2016/05/02/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%EF%BC%9AWebView%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>利用webview控件可以简单制作一个浏览器，实现基本的前进、后退、刷新、停止等功能。不过需要注意的是，如果网页是在新窗口打开，那就承受不了了，将自动用系统默认浏览器打开。所以，前进、后退功能的前提是：打开的网页是在同一个窗口。</p>
<p>命令栏代码：</p>
<p><pre class="lang:default decode:true ">&lt;Page.BottomAppBar&gt;<br>        &lt;AppBar IsOpen=”True”&gt;<br>            &lt;StackPanel Orientation=”Horizontal”&gt;<br>                &lt;AppBarButton Name=”BackAppBarButton”<br>                              Click=”BackAppBarButton_Click”<br>                              Label=”返回”<br>                              Icon=”Back”/&gt;<br>                &lt;AppBarButton Name=”ForwardAppBarButton”<br>                              Label=”前进”<br>                              Icon=”Forward”<br>                              Click=”ForwardAppBarButton_Click”/&gt;<br>                &lt;AppBarButton Name=”RefreshAppBarButton”<br>                              Label=”刷新”<br>                              Icon=”Refresh”<br>                              Click=”RefreshAppBarButton_Click”/&gt;<br>                &lt;AppBarButton Name=”StopAppBarButton”<br>                              Click=”StopAppBarButton_Click”<br>                              Label=”停止”<br>                              Icon=”Stop”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.BottomAppBar&gt;</pre><br>页面：</p>
<p><pre class="lang:default decode:true ">&lt;Grid.RowDefinitions&gt;<br>            &lt;RowDefinition Height=”Auto”/&gt;<br>            &lt;RowDefinition Height=”*”/&gt;<br>        &lt;/Grid.RowDefinitions&gt;<br>        &lt;TextBox Name=”URLTextBox”<br>                 InputScope=”Url”<br>                 KeyDown=”URLTextBox_KeyDown”<br>                 Margin=”20”/&gt;<br>        &lt;WebView Name=”Web”<br>                 Grid.Row=”1”<br>                 NavigationCompleted=”Web_NavigationCompleted”/&gt;</pre></p>
<pre><code>&amp;lt;/Grid&amp;gt;&lt;/pre&gt;
</code></pre><p>后台逻辑：</p>
<p><pre class="lang:default decode:true "> // 返回处理<br>        private void BackAppBarButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            if (Web.CanGoBack)<br>            {<br>                Web.GoBack();<br>            }<br>        }</pre></p>
<pre><code>// 前进处理
private void ForwardAppBarButton_Click(object sender, RoutedEventArgs e)
{
    if (Web.CanGoForward)
    {
        Web.GoForward();
    }
}

// 刷新
private void RefreshAppBarButton_Click(object sender, RoutedEventArgs e)
{
    Web.Refresh();
}

// 停止
private void StopAppBarButton_Click(object sender, RoutedEventArgs e)
{
    Web.Stop();
}

// 按（回车）键处理
private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
{
    // 如果按下的键是回车键
    if (e.Key== Windows.System.VirtualKey.Enter)
    {
        // 导航到文本框中的地址
        Web.Navigate(new Uri(URLTextBox.Text));
    }

    // 处理焦点
    Web.Focus(FocusState.Keyboard);
}

// 导航完成事件处理
private void Web_NavigationCompleted(WebView sender, WebViewNavigationCompletedEventArgs args)
{
    // 导航是否成功
    if (args.IsSuccess)
    {
        // 参数传递到地址栏
        URLTextBox.Text = args.Uri.ToString();
    }

}&lt;/pre&gt;
</code></pre><p>可以看到效果(原谅我无耻地用了自己的博客）：</p>
<p>初始页面：<img src="http://images.chenyalun.cn/2016/04/23/001.png" alt=""></p>
<p>打开新链接：</p>
<p><img src="http://images.chenyalun.cn/2016/04/23/002.png" alt=""></p>
<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><p>对键盘的按键（回车）键处理：<br>private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)<br>{<br>// 如果按下的键是回车键<br>if (e.Key== Windows.System.VirtualKey.Enter)<br>{<br>// 导航到文本框中的地址<br>Web.Navigate(new Uri(URLTextBox.Text));<br>}<br>}</p>
<p>对焦点的处理：<br>Web.Focus(FocusState.Keyboard);</p>
<p>还有就是，文本框（地址栏）输入的文本必须是URL，即 <a href="http://www.chenyalun.cn/如果是www.chenyalun.cn那就会报错了。" target="_blank" rel="external">http://www.chenyalun.cn/如果是www.chenyalun.cn那就会报错了。</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UWP开发笔记六：幸运彩色小球]]></title>
      <url>http://yoursite.com/2016/04/30/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9A%E5%B9%B8%E8%BF%90%E5%BD%A9%E8%89%B2%E5%B0%8F%E7%90%83/</url>
      <content type="html"><![CDATA[<p>这个和<a href="http://www.chenyalun.cn/uwp开发笔记四：随机数与筛子游戏.html" target="_blank" rel="external">UWP开发笔记四：随机数与筛子游戏</a>有异曲同工之妙，通过随机函数产生一定范围大小的数字，根据数字大小设定不同的颜色，点击命令栏的新建按钮，面板清空，重新产生一轮数字。</p>
<p>命令栏：</p>
<p><pre class="lang:default decode:true ">&lt;Page.BottomAppBar&gt;<br>        &lt;AppBar&gt;<br>            &lt;StackPanel Orientation=”Horizontal”&gt;<br>                &lt;AppBarButton Name=”NewAppBarButton”<br>                              Label=”新建”<br>                              Icon=”NewFolder”<br>                              Click=”NewAppBarButton_Click”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.BottomAppBar&gt;</pre><br>页面代码：</p>
<p><pre class="lang:default decode:true ">&lt;StackPanel HorizontalAlignment=”Center”<br>            VerticalAlignment=”Center”<br>            Name=”DisplayStackPanel”<br>                    Orientation=”Horizontal”/&gt;</pre><br>当然，为了方便起见，创建一个ShowBall类：需要引入的命名空间有：</p>
<p>//Thickness<br>using Windows.UI.Xaml;<br>//控件<br>using Windows.UI.Xaml.Controls;<br>//SolidColorBrush<br>using Windows.UI.Xaml.Media;<br>//球<br>using Windows.UI.Xaml.Shapes;</p>
<p>完整代码：</p>
<p><pre class="lang:default decode:true ">using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>//color<br>using Windows.UI;</pre></p>
<p>//Thickness<br>using Windows.UI.Xaml;<br>//控件<br>using Windows.UI.Xaml.Controls;<br>//SolidColorBrush<br>using Windows.UI.Xaml.Media;<br>//球<br>using Windows.UI.Xaml.Shapes;</p>
<p>namespace Lucky_Lotto<br>{<br>   public  class ShowBall<br>    {<br>        // 定义随机数(种子为日期和时间的计时周期）<br>        private Random random = new Random((int)DateTime.Now.Ticks);</p>
<pre><code>    // 定义获取数字集合方法
    private List&amp;lt;int&amp;gt; GetNumbers()
    {
        int Number;
        // 定义Numbers集合
        List&amp;lt;int&amp;gt; Numbers = new List&amp;lt;int&amp;gt;();
        // 当Numbers集合中整数个数小于6时，自动增加
        while (Numbers.Count &amp;lt; 6)
        {
            // 随机获取1到50之间的整数赋予Number（Number可以取1，不可取50）
            Number = random.Next(1, 50);
            // 将产生的随机数添加到集合之中
            // 处理当集合中的整数与产生的随机数相同的情况
            if (!Numbers.Contains(Number)||Number&amp;lt;1)
            {
                Numbers.Add(Number);
            }
            // 对集合中的数字进行有序整理（美观起见）
            Numbers.Sort();
        }

        return Numbers;

    }
    // 对StackPanel进行处理：创建小球，增添颜色等
    // 将每个小球分别放在Canva中s，6个Canvas放在一个StackPanel中
    public void PlayBall(ref StackPanel stackpanel)
    {
        // 清空原先讯在的元素
        stackpanel.Children.Clear();

        // 对数字集合遍历
        foreach(int number in GetNumbers())
        {
            // 定义Canvas
            Canvas canvas = new Canvas();
            canvas.Width = 48;
            canvas.Height = 48;
            canvas.Margin = new Thickness(2);

            // 定义球
            Ellipse ellipse = new Ellipse();
            ellipse.Width = canvas.Width;
            ellipse.Height = canvas.Height;
            // 设置小球边框颜色是黑色
            ellipse.Stroke = new SolidColorBrush(Colors.Black);

            // 根据数字的大小设置小球的填充颜色
            if (number &amp;gt;= 1 &amp;amp;&amp;amp; number &amp;lt;= 9)
            {
                ellipse.Fill = new SolidColorBrush(Colors.White);
            }
            else if (number &amp;gt; 9 &amp;amp;&amp;amp; number &amp;lt;= 19)
            {
                ellipse.Fill = new SolidColorBrush(Color.FromArgb(255, 112, 200, 236));
            }
            else if (number &amp;gt; 19 &amp;amp;&amp;amp; number &amp;lt;= 29)
            {
                ellipse.Fill = new SolidColorBrush(Colors.Magenta);
            }
            else if (number &amp;gt; 29 &amp;amp;&amp;amp; number &amp;lt;= 39)
            {
                ellipse.Fill = new SolidColorBrush(Color.FromArgb(255, 112, 255, 0));
            }
            else if (number &amp;gt; 39 &amp;amp;&amp;amp; number &amp;lt;= 49)
            {
                ellipse.Fill = new SolidColorBrush(Colors.Yellow);
            }

            // 定义球中的文本（数字）
            TextBlock textBlock = new TextBlock();
            textBlock.Text = number.ToString();
            textBlock.FontSize = 16;
            textBlock.Foreground = new SolidColorBrush(Colors.Black);
            textBlock.Margin = new Thickness(16, 12, 16, 12);

            // 将文本（数字）、小球添加到canvas中，将canvas添加到stackpanel中
            // 一定先添加球，再添加文本，否则文本不会显示
            canvas.Children.Add(ellipse);
            canvas.Children.Add(textBlock);
            stackpanel.Children.Add(canvas);
        }
    }
}
</code></pre><p>}<br><br>这样主页面的后台代码就可以轻松的调用了：</p>
<p><pre class="lang:default decode:true "> // 新建类的实例<br>        public  ShowBall showball = new ShowBall();<br>        private void NewAppBarButton_Click(object sender, RoutedEventArgs e)<br>        {</pre></p>
<pre><code>  showball.PlayBall(ref DisplayStackPanel);
}&lt;/pre&gt;
</code></pre><p>演示：</p>
<p><img src="http://images.chenyalun.cn/2016/04/22/001.png" alt=""><img src="http://images.chenyalun.cn/2016/04/22/002.png" alt=""></p>
<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><p>// 对数字集合遍历<br>foreach(int number in GetNumbers())  {}</p>
<p>// 设置小球边框颜色是黑色<br>ellipse.Stroke = new SolidColorBrush(Colors.Black);</p>
<p>//设置margin</p>
<p>textBlock.Margin = new Thickness(16, 12, 16, 12);</p>
<p>// 一定先添加球，再添加文本，否则文本不会显示<br>canvas.Children.Add(ellipse);<br>canvas.Children.Add(textBlock);<br>stackpanel.Children.Add(canvas);</p>
<p>// 清空原先存在的元素<br>stackpanel.Children.Clear();</p>
<p>// 对集合中的数字进行有序整理（美观起见）<br>Numbers.Sort();</p>
<p>// 定义随机数(种子为日期和时间的计时周期）<br>private Random random = new Random((int)DateTime.Now.Ticks);</p>
<p>// 定义Numbers集合<br>List&lt;int&gt; Numbers = new List&lt;int&gt;();</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UWP开发笔记五：应用数据本地存储]]></title>
      <url>http://yoursite.com/2016/04/28/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%9A%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
      <content type="html"><![CDATA[<p>应用数据存储有两种形式，一种存储在本地，另一种是漫游到云端。输入信息，保存在本地，点击显示按钮，重新显现刚刚输入的信息。</p>
<p>命令栏代码：</p>
<p><pre class="lang:default decode:true ">&lt;Page.BottomAppBar&gt;<br>        &lt;AppBar&gt;<br>            &lt;StackPanel Orientation=”Horizontal”&gt;<br>                &lt;AppBarButton Name=”NewAppBarButton”<br>                              Icon=”Page”<br>                              Label=”新建”<br>                              Click=”NewAppBarButton_Click”/&gt;<br>                &lt;AppBarButton Name=”LoadAppBarButton”<br>                              Icon=”Folder”<br>                              Label=”显示”<br>                              Click=”LoadAppBarButton_Click”/&gt;<br>                &lt;AppBarButton Name=”SaveAppBarButton”<br>                              Icon=”Save”<br>                              Label=”保存”<br>                              Click=”SaveAppBarButton_Click”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.BottomAppBar&gt;</pre><br>页面代码：</p>
<p><pre class="lang:default decode:true "> &lt;StackPanel&gt;<br>            &lt;TextBox Name=”Email”<br>                     PlaceholderText=”邮箱”<br>                     Margin=”20”<br>                     InputScope=”EmailSmtpAddress”/&gt;<br>            &lt;TextBox Name=”Web”<br>                     PlaceholderText=”网址”<br>                     Margin=”20”<br>                     InputScope=”Url”/&gt;<br>            &lt;TextBox Name=”Tel”<br>                     PlaceholderText=”手机号码”<br>                     Margin=”20”<br>                     InputScope=”TelephoneNumber”/&gt;<br>        &lt;/StackPanel&gt;</pre><br>后台逻辑：</p>
<p><pre class="lang:default decode:true ">  //  新建存储<br>        private void NewAppBarButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            Email.Text = string.Empty;<br>            Web.Text = string.Empty;<br>            Tel.Text = string.Empty;<br>        }</pre></p>
<pre><code>// 保存信息
private void SaveAppBarButton_Click(object sender, RoutedEventArgs e)
{
    Save(&quot;Email&quot;, Email.Text);
    Save(&quot;Web&quot;, Web.Text);
    Save(&quot;Tel&quot;, Tel.Text);
}

// 加载存储信息
private void LoadAppBarButton_Click(object sender, RoutedEventArgs e)
{
    Email.Text = Load(&quot;Email&quot;);
    Web.Text = Load(&quot;Web&quot;);
    Tel.Text = Load(&quot;Tel&quot;);
}

// 应用本地设置信息存储:保存 键 值
public void Save(string key,string value)
{
    ApplicationData.Current.LocalSettings.Values[key] = value;
}

// 加载应用本地设置存储的信息
public string Load(string key)
{
    if (ApplicationData.Current.LocalSettings.Values[key]!=null)
    {
        return ApplicationData.Current.LocalSettings.Values[key].ToString();
    }

    return string.Empty;
}&lt;/pre&gt;
</code></pre><p>输入信息并保存：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/005.png" alt=""></p>
<p>点击新建清空数据，点击显示：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/006.png" alt=""></p>
<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><ul>
<li>空字符串：string.Empty</li>
<li>保存的方式为键值对：key和value</li>
<li>本地设置类： ApplicationData.Current.LocalSettings.Values[key] = value;其中key一般是字符串，value是保存的值</li>
<li>需要引入命名空间：应用数据存储  using Windows.Storage;</li>
<li>删除存储 ApplicationData.Current.LocalSettings.Values.Remove(“key”); 其中key是键<br>&nbsp;</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UWP开发笔记四：随机数与筛子游戏]]></title>
      <url>http://yoursite.com/2016/04/26/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E7%AD%9B%E5%AD%90%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<p>点击方块，方块随机出现类似筛子的点数，连续点击，连续出现随机的数。当然，是有两个方块的。点击底部命令栏的刷新按钮，两块“筛子”均恢复空白状态。</p>
<p>命令栏：</p>
<p><pre class="lang:default decode:true ">&lt;Page.BottomAppBar&gt;<br>        &lt;AppBar&gt;<br>            &lt;StackPanel Orientation=”Horizontal”&gt;<br>                    &lt;AppBarButton Name=”NewAppBarButton”<br>                                  Icon=”Page”<br>                                  Click=”NewAppBarButton_Click”<br>                                  Label=”刷新”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.BottomAppBar&gt;</pre><br>页面代码：</p>
<p><pre class="lang:default decode:true "> &lt;Grid.ColumnDefinitions&gt;<br>            &lt;ColumnDefinition Width=”<em>“/&gt;<br>            &lt;ColumnDefinition Width=”Auto”/&gt;<br>            &lt;ColumnDefinition Width=”</em>“/&gt;<br>            &lt;ColumnDefinition Width=”Auto”/&gt;<br>            &lt;ColumnDefinition Width=”*”/&gt;<br>        &lt;/Grid.ColumnDefinitions&gt;</pre></p>
<pre><code>    &amp;lt;Grid Name=&quot;FirstGrid&quot;
          Tapped=&quot;FirstGrid_Tapped&quot;
          Width=&quot;100&quot;
          Height=&quot;100&quot;
          Background=&quot;HotPink&quot;
          Grid.Column=&quot;1&quot;&amp;gt;
        &amp;lt;Grid.RowDefinitions&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;/Grid.RowDefinitions&amp;gt;
        &amp;lt;Grid.ColumnDefinitions&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;/Grid.ColumnDefinitions&amp;gt;
    &amp;lt;/Grid&amp;gt;

&amp;lt;Grid Name=&quot;SecondGrid&quot;
          Tapped=&quot;SecondGrid_Tapped&quot;
          Width=&quot;100&quot;
          Height=&quot;100&quot;
          Background=&quot;HotPink&quot;
          Grid.Column=&quot;3&quot;&amp;gt;
    &amp;lt;Grid.RowDefinitions&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
    &amp;lt;/Grid.RowDefinitions&amp;gt;
    &amp;lt;Grid.ColumnDefinitions&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
    &amp;lt;/Grid.ColumnDefinitions&amp;gt;

&amp;lt;/Grid&amp;gt;&lt;/pre&gt;
</code></pre><p>后台代码MainPage.xaml.cs：</p>
<p>引入命名空间：</p>
<p><pre class="lang:default decode:true ">//颜色<br>using Windows.UI;<br>//图形<br>using Windows.UI.Xaml.Shapes;</pre><br>逻辑代码：</p>
<p><pre class="lang:default decode:true"> private void NewAppBarButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            //刷新页面<br>            FirstGrid.Children.Clear();<br>            SecondGrid.Children.Clear();<br>        }</pre></p>
<pre><code>    private void FirstGrid_Tapped(object sender, TappedRoutedEventArgs e)
    {
        // 移除面板上所有元素
        FirstGrid.Children.Clear();
        switch (Number())
        {
            case 0:
            case 1:
                Add(FirstGrid, 1, 1);
                break;
            case 2:
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 0);
                break;
            case 3:
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 1, 1);
                Add(FirstGrid, 2, 0);
                break;
            case 4:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 0);
                Add(FirstGrid, 2, 2);
                break;
            case 5:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 2);
                Add(FirstGrid, 1, 1);
                Add(FirstGrid, 2, 0);
                break;
            case 6:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 1, 0);
                Add(FirstGrid, 1, 2);
                Add(FirstGrid, 2, 0);
                Add(FirstGrid, 2, 2);
                break;
        }
    }

// 设置随机数
    public int Number()
    {
        // 返回0到7之间的随机整数
        return new Random().Next(0, 7);
    }

    // 设置添加圆点
    public void Add(Grid grid, int row, int col)
    {

        Ellipse ell = new Ellipse();
        // 设置填充颜色
        ell.Fill = new SolidColorBrush(Colors.White);
        // 设置宽高度
        ell.Width = 20;
        ell.Height = 20;
        // 设置圆点的在表格上的位置
        ell.SetValue(Grid.RowProperty, row);
        ell.SetValue(Grid.ColumnProperty, col);
        // 获取面板元素（把ell元素添加到面板中）
        grid.Children.Add(ell);
    }

    private void SecondGrid_Tapped(object sender, TappedRoutedEventArgs e)
    {
        // 移除面板上所有元素
        SecondGrid.Children.Clear();
        switch (Number())
        {
            case 0:
            case 1:
                Add(SecondGrid, 1, 1);
                break;
            case 2:
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 0);
                break;
            case 3:
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 1, 1);
                Add(SecondGrid, 2, 0);
                break;
            case 4:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 0);
                Add(SecondGrid, 2, 2);
                break;
            case 5:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 2);
                Add(SecondGrid, 1, 1);
                Add(SecondGrid, 2, 0);
                break;
            case 6:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 1, 0);
                Add(SecondGrid, 1, 2);
                Add(SecondGrid,2, 0);
                Add(SecondGrid, 2, 2);
                break;
        }
    }&lt;/pre&gt;
</code></pre><p>点击出现筛子点数：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/001.png" alt=""></p>
<p>点击刷新按钮，清空所有元素：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/002.png" alt=""></p>
<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><ul>
<li><h3 id="随机数："><a href="#随机数：" class="headerlink" title="随机数："></a>随机数：</h3></li>
</ul>
<p>Random()与时间相关的种子；</p>
<p>Random(seed)指定种子；</p>
<p>Random().NextDouble返回大于或等于0.0且小于1.0的随机浮点数；</p>
<p>Random().Next()返回非负随机整数；</p>
<p>Random().Next(下限，上限)返回指定范围非负随机整数（可取下限，不可取上限）；</p>
<h3 id="设置图形依赖属性："><a href="#设置图形依赖属性：" class="headerlink" title="设置图形依赖属性："></a>设置图形依赖属性：</h3><p>Ellipse ell = new Ellipse();</p>
<p>// 设置填充颜色<br>ell.Fill = new SolidColorBrush(Colors.White);</p>
<p>// 设置圆点的在表格上的位置<br>ell.SetValue(Grid.RowProperty, row);<br>ell.SetValue(Grid.ColumnProperty, col);<br>// 获取面板元素（把ell元素添加到面板中）<br>grid.Children.Add(ell);</p>
<p>// 移除面板上所有元素<br>SecondGrid.Children.Clear();</p>
<p>总结：代码比较琐碎，而且不是很令人满意，xaml创建图形很方便，可是处理逻辑的时候没有思路，只好把图形创建的代码写在后台。本想写个方法同时处理两个方块，然而并没有成功〒_〒</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UWP开发笔记三：动画编程之图形的翻转]]></title>
      <url>http://yoursite.com/2016/04/24/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E5%8A%A8%E7%94%BB%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9B%BE%E5%BD%A2%E7%9A%84%E7%BF%BB%E8%BD%AC/</url>
      <content type="html"><![CDATA[<p>动画编程可以实现很酷的很炫的效果，能让开发出的App散发无穷无尽的魅力，在颜值至上的时代，好看是检验UI的唯一标准。图形的翻转主要有三种形式：RotationX，RotationY，RotationZ，就是获取或设置围绕旋转的 X 轴或Y轴或Z轴旋转对象的角度。</p>
<p>计划在文本框中键入图片的地址源，按回车载入图片，点击命令栏中按钮，图片做出相应变换。</p>
<p>XAML代码：</p>
<pre class="lang:default decode:true ">&lt;!--命令栏--&gt;
    &lt;Page.BottomAppBar&gt;
        &lt;AppBar IsSticky="True"&gt;
            &lt;StackPanel Orientation="Horizontal" HorizontalAlignment="Right"&gt;
            &lt;AppBarButton Name="XRotateAppBarButton"
                          Icon="RepeatAll"
                          Label="Pitch"
                          Click="XRotateAppBarButton_Click"/&gt;
            &lt;AppBarButton Name="YRotateAppButton"
                          Icon="Rotate"
                          Label="Roll"
                          Click="YRotateAppButton_Click"/&gt;
            &lt;AppBarButton Name="ZRotateAppBarButton"
                          Icon="Refresh"
                          Label="Yaw"
                          Click="ZRotateAppBarButton_Click"/&gt;
            &lt;/StackPanel&gt;

        &lt;/AppBar&gt;
    &lt;/Page.BottomAppBar&gt;

    &lt;!--动画--&gt;
    &lt;Page.Resources&gt;
        &lt;!--X方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardX"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationX)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;

        &lt;!--Y方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardY"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationY)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;

        &lt;!--Z方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardZ"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationZ)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;
    &lt;/Page.Resources&gt;

    &lt;Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height="Auto"/&gt;
            &lt;RowDefinition Height="Auto"/&gt;
            &lt;RowDefinition Height="*"/&gt;
        &lt;/Grid.RowDefinitions&gt;
        &lt;TextBlock Text="请输入图片的地址"
                   HorizontalAlignment="Center"
                   Height="30"/&gt;
        &lt;TextBox  Grid.Row="1"
                  Name="URLTextBox"
                   FontSize="20"
                   HorizontalAlignment="Stretch"
                   Height="40"
                   Margin="20"
                   InputScope="Url"
                   KeyDown="URLTextBox_KeyDown"/&gt;
        &lt;Image Grid.Row="2"
               Name="ResultImage"
               Margin="60"
               Stretch="Uniform"&gt;
            &lt;!--注意一定要声明-Projection属性--&gt;
            &lt;Image.Projection&gt;
                &lt;PlaneProjection /&gt;
            &lt;/Image.Projection&gt;
        &lt;/Image&gt;
    &lt;/Grid&gt;</pre>
原图：

![](http://images.chenyalun.cn/2016/04/20/101.png)

X轴翻转:

![](http://images.chenyalun.cn/2016/04/20/102.gif)

&nbsp;

Y轴翻转：![](http://images.chenyalun.cn/2016/04/20/103.gif)

以及Z轴翻转：![](http://images.chenyalun.cn/2016/04/20/104.gif)

CS 代码（主要是获取文本框中的URL，以及处理按钮事件）：
<pre class="lang:default decode:true "> // TextBox输入完毕按下回车后，得到图片来源
        private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
        {
            // 判断与事件关联的输入按钮是否为虚拟按键的Enter键
            if (e.Key==Windows.System.VirtualKey.Enter)
            {
                ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(new Uri(URLTextBox.Text));
            }
        }

        // 设置按下按钮后的翻转效果
        private   void XRotateAppBarButton_Click(object sender, RoutedEventArgs e)
        {
             StoryBoardX.Begin();
        }

        private void YRotateAppButton_Click(object sender, RoutedEventArgs e)
        {
            StoryBoardY.Begin();
        }

        private void ZRotateAppBarButton_Click(object sender, RoutedEventArgs e)
        {
            StoryBoardZ.Begin();
        }</pre>

<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><h3 id="1-处理文本框的回车事件中，"><a href="#1-处理文本框的回车事件中，" class="headerlink" title="1,处理文本框的回车事件中，"></a>1,处理文本框的回车事件中，</h3><p>文本框输入类型：InputScope=”Url”   键盘按键属性KeyDown=”URLTextBox_KeyDown”</p>
<p>获取文本框内容并转换为URL：</p>
<p>// 判断与事件关联的按键是否为虚拟按键的Enter键<br>if (e.Key==Windows.System.VirtualKey.Enter)<br>{<br>ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(new Uri(URLTextBox.Text));</p>
<p>等同于：</p>
<pre class="lang:default decode:true ">Uri url = new Uri(URLTextBox.Text);
ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(url);</pre>
}

当然，如果引入命名空间了，那就更好了  using Windows.UI.Xaml.Media.Imaging;
<pre class="lang:default decode:true ">Uri url = new Uri(URLTextBox.Text);
ResultImage.Source = new BitmapImage(url);</pre>

<h3 id="2，关于动画"><a href="#2，关于动画" class="headerlink" title="2，关于动画"></a>2，关于动画</h3><p>首先目标图片要声明Projection属性，即添加：</p>
<pre class="lang:default decode:true ">&lt;Image.Projection&gt;
   &lt;PlaneProjection /&gt;
&lt;/Image.Projection&gt;</pre>
其次在 &lt;Page.Resources&gt;中添加故事板：
<pre class="lang:default decode:true ">&lt;Storyboard x:Name="StoryBoardX"&gt;
&lt;DoubleAnimation Storyboard.TargetName="ResultImage"
Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationX)"
From="0.0"
To="360.0"
AutoReverse="True"
RepeatBehavior="Forever"&gt;
&lt;/DoubleAnimation&gt;
&lt;/Storyboard&gt;
</pre>

<ul>
<li>命名：方便后台代码调用</li>
<li>类：DoubleAnimation针对Double属性，还有ColorAnimation针对Color属性，以及PointAnimation针对Point，这里图形翻转目标属性是PlaneProjection   值是double类型</li>
<li>Storyboard.TargetName：执行动画的对象名称</li>
<li>Storyboard.TargetProperty：执行动画的对象属性，此处是PlaneProjection.RotationX，写成Storyboard.TargetProperty=”PlaneProjection.RotationX”也没有关系</li>
<li>From：起始值</li>
<li>To：终点值</li>
<li>By：变化值</li>
<li>AutoReverse：自动重置（返回原状）</li>
<li>RepeatBehavior：播放次数</li>
<li>Duration：持续时间（值的格式为时分秒，即0.0.3  3秒）<br>以上是通过XAML写出界面，当然，完全可以在后台代码中，完成StoryBoard的设置：<br><pre class="lang:default decode:true ">            DoubleAnimation animation = new DoubleAnimation();<pre><code>animation.From = 0.0;
animation.To = 360.0;
animation.BeginTime = TimeSpan.FromSeconds(1);
animation.RepeatBehavior = RepeatBehavior.Forever;
Storyboard.SetTarget(animation, target);
Storyboard.SetTargetProperty(animation, &quot;(UIElement.Projection).(PlaneProjection.Rotation&quot; + axis + &quot;)&quot;);
rotation.Children.Clear();
rotation.Children.Add(animation);
rotation.Begin();
rotating = true;&lt;/pre&gt;
</code></pre>不过看个人爱好了，我还是喜欢XAML。</pre></li>
</ul>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UWP开发笔记二：AppBar和CommandBar]]></title>
      <url>http://yoursite.com/2016/04/22/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AAppBar%E5%92%8CCommandBar/</url>
      <content type="html"><![CDATA[<p>AppBar和CommandBar也算是比较常用的控件了，不过个人不太喜欢这些，主要是觉得很非主流，我还是喜欢把功能都做到汉堡菜单里。</p>
<p>1，CommandBar被包裹住了，一般放在页面顶部或底部。</p>
<p><pre class="lang:default decode:true ">&lt;Page<br>    x:Class=”ApplicationBar.MainPage”<br>    xmlns=”<a href="http://schemas.microsoft.com/winfx/2006/xaml/presentation" target="_blank" rel="external">http://schemas.microsoft.com/winfx/2006/xaml/presentation</a>“<br>    xmlns:x=”<a href="http://schemas.microsoft.com/winfx/2006/xaml" target="_blank" rel="external">http://schemas.microsoft.com/winfx/2006/xaml</a>“<br>    xmlns:local=”using:ApplicationBar”<br>    xmlns:d=”<a href="http://schemas.microsoft.com/expression/blend/2008" target="_blank" rel="external">http://schemas.microsoft.com/expression/blend/2008</a>“<br>    xmlns:mc=”<a href="http://schemas.openxmlformats.org/markup-compatibility/2006" target="_blank" rel="external">http://schemas.openxmlformats.org/markup-compatibility/2006</a>“<br>    mc:Ignorable=”d”&gt;</pre></p>
<p>  &lt;Page.BottomAppBar&gt;<br>        &lt;CommandBar&gt;</p>
<pre><code>    &amp;lt;/CommandBar&amp;gt;
&amp;lt;/Page.BottomAppBar&amp;gt;
&amp;lt;Grid Background=&quot;{ThemeResource ApplicationPageBackgroundThemeBrush}&quot;&amp;gt;
&amp;lt;/Grid&amp;gt;
</code></pre><p>&lt;/Page&gt;<br>所以就是这种效果，在CommandBar中有两种菜单可选</p>
<p>图标文字：添加AppBarButton即可</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/001.png" alt=""></p>
<p><pre class="lang:default decode:true ">&lt;AppBarButton Name=”FirstAppBarButton”<br>    Icon=”Account”<br>     Label=”主页”<br>    Click=”FirstAppBarButton_Click”/&gt;</pre><br>文字列表：需要夹在&lt;CommandBar.SecondaryCommands&gt;&lt;/CommandBar.SecondaryCommands&gt;中间</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/002.png" alt=""></p>
<p><pre class="lang:default decode:true ">&lt;CommandBar.SecondaryCommands&gt;<br>                &lt;AppBarButton Name=”TextAppBarButton1”<br>                              Label=”文字1”<br>                              Click=”TextAppBarButton1_Click”/&gt;<br>&lt;/CommandBar.SecondaryCommands&gt;</pre><br>2,AppBar 的话，可能更强大一点，它可以嵌套着命令栏CommandBar，不过也是需要放在页面顶部或者底部</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/005.png" alt=""></p>
<p><pre class="lang:default decode:true">&lt;Page.TopAppBar&gt;<br>        &lt;AppBar  &gt;</pre></p>
<pre><code>    &amp;lt;/AppBar&amp;gt;
&amp;lt;/Page.TopAppBar&amp;gt;&lt;/pre&gt;
</code></pre><p>对于每个命令栏按钮，依然可以添加Click事件进行处理。</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/003.png" alt=""></p>
<p><img src="http://images.chenyalun.cn/2016/04/20/004.png" alt=""></p>
<hr>
<hr>
<h3 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h3><p>1,</p>
<p><pre class="lang:default decode:true ">&lt;Page.TopAppBar&gt;<br>        &lt;AppBar  IsSticky=”True” &gt;<br>            &lt;StackPanel Orientation=”Horizontal” &gt;<br>                &lt;CommandBar&gt;<br>                    &lt;!–第二命令栏–&gt;<br>                    &lt;CommandBar.SecondaryCommands&gt;<br>                        &lt;AppBarButton Name=”Hide” Icon=”Cancel” Label=”文本” Visibility=”Collapsed” Click=”Show_Click”/&gt;<br>                    &lt;/CommandBar.SecondaryCommands&gt;<br>                     &lt;!–设置命令栏内容–&gt;<br>                    &lt;CommandBar.Content&gt;<br>                        &lt;TextBlock Text=”Now playing…” Margin=”12,14”/&gt;<br>                    &lt;/CommandBar.Content&gt;<br>                &lt;/CommandBar&gt;<br>                     &lt;!–分割线–&gt;<br>                &lt;AppBarSeparator/&gt;<br>                &lt;AppBarButton Name=”Show”<br>                              Icon=”Accept”<br>                              Label=”Show Other”<br>                              Click=”Show_Click”<br>                              IsCompact=”True”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.TopAppBar&gt;</pre><br>如上所示，AppBar中包裹命令栏。若菜单栏中只包含AppBarButton（普通按钮）、AppBarToggleButton（切换按钮）、AppBarSeparator（分割线） 这几个控件，且没有特殊布局格式要求，CommandBar 控件可以解决大多数问题。</p>
<p>第二命令栏需要使用：CommandBar.SecondaryCommands</p>
<p>命令栏内容：CommandBar.Content</p>
<p>命令按钮分割线： &lt;AppBarSeparator/&gt;</p>
<p>标签：label</p>
<p>图标: icon</p>
<p>顶部命令栏：&lt;Page.TopAppBar&gt;&lt;/Page.TopAppBar&gt;</p>
<p>底部命令栏： &lt;Page.BottomAppBar&gt; &lt;/Page.BottomAppBar&gt;</p>
<p>单词：toggle 切换   Separator分隔符</p>
<p>在AppBar属性中：IsSticky=”True”表示打开命令栏后，除非用户显式地点击鼠标右键或按Win+z, 或用手指从屏幕顶端或底端划过才会隐藏，否则AppBar会一直显示。一般不设置。</p>
<p>IsOpen=”True” 一直完全显示图标+文字，一般不设置。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UWP开发笔记一：Hello UWP与对话框]]></title>
      <url>http://yoursite.com/2016/04/20/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9AHello_UWP%E4%B8%8E%E5%AF%B9%E8%AF%9D%E6%A1%86/</url>
      <content type="html"><![CDATA[<p>这段时间在悄悄地学习UWP开发，不过担心会忘记，所以感觉还是记下笔记比较好。一来自己没事可以翻着看看，可解闷了，二来欢迎志同道合的童鞋一起交流。</p>
<p>1，假定PC装好VS2015，文件–新建–项目–windows通用应用</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/001.png" alt=""></p>
<p>设置版本：</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/002.png" alt=""></p>
<p>2，右侧解决方案中，打开MainPage.xaml，写入xaml代码：</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/003.png" alt=""></p>
<p><pre class="lang:default decode:true ">  &lt;Button Name=”HelloUWPButton”<br>                Content=”显示”<br>                HorizontalAlignment=”Center”<br>                VerticalAlignment=”Center”<br>        Click=”HelloUWPButton_Click”/&gt;</pre><br>或者拖入Button控件，属性中设置Click事件：HelloUWPButton_Click，内容设置为：显示。</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/004.png" alt=""></p>
<p>3，处理click事件：</p>
<p><pre class="lang:default decode:true ">private async void HelloUWPButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            await new Windows.UI.Popups.MessageDialog(“Hello UWP”).ShowAsync();</pre></p>
<pre><code>}&lt;/pre&gt;
</code></pre><p>4，调试运行即可。</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/005.png" alt=""></p>
<hr>
<hr>
<h3 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;<strong>笔记</strong></h3><p>1，其实点击事件的代码和下面两行等价：</p>
<p><pre class="lang:default decode:true ">var message = new MessageDialog(“Hello UWP”);<br>await  message.ShowAsync();</pre><br>&nbsp;</p>
<p>2，消息对话框引入的命名空间：<strong>using Windows.UI.Popups;</strong></p>
<p>&nbsp;</p>
<p>3，消息对话框的使用</p>
<p>创建对话框并设置内容：</p>
<p><pre class="lang:default decode:true ">var messageDialog = new MessageDialog(“消息对话框的内容”, “可省略的对话框标题”);</pre><br>设置对话框中的命令,最多有3个：</p>
<p><pre class="lang:default decode:true ">UICommand cmd1 = new UICommand();<br>UICommand cmd2 = new UICommand();<br>UICommand cmd3 = new UICommand();</pre><br>设置命令的标签文本：</p>
<p><pre class="lang:default decode:true ">cmd1.Label = “标签1”;<br>cmd2.Label = “标签2”;<br>cmd3.Label = “标签3”;</pre><br>设置命令的唯一标识符：</p>
<p><pre class="lang:default decode:true ">cmd1.Id = 1;<br>cmd2.Id = 2;<br>cmd3.Id = 3;</pre><br>设置消息对话框命令的默认ID（直接按下回车键就可以执行的命令）<br>三个命令默认从左到右DefaultCommandIndex依次是0，1，2，大于2或者不设置则DefaultCommandIndex的值为0</p>
<p><pre class="lang:default decode:true "> messageDialog.DefaultCommandIndex = 1;</pre><br>设置调用（点击）命令时引发的事件：OnCommend</p>
<p><pre class="lang:default decode:true ">cmd1.Invoked = new UICommandInvokedHandler(OnCommend);<br>cmd2.Invoked = new UICommandInvokedHandler(OnCommend);<br>cmd3.Invoked = new UICommandInvokedHandler(OnCommend);</pre><br>将3个命令添加到对话框中</p>
<p><pre class="lang:default decode:true ">messageDialog.Commands.Add(cmd1);<br>messageDialog.Commands.Add(cmd2);<br>messageDialog.Commands.Add(cmd3);</pre><br>显示消息对话框(异步)</p>
<p><pre class="lang:default decode:true ">await messageDialog.ShowAsync();</pre><br>截至目前，上面的代码可以简化为：</p>
<p><pre class="lang:default decode:true">var messageDialog = new MessageDialog(“消息对话框的内容”);<br>messageDialog.DefaultCommandIndex = 1;<br>messageDialog.Commands.Add(new UICommand(“标签1”, OnCommend, 1));<br>messageDialog.Commands.Add(new UICommand(“标签2”, OnCommend, 2));<br>messageDialog.Commands.Add(new UICommand(“标签3”, OnCommend, 3));<br>await messageDialog.ShowAsync();</pre><br>处理调用命令的事件：</p>
<p>一般通过命令的ID进行不同的处理，将object类型的command.Id转化为int32类型</p>
<p><pre class="lang:default decode:true "> private void OnCommend(IUICommand command)<br>        {<br>            var ID = Convert.ToInt32(command.Id);</pre></p>
<pre><code>    // 处理不同的命令
    if (ID == 1)
    {
        ResultTextBlock.Text = &quot;你点击了命令1：标签1&quot;;
    }
    else if (ID == 2)
    {
        ResultTextBlock.Text = &quot;你点击了命令2：标签2&quot;;
    }
    else
    {
        ResultTextBlock.Text = &quot;你点击了命令3：标签3&quot;;
    }

}&lt;/pre&gt;
</code></pre><p><img src="http://images.chenyalun.cn/2016/04/19/006.png" alt=""></p>
<p>4，单词积累：</p>
<p>popups：弹出窗口；弹出式视窗</p>
<p>invoked：恳求；实行；引起</p>
<p>5,github: <a href="http://www.chenyalun.cn/go/?url=https://github.com/chenyalun/UWP-Notes.git" target="_blank" rel="external">https://github.com/chenyalun/UWP-Notes.git</a></p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Visual Studio 2015如何配置Github]]></title>
      <url>http://yoursite.com/2015/11/06/Visual_Studio_2015%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEGithub/</url>
      <content type="html"><![CDATA[<p>身为一枚开发人员，使用Github是一项基本技能，Github的美妙之处在下就不细细道来了，其实，稍微入门的童鞋都会在Visual Studio 2015配置Github的，如此说来，我再分享这个教程纯属无聊了。</p>
<h3 id="1，申请注册Github"><a href="#1，申请注册Github" class="headerlink" title="1，申请注册Github"></a>1，申请注册Github</h3><p><a href="http://www.chenyalun.cn/go/?url=https://github.com" target="_blank" rel="external">https://github.com</a>，这个就是人家的官网，注册成功，点击右上角的“+”，创建新的organization。</p>
<p><img src="http://source.chenyalun.cn/images/201511/5110501.jpg" alt=""></p>
<p>注意你的organization name是全网唯一的，不允许重复。当然也可以选择用于付费的项目，视自己情况而定。</p>
<p><img src="http://source.chenyalun.cn/images/201511/5110602.jpg" alt=""></p>
<p>很巧妙的我的RoseMyCode就这样创建成功啦。</p>
<p><img src="http://source.chenyalun.cn/images/201511/5110503.jpg" alt=""></p>
<p>接着是创建自己的repository，当然这个是属于刚才的RoseMycode目录之下的。</p>
<p><img src="http://source.chenyalun.cn/images/201511/5110604.jpg" alt=""></p>
<p>如此，一个简单的Github搞定啦。</p>
<h3 id="2，配置VS2015"><a href="#2，配置VS2015" class="headerlink" title="2，配置VS2015"></a>2，配置VS2015</h3><p>依次点击视图-团队资源管理器，打开即可。</p>
<p><img src="http://source.chenyalun.cn/images/201511/5110605.jpg" alt=""></p>
<p>在右侧的团队资源管理器中找到本地Git存储库，点击克隆。</p>
<p><img src="http://source.chenyalun.cn/images/201511/5110606.jpg" alt=""></p>
<p>然后把我们刚才创建的repository链接地址粘贴即可，当然你要选定自己要克隆的代码的路径，是在默认的C盘，还是其他盘。</p>
<p><img src="http://source.chenyalun.cn/images/201511/5110607.jpg" alt=""><img src="http://source.chenyalun.cn/images/201511/5110608.jpg" alt=""></p>
<p>看吧，着实很简单，我们就把VS配置好啦。当然值得一提的是Visual Studio Online，为 Visual Studio、Eclipse、Xcode 或任何其他 IDE 或代码编辑器提供版本控制、敏捷规划、持续交付和应用程序分析的基于云的协作服务。这个也是令人神往的。有兴趣的同学不妨看看。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[泛谈单链表的插入与删除]]></title>
      <url>http://yoursite.com/2015/11/04/%E6%B3%9B%E8%B0%88%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4/</url>
      <content type="html"><![CDATA[<p>谈过<a href="http://www.chenyalun.cn/泛谈顺序表的插入与删除.html" target="_blank" rel="external">顺序表的插入与删除</a>，其实单链表也是比较有意思的，可惜我弄了好久才些微明白些。在顺序表中，一个数组就将近定义一个结构，但在单链表中，却又要和指针扯上关系了。还是那句话，本人对指针不感冒。</p>
<p>先看定义：</p>
<p><pre class="lang:default decode:true ">typedef struct LNode{<br>    int data;<br>    struct LNode <em>next;<br>}LNode;</em></pre><br>数据域和下个节点的指针，可惜我木有写上 LinkList，我是故意的，你咬我呀，哈哈。</p>
<p>江湖传言LNode *p等价于LinkList p，不知道有木有人认同呢？闲话少说，看代码：</p>
<p><pre class="lang:default decode:true ">#include&lt;stdio.h&gt;</pre></p>
<p>#include&lt;malloc.h&gt;<br>//定义并初始化单链表<br>typedef struct LNode{<br>    int data;<br>    struct LNode *next;<br>}LNode;</p>
<p>//单链表的创建与初始化，设定共n个节点（不含头节点）<br>void CreateLinkList(LNode <em>a,int n) {<br>        LNode </em>p,<em>q;<br>        p=a;<br>    while(n–){<br>         q=(LNode </em>)malloc(sizeof(LNode *));<br>         scanf(“%d”,&amp;q-&gt;data);<br>           q-&gt;next=NULL;<br>        p-&gt;next=q;<br>        p=q;<br>    }<br>}</p>
<p>//查找是否存在一个值为x的节点，若存在，删之，并返回OK，否则返回NOT FOUND<br>char <em>SearchAndDelete(LNode </em>c,int x){<br>    LNode <em>p,</em>q;<br>    p=c;<br>    //开始查找<br>    while(p-&gt;next!=NULL)<br>    {<br>        if(p-&gt;next-&gt;data==x)<br>        break;<br>        p=p-&gt;next;<br>    }<br>    //若找到则开始删除<br>    if(p-&gt;next==NULL)<br>    return “NOT FOUND”;<br>    else<br>    {<br>        q=p-&gt;next;<br>        p-&gt;next=p-&gt;next-&gt;next;<br>        free(q);<br>        return “OK”;<br>    }<br>}</p>
<p>//在链表c中第n个节点位置插入元素e<br>void Insert(LNode <em>c,int n,int e){<br>    LNode </em>p=( LNode <em>)malloc(sizeof(LNode </em>)),<br>    <em>q=( LNode </em>)malloc(sizeof(LNode <em>));//插入的节点<br>    p=c;<br>    q-&gt;data=e;<br>    //找到要插入节点的位置<br>    for(int i=1;i&lt;n;i++){<br>        p=p-&gt;next;<br>    }<br>    //插入节点<br>    q-&gt;next=p-&gt;next;<br>    p-&gt;next=q;<br>}<br>//打印单链表<br>void Print(LNode </em>a){<br>    LNode <em>p=( LNode </em>)malloc(sizeof(LNode *));<br>    p=a-&gt;next;<br>    while(p!=NULL){<br>        printf(“%d\n”,p-&gt;data);<br>        p=p-&gt;next;<br>    }<br>}</p>
<p>int main(){<br>   LNode <em>a=( LNode </em>)malloc(sizeof(LNode *));<br>    CreateLinkList(a,5);<br>   Insert(a,3,10086);//假定在第3个位置插入数值为10086的节点<br> Print(a);<br>   printf(“—————-\n”);<br>SearchAndDelete(a,13);//查找并执行删除数值为13的节点<br>  Print(a);<br>return 0;<br>}<br><br>说明如下：</p>
<p>1，假定输入的是11 12 13 14 15五个数值。在第三个位置（13的位置）插入一个数据域为10086的节点。此时原来的数值已经变成了11 12 10086 13 14 15</p>
<p>2，完事后，我为了方便不再另写代码，在11 12 10086 13 14 15的基础上假定查找并删除数据域为13的节点。</p>
<p><img src="http://source.chenyalun.cn/images/201511/5110101.jpg" alt=""></p>
<p>当然还有值得体会的是，我把节点的内存分配放在主函数里，不知道是不是有人想打我呢？</p>
<p>像这样：</p>
<p><pre class="nums:false lang:default decode:true ">LNode <em>a=( LNode </em>)malloc(sizeof(LNode *));</pre><br>当然，清晰一点就是</p>
<p>&nbsp;</p>
<p><pre class="nums:false lang:default decode:true ">LNode <em>a;<br>a=( LNode </em>)malloc(sizeof(LNode *));</pre><br>两者效果一样。这不是重点。看下面的两段代码：</p>
<p><pre class="lang:default decode:true ">void Print(LNode *a){</pre></p>
<p>}<br>和</p>
<p><pre class="lang:default decode:true">void Print(LNode <em>&amp;a){<br>    a=( LNode </em>)malloc(sizeof(LNode *));</pre></p>
<p>}<br>这才是重点，和小伙伴研究一下，决定采取有违伦理惨无人道的第一种方式。最后在主函数中再调用malloc觉得还是蛮灵活轻便的。</p>
<p>当然，上面的代码不是为了解题，只是提供一个思路，具体可视情况修改。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[泛谈顺序表的插入与删除]]></title>
      <url>http://yoursite.com/2015/11/02/%E6%B3%9B%E8%B0%88%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4/</url>
      <content type="html"><![CDATA[<p>严蔚敏版的数据结构着实编写的十分专业，可惜本人愚钝，思索再三还是木有想的十分明白，去翻翻资料，发现原来顺序表是如此easy，特别感叹作者的机智，当然，此时写下也是希望经常提醒自己，毕竟我对数据结构不是非常感冒。</p>
<p>所谓的顺序表，在严版的书中，定义的异常专业巧妙。存储空间基址、当前长度、分配的存储容量，这三部分融合而成线性表之顺序表。看到这时，确实很不high，还木有到链表呢，何必那么心急引入指针，而且我又不爱指针。</p>
<p><pre class="lang:default decode:true ">typedef struct{<br>    Elemtype *elem;<br>    int length;<br>    int listsize;<br>}SqList;</pre><br>没有指责的意思，只是我辈太愚笨罢了。</p>
<p>翻翻资料。发现还有一种更巧妙而且容易理解的方式：</p>
<p><pre class="lang:default decode:true ">typedef struct{<br>    int data[Max];<br>    int length;<br>}SqList;</pre><br>这样一来，整个顺序表就与数组特别特别相似啦。</p>
<p>那么，声明一个很长很长但是彼此知道的Max长度数组，作为默认“表长”（其实不是表长），再给它一个长度length，如此，顺序表横空出世了。</p>
<p>既然如此，那关于什么插入、删除操作就不在话下了。</p>
<h3 id="1，已知顺序表的所有元素值（自行输入），在元素e的位置插入元素m"><a href="#1，已知顺序表的所有元素值（自行输入），在元素e的位置插入元素m" class="headerlink" title="1，已知顺序表的所有元素值（自行输入），在元素e的位置插入元素m"></a>1，已知顺序表的所有元素值（自行输入），在元素e的位置插入元素m</h3><p>题目很清楚，插入元素m后，后面的元素自然往后移动啦。先看代码。</p>
<p><pre class="lang:default decode:true ">#include&lt;stdio.h&gt;<br>//#include&lt;malloc.h&gt;<br>//#include&lt;stdlib.h&gt;   //一般这两个是需要的</pre></p>
<p>#define Max 200<br>//定义并初始化顺序表<br>typedef struct{<br>    int data[Max];<br>    int length=10;<br>}SqList;<br>//顺序表l中查找元素e的位置<br>int LocatElem(SqList l,int e){<br>    int i=0;<br>    for(;i&lt;l.length;++i)<br>      if(l.data[i]==e)<br>      return i+1;<br>}</p>
<p>//在元素e的位置插入元素m<br>void Insert(SqList &amp;l,int e,int m) {<br>    int i=l.length,p=LocatElem(l,e);<br>    for(;i&gt;=p;–i){<br>        l.data[i]=l.data[i-1];<br>    }<br>    l.data[i]=m;<br>    l.length++;<br>}</p>
<p>int main(){<br>    int i=0,e=18,m=200;<br>    SqList a;<br>    for(;i&lt;a.length;++i)<br>         scanf(“%d”,&amp;a.data[i]);<br>    Insert(a,e,m);<br>    for(int i=0;i&lt;a.length;++i)<br>         printf(“%d\n”,a.data[i]);<br>    return 0;<br>}<br>这里假设我们输入从11，12一直到20的整数值，首先查找元素e=18的值的位置，插入m的值200。</p>
<p>原来：11 12 13 14 15 16 17 18 19 20</p>
<p>run后：11 12 13 14 15 16 17 200 18 19 20</p>
<p><img src="http://source.chenyalun.cn/images/201510/5103102.jpg" alt=""></p>
<h3 id="2，已知顺序表所有元素的值（自行输入），删除顺序表中值为e的元素"><a href="#2，已知顺序表所有元素的值（自行输入），删除顺序表中值为e的元素" class="headerlink" title="2，已知顺序表所有元素的值（自行输入），删除顺序表中值为e的元素"></a>2，已知顺序表所有元素的值（自行输入），删除顺序表中值为e的元素</h3><p><pre class="lang:default decode:true">#include&lt;stdio.h&gt;<br>//#include&lt;malloc.h&gt;<br>//#include&lt;stdlib.h&gt;</pre></p>
<p>#define Max 200<br>//定义并初始化顺序表<br>typedef struct{<br>    int data[Max];<br>    int length=10;<br>}SqList;<br>//顺序表l中查找元素e的位置<br>int LocatElem(SqList l,int e){<br>    int i=0;<br>    for(;i&lt;l.length;++i)<br>      if(l.data[i]==e)<br>      return i+1;<br>}</p>
<p>//删除顺序表中值为e的元素<br>void Delete(SqList &amp;l,int e){<br>    int i=LocatElem(l,e);<br>    for(;i&lt;=l.length;++i)<br>       l.data[i-1]=l.data[i];<br>       l.length–;<br>}<br>int main(){<br>    int i=0, e=15;//e的值自己说了算<br>    SqList a;<br>     for(;i&lt;a.length;++i)<br>          scanf(“%d”,&amp;a.data[i]);<br>     Delete(a,e);<br>    for(int i=0;i&lt;a.length;++i)<br>          printf(“%d\n”,a.data[i]);<br>     return 0;<br>}<br>改动不大，添加个函数而已。这里删除的是15，具体题目具体分析。</p>
<p>原来：11 12 13 14 15 16 17 18 19 20</p>
<p>run后：11 12 13 14  16 17  18 19 20</p>
<p><img src="http://source.chenyalun.cn/images/201510/5103101.jpg" alt=""></p>
<p>说这么多，无非是想分享一个模板，插入、删除搞定了，其他也很容易拿下了。当然变的是题目，不变的是方法论。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[题目：1011二进制整数的转换]]></title>
      <url>http://yoursite.com/2015/10/30/%E9%A2%98%E7%9B%AE%EF%BC%9A1011%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>题目概述：给定一个正整数，写出它的2进制表示</p>
<p>输入：多组输入，输入的第一行为一个正整数n，表示接下来有n组数据，每一行为1个正整数a(0&lt;a&lt;=10000)</p>
<p>输出：对于每一组数据，求出a的2进制表示法</p>
<p>样例输入：</p>
<p>2<br>5<br>10</p>
<p>样例输出：</p>
<p>101<br>1010</p>
<p>关于进制的转换，其实是有章可循的。而对于十进制整数到二进制整数的转换中，用给定的数反复除以2，除第一次外，每次除以2均取前一次商的整数部分作被除数并依次记下每次的余数。另外，所得到的商的最后一位余数是所求二进制数的最高位。如此，便可轻而易举得到我们需要的二进制整数。</p>
<p><table class="table-view log-set-param"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">被除数</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">计算过程</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">商</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">余数</div><br></p>
<p><tr></tr></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">6</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">6/2</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">3</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">0</div><br></p>
<p><tr></tr></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">3</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">3/2</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">1</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">1</div><br></p>
<p><tr></tr></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">1</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">1/2</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">0</div></p>
<p><td align="center" valign="center"></td></p>
<p><div class="para">1</div><br><br><br><br>&nbsp;</p>
<p>像上面的这个，二进制整数便是110。思路明了，那代码自然“油然而生”。</p>
<h3 id="1，C代码"><a href="#1，C代码" class="headerlink" title="1，C代码"></a>1，C代码</h3><pre class="lang:default decode:true ">#include&lt;stdio.h&gt;
void binary(int n){
    int a[200],i=0;
    do{
        a[i]=n%2;
        n=n/2;    
        i++;        
    }while(n!=0);

while(i&gt;0)
printf("%d",a[--i]);

printf("\n");
}
int main(){
    int n,a[200],i=0;
    scanf("%d",&amp;n);
    for(;i&lt;n;i++)
        scanf("%d",&amp;a[i]);
    for(i=0;i&lt;n;i++)
        binary(a[i]);
    return 0;
}</pre>

<h3 id="2，C-代码"><a href="#2，C-代码" class="headerlink" title="2，C++代码"></a>2，C++代码</h3><pre class="lang:default decode:true ">#include&lt;iostream&gt;
using namespace std;
void binary(int n){
    int a[200],i=0;
    do{
        a[i]=n%2;
        n=n/2;    
        i++;        
    }while(n!=0);

while(i&gt;0)
cout&lt;&lt;a[--i];
cout&lt;&lt;endl;
}
int main(){
    int n,a[200],i=0;
    cin&gt;&gt;n;
    for(;i&lt;n;i++)
        cin&gt;&gt;a[i];
    for(i=0;i&lt;n;i++)
        binary(a[i]);
    return 0;
}
</pre>

<h3 id="3，JAVA代码"><a href="#3，JAVA代码" class="headerlink" title="3，JAVA代码"></a>3，JAVA代码</h3><p><pre class="lang:default decode:true ">import java.util.Scanner;</pre></p>
<p>public class Main {</p>
<pre><code>static void binary(int n){
    int a[]=new int [200],i=0;
    do{
        a[i]=n%2;
        n=n/2;
        i++;
    }while(n!=0);

while(i&amp;gt;0)
    System.out.print(a[--i]);
System.out.println();
}

public static void main(String[] args) {
    int a[]=new int [200],n,i=0;
    Scanner s=new Scanner (System.in);
    n=s.nextInt();
    for(;i&amp;lt;n;i++)
    a[i]=s.nextInt();
    for(i=0;i&amp;lt;n;i++)
    binary(a[i]);
}
</code></pre><p>}<br><br>其实最根本的莫过于进制转换这个函数：用一个整形数组存储每次得到的余数a[i]=n%2（当然，打印的时候，顺序要倒过来），接着要做的便是n=n/2；整除2即可。核心函数搞定了，那与之相关的题目便可顺手解决了。像题目1012【给定一个正整数，写出它的2进制表示中有多少个1】很容易搞定。</p>
<h3 id="4，二进制数中1的个数"><a href="#4，二进制数中1的个数" class="headerlink" title="4，二进制数中1的个数"></a>4，二进制数中1的个数</h3><p><pre class="lang:default decode:true ">#include&lt;iostream&gt;<br>using namespace std;<br>int binary_number1(int n){<br>    int a[200],i=0,k=0;<br>    do{<br>        a[i]=n%2;<br>        n=n/2;<br>        i++;<br>    }while(n!=0);</pre></p>
<p>while(i&gt;0)<br>{<br>    if(a[–i]==1)<br>    k++;<br>}<br>return k;<br>}<br>int main(){<br>    int n,a[200],i=0;<br>    cin&gt;&gt;n;<br>    for(;i&lt;n;i++)<br>        cin&gt;&gt;a[i];<br>    for(i=0;i&lt;n;i++)<br>        cout&lt;&lt;binary_number1(a[i])&lt;&lt;endl;<br>    return 0;<br>}<br><br>&nbsp;</p>
<p>下面是JAVA代码：</p>
<p><pre class="lang:default decode:true ">import java.util.Scanner;</pre></p>
<p>public class Main {</p>
<pre><code> static int binary_number1(int n){
    int a[]=new int [200],i=0,k=0;
    do{
        a[i]=n%2;
        n=n/2;
        i++;
    }while(n!=0);

while(i&amp;gt;0){
    if(a[--i]==1)
    k++;
}
return k;
</code></pre><p>}<br>    public static void main(String[] args) {<br>        int a[]=new int [200],n,i=0;<br>        Scanner s=new Scanner (System.in);<br>        n=s.nextInt();<br>        for(;i&lt;n;i++)<br>        a[i]=s.nextInt();<br>        for(i=0;i&lt;n;i++)<br>        System.out.println(binary_number1(a[i]));<br>    }<br>}<br><br>&nbsp;</p>
<p>万变不离其宗，无非是增加个计数工具而已。</p>
<p>总之，十进制整数转换到二进制整数确实不算难解，稍微理解一下便可轻松解决，当然，有整数必然有小数，二进制如此其他进制也类似，具体看咱下回分解。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[题目1009：求出小于n的所有质数的和]]></title>
      <url>http://yoursite.com/2015/10/28/%E9%A2%98%E7%9B%AE1009%EF%BC%9A%E6%B1%82%E5%87%BA%E5%B0%8F%E4%BA%8En%E7%9A%84%E6%89%80%E6%9C%89%E8%B4%A8%E6%95%B0%E7%9A%84%E5%92%8C/</url>
      <content type="html"><![CDATA[<p>概述：给定一个质数n(5&lt;n&lt;1000)，求出小于n的所有质数的和</p>
<p>输入：多组输入，每行一个n(5&lt;n&lt;1000),</p>
<p>输出：对于每组数据，输出为一行，值为小于n的所有质数的和</p>
<p>样例输入：6 7</p>
<p>样例输出：10  10</p>
<p>看到这个题目我心中一乐，确实就是质数函数的改编版，难度不大，不过咱是为了锻炼写代码，所以还是要认真做的。直接看函数啦。</p>
<p>不过值得注意的是：</p>
<p>1，数字1不是质数，当然，也不是合数。回顾上次的题目1008，虽然输进去1打印的是Yes，但是题目要求是输入一个大于2的数，所以上次的代码不能算错。</p>
<p>2，函数sqrt的参数是double型，即使不在程序中特意说明，也不会产生影响，但还是值得注意的，因为这个关系到编译器，如果想保持代码的准确完美，int n=(int) sqrt((double)m);具体是(double)m还是double (m)，在c和c++中是不一样的，如果用错，可能编译会报错。</p>
<p>3，判断是否为质数的prime函数中，用于计数的自然数i要从2开始，关系到<span class="crayon-v">m</span><span class="crayon-o">%</span><span class="crayon-v">i</span><span class="crayon-o">==</span><span class="crayon-cn">0这个表达式，</span>如果从0开始，嘿嘿，你试试。</p>
<p>想到上次的代码，这次无非是多了一个求和函数，当然判断是否为质数的函数还可以再做些优化。</p>
<h3 id="1，C代码"><a href="#1，C代码" class="headerlink" title="1，C代码"></a>1，C代码</h3><pre class="lang:default decode:true">#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

int prime(int m){ 
int n=(int) sqrt((double)m),i;
    for(i=2;i&lt;=n;i++){
       if(m%i==0)
        break;
    }
  if(i&gt;n)
     return 1;
  else
     return 0;
}

int sum(int n){
     int s=0; 
     int i;
      for( i=2;i&lt;n;i++){
      if(prime(i)==1)    
      s+=i;
  }
      return s;
}

int main(){
     int n;
     while(scanf("%d",&amp;n)!= EOF) 
     printf("%d\n",sum(n));
    return 0;
   }
</pre>

<h3 id="2，C-代码"><a href="#2，C-代码" class="headerlink" title="2，C++代码"></a>2，C++代码</h3><pre class="lang:default decode:true">//c++代码沿用上次的函数
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;

string prime(int m){
    int n=(int) sqrt( double(m)),i=2;//一定要注意i=2
    for(;i&lt;=n;i++){
       if(m%i==0)
        break;
     }
  if(i&gt;n)
     return "Yes";
  else
     return "No";
}

int sum(int n){
     int s=0; 
      for(int i=2;i&lt;n;i++){
      if(prime(i)=="Yes")
      s+=i;
  }
      return s;
}

 int main(){
      int n;
     while(cin&gt;&gt;n){
         cout&lt;&lt;sum(n)&lt;&lt;endl;
    }
       return 0;
}
</pre>

<h3 id="3，JAVA代码"><a href="#3，JAVA代码" class="headerlink" title="3，JAVA代码"></a>3，JAVA代码</h3><p><pre class="lang:default decode:true">import java.util.*;</pre></p>
<p>public class Main {</p>
<pre><code>static int prime(int m){ 
int n=(int) Math.sqrt((double)m),i=2;
        for(;i&amp;lt;=n;i++){
           if(m%i==0)
            break;
        }
      if(i&amp;gt;n)
         return 1;
      else
         return 0;
    }

    static int sum(int n){
         int s=0; 
         int i;
          for( i=2;i&amp;lt;n;i++){
          if(prime(i)==1)    
          s+=i;
      }
          return s;
    }

public static void main(String[] args) {
    int n;
     while(1==1) {
         Scanner s=new Scanner(System.in);
         n=s.nextInt();
     System.out.println(sum(n));}
}
</code></pre><p>}<br><br>本身这道题目很简单，但确实花了我不少时间，嗯，还是不熟啊。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Windows Azure中创建并连接mysql]]></title>
      <url>http://yoursite.com/2015/10/27/%E5%9C%A8Windows_Azure%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%9E%E6%8E%A5mysql/</url>
      <content type="html"><![CDATA[<p>微软云中的数据库令人神往，尤其是云数据库中的MySql让无数仁人志士更为之向往。今天，咱们就一起尝试在微软云中创建一个MySql应用，并且将云服务器中的本地数据库迁移到云上。不过要着重提醒大家的是，云数据库的容量是有限的，陈亚伦在这里用的是20M的数据库，(T_T)，当然，因为是免费的。你玩的要是app，大型网站之类，建议选择微软云的高级订阅。因为我这里连接的是个人gallery，所以不介意数据库的大小。</p>
<h3 id="1，创建数据库订阅"><a href="#1，创建数据库订阅" class="headerlink" title="1，创建数据库订阅"></a>1，创建数据库订阅</h3><p>首先打开仪表板：<a href="http://www.chenyalun.cn/go/?url=https://portal.azure.com/" target="_blank" rel="external">https://portal.azure.com/</a>，最左侧选择“新建”—“数据 + 存储器”—“MySQL 数据库”。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5102601.jpg" alt=""></p>
<p>接着便是进行一系列的设置，location一般选择东亚，定价层根据自己情况而定，水星是免费的，还有Titan、金星、土星、木星，价格不同，大小也不同。最后别忘了法律条款的授权。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5102602.jpg" alt=""></p>
<p>创建成功后便可以看到如图所示的界面。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5102603.jpg" alt=""></p>
<p>打开“所有设置”，选择属性，可以清晰地看到状态、数据库名、主机名、用户名、密码、订阅类型等等。</p>
<p>那么，我们需要的便是主机名（主机地址）、用户名、密码，方便本地与云端的连接。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5102604.jpg" alt=""></p>
<p>猛戳仪表板上的管理数据库，便可跳转到cleardb整体预览，那么，亲想要在本地连接并管理吗？</p>
<p><img src="http://source.chenyalun.cn/images/201510/5102605.jpg" alt=""></p>
<h3 id="2，迁移数据库"><a href="#2，迁移数据库" class="headerlink" title="2，迁移数据库"></a>2，迁移数据库</h3><p>就是它：<a href="http://www.chenyalun.cn/go/?url=http://www.mysql.com/products/workbench/" target="_blank" rel="external">http://www.mysql.com/products/workbench/</a></p>
<p>下载你需要的管理工具即可。</p>
<p>安装成功后，填写刚刚在“属性”中的相关信息，譬如主机名、用户名、密码什么的，点击OK，便可轻松连接。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5102606.jpg" alt=""></p>
<p>若是要连接云端的数据库，首先我们要做的肯定是把原来的数据库迁移过来。当然，这里你肯定要有已经导出的数据库，直接导入即可。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5102607.jpg" alt=""></p>
<p><img src="http://source.chenyalun.cn/images/201510/5102608.jpg" alt=""></p>
<p>如此我们便把数据库巧妙地迁移到云端了，不对，你还要在你的网站或者软件的配置信息中稍做修改，这样才完美实现迁移。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[题目1008：质数还是合数]]></title>
      <url>http://yoursite.com/2015/10/26/%E9%A2%98%E7%9B%AE1008%EF%BC%9A%E8%B4%A8%E6%95%B0%E8%BF%98%E6%98%AF%E5%90%88%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><strong>质数</strong>（prime number）又称素数，有无限个。一个大于1的自然数，除了1和它本身外，不能被其他自然数整除，换句话说就是该数除了1和它本身以外不再有其他的因数；否则称为<strong>合数</strong>。</p>
<p>题目描述：给定一个正整数n(2&lt;n&lt;10000)，判断是否为质数</p>
<p>输入：多组输入，每行一个n(2&lt;n&lt;=10000),</p>
<p>输出：对于每一组数，如果是质数则输出Yes，否则输出No</p>
<p>样例：</p>
<p>2<br>3<br>4</p>
<p>Yes<br>Yes<br>No</p>
<p>看完题目，思路马上就有了。无非是先判断是不是为质数，进而输出Yes和No。怎么判断是不是为质数呢？</p>
<p>在一般领域，对正整数n，如果用2到n之间的所有整数去除，均无法整除，则n为质数。无非做个循环嘛，可是专家说了，不用到n，到根号2就可以了。因为将n分解为两个因数，必然一个大于根号2，一个小于根号2，比如18，分解成1和18、2和9、3和6，而18开根号约为4.2，看看，很符合吧。所以，循环到根号2就可以，不用浪费时间、消耗代码。</p>
<h3 id="1，C代码"><a href="#1，C代码" class="headerlink" title="1，C代码"></a>1，C代码</h3><pre class="lang:default decode:true">#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
char *prime(int a){
    char m[]="Yes";
    char n[]="No";
    int i=2,b=(int)sqrt(double (a));;
    for(;i&lt;=b;i++){
        if(a%i==0)
        break;
    }
    if(i&gt;b)
    return "Yes";
    else
    return "No";  
}

int main(){
    int n,i=0,a[100];
    scanf("%d",&amp;n);
    for(;i&lt;n;i++)
        scanf("%d",&amp;a[i]);
    for(i=0;i&lt;n;i++)    
        printf("%s\n",prime(a[i]));    
    return 0;
}
</pre>

<h3 id="2，C-代码"><a href="#2，C-代码" class="headerlink" title="2，C++代码"></a>2，C++代码</h3><pre class="lang:default decode:true ">#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
string prime(int a){
    int i=2,b;
    b=(int)sqrt(double (a));//sqrt()的参数为 double 类型
    for(;i&lt;=b;i++){
        if(a%i==0)
        break;
    }
    if(i&gt;b)
    return "Yes";
    else
    return "No";
}
int main(){
    int n,i=0,a[100];
    cin&gt;&gt;n;
    for(;i&lt;n;i++)
    cin&gt;&gt;a[i];
    for(i=0;i&lt;n;i++)
    cout&lt;&lt;prime(a[i])&lt;&lt;endl;
    return 0;
}
</pre>

<h3 id="3，JAVA代码"><a href="#3，JAVA代码" class="headerlink" title="3，JAVA代码"></a>3，JAVA代码</h3><p><pre class="lang:default decode:true ">import java.util.*;</pre></p>
<p>public class Main {<br>    static String prime(int a){<br>        int i=2,b;<br>        b=(int)Math.sqrt(a);//sqrt()的参数为 double 类型<br>        for(;i&lt;=b;i++){<br>            if(a%i==0)<br>            break;<br>        }<br>        if(i&gt;b)<br>        return “Yes”;<br>        else<br>        return “No”;<br>    }</p>
<pre><code>public static void main(String[] args) {
    int n,i=0;
    int a[]=new int [100];
    Scanner s=new Scanner(System.in);
    n=s.nextInt();
    for(;i&amp;lt;n;i++)
    a[i]=s.nextInt();;
    for(i=0;i&amp;lt;n;i++)
    System.out.println(prime(a[i]));
}
</code></pre><p>}<br><br>依然看不出差别有多大，但是值得一提的是，在C中，函数的返回值没有string，很不方便，返回”Yes“和”No”让我想了半天。当然，小伙伴劝我，不用那么强迫症非要在函数里返回，主函数写个”Yes“和”No”效果一样的。但是，纠结着最终还是实现了。</p>
<p>string prime(int a){}这样的函数在C中会报错，所以char <em>prime(int a){}是很巧妙的。</em>prime指向字符串”Yes“和”No”的首地址，打印%s，就可以借助强大的printf函数，把整个字符串（字符数组也可以）打印出来，着实强大！当然啦，%c，打印首个字符（Y或者N）。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[题目1005：最大公约数与最小公倍数]]></title>
      <url>http://yoursite.com/2015/10/24/%E9%A2%98%E7%9B%AE1005%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>最大公约数与最小公倍数应该是程序小题中的基础，今天闲来无事，再来探讨一下。所谓的最大公约数，其实求法比较多，但我比较青睐的还是欧几里得算法，当然，每个人都有自己的见解，因为题目比较简单，所以直接上代码啦。</p>
<p>先看题目：给定2个数，a和b(3&lt;a,b&lt;=10000)，求出a和b的最大公约数</p>
<p>输入：多组输入，输入的第一行为一个正整数n，表示接下来有n组数据，每一行为两个正整数a，b(3&lt;a,b&lt;=10000)</p>
<p>输出：对于每一组数据，求出a和b的最大公约数。</p>
<p>示例：</p>
<p>3</p>
<p>12 15</p>
<p>20 40</p>
<p>3 5</p>
<p>输出：</p>
<p>3</p>
<p>20</p>
<p>1</p>
<h3 id="1，求解方法"><a href="#1，求解方法" class="headerlink" title="1，求解方法"></a>1，求解方法</h3><p>&nbsp;</p>
<p>看看<strong>质数分解法：</strong>求24和60的最大公约数，先分解质因数，得24=2×2×2×3，60=2×2×3×5，24与60的全部公有的质因数是2、2、3，它们的积是2×2×3=12，所以，（24、60）=12。</p>
<p>把几个数先分别分解质因数，再把各数中的全部公有的质因数和独有的质因数提取出来连乘，所得的积就是这几个数的<strong>最小公倍数</strong>。</p>
<p>瞅见了吧，定义就是这么说的。</p>
<p><strong>短除法：</strong>短除法求最大公约数，先用这几个数的公约数连续去除，一直除到所有的商互质为止，然后把所有的除数连乘起来，所得的积就是这几个数的最大公约数。</p>
<p>而<strong>辗转相除法</strong>（也就是<strong>欧几里得算法</strong>）的原理是什么呢？</p>
<p>说真的，一切的核心就是那个函数段。</p>
<pre class="lang:default decode:true">int r;
        do{
            r=a%b;
            a=b;
            b=r;
            }while(r!=0);    
        return a;</pre>
先是定义一个变量r，然后便是一步一步一直一直循环循环，直到余数为0。这是为什么呢？

比如求98与63的最大公约数吧
<div class="para">∵ 98÷63=1（余35）</div>
<div class="para">∴（98，63）=（63，35）</div>
<div class="para">

∵ 63÷35=1（余28）
<div class="para">∴（63，35）=（35，28）</div>
<div class="para">

∵ 35÷28=1（余7）
<div class="para">∴（35，28）=（28，7）</div>
<div class="para">∵ 28÷7=4（余0）</div>
<div class="para">∴（28，7）=7</div>
<div class="para">而28与7的最大公约数为7，所以7=（28，7）=（35，28）=（63，35）=（98，63）</div>
<div class="para">因此98与63的最大公约数为7，不要告诉我你不知道（98，63）代表神马意思。。</div>
</div>
</div>
计算次数上辗转相除法计算次数相对较少，特别当两个数字大小区别较大时计算次数的区别较明显。

### 2，C语言实现

<pre class="lang:default decode:true">//最大公约数
#include&lt;stdio.h&gt;
int divisor(int a,int b){
    int r;
    do{
        r=a%b;
        a=b;
        b=r;
        }while(r!=0);    
    return a;
}
int main(){
    int n,i=0,a[100][2];
    scanf("%d",&amp;n);
    for(;i&lt;n;i++)
        scanf("%d %d",&amp;a[i][0],&amp;a[i][1]);
    for(i=0;i&lt;n;i++)
        printf("%d\n",divisor(a[i][0],a[i][1]));
    return 0;
}</pre>

<h3 id="3，C-代码实现"><a href="#3，C-代码实现" class="headerlink" title="3，C++代码实现"></a>3，C++代码实现</h3><pre class="lang:default decode:true">//最大公约数
#include&lt;iostream&gt;
using namespace std;
int divisor(int a,int b){
    int r;
    do{
        r=a%b;
        a=b;
        b=r;
        }while(r!=0);    
    return a;
}
int main(){
    int n,i=0,a[100][2];
    cin&gt;&gt;n;
    for(;i&lt;n;i++)
    cin&gt;&gt;a[i][0]&gt;&gt;a[i][1];
    for(i=0;i&lt;n;i++)
    cout&lt;&lt;divisor(a[i][0],a[i][1])&lt;&lt;endl;
    return 0;
}</pre>

<h3 id="4，JAVA代码实现"><a href="#4，JAVA代码实现" class="headerlink" title="4，JAVA代码实现"></a>4，JAVA代码实现</h3><pre class="lang:default decode:true">//最大公约数
import java.util.*;

public class Main {
    static int divisor(int a,int b){
        int r;
        do{
            r=a%b;
            a=b;
            b=r;
            }while(r!=0);    
        return a;
    }
    public static void main(String[] args) {
        int n ,i=0;
        int a[][]=new int [100][2];
        Scanner s=new Scanner(System.in);
        n=s.nextInt();
        for(;i&lt;n;i++){
            a[i][0]=s.nextInt();
            a[i][1]=s.nextInt();
        }
        for(i=0;i&lt;n;i++)
        System.out.println(divisor(a[i][0],a[i][1]));

    }

}</pre>
可以看到，换汤不换药，三种代码用的是同一个函数，只是输入输出变换了。(/▽＼=)别怪我偷懒哦。

### 4，最小公倍数定理

**两个自然数的最大公约数与它们的最小公倍数的乘积等于这两个数的乘积。**

显然，最大公约数求出来了，最小公倍数简直“呼之欲出”啊，呵呵，不知道成语有没有用错，别管我没文化。

改编的代码呈现。

#### C代码

<pre class="lang:default decode:true ">//最小公倍数
#include&lt;stdio.h&gt;
int divisor(int a,int b){
    int r;
    do{
        r=a%b;
        a=b;
        b=r;
        }while(r!=0);    
    return a;
}
int main(){
    int n,i=0,a[100][2];
    scanf("%d",&amp;n);
    for(;i&lt;n;i++)
        scanf("%d %d",&amp;a[i][0],&amp;a[i][1]);
    for(i=0;i&lt;n;i++)
        printf("%d\n",a[i][0]*a[i][1]/divisor(a[i][0],a[i][1]));
    return 0;
}</pre>

<h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h4><pre class="lang:default decode:true ">//最小公倍数
#include&lt;iostream&gt;
using namespace std;
int divisor(int a,int b){
    int r;
    do{
        r=a%b;
        a=b;
        b=r;
        }while(r!=0);    
    return a;
}
int main(){
    int n,i=0,a[100][2];
    cin&gt;&gt;n;
    for(;i&lt;n;i++)
    cin&gt;&gt;a[i][0]&gt;&gt;a[i][1];
    for(i=0;i&lt;n;i++)
    cout&lt;&lt;a[i][0]*a[i][1]/divisor(a[i][0],a[i][1])&lt;&lt;endl;
    return 0;</pre>

<h4 id="JAVA代码"><a href="#JAVA代码" class="headerlink" title="JAVA代码"></a>JAVA代码</h4><p><pre class="lang:default decode:true ">import java.util.*;</pre></p>
<p>public class Main {<br>    static int divisor(int a,int b){<br>        int r;<br>        do{<br>            r=a%b;<br>            a=b;<br>            b=r;<br>            }while(r!=0);<br>        return a;<br>    }<br>    public static void main(String[] args) {<br>        int n ,i=0;<br>        int a[][]=new int [100][2];<br>        Scanner s=new Scanner(System.in);<br>        n=s.nextInt();<br>        for(;i&lt;n;i++){<br>            a[i][0]=s.nextInt();<br>            a[i][1]=s.nextInt();<br>        }<br>        for(i=0;i&lt;n;i++)<br>        System.out.println(a[i][0]*a[i][1]/divisor(a[i][0],a[i][1]));</p>
<pre><code>}
</code></pre><p>}<br><br>上面的代码意义并不是很大，所以不说什么了。</p>
<p>值得注意的是，两个数的最大公约数求出来了，三个数那就不再话下了。</p>
<p><pre class="lang:default decode:true ">#include&lt;iostream&gt;<br>using namespace std;<br>int divisor(int a,int b){<br>    int r;<br>    do{<br>        r=a%b;<br>        a=b;<br>        b=r;<br>        }while(r!=0);<br>    return a;<br>}<br>int main(){<br>    int n,i=0,a[100][3];<br>    cin&gt;&gt;n;<br>    for(;i&lt;n;i++)<br>    cin&gt;&gt;a[i][0]&gt;&gt;a[i][1]&gt;&gt;a[i][2];<br>    for(i=0;i&lt;n;i++)<br>    cout&lt;&lt;divisor(a[i][0],divisor(a[i][1],a[i][2]))&lt;&lt;endl;<br>    return 0;<br>}<br></pre><br>照着这个思路，题目1007又可以轻而易举的解决了。上面只是C++代码，其他的就不再赘述了。</p>
<p>还有就是整套代码我放在云端了，下载地址：<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1mg1YbaC" target="_blank" rel="external">http://pan.baidu.com/s/1mg1YbaC</a></p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信应用之交通信息查询]]></title>
      <url>http://yoursite.com/2015/10/22/%E5%BE%AE%E4%BF%A1%E5%BA%94%E7%94%A8%E4%B9%8B%E4%BA%A4%E9%80%9A%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2/</url>
      <content type="html"><![CDATA[<p>基本上如果不是每天都宅在家里，公交车，实时路况，航班，火车等这些交通信息我们是肯定要用到的。其实这些信息也是比较好查询的，百度一下，全都有了。不过在微信上，把这些功能集于一体也是很有意思的。</p>
<h3 id="1，查询网站"><a href="#1，查询网站" class="headerlink" title="1，查询网站"></a>1，查询网站</h3><p>公交：<a href="http://m.8684.cn/bus" target="_blank" rel="external">http://m.8684.cn/bus</a>                                           <a href="http://m.gongjiao.com/" target="_blank" rel="external">http://m.gongjiao.com/</a></p>
<p>汽车：<a href="http://touch.trip8080.com/" target="_blank" rel="external">http://touch.trip8080.com/</a>                                 <a href="http://m.checi.org/" target="_blank" rel="external">http://m.checi.org/</a></p>
<p>火车：<a href="http://m.ctrip.com/html5/Trains/" target="_blank" rel="external">http://m.ctrip.com/html5/Trains/</a>                     <a href="http://m.huoche.com.cn/" target="_blank" rel="external">http://m.huoche.com.cn/</a></p>
<p>飞机：<a href="http://touch.qunar.com/h5/flight/" target="_blank" rel="external">http://touch.qunar.com/h5/flight/</a></p>
<p>路况：<a href="http://dp.sina.cn/dpool/tools/citytraffic/city.php" target="_blank" rel="external">http://dp.sina.cn/dpool/tools/citytraffic/city.php</a></p>
<p>违章：<a href="http://app.eclicks.cn/violation2/webapp/index?appid=10" target="_blank" rel="external">http://app.eclicks.cn/violation2/webapp/index?appid=10</a></p>
<p>这些查询网站非常多，当然广告也是非常多，比较恶心，如果你找到自己心仪的网站，替换即可。</p>
<h3 id="2，代码实现"><a href="#2，代码实现" class="headerlink" title="2，代码实现"></a>2，代码实现</h3><p>其实这些都不是接口，只是当用户输入“交通”的时候，微信公众号返回给用户一条图文而已，而图文则指向了相应的网址。那么举一反三，除了交通之外，任何我们想指向的网址都是可以的，所以技术含量并不高。</p>
<pre class="lang:default decode:true ">&lt;?php
define("TOKEN", "chenyalun");

$wechatObj = new wechatCallbackapiTest();
if (!isset($_GET['echostr'])) {
    $wechatObj-&gt;responseMsg();
}else{
    $wechatObj-&gt;valid();
}

class wechatCallbackapiTest
{
    public function valid()
    {
        $echoStr = $_GET["echostr"];
        if($this-&gt;checkSignature()){
            echo $echoStr;
            exit;
        }
    }

    private function checkSignature()
    {
        $signature = $_GET["signature"];
        $timestamp = $_GET["timestamp"];
        $nonce = $_GET["nonce"];
        $token = TOKEN;
        $tmpArr = array($token, $timestamp, $nonce);
        sort($tmpArr);
        $tmpStr = implode($tmpArr);
        $tmpStr = sha1($tmpStr);

        if($tmpStr == $signature){
            return true;
        }else{
            return false;
        }
    }

    public function responseMsg()
    {
        $postStr = $GLOBALS["HTTP_RAW_POST_DATA"];
        if (!empty($postStr)){
            $this-&gt;logger("R ".$postStr);
            $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);
            $RX_TYPE = trim($postObj-&gt;MsgType);

            switch ($RX_TYPE)
            {
                case "event":
                    $result = $this-&gt;receiveEvent($postObj);
                    break;
                case "text":
                    $result = $this-&gt;receiveText($postObj);
                    break;

            }
            $this-&gt;logger("T ".$result);
            echo $result;
        }else {
            echo "";
            exit;
        }
    }

    private function receiveEvent($object)
    {
        $content = "";
        switch ($object-&gt;Event)
        {
            case "subscribe":
                $content = "欢迎关注陈亚伦博客 ";
                break;
            case "unsubscribe":
                $content = "取消关注";
                break;
        }
        $result = $this-&gt;transmitText($object, $content);
        return $result;
    }

    private function receiveText($object)
    {
        $keyword = trim($object-&gt;Content);
        $content[] = array("Title" =&gt;"交通信息","Description" =&gt;"", "PicUrl" =&gt;"", "Url" =&gt;"http://m.8684.cn/bus");
        $content[] = array("Title" =&gt;"【公交线路】\n全车公交查询", "Description" =&gt;"", "PicUrl" =&gt;"http://photo.candou.com/ai/114/09caed4a27c56000bb870c68ab028850", "Url" =&gt;"http://m.8684.cn/shenzhen_bus");
        $content[] = array("Title" =&gt;"【汽车班次】\n长途汽车班车", "Description" =&gt;"", "PicUrl" =&gt;"http://photo.candou.com/i/175/4951bd2a2f368cafc5ad09ff95ce591d", "Url" =&gt;"http://touch.trip8080.com/");
        $content[] = array("Title" =&gt;"【火车时刻】\n火车时刻查询", "Description" =&gt;"", "PicUrl" =&gt;"http://photo.candou.com/ai/114/26a9407dcedda5f4a30b195f78ec3680", "Url" =&gt;"http://m.ctrip.com/html5/Trains/");
        $content[] = array("Title" =&gt;"【飞 机 票】\n机票查询", "Description" =&gt;"", "PicUrl" =&gt;"http://photo.candou.com/i/175/a1bd6303a8bde7da50166aa8dafb7568", "Url" =&gt;"http://touch.qunar.com/h5/flight/");
        $content[] = array("Title" =&gt;"【城市路况】\n重点城市实时路况", "Description" =&gt;"", "PicUrl" =&gt;"http://photo.candou.com/i/175/0d8488edf94574651d048025596a6190", "Url" =&gt;"http://dp.sina.cn/dpool/tools/citytraffic/city.php");
        $content[] = array("Title" =&gt;"【违章查询】\n全国违章查询", "Description" =&gt;"", "PicUrl" =&gt;"http://g.hiphotos.bdimg.com/wisegame/pic/item/9e1f4134970a304eab30503cd0c8a786c8175ce2.jpg", "Url" =&gt;"http://app.eclicks.cn/violation2/webapp/index?appid=10");

        $result = $this-&gt;transmitNews($object, $content);
        return $result;
    }

    private function transmitText($object, $content)
    {
        $textTpl = "&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;%s&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;
&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;
&lt;/xml&gt;";
        $result = sprintf($textTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), $content);
        return $result;
    }

    private function transmitNews($object, $arr_item)
    {
        if(!is_array($arr_item))
            return;

        $itemTpl = "    &lt;item&gt;
        &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt;
        &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt;
        &lt;PicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/PicUrl&gt;
        &lt;Url&gt;&lt;![CDATA[%s]]&gt;&lt;/Url&gt;
    &lt;/item&gt;
";
        $item_str = "";
        foreach ($arr_item as $item)
            $item_str .= sprintf($itemTpl, $item['Title'], $item['Description'], $item['PicUrl'], $item['Url']);

        $newsTpl = "&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;%s&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt;
&lt;Content&gt;&lt;![CDATA[]]&gt;&lt;/Content&gt;
&lt;ArticleCount&gt;%s&lt;/ArticleCount&gt;
&lt;Articles&gt;
$item_str&lt;/Articles&gt;
&lt;/xml&gt;";

        $result = sprintf($newsTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), count($arr_item));
        return $result;
    }

    private function logger($log_content)
    {
        if(isset($_SERVER['HTTP_BAE_ENV_APPID'])){   //BAE
            require_once "BaeLog.class.php";
            $logger = BaeLog::getInstance();
            $logger -&gt;logDebug($log_content);
        }else if(isset($_SERVER['HTTP_APPNAME'])){   //SAE
            sae_set_display_errors(false);
            sae_debug($log_content);
            sae_set_display_errors(true);
        }else if($_SERVER['REMOTE_ADDR'] != "127.0.0.1"){ //LOCAL
            $max_size = 10000;
            $log_filename = "log.xml";
            if(file_exists($log_filename) and (abs(filesize($log_filename)) &gt; $max_size)){unlink($log_filename);}
            file_put_contents($log_filename, date('H:i:s')." ".$log_content."\r\n", FILE_APPEND);
        }
    }
}
?&gt;</pre>

<h3 id="3，图片示例"><a href="#3，图片示例" class="headerlink" title="3，图片示例"></a>3，图片示例</h3><p><img src="http://source.chenyalun.cn/images/201510/5101701.png" alt=""><img src="http://source.chenyalun.cn/images/201510/5101702.png" alt=""><img src="http://source.chenyalun.cn/images/201510/5101703.png" alt=""></p>
<p>&nbsp;</p>
<p>不想直接复制代码的同学请直接下载完整代码</p>
<p>下载地址:<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1FP3oq" target="_blank" rel="external">http://pan.baidu.com/s/1FP3oq</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用VS2015发布Windows Azure网页应用]]></title>
      <url>http://yoursite.com/2015/10/20/%E5%88%A9%E7%94%A8VS2015%E5%8F%91%E5%B8%83Windows_Azure%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>相信vs2015大家都已经下载安装了，确实，这个版本着实让我惊喜了一把，尤其是同步到微软云，极其方便。今天，咱们就分享一下怎么在vs2015上发布网页应用。当然，大神们可以直接略过啦。</p>
<h3 id="1，准备工作"><a href="#1，准备工作" class="headerlink" title="1，准备工作"></a>1，准备工作</h3><ul>
<li>Visual Studio  2015</li>
<li><span lang="zh-chs">已经安装<a href="http://www.chenyalun.cn/go/?url=https://azure.microsoft.com/blog/2015/07/20/announcing-the-azure-sdk-2-7-for-net/" target="_blank" rel="external">Azure SDK 2.7</a></span><a href="http://www.chenyalun.cn/go/?url=https://azure.microsoft.com/blog/2015/07/20/announcing-the-azure-sdk-2-7-for-net/" target="_blank" rel="external">   </a>，下载<a href="http://go.microsoft.com/fwlink/?linkid=518003&amp;clcid=0x804" target="_blank" rel="external">vs2015版</a>，<a href="http://go.microsoft.com/fwlink/p/?linkid=323510&amp;clcid=0x804" target="_blank" rel="external">vs2013版</a>（下载成功后，运行，选择你需要的产品安装即可，在这里我们选择Windows Azure PowerShell）</li>
</ul>
<h3 id="2，启动连接"><a href="#2，启动连接" class="headerlink" title="2，启动连接"></a>2，启动连接</h3><p>打开vs2015，一般默认是自动登录，没有的话，右上角点击登录即可。</p>
<p>依次打开  文件&gt;新建&gt;网站。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101622.jpg" alt=""></p>
<h3 id="3-添加页面"><a href="#3-添加页面" class="headerlink" title="3,添加页面"></a>3,添加页面</h3><p>在右侧的解决方案管理器中右击，点击添加，添加新项。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101623.jpg" alt=""></p>
<p>默认的就是下图这样，当然创建html页，确定添加即可。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101624.jpg" alt=""></p>
<h3 id="4，修改代码"><a href="#4，修改代码" class="headerlink" title="4，修改代码"></a>4，修改代码</h3><p>看吧，出现了默认的代码，现在要做的是：</p>
<p>1，在右侧的这个页面管理中，右击HtmlPage.html，选择重命名为index.html，这样做是为了更加方便的访问到这个页面。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101626.jpg" alt=""></p>
<p>2，复制下面的代码。</p>
<p><pre class="nums:false lang:default decode:true">&lt;!DOCTYPE html&gt;</pre></p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;</p>
<p>&lt;title&gt;Hello Cloud!&lt;/title&gt;</p>
<p>&lt;meta charset=”utf-8” /&gt;</p>
<p>&lt;/head&gt;</p>
<p>&lt;body&gt;</p>
<p>&lt;h1&gt;Hello Cloud!&lt;/h1&gt;</p>
<p>&lt;p&gt;Check out this sweet website I made in Visual Studio 2015!&lt;/p&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;<br>3，全选页面的所有代码（ctrl+a），粘贴即可（ctrl+v）,别忘了要保存呦（ctrl+s )</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101625.jpg" alt=""></p>
<h3 id="5，进行发布"><a href="#5，进行发布" class="headerlink" title="5，进行发布"></a>5，进行发布</h3><p>依然是在解决方案中，右击，选择“发布web应用”</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101627.jpg" alt=""></p>
<p>然后你就看到下面的界面了。选择第一个，发布到微软云。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101628.jpg" alt=""></p>
<p>选择下一页，连接到你的云服务即可，点击发布。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101630.jpg" alt=""></p>
<p>接着是下面的界面，我们可以重新创建一个网页应用，嗯，我们确实也需要重建一个网页应用。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101629.jpg" alt=""></p>
<p>发布成功之后，访问我们设置的域名<a href="http://chenyalun2.azurewebsites.net/" target="_blank" rel="external">http://chenyalun2.azurewebsites.net/</a></p>
<p>果然，是我们写的，不对，是我们粘贴的代码，一个网页应用就这么成功的发布了。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101631.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用Windows Azure部署一个WordPress网站]]></title>
      <url>http://yoursite.com/2015/10/18/%E5%88%A9%E7%94%A8Windows_Azure%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AAWordPress%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<p>最近倒是对云计算很感兴趣，比较著名的应该就是微软云，亚马逊云，谷歌云了。今天就分享一下怎么在Windows Azure上部署一个基于wordpress的站点。过程比较简单，希望能给新手们一些帮助。</p>
<h3 id="1，登录Windows-Azure主页"><a href="#1，登录Windows-Azure主页" class="headerlink" title="1，登录Windows Azure主页"></a>1，登录Windows Azure主页</h3><p>点击：<a href="http://www.chenyalun.cn/go/?url=https://portal.azure.com/" target="_blank" rel="external"> https://portal.azure.com/</a></p>
<p>前提是你有Windows Live ID（现在很流行的是outlook邮箱），没有注册的注册一个即可。注册成功便可以登录你的微软账号啦，接着便是注册微软云（Windows Azure），可能需要提供信用卡号和（非中国大陆的）手机号。当然，因为众所周知的原因微软云并不直接在中国大陆推行，你也可以使用在中国的代理商世纪华联，其实效果是一样的，不过我还是想用原汁原味的微软云，所以这里以全球统一的微软云官网为例，就不分享在中国代理世纪华联怎么部署了。</p>
<h3 id="2，创建Web-应用"><a href="#2，创建Web-应用" class="headerlink" title="2，创建Web 应用"></a>2，创建Web 应用</h3><p>在微软云主页，请依次点击 新建&gt;&gt;Web+移动&gt;&gt;应用商店，效果如下图所示。<img src="http://source.chenyalun.cn/images/201510/5101601.jpg" alt=""></p>
<p>在搜索框中输入 wordpress,选择第一个。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101602.jpg" alt=""></p>
<h3 id="3，填写相关信息"><a href="#3，填写相关信息" class="headerlink" title="3，填写相关信息"></a>3，填写相关信息</h3><p>1，域名：类似 <a href="http://XXXX.azurewebsites.net，XXXX可以设置成自己喜欢的字符，比如我的是http://chenyalun.azurewebsites.net，当然，这个是默认域名，你可以自定义绑定一级、二级域名，前提仍然是你的订阅是可以付费的。" target="_blank" rel="external">http://XXXX.azurewebsites.net，XXXX可以设置成自己喜欢的字符，比如我的是http://chenyalun.azurewebsites.net，当然，这个是默认域名，你可以自定义绑定一级、二级域名，前提仍然是你的订阅是可以付费的。</a></p>
<p>2，数据库：数据库名称可以自定义，比较好的一点就是，你不用再另外记忆数据库的名称和密码，完成之后站点直接就和数据库相连接啦。</p>
<p>3，地域：这个不多说，看你网站的受众主要在哪个地方了，若是中国，那选择East Asia就可以啦，好像这个设置不可以更改，所以请慎重。（这个只是机房的位置，并不是说，除了这个位置的人之外，其他地方的人不能访问你的站点，唯一的影响就是，其他地方访问时速度可能相对比较慢）</p>
<p>4，定价层：选择你的数据库的套餐（容量，连接总数等，一个数据库可以让多个站点同时使用的），免费套餐是“水星”，容量是0.02G.连接总数是4个。下图中的套餐“Titan”连接总数为10个，大小为0.24G，当然每个月3.5美金。一共有5个套餐可以选择。</p>
<p>当然还有法律条款，这都是需要同意的。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101603.jpg" alt=""></p>
<p>填写完毕之后，点击创建即可。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101604.jpg" alt=""></p>
<h3 id="4，安装wordpress"><a href="#4，安装wordpress" class="headerlink" title="4，安装wordpress"></a>4，安装wordpress</h3><p>至此，一个Web 应用已经创建好了，下面开始安装wordpress。打开你的应用主页，就是你最初设置的域名，直接跳转到安装界面，如图，选择你想要的语言，这里以英语为例（如果你是面向中国的网站，选择简体中文就可以啦）</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101605.jpg" alt=""></p>
<p>点击“继续”按钮，填写网站的相应信息。</p>
<p>1，站点名称（Site-Title）：你自己想</p>
<p>2，用户名Username）：你以后登录网站后台的用户名</p>
<p>3，密码（Password）：不多说</p>
<p>4，邮箱（Your-Email）：填写常用邮箱即可</p>
<p>5，privacy：是否允许搜索引擎（百度、谷歌等）抓取你的网站，一般默认是同意的，除非你的网站只是想自己看。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101606.jpg" alt=""></p>
<p>填写好之后点击安装即可。秒秒钟，wordpress安装成功。接下来便是登录你的站点了。输入你刚才的用户名，密码（不要告诉我你已经忘啦，否则很麻烦，很麻烦，很麻烦）</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101007.jpg" alt=""></p>
<p>登录成功后，你的后台界面：</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101608.jpg" alt=""></p>
<p>网站前台界面：</p>
<p><img src="http://source.chenyalun.cn/images/201510/5101609.jpg" alt=""></p>
<p>于是，一个基于wordpress的站点就这么诞生啦。是不是很简单呢。</p>
<p>在Windows Azure上部署Web应用其实就是这么容易，这就是云的强大。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[题目1001：整数a+b的程序实现（下）]]></title>
      <url>http://yoursite.com/2015/10/11/%E9%A2%98%E7%9B%AE1001%EF%BC%9A%E6%95%B4%E6%95%B0a+b%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在【<a href="http://www.chenyalun.cn/%e9%a2%98%e7%9b%ae1001%ef%bc%9a%e6%95%b4%e6%95%b0ab%e7%9a%84%e7%a8%8b%e5%ba%8f%e5%ae%9e%e7%8e%b0%ef%bc%88%e4%b8%8a%ef%bc%89.html" target="_blank" rel="external">题目1001：整数a+b的程序实现（上）</a>】中我们简要讨论了正整数相加，当然，整数的大小在计算机心理承受范围之内，时隔好几天，继续探讨，这里就说下，大整数的加法。</p>
<p>关于高精度正整数加法，我首先想到的是利用数组存储那些可爱的数字们，但是又考虑到字符串同样可以存储200位的数字，然后就有下面3种解决方案。<br>1，只用数组<br>2，只用字符串<br>3，数组和字符串双管齐下<br>方案1：每个数组元素存储1位，需要多少位数字就开辟多少个数组元素<br>优点：数组中的每一位都是实实在在的数字，可以直接加减，运算时极为方便；<br>缺点：从键盘输入的时候很不爽，输入时每两位数之间必须有分隔符，才能保证一位数组元素存储一个数字，不符合正常人的输入习惯；</p>
<p>方案2：其实字符串的最大长度是255，可以表示255位，那么200位当然不在话下<br>优点：可以直接输入输出，输入时，每两位数之间不必分隔符，符合地球人的输入习惯；<br>缺点：字符串中的每一位是一个字符，而字符是不能直接进行运算的，我们必须先将它转化为数值再进行运算，在转化的时候要考虑很多东西；</p>
<p>方案3：输入的时候用字符串，计算的时候用数组。<br>优点：充分利用字符串和数组的优点，趋利避害，计算简便，容易理解，这个在臣妾看来，是极好的呀；<br>缺点：我们需要开辟数组存储空间，开辟字符串存储空间，些许占内存；<br>但是综合以上几点，显然，方案3是最巧妙的，既然如此，那代码怎么写呢？</p>
<p>考虑大整数相加有两种情况（美观起见我用三位数代替200位数的情况，效果其实一样：</p>
<p>a[3] 099<br>b[3] 009<br>c[3] 108</p>
<p>和<br>a[3] 091<br>b[3] 002<br>c[3] 093<br>显而易见，我们需要将两个字符串中长度最大的值作为所得结果数组c的长度，这时还要考虑数组c的首位元素是否为0，因为不可能输出093这样的数，必须把0去掉。</p>
<p>思路：<br>1，开辟两个字符串用于存储键入的两串数字<br>2，求取两个字符串中的最大长度<br>3，将字符串转化为数组（从末尾开始依次存取）<br>4，数组中每位元素相加，并考虑进位，得出的结果存储在c[3]中<br>5，判断相加的结果c[3]数组首位c[0]是否为0，若为0，从c[1]开始打印，若不为0，从c[0]开始打印。<br>6，喝杯茶开始敲代码</p>
<p>为节约内存，我把两个数组相加的结果依然存储在数组a中，就不再开辟多余的数组啦。代码如下：</p>
<h3 id="1，C语言版"><a href="#1，C语言版" class="headerlink" title="1，C语言版"></a>1，C语言版</h3><pre class="lang:default decode:true">//高精度正整数相加-C语言
//@陈亚伦博客 

#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
    void Add(char s1[200],char s2[200]){    
    int a[200]={0},b[200]={0},l1,l2,m,n,i;
    l1=strlen(s1);
    l2=strlen(s2);               //分别取出s1、s2的长度 赋给l1,l2 
    if(l1&lt;l2)
       m=l2;
    else
       m=l1;
    n=m;                         //取出l1与l2两者的最大值，赋予m和n 
    for( i=0;i&lt;l1;m--,i++) 
        a[m]=s1[l1-1-i]-'0';
    for(m=n,i=0;i&lt;l2;m--,i++)
         b[m]=s2[l2-1-i]-'0';    //将字符串s1，s2分别转化为数组a，b     
    for(i=n;i&gt;=0;i--)           //for循环开始实现两个数组相加 
    {    
       a[i]+=b[i];              //把两个数的结果给a[i] 
         if(a[i]&gt;=10)            //对是否进位进行判断
        {    
        a[i]-=10;
        a[i-1]+=1;              //a[i-1]++;
         }
    }
    if(a[0]!=0)                 //判断数组ａ的首位是否为０
    {
     for(i=0;i&lt;=n;i++)
       printf("%d",a[i]);
    }
    else 
    {
     for(i=1;i&lt;=n;i++)         //舍去a[0] 
       printf("%d",a[i]);
    }

}
int main(){ 
    char s1[200],s2[200];
    gets(s1);
    gets(s2);   
    Add(s1,s2);                //读取输入的两个字符串s1，s2
    printf("\n");           
    return 0;
}</pre>

<h3 id="2，C-版"><a href="#2，C-版" class="headerlink" title="2，C++版"></a>2，C++版</h3><pre class="lang:default decode:true">//高精度加法-C++版
//@陈亚伦博客 
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;

void Add(string s1,string s2){
    int a[200]={0},b[200]={0},l1,l2,m,n,i;

    //分别取出s1、s2的长度 赋给l1,l2               
    l1=s1.length();  
    l2=s2.length();      
    if(l1&lt;l2)
       m=l2;
    else
       m=l1;
    n=m;                         //取出l1与l2两者的最大值，赋予m和n 

    //将字符串s1，s2分别转化为数组a，b 
    for( i=0;i&lt;l1;m--,i++) 
        a[m]=s1[l1-1-i]-'0';
    for(m=n,i=0;i&lt;l2;m--,i++)
         b[m]=s2[l2-1-i]-'0';

    //for循环开始实现两个数组相加     
    for(i=n;i&gt;=0;i--)          
    {    
       a[i]+=b[i];              //把两个数的结果给a[i] 
         if(a[i]&gt;=10)            //对是否进位进行判断
        {    
        a[i]-=10;
        a[i-1]+=1;              //即 a[i-1]++;
         }
    }

    //从首位开始打印得出的结果 
    if(a[0]!=0)                 //判断数组ａ的首位是否为０
    {
     for(i=0;i&lt;=n;i++)
      cout&lt;&lt;a[i];
    }
    else                        //舍去a[0] 
    {
     for(i=1;i&lt;=n;i++)         
        cout&lt;&lt;a[i];
    }
}

int main(){    
    char s1[200],s2[200];

    //读取输入的两个字符串s1，s2
    cin.getline(s1, 200);
    cin.getline(s2, 200);
    Add(s1,s2);

    //美观起见打印个换行 
    cout&lt;&lt;endl;         
    return 0;

}</pre>

<h3 id="3，JAVA版"><a href="#3，JAVA版" class="headerlink" title="3，JAVA版"></a>3，JAVA版</h3><pre class="lang:default decode:true">//高精度加法-JAVA版
//@陈亚伦博客 
import java.util.*;

public class Add {
    static void Add(String s1,String s2){
        //字符串转化为数组
        int a[]=new int [200];
        int b[]=new int [200];       
        int l1,l2,i,m,n;
        //取出字符串s1,s2两者的最大长度，赋予m,n,并保证k是两者最大者
        l1= s1.length();
        l2= s2.length();
        if(l1&lt;=l2)
            m=l2;
        else
            m=l1; 
            n=m;

        //将字符串s1转化为数组
        for(i=0;i&lt;l1;m--,i++) 
        a[m]=s1.charAt(l1-1-i)-'0';

        //将字符串s2转化为数组
        for(m=n,i=0;i&lt;l2;m--,i++)
        b[m]=s2.charAt(l2-1-i)-'0';

        //实现数组a，b从末位元素开始相加
            for(i=n;i&gt;=0;i--)           //for循环开始实现两个数组相加 
                {    
                   a[i]+=b[i];              //把两个数的结果给a[i] 
                     if(a[i]&gt;=10)            //对是否进位进行判断
                    {    
                    a[i]-=10;
                    a[i-1]+=1;       
                     }
                }        
         //判断a[0]是否为0
          if(a[0]==0)
              for(i=1;i&lt;=n;i++)
                 System.out.print(a[i]);
          else
              for(i=0;i&lt;=n;i++)
                 System.out.print(a[i]);        
    } 
    public static void main(String[] args) {
                Scanner s=new Scanner(System.in);
                String s1=new String ();
                String s2=new String ();
                s1=s.nextLine();
                s2=s.nextLine();      
                Add(s1,s2);
                //换行美化
                System.out.println();
}
}</pre>
以上代码敲完，然后觉得不过瘾，是不是可以多组输入呢？

这个应该是比较简单的，不多说，直接上代码。

* * *

&nbsp;

### 4，C语言版多组输入

<pre class="lang:default decode:true">//高精度加法-C语言
//@陈亚伦博客 
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

    void Add(char s1[200],char s2[200]){    
    int a[200]={0},b[200]={0},l1,l2,m,n,i;
    l1=strlen(s1);
    l2=strlen(s2);               //分别取出s1、s2的长度 赋给l1,l2 
    if(l1&lt;l2)
       m=l2;
    else
       m=l1;
    n=m;                         //取出l1与l2两者的最大值，赋予m和n 
    for( i=0;i&lt;l1;m--,i++) 
        a[m]=s1[l1-1-i]-'0';
    for(m=n,i=0;i&lt;l2;m--,i++)
         b[m]=s2[l2-1-i]-'0';    //将字符串s1，s2分别转化为数组a，b     
    for(i=n;i&gt;=0;i--)           //for循环开始实现两个数组相加 
    {    
       a[i]+=b[i];              //把两个数的结果给a[i] 
         if(a[i]&gt;=10)            //对是否进位进行判断
        {    
        a[i]-=10;
        a[i-1]+=1;              //a[i-1]++;
         }
    }
    if(a[0]!=0)                 //判断数组ａ的首位是否为０
    {
     for(i=0;i&lt;=n;i++)
       printf("%d",a[i]);
    }
    else 
    {
     for(i=1;i&lt;=n;i++)         //舍去a[0] 
       printf("%d",a[i]);
    }

}
int main(){ while(1){
    char s1[200],s2[200];
    gets(s1);
    gets(s2);   
    Add(s1,s2);                //读取输入的两个字符串s1，s2
    printf("\n");           
}
    return 0;
}</pre>

<h3 id="5，C-多组输入"><a href="#5，C-多组输入" class="headerlink" title="5，C++多组输入"></a>5，C++多组输入</h3><pre class="lang:default decode:true">//高精度加法C++版
//@陈亚伦博客 
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
void Add(string s1,string s2){        
    int a[200]={0},b[200]={0},l1,l2,m,n,i;

    //分别取出s1、s2的长度 赋给l1,l2               
    l1=s1.length();  
    l2=s2.length();      
    if(l1&lt;l2)
       m=l2;
    else
       m=l1;
    n=m;                         //取出l1与l2两者的最大值，赋予m和n 

    //将字符串s1，s2分别转化为数组a，b 
    for( i=0;i&lt;l1;m--,i++) 
        a[m]=s1[l1-1-i]-'0';
    for(m=n,i=0;i&lt;l2;m--,i++)
         b[m]=s2[l2-1-i]-'0';

    //for循环开始实现两个数组相加     
    for(i=n;i&gt;=0;i--)          
    {    
       a[i]+=b[i];              //把两个数的结果给a[i] 
         if(a[i]&gt;=10)            //对是否进位进行判断
        {    
        a[i]-=10;
        a[i-1]+=1;              //即 a[i-1]++;
         }
    }

    //从首位开始打印得出的结果 
    if(a[0]!=0)                 //判断数组ａ的首位是否为０
    {
     for(i=0;i&lt;=n;i++)
      cout&lt;&lt;a[i];
    }
    else                        //舍去a[0] 
    {
     for(i=1;i&lt;=n;i++)         
        cout&lt;&lt;a[i];
    }
}
int main(){    
while(cin){
    char s1[200],s2[200];
    cin.getline(s1, 200);
    cin.getline(s2, 200);
    Add(s1,s2);
    cout&lt;&lt;endl;             
}
    return 0;
}
</pre>

<h3 id="6，JAVA多组输入"><a href="#6，JAVA多组输入" class="headerlink" title="6，JAVA多组输入"></a>6，JAVA多组输入</h3><p><pre class="lang:default decode:true">//高精度加法java版<br>//@陈亚伦博客<br>import java.util.*;</pre></p>
<p>public class Add {<br>    static void Add(String s1,String s2){<br>        //字符串转化为数组<br>        int a[]=new int [200];<br>        int b[]=new int [200];<br>        int l1,l2,i,m,n;<br>        //取出字符串s1,s2两者的最大长度，赋予m,n,并保证k是两者最大者<br>        l1= s1.length();<br>        l2= s2.length();<br>        if(l1&lt;=l2)<br>            m=l2;<br>        else<br>            m=l1;<br>            n=m;</p>
<pre><code>    //将字符串s1转化为数组
    for(i=0;i&amp;lt;l1;m--,i++) 
    a[m]=s1.charAt(l1-1-i)-&apos;0&apos;;

    //将字符串s2转化为数组
    for(m=n,i=0;i&amp;lt;l2;m--,i++)
    b[m]=s2.charAt(l2-1-i)-&apos;0&apos;;

    //实现数组a，b从末位元素开始相加
        for(i=n;i&amp;gt;=0;i--)           //for循环开始实现两个数组相加 
            {    
               a[i]+=b[i];              //把两个数的结果给a[i] 
                 if(a[i]&amp;gt;=10)            //对是否进位进行判断
                {    
                a[i]-=10;
                a[i-1]+=1;       
                 }
            }        
     //判断a[0]是否为0
      if(a[0]==0)
          for(i=1;i&amp;lt;=n;i++)
             System.out.print(a[i]);
      else
          for(i=0;i&amp;lt;=n;i++)
             System.out.print(a[i]);        
} 
public static void main(String[] args) {
    while(1==1){
            Scanner s=new Scanner(System.in);
            String s1=new String ();
            String s2=new String ();
            s1=s.nextLine();
            s2=s.nextLine();      
            Add(s1,s2);
            //换行美化
            System.out.println();
    }
</code></pre><p>}//main<br>}//class<br>&nbsp;</p>
<p>总的来说，代码基本上满足要求，可能在大神眼里根本不值得一提，但毕竟我刚开始接触JAVA，姑且当作学习及复习之用吧，所以不周到或者不合适的地方请多担待，也欢迎发送电子邮件或者在微博上艾特我，咱们一起交流，共同进步。</p>
<p>懒得复制的同学，请移步云盘下载：<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1sjuvAl3" target="_blank" rel="external">http://pan.baidu.com/s/1sjuvAl3</a></p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信开发之下载多媒体文件]]></title>
      <url>http://yoursite.com/2015/10/10/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E4%B9%8B%E4%B8%8B%E8%BD%BD%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>在【<a href="http://www.chenyalun.cn/微信开发之上传多媒体文件.html" target="_blank" rel="external">微信开发之上传多媒体文件</a>】中我们简要探讨了如何上传多媒体文件到服务器，有上传肯定就有下载了，那么今天我们再来分析一下从微信服务器下载文件（前提是我们已经上传）如何实现。不过需要提醒大家，视频已经不支持下载了。</p>
<p>接口地址：</p>
<p><a href="http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID" target="_blank" rel="external">http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID</a></p>
<p><strong>参数说明</strong></p>
<p><table border="1" width="640px" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>是否必须</th></p>
<p><th>说明</th><br></p>
<p><tr></tr></p>
<p><td>access_token</td></p>
<p><td>是</td></p>
<p><td>调用接口凭证</td><br></p>
<p><tr></tr></p>
<p><td>media_id</td></p>
<p><td>是</td></p>
<p><td>媒体文件ID</td><br><br><br><br><strong>返回说明</strong></p>
<p>正确情况下的返回HTTP头如下：</p>
<pre class="">HTTP/1.1 200 OK
Connection: close
Content-Type: image/jpeg 
Content-disposition: attachment; filename="MEDIA_ID.jpg"
Date: Sun, 06 Jan 2013 10:20:18 GMT
Cache-Control: no-cache, must-revalidate
Content-Length: 339721
curl -G "http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID"
</pre>
错误情况下的返回JSON数据包示例如下（示例为无效媒体ID错误）：:
<pre class="">{"errcode":40007,"errmsg":"invalid media_id"}</pre>
看到这里想必大家十分清楚啦，最关键的还是媒体ID和access_token。那么access_token的获取方法请查看【[获得Access_Token的三种方法总结](http://www.chenyalun.cn/%e8%8e%b7%e5%be%97access_token%e7%9a%84%e4%b8%89%e7%a7%8d%e6%96%b9%e6%b3%95%e6%80%bb%e7%bb%93.html)】，媒体ID的获取方法请查阅【[微信开发之上传多媒体文件](http://www.chenyalun.cn/微信开发之上传多媒体文件.html)】

### 1，下载图片

代码如下：
<pre class="lang:default decode:true ">&lt;?php
header("Content-Type:image/jpeg");
$access_token="ndX2jBjagfJBuhAi1S9UTtI4ZZD94CSuvRfsn3Fa2PYfTaFRrt_GvVgLE3e81p_mkYFP9OdYvjhvEY7Si2lUJSWQkNvtC0QycI2Q1-45vMw";
$mediaid = "7TzEATgNA3DMhhQK8jN0tVCdCl3mrvAdkkmd_Hy0s_mlX_3ysh2WaSUfde8vRc3d";
$url = "http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=$access_token&amp;media_id=$mediaid";
$pic=file_get_contents($url);
echo $pic;
?&gt;
</pre>
很显然，在浏览器上出现我们梦寐以求的图片。右键，另存为即可。

![](http://source.chenyalun.cn/images/201510/5100711.jpg)

### 2，下载语音

代码如下：
<pre class="lang:default decode:true">&lt;?php
$access_token="ndX2jBjagfJBuhAi1S9UTtI4ZZD94CSuvRfsn3Fa2PYfTaFRrt_GvVgLE3e81p_mkYFP9OdYvjhvEY7Si2lUJSWQkNvtC0QycI2Q1-45vMw";
$mediaid = "5Idx79V9E3XfBCz_A50gr1a1_klgPpJnb_eq73yz0bn-prhIsNlwI3n6jQgshmWk";
$url = "http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=$access_token&amp;media_id=$mediaid";
$yuyin = file_get_contents($url);
$yName= "chenyalun.amr";
if(file_put_contents($yName,$yuyin)){
echo"陈亚伦博客提醒你文件下载成功";
}else{
echo"陈亚伦博客提醒你文件下载失败";
}
?&gt;</pre>

<h3 id="3，下载缩略图"><a href="#3，下载缩略图" class="headerlink" title="3，下载缩略图"></a>3，下载缩略图</h3><p>代码如下：</p>
<pre class="lang:default decode:true ">&lt;?php
$access_token="ndX2jBjagfJBuhAi1S9UTtI4ZZD94CSuvRfsn3Fa2PYfTaFRrt_GvVgLE3e81p_mkYFP9OdYvjhvEY7Si2lUJSWQkNvtC0QycI2Q1-45vMw";
$mediaid = "wQu5FdN_W1rnsikE9tMfRGiy1XafRDYxsviiTS9TxW0q-cl19LYz7xere0ok8RQ5";
$url = "http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=$access_token&amp;media_id=$mediaid";
$pic=file_get_contents($url);
$picName="chenyalun1.jpg";
if(file_get_contents($picName,$pic)){
echo"陈亚伦博客提醒你缩略图下载成功";
}
else
{
echo"陈亚伦博客提醒你缩略图下载失败";
}
?&gt;</pre>

<h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://source.chenyalun.cn/images/201510/5100712.jpg" alt=""></h3><h3 id="4，总结"><a href="#4，总结" class="headerlink" title="4，总结"></a>4，总结</h3><p>1，以上代码请另存为php文件，编码格式选择ANSI，如果你执意选择UTF-8，可能会乱码。</p>
<p>2，语音以及缩略图文件不会直接显示在浏览器中，下载成功后，它将保存在你的代码文件的存放目录中。</p>
<p>3，请替换以上代码中的文件名、媒体ID以及access_token（这个貌似我不用提醒(●ˇ∀ˇ●)）</p>
<p>4，本着知识分享，共同进步的原则，我也将所有代码放在云端，需要的同学请下载。</p>
<p>下载链接：<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1ntEMtEL" target="_blank" rel="external">http://pan.baidu.com/s/1ntEMtEL</a></p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信开发之上传多媒体文件]]></title>
      <url>http://yoursite.com/2015/10/09/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>在前面的文章中我们已经提到过发送给用户多媒体消息，比如图片（含缩略图），视频，语音等等，而且我们还说了，本着节约光荣、浪费可耻的原则，腾讯微信服务器只把这些文件保留3天，过期删除。今天我们就详细探讨一下上传多媒体文件到微信服务器的方法。</p>
<p>当我们把这些多媒体文件上传到服务器后，每个文件会得到一个相应的媒体ID（media_ID)，以后就根据这个调用这些文件。一般来说上传文件都是通过提交html表单完成的，但是也可以通过CURL直接向服务器进行提交。接口地址：</p>
<pre class="nums:false lang:default decode:true ">http://file.api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&amp;type=TYPE</pre>
**参数说明**
<table border="1" width="640px" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
<tr>
<td>access_token</td>
<td>是</td>
<td>调用接口凭证</td>
</tr>
<tr>
<td>type</td>
<td>是</td>
<td>媒体文件类型，分别有图片（image）、语音（voice）、视频（video）和缩略图（thumb）</td>
</tr>
<tr>
<td>media</td>
<td>是</td>
<td>form-data中媒体文件标识，有filename、filelength、content-type等信息</td>
</tr>
</tbody>
</table>
值得注意的有：

1，若你的服务器是windows，上传的文件格式为：@C:\Users\Allen\chenyalun.jpg，但如果是在Linux服务器上那文件格式就为：@home/Users/Allen/chenyalun.jpg，相信大多数同学（包括我）用的都是Linux服务器，那下面的示例就以这个为标准啦。

2，文件名必须是完整绝对路径，而且需要在路径前加上@以示区分。

3，上传的文件中，图片最大1M，只能是JPG格式；语音不超过2M，播放长度不超过60秒，支持AMR,MP3,SPEEX等格式；视频不超过10M，支持MP4格式，缩略图不超过64KB，支持JPG格式。

### 1，上传图片

代码如下
<pre class="wrap:true lang:default decode:true ">&lt;?php

$access_token = "qOdqEnpIXNDOqhmLjOLR4VqRmVKZ-eKDA_8lpd8gFIA6Ltn6zZv9U7NU5Wz5Jfgod1ah75n8X_haNnIHDwexRYADd9OuSkgMmKw_ckKx3P4";

$type = "image";
$filepath = dirname(__FILE__)."/chenyalun.jpg";
$filedata = array("media"  =&gt; "@".$filepath);
$url = "http://file.api.weixin.qq.com/cgi-bin/media/upload?access_token=$access_token&amp;type=$type";
$result = https_request($url, $filedata); 
var_dump($result); 
function https_request($url, $data = null)
{
    $curl = curl_init();
    curl_setopt($curl, CURLOPT_URL, $url);
    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);
    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);
    if (!empty($data)){
        curl_setopt($curl, CURLOPT_POST, 1);
        curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
    }
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
    $output = curl_exec($curl);
    curl_close($curl);
    return $output;
}
?&gt;</pre>
保存为image.php(新建文本文档，选择另存为，注意编码格式为UTF-8，下面的代码编码格式都是这样的）

在浏览器打开就可以啦，比如我的是http://wechat.chenyalun.cn/image.php，打开之后返回结果如下：

![](http://source.chenyalun.cn/images/201510/5100671.jpg)
<pre class="nums:false wrap:true lang:default decode:true">string(118) "{"type":"image","media_id":"27E2jndYZ_yNOEKMld7rP3aLEQY_h0EZyr0sBh0707urqUD9BuWtHxzm4mvHXHVy","created_at":1444219660}"</pre>
**返回说明**

正确情况下的返回JSON数据包结果如下：
<pre class="nums:false lang:default decode:true">{"type":"TYPE","media_id":"MEDIA_ID","created_at":123456789}
</pre>
<table border="1" width="640px" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
<tr>
<td>type</td>
<td>媒体文件类型，分别有图片（image）、语音（voice）、视频（video）和缩略图（thumb，主要用于视频与音乐格式的缩略图）</td>
</tr>
<tr>
<td>media_id</td>
<td>媒体文件上传后，获取时的唯一标识</td>
</tr>
<tr>
<td>created_at</td>
<td>媒体文件上传时间戳</td>
</tr>
</tbody>
</table>
错误情况下的返回JSON数据包示例如下（示例为无效媒体类型错误）：
<pre class="nums:false lang:default decode:true">{"errcode":40004,"errmsg":"invalid media type"}</pre>
非常显然，媒体ID我们已经拿到手啦。就是下面这一串东东：

27E2jndYZ_yNOEKMld7rP3aLEQY_h0EZyr0sBh0707urqUD9BuWtHxzm4mvHXHVy

那么当我们再调用这个图片的时候，媒体ID就派上用场啦，一定要记得，图片只能在服务器保留3天，图片只能在服务器保留3天，图片只能在服务器保留3天。

敬请注意以下几点：

1，将第3行的access_token替换成你自己的（关于获取access_token，请查阅【[获得Access_Token的三种方法总结](http://www.chenyalun.cn/%e8%8e%b7%e5%be%97access_token%e7%9a%84%e4%b8%89%e7%a7%8d%e6%96%b9%e6%b3%95%e6%80%bb%e7%bb%93.html)】。

2，将第6行中的文件名称改成你自己的，注意不要搞错啦。

说到这里那么上传语音（以MP3文件为例)，视频（以MP4文件为例），缩略图（还是以JPG格式为例）都是轻而易举的了。嗯，不多说啦，上代码。

### 2，上传语音

<pre class="wrap:true lang:default decode:true">&lt;?php

$access_token = "qOdqEnpIXNDOqhmLjOLR4VqRmVKZ-eKDA_8lpd8gFIA6Ltn6zZv9U7NU5Wz5Jfgod1ah75n8X_haNnIHDwexRYADd9OuSkgMmKw_ckKx3P4";

$type = "voice";
$filepath = dirname(__FILE__)."/chenyalun.mp3";
$filedata = array("media"  =&gt; "@".$filepath);
$url = "http://file.api.weixin.qq.com/cgi-bin/media/upload?access_token=$access_token&amp;type=$type";
$result = https_request($url, $filedata); 
var_dump($result); 
function https_request($url, $data = null)
{
    $curl = curl_init();
    curl_setopt($curl, CURLOPT_URL, $url);
    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);
    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);
    if (!empty($data)){
        curl_setopt($curl, CURLOPT_POST, 1);
        curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
    }
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
    $output = curl_exec($curl);
    curl_close($curl);
    return $output;
}
?&gt;</pre>

<h3 id="3，上传视频"><a href="#3，上传视频" class="headerlink" title="3，上传视频"></a>3，上传视频</h3><pre class="wrap:true lang:default decode:true">&lt;?php

$access_token = "qOdqEnpIXNDOqhmLjOLR4VqRmVKZ-eKDA_8lpd8gFIA6Ltn6zZv9U7NU5Wz5Jfgod1ah75n8X_haNnIHDwexRYADd9OuSkgMmKw_ckKx3P4";

$type = "video";
$filepath = dirname(__FILE__)."/chenyalun.mp4";
$filedata = array("media"  =&gt; "@".$filepath);
$url = "http://file.api.weixin.qq.com/cgi-bin/media/upload?access_token=$access_token&amp;type=$type";
$result = https_request($url, $filedata);
var_dump($result); 
function https_request($url, $data = null)
{
    $curl = curl_init();
    curl_setopt($curl, CURLOPT_URL, $url);
    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);
    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);
    if (!empty($data)){
        curl_setopt($curl, CURLOPT_POST, 1);
        curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
    }
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
    $output = curl_exec($curl);
    curl_close($curl);
    return $output;
}
?&gt;</pre>
&nbsp;

### 4，上传缩略图

<pre class="wrap:true lang:default decode:true">&lt;?php

$access_token = "qOdqEnpIXNDOqhmLjOLR4VqRmVKZ-eKDA_8lpd8gFIA6Ltn6zZv9U7NU5Wz5Jfgod1ah75n8X_haNnIHDwexRYADd9OuSkgMmKw_ckKx3P4";

$type = "thumb";
$filepath = dirname(__FILE__)."/chenyalun.jpg";
$filedata = array("media"  =&gt; "@".$filepath);
$url = "http://file.api.weixin.qq.com/cgi-bin/media/upload?access_token=$access_token&amp;type=$type";
$result = https_request($url, $filedata);
var_dump($result); 
function https_request($url, $data = null)
{
    $curl = curl_init();
    curl_setopt($curl, CURLOPT_URL, $url);
    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);
    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);
    if (!empty($data)){
        curl_setopt($curl, CURLOPT_POST, 1);
        curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
    }
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
    $output = curl_exec($curl);
    curl_close($curl);
    return $output;
}
?&lt;br&gt;</pre>

<h3 id="5，利用官方工具进行调试"><a href="#5，利用官方工具进行调试" class="headerlink" title="5，利用官方工具进行调试"></a>5，利用官方工具进行调试</h3><p>点击这里打开上传接口调试工具，<a href="http://www.chenyalun.cn/go/?url=https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&amp;type=%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81&amp;form=%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%8E%A5%E5%8F%A3%20/media/upload" target="_blank" rel="external">这里这里</a>，接口列表选择【多媒体文件上传接口】，我们也可以在这里上传文件，不过，这个工具主要是检查问题进行调试，如果想偷个懒，也可以直接从这里上传。</p>
<p>还有就是有时候微信服务器也不是很给力，【System busy】偶尔会出现的，如果是这样，建议大家稍等片刻再来尝试。</p>
<p>本着知识分享、共同进步的原则，我把所有的代码都放在云端了，需要的同学可以免费下载。</p>
<p>下载地址：<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1jG8MM94" target="_blank" rel="external">http://pan.baidu.com/s/1jG8MM94</a></p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信开发之长链接转成短链接]]></title>
      <url>http://yoursite.com/2015/10/08/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E4%B9%8B%E9%95%BF%E9%93%BE%E6%8E%A5%E8%BD%AC%E6%88%90%E7%9F%AD%E9%93%BE%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>众所周知，链接就是一个网页的姓名，直接通过一个链接访问一个网页到现在仍然是主流。但是，链接的本质是字符串，我们需要一个一个的把它敲到地址栏里，比如说想访问陈亚伦博客，肯定输入www.chenyalun.cn（当然你要是省事输入chenyalun.cn照样可以访问，这个问题我们稍后再讨论），更可恶的是，陈亚伦博客文章的链接是中文名，些许麻烦啦。</p>
<p>二维码比较方便了，马化腾说”二维码是线上线下的一个关键入口”，由此可见，当我们掏出手机，扫下二维码就能付款，就能打开网页，在臣妾看来，这是极好的呀。不过，二维码扫描大多数还是跳转到一个网页，比如我们常见的“分享到微信朋友圈”，点开之后，就是这个网页的二维码。没错，陈亚伦博客每篇文章底部都有“分享到空间、微信、新浪微博”，大家可以尝试下哈。</p>
<p>那么问题来了，生成二维码的原链接太长就会导致扫码速度和成功率下降，这可怎么办呢？很简单，将很长很长的长链接转成短链接再生成二维码不就完美解决这个问题了。于是进入今天的主题：微信开发之长链接转成短链接。</p>
<h3 id="1，接口调用说明"><a href="#1，接口调用说明" class="headerlink" title="1，接口调用说明"></a>1，接口调用说明</h3><p>伟大的开发者们可以通过OpenID来获取用户的基本信息。</p>
<pre class="nums:false lang:default decode:true">http请求方式: POST
https://api.weixin.qq.com/cgi-bin/shorturl?access_token=ACCESS_TOKEN
</pre>
**<span style="color: green;">参数说明</span>**
<table border="1" width="640px" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
<tr>
<td>access_token</td>
<td>是</td>
<td>调用接口凭证</td>
</tr>
<tr>
<td>action</td>
<td>是</td>
<td>此处填long2short，代表长链接转短链接</td>
</tr>
<tr>
<td>long_url</td>
<td>是</td>
<td>需要转换的长链接，支持http://、https://、weixin://wxpay 格式的url</td>
</tr>
</tbody>
</table>
****<span style="color: green;">调用举例</span>****
<pre class="nums:false wrap:true lang:default decode:true">curl -d "{\"action\":\"long2short\",\"long_url\":\"http://wap.koudaitong.com/v2/showcase/goods?alias=128wi9shh&amp;spm=h56083&amp;redirect_count=1\"}" "https://api.weixin.qq.com/cgi-bin/shorturl?access_token=ACCESS_TOKEN"
</pre>
****<span style="color: green;">返回说明</span>****

正常情况下，微信会返回下述JSON数据包给公众号：
<pre class="nums:false lang:default decode:true">{"errcode":0,"errmsg":"ok","short_url":"http:\/\/w.url.cn\/s\/AvCo6Ih"}
</pre>
****<span style="color: green;">参数说明</span>****
<table border="1" width="640px" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
<tr>
<td>errcode</td>
<td>错误码。</td>
</tr>
<tr>
<td>errmsg</td>
<td>错误信息。</td>
</tr>
<tr>
<td>short_url</td>
<td>短链接。</td>
</tr>
</tbody>
</table>
当然，如果你没有成功，微信会返回错误码信息，JSON数据包示例如下（该示例为AppID无效错误）:
<pre class="nums:false lang:default decode:true ">{"errcode":40013,"errmsg":"invalid appid"}</pre>

<h3 id="2，代码实现"><a href="#2，代码实现" class="headerlink" title="2，代码实现"></a>2，代码实现</h3><p>如何实现代码呢，其实很简单，只要获得一个access_token就可以啦。代码如下：</p>
<p><pre class="wrap:true lang:default decode:true">&lt;?php<br>$access_token=”iuOGWooBMoVGYvqiTv5-mbfWdC6iwgV-j9YSIaoAkIYhSE1YqZ9iBjeP19OPwQObWC84286kd7H50wjkz9oOG-a7R9XwDcZq-tkJvI-DFUA”;<br>$url=”<a href="https://api.weixin.qq.com/cgi-bin/shorturl?access_token=&quot;.$access_token" target="_blank" rel="external">https://api.weixin.qq.com/cgi-bin/shorturl?access_token=&quot;.$access_token</a>;<br>$data=”{\”action\”:\”long2short\”,\”long_url\”:\”<a href="http://www.chenyalun.cn/%E8%BD%AF%E4%BB%B6%EF%BC%9Aoffice2016%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E6%AD%A3%E5%BC%8F%E7%89%88.html\&quot;}" target="_blank" rel="external">http://www.chenyalun.cn/%E8%BD%AF%E4%BB%B6%EF%BC%9Aoffice2016%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E6%AD%A3%E5%BC%8F%E7%89%88.html\&quot;}</a>“;<br>$res=url($url,$data);<br>var_dump($res);<br>function url($url,$data=null){<br>     $curl = curl_init();<br>     curl_setopt($curl, CURLOPT_URL, $url);<br>     curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);<br>     curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);<br>     curl_setopt($curl, CURLOPT_POST, 1);<br>curl_setopt($curl, CURLOPT_POSTFIELDS, $data);<br>curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);<br>$out=curl_exec($curl);<br>curl_close($curl);<br>return $out;<br>}<br>?&gt;<br></pre><br>敬请注意：1，第4行中的</p>
<p><pre class="nums:false wrap:true lang:default decode:true "><a href="http://www.chenyalun.cn/%E8%BD%AF%E4%BB%B6%EF%BC%9Aoffice2016%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E6%AD%A3%E5%BC%8F%E7%89%88.html" target="_blank" rel="external">http://www.chenyalun.cn/%E8%BD%AF%E4%BB%B6%EF%BC%9Aoffice2016%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E6%AD%A3%E5%BC%8F%E7%89%88.html</a></pre><br>就是我们要转化的长链接，一定要看清楚到哪里结束哈。2，第2行中的access_token就是很经典的我们重复很多次的access_token，如果还不清楚，请查阅【<a href="http://www.chenyalun.cn/%e8%8e%b7%e5%be%97access_token%e7%9a%84%e4%b8%89%e7%a7%8d%e6%96%b9%e6%b3%95%e6%80%bb%e7%bb%93.html" target="_blank" rel="external">获得ACCESS_TOKEN的三种方法总结</a>】。</p>
<p>嗯，就是这样，把上面的代码保存为url.php，直接在浏览器中打开就可以看到这个东东。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5100701.jpg" alt=""></p>
<p>具体代码如下：</p>
<p><pre class="nums:false lang:default decode:true ">string(71) “{“errcode”:0,”errmsg”:”ok”,”short_url”:”http:\/\/w.url.cn\/s\/A0qi0K3”}”</pre><br>那么生成的短链接就是：<a href="http://www.chenyalun.cn/go/?url=http://w.url.cn/s/A0qi0K3" target="_blank" rel="external">http://w.url.cn/s/A0qi0K3</a> ，至此已经大功告成啦。</p>
<p>为了照顾懒得复制代码的同学，我把完整的url.php文件放在云端，供大家下载，</p>
<p>下载地址：<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1dD15tmT" target="_blank" rel="external">http://pan.baidu.com/s/1dD15tmT</a></p>
<h3 id="3，其他方法"><a href="#3，其他方法" class="headerlink" title="3，其他方法"></a>3，其他方法</h3><p>生成短链接的域名是url.cn，想到这里，在联想到微博的短链接转换功能，我果断点开url.cn这个网址，果然跳转到腾讯微博，而w.url.cn竟然指向了微信主页。至此豁然开朗，所谓的长链接转短链接接口无非就是利用腾讯微博的短链接转换而已。</p>
<p>1，利用腾讯微博转换</p>
<p>直接在腾讯微博界面发一个长链接的微博，短链接巧妙生成。详见下图：</p>
<p><img src="http://source.chenyalun.cn/images/201510/5100702.jpg" alt=""></p>
<p><img src="http://source.chenyalun.cn/images/201510/5100703.jpg" alt=""></p>
<p>生成的短链接：<a href="http://www.chenyalun.cn/go/?url=http://url.cn/drDeH5" target="_blank" rel="external">http://url.cn/drDeH5</a>，</p>
<p>2，新浪微博亦然</p>
<p>3，百度短网址</p>
<p>打开<a href="http://www.chenyalun.cn/go/?url=http://dwz.cn/" target="_blank" rel="external">http://dwz.cn/</a>，直接输入你的长网址即可。</p>
<p>4，新浪短网址</p>
<p>打开网址<a href="http://www.chenyalun.cn/go/?url=http://sina.lt/" target="_blank" rel="external">http://sina.lt/</a>，选择自己喜欢的后缀。</p>
<p>以上方法对做营销的同学来说并不陌生，不喜勿喷，当然还有其他长链接转换为短链接的网站，甚至有批量转化链接的网站，大家可以自行搜索。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何改变图片的亮度与清晰度]]></title>
      <url>http://yoursite.com/2015/10/07/%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E7%9A%84%E4%BA%AE%E5%BA%A6%E4%B8%8E%E6%B8%85%E6%99%B0%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>那么从今天起我们就来探讨有关photoshop的知识，或者说是应用方面的技巧，其实ps是非常有用的，尽管我们已经拥有了美图，把照片修的漂漂些不成问题，但是ps仍是专业的工具，学习平面设计必须掌握的。那你要是说，我不学平面设计，那了解这个干什么呀。答：兴趣使然。</p>
<p>闲话少说，进入今天正题，我们今天探讨的是如果改变图片的亮度与清晰度。</p>
<h3 id="1，改变图片的亮度"><a href="#1，改变图片的亮度" class="headerlink" title="1，改变图片的亮度"></a>1，改变图片的亮度</h3><p><img src="http://source.chenyalun.cn/images/201510/5100641.jpg" alt=""></p>
<p><img src="http://source.chenyalun.cn/images/201510/5100641f.png" alt=""></p>
<p><strong> <span style="color: green;">实现方法：</span></strong></p>
<p>进入ps主页面，按住Ctrl+M调出曲线对话框，拨动线条调节图片的亮度；或者依次点击【图像】-【调整】-【曲线】也可以调出对话框。曲线逼近左上方图片高亮，逼近右下方图片灰暗。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5100643.jpg" alt=""></p>
<h3 id="2，改变图片的清晰度"><a href="#2，改变图片的清晰度" class="headerlink" title="2，改变图片的清晰度"></a>2，改变图片的清晰度</h3><p><img src="http://source.chenyalun.cn/images/201510/5100642.jpg" alt=""></p>
<p><img src="http://source.chenyalun.cn/images/201510/5100642f.jpg" alt=""></p>
<p><strong> <span style="color: green;">实现方法：</span></strong></p>
<p>进入ps主页面，依次点击【滤镜】-【模糊】-【高斯模糊】，改变半径的数值即可调节模糊度。</p>
<p>然而当打开【模糊】的时候，竟然有这么多种类的模糊，不就是调个清晰度嘛，干嘛这么麻烦？其实对专业人士来说，这全都非常有用的，下面简单介绍一下。</p>
<p><strong>场景模糊</strong></p>
<p>这是CS6中的新功能，顾名思义，就是让背景模糊，主体清晰可见，用以突出主体的效果。非常高科技的模糊处理方法o(^▽^)o，以往的话还要借助蒙版、通道什么的，现在很智能啦。</p>
<p><strong>光圈模糊</strong></p>
<p>出来一个圆圈，圆圈外面模糊，里面清晰可见。当然，可以调节圆圈的形状。</p>
<p><strong>倾斜模糊</strong></p>
<p>出现两条直线，两条虚线，随意摆动，调节不同层次不同位置的模糊程度。</p>
<p><strong>表面模糊</strong></p>
<p>在保留边缘的同时模糊图像，好像给图片蒙一层雾，仅仅是表层的模糊。半径是指模糊像素的半径大小，阈值就是清晰程度啦。</p>
<p><strong>动感模糊</strong></p>
<p>貌似图片是因为晃动才模糊的，给人的感觉也很独特。角度：用于调节方向，距离：用于调节“晃动”的半径。</p>
<p><strong>高斯模糊</strong></p>
<p>专业解释：“高斯”是指当 Adobe Photoshop CS2 将加权平均应用于像素时生成的钟形曲线。“高斯模糊”滤镜添加低频细节，并产生一种朦胧效果。在进行字体的特殊效果制作时，在通道内经常应用此滤镜的效果。我们常用的一种。</p>
<p><strong>进一步模糊</strong></p>
<p>“进一步模糊”滤镜生成的效果比“模糊”滤镜强三到四倍。</p>
<p><strong>径向模糊</strong></p>
<p>就是模拟前后移动相机或旋转相机所产生的模糊效果。</p>
<p><strong>镜头模糊</strong></p>
<p>图像中的一些对象在焦点内，而使另一些区域变模糊。貌似拼谁的手机像素高一样。</p>
<p><strong>模糊</strong></p>
<p>产生轻微的模糊效果。</p>
<p><strong>平均</strong></p>
<p>根据整张图片像素的平均值，简单粗暴对图片进行模糊处理。然后我们什么也不用操作了。好像用处不大。</p>
<p><strong>特殊模糊</strong></p>
<p>很特殊，我觉得画画的时候能用到，哈哈。</p>
<p><strong>形状模糊</strong></p>
<p>根据那些奇怪的箭头，表情等形状，给图片来一个等内核的模糊处理。</p>
<p>以上介绍顺序为Ps CS6的菜单顺序，我们常用的应该是高斯模糊和动感模糊。高斯模糊柔和地处理静态图片，动感模糊处理有动感的图片（比如奔跑的一瞬间拍下的照片，不是GIF动图哈）</p>
<p>还有就是按住Ctrl+Alt+Z可以撤销操作，很有用的。</p>
<p>### </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[获得Access_Token的三种方法总结]]></title>
      <url>http://yoursite.com/2015/10/06/%E8%8E%B7%E5%BE%97Access_Token%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>在自定义菜单和其他高级接口中均需要用到AppID和AppSecret，这两个参数也是非常显眼的放在开发页面，同时，我们也需要这两个参数生成Access_Token。Access_Token是什么东东？简单的说就是调用各个接口的钥匙，所以当我们获得Access_Token后注意妥善保存，当然，有效期是两个小时，需要定时刷新。现在，我就将获取Access_Token的三种方法分享一下。</p>
<h3 id="1，官网调试工具生成Access-Token"><a href="#1，官网调试工具生成Access-Token" class="headerlink" title="1，官网调试工具生成Access_Token"></a>1，官网调试工具生成Access_Token</h3><p>打开网址：<a href="http://www.chenyalun.cn/go/?url=https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&amp;type=%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81&amp;form=%E8%8E%B7%E5%8F%96access_token%E6%8E%A5%E5%8F%A3%20/token" target="_blank" rel="external">点击这里</a></p>
<p><img src="http://source.chenyalun.cn/images/201510/5100501.jpg" alt=""></p>
<p>直接输入你的AppID和AppSecret，点击检查问题，就可以看到传说中的Access_Token啦，就是图中红黄色的一串字符。</p>
<p><img src="http://source.chenyalun.cn/images/201510/5100502.jpg" alt=""></p>
<p>&nbsp;</p>
<h3 id="2-编写代码获取生成Access-Token"><a href="#2-编写代码获取生成Access-Token" class="headerlink" title="2,编写代码获取生成Access_Token"></a>2,编写代码获取生成Access_Token</h3><h4 id="第一种代码如下："><a href="#第一种代码如下：" class="headerlink" title="第一种代码如下："></a>第一种代码如下：</h4><p><pre class="lang:default decode:true">&lt;?php<br>define(“APPID”, “替换成你的APPID”);<br>define(“APPSECRET”, “替换成你的APPSECRET”);<br>$token_access_url = “<a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=" target="_blank" rel="external">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=</a>“ . APPID . “&amp;secret=” . APPSECRET;<br>$res = file_get_contents($token_access_url);<br>$result = json_decode($res, true);<br>$access_token = $result[‘access_token’];<br>echo $access_token;<br>?&gt;</pre><br>&nbsp;</p>
<p><strong>参数说明</strong></p>
<p><table border="1" width="640px" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>是否必须</th></p>
<p><th>说明</th><br></p>
<p><tr></tr></p>
<p><td>grant_type</td></p>
<p><td>是</td></p>
<p><td>获取access_token填写client_credential</td><br></p>
<p><tr></tr></p>
<p><td>appid</td></p>
<p><td>是</td></p>
<p><td>第三方用户唯一凭证</td><br></p>
<p><tr></tr></p>
<p><td>secret</td></p>
<p><td>是</td></p>
<p><td>第三方用户唯一凭证密钥，即appsecret</td><br><br><br><br><strong>返回说明</strong></p>
<p>正常情况下，微信会返回下述JSON数据包给公众号：</p>
<p><pre>{“access_token”:”ACCESS_TOKEN”,”expires_in”:7200}<br></pre></p>
<p><table border="1" width="640px" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>说明</th><br></p>
<p><tr></tr></p>
<p><td>access_token</td></p>
<p><td>获取到的凭证</td><br></p>
<p><tr></tr></p>
<p><td>expires_in</td></p>
<p><td>凭证有效时间，单位：秒</td><br><br><br><br>错误时微信会返回错误码等信息，JSON数据包示例如下（该示例为AppID无效错误）:</p>
<p><pre class="">{“errcode”:40013,”errmsg”:”invalid appid”}</pre><br>&nbsp;</p>
<p>将以上代码复制粘贴到文本文档中，保存为php格式，别忘了修改你的AppID和appsecret。然后直接在网页上运行就可以看到神奇的Access_Token啦。（本地环境，云服务器或者sae都是可以滴,我的是云服务器，如下图所示）</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://source.chenyalun.cn/images/201510/5100503.jpg" alt=""></h3><h3 id="3-编写代码获取生成Access-Token"><a href="#3-编写代码获取生成Access-Token" class="headerlink" title="3,编写代码获取生成Access_Token"></a>3,编写代码获取生成Access_Token</h3><h4 id="第二种代码如下："><a href="#第二种代码如下：" class="headerlink" title="第二种代码如下："></a>第二种代码如下：</h4><p><pre class="lang:default decode:true ">&lt;?php<br>$appid = “替换成你的appid”;<br>$appsecret = “替换成你的appsecret”;<br>$url = “<a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$appid&amp;secret=$appsecret" target="_blank" rel="external">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$appid&amp;secret=$appsecret</a>“;<br>GetToken($url);<br>function GetToken($url){<br>$ch = curl_init();<br>curl_setopt($ch, CURLOPT_URL, $url);<br>curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);<br>curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);<br>curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);<br>$res=curl_exec($ch);<br>   $access_token=json_decode($res,true);<br>   echo $access_token[‘access_token’];<br>}<br>?&gt;<br></pre><br>&nbsp;</p>
<p><img src="http://source.chenyalun.cn/images/201510/5100504.jpg" alt=""></p>
<p>【方法二和方法三本质上就是代码不同而已，原谅我，o(^▽^)o】</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[软件：MyEclipse 10免费激活及汉化]]></title>
      <url>http://yoursite.com/2015/10/05/%E8%BD%AF%E4%BB%B6%EF%BC%9AMyEclipse_10%E5%85%8D%E8%B4%B9%E6%BF%80%E6%B4%BB%E5%8F%8A%E6%B1%89%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>相信不少学习java的同学都是需要MyEclipse这款软件的，可是这是付费软件，那么怎样才能完美享用呢？闲话少说，今天，陈亚伦就将搜罗的相关技巧分享给大家。</p>
<h3 id="1，MyEclipse-10-7的下载与安装"><a href="#1，MyEclipse-10-7的下载与安装" class="headerlink" title="1，MyEclipse 10.7的下载与安装"></a>1，MyEclipse 10.7的下载与安装</h3><p>我已经把它放在云端了，点击下载：<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1kT1sUDD" target="_blank" rel="external">http://pan.baidu.com/s/1kT1sUDD</a></p>
<h3 id="2，MyEclipse-10-7激活工具的下载"><a href="#2，MyEclipse-10-7激活工具的下载" class="headerlink" title="2，MyEclipse 10.7激活工具的下载"></a>2，MyEclipse 10.7激活工具的下载</h3><p>点击下载：<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1dDAs9Z7" target="_blank" rel="external">http://pan.baidu.com/s/1dDAs9Z7</a></p>
<h3 id="3，MyEclipse-10-7汉化包的下载"><a href="#3，MyEclipse-10-7汉化包的下载" class="headerlink" title="3，MyEclipse 10.7汉化包的下载"></a>3，MyEclipse 10.7汉化包的下载</h3><p>点击下载：<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1pJrbuqB" target="_blank" rel="external">http://pan.baidu.com/s/1pJrbuqB</a></p>
<p>提醒大家，尽量不要汉化，主要是英文的界面可以锻炼自己的英语水平，提升自己的词汇量。如果特别特别想汉化，点击下载：</p>
<h3 id="附汉化教程"><a href="#附汉化教程" class="headerlink" title="附汉化教程"></a>附汉化教程</h3><p>因为激活教程是pdf文件，包含在激活工具文件中了，我觉得写得十分清楚，所以就不在这里赘述了，下面简要说一下汉化的步骤，其实也是非常简单的。</p>
<p>1，打开  myeclipse10.7汉化包 （别忘了解压哈），然后把language文件夹复制到MyEclipse 10目录下的Common文件夹里。注意：在<em>MyEclipse 10</em>同级下也有一个<em>Common</em>文件，然而却并不是它<em>。</em></p>
<p><img src="http://source.chenyalun.cn/images/201510/5100403.jpg" alt=""></p>
<p>并不是上图所示的Common文件夹，而是下图所示的。注意区分两者区别</p>
<p><img src="http://source.chenyalun.cn/images/201510/5100404.jpg" alt=""></p>
<p>2，运行MyEclipse软件并且创建一个项目，在项目里面建立一个CreatePluginsConfig类。</p>
<p>&nbsp;</p>
<p>3，打开汉化包，完全复制汉化包中CreatePluginsConfig.java中的代码（也可以选择用记事本打开，按住ctrl+a），并将其粘贴到步骤2中的CreatePluginsConfig类中。</p>
<p>&nbsp;</p>
<p>4，替换CreatePluginsConfig类中的代码：E:\software\MyEclipse 10\Common\language\plugins的路径改成你电脑安装<em>MyEclipse 10.7</em>的路径，注意在每个”\”多加一个”\”，比如我的安装路径是C:\Users\Allen\MyEclipse\MyEclipse 10\Common\language\plugins     就要改成C:\Users\Allen\MyEclipse\MyEclipse 10\Common\language\plugins</p>
<p><img src="http://source.chenyalun.cn/images/201510/5100406.jpg" alt=""></p>
<p>5，运行你的CreatePluginsConfig类，然后在控制台下面会输出一大串英文。这时要把控制台输出的英文全部都复制到C:\Users\Allen\MyEclipse\MyEclipse 10\configuration\org.eclipse.equinox.simpleconfigurator中的bundles.info里面的,用记事本把其中的bundles.info 打开，在最后一行回车一下。把刚才在控制台输出的内容都粘贴进去保存。完成后关闭MyEclipse.</p>
<p><img src="http://source.chenyalun.cn/images/201510/5100407.jpg" alt=""></p>
<p>6，在<em>MyEclipse 10</em>目录下找到myeclipse.ini文件，用记事本打开，在最后一行再增加一条语句，如下所示：</p>
<p><pre class="lang:default decode:true ">-Duser.language=zh<br></pre><br>&nbsp;</p>
<p><img src="http://source.chenyalun.cn/images/201510/5100405.jpg" alt=""></p>
<p>7，保存，启动你的MyEclipse吧，你就可以看到非常漂漂的中文界面了，宝贝，祝你成功。</p>
<p><img src="http://source.chenyalun.cn/images/201510/51008.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OAuth2.0网页授权]]></title>
      <url>http://yoursite.com/2015/10/04/OAuth2.0%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83/</url>
      <content type="html"><![CDATA[<p>网页授权最基本的就是满足通过在view按钮跳转的网页中获取用户的基本信息的需求，而OAuth2.0授权协议就是账号体系的基础。比如说通过第三方账号(qq，微信，微博，facebook等）登录某网站，网站获取用户的相关信息，这个过程的信息安全就是OAuth2.0协议。如果想要了解更多关于OAuth2.0的知识，请访问：<a href="http://oauth.net/" target="_blank" rel="external">http://oauth.net/</a>   <a href="http://oauth.net/2/" target="_blank" rel="external">http://oauth.net/2/</a></p>
<p>微信OAuth2.0协议与之类似，公众号可以很方便的获取用户的基本信息，比如昵称，性别，城市等等，可以实现用户来源统计，账号绑定等功能。下面一起实现神奇的OAuth2.0网页授权吧。</p>
<h3 id="1，配置回调域名"><a href="#1，配置回调域名" class="headerlink" title="1，配置回调域名"></a>1，配置回调域名</h3><p>在公众平台我的服务页中配置回调域名，之后这个域名下的网页都可以进行网页授权。值得注意的是：不要加  <a href="http://，而是直接填写域名，比如www.chenyalun.cn，那么[www.chenyalun.cn/版权声明](http://www.chenyalun.cn/版权声明)，[http://www.chenyalun.cn/category/gzhkf](http://www.chenyalun.cn/category/gzhkf" target="_blank" rel="external">http://，而是直接填写域名，比如www.chenyalun.cn，那么[www.chenyalun.cn/版权声明](http://www.chenyalun.cn/版权声明)，[http://www.chenyalun.cn/category/gzhkf](http://www.chenyalun.cn/category/gzhkf</a>)   都可以进行鉴权。在这里我用wechat.chenyalun.cn作为回调域名。</p>
<h3 id="2，网页授权流程分为四步"><a href="#2，网页授权流程分为四步" class="headerlink" title="2，网页授权流程分为四步"></a>2，网页授权流程分为四步</h3><pre class="nums:false lang:default decode:true">1、引导用户进入授权页面同意授权，获取code
2、通过code换取网页授权access_token（与基础支持中的access_token不同）
3，如果需要，开发者可以刷新网页授权access_token，避免过期
4、通过网页授权access_token和openid获取用户基本信息</pre>

<h4 id="第一步：用户同意授权，获取code"><a href="#第一步：用户同意授权，获取code" class="headerlink" title="第一步：用户同意授权，获取code"></a><span id=".E7.AC.AC.E4.B8.80.E6.AD.A5.EF.BC.9A.E7.94.A8.E6.88.B7.E5.90.8C.E6.84.8F.E6.8E.88.E6.9D.83.EF.BC.8C.E8.8E.B7.E5.8F.96code" class="mw-headline">第一步：用户同意授权，获取code</span></h4><p>引导关注者打开如下页面：<a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect" target="_blank" rel="external">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a></p>
<p><strong>参数说明</strong></p>
<table border="1" width="640px" cellspacing="0" cellpadding="4" align="center"><br><tbody><br><tr><br><th>参数</th><br><th>是否必须</th><br><th>说明</th><br></tr><br><tr><br><td>appid</td><br><td>是</td><br><td>公众号的唯一标识</td><br></tr><br><tr><br><td>redirect_uri</td><br><td>是</td><br><td>授权后重定向的回调链接地址，请使用urlencode对链接进行处理</td><br></tr><br><tr><br><td>response_type</td><br><td>是</td><br><td>返回类型，请填写code</td><br></tr><br><tr><br><td>scope</td><br><td>是</td><br><td>应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且，即使在未关注的情况下，只要用户授权，也能获取其信息）</td><br></tr><br><tr><br><td>state</td><br><td>否</td><br><td>重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节</td><br></tr><br><tr><br><td>#wechat_redirect</td><br><td>是</td><br><td>无论直接打开还是做页面302重定向时候，必须带此参数</td><br></tr><br></tbody><br></table><br>如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE。若用户禁止授权，则重定向后不会带上code参数，仅会带上state参数redirect_uri?state=STATE<br><br>#### <span id=".E7.AC.AC.E4.BA.8C.E6.AD.A5.EF.BC.9A.E9.80.9A.E8.BF.87code.E6.8D.A2.E5.8F.96.E7.BD.91.E9.A1.B5.E6.8E.88.E6.9D.83access_token" class="mw-headline">第二步：通过code换取网页授权access_token</span><br><br>获取code后，请求以下链接获取access_token：<a href="https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code" target="_blank" rel="external">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</a><br><br><strong>参数说明</strong><br><table border="1" width="640px" cellspacing="0" cellpadding="4" align="center"><br><tbody><br><tr><br><th>参数</th><br><th>是否必须</th><br><th>说明</th><br></tr><br><tr><br><td>appid</td><br><td>是</td><br><td>公众号的唯一标识</td><br></tr><br><tr><br><td>secret</td><br><td>是</td><br><td>公众号的appsecret</td><br></tr><br><tr><br><td>code</td><br><td>是</td><br><td>填写第一步获取的code参数</td><br></tr><br><tr><br><td>grant_type</td><br><td>是</td><br><td>填写为authorization_code</td><br></tr><br></tbody><br></table><br>正确时返回的JSON数据包如下：<br><pre class="">{<br>   “access_token”:”ACCESS_TOKEN”,<br>   “expires_in”:7200,<br>   “refresh_token”:”REFRESH_TOKEN”,<br>   “openid”:”OPENID”,<br>   “scope”:”SCOPE”,<br>   “unionid”: “o6_bmasdasdsad6_2sgVt7hMZOPfL”<br>}</pre><br><table border="1" cellspacing="0" cellpadding="4" align="center"><br><tbody><br><tr><br><th>参数</th><br><th>描述</th><br></tr><br><tr><br><td>access_token</td><br><td>网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同</td><br></tr><br><tr><br><td>expires_in</td><br><td>access_token接口调用凭证超时时间，单位（秒）</td><br></tr><br><tr><br><td>refresh_token</td><br><td>用户刷新access_token</td><br></tr><br><tr><br><td>openid</td><br><td>用户唯一标识，请注意，在未关注公众号时，用户访问公众号的网页，也会产生一个用户和公众号唯一的OpenID</td><br></tr><br><tr><br><td>scope</td><br><td>用户授权的作用域，使用逗号（,）分隔</td><br></tr><br><tr><br><td>unionid</td><br><td>只有在用户将公众号绑定到微信开放平台帐号后，才会出现该字段。</td><br></tr><br></tbody><br></table>

<h3 id="第三步：刷新access-token（如果需要）"><a href="#第三步：刷新access-token（如果需要）" class="headerlink" title="第三步：刷新access_token（如果需要）"></a>第三步：刷新access_token（如果需要）</h3><p>由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token拥有较长的有效期（7天、30天、60天、90天），当refresh_token失效的后，需要用户重新授权。</p>
<p>请求方法</p>
<pre>获取第二步的refresh_token后，请求以下链接获取access_token：  https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN</pre>
<table cellspacing="0" cellpadding="4">
<tbody>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
<tr>
<td>appid</td>
<td>是</td>
<td>公众号的唯一标识</td>
</tr>
<tr>
<td>grant_type</td>
<td>是</td>
<td>填写为refresh_token</td>
</tr>
<tr>
<td>refresh_token</td>
<td>是</td>
<td>填写通过access_token获取到的refresh_token参数</td>
</tr>
</tbody>
</table>
返回说明

正确时返回的JSON数据包如下：
<pre>{    "access_token":"ACCESS_TOKEN",    "expires_in":7200,    "refresh_token":"REFRESH_TOKEN",    "openid":"OPENID",    "scope":"SCOPE" }</pre>
<table cellspacing="0" cellpadding="4">
<tbody>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
<tr>
<td>access_token</td>
<td>网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同</td>
</tr>
<tr>
<td>expires_in</td>
<td>access_token接口调用凭证超时时间，单位（秒）</td>
</tr>
<tr>
<td>refresh_token</td>
<td>用户刷新access_token</td>
</tr>
<tr>
<td>openid</td>
<td>用户唯一标识</td>
</tr>
<tr>
<td>scope</td>
<td>用户授权的作用域，使用逗号（,）分隔</td>
</tr>
</tbody>
</table>
错误时微信会返回JSON数据包如下（示例为Code无效错误）:
<pre class="">{"errcode":40029,"errmsg":"invalid code"}</pre>

<h4 id="第四步：拉取用户信息"><a href="#第四步：拉取用户信息" class="headerlink" title="第四步：拉取用户信息"></a>第四步：拉取用户信息</h4><p>已经拿到access_token和openid就可以拉取用户信息了。</p>
<p>请求方法：<a href="https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN" target="_blank" rel="external">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</a></p>
<p><strong>参数说明</strong></p>
<p><table border="1" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>描述</th><br></p>
<p><tr></tr></p>
<p><td>access_token</td></p>
<p><td>网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同</td><br></p>
<p><tr></tr></p>
<p><td>openid</td></p>
<p><td>用户的唯一标识</td><br></p>
<p><tr></tr></p>
<p><td>lang</td></p>
<p><td>返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语</td><br><br><br><br>正确时返回的JSON数据包如下：</p>
<p><pre class="">{<br>   “openid”:” OPENID”,<br>   “ nickname”: NICKNAME,<br>   “sex”:”1”,<br>   “province”:”PROVINCE”<br>   “city”:”CITY”,<br>   “country”:”COUNTRY”,<br>    “headimgurl”:    “<a href="http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46" target="_blank" rel="external">http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46</a>“,<br>    “privilege”:[<br>    “PRIVILEGE1”<br>    “PRIVILEGE2”<br>    ],<br>    “unionid”: “o6_bmasdasdsad6_2sgVt7hMZOPfL”<br>}</pre></p>
<p><table border="1" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>描述</th><br></p>
<p><tr></tr></p>
<p><td>openid</td></p>
<p><td>用户的唯一标识</td><br></p>
<p><tr></tr></p>
<p><td>nickname</td></p>
<p><td>用户昵称</td><br></p>
<p><tr></tr></p>
<p><td>sex</td></p>
<p><td>用户的性别，值为1时是男性，值为2时是女性，值为0时是未知</td><br></p>
<p><tr></tr></p>
<p><td>province</td></p>
<p><td>用户个人资料填写的省份</td><br></p>
<p><tr></tr></p>
<p><td>city</td></p>
<p><td>普通用户个人资料填写的城市</td><br></p>
<p><tr></tr></p>
<p><td>country</td></p>
<p><td>国家，如中国为CN</td><br></p>
<p><tr></tr></p>
<p><td>headimgurl</td></p>
<p><td>用户头像，最后一个数值代表正方形头像大小（有0、46、64、96、132数值可选，0代表640*640正方形头像），用户没有头像时该项为空。若用户更换头像，原有头像URL将失效。</td><br></p>
<p><tr></tr></p>
<p><td>privilege</td></p>
<p><td>用户特权信息，json 数组，如微信沃卡用户为（chinaunicom）</td><br></p>
<p><tr></tr></p>
<p><td>unionid</td></p>
<p><td>只有在用户将公众号绑定到微信开放平台帐号后，才会出现该字段。</td><br><br><br><br>案例代码如下：</p>
<p><pre class="lang:default decode:true ">&lt;?php<br>/*<br>本文件位置<br>$redirect_url= “<a href="http://israel.duapp.com/weixin/oauth2_openid.php" target="_blank" rel="external">http://israel.duapp.com/weixin/oauth2_openid.php</a>“;</pre></p>
<p>URL<br><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx6292681b13329528&amp;redirect_uri=http://israel.duapp.com/weixin/oauth2_openid.php&amp;response_type=code&amp;scope=snsapi_base&amp;state=1#wechat_redirect" target="_blank" rel="external">https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx6292681b13329528&amp;redirect_uri=http://israel.duapp.com/weixin/oauth2_openid.php&amp;response_type=code&amp;scope=snsapi_base&amp;state=1#wechat_redirect</a><br>*/<br>$code = $_GET[“code”];<br>$userinfo = getUserInfo($code);</p>
<p>function getUserInfo($code)<br>{<br>    $appid = “wx6292681b13329528”;<br>    $appsecret = “3079cb22ad383ae7371d12aed1b2d0cc”;</p>
<pre><code>//oauth2的方式获得openid
$access_token_url = &quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=$appid&amp;amp;secret=$appsecret&amp;amp;code=$code&amp;amp;grant_type=authorization_code&quot;;
$access_token_json = https_request($access_token_url);
$access_token_array = json_decode($access_token_json, true);
$openid = $access_token_array[&apos;openid&apos;];

//非oauth2的方式获得全局access token
$new_access_token_url = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid=$appid&amp;amp;secret=$appsecret&quot;;
$new_access_token_json = https_request($new_access_token_url);
$new_access_token_array = json_decode($new_access_token_json, true);
$new_access_token = $new_access_token_array[&apos;access_token&apos;];

//全局access token获得用户基本信息
$userinfo_url = &quot;https://api.weixin.qq.com/cgi-bin/user/info?access_token=$new_access_token&amp;amp;openid=$openid&quot;;
$userinfo_json = https_request($userinfo_url);
$userinfo_array = json_decode($userinfo_json, true);
return $userinfo_array;
</code></pre><p>}</p>
<p>function https_request($url)<br>{<br>    $curl = curl_init();<br>    curl_setopt($curl, CURLOPT_URL, $url);<br>    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);<br>    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);<br>    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);<br>    $data = curl_exec($curl);<br>    if (curl_errno($curl)) {return ‘ERROR ‘.curl_error($curl);}<br>    curl_close($curl);<br>    return $data;<br>}<br>?&gt;</p>
<p>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.0 Transitional//EN”&gt;<br>&lt;HTML&gt;<br>    &lt;HEAD&gt;&lt;TITLE&gt;OAuth2.0认证&lt;/TITLE&gt;<br>        &lt;META charset=utf-8&gt;<br>        &lt;META name=viewport content=”width=device-width, user-scalable=no, initial-scale=1”&gt;<br>        &lt;LINK rel=”stylesheet” href=”css/jquery.mobile-1.3.2.css”&gt;<br>        &lt;SCRIPT src=”js/jquery-1.10.2.js”&gt;&lt;/SCRIPT&gt;<br>        &lt;SCRIPT src=”js/jquery.mobile-1.3.2.js”&gt;&lt;/SCRIPT&gt;<br>    &lt;/HEAD&gt;</p>
<pre><code>&amp;lt;BODY&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        document.addEventListener(&apos;WeixinJSBridgeReady&apos;, function onBridgeReady() {
            WeixinJSBridge.call(&apos;hideOptionMenu&apos;);
        });
        document.addEventListener(&apos;WeixinJSBridgeReady&apos;, function onBridgeReady() {
            WeixinJSBridge.call(&apos;hideToolbar&apos;);
        });
    &amp;lt;/script&amp;gt;
    &amp;lt;div data-role=&quot;page&quot; id=&quot;page1&quot;&amp;gt;
        &amp;lt;div data-role=&quot;content&quot;&amp;gt;
            &amp;lt;div style=&quot; text-align:center&quot;&amp;gt;
                &amp;lt;img style=&quot;width: 99%; height: %&quot; src=&quot;&amp;lt;?php echo $userinfo[&quot;headimgurl&quot;];?&amp;gt;&quot;&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;UL data-role=&quot;listview&quot; data-inset=&quot;true&quot;&amp;gt;
                &amp;lt;LI&amp;gt;
                    &amp;lt;P&amp;gt;
                        &amp;lt;div class=&quot;fieldcontain&quot;&amp;gt;
                            &amp;lt;label for=&quot;subscribe&quot;&amp;gt;是否关注&amp;lt;/label&amp;gt;
                            &amp;lt;input name=&quot;subscribe&quot; id=&quot;subscribe&quot; value=&quot;&amp;lt;?php echo $userinfo[&quot;subscribe&quot;];?&amp;gt;&quot; type=&quot;text&quot; &amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;fieldcontain&quot;&amp;gt;
                            &amp;lt;label for=&quot;openid&quot;&amp;gt;OpenID&amp;lt;/label&amp;gt;
                            &amp;lt;input name=&quot;openid&quot; id=&quot;openid&quot; value=&quot;&amp;lt;?php echo $userinfo[&quot;openid&quot;];?&amp;gt;&quot; type=&quot;text&quot; &amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;fieldcontain&quot;&amp;gt;
                            &amp;lt;label for=&quot;nickname&quot;&amp;gt;昵称&amp;lt;/label&amp;gt;
                            &amp;lt;input name=&quot;nickname&quot; id=&quot;nickname&quot; value=&quot;&amp;lt;?php echo $userinfo[&quot;nickname&quot;];?&amp;gt;&quot; type=&quot;text&quot; &amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;fieldcontain&quot;&amp;gt;
                            &amp;lt;label for=&quot;sex&quot;&amp;gt;性别&amp;lt;/label&amp;gt;
                            &amp;lt;input name=&quot;sex&quot; id=&quot;sex&quot; value=&quot;&amp;lt;?php echo $userinfo[&quot;sex&quot;];?&amp;gt;&quot; type=&quot;text&quot; &amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;fieldcontain&quot;&amp;gt;
                            &amp;lt;label for=&quot;country&quot;&amp;gt;国家&amp;lt;/label&amp;gt;
                            &amp;lt;input name=&quot;country&quot; id=&quot;country&quot; value=&quot;&amp;lt;?php echo $userinfo[&quot;country&quot;];?&amp;gt;&quot; type=&quot;text&quot; &amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;fieldcontain&quot;&amp;gt;
                            &amp;lt;label for=&quot;province&quot;&amp;gt;省份&amp;lt;/label&amp;gt;
                            &amp;lt;input name=&quot;province&quot; id=&quot;province&quot; value=&quot;&amp;lt;?php echo $userinfo[&quot;province&quot;];?&amp;gt;&quot; type=&quot;text&quot; &amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;fieldcontain&quot;&amp;gt;
                            &amp;lt;label for=&quot;city&quot;&amp;gt;城市&amp;lt;/label&amp;gt;
                            &amp;lt;input name=&quot;city&quot; id=&quot;city&quot; value=&quot;&amp;lt;?php echo $userinfo[&quot;city&quot;];?&amp;gt;&quot; type=&quot;text&quot; &amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;fieldcontain&quot;&amp;gt;
                            &amp;lt;label for=&quot;subscribe_time&quot;&amp;gt;关注时间&amp;lt;/label&amp;gt;
                            &amp;lt;input name=&quot;subscribe_time&quot; id=&quot;subscribe_time&quot; value=&quot;&amp;lt;?php echo $userinfo[&quot;subscribe_time&quot;];?&amp;gt;&quot; type=&quot;text&quot; &amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/P&amp;gt;
                &amp;lt;/LI&amp;gt;
            &amp;lt;/UL&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div data-theme=&quot;a&quot; data-role=&quot;footer&quot; data-position=&quot;fixed&quot;&amp;gt;
            &amp;lt;h3&amp;gt;陈亚伦博客&amp;lt;/h3&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/BODY&amp;gt;
</code></pre><p>&lt;/HTML&gt;<br>以上代码测试后效果如图：</p>
<p><img src="http://source.chenyalun.cn/images/5100631.png" alt=""></p>
<p>当然，如果只是想测试Oauth这个授权功能的话，就更简单了。</p>
<h3 id="单独测试代码如下："><a href="#单独测试代码如下：" class="headerlink" title="单独测试代码如下："></a>单独测试代码如下：</h3><p><pre class="lang:default decode:true">&lt;?php<br>$code = $_GET[‘code’];<br>if (isset($code)){<br>       $appid = “wx1f06a6d59f960018”;<br>       $appsecret = “87b4d3c8d560a522213fde2f5d42fb99”;<br>       $redirect_url=”<a href="http://wechat.chenyalun.cn/oauth.php" target="_blank" rel="external">http://wechat.chenyalun.cn/oauth.php</a>“;<br>$url =”<a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx1f06a6d59f960018&amp;redirect_uri=http://wechat.chenyalun.cn/oauth.php&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=123#wechat_redirect" target="_blank" rel="external">https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx1f06a6d59f960018&amp;redirect_uri=http://wechat.chenyalun.cn/oauth.php&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=123#wechat_redirect</a>“;<br>$oauth_token=”<a href="https://api.weixin.qq.com/sns/oauth2/access_token?appid=$appid&amp;secret=$appsecret&amp;code=$code&amp;grant_type=authorization_code" target="_blank" rel="external">https://api.weixin.qq.com/sns/oauth2/access_token?appid=$appid&amp;secret=$appsecret&amp;code=$code&amp;grant_type=authorization_code</a>“;<br>$out=file_get_contents($oauth_token);<br>$token=json_decode($out,true);<br>$access_token=$token[‘access_token’];<br>$openid=$token[‘openid’];<br>$userinfo_url= “<a href="https://api.weixin.qq.com/sns/userinfo?access_token=$access_token&amp;openid=$openid&amp;lang=zh_CN" target="_blank" rel="external">https://api.weixin.qq.com/sns/userinfo?access_token=$access_token&amp;openid=$openid&amp;lang=zh_CN</a>“;<br>$userinfo=file_get_contents($userinfo_url);<br>$userinfo=json_decode($userinfo,true);<br>var_dump($userinfo);<br>}<br>else{<br>    echo”oauth  fail”;exit;<br>}<br>?&gt;</pre><br>值得注意的有：</p>
<p>1，修改第6行中的回调域名，请换成你自己的哈</p>
<p><pre class="start-line:6 lang:default decode:true "> $redirect_url=”<a href="http://wechat.chenyalun.cn/oauth.php" target="_blank" rel="external">http://wechat.chenyalun.cn/oauth.php</a>“;</pre><br>2，请更换第4行和第5行中的appid和appsecret，换成你自己的</p>
<p><pre class="start-line:4 lang:default decode:true">       $appid = “wx1f06a6d59f960018”;<br>       $appsecret = “87b4d3c8d560a522213fde2f5d42fb99”;</pre><br>3，请修改第7行中相应的回调地址和appid（这个我觉得我是不应该提醒的(•ω•`)o），如果以上你都搞定了，将代码保存为oauth.php上传到服务器就可以了。然后用户（或者你自己）用微信内置浏览器访问下面这个地址（就是传说中第7行相应的回调地址）就可以看到授权页面啦，就是这个效果！</p>
<p><pre class="start-line:7 lang:default decode:true"><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx1f06a6d59f960018&amp;redirect_uri=http://wechat.chenyalun.cn/oauth.php&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=123#wechat_redirect" target="_blank" rel="external">https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx1f06a6d59f960018&amp;redirect_uri=http://wechat.chenyalun.cn/oauth.php&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=123#wechat_redirect</a></pre><br><img src="http://source.chenyalun.cn/images/5100632.png" alt=""></p>
<p>上图是我把链接发给自己用于测试</p>
<p><img src="http://source.chenyalun.cn/images/5100633.png" alt=""></p>
<p>上图是授权页面</p>
<p><img src="http://source.chenyalun.cn/images/5100634.png" alt=""></p>
<p>这个是授权结果</p>
<p>没错，就是这样，当然，你要是说我很懒，不想复制上面那些代码，木有关系，代码我都整理好啦，就在百度云</p>
<p>下载链接：<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1bnhW90V" target="_blank" rel="external">http://pan.baidu.com/s/1bnhW90V</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[软件：office2016专业增强正式版]]></title>
      <url>http://yoursite.com/2015/09/30/%E8%BD%AF%E4%BB%B6%EF%BC%9Aoffice2016%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E6%AD%A3%E5%BC%8F%E7%89%88/</url>
      <content type="html"><![CDATA[<p>悄然之间，office2016已经问世，在win10发布之后，office可谓是微软的又一杰作，本着知识分享的原则，今天咱们就一起共睹下office2016专业增强版的真容吧。闲话少说，陈亚伦的office2016已经激活，以word为例：</p>
<p><img src="http://source.chenyalun.cn/images/092601.jpg" alt=""></p>
<h3 id="1，下载office2016软件"><a href="#1，下载office2016软件" class="headerlink" title="1，下载office2016软件"></a>1，下载office2016软件</h3><p>下载地址：<a href="http://www.chenyalun.cn/go/?url=http://yun.baidu.com/s/1hqnlDFQ" target="_blank" rel="external">http://yun.baidu.com/s/1hqnlDFQ</a></p>
<h3 id="2，下载office2016激活工具"><a href="#2，下载office2016激活工具" class="headerlink" title="2，下载office2016激活工具"></a>2，下载office2016激活工具</h3><p>下载地址：<a href="http://www.chenyalun.cn/go/?url=http://yun.baidu.com/s/1mg8Imog" target="_blank" rel="external">http://yun.baidu.com/s/1mg8Imog</a></p>
<h3 id="3，激活过程"><a href="#3，激活过程" class="headerlink" title="3，激活过程"></a>3，激活过程</h3><p>解压office到当前文件夹，点击【office】，根据你的计算机系统选择32位或者64位进行安装。</p>
<p><img src="http://source.chenyalun.cn/images/092602.jpg" alt=""></p>
<p>如何知道自己计算机是32位或64位？以win10为例，打开【此电脑】，点击系统属性即可。</p>
<p><img src="http://source.chenyalun.cn/images/092603.jpg" alt=""></p>
<p><img src="http://source.chenyalun.cn/images/092804.jpg" alt=""></p>
<p>安装完成后，解压激活工具，查看【使用说明】，里面说的很详细了需要注意的是office2016组件可以与office2013组件并存。</p>
<p>【便携版运行】<br>1. 管理员身份运行 Auto.cmd、Autopico.exe<br>2. 完成.</p>
<p>【可以激活】<br>Windows 10 所有版<br>Office 2010/2013/2016<br>Windows 8 、Windows 8.1 所有版<br>Windows Server 2016 (Theorically)<br>Windows 7 Professional/N/Enterprise/N 专业版、企业版<br>Windows Vista Business/N/Enterprise/N 商业版、企业版<br>Windows Server Technical Preview Build 9841/9860/9926 所有版本<br>Windows Server 2008/2008R2 Standard/Datacenter/Enterprise 标准版/数据中心版/企业版<br>Windows Server 2012/2012R2 Standard/Datacenter/Enterprise 标准版/数据中心版/企业版</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自定义菜单的创建]]></title>
      <url>http://yoursite.com/2015/09/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>在微信公众号的高级接口中，自定义菜单可谓是非常重要的，通过它，订阅者可以十分方便地获取自己需要的内容，同时，正因为菜单这个功能，微信公众号才可以与APP媲美，成为简单精致的“轻APP”，如此，今天咱们就讨论下自定义菜单的创建与删除。</p>
<h3 id="1，自定义菜单的类型"><a href="#1，自定义菜单的类型" class="headerlink" title="1，自定义菜单的类型"></a>1，自定义菜单的类型</h3><p>自定义菜单最多包括3个一级菜单，每个一级菜单最多包括个二级菜单，一级菜单最多显示4个汉字，二级菜单最多显示7个汉字。自定义菜单创建后，由于客户端的缓存，需要24小时才能生效，对新关注用户立即生效，所以开发者们要是想测试的话，取消关注，再点击关注即可。</p>
<p>自定义菜单的类型：</p>
<pre class="show-plain-default:true lang:default decode:true">1、click：点击推事件
用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event    的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互；

2、view：跳转URL
用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。

3、scancode_push：扫码推事件
用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。

4、scancode_waitmsg：扫码推事件且弹出“消息接收中”提示框
用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。

5、pic_sysphoto：弹出系统拍照发图
用户点击按钮后，微信客户端将调起系统相机，完成拍照操作后，会将拍摄的相片发送给开发者，并推送事件给开发者，同时收起系统相机，随后可能会收到开发者下发的消息。

6、pic_photo_or_album：弹出拍照或者相册发图
用户点击按钮后，微信客户端将弹出选择器供用户选择“拍照”或者“从手机相册选择”。用户选择后即走其他两种流程。

7、pic_weixin：弹出微信相册发图器
用户点击按钮后，微信客户端将调起微信相册，完成选择操作后，将选择的相片发送给开发者的服务器，并推送事件给开发者，同时收起相册，随后可能会收到开发者下发的消息。

8、location_select：弹出地理位置选择器
用户点击按钮后，微信客户端将调起地理位置选择工具，完成选择操作后，将选择的地理位置发送给开发者的服务器，同时收起位置选择工具，随后可能会收到开发者下发的消息。

9、media_id：下发消息（除文本消息）
用户点击media_id类型按钮后，微信服务器会将开发者填写的永久素材id对应的素材下发给用户，永久素材类型可以是图片、音频、视频、图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。

10、view_limited：跳转图文消息URL
用户点击view_limited类型按钮后，微信客户端将打开开发者在按钮中填写的永久素材id对应的图文消息URL，永久素材类型只支持图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。</pre>
**请注意，3到8的所有事件，仅支持微信iPhone5.4.1以上版本，和Android5.4以上版本的微信用户，旧版本微信用户点击后将没有回应，开发者也不能正常接收到事件推送。9和10，是专门给第三方平台旗下未微信认证（具体而言，是资质认证未通过）的订阅号准备的事件类型，它们是没有事件推送的，能力相对受限，其他类型的公众号不必使用。**

**click和view的请求示例：**
<pre class="lang:default decode:true ">{
     "button":[
     {    
          "type":"click",
          "name":"今日歌曲",
          "key":"V1001_TODAY_MUSIC"
      },
      {
           "name":"菜单",
           "sub_button":[
           {    
               "type":"view",
               "name":"搜索",
               "url":"http://www.soso.com/"
            },
            {
               "type":"view",
               "name":"视频",
               "url":"http://v.qq.com/"
            },
            {
               "type":"click",
               "name":"赞一下我们",
               "key":"V1001_GOOD"
            }]
       }]
 }</pre>
**其他新增按钮类型的请求示例：**
<pre class="lang:default decode:true ">{
    "button": [
        {
            "name": "扫码", 
            "sub_button": [
                {
                    "type": "scancode_waitmsg", 
                    "name": "扫码带提示", 
                    "key": "rselfmenu_0_0", 
                    "sub_button": [ ]
                }, 
                {
                    "type": "scancode_push", 
                    "name": "扫码推事件", 
                    "key": "rselfmenu_0_1", 
                    "sub_button": [ ]
                }
            ]
        }, 
        {
            "name": "发图", 
            "sub_button": [
                {
                    "type": "pic_sysphoto", 
                    "name": "系统拍照发图", 
                    "key": "rselfmenu_1_0", 
                   "sub_button": [ ]
                 }, 
                {
                    "type": "pic_photo_or_album", 
                    "name": "拍照或者相册发图", 
                    "key": "rselfmenu_1_1", 
                    "sub_button": [ ]
                }, 
                {
                    "type": "pic_weixin", 
                    "name": "微信相册发图", 
                    "key": "rselfmenu_1_2", 
                    "sub_button": [ ]
                }
            ]
        }, 
        {
            "name": "发送位置", 
            "type": "location_select", 
            "key": "rselfmenu_2_0"
        },
        {
           "type": "media_id", 
           "name": "图片", 
           "media_id": "MEDIA_ID1"
        }, 
        {
           "type": "view_limited", 
           "name": "图文消息", 
           "media_id": "MEDIA_ID2"
        }
    ]
}</pre>
**参数说明**
<table border="1" width="640px" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
<tr>
<td>button</td>
<td>是</td>
<td>一级菜单数组，个数应为1~3个</td>
</tr>
<tr>
<td>sub_button</td>
<td>否</td>
<td>二级菜单数组，个数应为1~5个</td>
</tr>
<tr>
<td>type</td>
<td>是</td>
<td>菜单的响应动作类型</td>
</tr>
<tr>
<td>name</td>
<td>是</td>
<td>菜单标题，不超过16个字节，子菜单不超过40个字节</td>
</tr>
<tr>
<td>key</td>
<td>click等点击类型必须</td>
<td>菜单KEY值，用于消息接口推送，不超过128字节</td>
</tr>
<tr>
<td>url</td>
<td>view类型必须</td>
<td>网页链接，用户点击菜单可打开链接，不超过256字节</td>
</tr>
<tr>
<td>media_id</td>
<td>media_id类型和view_limited类型必须</td>
<td>调用新增永久素材接口返回的合法media_id</td>
</tr>
</tbody>
</table>
**返回结果**

正确时的返回JSON数据包如下：
<pre class="lang:default decode:true ">{"errcode":0,"errmsg":"ok"}</pre>
错误时的返回JSON数据包如下（示例为无效菜单名长度）：
<pre class="lang:default decode:true ">{"errcode":40018,"errmsg":"invalid button name size"}</pre>

<h3 id="2，测试代码"><a href="#2，测试代码" class="headerlink" title="2，测试代码"></a>2，测试代码</h3><p>接口使用POST方式提交json数据，测试代码如下：</p>
<p><pre class="lang:default decode:true">$jsonmenu = ‘{<br>      “button”:[<br>      {<br>            “name”:”关于我们”,<br>           “sub_button”:[<br>            {<br>               “type”:”click”,<br>               “name”:”公司简介”,<br>               “key”:”公司简介”<br>            },<br>            {<br>               “type”:”click”,<br>               “name”:”社会责任”,<br>               “key”:”社会责任”<br>            },<br>            {<br>               “type”:”click”,<br>               “name”:”联系我们”,<br>               “key”:”联系我们”<br>            }]<br>       },<br>       {<br>           “name”:”产品服务”,<br>           “sub_button”:[<br>            {<br>               “type”:”click”,<br>               “name”:”微信平台”,<br>               “key”:”微信平台”<br>            },<br>            {<br>               “type”:”click”,<br>               “name”:”微博应用”,<br>               “key”:”微博应用”<br>            },<br>            {<br>                “type”:”click”,<br>                “name”:”手机网站”,<br>                “key”:”手机网站”<br>            }]<br>       },<br>       {<br>           “name”:”技术支持”,<br>           “sub_button”:[<br>            {<br>               “type”:”click”,<br>               “name”:”文档下载”,<br>               “key”:”文档下载”<br>            },<br>            {<br>               “type”:”click”,<br>               “name”:”技术社区”,<br>               “key”:”技术社区”<br>            },<br>            {<br>                “type”:”click”,<br>                “name”:”服务热线”,<br>                “key”:”服务热线”<br>            }]<br>       }]<br> }’;</pre></p>
<p>$url = “<a href="https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&quot;.$access_token" target="_blank" rel="external">https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&quot;.$access_token</a>;<br>$result = https_request($url, $jsonmenu);<br>var_dump($result);</p>
<p>function https_request($url,$data = null){<br>    $curl = curl_init();<br>    curl_setopt($curl, CURLOPT_URL, $url);<br>    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);<br>    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);<br>    if (!empty($data)){<br>        curl_setopt($curl, CURLOPT_POST, 1);<br>        curl_setopt($curl, CURLOPT_POSTFIELDS, $data);<br>    }<br>    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);<br>    $output = curl_exec($curl);<br>    curl_close($curl);<br>    return $output;<br>}</p>
<p>$url = “<a href="https://api.weixin.qq.com/cgi-bin/menu/get?access_token=&quot;.$access_token" target="_blank" rel="external">https://api.weixin.qq.com/cgi-bin/menu/get?access_token=&quot;.$access_token</a>;<br>$result = https_request($url);<br>var_dump($result);</p>
<p>function https_request($url, $data = null){<br>    $curl = curl_init();<br>    curl_setopt($curl, CURLOPT_URL, $url);<br>    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);<br>    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);<br>    if (!empty($data)){<br>        curl_setopt($curl, CURLOPT_POST, 1);<br>        curl_setopt($curl, CURLOPT_POSTFIELDS, $data);<br>    }<br>    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);<br>    $output = curl_exec($curl);<br>    curl_close($curl);<br>    return $output;<br>}</p>
<p>$url = “<a href="https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=&quot;.$access_token" target="_blank" rel="external">https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=&quot;.$access_token</a>;<br>$result = https_request($url);<br>var_dump($result);</p>
<p>function https_request($url, $data = null){<br>    $curl = curl_init();<br>    curl_setopt($curl, CURLOPT_URL, $url);<br>    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);<br>    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);<br>    if (!empty($data)){<br>        curl_setopt($curl, CURLOPT_POST, 1);<br>        curl_setopt($curl, CURLOPT_POSTFIELDS, $data);<br>    }<br>    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);<br>    $output = curl_exec($curl);<br>    curl_close($curl);<br>    return $output;<br>}</p>
<p>private function receiveEvent($object)<br>{<br>    $contentStr = “”;<br>    switch ($object-&gt;Event)<br>    {<br>        case “subscribe”:<br>            $contentStr[] = array(“Title” =&gt;”欢迎关注陈亚伦”,<br>            “Description” =&gt;”点击图片关注或者微信搜索陈亚伦”,<br>            “PicUrl” =&gt;”<a href="http://7source.chenyalun.cn/wp-content/uploads/2015/09/50924w.jpg" target="_blank" rel="external">http://7source.chenyalun.cn/wp-content/uploads/2015/09/50924w.jpg</a>“,<br>            “Url” =&gt;”weixin://addfriend/pondbaystudio”);<br>        case “unsubscribe”:<br>            break;<br>        case “CLICK”:<br>            switch ($object-&gt;EventKey)<br>            {<br>                case “公司简介”:<br>                    $contentStr[] = array(“Title” =&gt;”公司简介”,<br>                    “Description” =&gt;”陈亚伦博客专注软件知识分享”,<br>                    “PicUrl” =&gt;”<a href="http://7source.chenyalun.cn/wp-content/uploads/2015/09/50924w.jpg" target="_blank" rel="external">http://7source.chenyalun.cn/wp-content/uploads/2015/09/50924w.jpg</a>“,<br>                    “Url” =&gt;”<a href="http://www.chenyalun.cn" target="_blank" rel="external">http://www.chenyalun.cn</a>“);<br>                    break;<br>                default:<br>                    $contentStr[] = array(“Title” =&gt;”默认菜单回复”,<br>                    “Description” =&gt;”您正在使用的是陈亚伦博客的自定义菜单测试接口”,<br>                    “PicUrl” =&gt;”<a href="http://7source.chenyalun.cn/wp-content/uploads/2015/09/50924w.jpg" target="_blank" rel="external">http://7source.chenyalun.cn/wp-content/uploads/2015/09/50924w.jpg</a>“,<br>                    “Url” =&gt;”<a href="http://www.chenyalun.cn" target="_blank" rel="external">http://www.chenyalun.cn</a>“);<br>                    break;<br>            }<br>            break;<br>        default:<br>            break;      </p>
<p>   }<br>    return $contentStr;<br>}<br><br>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字符串与定义字符数组的简单区分]]></title>
      <url>http://yoursite.com/2015/09/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%8C%BA%E5%88%86/</url>
      <content type="html"><![CDATA[<p>字符串定义与字符数组定义是编程语言的基础，是最起码的知识，而知识就像内裤，平时看不见，却非常有用。先回顾一下最简单的字符数组的定义，一共有三种典型方法。</p>
<h3 id="1，定义字符数组"><a href="#1，定义字符数组" class="headerlink" title="1，定义字符数组"></a>1，定义字符数组</h3><p><pre class="lang:default decode:true">char a[3]={‘1’,’2’,’3’};<br></pre></p>
<p><pre class="lang:default decode:true">char a[3]=”12”;其实是char a[3]={‘1’,’2’,’\0’}</pre></p>
<p><pre class="lang:default decode:true">char a[3]={“12”};其实是char a[3]={‘1’,’2’,’\0’}</pre><br>需要注意的是：</p>
<p>第一： 字符串其实就是以\0结尾的字符串。<br>第二：定义 字符数组时要考虑    \0 ，平时笔试题每次都出，但是一到实际编程中，就巧妙地遗忘了。</p>
<p>还有一种方式：</p>
<p><pre class="lang:default decode:true ">char a[3]={3,2,3};</pre><br>这个根本不是定义字符数组。因为少了单引号，当年出现这种情况，处于好奇，利用c++直接输出a[0],然后就是个表情。从a[0]开始，一直到a[47]，都是不正常的字符，到a[48]时才出现数字0。请看下面代码：</p>
<p><pre class="lang:default decode:true ">#include&lt;iostream&gt;<br>using namespace std;<br>int main(){<br>    char a[3]={3,2,1};<br>    cout&lt;&lt;a[0];<br>}</pre><br>不信可以自己测试一下。</p>
<h3 id="2，字符数组深入探讨"><a href="#2，字符数组深入探讨" class="headerlink" title="2，字符数组深入探讨"></a>2，字符数组深入探讨</h3><p><pre class="lang:default decode:true">#include&lt;stdio.h&gt;</pre></p>
<p>#include&lt;string.h&gt;<br>int main(){<br>    char a[3]={3,2,1},b[6]={5,6,7,8,9};<br>    int m;<br>    m=a[0]+b[4];<br>    printf(“%d”,m);<br>    return 0;<br>}<br>结果竟然是12，不可思议，明明我的字符数组定义是错误的，为什么还出现正确的结果？</p>
<p>和同学探讨一下，原因在于</p>
<p><pre class="lang:default decode:true">printf(“%d”,m);</pre><br>没错，就是这一行中的%d,   C语言中的输出强制类型转换将本是字符相加活生生变成数字相加。</p>
<p>当把这行代码改成</p>
<p><pre class="lang:default decode:true ">printf(“%c”,m);</pre><br>结果再一次变成表情，嗯，准确的说是个男性符号。</p>
<p>再次折腾一下，整个代码改成下面的这样：</p>
<p><pre class="lang:default decode:true ">#include&lt;iostream&gt;<br>using namespace std;<br>int main(){<br>    char a[3]={‘3’,’2’,’1’},b[6]={‘5’,’6’,’7’,’8’,’9’};<br>          cout&lt;&lt;a[0]+b[4]-‘0’-‘0’;<br>    return 0;<br>}</pre><br>为了避免C语言输出的类型转换，我用C++输出，可见，因为两个’0’的缘故，字符结果已经转换为数字了。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[李瓶儿：苦苦追寻爱情的痴心女子（下）]]></title>
      <url>http://yoursite.com/2015/09/24/%E6%9D%8E%E7%93%B6%E5%84%BF%EF%BC%9A%E8%8B%A6%E8%8B%A6%E8%BF%BD%E5%AF%BB%E7%88%B1%E6%83%85%E7%9A%84%E7%97%B4%E5%BF%83%E5%A5%B3%E5%AD%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在【<a href="http://www.chenyalun.cn/%E6%9D%8E%E7%93%B6%E5%84%BF%EF%BC%9A%E8%8B%A6%E8%8B%A6%E8%BF%BD%E5%AF%BB%E7%88%B1%E6%83%85%E7%9A%84%E7%97%B4%E5%BF%83%E5%A5%B3%E5%AD%90%EF%BC%88%E4%B8%8A%EF%BC%89.html" target="_blank" rel="external">李瓶儿：苦苦追寻爱情的痴心女子（上）</a>】中我们说到李瓶儿几经波折嫁进了西门府中（我想很大程度是因为李瓶儿的钱财），对西门庆可以说是俯首帖耳，死心塌地，对其他妻妾也显得十分谦恭。李瓶儿只要一面对西门庆，性格就会变得被动，就会逆来顺受，智商也变得不高了，这当然不是因为西门庆极大满足了她的情欲。无论是甘于屈居人下，或是忍辱负重，李瓶儿确实看开了许多，唯一的愿望是求得上下左右能认可她。她自个儿有财富可以自由支配，她经常拿出钱物进行公关，也因为如此，她在这个家的口碑越来越好，接着，也越发招人嫉妒。</p>
<p>在以男权为中心的一夫多妻制度下，妻妾争宠是必然的，谁要是最受丈夫的爱怜，谁就会成为众矢之的。果然，与潘金莲的斗争就此开始，李瓶儿的悲剧下场是必然的。</p>
<p>当命运安排李瓶儿的儿子——官哥儿呱呱坠地时，潘金莲竟跑到房中痛哭，可见其嫉妒之情浓厚，接着，一系列阴毒的计划实施了。她让官哥不是受惊就是受凉，最后放出猫，吓死了无辜的小生命。李瓶儿性格比较懦弱，见事则迷，头脑简单也使她丧失自我保护意识，她竟然幻想西门庆会保护她，到官哥死去的那一刻，她精神已经崩溃了，再加上身体在西门庆的另一种形式的糟蹋下，她罹患上血崩症。而此时，潘金莲仍不依不饶，处处紧逼，整日叫骂，她终于没有力量与死神较量了。</p>
<p>梦是一个人内心深处的真实写照，在李瓶儿的生命尽头，她每天的梦都会出现前夫花子虚，内容都是花子虚发誓绝不宽恕她，在梦境中，花子虚拿刀找她算账。从这一点可以看出她自己内心的痛苦，这是一种恐惧感、一种罪孽感、一种愧疚感。甚至可以说是她的良心发现。</p>
<p>李瓶儿获得西门庆的宠爱经过一波三折，而一旦获得了西门庆的宠爱，随之而来的则是横祸，她没有什么太大的奢望，就是希望能和 西门庆”团圆几年“”做夫妻一场“，这是多么简单质朴的愿望啊。可是，潘金莲像幽灵一样缠着她，明里暗里折磨她，甚至西门庆到自己房间都不敢收留，硬是把西门庆推到潘金莲那边去睡，呵，竟然怕到这种程度。</p>
<p>在最后一刻，她躺在龌龊的床上，西门庆要来陪她，但她还是拒绝了，她不愿意脏了西门庆，香消玉殒前，双手搂着西门庆，倾诉真心，细心叮嘱。</p>
<p>李瓶儿与西门庆所有的妻妾都不同，她深爱着西门庆，心甘情愿为他做许多事，而自己的愿望却十分简单，只想和他做夫妻一场。她心地善良，简单质朴，没有那么多心机，不如潘金莲会玩心计，可是命运却亏欠了她。</p>
<p>对爱情的执着，让她勇敢面对一切，却最终在西门府中丧命，对生活的期盼，让她重燃希望，却最终失去所有的希望，她不是不渴望走出阴影，而是她走不进阳光，那个社会的女人的尴尬就在此。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[李瓶儿：苦苦追寻爱情的痴心女子（上）]]></title>
      <url>http://yoursite.com/2015/09/24/%E6%9D%8E%E7%93%B6%E5%84%BF%EF%BC%9A%E8%8B%A6%E8%8B%A6%E8%BF%BD%E5%AF%BB%E7%88%B1%E6%83%85%E7%9A%84%E7%97%B4%E5%BF%83%E5%A5%B3%E5%AD%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>李瓶儿长得漂亮，五短身材，肌肤白净，瓜子脸皮，“细弯弯两道眉儿”“身软如棉花”，看看一出场就不简单。她原先被大名府梁中书纳为妾，但梁中书媳妇爱嫉妒，所以把她安置在外边书房，再后来，梁山好汉攻上大名府时，她趁乱带了一百颗西洋大珠、二两重一对鸦青宝石，随养娘逃到东京，被花太监纳为侄儿媳妇，名义上是嫁给花子虚，其实却一直被老太监霸占着。花太监告老还乡，花子虚与李瓶儿随之来到清河县住，巧的是，他们家就在<a href="http://www.chenyalun.cn/%e8%a5%bf%e9%97%a8%e5%ba%86%ef%bc%9a%e5%8d%a0%e6%9c%89%e6%ac%b2%e8%86%a8%e8%83%80%e7%9a%84%e6%82%b2%e5%82%ac%e8%a1%b0%e7%94%b7.html" target="_blank" rel="external">西门庆</a>家隔壁。</p>
<p>说这花子虚，浪荡公子一枚，在家有如花似玉的老婆，仍然是天天出没娱乐场所，寻花问柳，对媳妇也不在意，结果呢，人家西门庆趁虚而入。花子虚就知道在外面鬼混，而他又和西门庆拜了把子，西门庆在他家里一见到李瓶儿，就发动强烈攻势。而李瓶儿呢，老公整天不着家，内心也是相当孤寂，生活异常无聊，这个时候哪能经得起西门大官人这位情场高手的软磨硬泡，自然而然地两人开始偷情了。</p>
<p>这时花家发生巨大变故，花子虚因争家产吃了官司，进了牢房，此时的李瓶儿却没有落井下石，乞求西门庆拯救自己的丈夫，可是他求的人是西门庆，西门庆偷了人家媳妇，想着霸占他家财产，明摆着巴不得花子虚在牢房里死掉呢。到这里，可见李瓶儿为人妻的一面，“一日夫妻百日恩”，尽管丈夫十分不济，处处寻花问柳，她却仍然表现出了怜悯，但是这已经不是爱了，因为她早已对丈夫失望了，而且已经从内心承认自己是西门庆的人了。</p>
<p>他拿出3000两银子委托西门庆救人，西门庆认为不需要这么多，她硬是要西门庆收下，说明除了身体、情感，在钱财上已经和西门庆不分彼此了。从情感上来说，早先李瓶儿还劝说丈夫早些回家，希望他回心转意，可花子虚太不争气了，到最后，把媳妇仅剩的期盼也给撕得粉碎，那么，身为女人的她，最终把情感给予了西门庆，她真的眷恋上这个男人了。</p>
<p>花子虚诉讼失败被气死了。此时也发生了巨变，朝廷内部政治斗争，因为种种牵扯，西门庆怕自己受到连累，紧闭家门，就像从人家蒸发了。而李瓶儿这边呢，丈夫死去，西门庆突然又不联络自己，这才有“李瓶儿招赘蒋竹山”的故事。李瓶儿病倒了，内心恐慌，无依无靠，看病的时候不免与医生闲谈几句，医生蒋竹山看到李瓶儿大美女一个，自告奋勇，愿意照顾李瓶儿，李瓶儿就想凑合过吧，两人于是结婚。</p>
<p>不计后果的婚姻终究不美满，蒋竹山是个性无能，而且性格软弱，与西门庆的潇洒伟岸形成鲜明对比。李瓶儿像大多数女子一样，希望有个可以在意自己的男人相伴，这是一个妇女最朴素的愿望了，所以尽管李瓶儿对西门庆痴情一片，可西门庆已经“人间蒸发”了，所以片面地说李瓶儿性欲旺盛、寂寞怀春是不正确的。</p>
<p>到后来，斗争平息，西门庆又一次趾高气昂地走到十字街口，当他知道昔日情妇嫁给蒋竹山后十分恼火，但请注意，恼火的根本原因是蒋竹山凭借李瓶儿的钱财开了间药铺，抢了西门庆的生意。所以，可怜人家对他痴情一片，西门庆却在意的是钱，而且西门庆此时也有另一个情妇了。</p>
<p>事情正常发展，蒋竹山被流氓（其实可以想到是西门大官人）欺侮，吃了冤枉官司，李瓶儿撒气将他扫地出门。这样，西门庆在对付完朝廷的危机后，又趁便娶进了李瓶儿，那李瓶儿嫁到心仪的西门府中又会有什么遭遇呢，她的痴情能否感动西门庆呢，且看 【<span class="trail-end"><a href="http://www.chenyalun.cn/%E6%9D%8E%E7%93%B6%E5%84%BF%EF%BC%9A%E8%8B%A6%E8%8B%A6%E8%BF%BD%E5%AF%BB%E7%88%B1%E6%83%85%E7%9A%84%E7%97%B4%E5%BF%83%E5%A5%B3%E5%AD%90%EF%BC%88%E4%B8%8B%EF%BC%89.html" target="_blank" rel="external">李瓶儿：苦苦追寻爱情的痴心女子（下）</a>】</span>分解。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用语音识别实现翻译助手功能]]></title>
      <url>http://yoursite.com/2015/09/23/%E5%88%A9%E7%94%A8%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E5%AE%9E%E7%8E%B0%E7%BF%BB%E8%AF%91%E5%8A%A9%E6%89%8B%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>在微信接口权限中，语音识别默认是关闭的，需要我们手动打开。由于客户端缓存，开发者开启语音识别权限对新关注用户立即生效，对已关注用户24小时内生效，所以想要立即体验，请取消关注后再次关注即可。</p>
<p><img src="http://source.chenyalun.cn/images/509231.jpg" alt=""></p>
<p>开通语音识别功能，用户每次发送语音给公众号时，微信会在推送的语音消息XML数据包中，增加一个Recongnition字段。开启语音识别后的语音XML数据包如下：</p>
<p><pre class="lang:default decode:true">&lt;xml&gt;<br>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br>&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;<br>&lt;CreateTime&gt;1357290913&lt;/CreateTime&gt;<br>&lt;MsgType&gt;&lt;![CDATA[voice]]&gt;&lt;/MsgType&gt;<br>&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;<br>&lt;Format&gt;&lt;![CDATA[Format]]&gt;&lt;/Format&gt;<br>&lt;Recognition&gt;&lt;![CDATA[陈亚伦博客]]&gt;&lt;/Recognition&gt;<br>&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;<br>&lt;/xml&gt;</pre><br>参数说明：</p>
<p><table border="1" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>描述</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>发送方帐号（一个OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>消息创建时间 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td>语音为voice</td><br></p>
<p><tr></tr></p>
<p><td>MediaID</td></p>
<p><td>语音消息媒体id，可以调用多媒体文件下载接口拉取该媒体</td><br></p>
<p><tr></tr></p>
<p><td>Format</td></p>
<p><td>语音格式：amr</td><br></p>
<p><tr></tr></p>
<p><td>Recognition</td></p>
<p><td>语音识别结果，UTF8编码</td><br></p>
<p><tr></tr></p>
<p><td>MsgID</td></p>
<p><td>消息id，64位整型</td><br><br><br><br>如果想要利用语音识别实现翻译助手的功能，那该怎么实现呢？</p>
<p>1，申请API访问权限以及接口说明</p>
<p>翻译助手的规则是：消息的头两个字是“翻译”，我们翻译后面的文本，如果是中文就翻译成英文，如果是非中文就翻译成中文。比较知名的API有：</p>
<p>有道翻译API：<a href="http://fanyi.youdao.com/openapi?path=data-mode" target="_blank" rel="external">http://fanyi.youdao.com/openapi?path=data-mode</a></p>
<p>（使用<span class="strong">API key</span> 时，请求频率限制为每小时1000次，超过限制会被封禁。）</p>
<p>百度翻译API：<a href="http://openapi.baidu.com/public/2.0/bmt/translate" target="_blank" rel="external">http://openapi.baidu.com/public/2.0/bmt/translate</a></p>
<p>这里我们采用有道翻译，直接在页面上申请即可：</p>
<p><img src="http://source.chenyalun.cn/images/509232.jpg" alt=""></p>
<p>有道的数据接口：</p>
<p><a href="http://fanyi.youdao.com/openapi.do?keyfrom=&amp;key=&amp;type=data&amp;doctype=&amp;version=1.1&amp;q=要翻译的文本" target="_blank" rel="external">http://fanyi.youdao.com/openapi.do?keyfrom=&amp;key=&amp;type=data&amp;doctype=&amp;version=1.1&amp;q=要翻译的文本</a></p>
<p>参数说明：</p>
<p>　type - 返回结果的类型，固定为data</p>
<p>　doctype - 返回结果的数据格式，xml或json或jsonp</p>
<p>　version - 版本，当前最新版本为1.1</p>
<p>　q - 要翻译的文本，必须是UTF-8编码，字符长度不能超过200个字符，需要进行urlencode编码</p>
<p>　only - 可选参数，dict表示只获取词典数据，translate表示只获取翻译数据，默认为都获取</p>
<p>　注： 词典结果只支持中英互译，翻译结果支持英日韩法俄西到中文的翻译以及中文到英语的翻译</p>
<p>errorCode：</p>
<p>　0 - 正常</p>
<p>　20 - 要翻译的文本过长</p>
<p>　30 - 无法进行有效的翻译</p>
<p>　40 - 不支持的语言类型</p>
<p>　50 - 无效的key</p>
<p>　60 - 无词典结果，仅在获取词典结果生效</p>
<p>一个json数据格式的例子：</p>
<p><pre class="lang:default decode:true "><a href="http://fanyi.youdao.com/openapi.do?keyfrom=&lt;keyfrom&gt;&amp;key=&lt;key&gt;&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=good" target="_blank" rel="external">http://fanyi.youdao.com/openapi.do?keyfrom=&lt;keyfrom&gt;&amp;key=&lt;key&gt;&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=good</a><br>{<br>    “errorCode”:0<br>    “query”:”good”,<br>    “translation”:[“好”], // 有道翻译<br>    “basic”:{ // 有道词典-基本词典<br>        “phonetic”:”gʊd”<br>        “uk-phonetic”:”gʊd” //英式发音<br>        “us-phonetic”:”ɡʊd” //美式发音<br>        “explains”:[<br>            “好处”,<br>            “好的”<br>            “好”<br>        ]<br>    },<br>    “web”:[ // 有道词典-网络释义<br>        {<br>            “key”:”good”,<br>            “value”:[“良好”,”善”,”美好”]<br>        },<br>        {…}<br>    ]<br>}</pre><br>这里我们也采用json的数据格式，判断消息的类型，如果是文本，处理文本正文，如果是语音，处理语音识别后的文本。如果文本消息的前两个字是翻译，调用翻译助手，如果不是就返回文本内容。</p>
<p>程序实现：</p>
<p><pre class="lang:default decode:true ">&lt;?php<br>define(‘KEYFROM’,’chenyalun’);<br>define(‘APIKEY’,’232203214’);</pre></p>
<p>function translationHelper($msg)<br>{<br>  $youdaoUrl = ‘<a href="http://fanyi.youdao.com/fanyiapi.do?keyfrom=&#39;.KEYFROM.&#39;&amp;key=&#39;.APIKEY.&#39;&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=&#39;.$msg" target="_blank" rel="external">http://fanyi.youdao.com/fanyiapi.do?keyfrom=&#39;.KEYFROM.&#39;&amp;key=&#39;.APIKEY.&#39;&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=&#39;.$msg</a>;<br>  $content=curl_get($youdaoUrl);<br>  $ret=json_decode($content,true);<br>  $result = ‘深呼吸，再试一次’;<br>  if(array_key_exists(‘errorCode’,$ret)){<br>       switch($ret[‘errorCode’])<br>       {<br>               case 0:<br>                   $result = $ret[‘translation’][‘0’];<br>                break;<br>               case 20:<br>                   $result = ‘亲,您的消息太长长长了哦’;<br>                   break;<br>               case 30:<br>                $result = ‘宝贝，翻译助手也有不会翻译的时候哦’;<br>                break;<br>            case 40:<br>                $result = ‘本助手是有原则的,不翻译鸟语,哼’;<br>                break;<br>            case 50:<br>                $result = ‘不要胡言乱语，说人话’;<br>                break;<br>       }<br>  }<br>  return $result;<br>}<br>?&gt;<br>代码保存的时候请注意是ANCII格式，否则会出错的。上面这个代码是嵌入到程序中的，如果想要单独测试，不用“翻译”二字，发送什么翻译什么，就像下面的图片。</p>
<p><img src="http://source.chenyalun.cn/images/5100611.png" alt=""><img src="http://source.chenyalun.cn/images/5100610.png" alt=""></p>
<p>也是十分简单的，如果自己想要尝试的话，请下载代码与数据库的压缩包，</p>
<p>嗯，下载链接：<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1nt5YCWD" target="_blank" rel="external">http://pan.baidu.com/s/1nt5YCWD</a> 云中的代码就是上图的效果，发送什么翻译什么，中英文都可以的。而且代码很容易配置，再次友好提醒一下，TOKEN是chenyalun。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[题目1001：整数a+b的程序实现（上）]]></title>
      <url>http://yoursite.com/2015/09/22/%E9%A2%98%E7%9B%AE1001%EF%BC%9A%E6%95%B4%E6%95%B0a+b%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>从这篇文章起，咱们就一起探讨下程序设计题，一方面练练技术，另一方面也好和大家一起提高，所以如果你遇到不解或者有什么建议请及时联系我，咱们一起探讨，毕竟三人行，必有我师嘛。</p>
<p>今天，咱们就探讨下a+b的问题，别看这个问题很easy，但是确实值得思考。题目如下：</p>
<p>输入：a  b</p>
<p>输出：a+b的结果</p>
<p>例如：</p>
<pre class="lang:default decode:true ">输入：
3  7
输出：
10</pre>
看到这个题目是不是很无语呀，哈哈，这个题目是我自己编的，好吧，进入正题，我们要考虑的情况有：

1，普通整数加法运行一次；

2，普通整数加法多次输入（运行一次程序不退出）；

3，长整数加法（比如15位的数相加）运行一次；

4，长整数加法（比如15位的数相加）多次输入；

因为我们是对问题进行分析，所以程序的实现笔者就用三种代码（c，c++，java）供大家参考。

### 1，普通整数加法运行一次

这个问题过于简单，不做多说。上代码：

c语言版
<pre class="lang:default decode:true">//普通整数a与b相加代码的实现--c语言
#include &lt;stdio.h&gt;
int main()
{
 int a,b;
 scanf("%d %d",&amp;a,&amp;b);
 printf("%d\n",a+b);
 return 0;
}</pre>
此时输完a后，输入回车或空格，再输入b即可；如果想要输完a后，输入逗号，再输入b，代码第6行改为：
<pre class="lang:default decode:true "> scanf("%d,%d",&amp;a,&amp;b);</pre>
值得注意的是，一定要分清“，”与“,”的区别，错一点都不行。c语言是这样，c++，java请自行分析。

本博客采用国际上流行的标准。输入a后，按回车键作为分隔，再输入b，以后代码默认如此，不再赘述。

c++版
<pre class="lang:default decode:true">//普通整数a与b相加代码的实现--c++
#include&lt;iostream&gt;
using namespace std;
  int main(){
  int a,b;
  cin&gt;&gt;a&gt;&gt;b;
  cout&lt;&lt;a+b&lt;&lt;endl;
}</pre>
java版
<pre class="lang:default decode:true">//普通整数a与b相加代码的实现--java
import java.io.*;
import java.util.*;
public class Main
{
            public static void main(String args[]) throws Exception
            {
                int a,b;
        Scanner s=new Scanner(System.in);
        a=s.nextInt();
        b=s.nextInt();
        System.out.println(a+b);
            }
}</pre>

<h3 id="2，普通整数加法多次输入"><a href="#2，普通整数加法多次输入" class="headerlink" title="2，普通整数加法多次输入"></a>2，普通整数加法多次输入</h3><p>添加个while循环即可完美解决。</p>
<p>C语言版</p>
<pre class="lang:default decode:true ">//普通整数a与b相加代码的实现--c语言
#include &lt;stdio.h&gt;
int main()
{
 int a,b;
 while(scanf("%d %d",&amp;a,&amp;b))
 printf("%d\n",a+b);
 return 0;
}
</pre>
c++版
<pre class="lang:default decode:true ">//普通整数a与b相加代码的实现--c++
#include&lt;iostream&gt;
using namespace std;
  int main(){
  int a,b;
  while(cin&gt;&gt;a&gt;&gt;b)
  cout&lt;&lt;a+b&lt;&lt;endl;
}</pre>
java版
<pre class="lang:default decode:true">//普通整数a与b相加代码的实现--java
import java.io.*;
import java.util.*;
public class Main
{
            public static void main(String args[]) throws Exception
    {
        int a,b;
        Scanner s=new Scanner(System.in);
        while(s.hasNext())
        {
        a=s.nextInt();
        b=s.nextInt();
        System.out.println(a+b);
        }
    }
}</pre>

<p>### </p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[潘金莲：用手段证明自己存在的女强人（下）]]></title>
      <url>http://yoursite.com/2015/09/21/%E6%BD%98%E9%87%91%E8%8E%B2%EF%BC%9A%E7%94%A8%E6%89%8B%E6%AE%B5%E8%AF%81%E6%98%8E%E8%87%AA%E5%B7%B1%E5%AD%98%E5%9C%A8%E7%9A%84%E5%A5%B3%E5%BC%BA%E4%BA%BA%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>接着上回，<a href="http://www.chenyalun.cn/%e6%bd%98%e9%87%91%e8%8e%b2%ef%bc%9a%e7%94%a8%e6%89%8b%e6%ae%b5%e8%af%81%e6%98%8e%e8%87%aa%e5%b7%b1%e5%ad%98%e5%9c%a8%e7%9a%84%e5%a5%b3%e5%bc%ba%e4%ba%ba%ef%bc%88%e4%b8%8a%ef%bc%89.html" target="_blank" rel="external">潘金莲：用手段证明自己存在的女强人（上）</a>中咱们说到潘金莲心高气傲的性格，当她嫁到西门庆家中，首先她既是主人又是奴隶，西门庆不顺心随时可以对她踢两脚，她和正妻吴月娘发生口角，西门庆也不会给她留情面，而她对这种既贵又贱的身份地位不仅可以理解还安之若素，但是，有一点，西门庆不仅妻妾成群还是个花心大萝卜，在妻妾争宠中，潘金莲的聪明才智在这里发挥的淋漓尽致。那有看官就问了，潘金莲不会阻止西门庆再找情人吗？呵呵，她根本不可能阻挡西门庆对女人的占有欲，她能做的便是在西门庆找到新欢之后顺水推舟，提供场地，出谋划策。</p>
<p>潘金莲软硬兼施，在正妻吴月娘面前低声下气，百般奉承掌握其心理特点后挑拨她与西门庆的关系。在争宠中，能分清敌友，对孟玉楼采取拉的策略，对孙雪娥则采取打的策略。之后又把李瓶儿和宋惠莲作为对手，置强敌于死地，中间过程大家可以想象，就跟后宫效果差不多。所以，潘金莲的手段可以从中窥见一二。</p>
<p>首先是宋惠莲，她和西门庆偷情也就罢了，还说潘金莲的坏话，这不是找事吗，潘金莲用两面派的做法先稳住敌手，再借西门庆之手灭了宋惠莲的丈夫，结果宋惠莲夫妇“男的入官，女的上吊”。接着是李瓶儿，李瓶儿的有钱、貌美成了潘金莲的嫉妒对象，再加上又先给西门庆生个儿子，关键西门庆对李瓶儿还特别喜爱，每晚到她房里，潘金莲心想，这哪成啊，以后我就等于不存在了嘛。于是，潘金莲就对孩子下手了，先是在娃娃满月的时候故意摆弄，让他患上寒潮热，接着精心喂养一只猫，训练有素，平日里用红布裹着肉喂它，而孩子呢，穿的也是红缎衫，你看，潘金莲聪明吧。结果可想而知，某个下午，训练有素的猫扑向孩子，疯狂撕扯，不久这孩子一命呜呼了。孩子死掉了，潘金莲接着对李瓶儿进行疯狂打击，无事生非和她斗气，本来李瓶儿没了孩子情绪就不好，再加上潘金莲这天天给气受，不久也去世了。</p>
<p>潘金莲似乎胜利了，在“后宫”胜利了。她确实是个女强人，聪明伶俐，但是首先她与西门庆没有感情。西门庆只是她的一个梯子，到西门庆府中后，他性欲旺盛，但又无法独自拥有一个男人，后又与西门庆的女婿陈经济发生关系，到最后，为了满足自己的性欲，在西门庆生病、极度虚弱的情况下仍让他吃春药，结果西门庆一命呜呼，所以可以看到她对西门庆从没有过真感情。再说她自己，不惜一切手段包括罪恶证明自己的存在，武大郎也好，宋惠莲、李瓶儿也罢，谁挡了她的路，谁就要付出惨痛的代价，她是个有足够勇气满足自己情欲的人，用杀死一个又一个不喜欢的人证明自己是可爱的。可结果呢？最后一刀被武松解决掉。</p>
<p>潘金莲因为耐不住寂寞，或者说不甘心不满足而出轨，单纯说她不守妇道过于片面，人追求幸福本没有错，既然婚姻不合适就离婚嘛，直接向武大郎说，依大郎的实在憨厚应该会成全她的，但她没有，他选择用杀死武大郎的方式结束自己的婚姻，同时为自己的死埋下伏笔。再说她嫁到西门家族中，处处小心设防，时时争宠寻欢，已由单纯的少女成为一个蛇蝎心肠的少妇，与女婿陈经济偷情，杀死竞争对手，用过度的饥渴毁掉西门庆，不得不说她已满手罪恶。</p>
<p>人人都想活得光鲜亮丽，谁都不想平庸的过这一生，证明自己存在并没有错，但是要讲究方式方法。我们能做的是用自己辛勤的双手，智慧的大脑去创造自己殷切期盼的幸福生活，用不懈的奋斗去书写自己的无悔青春。用不屈不挠的意志去实现自己的小小梦想。而企图通过不劳而获、出卖自己肉体与灵魂去拥有财富、名望、地位，那么这种人终究被人所不齿，所拥有的一切最终会如过眼云烟渐渐远去，被时间的铁蹄疯狂践踏后，留下的恐怕只有破裂肮脏的躯壳和茶余饭后的笑谈。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[潘金莲：用手段证明自己存在的女强人（上）]]></title>
      <url>http://yoursite.com/2015/09/21/%E6%BD%98%E9%87%91%E8%8E%B2%EF%BC%9A%E7%94%A8%E6%89%8B%E6%AE%B5%E8%AF%81%E6%98%8E%E8%87%AA%E5%B7%B1%E5%AD%98%E5%9C%A8%E7%9A%84%E5%A5%B3%E5%BC%BA%E4%BA%BA%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>说起潘金莲，想必您诸位都不陌生，<a href="http://www.chenyalun.cn/%e8%a5%bf%e9%97%a8%e5%ba%86%ef%bc%9a%e5%8d%a0%e6%9c%89%e6%ac%b2%e8%86%a8%e8%83%80%e7%9a%84%e6%82%b2%e5%82%ac%e8%a1%b0%e7%94%b7.html" target="_blank" rel="external">西门庆</a>与潘金莲的佳话一直流传到现在，表面上看潘金莲是一个不守妇道，情欲旺盛，心如蛇蝎的荡妇，可实际上，潘金莲还是个女强人，一个始终费尽心机用尽手段证明自己存在的女强人。</p>
<p>潘金莲是个裁缝的女儿，七岁上学，九岁就被卖到王招宣府里，而府中女主人便是日后与西门庆勾搭的林太太。所以，潘金莲慢慢地学会了“描眉画眼，傅粉施朱”。到二十几岁时，加上天生的身材样貌优势，可以想象，潘姑娘定是个媚态外露情致风骚美丽妖艳的大美人了。后又被卖入张大户家做使女，被张大户“收用”，因其妻子严厉，张大户不要一分钱，把她嫁给了武大郎。而武大郎呢，穷的叮当响，一米五几的个头，上身短，下身长，关键长的还不咋地，性格还有些懦弱，虽然说勤勤恳恳，热爱劳动，可人家潘金莲怎么会看得上这“三寸丁谷树皮”呢。可想而知，美貌艳丽的潘姑娘嫁到武大郎家，心理落差非常大。二十出头的姑娘谁不爱翩翩君子，谁不想嫁给有钱人家，好谋个好未来。命运的不公让她内心充满了怨恨，她要证明自己的存在，她要改变！</p>
<p>机会只垂青那些时刻准备着的人，她不甘寂寞，趁着武大郎出去卖炊饼，自己打扮的光鲜亮丽，招蜂引蝶，眉目传情，借此打发无聊的日子。精神很空虚啊，那时候也没个手机，还能斗个地主，玩个陌陌什么的，这时一个人出现了，谁呢？武松。这武松呢，一米九的个头，长的英姿飒爽，风度翩翩，还会武术，瞅瞅，这条件再和武大郎一比，潘金莲肯定心神荡漾，想入非非了。被燃起心中欲火后，潘便运用女人技俩试探，甚至表白，可人家武松是个好汉，根本不吃这一套。所以可想而知，潘金莲内心是多么失落、无助。</p>
<p>到这里毋庸置疑，潘金莲与武大郎的婚姻已经出现严重问题了，如果此时被拒绝的潘金莲及时醒悟，武大郎稍微机灵点，看出媳妇的异常，那说不定就不会有后面的事了。但是，潘金莲不会“醒悟”，因为她不甘心，她貌美，会弹琵琶，做得一手好菜，还会女红，不甘心这样的自己一生就这样平平淡淡地和一个懦弱丑陋卖炊饼的凑合过了。所以首先，他们的婚姻是不平等的，两人没有共同的兴趣爱好，再者，二人不是“门当户对”，一直我是很相信真爱的，但是长辈的“门当户对”也是有一定道理的，两人地位不等，阶级立场不同，婚姻肯定要破败。放到潘金莲这，一个貌美如花，一个丑陋矮小，再加上潘金莲的心高气傲，她又怎么会满足当前的生活。所以，她有梦想，她想着有朝一日能有钱，有房，有车，有英俊潇洒的男人。</p>
<p>梦想还是要有的，万一实现了呢，马云说的真对，在西门庆这，潘金莲的梦想实现了。但请注意，西门庆只是她实现所谓“梦想”的天梯，他对西门庆没有过真感情，这个咱们一会再说。</p>
<p>西门大官人是个好色之徒，他与潘金莲一拍即合，关于西门庆追求潘金莲的整个过程，也是很经典的，很有借鉴意义。在经过一番周折后，潘金莲终于如愿以偿，成为西门家族荣耀的一员。那到西门府中面对好色成性的西门大官人，面对日后西门庆五六个老婆、十几个情人她又如何证明自己的存在呢？请看【<a href="http://www.chenyalun.cn/潘金莲：用手段证明自己存在的女强人（下）.html" target="_blank" rel="external">潘金莲：用手段证明自己存在的女强人（下）</a>】</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[西门庆：占有欲膨胀的悲催衰男]]></title>
      <url>http://yoursite.com/2015/09/20/%E8%A5%BF%E9%97%A8%E5%BA%86%EF%BC%9A%E5%8D%A0%E6%9C%89%E6%AC%B2%E8%86%A8%E8%83%80%E7%9A%84%E6%82%B2%E5%82%AC%E8%A1%B0%E7%94%B7/</url>
      <content type="html"><![CDATA[<p>相信不用多说，西门庆这个人物大家都了解的比较清楚，贪财好色，勾引良家妇女，好吧，我错了，潘金莲不是良家。可是，西门庆并不简单，他精明，好学，会武术，会讨好女人，还会“来事”，社交能力还强，如果他走上正道，世界将再次出现一个superhero。</p>
<p>西门庆原先就是个开药铺的，但是通过婚姻来谋取大笔的嫁资完成了资本的原始积累。潘金莲这一出您各位都很熟悉，在王婆的悉心教导下，凭借“潘驴邓小闲”的理论指导，加上缜密的计划，一步一步完成了对一个女人的征服。可以说，王婆把原理与方法论掌握的非常熟练，不仅出色地完成了西门大官人交代的任务，还从中赚了一大笔银子，尤其是她那五字真言，还是小伙子们追求女性不得不掌握的技巧，被后世称为典范。</p>
<p><span class="ask-title ">“资本作为一种自行增殖的价值，不仅在生产过程内运动，而且也在流通过程内运动”，《资本论》上的这话是啥意思，简单的说就是钱生钱的道理，马克思懂的东西，人家西门大官人也懂，他很善于扩大再生产。比</span>如他与乔大户合开的服装店，注册资本才一千两银子，后来他靠贩盐赚的钱又进了一万多两银子的货物，服装店开张没多久就净赚了六千两银子。完事人家还不满足，他又很开心地拿着纯利从湖州和松江进货。就这样本利越滚越大。到西门庆临死时，服装店的估值已经达到“五万两银子的本钱”。当然，也不能只开服装店，人家还放高利贷，开当铺，走标船，进行多样化经营，打通本地市场，搞垂直领域营销，最后（官商合作）行业垄断。所以不得不佩服西门庆的经商头脑。</p>
<p>西门庆孜孜不倦的还有女人。吴月娘、李娇儿、孟玉楼、潘金莲、孙雪娥、李瓶儿等都是他的媳妇，不要嫉妒的说人家重婚罪。除去有名份的女性妻妾，还有15个情人（包括一枚男性书童，看看，人家会找刺激吧）。他把经济头脑运用到女人身上。比如说，去“私人会所”包养一个情人每月500两银子（姑且这么说），一共花500两，但是娶到家里，酒宴、新房、红包、再加上娶回家后吃住、零花钱都要你管，无疑增加家庭负担（西门庆不缺钱，但也不傻），而两种方法对他本人的效果都是一样的，所以，不娶。那么无论你说什么好话，怎么央求都没用，除非你能带来好处，比如你是某个官员的亲戚，或者有很多嫁妆（比如李瓶儿），否则别说名分。这一大堆女人甚至还有男性书童只是满足他个人的性欲，所以不用幻想他会产生什么爱情，但是女人就不一样了，他的女人们各有各的性格，咱们抽空一 一道来。</p>
<p>西门庆毕生追求的是金钱（钱可以生出权力）和女人，无法填满的也是金钱欲与性欲，在金钱上想方设法、绞尽脑汁，只要能挣到钱，什么事都干的出来，在女人上，女人成了他的泄欲工具，性成了他唯一的消遣方式，随时随地都能够和女人们嬉戏一番，而对性的渴望已经让他足够变态，最后的结局还是挺符合他心意 的———吃春药亢奋死在潘金莲床上。对金钱，对权力，对女人，这些占有欲的无限膨胀，最终导致了他的毁灭。</p>
<p>人类的欲望是主观存在的、无穷无尽的，而人本身确是客观的、有时间空间限制的，用有限的载体承载无限的欲望，最终的结果肯定是载体的毁灭。我们要的不是禁欲主义，更不是纵欲，而是有节制的，有条件的释放自己的欲望，只有这样，生命才不会轰然倒塌，我们才能享受到真正的快乐。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[生成带参数的二维码]]></title>
      <url>http://yoursite.com/2015/09/19/%E7%94%9F%E6%88%90%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>在实际应用操作中，我们可能需要进行推广分析，因此微信公众平台有提供生成不同参数二维码的接口。简单来说，这些二维码带有场景值，是进行账号绑定用，还是用来查看用户来源，你开心就好。</p>
<p>这些二维码有两种类型，临时的和永久的，从字面上看，临时的肯定是有过期时间啦，最大是1800秒，但是生成的数量大大的多，另一种是永久的，木有过期限制，不过生成的数量少一点，大约是10000以内吧。两者用途很明显，前者是用于账号绑定，后者用于用户来源统计。不难理解，比如我们每次扫二维码登录的测试公众号，都是有期限的，二维码窗口弹出来，如果很长时间不扫描登录，就会过期；而扫描某个二维码进行关注什么的，一般是没有期限限制的。获取带参数的二维码需要两步，首先创建ticket，然后拿着ticket去换二维码。好，接下来就开始探讨。</p>
<h3 id="1，创建二维码ticket"><a href="#1，创建二维码ticket" class="headerlink" title="1，创建二维码ticket"></a>1，创建二维码ticket</h3><p>请求地址：<a href="https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=TOKEN，POST的数据格式是json，临时二维码格式和永久二维码格式分别如下所示：" target="_blank" rel="external">https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=TOKEN，POST的数据格式是json，临时二维码格式和永久二维码格式分别如下所示：</a></p>
<pre class="lang:default decode:true">{"expire_seconds": 1800, "action_name": "QR_SCENE", "action_info": {"scene": 
{"scene_id": 123}}}</pre>
<pre class="lang:default decode:true ">{"action_name": "QR_LIMIT_SCENE", "action_info": {"scene": {"scene_id": 123}}}</pre>
参数说明：expire_seconds：二维码的有效时间，以秒为单位，最大1800，action_name:二维码类型，QR_SCENE是临时二维码，QR_LIMIT_SCENE是永久二维码；action_info：二维码详细信息；scene_id：场景值ID，临时二维码时为32位非0整型，永久二维码时最大值为100000（目前参数只支持1--100000）正确的Json返回结果
<div class="reader-pic-layer">
<pre class="lang:default decode:true ">{"ticket":"gQH47joAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxL2taZ2Z3TVRtNzJXV1Brb3ZhYmJJAAIEmm3sUw==",
"expire_seconds":160,"url":"http://weixin.qq.com/q/kZgfwMTm7abbI"}</pre>
ticket:不多说，就是凭借这个换二维码的；expire_seconds：二维码的有效时间，最大1800；url：二维码解析后的地址；错误的Json返回示例：
<pre class="lang:default decode:true ">{"errcode":40013,"errmsg":"invalid appid"}</pre>

<h3 id="具体的代码如下："><a href="#具体的代码如下：" class="headerlink" title="具体的代码如下："></a>具体的代码如下：</h3><p><pre class="lang:default decode:true">&lt;?php<br>$access_token = “FKv__zXmH4uKAgPLuakGcX6Lg21IWrjxKxJ1lHHnXeziNAA3LgJAibWYuEhWXcAgEeVJGdv6U2it8UXbSIhNOzPUqwncsz–69Ck3z7nzyY”;<br>//记得替换自己的access_token<br>$url=”<a href="https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=&quot;.$access_token" target="_blank" rel="external">https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=&quot;.$access_token</a>;</pre></p>
<p>$json_1= ‘{“expire_seconds”: 1800, “action_name”: “QR_SCENE”, “action_info”: {“scene”: {“scene_id”: 123}}}’;//临时二维码</p>
<p>$json_2 = ‘{“action_name”: “QR_LIMIT_SCENE”, “action_info”: {“scene”: {“scene_id”: 123}}}’;//永久二维码</p>
<p>$result = func_ticket($url,$json_1);</p>
<p>var_dump($result);<br>echo “&lt;br/&gt;”;<br>$json_result=json_decode($result,true);<br>echo “&lt;br/&gt;”;<br>echo “陈亚伦博客提醒您ticket的值：”.$json_result[‘ticket’];</p>
<p>function func_ticket($url, $data = null){<br>    $curl = curl_init();<br>    curl_setopt($curl, CURLOPT_URL, $url);<br>    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);<br>    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);<br>    curl_setopt($curl, CURLOPT_POST, 1);<br>    curl_setopt($curl, CURLOPT_POSTFIELDS, $data);<br>    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);<br>    $out = curl_exec($curl);<br>    curl_close($curl);<br>    return $out;<br>}<br>?&gt;<br>简单说下代码的意思吧。</p>
<p>第2行：你需要把access_token改成自己的，关于access_token的问题，我们已经探讨过了，如果还不太了解，或者不知道怎么得到，请查看文章：<a href="http://www.chenyalun.cn/获得access_token的三种方法总结.html" target="_blank" rel="external">获得access_token的三种方法总结</a></p>
<p>第6行和第8行：分别是生成临时二维码和永久二维码</p>
<p>第10行：我这里的代码是生成临时二维码，如果你要生成永久二维码，请将第10行改成</p>
<p><pre class="start-line:10 lang:default decode:true">$result = func_ticket($url,$json_2);</pre><br>第16行：打印我们期盼已久的ticket,效果如图所示：</p>
<p><img src="http://source.chenyalun.cn/images/201510/5100601.jpg" alt=""></p>
<h3 id="2，通过Ticket换取二维码"><a href="#2，通过Ticket换取二维码" class="headerlink" title="2，通过Ticket换取二维码"></a>2，通过Ticket换取二维码</h3><p>获取二维码ticket后，开发者就可以换取二维码图片了，这个接口使用GET请求方式。</p>
<p>HTTP请求地址：<a href="https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=$ticket，如果ticket正确，http返回200，是一张图片，如果错误，那肯定就是404喽。" target="_blank" rel="external">https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=$ticket，如果ticket正确，http返回200，是一张图片，如果错误，那肯定就是404喽。</a></p>
<p>比如我获取到的临时二维码ticket：</p>
<p>gQHf7zoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL29Uam9tU0htN1BXVkh1SWVxaGJBAAIEpWYSVgMECAcAAA==</p>
<p>很简单，把上面的ticket复制一下，然后替换<a href="https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=XXXX中的XXXX,接着在浏览器中打开就可以巧妙的看到二维码呦。" target="_blank" rel="external">https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=XXXX中的XXXX,接着在浏览器中打开就可以巧妙的看到二维码呦。</a></p>
<p><img src="http://source.chenyalun.cn/images/201510/5100603.jpg" alt=""></p>
<p>上图为临时二维码</p>
<p><img src="http://source.chenyalun.cn/images/201510/5100606.jpg" alt=""></p>
<p>上图为永久二维码</p>
<p></p></div><br>我把测试的结果和大家分享一下：点击<a href="http://www.chenyalun.cn/go/?url=https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQHf7zoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL29Uam9tU0htN1BXVkh1SWVxaGJBAAIEpWYSVgMECAcAAA==" target="_blank" rel="external">这里</a>查看临时二维码；点击<a href="http://www.chenyalun.cn/go/?url=https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQEz8DoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL0xUaWc5bXJtMmZXZ3RHd000aFRBAAIEjGsSVgMEAAAAAA==" target="_blank" rel="external">这里</a>查看永久二维码；<p></p>
<div class="reader-pic-layer">

<p>请注意，因为我用的是微信测试账号，有1年的使用时间限制，时间到就会被收回啦，（但是它却拥有微信所有的接口权限，未认证个人订阅号貌似没有这个换取二维码的api权限，如果你硬要用自己的木有认证的订阅号，将会返回48001错误），所以某些年后你再打开的时候，两个链接可能会失效，表埋怨我哈。。(●’◡’●)</p>
<h3 id="3，懒人的方法"><a href="#3，懒人的方法" class="headerlink" title="3，懒人的方法"></a>3，懒人的方法</h3><p>上面我们试着利用编写代码的方式首先获取ticket，接着捧着ticket向人家换我们梦寐以求的二维码，有没有更加简单粗暴的方法呢。宝贝儿，这个可以有滴。点击这里打开官网测试工具，<a href="http://www.chenyalun.cn/go/?url=https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&amp;type=%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81&amp;form=%E8%8E%B7%E5%8F%96access_token%E6%8E%A5%E5%8F%A3%20/token" target="_blank" rel="external">这里这里</a></p>
<p>1，接口类型选择：推广支持</p>
<p>2，输入你的access_token</p>
<p>3，输入你的body内容，具体代码如下：</p>
<p><pre class="lang:default decode:true ">{<br>    “expire_seconds”: 1800,<br>    “action_name”: “QR_SCENE”,<br>    “action_info”: {<br>        “scene”: {<br>            “scene_id”: 123<br>        }<br>    }<br>}</pre><br>上面这个是临时二维码的body，其实就是本文最开始最顶端所给出的代码</p>
<p><pre class="lang:default decode:true">$json_1= ‘{“expire_seconds”: 1800, “action_name”: “QR_SCENE”, “action_info”: {“scene”: {“scene_id”: 123}}}’;//临时二维码</pre><br></p></div><br>看看，是不是花括号里面的内容。好啦，说到这里，相信我就不需要再赘述永久二维码的body了。嗯，就是这样。<p></p>
<p><img src="http://source.chenyalun.cn/images/201510/5100605.jpg" alt=""></p>
<p>4，点击 检查问题，就可以拿到输出来的ticket，ticket都到手了，二维码还远吗？</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[赵光义：惶恐猥琐中折射屌丝心态]]></title>
      <url>http://yoursite.com/2015/09/19/%E8%B5%B5%E5%85%89%E4%B9%89%EF%BC%9A%E6%83%B6%E6%81%90%E7%8C%A5%E7%90%90%E4%B8%AD%E6%8A%98%E5%B0%84%E5%B1%8C%E4%B8%9D%E5%BF%83%E6%80%81/</url>
      <content type="html"><![CDATA[<p>看到这个标题，相信不少同学已经开始骂我了，人家赵光义虽然不是自小皇子出身，但起码人家当上皇帝了呀，完成祖国统一大业，基本上把大宋朝治理的还不错，怎么好说人家猥琐还屌丝呢？</p>
<p>说到这，不得不提下赵光义著名的箭伤，在战场上中箭之后，留下病根了，到最后这病根还是要了他的命。关键是在中箭之后，他的心理发生了巨大的变化。最早的时候，他老哥赵匡胤没当上皇帝时，可以说光义对哥哥忠心耿耿，两人感情也是极好的，赵匡胤能打下江山绝对有赵光义的功劳。但是，按理说，皇帝死了应该传位给儿子，可赵匡胤却“传位”给弟弟，不要不信，就是这么神奇。这肯定让人浮想联翩了，就留下历史谜团“烛光斧影”。</p>
<p>在皇室家族中，不可否认，很多人是想当皇帝的。那赵光义是不是权欲熏心，杀了哥哥坐上皇位呢，可能性很大。但是还有一点，赵光义心理有问题了，这可能比权欲更能驱使他做出伤天害理的事。你想啊，每天忍受箭伤顽疾的折磨（御医们大都是吃干饭的，所以不要寄希望于他们），看不到阳光，享受不了健康的幸福，心理负担越发严重，整天想着灰暗的事，想着说不定哪天就一命呜呼了，怎么办，越想越焦急，越着急就自私自利，可不就做出很多猥琐的事。把哥哥搞定之后，自己堂而皇之的继承了皇位，对哥哥家孩子的所作所为，更体现他的猥琐阴险。</p>
<p>赵匡胤有四个儿子，依次是赵德秀，赵德昭，赵德林，赵德芳。德秀，德林幼年夭亡。先说德昭，因为将士们论功行赏的事，德昭向皇帝觐见，皇帝觉得战败了，很不爽，就不想封赏什么的，而文武大臣包括德昭想按法律来，应该论功行赏，然后皇上很不开心，来一句“现在还轮不到你丫做主，等你自己当上皇帝再赏也不晚”。然后德昭没想到自己成了抢夺皇位的嫌疑人，越想越害怕，想着与其日后扣上谋反的罪名，不如现在KO自己，最后拿一把水果刀把自己解决了。</p>
<p>话说，赵光义当初是按着他老娘的旨意（这是他自己说的，谁知道他老娘有没有这个旨意呢），因为哥哥的孩子还小，自己先当上皇帝，巩固朝廷统治，日后还传位给德昭，德芳的。可是现在，明显是反悔了，一步一步铲除异己，想传位给自家孩子。再说德芳，死法更神奇，被一场天衣无缝的阴谋秒掉的，虽说是喝毒酒身亡，可当时，包括皇帝赵光义，光义他孩子们，光义他嫂子（赵匡胤媳妇）们，诸位大臣在场，明明德芳喝毒酒身亡，却说成酒中木有毒，乐极生悲，笑死的（毒酒喝下去，产生狂笑的症状，最后挂掉）。</p>
<p>看看，硬是把哥哥家的孩子一个一个给铲除掉。</p>
<p>赵光义怕死，因为整天被箭伤折磨，心理愈发压抑，也就愈发变态猥琐了。李煜，没有错，就是写“恰似一江春水向东流”的李煜被光义赐毒酒灭掉的，这不是关键。关键是，李煜的媳妇，容貌美丽、神彩端静小周后，很漂亮滴，你懂的。赵光义硬是“强幸”了人家，场面“蔚为大观”。人在做，天在看，画工们把这现场给画下来了，高清无码的<a href="http://www.chenyalun.cn/go/?url=http://baike.baidu.com/view/1278848.htm" target="_blank" rel="external">熙陵幸小周后图</a>从此流芳百世。可见，赵光义也是个好色之徒。</p>
<p>赵光义远远没有他哥赵匡胤值得人尊敬，玩手腕，弄权术，这点他是最擅长的，我觉得他有一个不可忽视的优点就是他爱读书，每天都读，成年累月的读，玩着命的读书，“开卷有益”的典故就出自他，最后把一千多种古籍看完之后，起个名，就什么《太平御览》，名扬天下。每天不论政事多忙，都要抽空读书，这点值得人学习，值得人敬佩。</p>
<p>出身皇族，本就有许多迫不得已，而赵光义，在哥哥当上皇帝后因为种种原因就开始沦为屌丝，很穷，尤其在亲情方面，但是，他不是个昏君，因为他读很多书，会音乐，会下棋，会书法等等。无论是觊觎皇权，还是心理问题，他终究做了不少卑鄙的事，虽说他就很多成就，但就品德方面，他是个好色之徒，他弑兄篡位，他还铲除自己亲哥哥的孩子，就这点，我看不起他。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[回复用户消息]]></title>
      <url>http://yoursite.com/2015/09/18/%E5%9B%9E%E5%A4%8D%E7%94%A8%E6%88%B7%E6%B6%88%E6%81%AF/</url>
      <content type="html"><![CDATA[<p>当用户发送消息给公众号时，会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。那么现在我们就来分析下回复给用户的六种消息类型。依然按照原先接受普通消息的格式，分析其xml，进行相关参数解释，以及给出实例代码。</p>
<h3 id="1，文本消息"><a href="#1，文本消息" class="headerlink" title="1，文本消息"></a>1，文本消息</h3><p>依然是xml格式：</p>
<pre class="lang:default decode:true ">&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;
&lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;/Content&gt;
&lt;/xml&gt;</pre>
<table border="1" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>描述</th>
</tr>
<tr>
<td>ToUserName</td>
<td>是</td>
<td>接收方帐号（收到的OpenID）</td>
</tr>
<tr>
<td>FromUserName</td>
<td>是</td>
<td>**开发者**微信号</td>
</tr>
<tr>
<td>CreateTime</td>
<td>是</td>
<td>消息创建时间 （整型）</td>
</tr>
<tr>
<td>MsgType</td>
<td>是</td>
<td>text</td>
</tr>
<tr>
<td>Content</td>
<td>是</td>
<td>回复的消息内容（换行：在content中能够换行，微信客户端就支持换行显示）</td>
</tr>
</tbody>
</table>
<pre class="lang:default decode:true"> const REPLY_TYPE_TEXT = 'text';

/**
 * 生成向用户发送的文字信息
 * @param string $content
 * @return string xml字符串
 */
 public function outputText($content)
 {
 $textTpl = '&lt;xml&gt;
 &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;
 &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;
 &lt;CreateTime&gt;%s&lt;/CreateTime&gt;
 &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt;
 &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt; 
 &lt;/xml&gt;';

 $text = sprintf($textTpl, $this-&gt;_postData-&gt;FromUserName, $this-&gt;_postData-&gt;ToUserName, time(), self::REPLY_TYPE_TEXT, $content);
 return $text;
 }

</pre>

<h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://source.chenyalun.cn/5091809180002.png" alt=""></h3><h3 id="2，图片消息"><a href="#2，图片消息" class="headerlink" title="2，图片消息"></a>2，图片消息</h3><p><pre class="lang:default decode:true ">&lt;xml&gt;<br>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br>&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;<br>&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;<br>&lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;<br>&lt;Image&gt;<br>&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;<br>&lt;/Image&gt;<br>&lt;/xml&gt;</pre></p>
<p><table border="1" width="640px" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>是否必须</th></p>
<p><th>说明</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td>是</td></p>
<p><td>接收方帐号（收到的OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>是</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>是</td></p>
<p><td>消息创建时间 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td>是</td></p>
<p><td>image</td><br></p>
<p><tr></tr></p>
<p><td>MediaId</td></p>
<p><td>是</td></p>
<p><td>通过素材管理接口上传多媒体文件，得到的id。</td><br><br><br></p>
<p><pre class="lang:default decode:true">const REPLY_TYPE_IMAGE=’image’;<br>/**</pre></p>
<pre><code> * 生成向用户发送的图片信息
 * @param string $media_id
 * @return string xml字符串
 */
public function outputImage($media_id)
{
    $textTpl = &apos;&amp;lt;xml&amp;gt;
            &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
            &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
            &amp;lt;CreateTime&amp;gt;%s&amp;lt;/CreateTime&amp;gt;
            &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/MsgType&amp;gt;
            &amp;lt;Image&amp;gt;
                &amp;lt;MediaId&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/MediaId&amp;gt;
            &amp;lt;/Image&amp;gt;
        &amp;lt;/xml&amp;gt;&apos;;

    $text = sprintf($textTpl, $this-&amp;gt;_postData-&amp;gt;FromUserName, $this-&amp;gt;_postData-&amp;gt;ToUserName, time(), self::REPLY_TYPE_VOICE, $media_id);
    return $text;
}
</code></pre><p><br>注意：图片，语音，视频以及音乐缩略图的媒体ID（MediaID）是自己上传之后获取的，微信服务器只保存3天，所以你在测试时请自行上传。上传方法：把图片直接发送到测试微信公众号就可以得到媒体ID了，像视频，语音之类以此类推，想要查看媒体ID，可以直接把【<a href="http://www.chenyalun.cn/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%BB%A3%E7%A0%81.html" target="_blank" rel="external">微信公众账号接收消息类型判断代码</a>】这篇文章中的代码文件配置成微信接口即可。</p>
<h3 id="3，语音消息"><a href="#3，语音消息" class="headerlink" title="3，语音消息"></a>3，语音消息</h3><p><pre class="lang:default decode:true ">&lt;xml&gt;<br>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br>&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;<br>&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;<br>&lt;MsgType&gt;&lt;![CDATA[voice]]&gt;&lt;/MsgType&gt;<br>&lt;Voice&gt;<br>&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;<br>&lt;/Voice&gt;<br>&lt;/xml&gt;</pre></p>
<p><table border="1" width="640px" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>是否必须</th></p>
<p><th>说明</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td>是</td></p>
<p><td>接收方帐号（收到的OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>是</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>是</td></p>
<p><td>消息创建时间戳 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td>是</td></p>
<p><td>语音，voice</td><br></p>
<p><tr></tr></p>
<p><td>MediaId</td></p>
<p><td>是</td></p>
<p><td>通过素材管理接口上传多媒体文件，得到的id</td><br><br><br></p>
<p><pre class="lang:default decode:true"> const REPLY_TYPE_VOICE = ‘voice’;</pre></p>
<p>/**</p>
<pre><code> * 生成向用户发送的语音信息
 * @param string $content
 * @return string xml字符串
 */
public function outputVoice($media_id)
{
    $textTpl = &apos;&amp;lt;xml&amp;gt;
            &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
            &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
            &amp;lt;CreateTime&amp;gt;%s&amp;lt;/CreateTime&amp;gt;
            &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/MsgType&amp;gt;
            &amp;lt;Voice&amp;gt;
                &amp;lt;MediaId&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/MediaId&amp;gt;
            &amp;lt;/Voice&amp;gt;
        &amp;lt;/xml&amp;gt;&apos;;

    $text = sprintf($textTpl, $this-&amp;gt;_postData-&amp;gt;FromUserName, $this-&amp;gt;_postData-&amp;gt;ToUserName, time(), self::REPLY_TYPE_VOICE, $media_id);
    return $text;
}
</code></pre><p><br>4，视频消息</p>
<p><pre class="lang:default decode:true">&lt;xml&gt;<br>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br>&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;<br>&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;<br>&lt;MsgType&gt;&lt;!<br>[CDATA]&gt;<br>&lt;/MsgType&gt;<br>&lt;Video&gt;<br> &lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;<br>&lt;Title&gt;&lt;![CDATA[title]]&gt;&lt;/Title&gt;<br> &lt;Description&gt;&lt;![CDATA[description]]&gt;&lt;/Description&gt; &lt;/Video&gt; &lt;/xml&gt;</pre><br>&nbsp;</p>
<p>&nbsp;</p>
<p><table border="1" width="640px" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>是否必须</th></p>
<p><th>说明</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td>是</td></p>
<p><td>接收方帐号（收到的OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>是</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>是</td></p>
<p><td>消息创建时间 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td>是</td></p>
<p><td>video</td><br></p>
<p><tr></tr></p>
<p><td>MediaId</td></p>
<p><td>是</td></p>
<p><td>通过素材管理接口上传多媒体文件，得到的id</td><br></p>
<p><tr></tr></p>
<p><td>Title</td></p>
<p><td>否</td></p>
<p><td>视频消息的标题</td><br></p>
<p><tr></tr></p>
<p><td>Description</td></p>
<p><td>否</td></p>
<p><td>视频消息的描述</td><br><br><br></p>
<p><pre class="lang:default decode:true"> const REPLY_TYPE_VIDEO = ‘video’;</pre></p>
<p>/**</p>
<pre><code> * 生成向用户发送的视频信息
 * @param string $content
 * @return string xml字符串
 */
public function outputVideo($videopost)
{
    $textTpl = &apos;&amp;lt;xml&amp;gt;
            &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
            &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
            &amp;lt;CreateTime&amp;gt;%s&amp;lt;/CreateTime&amp;gt;
            &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/MsgType&amp;gt;
            &amp;lt;Video&amp;gt;
                &amp;lt;MediaId&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/MediaId&amp;gt;
                &amp;lt;Title&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/Title&amp;gt;
                &amp;lt;Description&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/Description&amp;gt;
            &amp;lt;/Video&amp;gt; 
        &amp;lt;/xml&amp;gt;&apos;;

    $text = sprintf($textTpl, $this-&amp;gt;_postData-&amp;gt;FromUserName, $this-&amp;gt;_postData-&amp;gt;ToUserName, time(), self::REPLY_TYPE_VIDEO, $videopost[&apos;media_id&apos;], $videopost[&apos;title&apos;], $videopost[&apos;description&apos;]);
    return $text;
}
</code></pre><p><br>&nbsp;</p>
<h3 id="5，音乐消息"><a href="#5，音乐消息" class="headerlink" title="5，音乐消息"></a>5，音乐消息</h3><p><pre class="lang:default decode:true ">&lt;xml&gt;<br>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br>&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;<br>&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;<br>&lt;MsgType&gt;<br>&lt;![CDATA[music]]&gt;&lt;/MsgType&gt;<br>&lt;Music&gt;<br>&lt;Title&gt;&lt;![CDATA[TITLE]]&gt;&lt;/Title&gt;<br>&lt;Description&gt;&lt;![CDATA[DESCRIPTION]]&gt;&lt;/Description&gt;<br>&lt;MusicUrl&gt;&lt;![CDATA[MUSIC_Url]]&gt;&lt;/MusicUrl&gt;<br>&lt;HQMusicUrl&gt;&lt;![CDATA[HQ_MUSIC_Url]]&gt;&lt;/HQMusicUrl&gt;<br>&lt;ThumbMediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/ThumbMediaId&gt;<br>&lt;/Music&gt;<br>&lt;/xml&gt;</pre></p>
<p><table border="1" width="640px" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>是否必须</th></p>
<p><th>说明</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td>是</td></p>
<p><td>接收方帐号（收到的OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>是</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>是</td></p>
<p><td>消息创建时间 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td>是</td></p>
<p><td>music</td><br></p>
<p><tr></tr></p>
<p><td>Title</td></p>
<p><td>否</td></p>
<p><td>音乐标题</td><br></p>
<p><tr></tr></p>
<p><td>Description</td></p>
<p><td>否</td></p>
<p><td>音乐描述</td><br></p>
<p><tr></tr></p>
<p><td>MusicURL</td></p>
<p><td>否</td></p>
<p><td>音乐链接</td><br></p>
<p><tr></tr></p>
<p><td>HQMusicUrl</td></p>
<p><td>否</td></p>
<p><td>高质量音乐链接，WIFI环境优先使用该链接播放音乐</td><br></p>
<p><tr></tr></p>
<p><td>ThumbMediaId</td></p>
<p><td>否</td></p>
<p><td>缩略图的媒体id，通过素材管理接口上传多媒体文件，得到的id</td><br><br><br></p>
<p><pre class="lang:default decode:true ">const REPLY_TYPE_MUSIC=’music’;<br> /**</pre></p>
<pre><code> * 生成向用户发送的音乐信息
 * @param type $musicpost
 * @return type
 * @throws Exception
 */
public function outputMusic($musicpost){
    $textTpl = &apos;&amp;lt;xml&amp;gt;
        &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
        &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
        &amp;lt;CreateTime&amp;gt;%s&amp;lt;/CreateTime&amp;gt;
        &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/MsgType&amp;gt; 
        &amp;lt;Music&amp;gt;%s&amp;lt;/Music&amp;gt;
    &amp;lt;/xml&amp;gt;&apos;;

    $musicTpl = &apos;
        &amp;lt;Title&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/Title&amp;gt;
        &amp;lt;Description&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/Description&amp;gt;
        &amp;lt;MusicUrl&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/MusicUrl&amp;gt;
        &amp;lt;HQMusicUrl&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/HQMusicUrl&amp;gt;
        &apos;;
    $music = &apos;&apos;;        
    if (is_array($musicpost)){
        $music .= sprintf($musicTpl, $musicpost[&apos;title&apos;], $musicpost[&apos;description&apos;], $musicpost[&apos;musicurl&apos;], $musicpost[&apos;hdmusicurl&apos;]);
    }else{
        throw new Exception(&apos;$posts 数据结构错误&apos;);
    }

    $text = sprintf($textTpl, $this-&amp;gt;_postData-&amp;gt;FromUserName, $this-&amp;gt;_postData-&amp;gt;ToUserName, time(), self::REPLY_TYPE_MUSIC, $music);
    return $text;

}
</code></pre><p><br><img src="http://source.chenyalun.cn/5091809180010.png" alt=""></p>
<h3 id="6，图文消息"><a href="#6，图文消息" class="headerlink" title="6，图文消息"></a>6，图文消息</h3><p><pre class="lang:default decode:true ">&lt;xml&gt;<br>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br>&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;<br>&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;<br>&lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt;<br>&lt;ArticleCount&gt;2&lt;/ArticleCount&gt;<br>&lt;Articles&gt;<br>&lt;item&gt;<br>&lt;Title&gt;&lt;![CDATA[title1]]&gt;&lt;/Title&gt;<br>&lt;Description&gt;&lt;![CDATA[description1]]&gt;&lt;/Description&gt;<br>&lt;PicUrl&gt;&lt;![CDATA[picurl]]&gt;&lt;/PicUrl&gt;<br>&lt;Url&gt;&lt;![CDATA[url]]&gt;&lt;/Url&gt;<br>&lt;/item&gt;<br>&lt;item&gt;<br>&lt;Title&gt;&lt;![CDATA[title]]&gt;&lt;/Title&gt;<br>&lt;Description&gt;&lt;![CDATA[description]]&gt;&lt;/Description&gt;<br>&lt;PicUrl&gt;&lt;![CDATA[picurl]]&gt;&lt;/PicUrl&gt;<br>&lt;Url&gt;&lt;![CDATA[url]]&gt;&lt;/Url&gt;<br>&lt;/item&gt;<br>&lt;/Articles&gt;<br>&lt;/xml&gt;</pre></p>
<p><table border="1" width="640px" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>是否必须</th></p>
<p><th>说明</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td>是</td></p>
<p><td>接收方帐号（收到的OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>是</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>是</td></p>
<p><td>消息创建时间 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td>是</td></p>
<p><td>news</td><br></p>
<p><tr></tr></p>
<p><td>ArticleCount</td></p>
<p><td>是</td></p>
<p><td>图文消息个数，限制为10条以内</td><br></p>
<p><tr></tr></p>
<p><td>Articles</td></p>
<p><td>是</td></p>
<p><td>多条图文消息信息，默认第一个item为大图,注意，如果图文数超过10，则将会无响应</td><br></p>
<p><tr></tr></p>
<p><td>Title</td></p>
<p><td>否</td></p>
<p><td>图文消息标题</td><br></p>
<p><tr></tr></p>
<p><td>Description</td></p>
<p><td>否</td></p>
<p><td>图文消息描述</td><br></p>
<p><tr></tr></p>
<p><td>PicUrl</td></p>
<p><td>否</td></p>
<p><td>图片链接，支持JPG、PNG格式，较好的效果为大图360<em>200，小图200</em>200</td><br></p>
<p><tr></tr></p>
<p><td>Url</td></p>
<p><td>否</td></p>
<p><td>点击图文消息跳转链接</td><br><br><br></p>
<p><pre class="lang:default decode:true ">const REPLY_TYPE_NEWS = ‘news’;<br>   /**</pre></p>
<pre><code> * 生成向用户发送的图文信息
 * @param arrry $posts 文章数组，每一个元素是一个文章数组，索引跟微信官方接口说明一致
 * @return string xml字符串
 */
public function outputNews($posts = array())
{
    $textTpl = &apos;&amp;lt;xml&amp;gt;
         &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
         &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
         &amp;lt;CreateTime&amp;gt;%s&amp;lt;/CreateTime&amp;gt;
         &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/MsgType&amp;gt;
         &amp;lt;ArticleCount&amp;gt;%d&amp;lt;/ArticleCount&amp;gt;
         &amp;lt;Articles&amp;gt;%s&amp;lt;/Articles&amp;gt;
     &amp;lt;/xml&amp;gt;&apos;;

    $itemTpl = &apos;&amp;lt;item&amp;gt;
         &amp;lt;Title&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/Title&amp;gt;
         &amp;lt;Discription&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/Discription&amp;gt;
         &amp;lt;PicUrl&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/PicUrl&amp;gt;
         &amp;lt;Url&amp;gt;&amp;lt;![CDATA[%s]]&amp;gt;&amp;lt;/Url&amp;gt;
     &amp;lt;/item&amp;gt;&apos;;

    $items = &apos;&apos;;
    foreach ((array)$posts as $p) {
        if (is_array($p))
            $items .= sprintf($itemTpl, $p[&apos;title&apos;], $p[&apos;discription&apos;], $p[&apos;picurl&apos;], $p[&apos;url&apos;]);
        else
            throw new Exception(&apos;$posts 数据结构错误&apos;);
    }

    $text = sprintf($textTpl, $this-&amp;gt;_postData-&amp;gt;FromUserName, $this-&amp;gt;_postData-&amp;gt;ToUserName, time(), self::REPLY_TYPE_NEWS,  count($posts), $items);
    return $text;
}
</code></pre><p><br><img src="http://source.chenyalun.cn/5091809180007.png" alt="">         <img src="http://source.chenyalun.cn/5091809180008.png" alt=""></p>
<p>以上就把回复用户消息类型介绍完了，文中的代码和实际中的有所差距，本着知识共享的原则，现在将实际的代码分享出来，可以查看文章：【<a href="http://www.chenyalun.cn/%e5%9b%9e%e5%a4%8d%e5%90%84%e7%a7%8d%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b%e4%bb%a3%e7%a0%81.html" target="_blank" rel="external">回复各种消息类型代码</a>】</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[回复各种消息类型代码]]></title>
      <url>http://yoursite.com/2015/09/18/%E5%9B%9E%E5%A4%8D%E5%90%84%E7%A7%8D%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>1，此处代码，经配置后，可以根据用户的关键词自动回复相关消息，经测试代码完全正确，本着知识共享的原则，如需要可自行复制，当然如果不想复制，请移步至百度云下载。<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1eQEZjI6" target="_blank" rel="external">点击这里下载</a>。</p>
<p>2，配置的时候请注意TOKEN是chenyalun，URL为代码文件所在地址。</p>
<p>3，由于服务器原因，一次配置不成功，请多试几次。</p>
<p>4，语音，图片，视频等消息类型因为涉及到媒体ID，而媒体ID在微信服务器的有效期只有3天，所以没有具体给出例子，如果需要，请自行上传语音，图片，视频到微信测试号获取媒体ID，方法不多说，在【<a href="http://www.chenyalun.cn/%e5%be%ae%e4%bf%a1%e5%85%ac%e4%bc%97%e8%b4%a6%e5%8f%b7%e6%8e%a5%e6%94%b6%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad%e4%bb%a3%e7%a0%81.html" target="_blank" rel="external">微信公众账号接收消息类型判断代码</a>】中可以下载获取媒体ID的代码。文中也有媒体ID的说明。</p>
<pre class="lang:default decode:true">&lt;?php
//
// 响应用户消息
// 微信公众账号响应给用户的不同消息类型
// www.chenyalun.cn 陈亚伦博客
//

define("TOKEN", "iloveyou");

$wechatObj = new wechatCallbackapiTest();
if (!isset($_GET['echostr'])) {
    $wechatObj-&gt;responseMsg();
}else{
    $wechatObj-&gt;valid();
}

class wechatCallbackapiTest
{
    public function valid()
    {
        $echoStr = $_GET["echostr"];
        if($this-&gt;checkSignature()){
            echo $echoStr;
            exit;
        }
    }

    private function checkSignature()
    {
        $signature = $_GET["signature"];
        $timestamp = $_GET["timestamp"];
        $nonce = $_GET["nonce"];
        $token = TOKEN;
        $tmpArr = array($token, $timestamp, $nonce);
        sort($tmpArr);
        $tmpStr = implode($tmpArr);
        $tmpStr = sha1($tmpStr);

        if($tmpStr == $signature){
            return true;
        }else{
            return false;
        }
    }

    public function responseMsg()
    {
        $postStr = $GLOBALS["HTTP_RAW_POST_DATA"];
        if (!empty($postStr)){
            $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);
            $RX_TYPE = trim($postObj-&gt;MsgType);

            //用户发送的消息类型判断
            switch ($RX_TYPE)
            {
                case "text":
                    $result = $this-&gt;receiveText($postObj);
                    break;
                case "image":
                    $result = $this-&gt;receiveImage($postObj);
                    break;
                case "voice":
                    $result = $this-&gt;receiveVoice($postObj);
                    break;
                case "video":
                    $result = $this-&gt;receiveVideo($postObj);
                    break;
                default:
                    $result = "unknow msg type: ".$RX_TYPE;
                    break;
            }
            echo $result;
        }else {
            echo "";
            exit;
        }
    }

    private function receiveText($object)
    {
        $keyword = trim($object-&gt;Content);

        if($keyword == "文本"){
            //回复文本消息
            $content = "代码改变世界，陈亚伦博客";
            $result = $this-&gt;transmitText($object, $content);
        }
        else if($keyword == "图文" || $keyword == "单图文"){
            //回复单图文消息
            $content = array();
            $content[] = array("Title"=&gt;"单图文标题", 
                                "Description"=&gt;"单图文内容", 
                                "PicUrl"=&gt;"http://source.chenyalun.cn/weixinceshi0918q.jpg", 
                                "Url" =&gt;"http://www.chenyalun.cn");
            $result = $this-&gt;transmitNews($object, $content);
        }
        else if($keyword == "多图文"){
            //回复多图文消息
            $content = array();
            $content[] = array("Title"=&gt;"多图文1标题", "Description"=&gt;"", "PicUrl"=&gt;"http://source.chenyalun.cn/weixinceshi0918w.jpg", "Url" =&gt;"http://www.chenyalun.cn");
            $content[] = array("Title"=&gt;"多图文2标题", "Description"=&gt;"", "PicUrl"=&gt;"http://source.chenyalun.cn/weixinceshi0918q.jpg", "Url" =&gt;"http://www.chenyalun.cn");
            $content[] = array("Title"=&gt;"多图文3标题", "Description"=&gt;"", "PicUrl"=&gt;"http://source.chenyalun.cn/weixinceshi0918e.jpg", "Url" =&gt;"http://www.chenyalun.cn");
            $result = $this-&gt;transmitNews($object, $content);

        }
        else if($keyword == "音乐"){
            //回复音乐消息
            $content = array("Title"=&gt;"年轮", 
            "Description"=&gt;"歌手：张碧晨", 
            "MusicUrl"=&gt;"http://www.soge8.com/1434330010/34bf3993bcb76a98df5f88244e2dfd05.mp3",
            "HQMusicUrl"=&gt;"http://www.soge8.com/1434330010/34bf3993bcb76a98df5f88244e2dfd05.mp3");
            $result = $this-&gt;transmitMusic($object, $content);
        }

        return $result;
    }

    private function receiveImage($object)
    {
        //回复图片消息 
        $content = array("MediaId"=&gt;$object-&gt;MediaId);
        $result = $this-&gt;transmitImage($object, $content);;
        return $result;
    }

    private function receiveVoice($object)
    {
        //回复语音消息 
        $content = array("MediaId"=&gt;$object-&gt;MediaId);
        $result = $this-&gt;transmitVoice($object, $content);;
        return $result;
    }

    private function receiveVideo($object)
    {
        //回复视频消息 
        $content = array("MediaId"=&gt;$object-&gt;MediaId, "ThumbMediaId"=&gt;$object-&gt;ThumbMediaId, "Title"=&gt;"", "Description"=&gt;"");
        $result = $this-&gt;transmitVideo($object, $content);;
        return $result;
    }  

    /*
     * 回复文本消息
     */
    private function transmitText($object, $content)
    {
        $textTpl = "&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;%s&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;
&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;
&lt;/xml&gt;";
        $result = sprintf($textTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), $content);
        return $result;
    }

    /*
     * 回复图片消息
     */
    private function transmitImage($object, $imageArray)
    {
        $itemTpl = "&lt;Image&gt;
    &lt;MediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/MediaId&gt;
&lt;/Image&gt;";

        $item_str = sprintf($itemTpl, $imageArray['MediaId']);

        $textTpl = "&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;%s&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;
$item_str
&lt;/xml&gt;";

        $result = sprintf($textTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());
        return $result;
    }

    /*
     * 回复语音消息
     */
    private function transmitVoice($object, $voiceArray)
    {
        $itemTpl = "&lt;Voice&gt;
    &lt;MediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/MediaId&gt;
&lt;/Voice&gt;";

        $item_str = sprintf($itemTpl, $voiceArray['MediaId']);

        $textTpl = "&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;%s&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[voice]]&gt;&lt;/MsgType&gt;
$item_str
&lt;/xml&gt;";

        $result = sprintf($textTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());
        return $result;
    }

    /*
     * 回复视频消息
     */
    private function transmitVideo($object, $videoArray)
    {
        $itemTpl = "&lt;Video&gt;
    &lt;MediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/MediaId&gt;
    &lt;ThumbMediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/ThumbMediaId&gt;
    &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt;
    &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt;
&lt;/Video&gt;";

        $item_str = sprintf($itemTpl, $videoArray['MediaId'], $videoArray['ThumbMediaId'], $videoArray['Title'], $videoArray['Description']);

        $textTpl = "&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;%s&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[video]]&gt;&lt;/MsgType&gt;
$item_str
&lt;/xml&gt;";

        $result = sprintf($textTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());
        return $result;
    }

    /*
     * 回复图文消息
     */
    private function transmitNews($object, $arr_item)
    {
        if(!is_array($arr_item))
            return;

        $itemTpl = "    &lt;item&gt;
        &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt;
        &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt;
        &lt;PicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/PicUrl&gt;
        &lt;Url&gt;&lt;![CDATA[%s]]&gt;&lt;/Url&gt;
    &lt;/item&gt;
";
        $item_str = "";
        foreach ($arr_item as $item)
            $item_str .= sprintf($itemTpl, $item['Title'], $item['Description'], $item['PicUrl'], $item['Url']);

        $newsTpl = "&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;%s&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt;
&lt;Content&gt;&lt;![CDATA[]]&gt;&lt;/Content&gt;
&lt;ArticleCount&gt;%s&lt;/ArticleCount&gt;
&lt;Articles&gt;
$item_str&lt;/Articles&gt;
&lt;/xml&gt;";

        $result = sprintf($newsTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), count($arr_item));
        return $result;
    }

    /*
     * 回复音乐消息
     */
    private function transmitMusic($object, $musicArray)
    {
        $itemTpl = "&lt;Music&gt;
    &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt;
    &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt;
    &lt;MusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/MusicUrl&gt;
    &lt;HQMusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/HQMusicUrl&gt;
&lt;/Music&gt;";

        $item_str = sprintf($itemTpl, $musicArray['Title'], $musicArray['Description'], $musicArray['MusicUrl'], $musicArray['HQMusicUrl']);

        $textTpl = "&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;%s&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[music]]&gt;&lt;/MsgType&gt;
$item_str
&lt;/xml&gt;";

        $result = sprintf($textTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());
        return $result;
    }
}
?&gt;</pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[接收事件消息]]></title>
      <url>http://yoursite.com/2015/09/17/%E6%8E%A5%E6%94%B6%E4%BA%8B%E4%BB%B6%E6%B6%88%E6%81%AF/</url>
      <content type="html"><![CDATA[<p>在前面的文章中，具体的链接、图片、文本等消息类型已经进行过分析，接下来分析下关注、取消关注，扫描二维码，上传地理位置以及点击菜单等事件消息类型。</p>
<h3 id="1，关注与取消"><a href="#1，关注与取消" class="headerlink" title="1，关注与取消"></a>1，关注与取消</h3><p>用户在关注与取消关注公众号时，微信会把这个事件推送到开发者填写的URL。方便开发者给用户下发欢迎消息或者做帐号的解绑。微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。</p>
<p>&nbsp;</p>
<p>关注事件的xml文件分析</p>
<pre class="lang:default decode:true">&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[FromUser]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt;
&lt;Event&gt;&lt;![CDATA[subscribe]]&gt;&lt;/Event&gt;
&lt;/xml&gt;</pre>
参数说明：
<table border="1" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
<tr>
<td>ToUserName</td>
<td>**开发者**微信号</td>
</tr>
<tr>
<td>FromUserName</td>
<td>发送方帐号（一个OpenID）</td>
</tr>
<tr>
<td>CreateTime</td>
<td>消息创建时间 （整型）</td>
</tr>
<tr>
<td>MsgType</td>
<td>消息类型，event</td>
</tr>
<tr>
<td>Event</td>
<td>事件类型，subscribe(订阅)、unsubscribe(取消订阅)</td>
</tr>
</tbody>
</table>
&nbsp;

isSubscribeEvent用于判断消息类型是否为订阅事件，具体代码如下：

&nbsp;
<pre class="lang:default decode:true">/**
     * 判断是否是订阅事件
     * @return boolean
     */
    public function isSubscribeEvent()
    {
       return $this-&gt;_postData-&gt;Event == self::EVENT_TYPE_SUBSCRIBE &amp;&amp;
           $this-&gt;_postData-&gt;EventKey == "";

    }</pre>
&nbsp;
<pre class="lang:default decode:true">/**   
   * 判断是否是退订事件   
   * @return boolean    
  */   
  public function isUnsubscribeEvent()  
   {      
   return $this-&gt;_postData-&gt;Event == self::EVENT_TYPE_UNSUBSCRIBE;  
   }</pre>

<h3 id="2，扫描二维码"><a href="#2，扫描二维码" class="headerlink" title="2，扫描二维码"></a>2，扫描二维码</h3><p>扫描二维码的类型分为已关注用户扫描和未关注用户扫描，二者略有不同，如果未关注公众号，则可以先关注公众号，关注后微信将带关注场景值（扫二维码关注、搜索微信号关注、搜索昵称关注等等）的事件推送给开发者用户硬是不关注的话，就不推送了，如果已经关注，那更好办。</p>
<p>isSubscribeScanEvent用于判断消息类型是否为未关注用户扫描二维码事件，它们的xml文件分析如下：</p>
<p>用户未关注时，进行关注后的事件推送，推送XML数据包示例：</p>
<pre class="lang:default decode:true">&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[FromUser]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt;
&lt;Event&gt;&lt;![CDATA[subscribe]]&gt;&lt;/Event&gt;
&lt;EventKey&gt;&lt;![CDATA[qrscene_123123]]&gt;&lt;/EventKey&gt;
&lt;Ticket&gt;&lt;![CDATA[TICKET]]&gt;&lt;/Ticket&gt;
&lt;/xml&gt;</pre>
参数说明：
<table border="1" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
<tr>
<td>ToUserName</td>
<td>**开发者**微信号</td>
</tr>
<tr>
<td>FromUserName</td>
<td>发送方帐号（一个OpenID）</td>
</tr>
<tr>
<td>CreateTime</td>
<td>消息创建时间 （整型）</td>
</tr>
<tr>
<td>MsgType</td>
<td>消息类型，event</td>
</tr>
<tr>
<td>Event</td>
<td>事件类型，subscribe</td>
</tr>
<tr>
<td>EventKey</td>
<td>事件KEY值，qrscene_为前缀，后面为二维码的参数值</td>
</tr>
<tr>
<td>Ticket</td>
<td>二维码的ticket，可用来换取二维码图片</td>
</tr>
</tbody>
</table>
用户已关注时的事件推送，推送XML数据包示例：
<pre class="lang:default decode:true ">&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[FromUser]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt;
&lt;Event&gt;&lt;![CDATA[SCAN]]&gt;&lt;/Event&gt;
&lt;EventKey&gt;&lt;![CDATA[SCENE_VALUE]]&gt;&lt;/EventKey&gt;
&lt;Ticket&gt;&lt;![CDATA[TICKET]]&gt;&lt;/Ticket&gt;
&lt;/xml&gt;</pre>
参数说明：
<table border="1" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
<tr>
<td>ToUserName</td>
<td>**开发者**微信号</td>
</tr>
<tr>
<td>FromUserName</td>
<td>发送方帐号（一个OpenID）</td>
</tr>
<tr>
<td>CreateTime</td>
<td>消息创建时间 （整型）</td>
</tr>
<tr>
<td>MsgType</td>
<td>消息类型，event</td>
</tr>
<tr>
<td>Event</td>
<td>事件类型，SCAN</td>
</tr>
<tr>
<td>EventKey</td>
<td>事件KEY值，是一个32位无符号整数，即创建二维码时的二维码scene_id</td>
</tr>
<tr>
<td>Ticket</td>
<td>二维码的ticket，可用来换取二维码图片</td>
</tr>
</tbody>
</table>

*   <pre class="lang:default decode:true">/**
     * 判断是否是未关注用户扫描二维码事件
     * @return boolean
     */
    public function isSubscribeScanEvent()
    {
         return $this-&gt;_postData-&gt;Event == self::EVENT_TYPE_SUBSCRIBE &amp;&amp;
               $this-&gt;_postData-&gt;EventKey != "";
    }</pre>
<pre class="lang:default decode:true">/**    
  * 判断是否是扫描二维码事件     
      * @return boolean    
  */   
  public function isScanEvent()  
   {        
 return $this-&gt;_postData-&gt;Event == self::EVENT_TYPE_SCAN;  
   }</pre>

<h3 id="3，上传地理位置事件"><a href="#3，上传地理位置事件" class="headerlink" title="3，上传地理位置事件"></a>3，上传地理位置事件</h3><p>用户同意上报地理位置后，每次进入公众号会话时，都会在进入时上报地理位置，或在进入会话后每5秒上报一次地理位置，公众号可以在公众平台网站中修改以上设置。上报地理位置时，微信会将上报地理位置事件推送到开发者填写的URL。</p>
<p>isLocaitonEvent用于判断消息类型是否是地理位置事件，具体xml数据包如下</p>
<pre class="lang:default decode:true ">&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt;
&lt;Event&gt;&lt;![CDATA[LOCATION]]&gt;&lt;/Event&gt;
&lt;Latitude&gt;23.137466&lt;/Latitude&gt;
&lt;Longitude&gt;113.352425&lt;/Longitude&gt;
&lt;Precision&gt;119.385040&lt;/Precision&gt;
&lt;/xml&gt;</pre>
参数说明：
<table border="1" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
<tr>
<td>ToUserName</td>
<td>**开发者**微信号</td>
</tr>
<tr>
<td>FromUserName</td>
<td>发送方帐号（一个OpenID）</td>
</tr>
<tr>
<td>CreateTime</td>
<td>消息创建时间 （整型）</td>
</tr>
<tr>
<td>MsgType</td>
<td>消息类型，event</td>
</tr>
<tr>
<td>Event</td>
<td>事件类型，LOCATION</td>
</tr>
<tr>
<td>Latitude</td>
<td>地理位置纬度</td>
</tr>
<tr>
<td>Longitude</td>
<td>地理位置经度</td>
</tr>
<tr>
<td>Precision</td>
<td>地理位置精度</td>
</tr>
</tbody>
</table>
&nbsp;

&nbsp;
<pre class="lang:default decode:true">/**
     * 判断是否是上传地理位置事件
     * @return boolean
     */
    public function isLocaitonEvent()
    {
        return $this-&gt;_postData-&gt;Event == self::EVENT_TYPE_LOCATION;
    }

</pre>

<h3 id="4，自定义菜单事件"><a href="#4，自定义菜单事件" class="headerlink" title="4，自定义菜单事件"></a>4，自定义菜单事件</h3><p>用户点击自定义菜单后，如果是Click类型，微信会把点击事件推送给开发者，如果是View型，或者点击菜单弹出子菜单，则不会上报。所以具体分为以下两种。</p>
<p><span id=".E7.82.B9.E5.87.BB.E8.8F.9C.E5.8D.95.E6.8B.89.E5.8F.96.E6.B6.88.E6.81.AF.E6.97.B6.E7.9A.84.E4.BA.8B.E4.BB.B6.E6.8E.A8.E9.80.81" class="mw-headline">点击菜单拉取消息时的事件推送</span></p>
<p><pre class="lang:default decode:true ">&lt;xml&gt;<br>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br>&lt;FromUserName&gt;&lt;![CDATA[FromUser]]&gt;&lt;/FromUserName&gt;<br>&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;<br>&lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt;<br>&lt;Event&gt;&lt;![CDATA[CLICK]]&gt;&lt;/Event&gt;<br>&lt;EventKey&gt;&lt;![CDATA[EVENTKEY]]&gt;&lt;/EventKey&gt;<br>&lt;/xml&gt;</pre><br>参数说明：</p>
<p><table border="1" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>描述</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>发送方帐号（一个OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>消息创建时间 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td>消息类型，event</td><br></p>
<p><tr></tr></p>
<p><td>Event</td></p>
<p><td>事件类型，CLICK</td><br></p>
<p><tr></tr></p>
<p><td>EventKey</td></p>
<p><td>事件KEY值，与自定义菜单接口中KEY值对应</td><br><br><br><br><span id=".E7.82.B9.E5.87.BB.E8.8F.9C.E5.8D.95.E8.B7.B3.E8.BD.AC.E9.93.BE.E6.8E.A5.E6.97.B6.E7.9A.84.E4.BA.8B.E4.BB.B6.E6.8E.A8.E9.80.81" class="mw-headline">点击菜单跳转链接时的事件推送</span></p>
<p><pre class="lang:default decode:true ">&lt;xml&gt;<br>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br>&lt;FromUserName&gt;&lt;![CDATA[FromUser]]&gt;&lt;/FromUserName&gt;<br>&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;<br>&lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt;<br>&lt;Event&gt;&lt;![CDATA[VIEW]]&gt;&lt;/Event&gt;<br>&lt;EventKey&gt;&lt;![CDATA[www.qq.com]]&gt;&lt;/EventKey&gt;<br>&lt;/xml&gt;</pre><br>参数说明：</p>
<p><table border="1" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>描述</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>发送方帐号（一个OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>消息创建时间 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td>消息类型，event</td><br></p>
<p><tr></tr></p>
<p><td>Event</td></p>
<p><td>事件类型，VIEW</td><br></p>
<p><tr></tr></p>
<p><td>EventKey</td></p>
<p><td>事件KEY值，设置的跳转URL</td><br><br><br><br>isClickEvent用于判断消息类型具体指哪一种。</p>
<p><pre class="lang:default decode:true"> /**</pre></p>
<pre><code> * 判断是否是点击菜单拉取消息事件
 * @return boolean
 */
public function isClickEvent()
{
    return $this-&amp;gt;_postData-&amp;gt;Event == self::EVENT_TYPE_CLICK;
}

/**
 * 判断是否是点击菜单跳转事件
 * @return boolean
 */
public function isViewEvent()
{
    return $this-&amp;gt;_postData-&amp;gt;Event == self::EVENT_TYPE_VIEW;
}
</code></pre><p><br>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信公众账号接收消息类型判断代码]]></title>
      <url>http://yoursite.com/2015/09/17/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>在填写接口配置信息的时候，请注意：</p>
<p>1，url为你的代码文件所在地址，例如</p>
<p><pre class="lang:default decode:true"><a href="http://wechat.chenyalun.cn/xiaoxi.php" target="_blank" rel="external">http://wechat.chenyalun.cn/xiaoxi.php</a></pre><br>2，当前代码的Token为 iloveyou  可以自行修改。</p>
<p>3，代码经过测试完全正确，具体在测试时，由于微信服务器或者自己的服务器的原因，公众号回复消息可能略微延迟。</p>
<p>4，如果需要将代码下载至本地，可直接复制。用记事本打开，在保存的时候选择另存为ANSI编码，保存为PHP文件即可。什么？不想复制，没关系，我把代码分享出来，<a href="http://www.chenyalun.cn/go/?url=http://pan.baidu.com/s/1c0Hffqw" target="_blank" rel="external">点击这里下载</a></p>
<p><pre class="lang:default decode:true">&lt;?php</pre></p>
<p>//<br>// 接收用户消息<br>// 微信公众账号接收到用户的消息类型判断<br>// www.chenyalun.cn 陈亚伦博客<br>//</p>
<p>define(“TOKEN”, “iloveyou”);</p>
<p>$wechatObj = new wechatCallbackapiTest();<br>if (!isset($_GET[‘echostr’])) {<br>    $wechatObj-&gt;responseMsg();<br>}else{<br>    $wechatObj-&gt;valid();<br>}</p>
<p>class wechatCallbackapiTest<br>{<br>    public function valid()<br>    {<br>        $echoStr = $_GET[“echostr”];<br>        if($this-&gt;checkSignature()){<br>            echo $echoStr;<br>            exit;<br>        }<br>    }</p>
<pre><code>private function checkSignature()
{
    $signature = $_GET[&quot;signature&quot;];
    $timestamp = $_GET[&quot;timestamp&quot;];
    $nonce = $_GET[&quot;nonce&quot;];

    $token = TOKEN;
    $tmpArr = array($token, $timestamp, $nonce);
    sort($tmpArr);
    $tmpStr = implode( $tmpArr );
    $tmpStr = sha1( $tmpStr );

    if( $tmpStr == $signature ){
        return true;
    }else{
        return false;
    }
}

public function responseMsg()
{
    $postStr = $GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;];
    if (!empty($postStr)){
        $postObj = simplexml_load_string($postStr, &apos;SimpleXMLElement&apos;, LIBXML_NOCDATA);
        $RX_TYPE = trim($postObj-&amp;gt;MsgType);

        //用户发送的消息类型判断
        switch ($RX_TYPE)
        {
            case &quot;text&quot;:    //文本消息
                $result = $this-&amp;gt;receiveText($postObj);
                break;
            case &quot;image&quot;:   //图片消息
                $result = $this-&amp;gt;receiveImage($postObj);
                break;

            case &quot;voice&quot;:   //语音消息
                $result = $this-&amp;gt;receiveVoice($postObj);
                break;
            case &quot;video&quot;:   //视频消息
                $result = $this-&amp;gt;receiveVideo($postObj);
                break;
            case &quot;location&quot;://位置消息
                $result = $this-&amp;gt;receiveLocation($postObj);
                break;
            case &quot;link&quot;:    //链接消息
                $result = $this-&amp;gt;receiveLink($postObj);
                break;
            default:
                $result = &quot;unknow msg type: &quot;.$RX_TYPE;
                break;
        }
        echo $result;
    }else {
        echo &quot;&quot;;
        exit;
    }
}

/*
 * 接收文本消息
 */
private function receiveText($object)
{
    $content = &quot;你发送的是文本，内容为：&quot;.$object-&amp;gt;Content;
    $result = $this-&amp;gt;transmitText($object, $content);
    return $result;
}

/*
 * 接收图片消息
 */
private function receiveImage($object)
{
    $content = &quot;你发送的是图片，地址为：&quot;.$object-&amp;gt;PicUrl;
    $result = $this-&amp;gt;transmitText($object, $content);
    return $result;
}

/*
 * 接收语音消息
 */
private function receiveVoice($object)
{
    $content = &quot;你发送的是语音，媒体ID为：&quot;.$object-&amp;gt;MediaId;
    $result = $this-&amp;gt;transmitText($object, $content);
    return $result;
}

/*
 * 接收视频消息
 */
private function receiveVideo($object)
{
    $content = &quot;你发送的是视频，媒体ID为：&quot;.$object-&amp;gt;MediaId;
    $result = $this-&amp;gt;transmitText($object, $content);
    return $result;
}

/*
 * 接收位置消息
 */
private function receiveLocation($object)
{
    $content = &quot;你发送的是位置，纬度为：&quot;.$object-&amp;gt;Location_X.&quot;；经度为：&quot;.$object-&amp;gt;Location_Y.&quot;；缩放级别为：&quot;.$object-&amp;gt;Scale.&quot;；位置为：&quot;.$object-&amp;gt;Label;
    $result = $this-&amp;gt;transmitText($object, $content);
    return $result;
}

/*
 * 接收链接消息
 */
private function receiveLink($object)
{
    $content = &quot;你发送的是链接，标题为：&quot;.$object-&amp;gt;Title.&quot;；内容为：&quot;.$object-&amp;gt;Description.&quot;；链接地址为：&quot;.$object-&amp;gt;Url;
    $result = $this-&amp;gt;transmitText($object, $content);
    return $result;
}

/*
 * 回复文本消息
 */
private function transmitText($object, $content)
{
    $textTpl = &quot;&amp;lt;xml&amp;gt;
</code></pre><p>&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;<br>&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;<br>&lt;CreateTime&gt;%s&lt;/CreateTime&gt;<br>&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;<br>&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;<br>&lt;/xml&gt;”;<br>        $result = sprintf($textTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), $content);<br>        return $result;<br>    }<br>}<br>?&gt;<br><br>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[赵匡胤：呆萌温和中透露君王霸气]]></title>
      <url>http://yoursite.com/2015/09/16/%E8%B5%B5%E5%8C%A1%E8%83%A4%EF%BC%9A%E5%91%86%E8%90%8C%E6%B8%A9%E5%92%8C%E4%B8%AD%E9%80%8F%E9%9C%B2%E5%90%9B%E7%8E%8B%E9%9C%B8%E6%B0%94/</url>
      <content type="html"><![CDATA[<p>印象中的赵匡胤是一个呆萌的老头，一个宅心仁厚的兄长，一个胸怀天下的武将，一个霸气侧漏的大宋君王。</p>
<p>以前对古代的皇帝们不太感兴趣，主要是因为没有几个好货色，而且一想起皇帝们整天过着长腿妹子随便啪，麻辣小龙虾随便吃的生活，嫉妒愤恨之情油然而生。赵匡胤不一样，至少，他是个节俭的皇帝，节俭到宫女不够三百人。您可能要说，节俭的皇帝那么多，不差他一个，干嘛就提他呀，别说话，静静看我写。</p>
<p>出身军人家庭的他，自小勇毅，长大后还是那种英俊潇洒的高富帅，所以虎父无犬子，就是降服一匹烈马，也是那种头撞到门楣也很开心的那种，当然偶尔有时候会为了捉麻雀把人家屋子给搞塌的。不过说勇敢是真的，就是来20个老太太，一样毫无畏惧地去扶。</p>
<p>《大宋传奇之赵匡胤》我看了前半部分，虽然有人经过加工，篡改了一些历史，不过，却把他演绎的更加有血有肉了。就像在泰山之巅，年轻气盛立下铮铮誓言，胸怀天下，以仁治天下。我希望这是真的。</p>
<p>天下是打下来的，对赵匡胤来说，从殿前都虞候，殿前都指挥使再到殿前都点检，一步一个脚印，承载的是一个七尺男儿的梦想。无论是自己想当皇帝还是部下逼迫，陈桥兵变，黄袍加身，都是一个传奇的开始。手握兵权，却不伤百姓，觊觎皇位，却兵不血刃，占荆湖，灭后蜀，平江南，我看到的是一个君王统一天下的宏图大志，一个皇帝施展抱负的气势磅礴。就像他说的“卧榻之侧，岂容他人酣睡”，在这方面，他做到一个男人梦寐以求的事，让天下人羡慕。</p>
<p>或许，霸气之外，还能看到他的温和宽容，就像在酒宴上看到臣子哭泣，怀念旧主，他微微一笑，冷箭射中轿子，还要开心地谢刺客教他箭法，不做追究，饭菜上有虱子，也不对伺候御膳的人施予惩罚。能有皇帝这样做，着实不简单。</p>
<p>长兄如父。他对他的亲兄弟们没得说，比他们大十几岁，二十几岁，硬是细心呵护，悉心教导，可以想象出一位长兄的仁爱。可是某些兄弟对他却又是另一回事了，夺了皇位不说，还把老哥家的孩子逼上绝路。我是不会告诉你这个人就是赵光义的。</p>
<p>老赵活了四十九年，在位十六年间励精图治，最后还留个烛光斧影的谜，让后人解说。</p>
<p>他的传奇，实实在在是由他书写的，他的江山，着着实实是他打下来的，毋庸置疑，这点倒是让人感到敬佩，不像一些富二代，出生后就是太子，这辈子就是皇帝命。天道酬勤，我们都拥有梦想，都想实现自己的梦想，倘若我们不是富二代，那么江山，只能靠我们自己打，机遇也好，能力也罢，总之一切的根本是自己付出的努力，没有努力，所有都是空谈罢了。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[收发消息的XML数据包分析（下）]]></title>
      <url>http://yoursite.com/2015/09/15/%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF%E7%9A%84XML%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在前文的<a href="http://www.chenyalun.cn/%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF%E7%9A%84xml%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89.html" target="_blank" rel="external">收发消息的XML数据包分析（上）</a>中我们介绍了文本，图片以及语音三种消息类型，并给出了相关的代码，今天，我们就接着介绍地理位置，链接，视频消息类型，并分析它们的消息结构。</p>
<h3 id="一，地理位置"><a href="#一，地理位置" class="headerlink" title="一，地理位置"></a>一，地理位置</h3><p>消息结构如下：</p>
<pre class="lang:default decode:true ">&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;1351776360&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[location]]&gt;&lt;/MsgType&gt;
&lt;Location_X&gt;23.134521&lt;/Location_X&gt;
&lt;Location_Y&gt;113.358803&lt;/Location_Y&gt;
&lt;Scale&gt;20&lt;/Scale&gt;
&lt;Label&gt;&lt;![CDATA[位置信息]]&gt;&lt;/Label&gt;
&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;
&lt;/xml&gt;</pre>
&nbsp;
<table border="1" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
<tr>
<td>ToUserName</td>
<td>**开发者**微信号</td>
</tr>
<tr>
<td>FromUserName</td>
<td>发送方帐号（一个OpenID）</td>
</tr>
<tr>
<td>CreateTime</td>
<td>消息创建时间 （整型）</td>
</tr>
<tr>
<td>MsgType</td>
<td>location</td>
</tr>
<tr>
<td>Location_X</td>
<td>地理位置维度</td>
</tr>
<tr>
<td>Location_Y</td>
<td>地理位置经度</td>
</tr>
<tr>
<td>Scale</td>
<td>地图缩放大小</td>
</tr>
<tr>
<td>Label</td>
<td>地理位置信息</td>
</tr>
<tr>
<td>MsgId</td>
<td>消息id，64位整型</td>
</tr>
</tbody>
</table>
isLocationMsg用于判断消息的类型是否为位置消息：
<pre class="lang:default decode:true "> const MSG_TYPE_LOCATION = 'location';

/**
     * 判断是否是位置信息
     * @return boolean
     */
    public function isLocationMsg()
    {
        return $this-&gt;_postData-&gt;MsgType == self::MSG_TYPE_LOCATION;
    }
//发送消息
 $this-&gt;outputText("您发送的是位置消息,维度为: ".$data-&gt;Location_X."\n经度为: ".$data-&gt;Location_Y."\n缩放级别为: ".$data-&gt;Scale."\n位置为: ".$data-&gt;Label);

</pre>

<h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://source.chenyalun.cn/5091809180004.png" alt=""></h3><h3 id="二，链接消息"><a href="#二，链接消息" class="headerlink" title="二，链接消息"></a>二，链接消息</h3><p>此处的链接消息与URL有所不同，因为用户直接发送的URL仍是被视作文本消息，而链接消息是指用户点击右上角的“发送给好友”“分享到朋友圈”，此处的链接才是真正的链接，我们可以通过“收藏”功能，把它保存下来，再发送到公众号。</p>
<p>链接消息的数据结构如下</p>
<pre class="lang:default decode:true ">&lt;xml&gt;
&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;1351776360&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[link]]&gt;&lt;/MsgType&gt;
&lt;Title&gt;&lt;![CDATA[公众平台官网链接]]&gt;&lt;/Title&gt;
&lt;Description&gt;&lt;![CDATA[公众平台官网链接]]&gt;&lt;/Description&gt;
&lt;Url&gt;&lt;![CDATA[url]]&gt;&lt;/Url&gt;
&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;
&lt;/xml&gt;</pre>
&nbsp;
<table border="1" cellspacing="0" cellpadding="4" align="center">
<tbody>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
<tr>
<td>ToUserName</td>
<td>接收方微信号</td>
</tr>
<tr>
<td>FromUserName</td>
<td>发送方微信号，若为普通用户，则是一个OpenID</td>
</tr>
<tr>
<td>CreateTime</td>
<td>消息创建时间</td>
</tr>
<tr>
<td>MsgType</td>
<td>消息类型，link</td>
</tr>
<tr>
<td>Title</td>
<td>消息标题</td>
</tr>
<tr>
<td>Description</td>
<td>消息描述</td>
</tr>
<tr>
<td>Url</td>
<td>消息链接</td>
</tr>
<tr>
<td>MsgId</td>
<td>消息id，64位整型</td>
</tr>
</tbody>
</table>
&nbsp;

isLinkMsg用于判断消息的类型是否为链接类型
<pre class="lang:default decode:true">   const MSG_TYPE_LINK='link';

/**
     * 判断是否是链接
     * @return boolean
     */
    public function isLinkMsg(){
        return $this-&gt;_postData-&gt;MsgType == self::MSG_TYPE_LINK;
    }

//发送消息
      $this-&gt;outputText("您发送的是链接消息,标题是: ".$data-&gt;Title."\n摘要是: ".$data-&gt;Description."\n链接是: ".$data-&gt;Url);
</pre>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="http://source.chenyalun.cn/5091809180003.png" alt=""></h3><h3 id="三，视频消息"><a href="#三，视频消息" class="headerlink" title="三，视频消息"></a>三，视频消息</h3><p>目前分为视频消息和短视频消息，二者仅有丝毫的不同，数据结构如下：</p>
<p>&nbsp;</p>
<p><pre class="lang:default decode:true ">&lt;xml&gt;<br>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br>&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;<br>&lt;CreateTime&gt;1357290913&lt;/CreateTime&gt;<br>&lt;MsgType&gt;&lt;![CDATA]&gt;<br>&lt;/MsgType&gt; &lt;MediaId&gt;<br>&lt;![CDATA[media_id]]&gt;<br>&lt;/MediaId&gt;<br> &lt;ThumbMediaId&gt;<br>&lt;![CDATA[thumb_media_id]]&gt;<br> &lt;/ThumbMediaId&gt;<br>&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt; &lt;/xml&gt;</pre><br>&nbsp;</p>
<p><table border="1" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>描述</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>发送方帐号（一个OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>消息创建时间 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td><strong>视频为video，小视频为shortvideo</strong></td><br></p>
<p><tr></tr></p>
<p><td>MediaId</td></p>
<p><td>视频消息媒体id，可以调用多媒体文件下载接口拉取数据。</td><br></p>
<p><tr></tr></p>
<p><td>ThumbMediaId</td></p>
<p><td>视频消息缩略图的媒体id，可以调用多媒体文件下载接口拉取数据。</td><br></p>
<p><tr></tr></p>
<p><td>MsgId</td></p>
<p><td>消息id，64位整型</td><br><br><br><br>isVideoMsg用于判断消息类型是否为视频消息</p>
<p><pre class="lang:default decode:true">  const MSG_TYPE_VIDEO=’video’;</pre></p>
<p>/**</p>
<pre><code> * 判断是否是视频消息
 * @return boolean
 */
public function isVideoMsg(){
    return $this-&amp;gt;_postData-&amp;gt;MsgType == self::MSG_TYPE_VIDEO;
}
</code></pre><p>//发送消息<br>$this-&gt;outputText(“您发送的是视频消息,媒体ID是: “.$data-&gt;MediaId.”\n缩略图ID是: “.$data-&gt;ThumbMediaId);<br><br>于是所有的普通消息类型我们都分析完了，<span class="toctext">文本消息，</span><span class="toctext">图片消息，</span><span class="toctext">语音消息，</span> <span class="toctext">视频消息，</span><span class="toctext">小视频消息，</span><span class="toctext">地理位置消息，</span><span class="toctext">链接消息都是普通的消息类型，也是最常用的消息类型，所以需要认真研习掌握，当然文中的全部代码会给出供下载，可自行配置测试。</span></p>
<p>具体代码可点击文章查看： <a href="http://www.chenyalun.cn/%e5%be%ae%e4%bf%a1%e5%85%ac%e4%bc%97%e8%b4%a6%e5%8f%b7%e6%8e%a5%e6%94%b6%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad%e4%bb%a3%e7%a0%81.html" target="_blank" rel="external">微信公众账号接收消息类型判断代码</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[收发消息的XML数据包分析（上）]]></title>
      <url>http://yoursite.com/2015/09/14/%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF%E7%9A%84XML%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>微信服务器的数据交换方式就是把消息封装成xml数据以POST的形式发到我们配置的url上，根据消息类型的不同，xml数据格式也有所不同，而前面我们已经强调过，熟练掌握各种消息类型的收发是微信公众平台开发基础，那么我们今天就首先认识下3种常见的消息类型，它们是：文本，图片和语音。当然还有地理位置，链接，视频，图文，我们稍后提及。</p>
<h3 id="一，文本消息"><a href="#一，文本消息" class="headerlink" title="一，文本消息"></a>一，文本消息</h3><p><pre class="lang:default decode:true">/**</pre></p>
<pre><code> * 解析接收到的post数据
 * @return SimpleXMLElement
 */
public function parsePostRequestData()
{
    $rawData = $GLOBALS[&apos;HTTP_RAW_POST_DATA&apos;];
    $data = simplexml_load_string($rawData, &apos;SimpleXMLElement&apos;, LIBXML_NOCDATA);
    if ($data !== false)
        $this-&amp;gt;_postData = $data;

    return $data;
}
</code></pre><p><br>从$GLOBALS[‘HTTP_RAW_POST_DATA’]中获取POST数据，不过此时的数据是无类型的，通过simplexml_load_string将它解析成xml对象，就能后续使用了。</p>
<p>任何文字消息都是文本消息，包括url，这和我们将要说的“链接”类型有所不同。</p>
<p>文本消息结构如下：</p>
<p><pre class="lang:default decode:true">&lt;xml&gt;<br> &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br> &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;<br> &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;<br> &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;<br> &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;<br> &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;<br> &lt;/xml&gt;</pre></p>
<p><table border="1" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>描述</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>发送方帐号（一个OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>消息创建时间 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td>text</td><br></p>
<p><tr></tr></p>
<p><td>Content</td></p>
<p><td>文本消息内容</td><br></p>
<p><tr></tr></p>
<p><td>MsgId</td></p>
<p><td>消息id，64位整型</td><br><br><br><br>ToUserName：微信公众账号，在账号信息中可以看到的。</p>
<p>FromUserName：消息发送者的OpenID，对于同一个公众号，订阅者的OpenID固定不变，对于不同的公众号，用户的OpenID是不同的。</p>
<p>CreateTime：消息创造的时间，是整形数字，表示从1970年1月1日0时0分0秒到现在经过的秒数。</p>
<p>MsgType：消息类型，就是我们所说的文本，语音，视频等类型。</p>
<p>Content：消息内容。</p>
<p>MsgId：消息id编号，是64位整形数据。</p>
<p><pre class="lang:default decode:true">//定义test<br>const MSG_TYPE_TEXT = ‘text’;<br>  /**</pre></p>
<pre><code> * 判断是否是文字信息
 * @return boolean
 */
public function isTextMsg()
{
    return $this-&amp;gt;_postData-&amp;gt;MsgType == self::MSG_TYPE_TEXT;
}
</code></pre><p>//发送消息<br>$this-&gt;text(“您发送的是文本消息，消息内容是：”.$data-&gt;Content);</p>
<p><br>text函数用来发送消息，后面更加详细介绍。</p>
<p><img src="http://source.chenyalun.cn/5091809180001.png" alt=""></p>
<h3 id="二，图片消息"><a href="#二，图片消息" class="headerlink" title="二，图片消息"></a>二，图片消息</h3><p>图片消息就是媒体消息，微信在收到时，就存在云端生成图片的url和媒体ID，图片的URL可以公共访问，比如百度logo的url：<a href="https://www.baidu.com/img/bd_logo1.png,我们点击就可以访问了，而公众号则可以通过媒体ID获取图片文件，更加方便，图片的结构如下；" target="_blank" rel="external">https://www.baidu.com/img/bd_logo1.png,我们点击就可以访问了，而公众号则可以通过媒体ID获取图片文件，更加方便，图片的结构如下；</a></p>
<p><pre class="lang:default decode:true ">&lt;xml&gt;<br> &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br> &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;<br> &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;<br> &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;<br> &lt;PicUrl&gt;&lt;![CDATA[this is a url]]&gt;&lt;/PicUrl&gt;<br> &lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;<br> &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;<br> &lt;/xml&gt;</pre></p>
<p><table border="1" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>描述</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>发送方帐号（一个OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>消息创建时间 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td>image</td><br></p>
<p><tr></tr></p>
<p><td>PicUrl</td></p>
<p><td>图片链接</td><br></p>
<p><tr></tr></p>
<p><td>MediaId</td></p>
<p><td>图片消息媒体id，可以调用多媒体文件下载接口拉取数据。</td><br></p>
<p><tr></tr></p>
<p><td>MsgId</td></p>
<p><td>消息id，64位整型</td><br><br><br></p>
<p><pre class="lang:default decode:true">const REPLY_TYPE_IMAGE=’image’;<br>;/**</pre></p>
<pre><code> * 判断是否是图片
 * @return boolean
 */
public function isImageMsg(){
    return $this-&amp;gt;_postData-&amp;gt;MsgType == self::MSG_TYPE_IMAGE;
}
</code></pre><p>//发送消息<br>$this-&gt;text(“您发送的是图片消息，图片链接是：”.$data-&gt;PicUrl.”\n媒体ID是：”.$data-&gt;MediaID);<br><img src="http://source.chenyalun.cn/5091809180005.png" alt=""></p>
<h3 id="三，语音消息"><a href="#三，语音消息" class="headerlink" title="三，语音消息"></a>三，语音消息</h3><p>语音消息也是只发送媒体ID，结构如下：</p>
<p><pre class="lang:default decode:true ">&lt;xml&gt;<br>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;<br>&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;<br>&lt;CreateTime&gt;1357290913&lt;/CreateTime&gt;<br>&lt;MsgType&gt;&lt;![CDATA[voice]]&gt;&lt;/MsgType&gt;<br>&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;<br>&lt;Format&gt;&lt;![CDATA[Format]]&gt;&lt;/Format&gt;<br>&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;<br>&lt;/xml&gt;</pre></p>
<p><table border="1" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>描述</th><br></p>
<p><tr></tr></p>
<p><td>ToUserName</td></p>
<p><td><strong>开发者</strong>微信号</td><br></p>
<p><tr></tr></p>
<p><td>FromUserName</td></p>
<p><td>发送方帐号（一个OpenID）</td><br></p>
<p><tr></tr></p>
<p><td>CreateTime</td></p>
<p><td>消息创建时间 （整型）</td><br></p>
<p><tr></tr></p>
<p><td>MsgType</td></p>
<p><td>语音为voice</td><br></p>
<p><tr></tr></p>
<p><td>MediaId</td></p>
<p><td>语音消息媒体id，可以调用多媒体文件下载接口拉取数据。</td><br></p>
<p><tr></tr></p>
<p><td>Format</td></p>
<p><td>语音格式，如amr，speex等</td><br></p>
<p><tr></tr></p>
<p><td>MsgID</td></p>
<p><td>消息id，64位整型</td><br><br><br><br>&nbsp;</p>
<p><pre class="lang:default decode:true"> const MSG_TYPE_VOICE = ‘voice’;</pre></p>
<p>  /**</p>
<pre><code> * 判断是否是语音消息
 * @return boolean
 */
public function isVoiceMsg(){
    return $this-&amp;gt;_postData-&amp;gt;MsgType == self::MSG_TYPE_VOICE;
}
</code></pre><p>  //发送消息<br>$this-&gt;text(“您发送的是语音消息，媒体ID是：”.$data-&gt;MediaID.”\n语音格式是：”.$data-&gt;Format);<br><br><img src="http://source.chenyalun.cn/5091809180006.png" alt=""></p>
<p>好，今天就先介绍这三个，重要的是对消息类型的理解，勤加思考方会融会贯通。</p>
<p>&nbsp;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信开发者模式接入]]></title>
      <url>http://yoursite.com/2015/09/14/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E6%8E%A5%E5%85%A5/</url>
      <content type="html"><![CDATA[<p>在<a href="http://www.chenyalun.cn/%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8.html" target="_blank" rel="external">开发第一个应用</a>中我们详细介绍了测试代码的上传与应用，那么今天，我们就认真剖析下微信服务器发送给我们的GET请求，以及有关接口。很明显，普通用户发送文本、图片、语音等消息到我们的公众号（或者说微信服务器），微信服务器再将这些消息以POST的形式发送到我们的服务器上，我们为所欲为地进行解剖，再返还给微信服务器，继而返还给用户，便是整个微信开发过程。</p>
<p>首先，我们肯定要明白发送给我们服务器的GET请求是个什么鬼，这样才能进行剖析嘛，如图所示：</p>
<p>微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带四个参数：</p>
<p><table border="1" width="640px" cellspacing="0" cellpadding="4" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>参数</th></p>
<p><th>描述</th><br></p>
<p><tr></tr></p>
<p><td>signature</td></p>
<p><td>微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</td><br></p>
<p><tr></tr></p>
<p><td>timestamp</td></p>
<p><td>时间戳</td><br></p>
<p><tr></tr></p>
<p><td>nonce</td></p>
<p><td>随机数</td><br></p>
<p><tr></tr></p>
<p><td>echostr</td></p>
<p><td>随机字符串</td><br><br><br><br>开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。这里的“原样返回”就是我们前文所说的“鹦鹉学舌”。</p>
<p>那么我们如何验证URL来源是否可靠呢？很简单检验签名就行了，开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。上代码：</p>
<p><pre class="lang:default decode:true"> //检验signature的PHP示例代码</pre></p>
<p>private function checkSignature()<br>{<br>//获取参数值<br>        $signature = $_GET[“signature”];<br>        $timestamp = $_GET[“timestamp”];<br>        $nonce = $_GET[“nonce”];<br>    $token = TOKEN;<br>    $tmpArr = array($token, $timestamp, $nonce);<br>    sort($tmpArr, SORT_STRING);<br>    $tmpStr = implode( $tmpArr );<br>    $tmpStr = sha1( $tmpStr );</p>
<pre><code>if( $tmpStr == $signature ){
    return true;
}else{
    return false;
}
</code></pre><p>}<br>&nbsp;</p>
<p>懂得这一原理的同学，想必已经理解了，不过我估计理解的人应该很少吧，木有关系，这篇文章只是告诉大家，微信开发者接入原理是怎么样的，希望大家知识是完整的。如果实在不好理解，无伤大雅。在接下来的文章中，我们就来分析下，微信服务器发送来的请求的类型，诸如文本，图片，语音，地理位置，视频，链接等等，而掌握各种消息类型的接收回复就是进行微信公众平台开发的基础。这才是至关重要的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开发第一个应用]]></title>
      <url>http://yoursite.com/2015/09/14/%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>当决定进入微信公众平台开发时，有一件重要的事情摆在你面前：申请公众账号和相关接口，然而并不是每个人类都能够拥有这些接口，因为很多巧妙的接口只开放给认证的童鞋，不过我们完全可以通过申请官方的测试账号进行开发。于是奇妙的微信开发就这么开始了，想想都激动o(^▽^)o</p>
<p>1，下载PHP SDK</p>
<p>微信公众平台提供许多接口，网上也有很多开源公众平台PHP SDK，作为一名闷骚的开发者，重复造轮子实在不是明智之举，那么我们可以根据自身的用途，来选择一个巧妙的开源软件，我在此向大家推荐几个：</p>
<p><a href="https://github.com/spetacular/weixin" target="_blank" rel="external">https://github.com/spetacular/weixin</a>  采用MIT License</p>
<p><a href="https://github.com/zemzheng/wechatphp-sdk" target="_blank" rel="external">https://github.com/zemzheng/wechatphp-sdk</a>   采用MIT License</p>
<p><a href="https://github.com/dodgepudding/wechat-php-sdk" target="_blank" rel="external">https://github.com/dodgepudding/wechat-php-sdk</a>  采用GUN LGPL version 2.1 License</p>
<p>我们就以第一个SDK为例。大家进入页面点击项目主页右下角的“Download Zip”直接下载，或者直接点击下载地址：<a href="https://github.com/spetacular/weixin/archive/master.zip" target="_blank" rel="external">https://github.com/spetacular/weixin/archive/master.zip</a></p>
<p><img src="http://source.chenyalun.cn/50914001.jpg" alt="">解压后得到文件目录：</p>
<p>api.php为自定义回复接口</p>
<p>menu.php为菜单操作</p>
<p>defaultweixin.php拓展逻辑实现</p>
<p>weixin.class.php微信接口实现类</p>
<p>weixin.config.php微信配置文件</p>
<p>还有个README.MD就是使用说明了，然并L。。</p>
<p>2，接口测试账号申请</p>
<p>在公众号木有审核通过或者根本无法认证时，我们可以申请这个进行开发，申请地址：<a href="http://www.chenyalun.cn/go/?url=http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="external">http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a></p>
<p><img src="http://source.chenyalun.cn/50914003.jpg" alt=""></p>
<p>类似电脑版微信的登录模式，扫一扫即可，接着出现了神奇的管理界面，最重要的就是</p>
<div class="frm_control_group show_value info_item">

<p><label class="frm_label" for="">appID和</label><label class="frm_label" for="">appsecret了，访问接口必然要用的。还有就是“请填写接口配置信息，此信息需要你有自己的服务器资源，填写的URL需要正确响应微信发送的Token验证”这里的url就是服务器地址，Token是我们与微信服务器约定的密码。</label></p>
<p><div class="frm_controls"></div><br></p></div><p></p>
<p><div class="frm_control_group show_value info_item">3，上传至服务器</div></p>
<p><div class="frm_control_group show_value info_item">在上传至服务器之前我们要修改weixin.config.php中的配置项，包括<label class="frm_label" for="">appID，</label><label class="frm_label" for="">appsecret和Token，打开weixin.config.php可以看到</label></div></p>
<p><div class="frm_control_group show_value info_item"></div></p>
<p><pre class="lang:default decode:true">&lt;?php<br>define(‘APPID’,’APPID’);<br>define(‘APPSECRET’,’APPSECRET’);<br>define(‘TOKEN’,’Token’);<br>?&gt;<br></pre><br>直接将APPID,APPSECRET,还有自己设置的TOKEN依次替换即可。注意，是替换第二个，不要全部替换，否则配置会出错的。例如：</p>
<p><pre class="lang:default decode:true">&lt;?php<br>define(‘APPID’,wxxxxxxxxxsx’);<br>define(‘APPSECRET’,’87b4d3xxxxxxxxxx99’);<br>define(‘TOKEN’,’iloveyou’);//此处是自己设置的密钥，比如我的iloveyou，设置成什么，自己开心就好，哈哈<br>?&gt;</pre><br>将代码上传至服务器，如果按照前文所说采用SAE的话，那只需在把所示的六个文件修改后复制到版本号为“1”的文件夹内，右击打开菜单点击SVN Commit即可上传至服务器。如果你仔细看过<a href="http://www.chenyalun.cn/%E5%88%A9%E7%94%A8sae%E6%90%AD%E5%BB%BA%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html" target="_blank" rel="external">SAE环境的搭建</a>，这些都不是问题，当然如果实在不理解，那就在回到SAE，点击代码管理，上传代码包，效果一样。</p>
<p>如果api.php的网址是“<a href="http://www.chenyalun.cn/api.php”，那么测试管理员的url就填成“http://www.chenyalun.cn/api.php”。因为我们是采用的SAE，所以api.php的网址是http://1.chenyalun1.sinaapp.com/api.php，此处的&quot;1&quot;表示版本号，无伤大雅。点击提交，微信服务器会自动验证接口和签名是否正确，正确的话，恭喜，成功进入开发者模式了。" target="_blank" rel="external">http://www.chenyalun.cn/api.php”，那么测试管理员的url就填成“http://www.chenyalun.cn/api.php”。因为我们是采用的SAE，所以api.php的网址是http://1.chenyalun1.sinaapp.com/api.php，此处的&quot;1&quot;表示版本号，无伤大雅。点击提交，微信服务器会自动验证接口和签名是否正确，正确的话，恭喜，成功进入开发者模式了。</a></p>
<p>4，扫描二维码</p>
<p>扫描测试号的二维码，并关注，就可以看到管理测试页的用户列表了，php sdk默认的消息处理方式是返回用户发送的消息，效果如图：，就这样，一个简单的应用就这么巧妙地完成了。</p>
<p><br><img src="http://source.chenyalun.cn/0915q1.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SAE本地环境搭建]]></title>
      <url>http://yoursite.com/2015/09/12/SAE%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>在上回咱们说到<a href="http://www.chenyalun.cn/%e5%88%a9%e7%94%a8sae%e6%90%ad%e5%bb%ba%e5%85%ac%e4%bc%97%e5%8f%b7%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83.html" target="_blank" rel="external">利用SAE搭建公众号开发环境</a>，并且利用svn客户端进行代码部署，当然也提过，利用这种方式的原因是，可以随时回退到历史版本，十分方便。其实为了开发者方便调试，sae是提供了本地开发环境的，它们能模仿sae的大部分功能及服务，而且如果我们在本地开发不仅节约时间，不用频繁上传代码，而且节省测试程序调用sae服务造成的云豆（人民币）消耗。</p>
<p>Ok，现在咱们就开始搭建本地开发环境。</p>
<h3 id="1，下载部署文件"><a href="#1，下载部署文件" class="headerlink" title="1，下载部署文件"></a>1，下载部署文件</h3><p>在sae资源加速网站 lib.sinaapp.com上，点击页面底部的本地 SAE Local Environment（Windows）即可下载该压缩包。</p>
<p>需要指出的是，该绿色软件集成Apache，PHP，Redis等服务，但没有集成Mysql，若有需要，请自行配制，还有就是，软件只有win版本，只有命令行方式，所以需要仔细认真部署了。</p>
<p>下载完成后解压即可，放置在你喜欢的路径下，执行init.cmd脚本即可运行，话说，如果无法运行的话，右击，点击“以管理员身份运行”即可。如果出现LocalSAE&gt;就表示成功了。</p>
<h3 id="2，常用命令部署"><a href="#2，常用命令部署" class="headerlink" title="2，常用命令部署"></a>2，常用命令部署</h3><p>步骤还是和前文类似，创建应用—选择应用—-创建版本</p>
<p>以创建名为chenyalun的应用为例，具体步骤如下：</p>
<ul>
<li><h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><div id="crayon-55f3fa41584ab029309795" class="crayon-syntax crayon-theme-familiar crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"><br><div class="crayon-plain-wrap"></div><br><div class="crayon-main"><br><pre class="lang:default decode:true">LocalSAE&gt;  capp chenyalun</pre><br>&nbsp;</div></div></li>
</ul>
<p><br><br>创建成功后，wwwroot目录下神奇的出现一个名为chenyalun的文件夹</p>
<ul>
<li><h4 id="选择应用"><a href="#选择应用" class="headerlink" title="选择应用"></a>选择应用</h4><p>因为可能同时存在多个应用，所以切换到当前开发的应用。</p>
<div id="crayon-55f3fa41584ba485569908" class="crayon-syntax crayon-theme-familiar crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"><br><div class="crayon-main"><br><pre class="lang:default decode:true">LocalSAE&gt;  use  chenyalun</pre><br></div><br></div>
</li>
<li><h4 id="创建版本"><a href="#创建版本" class="headerlink" title="创建版本"></a>创建版本</h4><p>版本存在的意义主要是允许应用以多种姿态（面目）存活于世，sae允许创建10个版本，版本号必须是整数<br><div id="crayon-55f3fa41584c2452879746" class="crayon-syntax crayon-theme-familiar crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"><br><div class="crayon-main"><br><pre class="lang:default decode:true">LocalSAE&gt;  cversion 1</pre><br></div><br></div><br>不出意外，应用目录下有个名称为1的文件夹<br><div id="crayon-55f3fa41584c8872558914" class="crayon-syntax crayon-theme-familiar crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"><br><div class="crayon-main"><br><pre class="lang:default decode:true">LocalSAE&gt;  defer  1</pre><br></div><br></div><br>设置默认版本成功</p>
</li>
<li><h4 id="更新配置文件"><a href="#更新配置文件" class="headerlink" title="更新配置文件"></a>更新配置文件</h4><p>由于刚刚的操作会更改config.yaml文件，完成上面的步骤后更新这个文件就可以保证操作生效了。</p>
</li>
</ul>
<p>更新单个版本的配置文件</p>
<p><div id="crayon-55f3fa41584cf612531325" class="crayon-syntax crayon-theme-familiar crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"></div></p>
<p><div class="crayon-plain-wrap"></div></p>
<p><div class="crayon-main"></div></p>
<p><pre class="lang:default decode:true">LocalSAE&gt;  upconfig 1</pre><br><br><br>更新应用下所以版本的配置文件</p>
<p><div id="crayon-55f3fa41584d5956111071" class="crayon-syntax crayon-theme-familiar crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"></div></p>
<p><div class="crayon-main"></div></p>
<p><pre class="lang:default decode:true  ">LocalSAE&gt;  upallconfig</pre><br><br><br>至此，咱们就创建一个名为chenyalun的应用，按照sae的规则，咱们就可以通过访问chenyalun.sinaapp.com或者1.chenyalun.sinaapp.com访问应用了</p>
<p>因为SAE本地环境的搭建个人觉得比较简单，所以介绍个大概，没有配上详细的图片，就是命令行对一些同学来说可能不太适用，所以需要大家认真学习了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用SAE搭建公众号开发环境]]></title>
      <url>http://yoursite.com/2015/09/12/%E5%88%A9%E7%94%A8SAE%E6%90%AD%E5%BB%BA%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>微信开发的实质就是利用我们自己创造的服务器与微信服务器进行数据交换，而微信服务器需要先对消息进行预处理，区分消息类型，封装成xml数据后，以post的形式交给开发者，然后开发者就可以为所欲为的根据它的数据返回相应的内容了。成为开发者后，就可以获取公众平台的接口权限，当然不同类型的公众号权限是不同滴。具体接口状态可以查看公众号的开发者中心。</p>
<p>总而言之，想要成为开发者，最好有PHP语言程序、MySQL数据库、计算机网络通讯、及HTTP/XML/CSS/JS等基础。当然，小白也是可以的，只不过需要非同寻常的努力。</p>
<p>首先我们要做的当然是搭建一个服务器了，本文介绍sae环境搭建。</p>
<h3 id="1，注册账号"><a href="#1，注册账号" class="headerlink" title="1，注册账号"></a>1，注册账号</h3><p>进入sae官网<a href="http://sae.sina.com.cn/，直接用你的微博账号登录即可，纳尼，你还没有微博？！" target="_blank" rel="external">http://sae.sina.com.cn/，直接用你的微博账号登录即可，纳尼，你还没有微博？！</a></p>
<p><img src="http://source.chenyalun.cn/50913001.jpg" alt=""></p>
<p>&nbsp;</p>
<p>授权完成后，填写相关信息就完成了sae的注册，sae的账号就是你的微博账号。要记住你填写的安全邮箱和密码，后面会用到的。接着点击实名认证，不要嫌麻烦，不实名认证的话，后果很严重，后果很严重，后果很严重。</p>
<h3 id="2-实名认证"><a href="#2-实名认证" class="headerlink" title="2,实名认证"></a>2,实名认证</h3><p><img src="http://source.chenyalun.cn/50913002.jpg" alt=""></p>
<p>&nbsp;</p>
<h3 id="3-SVN部署"><a href="#3-SVN部署" class="headerlink" title="3, SVN部署"></a>3, SVN部署</h3><p>实名认证会有3天时间，资料正确的话很容易就通过了。话说sae有四种代码管理方式：在线安装应用，在线编辑，本地开发环境上传，还有就是SVN部署。我们这里采用SVN部署，因为它和阿里云服务器一样，可以随时回退到任意历史版本，简直炸天了o(^▽^)o</p>
<p>&nbsp;</p>
<p>不出意外的话你用的是windows操作系统，不要问我为什么知道，这就好办了，推荐使用Tortoise SVN客户端，下载地址: <a href="http://www.chenyalun.cn/go/?url=http://tortoisesvn.net/downloads.html" target="_blank" rel="external">http://tortoisesvn.net/downloads.html</a>，，注意选择是64位还是32位的哦，，安装完成后就不用管它了。</p>
<p><img src="http://source.chenyalun.cn/50913003.jpg" alt=""></p>
<h3 id="4，创建应用"><a href="#4，创建应用" class="headerlink" title="4，创建应用"></a>4，创建应用</h3><p>点击控制台，云应用sae，再点击创建新应用，下面以创建域名为“chenyalun”，名称为“微信”为例，语言选择php5.3，这个名称也是要记住的。</p>
<p><img src="http://source.chenyalun.cn/50913004.jpg" alt=""><img src="http://source.chenyalun.cn/50913005.jpg" alt=""></p>
<p>创建成功后出现图示下列界面：</p>
<p><img src="http://source.chenyalun.cn/50913007.jpg" alt=""></p>
<p>&nbsp;</p>
<p>接着点击微信二字，我们进入应用管理界面，然后选择代码管理，选择SVN工具。</p>
<p><img src="http://source.chenyalun.cn/50913006.jpg" alt=""><img src="http://source.chenyalun.cn/50913008.jpg" alt=""></p>
<p>然后点击创建版本，默认版本是“1”</p>
<p><img src="http://source.chenyalun.cn/50913009.jpg" alt=""></p>
<p>&nbsp;</p>
<p>下面所示就是创建好的代码版本，注意该图中有提示SVN仓库地址。我们要记下来，用心记住。</p>
<p><img src="http://source.chenyalun.cn/50913010.jpg" alt=""></p>
<p>&nbsp;</p>
<h3 id="5，本地SVN连接"><a href="#5，本地SVN连接" class="headerlink" title="5，本地SVN连接"></a>5，本地SVN连接</h3><p>打开计算机，选择一个本地工作目录，我以F盘为例，进入F盘根目录，在空白区域右击，弹出的菜单中明显多出两个东东，就是SVN checkout和TortoiseSVN，如果没有，说明你并没有安装好Tortoise SVN客户端，然后点击SVN checkout，出现这个画面：</p>
<p><img src="http://source.chenyalun.cn/50913011.jpg" alt=""></p>
<p>SVN仓库地址     <a href="https://svn.sinaapp.com/你的应用名称（我的是chenyalun）" target="_blank" rel="external">https://svn.sinaapp.com/你的应用名称（我的是chenyalun）</a></p>
<p>用户名  是SAE安全邮箱</p>
<p>密码      是SAE安全密码</p>
<p>这些在最开始注册时需要记下来的。</p>
<p><img src="http://source.chenyalun.cn/50913012.jpg" alt=""></p>
<p>然后点击ok即可，完成之后，明显在F盘多出了一个名为chenyalun的文件夹</p>
<p><img src="http://source.chenyalun.cn/50913013.jpg" alt=""></p>
<p>没错，在chenyalun文件夹中有个名称为“1”的文件夹，就是我们刚刚创建的版本号，打开之后看到index.php文件，再次点击<a href="http://1.chenyalun.sinaapp.com/，就可以访问了，当然内容是index.php文件中的代码。" target="_blank" rel="external">http://1.chenyalun.sinaapp.com/，就可以访问了，当然内容是index.php文件中的代码。</a></p>
<p>就这样，sae开发环境已经搭建好了。如果我们需要修改代码，直接在index.php中修改即可，完成后，右击选择SVN Commit ，在弹出的对话框中点击OK，这样就上传到云端了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编辑模式下你不知道的微信设置]]></title>
      <url>http://yoursite.com/2015/09/12/%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%BE%AE%E4%BF%A1%E8%AE%BE%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>2015年，微信走到了第五个年头，在大部分功能单一的app销声匿迹后，以h5技术为主的轻应用占据手机市场，而微信就是其一，尽管市场份额次于WhatsApp，但是微信确实创造一个奇迹，一个移动终端的奇迹。微信公众平台就是微信的一个大的分支。从今天起，咱们就一起探讨微信公众号的开发与运营。</p>
<p>首先我们需要注册一个微信公众号，方法十分简单，在此不再赘述，咱们直接进入正题。刚刚注册的微信公众号（或者你没有开启开发模式）它是非常直观易操作的，当然也有好奇的同学开启了开发模式，但不知道它是什么鬼的。以订阅号为例，具体功能一一介绍。</p>
<ul>
<li>自动回复<br>有的童鞋设置了被添加自动回复，基本上就是“谢谢你关注我”“你终于来了亲! ”“好饭不怕晚啊亲”哎哟我去，拜托不能有点新意吗，人家好不容易关注你一下，就给人家这么敷衍的一句话，太low了！其实我们完全可以个性一点的，如果你在回复的文字消息中设置些诸如“么么哒”“恭喜发财”“想你了”这些特殊的词语，会掉表情的，想想这么一来公众号是不是很出彩呢。这些关键词在所有回复文字消息的地方都是适用滴，当然我已经整理了大部分的关键词，就在下面了。</li>
</ul>
<p>么么哒  想你了  生日快乐  一路平安 恭喜发财  年年有鱼  红红火火  圣诞快乐</p>
<p>点个赞  xoxo，么么哒，cium，baci，besos  birthday  想你了  miss u</p>
<p>需要说明的是，有些是具有时效性的，过期会失效。</p>
<ul>
<li>回复链接<br>如果想让关注的童鞋点击某个链接了解更多内容，我们完全可以在文字回复中设置超链接的，微信说文字是支持网页链接地址的，但不支持超链接，那怎么办呢，很简单</li>
</ul>
<p>如下所示：</p>
<p><pre class="lang:default decode:true ">&lt;a href=<a href="http://www.chenyalun.cn/&amp;gt" target="_blank" rel="external">http://www.chenyalun.cn/&amp;gt</a>;  陈亚伦博客&lt;/a&gt;</pre><br><img src="http://source.chenyalun.cn/0915m002.png" alt=""></p>
<p>这一效果是由代码【&lt;a href =”某网页的链接地址”&gt;你想要显示的文字&lt;/a&gt;】组成实现的</p>
<p>就是酱紫，通过&lt;a&gt;标签设置超链接效果，一般人不知道，当然，一般人我也不告诉他。</p>
<p>&nbsp;</p>
<ul>
<li>自定义菜单<br>菜单自定义权限已经全部开启，即使公众号木有认证，一样可以使用，而菜单的动作也是非常简单，具体菜单动作不作多说，需要提一下的是，菜单的设置一定要美观，得体。尽量不要设置一个主菜单，这是很掉颜值的，三个最完美，而副菜单根据具体情况设置，要兼顾特色和实用性，有所取舍，突出重点，不要堆砌功能，用户喜欢才是王道。</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>投票功能<br>用的比较少的投票功能表面上很鸡肋，其实我们可以通过它了解用户的需求，做出有针对性的调整，当然，让用户投票，要么给予他些许好处，要么，给予她些许好处，反正除了某些很闲的人或者真的对你的公众号有感情的人，否则，你懂的，结果可想而知。所以要善于利用投票这个功能了解用户的需求，利用需求进行营销。</li>
</ul>
<p>就这样，简单提醒下大家可能忽略的公众号技巧，下次咱们就正式进入公众号开发模式，研究下很高大上的代码哥。</p>
]]></content>
    </entry>
    
  
  
</search>
