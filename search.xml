<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[App作品：Splash]]></title>
    <url>%2F2019%2F12%2F06%2FApp%E4%BD%9C%E5%93%81%EF%BC%9ASplash%2F</url>
    <content type="text"><![CDATA[实践一些想法。 一、前言拜读了Casa前辈的《iOS应用架构谈》系列文章，收获颇丰，萌生了想实践的想法。2017年到现在，虽然写过不少项目，但是始终没有App作品在App Store上架过，也一直有这个小心愿。手机里面有个叫Splasher的App，是壁纸类型的App，虽然壁纸质量不错，但是App体验不太好，加载慢，界面冷酷无情。后来打听到它的API来自无版权可以商用的UnSplash。天时地利人和都有了，我的第一个期望上架App Store的作品：Splash，诞生了。 虽然只是壁纸类的没有多少功能的不需要多少道行就能写出来的App，但是还是想简单聊一聊。 二、思路1，代码结构与俺目前的习惯一致：方法结构按照life cycle、Delegate方法实现、event response、getters and setters顺序。#pragma mark - Life cycle#pragma mark - Event response#pragma mark - Getter and setter#pragma mark - Private methods#pragma mark - Public methods#pragma mark - UITableViewDelegate#pragma mark - UITableViewDataSource 在viewDidload里面只做addSubview的事情，在viewDidLoad里面开一个layoutPageSubviews的方法，在这个里面创建Constraints并添加，在viewDidAppear里面做Notification的监听之类的事情。所有的属性都使用getter和setter，并且全部都放在最后。 我觉得作者说的还是有道理的，虽然某些getter一定会用到，再做一层懒加载貌似显得冗余，但是从结构上看更清晰。 2，公有特性面向切片编程 什么是切片？程序要完成一件事情，一定会有一些步骤，1，2，3，4这样。这里分解出来的每一个步骤我们可以认为是一个切片。 什么是面向切片编程？你针对每一个切片的间隙，塞一些代码进去，在程序正常进行1，2，3，4步的间隙可以跑到你塞进去的代码，那么你写这些代码就是面向切片编程。 为什么会出现面向切片编程？你要想做到在每一个步骤中间做你自己的事情，不用AOP也一样可以达到目的，直接往步骤之间塞代码就好了。但是事实情况往往很复杂，直接把代码塞进去，主要问题就在于：塞进去的代码很有可能是跟原业务无关的代码，在同一份代码文件里面掺杂多种业务，这会带来业务间耦合。为了降低这种耦合度，我们引入了AOP。 如何实现AOP？Method Swizzling或者protocol的方式来实现拦截器（beforePerform、afterPerform） 使用AOP而非继承来实现公有特性。比如每个ViewController都有一个通用的navigationHeaderBar: @implementation YAObjectIntercepter+ (void)load &#123; [YAObjectIntercepter sharedInstance];&#125;+ (instancetype)sharedInstance &#123; static dispatch_once_t onceToken; static YAObjectIntercepter *sharedInstance; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [YAObjectIntercepter new]; &#125;); return sharedInstance;&#125;- (instancetype)init &#123; if (self = [super init]) &#123; // 方法拦截 [UIViewController aspect_hookSelector:@selector(viewDidLoad) withOptions:AspectPositionBefore usingBlock:^(id &lt;AspectInfo&gt; aspectInfo)&#123; [self viewDidLoadWithViewController:[aspectInfo instance]]; &#125; error:NULL]; &#125; return self;&#125;#pragma mark - fake methods- (void)viewDidLoadWithViewController:(UIViewController *)viewController &#123; if ([viewController isKindOfClass:UIViewController.class] &amp;&amp; [NSStringFromClass(viewController.class) hasPrefix:@"YA"]) &#123; viewController.view.backgroundColor = UIColor.whiteColor; viewController.navigationHeaderBar.backgroundColor = UIColor.whiteColor; [viewController.view addSubview:viewController.navigationHeaderBar]; viewController.navigationHeaderBar.frame = CGRectMake(0, kIPHONEX_TOP, kScreenWidth, kNavigationBarHeight); [viewController.navigationHeaderBar.leftButton setBackgroundImage:[UIImage imageNamed:@"feed_back"] forState:UIControlStateNormal]; [viewController.navigationHeaderBar.leftButton setBackgroundImage:[UIImage imageNamed:@"feed_back"] forState:UIControlStateHighlighted]; [viewController.navigationHeaderBar.leftButton addTarget:viewController action:@selector(popViewControllerWithAnimation) forControlEvents:UIControlEventTouchUpInside]; &#125;&#125;@end 3，网络层设计 1，网络层数据通信以Delegate为主，Notification为辅（网络信号从2G变成3G变成4G变成Wi-Fi）。2，提供reformer机制来处理网络层反馈的数据，交付NSDictionary给业务层，使用Const字符串作为Key来保持可读性。3，网络层上部分使用离散型设计，下部分使用集约型设计。设计合理的继承机制，让派生出来的APIManager受到限制，避免混乱。关于集约型的API调用和离散型的API调用，我倾向于这样：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约化的手段组装请求，放飞请求，然而业务方调用API的时候，则是以离散的API调用方式来调用。如果你的App只提供了集约化的方式，而没有离散方式的通道，那么我建议你再封装一层，便于业务方使用离散的API调用方式来放飞请求。 大型App可以使用封装AFN的YTKNetwork，而小型App由于API少，参数不复杂，很多就直接使用一个类，暴露Get和Post接口就可以了。 下层：统一接口，以离散型封装AFNetworkingtypedef NSString *YAServerInterfaceName;// 首页Feed接口extern YAServerInterfaceName const kYAServerInterfaceFeed;// 搜索接口extern YAServerInterfaceName const kYAServerInterfaceSearch;@interface YANetworkManager : NSObject+ (instancetype)manager;- (NSURLSessionDataTask *)requestWithInterfaceName:(YAServerInterfaceName)interfaceName parameters:(NSDictionary *)parameters progress:(void (^)(NSProgress *))downloadProgress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure;@end 把接口以及公共参数进行封装，避免散落一地。使用时只需要传入InterfaceName即可。每个业务都可以有自己的manager，成功或者失败回调以block的形式回传，供各个业务自己发挥。 上层：统一APIManager，以集约型的delegate进行回调/// API manager的基类@interface YABaseAPIManager : NSObject@property (nonatomic, assign) BOOL noMoreData;- (void)fetchNetworkDataWithParameters:(NSDictionary *)parameters;- (void)cancelPreviousRequest;@end BaseAPIManager负责派生各个业务的APIManager，提供数据请求及取消数据请求接口。BaseAPIManager还约定了子类需要实现的方法：成功回调、失败回调、以及接口名称。具体请求的参数怎么配置、成功回调怎么处理、失败回调怎么处理都由子类决定。 @protocol YABaseAPIManagerChildProtocol &lt;NSObject&gt;@required- (YAServerInterfaceName)interfaceName;- (void)APIManager:(YABaseAPIManager *)manager finishedWithFailedError:(NSError *)error;- (void)APIManager:(YABaseAPIManager *)manager finishedWithSuccessResult:(id)result;@end 4，从MVC、MVVM到去Model化MVCM应该做的事：给ViewController提供数据；给ViewController存储数据提供接口；提供经过抽象的业务基本组件，供Controller调度； C应该做的事：管理View Container的生命周期；负责生成所有的View实例，并放入View Container；监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务； V应该做的事：响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等；界面元素表达 MVVM在MVC的基础上，把C拆出一个ViewModel专门负责数据处理的事情，就是MVVM。然后，为了让View和ViewModel之间能够有比较松散的绑定关系，于是我们使用ReactiveCocoa，因为苹果本身并没有提供一个比较适合这种情况的绑定方法。iOS领域里KVO，Notification，block，delegate和target-action都可以用来做数据通信，从而来实现绑定，但都不如ReactiveCocoa提供的RACSignal来的优雅，如果不用ReactiveCocoa，绑定关系可能就做不到那么松散那么好，但并不影响它还是MVVM。 去Model化保留原始数据，定义reform协议，遵守该协议的对象来处理manager的原始数据，处理后的数据依然是字典或者数组。 @protocol YAFeedReformerProtocol &lt;NSObject&gt;- (NSArray *)reformData:(id)data manager:(YAFeedAPIManager *)manager;@end 每类数据对应一个Reformer：extern NSString * const kPropertyListDataKeyFeedID; ///&lt; idextern NSString * const kPropertyListDataKeyFeedThumbUrl; ///&lt; 拇指图urlextern NSString * const kPropertyListDataKeyFeedSmallUrl; ///&lt; 小图urlextern NSString * const kPropertyListDataKeyFeedRegularUrl; ///&lt; 常规图url@interface YAFeedReformer : NSObject &lt;YAFeedReformerProtocol&gt;@end 根据字典的key可以直接使用:- (void)setPhotoInfo:(NSDictionary *)photoInfo &#123; NSURL *url = nil; if (YASettingManager.columnCount &lt;= 2) &#123; url = [NSURL URLWithString:photoInfo[kPropertyListDataKeyFeedRegularUrl]]; &#125; // ...&#125; 5，网络优化针对链接建立环节的优化 使用缓存手段减少请求的发起次数（API名字和参数拼成一个字符串然后取MD5作为key，存储对应返回的数据） 使用策略来减少请求的发起次数（下拉刷新、条件筛选取消原先存在的请求，用户日志满足一定数量再上传） 针对DNS域名解析做的优化原因：API请求在DNS解析阶段的耗时会很多（网络信号源会经常变换、自己的App所做的DNS缓存会被别的DNS缓存给挤出去被清理掉、墙 这三个原因造成链路的DNS缓存很快失效相当于没有，于是直接走IP请求，绕过DNS服务的耗时）方案：本地有一份IP列表，这些IP是所有提供API的服务器的IP，每次应用启动的时候，针对这个列表里的所有IP取ping延时时间，然后取延时时间最小的那个IP作为今后发起请求的IP地址。一般都是在应用启动的时候获得本地列表中所有IP的ping值，然后通过NSURLProtocol的手段将URL中的HOST修改为我们找到的最快的IP。另外，这个本地IP列表也会需要通过一个API来维护，一般是每天第一次启动的时候读一次API，然后更新到本地。 针对链接传输数据量的优化压缩。 针对链接复用的优化HTTP/2.0。 判断API的调用请求是来自于经过授权的APP？设计签名服务端需要给你一个密钥，每次调用API时，你使用这个密钥再加上API名字和API请求参数算一个hash出来，然后请求的时候带上这个hash。服务端收到请求之后，按照同样的密钥同样的算法也算一个hash出来，然后跟请求带来的hash做一个比较，如果一致，那么就表示这个API的调用者确实是你的APP。为了不让别人也获取到这个密钥，你最好不要把这个密钥存储在本地，直接写死在代码里面就好了。另外适当增加一下求Hash的算法的复杂度，那就是各种Hash算法（比如MD5）加点盐，再回炉跑一次Hash啥的。这样就能解决第一个目的了：确保你的API是来自于你自己的App。 网络优化在Splash上的实践主要是ip直连。Casa前辈给出了NSEtcHosts，但是它处理NSURLConnection，过时了，我学习借鉴写了个NSURLSession版本的。当然，思路都是一样的，自定义NSURLProtocol。增加了一点点功能： 支持HTTPS 直连ip失败后自动切回host 支持AFN @protocol YAHostsConfiguration// 配置host与IP的映射- (void)resolveHostName:(NSString *)hostName mapIPAddress:(NSString *)IPAddress;@end@interface YADomainURLProtocol : NSURLProtocol+ (void)configureHostsWithBlock:(void (^)(id &lt;YAHostsConfiguration&gt; configuration))block;@end@interface YAHostsConfiguration : NSObject &lt;YAHostsConfiguration&gt;@property (nonatomic, strong) NSMutableDictionary *mutableIPAddressesByHostName;- (NSString *)IPAddressForHostName:(NSString *)hostName;@end@implementation YAHostsConfiguration- (instancetype)init &#123; if (self = [super init]) &#123; _mutableIPAddressesByHostName = [NSMutableDictionary dictionary]; &#125; return self;&#125;- (NSString *)IPAddressForHostName:(NSString *)hostName &#123; return self.mutableIPAddressesByHostName[hostName.lowercaseString];&#125;- (void)resolveHostName:(NSString *)hostName mapIPAddress:(NSString *)IPAddress &#123; self.mutableIPAddressesByHostName[hostName.lowercaseString] = IPAddress;&#125;@endstatic NSString * const kURLProtocolHostModifiedKey = @"kURLProtocolHostModifiedKey";@interface YADomainURLProtocol () &lt;NSURLSessionTaskDelegate&gt;@property (atomic, strong, readwrite) NSURLSession *session;@end@implementation YADomainURLProtocol+ (YAHostsConfiguration *)sharedConfiguration &#123; static YAHostsConfiguration * sharedConfiguration = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedConfiguration = [YAHostsConfiguration new]; &#125;); return sharedConfiguration;&#125;+ (void)configureHostsWithBlock:(void (^)(id &lt;YAHostsConfiguration&gt; configuration))block &#123; if (block) block([self sharedConfiguration]);&#125;+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; BOOL isHttp = [request.URL.scheme caseInsensitiveCompare:@"http"] == NSOrderedSame; BOOL isHttps = [request.URL.scheme caseInsensitiveCompare:@"https"] == NSOrderedSame; if (isHttp || isHttps) &#123; // 没有处理过且有映射 if (![self propertyForKey:kURLProtocolHostModifiedKey inRequest:request] &amp;&amp; [[self sharedConfiguration] IPAddressForHostName:request.URL.host]) &#123; YALog(@"命中ip直连"); return YES; &#125; return NO; &#125; return NO;&#125;+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123; // 容错 if (request.URL.host.length == 0) return request; NSMutableURLRequest *mutableRequest = [request mutableCopy]; NSURLComponents *URLComponents = [NSURLComponents componentsWithString:mutableRequest.URL.absoluteString]; URLComponents.scheme = @"https"; URLComponents.host = [[self sharedConfiguration] IPAddressForHostName:URLComponents.host]; mutableRequest.URL = [URLComponents URL]; [self setProperty:@(YES) forKey:kURLProtocolHostModifiedKey inRequest:mutableRequest]; // 设置原先的host [mutableRequest setValue:request.URL.host forHTTPHeaderField:@"host"]; return mutableRequest;&#125;- (void)startLoading &#123; self.session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration ephemeralSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue new]]; [[self.session dataTaskWithRequest:self.request] resume];&#125;- (void)stopLoading &#123; [self.session finishTasksAndInvalidate]; self.session = nil;&#125;#pragma mark - NSURLSessionDataDelegate- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; if (error) &#123; // 加载完成: error回调 [self.client URLProtocol:self didFailWithError:error]; // 出错: 取消ip直连 NSString *host = [self.request valueForHTTPHeaderField:@"host"]; [YADomainURLProtocol sharedConfiguration].mutableIPAddressesByHostName[host.lowercaseString] = nil; &#125; else &#123; // 加载完成: success回调 [self.client URLProtocolDidFinishLoading:self]; &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123; // 接收response回调 [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]; completionHandler(NSURLSessionResponseAllow);&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; // 接收数据回调 [self.client URLProtocol:self didLoadData:data];&#125;#pragma mark - 证书// https: 证书- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential *))completionHandler &#123; if (!challenge) return; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; NSURLCredential *credential = nil; NSString *host = [self.request.allHTTPHeaderFields objectForKey:@"host"]; if (!host) host = self.request.URL.host; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust] &amp;&amp; [self createServerTrust:challenge.protectionSpace.serverTrust forDomain:host]) &#123; disposition = NSURLSessionAuthChallengeUseCredential; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; completionHandler(disposition, credential);&#125;// 创建证书校验策略- (BOOL)createServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain &#123; NSMutableArray *policies = [NSMutableArray array]; if (domain) &#123; [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)]; &#125; else &#123; [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; &#125; // 绑定校验策略到服务端的证书上 SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); SecTrustResultType result; CFErrorRef error; SecTrustEvaluate(serverTrust, &amp;result); return (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);&#125;@end 只需要这么使用：[NSURLProtocol registerClass:YADomainURLProtocol.class];[YADomainURLProtocol configureHostsWithBlock:^(id&lt;YAHostsConfiguration&gt; configuration) &#123; [configuration resolveHostName:@"www.baidu.com" mapIPAddress:@"220.181.38.150"];&#125;]; 对于AFN，配置configuration即可NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];configuration.protocolClasses = @[YADomainURLProtocol.class];AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithSessionConfiguration:configuration]; 6，持久化持久化方案有哪些？ NSUserDefault： 小规模数据，弱业务相关数据，都可以放到NSUserDefault里面，内容比较多的数据，强业务相关的数据就不太适合NSUserDefault了。 Keychain ： Keychain是苹果提供的带有可逆加密的存储机制，普遍用在各种存密码的需求上。另外，由于App卸载只要系统不重装，Keychain中的数据依旧能够得到保留，以及可被iCloud同步的特性，大家都会在这里存储用户唯一标识串。所以有需要加密、需要存iCloud的敏感小数据，一般都会放在Keychain。 文件存储：文件存储包括了Plist、archive、Stream等方式，一般结构化的数据或者需要方便查询的数据，都会以Plist的方式去持久化。Archive方式适合存储平时不太经常使用但很大量的数据，或者读取之后希望直接对象化的数据，因为Archive会将对象及其对象关系序列化，以至于读取数据的时候需要Decode很花时间，Decode的过程可以是解压，也可以是对象化，这个可以根据具体中的实现来决定。Stream就是一般的文件存储了，一般用来存存图片啊啥的，适用于比较经常使用，然而数据量又不算非常大的那种。 数据库存储：苹果自带了一个Core Data，其他还有FMDB。数据库方案主要是为了便于增删改查，当数据有状态和类别的时候最好还是采用数据库方案比较好。因为你不可能通过文件系统遍历文件去甄别你需要获取的属于某个状态或类别的数据，这么做成本就太大了。当然，特别大量的数据也不适合直接存储数据库，比如图片或者文章这样的数据，一般来说，都是数据库存一个文件名，然后这个文件名指向的是某个图片或者文章的文件。如果真的要做全文索引这种需求，建议最好还是挂个API丢到服务端去做。 上面是前辈总结的面试题答案😂 接下来是持久化的实践：与以往不同的是，之前采用MVC或者MVVM模式，存在数据库的是Model，而现在去Model化了，存原始数据呢，还是存Reform之后的数据。我选择存储原始数据，原因有二：1，Reformer有多个，但是原始数据只有一份，只存储一份原始数据避免冗余。2，如果存储原始数据，那从数据库取出的数据和从网络获取的数据，格式将会是一样的，只需要一种处理方式。 怎么存储？每条photo信息中的photo_id作为主键，再加上时间戳用于筛选，photo_content自然就是存储的原始信息了：CREATE TABLE IF NOT EXISTS "t_photoList" ("photo_id" text,"photo_content" text,"photo_date" INTEGER,PRIMARY KEY("photo_id")); 这样职责更清晰了：APIManager负责从网络或者数据库取数据以及持久化数据，Reformer只负责格式化APIManager的数据。对于控制器来说，它做的也很简单了：- (void)feedAPIDidSuccessWithManager:(YAFeedAPIManager *)manager isNewData:(BOOL)isNewData &#123; NSArray &lt;NSDictionary *&gt; *array = [manager fetchDataWithReformer:self.feedReformer]; if (isNewData) &#123; [self.photoArray removeAllObjects]; [self.refreshHeader endRefreshing]; &#125; [self.photoArray addObjectsFromArray:array]; if (manager.noMoreData) &#123; // 没有更多数据 [self.refreshFooter endRefreshingWithNoMoreData]; &#125; else &#123; [self.refreshFooter endRefreshing]; &#125; [self.feedCollectionView reloadData];&#125; 7，动态部署方案（1）Web App其实所谓的web app，就是通过手机上的浏览器进行访问的H5页面。这个H5页面是针对移动场景特别优化的，比如UI交互等。 优点无需走苹果流程，所有苹果流程带来的成本都能避免，包括审核周期、证书成本等。版本更新跟网页一样，随时生效。不需要Native App工程师的参与，而且市面上已经有很多针对这种场景的框架。 缺点重度依赖网络环境、流畅度不如Native、很难做好本地持久化（只能提供账户体系，对应账户的持久化数据全部存在服务端）、即时响应方案、远程通知实现方案、移动端传感器的使用方案复杂，维护难度大。安全问题，H5页面等于是所有东西都暴露给了用户，如果对安全要求比较高的，很多额外的安全机制都需要在服务端实现。 总结web app一般是创业初期会重点考虑的方案，因为迭代非常快，而且创业初期的主要目标是需要验证模式的正确性，并不在于提供非常好的用户体验，只需要完成闭环即可。 （2）Hybrid App通过市面上各种Hybrid框架，来做H5和Native的混合应用，或者通过JS Bridge来做到H5和Native之间的数据互通。 优点除了要承担苹果流程导致的成本以外，具备所有web app的优势、能够访问本地数据、设备传感器等 缺点跟web app一样存在过度依赖网络环境的问题、用户体验也很难做到很好、安全性问题依旧存在、大规模的数据交互很难实现，例如图片在本地处理后，将图片传递给H5 总结Hybrid方案更加适合跟本地资源交互不是很多，然后主要以内容展示为主的App。在天猫App中，大量地采用了JS Bridge的方式来让H5跟Native做交互，因为天猫App是一个以内容展示为主的App，且营销活动多，周期短，比较适合Hybrid。 （3）React-Native 优点响应速度很快，只比Native慢一点，比webview快很多。能够做到一定程度上的动态部署 缺点组装页面的元素需要Native提供支持，一定程度上限制了动态部署的灵活性。 总结由于View的展示和View的事件响应分属于不同的端，展示部分的描述在JS端，响应事件的监听和描述都在Native端，通过Native转发给JS端。所以，从做动态部署的角度上讲，React-Native只能动态部署新View，不能动态部署新View对应的事件。View的原型需要从Native中取，以后某个页面需要添加某个复杂的view的时候，需要从现有的组件中拼装。它解决的是如何不使用Objc/Swift来写iOS App的View的问题，对于如何通过不发版来给已发版的App更新功能这样的问题，帮助有限。 （4）Lua PatchwaxPatch的主要原理是通过lua来针对objc的方法进行替换，由于lua本身是解释型语言，可以通过动态下载得到，因此具备了一定的动态部署能力。然而iOS系统原生并不提供lua的解释库，所以需要在打包时把lua的解释库编译进app。 优点能够通过下载脚本替换方法的方式，修改本地App的行为。执行效率较高 缺点对于替换功能来说，lua是很不错的选择。但如果要添加新内容，实际操作会很复杂，很容易改错，小问题变成大问题 总结lua的解决方案在一定程度上解决了动态部署的问题。实际操作时，一般不使用它来做新功能的动态部署，主要还是用于修复bug时代码的动态部署。 （5）Javascript Patch这个工作原理其实跟上面说的lua那套方案的工作原理一样，只不过是用javascript实现。 优点打包时不用将解释器也编译进去，iOS自带JavaScript的解释器。 缺点同Lua方案的缺点 总结在对app打补丁的方案中，目前我更倾向于使用JSPatch的方案，在能够完成Lua做到的所有事情的同时，还不用编一个JS解释器进去，而且会javascript的人比会lua的人多，技术储备比较好做。 （6）JSON Descripted View使用JSON来描述一个View应该有哪些元素，以及元素的位置，以及相关的属性，比如背景色，圆角等等。然后本地有一个解释器来把JSON描述的View生成出来。这跟React-Native有点儿像，一个是JS转Native，一个是JSON转Native。但是同样有的问题就是事件处理的问题，在事件处理上，React-Native做得相对更好。因为JSON不能够描述事件逻辑，所以JSON生成的View所需要的事件处理都必须要本地事先挂好。 优点能够自由生成View并动态部署 缺点天猫实际使用下来，发现还是存在一定的性能问题，不够快事件需要本地事先写好，无法动态部署事件 总结其实JSON描述的View比React-Native的View有个好处就在于对于这个View而言，不需要本地也有一套对应的View，它可以依据JSON的描述来自己生成。然而对于事件的处理是它的硬伤，所以JSON描述View的方案，一般比较适用于换肤，或者固定事件不同样式的View，比如贴纸。 作者总结地实在是太全面太好了（崇拜脸😁）。目前来看，使用比较广泛的是JS Patch。手百参考了一下它的原理，自己又写了一个，用于热修复，之前老板让调研过，最近用了几次。 在Splash中目前还没有实践热更新方案。 三、总结1.0.0版本已经发布了，但是最近开发人员注册好像出了点问题，付款老是失败，然后就没上线。 github放这了：https://github.com/chenYalun/Splash]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程与Runloop拾遗]]></title>
    <url>%2F2019%2F09%2F30%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8ERunloop%E6%8B%BE%E9%81%97%2F</url>
    <content type="text"><![CDATA[回顾了多线程、Runloop相关的重点知识。 比较零碎。 多线程基本首先简单回顾几个常见的术语：同步：只能在当前线程中执行任务，不具备开启新线程的能力。在队列里面的任务完成之前会一直等待。异步：可以在新的线程中执行任务，具备开启新线程的能力。它不会做任何等待，可以继续执行任务。串行：一个任务执行完毕后，再执行下一个任务。并发：多个任务并发（同时）执行，并发队列的并发功能只有在异步函数下才有效。 自己创建的串行队列（非主队列），使用异步方式，会开启新线程执行任务。并发队列下的异步方式，会开启新线程，并发执行任务。 死锁dispatch_sync类型主队列下的同步执行，会产生死锁。 // 在主线程执行task方法- (void)task &#123; NSLog(@"a任务"); dispatch_sync(dispatch_get_main_queue(), ^&#123; // 追加到主队列中按照顺序执行 NSLog(@"b任务"); &#125;); NSLog(@"c任务");&#125; 因为是同步执行，所以c任务需要等待b任务执行完毕之后才可以执行；又因为是主队列且a任务和c任务都要在主线程执行，所以b任务需要等待（a任务和）c任务执行完毕之后才可以执行；这样a任务与c任务互相等待产生了死锁。 再比如知识小集中的一个例子：dispatch_queue_t queue = dispatch_queue_create("com.app.test", NULL);dispatch_async(queue, ^&#123; dispatch_sync(queue, ^&#123; // 向串行队列queue中追加任务B NSLog(@"B任务"); &#125;); NSLog(@"A任务");&#125;); 向串行队列queue中追加任务B，B任务需要等待A任务执行完毕才能执行，由于是串行队列下的同步执行，A任务需要等待B任务执行完毕才能执行，二者互相等待产生死锁。 可以总结，使用sync函数向当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）。 dispatch_once类型void test() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; test(); &#125;); printf("This is a test");&#125; dispatch_once的递归调用也会产生死锁。 onceToken在第一次执行block之前，其值将由NULL变为指向第一个调用者的指针(&amp;dow)。如果在block完成之前，有其它的调用者进来，则会把这些调用者放到一个waiter链表中(走else分支)，直到block执行完成。waiter链中的每个调用者都会等待一个信号量(dow.dow_sema)。在block执行完成后，除了将onceToken置为DISPATCH_ONCE_DONE外，还会去遍历waiter链中的所有waiter，抛出相应的信号量，以告知waiter们调用结束。递归调用test()时，第二次调用作为一个waiter，在等待block完成，而block的完成依赖于test()的执行完成，这就成了一个死锁。 下一篇文章看一下GCD源码吧。。 dispatch_applytutuge介绍了一个例子： dispatch_queue_t queue = dispatch_queue_create("com.app.test", DISPATCH_QUEUE_SERIAL);dispatch_apply(3, queue, ^(size_t i) &#123; NSLog(@"apply loop outside %zu", j); // 死锁 dispatch_apply(3, queue, ^(size_t j) &#123; NSLog(@"apply loop inside %zu", j); &#125;);&#125;); dispatch_apply是将block追加到指定的Queue中执行指定次数，并等待全部block执行完毕，也即它用的是dispatch_sync。这自然解释了为啥会死锁了。官方文档上苹果推荐的使用方式是配合dispatch_get_global_queue全局队列。 线程同步iOS中的线程同步方案有很多： OSSpinLock（自旋锁，忙等） os_unfair_lock（休眠，iOS10+） pthread_mutex（互斥锁，可递归，可条件，休眠） dispatch_semaphore（信号量） dispatch_queue(DISPATCH_QUEUE_SERIAL)（串行同步） NSLock（封装mutex） NSRecursiveLock（封装mutex递归锁） NSCondition（封装mutex条件锁） NSConditionLock（封装NSCondition，可设置条件值） @synchronized（封装mutex递归锁，语法简单） ibireme在《不再安全的OSSpinLock》中介绍了自旋锁（比如OSSpinLock）优先级翻转的问题：假定有优先级较高的线程a，优先级较低的线程b，一开始由线程b执行任务，则加锁，线程a处于忙等状态。但是由于线程a的优先级较高，获得的时间片也较多，那么线程b的时间片比较少，可能一直无法往下执行，无法释放锁。于是造成线程a一直处于忙等状态，而优先级较低的线程b却在一直执行任务，便出现了优先级反转。当使用互斥锁时就不会有这种问题：线程a不会忙等，而是休眠，也即不会占用CPU资源，这样线程b的任务很快执行完毕并释放锁，线程a的任务就得到执行了。 什么情况使用自旋锁比较划算？ 预计线程等待锁的时间很短 加锁的代码（临界区）经常被调用，但竞争情况很少发生 CPU资源不紧张 多核处理器 什么情况使用互斥锁比较划算？ 预计线程等待锁的时间较长 单核处理器 临界区有IO操作 临界区代码复杂或者循环量大 临界区竞争非常激烈 在开发中常用的是信号量，性能较高（次于OSSpinLock和os_unfair_lock）且方便。 存取方法加锁nonatomic与atomic是很常见的话题。atomic保证了getter和setter的原子性，方法内部是线程安全的。但是不能保证使用属性过程中的线程安全。而大多数情况下，需要保证“使用属性过程中的线程安全”。所以，这就造成我们经常选择nonatomic：1， 项目中有太多的属性设置取值操作，每次都加锁，消耗性能；2， 并不是每个属性取值设值操作都需要加锁的，完全可以在真正需要的地方自己加锁； 对于属性来说，最理想的自然是读操作，允许多条线程并发执行，写操作，同一时刻只能一条线程执行。实现方案有两种，读写锁pthread_rwlock或者GCD中的dispatch_barrier_async。个人喜欢第二种。@synthesize name = _name;- (void)setName:(NSString *)name &#123; dispatch_barrier_sync(self.propertyQueue, ^&#123; if (name != _name) &#123; _name = name; &#125; &#125;);&#125;- (NSString *)name &#123; __block NSString *name = nil; dispatch_sync(self.propertyQueue, ^&#123; name = _name; &#125;); return name;&#125; Runloop原理Runloop与线程每条线程都有唯一的一个与之对应的RunLoop对象，RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value。线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建，会在线程结束时销毁。主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop。 Runloop的ModeCFRunLoopModeRef代表RunLoop的运行模式。一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer。RunLoop启动时只能选择其中一个Mode，作为currentMode如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入（这样做可以保证专心处理一个Mode下的事件）。不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响。如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出。 kCFRunLoopDefaultMode是App的默认Mode，通常主线程是在这个Mode下运行。UITrackingRunLoopMode是界面跟踪 Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响。 Mode下的Source0/Source1/Timer/ObserverSource0 触摸事件处理 performSelector:onThread: Source1 基于Port的线程间通信（比如不同线程间的Notification） 系统事件捕捉 Timers NSTimer performSelector:withObject:afterDelay:（内部也是定时器） Observers 用于监听RunLoop的状态 UI刷新（BeforeWaiting） Autorelease pool（BeforeWaiting） Runloop的内部逻辑01、通知Observers：进入Loop02、通知Observers：即将处理Timers03、通知Observers：即将处理Sources04、处理Blocks05、处理Source0（可能会再次处理Blocks）06、如果存在Source1，就跳转到第8步07、通知Observers：开始休眠（等待消息唤醒）08、通知Observers：结束休眠（被某个消息唤醒） （01）&gt; 处理Timer （02）&gt; 处理GCD Async To Main Queue （03）&gt; 处理Source109、处理Blocks10、根据前面的执行结果，决定如何操作 （01）&gt; 回到第02步 （02）&gt; 退出Loop11、通知Observers：退出Loop Runloop状态监听 // 创建ObserverCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch (activity) &#123; case kCFRunLoopEntry: &#123; CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent()); NSLog(@"kCFRunLoopEntry - %@", mode); CFRelease(mode); break; &#125; case kCFRunLoopExit: &#123; CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent()); NSLog(@"kCFRunLoopExit - %@", mode); CFRelease(mode); break; &#125; default: break; &#125;&#125;);// 添加Observer到RunLoop中CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);// 释放CFRelease(observer); 休眠的实现原理依靠mach_msg()函数，做到用户态处理消息，内核态等待消息，没有消息就让线程休眠。 应用1，控制线程周期借助Runloop实现线程保活：@interface YAPermenantThread()@property (nonatomic, strong) NSThread *innerThread;@end@implementation YAPermenantThread- (instancetype)init &#123; if (self = [super init]) &#123; _innerThread = [[NSThread alloc] initWithBlock:^&#123; CFRunLoopSourceContext context = &#123;0&#125;; CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &amp;context); CFRelease(source); // 第3个参数：returnAfterSourceHandled，设置为true，代表执行完source后就会退出当前loop CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, false); &#125;]; [_innerThread start]; &#125; return self;&#125;- (void)dealloc &#123; [self stop];&#125;- (void)executeTask:(void (^)(void))task &#123; if (!self.innerThread || !task) return; [self performSelector:@selector(executeInnerTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];&#125;- (void)stop &#123; if (!self.innerThread) return; [self performSelector:@selector(stopThread) onThread:self.innerThread withObject:nil waitUntilDone:YES];&#125;#pragma mark - private methods- (void)stopThread &#123; CFRunLoopStop(CFRunLoopGetCurrent()); self.innerThread = nil;&#125;- (void)executeInnerTask:(void (^)(void))task &#123; if (task) task();&#125;@end 2，解决NSTimer在UIScrollView滑动时停止工作修改Runloop的Mode即可。 3，监控应用卡顿常见原因：死锁：主线程拿到锁 A，需要获得锁 B，而同时某个子线程拿了锁 B，需要锁 A，这样相互等待就死锁了。抢锁：主线程需要访问 DB，而此时某个子线程往 DB 插入大量数据。通常抢锁的体验是偶尔卡一阵子，过会就恢复了。主线程大量 IO：主线程为了方便直接写入大量数据，会导致界面卡顿。主线程大量计算：算法不合理，导致主线程某个函数占用大量 CPU。大量的 UI 绘制：复杂的 UI、图文混排等，带来大量的 UI 绘制。 主线程绝大部分计算或者绘制任务都是以Runloop为单位发生。单次Runloop如果时长超过16ms，就会导致UI体验的卡顿。 ——by mrpeak前辈 方案一创建一个子线程，监控主线程的活动情况，如果发现有卡顿，就将堆栈dump下来。如何监控？主要利用Runloop状态监听，kCFRunLoopExit的时间，减去kCFRunLoopEntry的时间，获得一次Runloop所耗费的时间。实际上，主线程的RunLoop是在应用启动时自动开启的，主线程中的block、交互事件、以及其他任务都是在kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting之间执行，所以可以在即将开始执行Sources时，记录一下起始时间，并标记任务状态为YES，将要进入睡眠状态时，标记置为NO。 第一种方式是添加一个定时器，设定为2秒一次回调，也即每隔2秒计算一下时间差看是否会有卡顿发生。有同学已经给出了方法。 每次定时器回调时，若任务状态仍然为YES（说明Runloop在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间），则判断时间有没有超过阈值： static void RunLoopTimerCallBack(CFRunLoopTimerRef timer, void *info) &#123; YAFluencyMonitorManager *manager = (__bridge YAFluencyMonitorManager *)info; if (!manager.excuting) return; NSTimeInterval excuteTime = [NSDate.date timeIntervalSinceDate:manager.startDate]; if (excuteTime &gt;= manager.fault) &#123; NSLog(@"线程卡顿了%f秒", excuteTime); [manager handleStackInfo]; &#125;&#125; 比如，我从数据库中读出1000条数据，再把这1000条数据写到数据库中，这些操作都在主线程进行，利用第三方框架CrashReporter可以看到函数调用栈： Thread 0:0 libsystem_kernel.dylib 0x00000001874cb42c fsync + 81 libsqlite3.dylib 0x00000001893549ec sqlite3_randomness + 25202 libsqlite3.dylib 0x000000018934a780 sqlite3_free_table + 620083 libsqlite3.dylib 0x0000000189335d0c sqlite3_value_text + 235044 libsqlite3.dylib 0x0000000189301f44 sqlite3_finalize + 36085 libsqlite3.dylib 0x000000018932e774 sqlite3_step + 608286 libsqlite3.dylib 0x000000018931fb5c sqlite3_step + 3887 FMDB 0x00000001051b39d0 -[FMDatabase executeUpdate:error:withArgumentsInArray:orDictionary:orVAList:] + 31528 FMDB 0x00000001051b4038 -[FMDatabase executeUpdate:] + 969 FMDB 0x00000001051b4ab8 -[FMDatabase commit] + 4810 FMDB 0x00000001051bb270 __46-[FMDatabaseQueue beginTransaction:withBlock:]_block_invoke + 59211 libdispatch.dylib 0x00000001053d2bd8 _dispatch_client_callout + 1612 libdispatch.dylib 0x00000001053e1858 _dispatch_lane_barrier_sync_invoke_and_complete + 12413 FMDB 0x00000001051bafd8 -[FMDatabaseQueue beginTransaction:withBlock:] + 17614 FMDB 0x00000001051bb2dc -[FMDatabaseQueue inTransaction:] + 8015 Splash 0x0000000104cb0be4 +[YAFeedPhotoDBManager savePhotoListToDataBase:] + 38816 Splash 0x0000000104c9f380 __65-[YAFeedAPIManager parseAPIManager:successResult:isFromDataBase:]_block_invoke + 8017 Splash 0x0000000104cb09d8 __73+[YAFeedPhotoDBManager loadPhotoListWithStartTime:limitCount:completion:]_block_invoke + 6018 libdispatch.dylib 0x00000001053d17fc _dispatch_call_block_and_release + 2419 libdispatch.dylib 0x00000001053d2bd8 _dispatch_client_callout + 1620 libdispatch.dylib 0x00000001053e0c34 _dispatch_main_queue_callback_4CF + 131621 CoreFoundation 0x000000018764f3a8 &lt;redacted&gt; + 1222 CoreFoundation 0x000000018764a39c &lt;redacted&gt; + 200423 CoreFoundation 0x00000001876498a0 CFRunLoopRunSpecific + 46424 GraphicsServices 0x00000001915a1328 GSEventRunModal + 10425 UIKitCore 0x000000018b73a740 UIApplicationMain + 193626 Splash 0x0000000104cac944 main + 12027 libdyld.dylib 0x00000001874d4360 &lt;redacted&gt; + 4 可以看到，问题就在+[YAFeedPhotoDBManager savePhotoListToDataBase:]这行代码了。 方案二第二种方式主要是对检测粒度的改进。比如，卡顿阈值T=500ms、卡顿次数N=1，可以判定为单次耗时较长的一次有效卡顿；而卡顿阈值T=50ms、卡顿次数N=5，可以判定为频次较快的一次有效卡顿。这样就需要对每次Runloop时间段做处理。minjing_linlv同学有给出Demo，作者没有使用定时器来定时监测卡顿状况，而是“实时计算两个状态区域之间的耗时是否到达某个阀值”。 把代码down下来试了一试，发现作者是把卡顿耗时和卡顿次数两个条件综合起来判断的，耗时的实现是利用dispatch_semaphore_wait函数，设置了超时参数。 不过代码这块有几个地方值得商榷：1，子线程卡顿监控最好开一个独立的常驻线程，而作者却用了一个全局队列。2，“发生一次有效的卡顿回调函数”，设置这种接口而且暴露给外界不知道意义何在，发生卡顿难道不是这个单例自己处理并上报吗？3，在setter方法中手动调用willChangeValueForKey和didChangeValueForKey，貌似是为了手动触发KVO，但是却又不重写automaticallyNotifiesObserversForName方法，那这么做图啥？ 只看作者思路，这种方式较方案一显得细腻，还是挺棒的。 方案三其实最棒的还是《微信iOS卡顿监控系统》这篇文章介绍的。 总结一下key point：1，CPU 占用超过了100%和主线程 Runloop 执行了超过2秒综合起来判断是一次卡顿发生了（需要双核iPhone）。2，遇到相同的卡顿堆栈，按照斐波那契数列将检查时间递增，避免同一个卡顿写入多个文件，也避免检测线程围着同一个卡顿空转。3，主要根据堆栈的最内层归类，这样能够将同一原因的卡顿归类起来。4，抽样上报，减小后台压力。 4，应用起死回生App出现异常后，手动创建一个循环，在这个循环里面跑Runloop的所有mode。主要就是下面这段代码：// 取出runLoop所有运行的modeNSArray *allModes = CFBridgingRelease(CFRunLoopCopyAllModes(CFRunLoopGetCurrent()));while (1) &#123; for (NSString *mode in allModes) &#123; //在每个 mode 中轮流运行至少0.001 秒 CFRunLoopRunInMode((CFStringRef)mode, 0.001, false); &#125;&#125; 但是，如果在自己手动创建的循环里面又一次出现crash，那神仙也没办法了。 整理一下，是这样：@interface YACrashHandlerManager ()@property (nonatomic, assign) BOOL shouldIgnore;@end@implementation YACrashHandlerManager- (void)handleException:(NSException *)exception &#123; NSString *message = [NSString stringWithFormat:@"崩溃原因如下:\n%@\n%@", [exception reason], [[exception userInfo] objectForKey:kCaughtExceptionStackInfoKey]]; NSLog(@"%@",message); // 弹出弹窗, 设置shouldIgnore的值 // .... NSArray *allModes = CFBridgingRelease(CFRunLoopCopyAllModes(CFRunLoopGetCurrent())); while (!self.shouldIgnore) &#123; for (NSString *mode in allModes) &#123; CFRunLoopRunInMode((CFStringRef)mode, 0.001, false); &#125; &#125; configCatchExceptionHandler(YES); if ([[exception name] isEqual:kSignalExceptionName]) &#123; kill(getpid(), [[[exception userInfo] objectForKey:kSignalKey] intValue]); &#125; else &#123; [exception raise]; &#125;&#125;@endstatic NSArray *getBacktrace() &#123; void *callstack[128]; int frames = backtrace(callstack, 128); char **strs = backtrace_symbols(callstack, frames); NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames]; for (int i = 0; i &lt; frames; i++) &#123; [backtrace addObject:[NSString stringWithUTF8String:strs[i]]]; &#125; free(strs); return backtrace;&#125;static void configCatchExceptionHandler(BOOL isNil) &#123; void (*handler)(int) = SIG_DFL; NSUncaughtExceptionHandler *exc = NULL; if (!isNil) &#123; handler = signalHandler; exc = &amp;handleException; &#125; NSSetUncaughtExceptionHandler(exc); signal(SIGABRT, handler); signal(SIGILL, handler); signal(SIGSEGV, handler); signal(SIGFPE, handler); signal(SIGBUS, handler); signal(SIGPIPE, handler);&#125;static void handleException(NSException *exception) &#123; NSException *customException = [NSException exceptionWithName:[exception name] reason:[exception reason] userInfo:@&#123;kCaughtExceptionStackInfoKey: [exception callStackSymbols]&#125;]; [[YACrashHandlerManager sharedManager] performSelectorOnMainThread:@selector(handleException:) withObject:customException waitUntilDone:YES];&#125;static void signalHandler(int signal) &#123; NSString *stack = [NSString stringWithFormat:@"%@", getBacktrace()]; NSException *customException = [NSException exceptionWithName:kSignalExceptionName reason:[NSString stringWithFormat:NSLocalizedString(@"Signal %d was raised.", nil), signal] userInfo:@&#123;kSignalKey:[NSNumber numberWithInt:signal], kCaughtExceptionStackInfoKey: stack&#125;]; [[YACrashHandlerManager sharedManager] performSelectorOnMainThread:@selector(handleException:) withObject:customException waitUntilDone:YES];&#125; 自实现这篇文章有空写一点，结果发出来都12月份了。太忙了，hold不住。。。立个flag，2020年Q1自实现一个Runloop。 网上搜了几篇很棒的文章：iOS 并发编程之 Operation QueuesiOS 多线程编程知识整理iOS 多线编程之线程安全谈 iOS 的锁@synchronized，这儿比你想知道的还要多Threading Programming Guide(2)RunLoop 源码阅读RunLoop深入学习笔记]]></content>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中的Crash防护]]></title>
    <url>%2F2019%2F09%2F11%2FiOS%E4%B8%AD%E7%9A%84Crash%E9%98%B2%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[避免App crash。 App的质量评测主要有两个关注点，一个是Crash，另一个是卡顿。手百已经建立了卡顿监测平台，主要是通过监测主线程的Runloop的状态切换耗时实现。对于Crash只做了收集，及时报告给个业务方，但并没有“防护”平台（貌似由于种种原因目前还没有完成）。假如需要做一个简单的crash防护措施，该怎么着手呢？ 《大白健康系统–iOS APP运行时Crash自动修复系统》这篇文章总结地很不错了，网上很多组件都是根据这篇文章开发的（手百内部也有参考）。本文在前辈们的基础上，简单叙述下自己的想法。 一、常见Crash类型1. unrecognized selector crashunrecognized selector sent to instance类型的crash是比较常见的，原因是没有找到方法的实现。H5与NA交互时，别人难免会调错；项目在合并分支、重构等大改动的时候也难免不小心把方法的实现删掉了（这种情况俺遇到好多次了==）。这类crash的防护是最有意义的，一来解决了体验问题，二来只是添加一个单纯的实现，一般不会影响其他功能和数据。 根据消息机制，resolveInstanceMethod需要在类中提前加上，略显冗余；forwardInvocation需要创建NSInvocation，开销较大且常被外界重写以转发消息。最适合的还是forwardingTargetForSelector。 需要考虑的有： 防护实例方法和类方法。 防护的方法要可供选择，如白名单，或者前缀等（避免影响其他业务方）。 获取crash的函数调用栈以供追踪。 不能影响已重写了forwardInvocation:方法（含实例方法和类方法）的类。 第一条，方法交换时传入类对象或者元类对象即可；第二条，可以获取当前的classString进行定制化判断；第三条，[NSThread callStackSymbols]可以获取调用栈；第四条，可以参考KVO中判断willChangeValueForKey:是否已被重写的逻辑—比较IMP是否一致。也即比较NSObject和当前类中的forwardInvocation:方法的IMP是否一致；当然，需要对-forwardInvocation:和+forwardInvocation:区分； 这样，首先添加一个继承自NSObject的target，重写resolveInstanceMethod和resolveClassMethod以添加空白的方法实现：forwardingTargetDynamicMethod。这里也是获取调用栈的好时机：#define kYACurrentCallStackSymbols [NSString stringWithFormat:@"%@",[NSThread callStackSymbols]]@interface YAForwardingTarget : NSObject@end@implementation YAForwardingTargetstatic inline void forwardingTargetDynamicMethod(id self, SEL _cmd) &#123;&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; class_addMethod(self.class, sel, (IMP)forwardingTargetDynamicMethod, "v@:"); [super resolveInstanceMethod:sel]; NSLog(@"Unrecognized instance Method: %@\n调用栈是:%@", NSStringFromSelector(sel), kYACurrentCallStackSymbols); return YES;&#125;+ (BOOL)resolveClassMethod:(SEL)sel &#123; class_addMethod(object_getClass(self), sel, (IMP)forwardingTargetDynamicMethod, "v@:"); [class_getSuperclass(self) resolveClassMethod:sel]; NSLog(@"Unrecognized class Method: %@\n调用栈是:%@", NSStringFromSelector(sel), kYACurrentCallStackSymbols); return YES;&#125;@end 利用方法交换，在NSObject的分类中hook forwardingTargetForSelector:方法处理转发逻辑：@interface NSObject (YAResolveUnrecognizedSelector)@end@implementation NSObject (YAResolveUnrecognizedSelector)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; ya_methodSwizzle(self.class, @selector(forwardingTargetForSelector:), @selector(swizzleForwardingTargetForSelector:)); ya_methodSwizzle(object_getClass(self), @selector(forwardingTargetForSelector:), @selector(swizzleForwardingTargetForSelector:)); &#125;);&#125;#define swizzleForwardingTargetForSelector(arg) \arg (id)swizzleForwardingTargetForSelector:(SEL)aSelector &#123; \ id result = [self swizzleForwardingTargetForSelector:aSelector]; \ if (result) return result; \ NSString *classString = NSStringFromClass(object_getClass(self)); \ BOOL isClsMethod = [@#arg isEqualToString:@"+"]; /* 区分类方法和实例方法 */\ Class currCls = isClsMethod ? object_getClass(self) : self.class;\ Class oriCls = isClsMethod ? object_getClass(NSObject.class) : NSObject.class;\ IMP currentImp = class_getMethodImplementation_stret(currCls, @selector(forwardInvocation:));\ IMP originImp = class_getMethodImplementation_stret(oriCls, @selector(forwardInvocation:));\ /* 也可以添加白名单. */ \ if ([classString hasPrefix:@"YA"] &amp;&amp; currentImp == originImp) &#123; \ /* 避免crash. */\ return isClsMethod ? YAForwardingTarget.class : [YAForwardingTarget new]; \ &#125; else &#123; \ return nil; /* 抛出异常. */ \ &#125; \&#125; \// Class method and instance method.swizzleForwardingTargetForSelector(+)swizzleForwardingTargetForSelector(-)#undef swizzleForwardingTargetForSelector@end 在获取到classString时，可以根据下发的白名单判断是否需要防护，当然也可以直接判断前缀，只防护自己业务的方法。 2. 容器 crash再一个比较常见的就是容器crash，比如向NSMutableArray中添加空元素抛出异常。这种crash看似很低级，但却防不胜防。当向一个数组中添加元素时，需要由开发者考虑这个元素有没有可能为空，如果有，做空值判断；如果没有，直接添加即可。但是这种“考虑”往往不是百分百可靠的。最保险的办法是对所有被添加的元素都做空值判断，可是项目中的容器何其多，每次都要if判断，是否有性能方面的影响呢？这就是另一种权衡了。 现在不考虑那么多，假定需要对NSMutableArray的addObject做防护，最简单的是添加一个safe方法：@implementation NSMutableArray (YAResolveNilObject)- (void)ya_addObject:(id)anObject &#123; if (anObject) &#123; [self addObject:anObject]; &#125;&#125;@end 之后使用时只需要使用ya_addObject:就行了。当然最优雅的还是进行hook，让外界继续使用原生方法：@implementation NSMutableArray (YAResolveNilObject)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; ya_methodSwizzle(NSClassFromString(@"__NSArrayM"), @selector(addObject:), @selector(ya_addObject:)); &#125;);&#125;- (void)ya_addObject:(id)anObject &#123; if (anObject) &#123; [self ya_addObject:anObject]; &#125; else &#123; NSLog(@"防护了"); &#125;&#125;@end 需要注意的是Array系列是类簇，直接hook NSMutableArray是无法成功的，需要hook对外隐藏的实际起作用的类：__NSArrayM。还有就是如果要考虑线程安全的话，自己再通过加锁来保证（这种case较少，建议单独写一个线程安全的addObject，一股脑全都加锁实在没有必要）。不然 if (anObject)判断时发现为YES，而到addObject:时，anObject又为空了，十分尴尬。 除了addObject时的判空，还有objectAtIndex时的range判断，也需要处理。 NSMutableArray是这样，那NSMutableSet、NSMutableDictionary、NSCache等类也好说了。 3. KVO crashKVO引起crash有两种场景：1，observer已经销毁，但是未及时移除监听；2，addObserver与removeObserver不匹配（重复添加或移除、没有添加却移除等）； 预防从“预防”层面讲，可以使用KVO的第三方框架：KVOController。1，使用单例接管了系统的observeValueForKeyPath方法，通过它再来分发调用。如果observer已经销毁，则不再回调（block），解决了第一个问题；2，只有addObserver接口，其内部依赖容器避免外界重复addObserver，没有暴露removeObserver接口，解决了第二个问题； 而且KVOController极其优雅，只调用一个方法就可以完成一个对象的键值观测。更多介绍可以查看draveness大神的文章：《如何优雅地使用 KVO》，当然也可以简单参考下俺写的水文《「KVOController」的封装》。 防护好了，预防层面有办法解决了，那防护层面呢？“observer已经销毁，但是未及时移除监听”，针对这个问题很自然地想到在observer的dealloc方法中做移除监听操作。这种做法的思路是：1， hook addObserver方法，object为key，keyPath数组作为value，与observer建立关系，大致是这种结构：observer1: &#123; object1: ["keyPath1", "keyPath2"], object2: ["keyPath3", "keyPath4"], ///....&#125;,observer2: &#123; object3: ["keyPath5", "keyPath6"], object4: ["keyPath7", "keyPath8"], ///....&#125; 2， hook observer的dealloc方法，在这里面逐个移除object的keyPath监听：// observer1[object1 removeObserver:self forKeyPath:keyPath1];[object1 removeObserver:self forKeyPath:keyPath2];[object2 removeObserver:self forKeyPath:keyPath3];[object2 removeObserver:self forKeyPath:keyPath4];// observer2/// ... 具体代码实现层面，NSMapTable可以支持直接使用对象（object）作为key；keyPath的重复过滤可以使用NSMutableSet；可以使用一个标志位判断是否重复添加或者移除； hook后的addObserver方法：- (void)ya_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context &#123; BOOL shouldAddObserver = YES; NSString *observerKey = [NSString stringWithFormat:@"%p", observer]; if (!mainMap) &#123; mainMap = [NSMutableDictionary dictionary]; &#125; NSMapTable *subMap = [mainMap objectForKey:observerKey]; if (!subMap) &#123; subMap = [NSMapTable strongToStrongObjectsMapTable]; NSMutableSet *set = [NSMutableSet setWithObject:keyPath]; [subMap setObject:set forKey:self]; &#125; else &#123; NSMutableSet *set = [subMap objectForKey:self]; if ([set containsObject:keyPath]) &#123; // 重复addObserver shouldAddObserver = NO; &#125; [set addObject:keyPath]; &#125; [mainMap setObject:subMap forKey:observerKey]; if (shouldAddObserver) &#123; [self ya_addObserver:observer forKeyPath:keyPath options:options context:context]; &#125;&#125; 同理，removeObserver原理大致相同，就不再复述了。 hook后的dealloc方法：- (void)ya_dealloc &#123; NSString *selfKey = [NSString stringWithFormat:@"%p", self]; NSMapTable *subMap = [mainMap objectForKey:selfKey]; if (subMap) &#123; [[[subMap keyEnumerator] allObjects] enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSSet *set = [subMap objectForKey:object]; [set enumerateObjectsUsingBlock:^(NSString *key, BOOL * _Nonnull stop) &#123; [object removeObserver:self forKeyPath:key]; &#125;]; // 移除keyPath [subMap removeObjectForKey:object]; &#125;]; // 移除subMap [mainMap removeObjectForKey:selfKey]; &#125; [self ya_dealloc];&#125; 但是这种方式有个问题：hook dealloc方法风险极大，因为这个方法关乎App中所有对象的释放，代码一旦有瑕疵，后果不堪设想。子线程调用、hook方式正确与否都会产生潜在的风险，应该尽量避免这种风险极大的操作。那还有其他方式能在对象销毁之前做点事吗？有的。关联对象。一个对象在dealloc之前会移除自己的所有关联对象，我们可以自定义一个对象，将其作为NSObject的关联对象，同时在这个自定义对象的dealloc方法中做上面的操作。为了避免循环引用，自定义的对象不能强引用NSObject，但是使用weak的话，在实践中会发现被关联的NSObject已经销毁了，根本获取不到，所以这里使用unsafe_unretained。/// 被关联的对象@interface YAKVOInfoObject : NSObject// 注意使用unsafe_unretained修饰@property (nonatomic, unsafe_unretained) id object;@end@implementation YAKVOInfoObject- (void)dealloc &#123; @autoreleasepool &#123; id observer = self.object; NSString *observerKey = [NSString stringWithFormat:@"%p", observer]; NSMapTable *subMap = [mainMap objectForKey:observerKey]; if (subMap) &#123; [[[subMap keyEnumerator] allObjects] enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSSet *set = [subMap objectForKey:object]; [set enumerateObjectsUsingBlock:^(NSString *key, BOOL * _Nonnull stop) &#123; [object removeObserver:observer forKeyPath:key]; &#125;]; // 移除keyPath [subMap removeObjectForKey:object]; &#125;]; // 移除subMap [mainMap removeObjectForKey:observerKey]; &#125; &#125;;&#125;@end/// 分类，用于设置关联对象@implementation NSObject (YAKVOInfoObject)- (void)ya_setKVOInfoObject:(YAKVOInfoObject *)object &#123; objc_setAssociatedObject(self, "ya_kVOInfoObject", object, OBJC_ASSOCIATION_RETAIN);&#125;@end 这样一来似乎更体面一点了，设置关联对象的时机自然是在成功addObserver的时候，而且每个对象只需要设置一次即可。 需要注意的是，由于需要严格依赖observer的dealloc方法，如果系统的自动释放池出现了延时释放，会导致observer被销毁之后过一段时间关联对象才会释放，这时候使用unsafe_unretained访问的就是非法地址。所以需要在关联对象的dealloc方法中添加上自己的自动释放池。这一点我确实没有想到，请参考这篇文章。 到这里，removeObserver的时机已经搞定了，至于对这些keyPath和object的保存，可以参考上面的代码使用全局的容器，当然也可以把它们放在关联对象YAKVOInfoObject中存储。还有一种方式，是使用代理，不过我想了一下，要是使用代理，首先要设置observer的delegate为object，然后还要在observer销毁的时候移除delegate（也就是object）的keyPath监听，但是keyPath需要保存，observer销毁的时机同样需要hook，似乎observer与object只是多了一层直接联系，并且把结构搞得更加复杂了。。。 至于未及时移除NSNotificationCenter的监听产生的crash在iOS9之后已经不存在了，而且我在《NSNotificationCenter探索》这篇文章中还利用弱引用容器简单实现了个demo，即便不移除也不会产生异常，作为练习之用。目前App的最低版本已经是iOS9了，不过还是建议addObserver后能有对应的removeObserver，有头有尾，严谨一些。当然，要是铁了心非要对它加上防护，原理与KVO这个类似，或者说更简单了，毕竟不需要保存keyPath、object之类的。 4. NSTimer crashNSTimer会强引用着target，target往往也需要强引用着NSTimer，容易产生循环引用，引发内存泄漏进而可能产生crash问题（ps：CADisplayLink同理，推荐使用不依赖Runloop更准时的dispatch_source_t）。 可以举个循环引用的例子：控制器强引用着YASinger对象，YASinger对象强引用着NSTimer。当控制器调用self.singer = nil;的时候，会发现sing方法依然在不停调用。可见，NSTimer内部又强引用着YASinger对象，二者是循环引用，控制器把YASinger对象的引用计数减1并不能使得它及时销毁。 @interface YASinger : NSObject@property (nonatomic, strong) NSTimer *timer;@end@implementation YASinger- (void)sing &#123; NSLog(@"YASinger show");&#125;- (void)dealloc &#123; [self.timer invalidate];&#125;@end- (void)startTask &#123; YASinger *singer = [YASinger new]; singer.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:singer selector:@selector(sing) userInfo:nil repeats:YES]; self.singer = singer;&#125; 一般解决NSTimer的循环引用问题有三种方法。 方法一使用block作为中间件，可以参考BlocksKit2.2.5的实现：@implementation NSTimer (BlocksKit)+ (id)bk_scheduledTimerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)(NSTimer *timer))block repeats:(BOOL)inRepeats&#123; NSParameterAssert(block != nil); return [self scheduledTimerWithTimeInterval:inTimeInterval target:self selector:@selector(bk_executeBlockFromTimer:) userInfo:[block copy] repeats:inRepeats];&#125;+ (id)bk_timerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)(NSTimer *timer))block repeats:(BOOL)inRepeats&#123; NSParameterAssert(block != nil); return [self timerWithTimeInterval:inTimeInterval target:self selector:@selector(bk_executeBlockFromTimer:) userInfo:[block copy] repeats:inRepeats];&#125;+ (void)bk_executeBlockFromTimer:(NSTimer *)aTimer &#123; void (^block)(NSTimer *) = [aTimer userInfo]; if (block) block(aTimer);&#125;@end NSTimer实例对象直接强引用着NSTimer的类对象（单例），通过持有block再间接持有外界的target。这样NSTimer与target的引用问题就转化为NSTimer的block与target的引用问题。而这类问题是我们非常熟悉的，可以通过weakSelf-strongSelf解决：- (void)startTask &#123; YASinger *singer = [YASinger new]; self.singer = singer; __weak YASinger *weakSinger = singer; singer.timer = [NSTimer bk_scheduledTimerWithTimeInterval:1 block:^(NSTimer *timer) &#123; __strong YASinger *singer = weakSinger; [singer sing]; &#125; repeats:YES];&#125; 方法二使用继承自NSObject的对象作为中间件，弱引用着target：@interface YAWeakTarget : NSObject@property (nonatomic, weak) id target;@property (nonatomic, assign) SEL selector;@property (nonatomic, strong) NSTimer *timer;;@end@implementation YAWeakTarget- (void)timerTask:(NSTimer *)timer &#123; if (self.target) &#123; [self.target performSelector:self.selector withObject:timer.userInfo]; &#125; else &#123; [self.timer invalidate]; &#125;&#125;@end 由YAWeakTarget保存着target、selector和timer，并负责间接调用target的selector方法。使用的时候，统一调用YAWeakTarget的timerTask:方法：- (void)startTask &#123; YASinger *singer = [YASinger new]; self.singer = singer; YAWeakTarget *weakTarget = [YAWeakTarget new]; weakTarget.target = singer; weakTarget.selector = @selector(sing); weakTarget.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:weakTarget selector:@selector(timerTask:) userInfo:@&#123;&#125; repeats:YES];&#125; 一图胜千言： 打破循环引用的根本原因是NSTimer的invalidate方法得到执行。NSTimer在其invalidate方法调用后，Runloop会自动移除对它的引用，它也会移除对target和userInfo的强引用。 weakTarget一旦发现YASinger为nil，就会调用定时器的invalidate方法。因此，weakTarget强引用着timer也是没关系的（也就是图中的蓝线）。 方法三使用继承自NSProxy的对象作消息转发：forwardInvocation:和methodSignatureForSelector:两个基本方法必须实现。在这基础上，加上自己需要的。@interface YAProxy : NSProxy@property (nonatomic, weak) id target;@end@implementation YAProxy- (instancetype)initWithTarget:(id)target &#123; _target = target; return self;&#125;- (BOOL)respondsToSelector:(SEL)aSelector&#123; return [self.target respondsToSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)invocation&#123; if ([self.target respondsToSelector:invocation.selector]) &#123; [invocation invokeWithTarget:self.target]; &#125;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; return [self.target methodSignatureForSelector:aSelector];&#125;@end 使用的时候，这么做就行了：- (void)startTask &#123; YASinger *singer = [YASinger new]; self.singer = singer; singer.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:[[YAProxy alloc] initWithTarget:singer] selector:@selector(sing) userInfo:@&#123;&#125; repeats:YES];&#125; 这三种方法就个人而言，我更喜欢方法三。方法一需要时刻牢记weak-strong，影响代码美观；方法二不优雅，还要引入中间件。方法三中的Proxy专门做消息转发，而且复用性强，并不单单针对NSTimer的循环引用问题。 如此，根本方法有了，剩下的就是做相关方法的hook工作了，不再赘述。 5. Bad Access crash这种crash产生的原因是向已经销毁的对象发送消息。类型很常见，但是却又比较难排查。防护层面也是有办法的，原理是hook 需要监测的对象的dealloc方法，不让它释放内存（避免调用dealloc方法），并修改它的isa指针从而把之后的消息转发给固定的对象。 假定需要监测“YA”打头的所有对象：@implementation NSObject (YAResolveZombie)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; ya_methodSwizzle(NSObject.class, NSSelectorFromString(@"dealloc"), @selector(ya_dealloc)); &#125;);&#125;- (void)ya_dealloc &#123; NSString *clsName = NSStringFromClass(self.class); if ([clsName hasPrefix:@"YA"]) &#123; // 修改isa指针 object_setClass(self, YAZombieInfoObject.class); // 记录类信息 objc_setAssociatedObject(self, "ya_className", clsName, OBJC_ASSOCIATION_COPY_NONATOMIC); &#125; else &#123; // 其他对象正常调用dealloc [self ya_dealloc]; &#125;&#125;@end 而这个YAZombieInfoObject对象是现成的（我看有文章使用动态生成class，确实没有必要），类似unrecognized selector crash的防护，记录类名、方法名、调用栈等信息即可。由于类对象是单例，所以只需要防护实例对象（实例方法）就行了。 @interface YAZombieInfoObject : NSObject@end@implementation YAZombieInfoObjectstatic inline void forwardingTargetDynamicMethod(id self, SEL _cmd) &#123; NSString *clsName = objc_getAssociatedObject(self, "ya_className"); NSLog(@"Class name is %@, zombie instance Method is %@, \n调用栈是:%@",clsName, NSStringFromSelector(_cmd), kYACurrentCallStackSymbols);&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; class_addMethod(self.class, sel, (IMP)forwardingTargetDynamicMethod, "v@:"); [super resolveInstanceMethod:sel]; return YES;&#125;@end 这种方法有几个点需要考虑：1，被监测对象的范围怎么衡量，是所有自定义的类吗？2，被监测对象延迟释放会占用内存，内存限制多少合适？3，被监测对象最终还是调要dealloc的，什么时机比较合适？4，这种方法hook了dealloc方法，会不会有潜在的危险？ 预防为主，下面简单列举几个这种类型的例子吧。 block为nilvoid (^block)() = nil;block(); 一般是新人才犯这种错误。block在执行之前一定要判空，不然会造成程序读取内存地址时出错。 使用条件运算符可以使风格更加优雅：!block ?: block(); 指针传递未判空BOOL saveText(NSString *text, NSError **error) &#123; // 保存文本却失败了 // ... // 传递error *error = [NSError errorWithDomain:@"error" code:-1 userInfo:nil]; return NO;&#125; saveText(@"test", nil); 同样地，指针不做判空也是会出问题。 assgin修饰对象@property (nonatomic, assign) NSString *cuid; 这种错误一般是在复制、粘贴的时候没仔细review造成的，一旦出问题也很严重，而且排查起来极其蛋疼。。。 self提前释放为了保证性能，self的修饰是__unsafe_unretained而不是strong（一般情况下调用方都不会在方法执行时把这个对象释放所以不增加引用计数）。这就有可能造成方法还没有执行完毕，而自己（self）被释放掉，从而产生坏内存访问。 比如孙源大神文章中的例子 @class YARequest;@protocol YARequestDelegate &lt;NSObject&gt;- (void)requestFinished;@end@interface YARequest : NSObject@property (nonatomic, weak) id &lt;YARequestDelegate&gt; delegate;@end@implementation YARequest- (void)start &#123; [self.delegate requestFinished]; NSLog(@"%@", self); // EXC_BAD_ACCESS&#125;@end 控制器中的方法：static YARequest *gRequest;// 开始执行- (void)start &#123; gRequest = [YARequest new]; gRequest.delegate = self; [gRequest start];&#125;// 代理- (void)requestFinished &#123; gRequest = nil; NSLog(@"请求执行完毕");&#125; 很容易就发现EXC_BAD_ACCESS了。原因是在YARequest的代理方法中，控制器把YARequest置为nil了。这就造成继续在start方法中访问self产生了问题。 注意：这里的gRequest对象，直接使用了全局变量而不是属性。如果使用属性的getter取值，对象作为返回值会自动被auto release，引用计数会被干扰，就没办法复现了。 这个case出现的可能性比较低，但是也值得注意的。 快速遍历下的__autoreleasing指向引用类型指针的指针作为参数传递时，是使用__autoreleasing修饰的。比如NSFileManager中的删除文件方法：removeItemAtURL:(NSURL *)url error:(NSError *__autoreleasing *)error;当这种指针遇见enumerateObjectsUsingBlock时，金风玉露一相逢，就该出问题了。比如这个例子，看着没毛病，其实是有问题的： // 解决方法: void enumerateArray(__strong NSError **error) &#123;void enumerateArray(NSError **error) &#123; NSArray *array = @[@1, @2, @3, @4, @5]; [array enumerateObjectsUsingBlock:^(NSNumber *obj, NSUInteger idx, BOOL *stop) &#123; NSLog(@"%@", obj); if (idx == 0 &amp;&amp; error) &#123; *error = [NSError errorWithDomain:@"error" code:-1 userInfo:nil]; &#125; &#125;];&#125;int main(int argc, const char * argv[]) &#123; NSError *error = nil; enumerateArray(&amp;error); if (error) &#123; NSLog(@"%@", error); &#125; return 0;&#125; 当然，编译器也会警告的：Block captures an autoreleasing out-parameter, which may result in use-after-free bugs。 __autoreleasing修饰时，会把外界的这个对象放到自动释放池中，可是enumerateObjectsUsingBlock恰恰是会自己创建自动释放池的，这样一来，*error被创建之后在下次迭代之前就已经销毁了。于是外界访问已经释放的*error自然会出错了。解决这个问题也很简单，改为__strong修饰即可。 两个小点：1、enumerateObjectsUsingBlock内部会自己创建自动释放池，for循环、for in循环是没有这个能力的。因为这是属于C语言的语法，自然不存在自动释放池的概念。不过要是自己手动添加@autoreleasepool{}，那就又另说了。2、关于为啥指向引用类型的指针的指针默认是使用__autoreleasing修饰的，这个我觉得和引用类型的返回值需要被添加到自动释放池中是同样的道理：本来自己作用域内retain的对象就应该自己把它release，但是偏偏这个对象要延长它的生命周期以供外界使用，所以就需要被添加到autoreleasepool中延迟release了。 IMP调用坏内存：SEL sel = @selector(showText:);IMP imp = [self.target methodForSelector:sel]; // self.target为nilid (*func)(id, SEL, id) = (void *)imp;func(self, sel, @"text"); 正常：SEL sel = @selector(showText:);IMP imp = [self.target methodForSelector:sel];id (*func)(id, SEL, id) = (void *)imp;if (func) func(self, sel, @"text"); 当直接使用函数指针调用方法时，倘若获取的imp为nil而直接调用也会产生异常。比如当self.target返回nil时，就会造成imp也为nil。这时候做一个判空再好不过了。 6. 其他类型的crash还有几个我见过的crash，一并分享一下，以后慢慢补充： 遍历数组的同时移除数组元素NSMutableArray *array = [NSMutableArray arrayWithArray:@[@1, @2, @3, @4, @5]];for (NSNumber *num in array) &#123; if ([num isEqualToNumber:@1]) &#123; [array removeObject:num]; &#125;&#125; 使用逆序遍历可以解决：for (NSNumber *num in array.reverseObjectEnumerator) &#123; if ([num isEqualToNumber:@1]) &#123; [array removeObject:num]; &#125;&#125; 为啥使用逆序遍历就能解决问题呢？因为正序遍历时，移除元素会造成没有遍历的元素的索引发生异常，而逆序遍历时，索引改变的是遍历过的元素，而没有遍历到的元素索引却没有改变，自然索引也不会越界了。 还有一点，这个reverseObjectEnumerator目前还是好使的，往后好不好使不好说的： In Objective-C, it is not safe to modify a mutable collection while enumerating through it. Some enumerators may currently allow enumeration of a collection that is modified, but this behavior is not guaranteed to be supported in the future. 非法数值CGFloat width = 100.0;CGFloat height = 0.0;CGFloat scale = width / height;UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, width, height * scale)]; 一个非法的数值在传来传去传到UIView的frame上的时候，就该出问题了：&#39;CALayer bounds contains NaN: [0 0; 100 nan].。判断数值的合法性可以使用isnan()函数和isinf()函数。遇到除法的时候，一定要做个判断。 二、小结这篇文章写得很是随意，简单描述了自己的想法却没有给出完整的解决方案。Crash防护在一定程度上是有意义的，能增强用户体验，但是还有几个问题需要考虑的： Crash防护原理大多是hook系统方法，那是否会对App产生性能或者速度方面的影响，尤其是亿万级别的App？比如是做速度优化的核心方法？ 发生Crash一定是App出现异常情况了，系统把它杀死也是一种保护机制。倘若执意让App继续运行，会不会造成数据异常、界面异常？ Crash防护只能算作一个兜底策略，目前来说，很多问题可以通过热修复解决，更有针对性。当然，最核心最重要的是小伙伴们都有良好的编程习惯，仔细review。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C设计指北]]></title>
    <url>%2F2019%2F08%2F22%2FObjective-C%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[尝试回答“给你 C 语言，如何实现一个 Objective-C”。 孙源大神在他的文章中留下了这样一道问题：假如非要让我考一道 Runtime 的题，可能是“给你 C 语言，如何实现一个 Objective-C？”，答到哪儿算哪儿。 这篇文章尝试做一点解答，也整体复习一下Objective-C。 一、类与对象对象/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;; Objective-C实例对象的本质是结构体，混沌初开的时候，其内部有且只有一个成员：Class类型的isa。isa是一个指向objc_class结构体的指针，在arm64上占用8个字节，在armv7上占用4个字节（本文都按照64位平台来说的）。一个NSObject对象只有这一个成员变量，理论上也只需要8个字节，但是通过memory read可以知道系统给它分配了16个字节。查看源码发现allocWithZone最终调用到instanceSize()函数时，为了内存对齐，限制了一个对象的最小占用内存为16个字节。同时，这也是为了呼应“操作系统的内存对齐”：给一个对象分配的字节数量为16的倍数。 size_t instanceSize(size_t extraBytes) &#123; // 内存对齐之后的大小 size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. if (size &lt; 16) size = 16; return size;&#125; 在arm64架构之前，isa是一个普通的指针，直接指向类对象或者元类对象的内存地址。从arm64架构开始，isa被优化为一个共用体，使用位域把诸多信息存储在8个字节的方寸之间。 union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL struct &#123; uintptr_t nonpointer : 1; // 1表示优化过的isa指针 uintptr_t has_assoc : 1; // 是否有设置过关联对象 uintptr_t has_cxx_dtor : 1; // 是否有C++的析构函数 uintptr_t shiftcls : 33; // 类对象或者元类对象地址 uintptr_t magic : 6; // 是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否有弱引用指向过 uintptr_t deallocating : 1; // 是否正在dealloc uintptr_t has_sidetable_rc : 1; // 引用计数是否过大使得无法存储在isa中， // 如果是则引用计数存储在SideTable中 uintptr_t extra_rc : 19; // 里面存储的值是引用计数减去1 &#125;;&#125; 这时候使用掩码进行按位与运算就可以计算出它的类对象或者元类对象的地址。# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# endifNSObject *obj = [NSObject new];// (lldb) p/x (long)obj-&gt;isa// (long) $3 = 0x001dffff9da71141 Class cls = [NSObject class];// (lldb) p/x (long)obj.class// (long) $5 = 0x00007fff9da71140// (lldb) p/x (0x001dffff9da71141 &amp; 0x00007ffffffffff8ULL)// (unsigned long long) $7 = 0x00007fff9da71140 每个实例对象生而不同，自己的成员变量理所应当地存储在每一个实例对象中，而方法具有唯一性，同一个类实例化的所有的对象应当共享一份对象方法。自然，对象方法应该存储在“类”中，这个“类”，就是类对象。除了对象方法之外还有类方法，就像全局函数，类方法存储在元类对象中。 成员变量与属性声明一个YAPerson类，并填充一些成员变量、属性、实例方法和类方法。@interface YAPerson : NSObject &#123; @public uint age; NSString *nickname; @private BOOL isRich;&#125;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign, readonly) BOOL isMale;@end@implementation YAPerson- (void)singWithSongName:(NSString *)songName &#123; NSLog(@"I'm singing a song named %@", songName);&#125;+ (BOOL)canWork &#123; return YES;&#125;@end 创建一个YAPerson实例，它包含了继承自NSObject的成员变量isa和自有的成员变量。它的结构是这样的：struct YAPerson_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; // Class isa; uint age; NSString *nickname; BOOL isRich; BOOL _isMale; NSString *_name;&#125;; 迫于结构体内存对齐、系统内存对齐以及一个对象最小16个字节的限制，YAPerson实例占用48个字节。 当创建一个实例对象时，由于消息机制，类方法“new”的调用实际上是被转换为objc_msgSend()函数调用，消息接收者是类对象。而调用实例方法也是通过objc_msgSend()函数，只不过第一个参数是具体的实例对象。这里的字符串@&quot;Love&quot;会被编译器优化为常量字符串，直接取地址使用了。 [jack singWithSongName:@"Love"];objc_msgSend(jack, sel_registerName("singWithSongName:"), (NSString *)&amp;__NSConstantStringImpl__var_xxxxxx); 当对实例对象的属性进行赋值时，点语法会被编译器转化为setter方法，最后还是调用objc_msgSend()函数：objc_msgSend(jack, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_xxxxxxxxx); 当对实例对象的成员变量赋值时就比较有趣了，jack-&gt;age = 23;，大致是这种效果：#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)unsigned long int OBJC_IVAR_$_YAPerson$age = __OFFSETOFIVAR__(struct YAPerson, age);uint *ageOffset = (uint *)((char *)jack + OBJC_IVAR_$_YAPerson$age);(*ageOffset) = 23; 首先通过__OFFSETOFIVAR__宏，获取成员变量age在YAPerson_IMPL结构体中的偏移量：8个字节（isa占用8个字节），并把它存储为全局的常量，接着根据实例对象jack的地址加上成员变量age的偏移量获取age的地址，最后对age进行赋值。这些在编译的时候，就已经确定了，也即根本不需要通过jack-&gt;age = 23;这样的指针调用。一个成员变量的结构是这样的： struct ivar_t &#123; int32_t *offset; // pointer to ivar offset location const char *name; const char *type; uint32_t alignment_raw; // alignment is sometimes -1; use alignment() instead uint32_t int size; // 占用字节 uint32_t alignment() const &#123;#ifdef __LP64__# define WORD_SHIFT 3UL#else# define WORD_SHIFT 2UL#endif if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT; return 1 &lt;&lt; alignment_raw; &#125;&#125; ageIvar = &#123;(unsigned long int *)&amp;OBJC_IVAR_$_YAPerson$age, "age", "I", 2, 4&#125;; 由于偏移量是全局的常量，所以使用int32_t *类型的offset存储这个偏移量的地址，而不是使用int32_t存储这个偏移量的值。name和type描述了成员变量的名称与类型，alignment的值取决于成员变量类型和机器架构，它的最小值为2的n次方。size是该类型变量占用字节。 编译时确定偏移量的原因是这样： In the modern runtime, if you change the layout of instance variables in a class, you do not have to recompile classes that inherit from it.在程序启动后，runtime加载类的时候，通过计算基类的大小，runtime动态调整了类成员变量布局。于是我们的程序无需编译，就能在新版本系统上运行。变量地址 = 对象地址 + ivar.offsetivar.offset = 基类地址(动态) + ivar在本类中的偏移量(编译时固定) 动态创建一个类，添加成员变量的时候我们会用到这些信息：class_addIvar(myClass, "someIvar", sizeof(int), log2(_Alignof(int)), @encode(int)) 这个函数只能用在动态创建类的时候。类一旦定义完毕就无法再（在分类中）添加成员变量，因为“类中成员变量的偏移量是由基类大小和本类中成员变量共同决定的，如果一个类添加了成员变量，size发生了变化，会导致子类无法工作”。 一个类的所有成员变量信息汇聚在一起就成为了成员变量列表struct ivar_list_t，它在内存中只需要一份：static struct &#123; unsigned int entsize; // sizeof(struct _prop_t) unsigned int count; // 数量 struct ivar_t ivar_list[6]; // 成员变量数组&#125; _OBJC_$_INSTANCE_VARIABLES_YAPerson = &#123; sizeof(ivar_t), 6, &#123;&#123;(unsigned long int *)&amp;OBJC_IVAR_$_YAPerson$age, "age", "I", 2, 4&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_YAPerson$nickname, "nickname", "@\"NSString\"", 3, 8&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_YAPerson$isRich, "isRich", "B", 0, 1&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_YAPerson$_isMale, "_isMale", "B", 0, 1&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_YAPerson$_name, "_name", "@\"NSString\"", 3, 8&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_YAPerson$_block, "_block", "@?", 3, 8&#125;&#125;&#125;; _OBJC_$_INSTANCE_VARIABLES_YAPerson是YAPerson类的全局的成员变量列表。 对于我们来说，Objective-C中的属性指的就是成员变量与存取器方法。一般地，声明一个属性的时候，编译器会生成一个下划线打头的成员变量，比如@property (nonatomic, copy) NSString *name;会生成成员变量：NSString *_name;。 在语言层面，属性指的是属性的名称与对属性的修饰（类型、原子性、内存策略等）。 struct property_t &#123; const char *name; const char *attributes;&#125;; name是属性的名称，attributes包含的信息就比较多了，可以通过property_getAttributes()获取，比如YAPerson的name属性，得到的是&quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;，“C”表示copy，“N”表示nonatomic，具体含义官方文档说的很详细。 当然，属性列表是所有属性的集合：static struct &#123; unsigned int entsize; // sizeof(struct _prop_t) unsigned int count_of_properties; struct property_t prop_list[3];&#125; _OBJC_$_PROP_LIST_YAPerson = &#123; sizeof(property_t), 3, &#123;&#123;"name","T@\"NSString\",C,N,V_name"&#125;, &#123;"isMale","TB,R,N,V_isMale"&#125;, &#123;"block","T@?,C,N,V_block"&#125;&#125;&#125;; _OBJC_$_PROP_LIST_YAPerson是YAPerson类的全局的属性列表。 方法设计一个方法需要解决三个问题：方法名、方法实现以及方法的参数类型和返回值类型。 SEL表征方法名的selector是SEL类型：typedef struct objc_selector *SEL;，也即“Defines an opaque type that represents a method selector”。关于它的解释目前主要有两种看法：一、有人根据Runtime源码中的定义和官方文档认为它是指向objc_selector结构体的指针，但是objc_selector结构体的具体实现并没有开源。二、有人说它就是C语言中的字符串常量const char *类型，理由是Runtime源码中sel_getName()的函数实现表明了SEL类型可以直接转换为const char *类型，而且“对于字符串的比较仅仅需要比较他们的地址就可以”，在各种查找中速度更快。 const char *sel_getName(SEL sel) &#123; if (!sel) return "&lt;null selector&gt;"; return (const char *)(const void*)sel;&#125; 我觉得这两种看法可以结合一下，SEL是指向objc_selector结构体的指针，objc_selector的实现应该是这样的： struct objc_selector &#123; char name[]; // 构造 objc_selector(char name[]) &#123; strcpy(this-&gt;name, name); &#125;&#125;; 1.从结果上看，可以满足直接转换为const char *类型：str的值就是“new”。从本质上看，指向结构体的指针就是指向结构体第一个成员（name数组）的指针。// 创建结构体objc_selector selector = &#123;"new"&#125;;// p为指向结构体的指针objc_selector *p = &amp;selector;// 将 p 强制转化为 const char * 类型const char *str = (const char *)p;// 实际上str与结构体中的name是等价的bool res = (str == p-&gt;name); 2.与SEL的内存表现是一致的。需要根据方法名的长度，创建相应长度的name数组。比如“new”方法，占用4个字节：6e 65 77 00。 objc_selector selector = &#123;"new"&#125;;objc_selector *p = &amp;selector;SEL sel = @selector(new); (lldb) x p0x16f825c78: 6e 65 77 00 01 00 00 00 a0 85 c0 00 01 00 00 00 new.............(lldb) x sel0x1fc67fc8f: 6e 65 77 00 69 73 61 00 63 6f 6e 66 6f 72 6d 73 new.isa.conforms 看源码不难得知，相同名称对应的selector在内存中只有一个，存储在NXMapTable中。也就是说通过@selector()语法糖、sel_registerName()函数、NSSelectorFromString()函数，都是从NXMapTable中取出selector。如果这个名称对应的selector已经注册在Runtime（存储在NXMapTable）中，直接返回，如果没有注册，才会进行创建。不同指针变量指向同一个结构体，这也解释了为啥可以使用==运算符比较。 最后一个问题，为什么表征方法名的selector要设计成结构体而不是直接使用const char *？ When using selectors, you must use the value returned from sel_registerName or the Objective-C compiler directive @selector(). You cannot simply cast a C string to SEL. 苹果希望我们使用诸如sel_registerName()这些转化函数，就是想让方法名与selector建立映射，同时把selector纳入管理。而不是像这样： SEL sel = (SEL)"show";[view performSelector:sel]; IMP对于一般的函数来说，函数名也是指向函数实现的指针。void func() &#123; printf("%s\n", __func__);&#125; 对于func函数，func()是通过函数名调用，(*func)()是通过指向函数的指针调用。在Objective-C中，IMP就是指向函数的指针。 标准的IMP定义是这样的：typedef id (*IMP)(id, SEL, ...); 在实际使用时，需要根据具体的参数、返回值重新定义： typedef NSString *(*_IMP)(id ,SEL, ...);SEL sel = @selector(description);NSObject *obj = [NSObject new];_IMP imp = (_IMP)class_getMethodImplementation(obj.class, sel);if (imp) &#123; // 函数名调用 NSString *desc1 = imp(obj, sel); // 函数指针调用 NSString *desc2 = (*imp)(obj, sel);&#125; Method为了简便地描述类型、修饰符，字符串形式的类型编码产生了。const char *type = @encode(int)在编译时便返回了字符串常量“i”，用来表明这是int类型。但是有一些像const、inout等方法参数的修饰符无法通过@encode()获取。对于方法来说，const char *method_getTypeEncoding(Method m)函数可以直接返回方法完整的Type Encode。这里的Method是集成了方法名SEL、函数指针、类型编码的结构体指针。 typedef struct method_t *Method;struct method_t &#123; SEL name; const char *types; IMP imp;&#125;; 实例方法存放在类对象之中，这样，类对象的方法列表就产生了：static struct &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct method_t method_list[6];&#125; _OBJC_$_INSTANCE_METHODS_YAPerson = &#123; sizeof(method_t), 6, &#123;&#123;(struct objc_selector *)"singWithSongName:", "v24@0:8@16", (void *)_I_YAPerson_singWithSongName_&#125;, &#123;(struct objc_selector *)"name", "@16@0:8", (void *)_I_YAPerson_name&#125;, &#123;(struct objc_selector *)"setName:", "v24@0:8@16", (void *)_I_YAPerson_setName_&#125;, &#123;(struct objc_selector *)"isMale", "B16@0:8", (void *)_I_YAPerson_isMale&#125;, &#123;(struct objc_selector *)"block", "@?16@0:8", (void *)_I_YAPerson_block&#125;, &#123;(struct objc_selector *)"setBlock:", "v24@0:8@?16", (void *)_I_YAPerson_setBlock_&#125;&#125;&#125;; 类方法保存在元类对象之中，对于YAPerson，只有一个类方法canWork，其方法列表是这样：static struct &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct method_t method_list[1];&#125; _OBJC_$_CLASS_METHODS_YAPerson = &#123; sizeof(method_t), 1, &#123;&#123;(struct objc_selector *)"canWork", "B16@0:8", (void *)_C_YAPerson_canWork&#125;&#125;&#125;; 成员变量列表、属性列表、实例方法列表、类方法列表都已经有了，那么一个类的结构也就出来了。 类class、meta-class、root meta-class的本质都是objc_class结构体，且都是以单例的形式表现在内存中。objc_class继承自objc_object，它的cache存储着缓存的方法列表，bits中的一些位存储着指向class_rw_t的指针。 struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; const uint8_t * ivarLayout; const char * name; // baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容 method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; // ......&#125;;struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; // methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容 method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName; // ......&#125;;struct objc_object &#123;private: isa_t isa; // ......&#125;;struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // bits &amp; FAST_DATA_MASK可以获取class_rw_t // ......&#125;; YAPerson类对象的结构是这样的：struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; const uint8_t * ivarLayout; const char * name; // baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容 method_list_t * baseMethodList; // 方法列表 protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties; // 属性列表&#125; _OBJC_CLASS_RO_$_YAPerson = &#123; 0, // 计算 YAPerson 中的第一个成员变量在结构体中的偏移量 __OFFSETOFIVAR__(struct YAPerson, age), sizeof(struct YAPerson_IMPL), 0, "YAPerson", (method_list_t *)&amp;_OBJC_$_INSTANCE_METHODS_YAPerson, 0, (const ivar_list_t *)&amp;_OBJC_$_INSTANCE_VARIABLES_YAPerson, 0, (property_list_t *)&amp;_OBJC_$_PROP_LIST_YAPerson,&#125;; 元类对象与类对象的结构是相同的，就YAPerson而言，主要存储了类方法列表，内容是这样： static struct class_ro_t _OBJC_METACLASS_RO_$_YAPerson = &#123; 1, sizeof(struct class_t), sizeof(struct class_t), 0, "YAPerson", (struct method_list_t *)&amp;_OBJC_$_CLASS_METHODS_YAPerson, 0, 0, 0,0,&#125;; 二、协议协议规定了协议遵守者需要实现的方法。如果在协议中声明一个属性，实际上相当于在协议中添加了该属性对应的存取器方法声明。对于协议遵守者，一般来说，需要合成该属性对应的成员变量：@synthesize 属性名;。@class YAStudent;@protocol YAStudentProtocol &lt;NSObject&gt;@required// 实例属性@property (nonatomic, assign) BOOL isExcellent;// 类属性@property (class, nonatomic, copy) NSString *protocolName;// 实例方法- (BOOL)isSame:(YAStudent *)person;// 类方法+ (NSString *)description;@optional// 可选的实例属性@property (readonly, copy) NSString *debugDescription;@end 上面声明的协议的对应的结构是这样的： struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; // 协议列表 method_list_t *instanceMethods; // 实例方法列表 method_list_t *classMethods; // 类方法列表 method_list_t *optionalInstanceMethods; // 可选的实例方法列表 method_list_t *optionalClassMethods; // 可选的类方法列表 property_list_t *instanceProperties; // 实例属性列表 uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; // 类属性列表&#125;;// 转为C++后struct _protocol_t &#123; void * isa; // NULL const char *protocol_name; // 协议名 const struct _protocol_list_t * protocol_list; // super protocols const struct method_list_t *instance_methods; // 实例方法列表 const struct method_list_t *class_methods; //类方法列表 const struct method_list_t *optionalInstanceMethods; // 可选的实例方法列表 const struct method_list_t *optionalClassMethods; // 可选的类方法列表 const struct _prop_list_t * properties; // 属性列表 const unsigned int size; // sizeof(struct _protocol_t) const unsigned int flags; // = 0 const char ** extendedMethodTypes; // 方法type&#125; = &#123; 0, "YAStudentProtocol", (const struct _protocol_list_t *)&amp;_OBJC_PROTOCOL_REFS_YAStudentProtocol, (const struct method_list_t *)&amp;_OBJC_PROTOCOL_INSTANCE_METHODS_YAStudentProtocol, (const struct method_list_t *)&amp;_OBJC_PROTOCOL_CLASS_METHODS_YAStudentProtocol, (const struct method_list_t *)&amp;_OBJC_PROTOCOL_OPT_INSTANCE_METHODS_YAStudentProtocol, 0, (const struct _prop_list_t *)&amp;_OBJC_PROTOCOL_PROPERTIES_YAStudentProtocol, sizeof(_protocol_t), 0, (const char **)&amp;_OBJC_PROTOCOL_METHOD_TYPES_YAStudentProtocol&#125;; 可以看到，协议主要存储了方法。协议的方法列表和类对象中的方法列表结构是一样的，但是有一点，协议方法列表中的方法Method没有具体实现IMP。也容易理解，毕竟协议只能提供方法名、方法参数和返回值。那么有没有可能为协议添加方法实现呢？有。因为，协议继承自objc_object，所以协议也是一个实例对象。当获取它的superclass时，发现就是NSObject。Protocol *pro = objc_getProtocol("YAStudentProtocol");(lldb) po [pro class]Protocol(lldb) po [pro superclass]NSObject 那么，把它当做一个普通对象即可：Method me = class_getInstanceMethod(YAStudent.class, @selector(show));IMP imp = method_getImplementation(me);const char *type = method_getTypeEncoding(me);BOOL success = class_addMethod(NSClassFromString(@"Protocol"), @selector(show), imp, type);if (success) &#123; // "创建"一个叫"YAStudentProtocol"的协议对象, 它的class是Protocol, 它的superclass是NSObject Protocol *pro = objc_getProtocol("YAStudentProtocol"); // 调用协议对象的show方法 NSString *result = [(id)pro performSelector:@selector(show)];&#125; 虽然这么做意义并不是很大，但是脑洞再大一点，有没有可能只要遵守一个协议，那么就拥有了协议中的方法声明和方法实现呢？有。ProtocolKit解决了这个问题。 三、类扩展与分类类扩展和分类都可以给已有的类添加功能，不同的是类扩展是编译时合并到类中，分类是在运行时合并到类中。 struct category_t &#123; const char *name; // 主类的名称 classref_t cls; // 类 struct method_list_t *instanceMethods; // 实例方法列表 struct method_list_t *classMethods; // 类方法列表 struct protocol_list_t *protocols; // 协议列表 struct property_list_t *instanceProperties; // 实例属性列表 // Fields below this point are not always present on disk. struct property_list_t *_classProperties; // 类属性列表&#125;; 每创建一个分类时，都会产生一个_category_t结构体：static struct category_t _OBJC_$_CATEGORY_YAStudent_$_HighSchoolStudent; 根据源码，分类中的属性、方法、协议等信息，合并到主类中的过程是这样的：// Attach method lists and properties and protocols from categories to a class.// Assumes the categories in cats are all loaded and sorted by load order, // oldest categories first.static void attachCategories(Class cls, category_list *cats, bool flush_caches) &#123; // 保证不为空 if (!cats) return; // "log methods replaced by category implementations" if (PrintReplacedMethods) printReplacements(cls, cats); // 是否是元类对象 bool isMeta = cls-&gt;isMetaClass(); // 存储空间分配 fixme rearrange to remove these intermediate allocations method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; // 方法数量 int propcount = 0; // 属性数量 int protocount = 0; // 协议数量 int i = cats-&gt;count; // 分类数量 bool fromBundle = NO; while (i--) &#123; // 取出分类列表中的最后一个分类 auto&amp; entry = cats-&gt;list[i]; // 获取方法列表 method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; // 获取属性列表 property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; // 获取协议列表 protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; auto rw = cls-&gt;data(); // 附加 prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 可以看到，分类信息是按照分类列表的逆序逐个进行合并，分类列表的顺序是由加载顺序确定的。方法、属性、协议数组等，都是二维数组，一维对应着分类，二维对应着每条信息。 附加过程是这样的：void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; // 重新分配newCount的内存 setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; // 把addedLists放到老数据的前面, 形成新的array()-&gt;lists memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; // 把oldList放到addedLists的后面 if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125;&#125; 各种情况都有考虑，但是目的只有一个：把addedLists插入到原有数据的前面。这也解释了为什么分类中的方法与主类中的方法同名时，实际上会调用分类的。表面上看是“覆盖”，实际上方法都是存在的，只不过一旦在方法列表中找到需要调用的方法，就不再往下找了。 四、关联对象由于内存布局在类定义后就已经固定，所有没有办法在分类中添加成员变量，但是相似的场景还是有的，这就需要用到关联对象。 设置关联对象的逻辑是这样的：void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); // 如果修饰策略是OBJC_ASSOCIATION_SETTER_RETAIN, 则new_value = [value retain] // 如果修饰策略是OBJC_ASSOCIATION_SETTER_COPY, 则new_value = [value copy] id new_value = value ? acquireValue(value, policy) : nil; AssociationsManager manager; // 获取哈希表(AssociationsHashMap)的引用: associations AssociationsHashMap &amp;associations(manager.associations()); // 获取object的"按位取反值" unsigned long disguised_object = DISGUISE(object); // ~(unsigned long)(object) if (new_value) &#123; // 根据object的"按位取反值"作为key, 查找对应的iterator, 如未查找到，返回end() AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // object已经设置过关联对象, 则需要更新key对应的对象 ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; // 找到key对应的对象, 获取旧的对象, 设置新的对象 old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; // 没有找到key对应的对象, 这是一个新的key (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // 说明在AssociationsHashMap中, object目前还没有对应的ObjectAssociationMap, 也即是第一次设置关联对象, 则创建ObjectAssociationMap ObjectAssociationMap *refs = new ObjectAssociationMap; // 存储refs associations[disguised_object] = refs; // 在ref中存储关联策略和new_value (*refs)[key] = ObjcAssociation(policy, new_value); // 标明当前类具有关联类, 它会将isa中的has_assoc标记为true object-&gt;setHasAssociatedObjects(); &#125; &#125; else &#123; // value为空, 说明是要删除原先的关联引用(一般也是这么用的, 而不是使用remove) // 查找对应的iterator AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // 说明是有值的 // 获取值(first是键, second是值): ObjectAssociationMap ObjectAssociationMap *refs = i-&gt;second; // 根据参数key, 获取在refs中对应的iterator ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; // 获取旧值 old_association = j-&gt;second; // 把参数key对应的对象擦除 refs-&gt;erase(j); &#125; &#125; &#125; // 如果旧的关联对象不为空, 就把它release. release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 获取关联对象的逻辑是这样的：id _object_get_associative_reference(id object, void *key) &#123; id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; AssociationsManager manager; // 获取AssociationsHashMap AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // 找到ObjectAssociationMap ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; // 再找到ObjcAssociation ObjcAssociation &amp;entry = j-&gt;second; // 取出关联对象和关联策略 value = entry.value(); policy = entry.policy(); // 策略是retain的话, 获取[value retain] if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain); &#125; &#125; if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123; // 策略是autorelease的话, 获取[value autorelease] ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease); &#125; return value;&#125; 整体来看是比较简单的，有同学画了一幅图，很清晰地说明了存储层次： 关联对象的存储与类的存储没有关系。全局的AssociationsHashMap存储着所有对象与关联对象的映射关系，并由AssociationsManager管理。在AssociationsHashMap中，每个对象的“按位取反值”作为键，每个对象对应的ObjectAssociationMap作为值。在ObjectAssociationMap中，参数key作为键，关联的对象被包装成ObjcAssociation并作为值存储。 实际使用时，一般把getter方法的selector作为key，避免了新变量的产生；在移除关联对象时，常常使用objc_setAssociatedObject()函数，传入空的object，而不是使用objc_removeAssociatedObjects()函数直接把所有的关联对象都给移除。 一个对象在销毁之前，会自动移除它所有的关联对象。利用这个特性，可以实现不hook dealloc方法而在一个对象生命周期结束的时候触发一个操作。简单地说，就是利用一个中间对象，让它保存需要执行的操作，在其dealloc时执行操作。而把这个中间对象（或者保存中间对象的数组，亦或者是block）作为分类的关联属性，也算是一种思路吧。 最后就是很有意思的weak关联属性，这个在《Weak Associated Object》一文中专门做了思考与说明，巧妙地利用现成的weak关键字和block即可轻松实现。 五、消息机制Objective-C中的实例方法调用和类方法调用都是基于消息机制的，通过发送消息而不是直接的函数调用使得这个语言非常具有动态性，这也是很有意思的。 假定YAStudent继承自YAPerson，YAPerson继承自NSObject。 以YAStudent为模板创建出一个student实例，它的实例方法大致是这么调用的：首先会先通过isa找到YAStudent的类对象，在类对象的方法列表找到目标方法，没有找到的话再通过superclass找到YAPerson的类对象，再在其方法列表中查找，没有找到的话再通过superclass找到NSObject的类对象，看是否能在其方法列表中找到并调用。 YAStudent的类方法大致是这么调用的：会先通过isa找到YAStudent的元类对象，在其方法列表中查找目标方法，如果没有找到再通过superclass找到YAPerson的元类对象，如果还没有找到就再通过superclass找到NSObject的元类对象，还是没有找到的话最后再通过isa找到NSObject类对象，看是否能在其方法列表中找到并调用。 实例对象的isa指向类对象，类对象的isa指向元类对象，元类对象的isa指向根元类，根元类的isa指向它自己。类对象的superclass指针指向父类的类对象，元类对象的superclass指针指向父类的元类对象，根元类的superclass指针指向根类（NSObject）。 由于根元类的superclass指针指向根类，这就解释了[NSObject show];这样明明是类方法调用却成功变成了调用NSObject的show实例方法。@interface NSObject (YAShow)@end@implementation NSObject (YAShow)- (void)show &#123; NSLog(@"- (void)show");&#125;@end objc_msgSend编译器会将方法的调用转换为objc_msgSend、objc_msgSend_stret、objc_msgSendSuper和objc_msgSendSuper_stret。 发送给对象的父类的消息会使用 objc_msgSendSuper;有数据结构作为返回值的方法会使用 objc_msgSendSuper_stret 或 objc_msgSend_stret;其它的消息都是使用 objc_msgSend 发送的。 objc_msgSend的具体实现由汇编语言编写而成，原因有两个： 一个C++函数不可能调用任意的函数指针，它可以重载、有可变参数，但是不可能有可变的返回值。 通过使用汇编，可以免去大量局部变量拷贝的操作，参数会直接被存放在寄存器中，当找到IMP时，参数已经保存在了寄存器中，可以直接使用，速度更快。 第一条的解释是这样的，假定objc_msgSend是使用C++实现，那么从语法层面它需要做到能接收可变参数、返回值类型可以任意。比如返回值类型可以是NSUInteger也可以是id： NSUInteger n = [array count];id obj = [array objectAtIndex:6];// 转化后NSUInteger n = (NSUInteger (*)(id, SEL))objc_msgSend(array, @selector(count));id obj = (id (*)(id, SEL, NSUInteger))objc_msgSend(array, @selector(objectAtIndex:), 6); 可变参数可以做到，任意返回值类型貌似可以利用重载，但是仅仅返回值类型不同无法构成重载：// 编译通不过NSUInteger objc_msgSend(id, SEL, ...) &#123; return 0;&#125;id objc_msgSend(id, SEL, ...) &#123; return nil;&#125; 而且就算这两条都做到了，也没有办法支撑无穷无尽的任意函数指针—不可能把所有函数指针一一穷举。 objc_msgSend的解决办法，主要依据的是：当objc_msgSend被调用时，所有的参数已经被设置好了。换一种方式来说，就是：在objc_msgSend开始执行时，栈帧（stack frame）的状态、数据，和各个寄存器的组合形式、数据，跟调用具体的函数指针（IMP）时所需的状态、数据，是完全一致的！ ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame MESSENGER_START cmp x0, #0 // 消息接收者为空，返回0 b.le LNilOrTagged // (MSB tagged pointer looks negative) ldr x13, [x0] // x13 = isa and x16, x13, #ISA_MASK // x16 = class LGetIsaDone: CacheLookup NORMAL // calls imp or objc_msgSend_uncachedLNilOrTagged: b.eq LReturnZero // nil check // tagged mov x10, #0xf000000000000000 cmp x0, x10 b.hs LExtTag adrp x10, _objc_debug_taggedpointer_classes@PAGE add x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF ubfx x11, x0, #60, #4 ldr x16, [x10, x11, LSL #3] b LGetIsaDoneLExtTag: // ext tagged adrp x10, _objc_debug_taggedpointer_ext_classes@PAGE add x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF ubfx x11, x0, #52, #8 ldr x16, [x10, x11, LSL #3] b LGetIsaDone LReturnZero: // x0 is already zero mov x1, #0 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 MESSENGER_END_NIL ret END_ENTRY _objc_msgSend 消息转发当一个方法没有相应的实现时，就会进入消息转发机制，在这套流程中，可以动态增加方法实现。 第一阶段在动态方法解析中可以直接添加上函数实现。比如调用YAPerson的instanceShow实例方法，当判断出这个selector是instanceShow的时候，在resolveInstanceMethod方法中为instanceShow实例方法添加上函数实现instanceFunc。而对于classShow类方法，在resolveClassMethod方法中为classShow方法添加上函数实现classFunc。 // 实例方法void instanceFunc(id self, SEL _cmd) &#123; NSLog(@"%@, %p", self, _cmd);&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel_isEqual(sel, @selector(instanceShow))) &#123; // 添加关于类对象的sel实现 class_addMethod(self.class, sel, (IMP)instanceFunc, "@:"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;// 类方法void classFunc(id self, SEL _cmd) &#123; NSLog(@"%@, %p", self, _cmd);&#125;+ (BOOL)resolveClassMethod:(SEL)sel &#123; if (sel_isEqual(sel, @selector(classShow))) &#123; // 添加关于元类对象的sel实现 class_addMethod(object_getClass(self), sel, (IMP)classFunc, "@:"); return YES; &#125; return [super resolveClassMethod:sel];&#125; 预先把函数实现都写好了，再通过class_addMethod()把实现添加到方法中，那何不如直接完整地把方法实现写了，比如上面的例子，直接把instanceShow实例方法和classShow类方法完整地写出来不就行了？何必多此一举。 实际上，这一阶段常是配合@dynamic来使用。peerassembly举了一个还不错的例子：假定需要通过Preferences接管NSUserDefaults，由它提供各个key的存取接口，那一般需要这么做：@interface Preferences : NSObject &#123; NSUserDefaults *_defaults;&#125;+ (Preferences *)sharedInstance;@property (nonatomic, assign) BOOL autoStartBreak;// ... 还有好多属性@end@implementation Preferences- (BOOL)autoStartBreak &#123; return [_defaults boolForKey:@"autoStartBreak"];&#125;- (void)setAutoStartBreak:(BOOL)autoStartBreak &#123; [_defaults setBool:autoStartBreak forKey:@"autoStartBreak"];&#125;// ... 写好多好多@end 需要对每一个属性都写上存取方法的实现，如果有20个属性，岂不是要写40个方法？ 要是借助resolveInstanceMethod()，就可以这么办：@interface Preferences : NSObject@property (nonatomic, assign) BOOL autoStartBreak;@property (nonatomic, assign) BOOL iaFromSmartApp;@property (nonatomic, assign) BOOL isDarkMode;// ... 还有好多属性@endstatic NSMutableDictionary *_dynamicProperties;@implementation Preferences@dynamic autoStartBreak, iaFromSmartApp, isDarkMode;BOOL paprefBoolGetter(id self, SEL _cmd) &#123; NSString *selectorString = NSStringFromSelector(_cmd); PAPropertyDescriptor *propertyDescriptor = _dynamicProperties[selectorString]; return [NSUserDefaults.standardUserDefaults boolForKey:propertyDescriptor.name];&#125;void paprefBoolSetter(id self, SEL _cmd, BOOL value) &#123; NSString *selectorString = NSStringFromSelector(_cmd); PAPropertyDescriptor *propertyDescriptor = _dynamicProperties[selectorString]; [NSUserDefaults.standardUserDefaults setBool:value forKey:propertyDescriptor.name]; [NSUserDefaults.standardUserDefaults synchronize];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; NSString *selectorString = NSStringFromSelector(sel); PAPropertyDescriptor *propertyDescriptor = [PAPropertyDescriptor new]; if ([selectorString hasPrefix:@"set"]) &#123; // setAutoStartBreak --&gt;autoStartBreak NSString *first = [selectorString substringWithRange:NSMakeRange(3, 1)]; NSString *prop = [selectorString substringWithRange:NSMakeRange(4, selectorString.length - 5)]; propertyDescriptor.name = [first.lowercaseString stringByAppendingString:prop]; class_addMethod(self.class, sel, (IMP)paprefBoolSetter, "v@:B"); &#125; else &#123; propertyDescriptor.name = selectorString; class_addMethod(self.class, sel, (IMP)paprefBoolGetter, "B@:"); &#125; if (!_dynamicProperties[selectorString]) &#123; _dynamicProperties[selectorString] = propertyDescriptor; &#125; return YES;&#125;@end 通过建立映射，把所以存取器都统一纳入管理，更清晰高效。上面的只是一个示例，还要考虑许多问题，比如支持不同类型的属性、替换默认的方法实现等，这个作者已经写了一个完整的组件，可参考PAPreferences。 第二阶段将消息转发给其他target。第一阶段中无法及时添加上相应的方法实现，就会进入第二阶段，我们可以在这里把消息转发给其他对象处理。如果是实例方法，需要实现- (id)forwardingTargetForSelector:(SEL)aSelector，如果是类方法，则需要实现+ (id)forwardingTargetForSelector:(SEL)aSelector。 假定YAPerson的instanceShow实例方法没有具体的实现，而YASinger却是有的，那可以把消息转发给YASinger实例对象，交由它处理：- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return [YASinger new];&#125; 假定YADancer有classShow类方法的实现，那可以把消息转发给YADancer类对象：+ (id)forwardingTargetForSelector:(SEL)aSelector &#123; return YADancer.class;&#125; 实际上，把YAPerson的消息转发给其他对象（实例对象或者类对象）之后，其他对象就会开启新一轮的消息解析，它如果没有对应的方法实现，同样会开启这三个阶段。因此，其他对象不一定要完完整整地具备YAPerson所缺省的方法实现。 第三阶段完整的消息转发。如若前两个阶段都没办法妥善地处理，就会进入消息解析的第三阶段。在这个阶段中，使用forwardInvocation配合methodSignatureForSelector对消息做最后一步的处理。 首先会解析methodSignatureForSelector，只有当它返回的方法签名不为空时，才会进入forwardInvocation流程中，因此我们对该方法重写并返回一个不为空的signature。- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) &#123; if ([YAMethodHelper instancesRespondToSelector:aSelector]) &#123; signature = [YAMethodHelper instanceMethodSignatureForSelector:aSelector]; &#125; &#125; return signature;&#125; 接着在forwardInvocation中获取创建的NSInvocation对象，调用selector即可：- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; if ([YAMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:_helper]; &#125;&#125; 这是很传统的处理步骤，实际上只要保证methodSignatureForSelector返回一个不为空的方法签名，可以在forwardInvocation中对NSInvocation对象做肆意更改。 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) &#123; signature = [NSObject instanceMethodSignatureForSelector:@selector(class)]; &#125; return signature;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; // 调用NSObject对象的description方法 anInvocation.selector = @selector(description); [anInvocation invokeWithTarget:[NSObject new]];&#125; 当然，前提是这么做有意义。 其实在这一阶段还可以实现伪多继承：- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSMethodSignature *first = [(NSObject *)self.firstDelegate methodSignatureForSelector:aSelector]; NSMethodSignature *second = [(NSObject *)self.secondDelegate methodSignatureForSelector:aSelector]; if (first)&#123; return first; &#125; else if(second) &#123; return second; &#125; return nil;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; SEL aSelector = [anInvocation selector]; if([self.firstDelegate respondsToSelector:aSelector])&#123; [anInvocation invokeWithTarget:self.firstDelegate]; &#125; if([self.secondDelegate respondsToSelector:aSelector])&#123; [anInvocation invokeWithTarget:self.secondDelegate]; &#125;&#125;- (BOOL)respondsToSelector:(SEL)aSelector&#123; if([self.firstDelegate respondsToSelector:aSelector] || [self.secondDelegate respondsToSelector:aSelector])&#123; return YES; &#125; else &#123; return NO; &#125;&#125; NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。 方法缓存为了加快方法查找速度，方法缓存产生了。调用过的方法会被缓存起来，如果方法是属于父类的，也会把方法缓存在自己的cache中。 struct cache_t &#123; struct bucket_t *_buckets; // 散列表，指向bucket_t结构体数组的指针 mask_t _mask; // 散列表长度减1 mask_t _occupied; // 已经缓存的方法数量public: struct bucket_t *buckets(); mask_t mask(); mask_t occupied(); void incrementOccupied(); void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask); void initializeToEmpty(); mask_t capacity(); bool isConstantEmptyCache(); bool canBeFreed(); static size_t bytesForCapacity(uint32_t cap); static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap); void expand(); void reallocate(mask_t oldCapacity, mask_t newCapacity); struct bucket_t * find(cache_key_t key, id receiver); static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));&#125;; struct bucket_t &#123;private: cache_key_t _key; IMP _imp;public: inline cache_key_t key() const &#123; return _key; &#125; inline IMP imp() const &#123; return (IMP)_imp; &#125; inline void setKey(cache_key_t newKey) &#123; _key = newKey; &#125; inline void setImp(IMP newImp) &#123; _imp = newImp; &#125; void set(cache_key_t newKey, IMP newImp);&#125;; 方法查找过程：// Selector转换为cache_key_t（unsigned long类型）cache_key_t getKey(SEL sel) &#123; assert(sel); return (cache_key_t)sel;&#125;bucket_t *cache_t::find(cache_key_t k, id receiver) &#123; assert(k != 0); bucket_t *b = _buckets; mask_t m = _mask; mask_t begin = (mask_t)(k &amp; m); mask_t i = begin; do &#123; if (b[i].key() == 0 || b[i].key() == k) &#123; return &amp;b[i]; &#125; &#125; while ((i = ((i+1) &amp; m)) != begin); // hack Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache)); cache_t::bad_cache(receiver, (SEL)k, cls);&#125; 散列表的索引通过index = selector &amp; _mask获得。 六、block结构block的本质是__main_block_impl_0结构体，它拥有isa指针，是一个封装了函数调用以及函数调用环境的Objective-C对象。// 函数实现以及isastruct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;// 一些描述信息static struct __main_block_desc_0 &#123; // 0 size_t reserved; // block大小 size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;// 完整定义struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; // 构造函数 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 定义一个block时，会调用__main_block_impl_0的构造函数，主要是把需要执行的函数地址赋值给FuncPtr指针。 // 函数调用的第一个参数是指向block自己的指针，之后的才是自定义的参数static void __main_block_func_0(struct __main_block_impl_0 *__cself, int age, double height) &#123; // block做的事情&#125; 调用block也即执行FuncPtr函数。 // 一个int型参数、一个double型参数void (*myBlock)(int, double) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);myBlock-&gt;FuncPtr(myBlock, 22, 175.3); 类型从代码段（text区）、数据段（data区）、堆区再到栈区，内存地址逐渐增高。block有三种类型，分别分布在数据段、栈区和堆区。 没有访问auto变量的block是Global类型，继承关系链为：__NSGlobalBlock__，__NSGlobalBlock，NSBlock，NSObject。比如：void (^block)(void) = ^(void) &#123; &#125;; 访问了auto变量的block是Stack类型，继承关系链为：__NSStackBlock__，__NSStackBlock，NSBlock，NSObject。比如：int age = 10;void (^block)(void) = ^(void) &#123; NSLog(@"名字是:%d", age);&#125;; 当__main_block_impl_0的构造函数调用完毕，栈上的该结构体变量销毁，那取出该结构体的指针，再访问数据就不会是正确的数据了。这时候为了保证访问数据的正确性，需要把block放到堆空间，手动管理该结构体变量的生命周期。 Global类型的block调用copy方法后，它依然是Global类型。Stack类型的block调用copy方法后，就成为Malloc类型，继承关系链为：__NSMallocBlock__，__NSMallocBlock，NSBlock，NSObject。比如：int age = 10;void (^block)(void) = [^(void) &#123; NSLog(@"名字是:%d", age);&#125; copy]; 而Malloc类型的block调用copy方法后，引用计数增加1。 在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况，block作为函数返回值时、将block赋值给__strong指针时、block作为Cocoa API中方法名含有usingBlock的方法参数时、block作为GCD API的方法参数时。 捕获变量一般来说，当block捕获外界的auto变量时，该变量会作为block对象的一个成员变量存储，是值传递；当block捕获外界的static变量（非全局变量）时，block对象会增加一个存储该static变量的指针的成员变量，是指针传递；对于全局变量（无论是否static修饰），block会直接访问，不进行捕获。 // 全局变量NSString *globalName = @"globalName";int main(int argc, const char * argv[]) &#123; // 静态变量 static NSString *staticName = @"staticName"; // 局部变量 NSString *autoName = @"autoName"; void (^myBlock)(int, double) = ^(int age, double height) &#123; NSLog(@"globalName: %@, staticName: %@, autoName: %@,", globalName, staticName, autoName); NSLog(@"年龄是:%d, 身高是:%f", age, height); &#125;; myBlock(22, 175.3); return 0;&#125; // 结构如下struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; NSString **staticName; NSString *autoName; // 初始化列表中对autoName和staticName赋值 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString **_staticName, NSString *_autoName, int flags=0) : staticName(_staticName), autoName(_autoName) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 特殊地，self作为隐式参数，是局部变量，所以block访问时会进行捕获。而对于直接访问某个对象的成员变量，比如：void (^block)(void) = ^(void) &#123; NSLog(@"名字是:%@", _name); &#125;; 实际上是首先访问self，接着访问self的成员变量_name，因此，也会对self进行捕获。 尤其需要说明的是，对于一般的auto变量来说，捕获基本数据类型的自动变量的方式是const copy。而当block内部访问了对象类型的auto变量时，如果block是在栈上，将不会对auto变量产生强引用。如果block被拷贝到堆上，会调用block内部的copy函数，copy函数内部会调用_Block_object_assign函数，_Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用。如果block从堆上移除，会调用block内部的dispose函数，dispose函数内部会调用_Block_object_dispose函数，_Block_object_dispose函数会自动释放引用的auto变量（release）。 __block对于__block修饰的auto变量（含基本数据类型和对象类型），block捕获时会将该变量包装成新的对象：NSObject *obj = [NSObject new];__block int age = 22;__block NSObject *strongObj = obj;__block __weak NSObject *weakObj = obj;void (^myBlock)(void) = ^(void) &#123; age = 23; strongObj = nil; weakObj = nil;&#125;;myBlock();// 再次访问strongObj = [NSObject new];age = 24; 实际上是这样： // 把age包装成新的对象struct __Block_byref_age_0 &#123; void *__isa; __Block_byref_age_0 *__forwarding; int __flags; int __size; int age;&#125;;// 把strong修饰的strongObj包装成新的对象struct __Block_byref_strongObj_1 &#123; void *__isa; __Block_byref_strongObj_1 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSObject *__strong strongObj;&#125;;// 把weak修饰的weakObj包装成新的对象struct __Block_byref_weakObj_2 &#123; void *__isa; __Block_byref_weakObj_2 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSObject *__weak weakObj;&#125;;// block的结构struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_age_0 *age; // by ref __Block_byref_strongObj_1 *strongObj; // by ref __Block_byref_weakObj_2 *weakObj; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, __Block_byref_strongObj_1 *_strongObj, __Block_byref_weakObj_2 *_weakObj, int flags=0) : age(_age-&gt;__forwarding), strongObj(_strongObj-&gt;__forwarding), weakObj(_weakObj-&gt;__forwarding) &#123; // 初始化列表 impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 而从这一刻开始，再访问该auto变量（age、strongObj、weakObj），实质上是访问包装成新的对象内部的同名变量（原先的变量已经不存在了）。 __block int age = 22;void (^myBlock)(void) = ^(void) &#123; age = 23;&#125;;myBlock();age = 24;// 进行类型转换struct __main_block_impl_0 *block_imp = (__bridge struct __main_block_impl_0 *)(myBlock);struct __Block_byref_age_0 *age_imp = block_imp-&gt;age;// 打印结果：(lldb) p/x &amp;age(int *) $3 = 0x00000001006207d8(lldb) p/x &amp;(age_imp-&gt;age)(int *) $2 = 0x00000001006207d8 利用类型转换，打印变量age的地址与结构体age_imp中的age成员的地址，发现是一致的，也印证了这一点：__block修饰的age就是“不可见”的新结构体内部的age。 这个“被包装的新的对象”的内存管理也需要考虑，当block在栈上时，并不会对这个“新的对象”产生强引用。当block被copy到堆时，会对“新的对象”产生强引用。对于基本数据类型的包装并不需要赘述，而对于对象类型的包装倒值得一提。“新的对象”内部的strongObj以及weakObj的修饰策略很清晰地表明了它对原来对象内存管理的立场：原来是strong，包装后依然是strong；原来是weak，包装后依然是weak。 对于__block修饰的变量进行装箱也很容易理解，倘若考虑把被修改的auto变量的指针传递给block，这样似乎也能达到修改变量的效果，但是不应该忘记，被修改的auto变量的生命周期是不确定的，假如这个变量很快就销毁，过了很久block才得到执行，这时再去通过指针是无法访问到这个变量的，这种访问方式也很危险。而包装成一个新的对象后，这个对象的生命周期就随着block了，block无论在栈上还是在堆上，都没有关系。 属性修饰一般来说，只有当栈上的block作为方法的参数时，需要我们手动调用block的copy方法，将栈上的block复制到堆上，以避免坏内存问题。在ARC时代，如果block作为属性，无论是copy修饰还是strong修饰都是可以的。对于getter方法，由于block是作为方法的返回值，则它会自动被copy到堆空间，不需要我们关心。对于setter方法，block是作为方法的参数，如果是copy修饰，栈上的block自然会被调用copy方法而被复制到堆空间。如果是strong修饰，那么当把栈上的block赋值给 __strong id类型的对象，也是会被调用copy方法复制到堆空间的。即便如此，还是推荐使用copy修饰，这样能时刻提醒我们这个block将来会被安全地copy到堆空间上。但是，如果是使用weak、assign、unsafe_unretained这些另类的修饰符修饰block，那很轻而易举地就会出问题了。 七、小结halfrost同学概括了与Runtime有关的应用大概是这些，也是比较全面了。 实现多继承（消息转发） Method Swizzling Aspect Oriented Programming（比如打点） Isa Swizzling（KVO的动态派生） Associated Object关联对象 动态地增加方法 NSCoding的自动归档和自动解档 字典和模型互相转换（KVC也可，利用IMP也行） 这篇文章主要总结了Objective-C“对象”相关的基础知识，最后还提了一下这门语言特有的block。不知道有没有把开头的那道问题回答好（捂脸），写了好久，会经常回顾并完善。 参考感谢：《方法与消息》《用代码理解 ObjC 中的发送消息和消息转发》《如何正确使用 Runtime》《为什么objc_msgSend()是用汇编实现的》《通过汇编解读-objc_msgSend》]]></content>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源项目：YAPageView]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9AYAPageView%2F</url>
    <content type="text"><![CDATA[轻量级、新样式轮播视图。 一、前言在拜读里脊串的开发随笔大神的博客时，发现个好玩的东西：《开源项目:XXPagingScrollView》。虽然是很常见的轮播视图，但是这种新样式的实现思路挺有意思。记得两年前在写某个项目时也遇到过这个，但是当然确实没有想出来咋实现这种非全屏有间隙的轮播控件。 读完大神的文章，很是兴奋，一般是不爱造重复的轮子，但是作者这个是Swift版本的，而且是基础组件，少了很多功能，所以心血来潮，在大神基础上再进一步。 相比较来说更加完善了： 支持设置pagingWidth 支持设置pageInset 支持无限循环轮播 支持本地图片 支持网络图片 支持自动轮播、设置轮播时间间隔 支持点击回调 整体代码约150行左右，更加精简。项目地址:https://github.com/ChenYalun/YAPageView 二、思路实际上轮播视图是烂大街的东西了，网上现成代码特别多。一般而言，假定需要n个页面，实现方式有： 使用UIScrollView，添加 n 个UIImageView。 使用UIScrollView，添加两个UIImageView，动态循环调整。 使用UICollectionView。 方法1比较基础，更适合非循环；方法3比较简单，但是UICollectionView过于heavily。方法2，很精简轻量，就是处理起来有点绕。然而，绕一次，换来永久的舒适，很值得。 如何实现自定义Page width的视图，作者给出的方案是： 方案1: 不使用pagingEnabled属性 而是手动的计算并设置滑动偏移方案2: 使用pagingEnabled属性 扩大UIScrollview的显示范围即可 很明显，方案2更好。思路是，扩大UIScrollView的可显示范围并让UIScrollView响应超出其本身范围的触摸事件。思路知道了，实现起来很简单，就是clipsToBounds属性和pointInside方法。 间距处理核心有三条： UIScrollView的宽度就是pageWidth + pageInset。 为了保持左右显示区域的对称性，UIScrollView的x是(superView.width - pageWidth) * 0.5。 子视图的frame是CGRectMake(idx * (pageWidth + pageInset), 0, pageWidth, height)，也即，子视图的宽度与UIScrollView的宽度保持一致。 无限循环处理 视图循环利用使用三个UIImageView，记为左、中、右，重复利用。默认显示中间的imageView。 刷新逻辑在scrollViewDidScroll回调中，当UIScrollView即将显示出下一个（可能是左、也可能是右）视图时，立即调用刷新方法。刷新的逻辑是： 重新计算left、currentIndex、right三个索引 #define kLeft (_currentIndex == 0 ? kCount - 1 : _currentIndex - 1)#define kRight (_currentIndex == kCount - 1 ? 0 : _currentIndex + 1) 对左、中、右三个UIImageView重新设置配图 self.pageArray[0].image = self.imageArray[kLeft];self.pageArray[1].image = self.imageArray[_currentIndex];self.pageArray[2].image = self.imageArray[kRight]; 以非动画方式设置UIScrollView的偏移量 CGFloat x = self.scrollView.contentOffset.x;CGFloat width = self.pageWidth + self.pageInset;if (x == 0) &#123; x = width;&#125; else &#123; x += x &gt; width ? -width : width;&#125;[self.scrollView setContentOffset:CGPointMake(x, 0)]; 这样便实现了无限循环。 刷新时机处理scrollViewDidScroll会回调很多次，本来以为使用一个标志位就可以控制只刷新一次，但是并没有实现😂 所以，退一步，用了两个标志位： @property (nonatomic, assign) BOOL leftLock;@property (nonatomic, assign) BOOL rightLock; 逻辑是这样的： // Turn left.if (offsetX &gt; 2 * (width - self.pageInset)) self.rightLock = NO;if (!self.leftLock &amp;&amp; offsetX &lt; width - 2 * self.pageInset) &#123; self.leftLock = YES; _currentIndex = kLeft; [self refresh];&#125;// Turn right.if (offsetX &lt; 2 * self.pageInset) self.leftLock = NO;if (!self.rightLock &amp;&amp; offsetX &gt; width + 2 * self.pageInset) &#123; self.rightLock = YES; _currentIndex = kRight; [self refresh];&#125; 请牢记UIScrollView的宽度width是width=pageWidth+pageInset，这里以即将显示右边视图为例： scrollView的初始偏移量是width，逐渐偏移，直到越过空白间距(pageInset)要显示下一个视图时，此时offsetX为width + (pageWidth - pageInset)，也即代码中的2 * (width - pageInset)，立即将offsetX还原为2 * (width - pageInset) - (width)也就是pageWidth-pageInset，对leftLock加锁，更新当前索引。 点击事件处理对UIScrollView添加点击手势，计算出当前点击位置在图片数组中的索引即可：CGFloat pointX = [tap locationInView:tap.view].x;NSUInteger idx = _currentIndex;if (pointX &lt; self.pageWidth + self.pageInset) &#123; idx = kLeft;&#125; else if (pointX &gt; 2 * self.pageWidth + self.pageInset) &#123; idx = kRight;&#125; 自动轮播处理当设置timeInterval属性时，说明需要自动轮播，懒加载创建定时器： _timer = [NSTimer timerWithTimeInterval:_timeInterval repeats:YES block:^(NSTimer *timer) &#123; [self.scrollView setContentOffset:CGPointMake(CGRectGetWidth(self.scrollView.frame) * 2, 0) animated:YES];&#125;]; 并把定时器放到currentRunLoop中，设置NSRunLoopCommonModes。当然，需要在ScrollView的一些代理中处理用户手动滑动与定时器设置的滑动的冲突。 定时器循环引用处理解决方式是，当PageView从父视图上移除时，手动销毁定时器：- (void)willMoveToSuperview:(UIView *)newSuperview &#123; [super willMoveToSuperview:newSuperview]; if (newSuperview == nil) &#123; // 视图从父视图移除时, 销毁定时器 [_timer invalidate]; _timer = nil; &#125;&#125; 点击回调循环引用处理点击事件给出的接口我选择使用block，（使用弱引用的代理就不会有这个问题了，但是代理会增加调用的复杂性，设置代理、遵守协议、实现方法巴拉巴拉。。。） 然而，同许多视图的block回调一样，会有循环引用的问题，只能这样使用： __weak typeof(self) weakSelf = self;pageView.tapHandler = ^(NSUInteger idx, UIImage *img, NSURL *url) &#123; __strong typeof(weakSelf) self = weakSelf; NSLog(@"self = %@, index = %lu, url = %@", self, (unsigned long)idx, url); /// ....&#125;; 万一调用方忘了呢，那就内存泄漏了。 大神玉令天下的方式是使用弱引用的变量持有外界的调用者，然后在适当时机将组件“自己”置为空。不过需要给调用者写个分类（属性）持有组件，还需要明确切断循环引用的时机，对于我的这个100来行的PageView，可能有点不太合适。 突然脑洞一开，想到一个方法，显式让使用方传进来调用者，重新定义外界的self，将其作为一个回调参数传递给使用方（PageView内部使用weak持有外界的self）。 @property (nonatomic, copy) void (^tapHandler)(NSUInteger idx, UIImage *img, NSURL *url, id self); 外界使用的时候像这样： pageView.tapHandler = ^(NSUInteger idx, UIImage *img, NSURL *url, UIViewController *self) &#123; [self.navigationController popViewControllerAnimated:YES];&#125;; 确实能解决循环引用，而且不是很费事。但是，实际使用的时候是这样的： pageView.tapHandler = ^(NSUInteger idx, UIImage *img, NSURL *url, id controller) &#123; // 需要手动把id类型改成实际的类型，如UIViewController、UIView等等&#125;; 并不知道外界的self是啥类型，只能用id。我感觉也不是很巧妙。所以，还是使用苹果推荐的主流的weak-strong吧。 三、使用本地图片本地图片直接传入UIImage数组即可。 // 指定构造器，设定pageWidth、pageInset等YAPageView *pageView = [[YAPageView alloc] initWithFrame:CGRectMake(0, 200, kScreenWidth, 200) controller:self pageWidth:300 pageInset:20];pageView.imageArray = @[ [UIImage imageNamed:@"1"], [UIImage imageNamed:@"2"], [UIImage imageNamed:@"3"], [UIImage imageNamed:@"4"], [UIImage imageNamed:@"5"], [UIImage imageNamed:@"6"],]; 网络图片网络图片传入图片URL数组，并设置处理图片的block。这个block指的是给UIImageView设置图片URL的方式。 // 如果使用SDWebImage，可以这么设置pageView.configImageHandler = ^(UIImageView *imageView, NSURL *url) &#123; [imageView sd_setImageWithURL:url];&#125;;pageView.imageURLArray = @[ [NSURL URLWithString:@"https://picsum.photos/id/230/350/200"], [NSURL URLWithString:@"https://picsum.photos/id/231/350/200"], [NSURL URLWithString:@"https://picsum.photos/id/232/350/200"], [NSURL URLWithString:@"https://picsum.photos/id/233/350/200"], [NSURL URLWithString:@"https://picsum.photos/id/234/350/200"], [NSURL URLWithString:@"https://picsum.photos/id/235/350/200"]]; 设置自动轮播时间pageView.timeInterval = 3.f; 设置点击回调别忘了循环引用的问题。 __weak typeof(self) weakSelf = self;pageView.tapHandler = ^(NSUInteger idx, UIImage *img, NSURL *url) &#123; __strong typeof(weakSelf) self = weakSelf; NSLog(@"self = %@, index = %lu, url = %@", self, (unsigned long)idx, url); [self.navigationController popViewControllerAnimated:YES];&#125;; 四、总结整体而言，没有冗余逻辑，能优化的也优化了（比如索引计算对取模的优化、定时器懒加载、刷新时机次数等等），应该算是比较轻量了吧哈哈哈哈。 具体应用方面，比如腾讯视频App中的首页Tab、会员Tab都有这种custom width的轮播图。 QQ音乐中的发现Tab也是这种轮播图，不过不能无限循环（不能无限循环岂不是更简单。。）。 好了，把两年前的坑填上了。 后记有因必有果。2019年11月，图搜进行大改版，pm有个新特性引导的需求。于是我在这个代码的基础上修修改改，很快就开发完毕了，大幅缩短了这块需求的开发时间😁。]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构的Swift实现]]></title>
    <url>%2F2019%2F07%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84Swift%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[使用Swift实现常见的数据结构。 1.动态数组class ArrayList&lt;T: Equatable&gt; &#123; // 元素数量(只读) private(set) var count: Int = 0 // 使用nil作为占位 private var elements: [T?] // 默认10个元素 private let DEFAULT_CAPACITY = 10 private let ELEMENT_NOT_FOUND = -1 // 构造器, 初始化容量为capaticy的数组 init(_ capaticy: Int) &#123; let capaticy = capaticy &lt; DEFAULT_CAPACITY ? DEFAULT_CAPACITY : capaticy elements = [T?](repeating: nil, count: capaticy) &#125; // 是否为空 func isEmpty() -&gt; Bool &#123; return count == 0 &#125; // 插入元素 func insert(_ item: T, _ index: Int) &#123; if index &lt; 0 || index &gt; count &#123; // 越界 fatalError("索引有误, 已经越界") &#125; ensureCapacity() for idx in (index...count).reversed() &#123; elements[idx + 1] = elements[idx] &#125; count += 1 elements[index] = item &#125; // 追加元素 func append(_ item: T) &#123; insert(item, count) &#125; // 获取索引所在元素 func get(_ index: Int) -&gt; T &#123; checkBounds(index) return elements[index]! &#125; // 设置元素 func set(_ item: T, _ index: Int) &#123; checkBounds(index) elements[index] = item &#125; // 移除元素 func remove(_ index: Int) -&gt; T &#123; let ele = get(index) for idx in index..&lt;count &#123; elements[idx] = elements[idx + 1] &#125; elements[count - 1] = nil count -= 1 return ele &#125; // 清空元素 func clear() &#123; for idx in 0..&lt;count &#123; elements[idx] = nil &#125; count = 0 &#125; // 是否包含某个元素 func contains(_ item: T) -&gt; Bool &#123; // item 不可能为nil return indexOf(item) != ELEMENT_NOT_FOUND &#125; // 获取某个元素对应的索引 private func indexOf(_ item: T) -&gt; Int &#123; // 这里的item不可能为nil for idx in 0..&lt;count &#123; if elements[idx]! == item &#123; return idx &#125; &#125; return ELEMENT_NOT_FOUND &#125; // 数组扩容 private func ensureCapacity() &#123; if count &gt; elements.count &gt;&gt; 1 &#123; var elements = self.elements // 扩容1.5倍 let newCapacity = elements.count + elements.count &gt;&gt; 1 self.elements = [T?](repeating: nil, count: newCapacity) for idx in 0..&lt;count &#123; self.elements[idx] = elements[idx] &#125; &#125; &#125; // 索引越界检查 private func checkBounds(_ index: Int) &#123; if index &lt; 0 || index &gt;= count &#123; // 越界 fatalError("索引有误, 已经越界") &#125; &#125;&#125; 实现过程中几个需要注意的点: 在indexOf()函数中，元素使用==判等，需要遵守Equatable协议 数组的扩容中，使用位运算符可以避免产生浮点数 由于Swift中可选类型的存在，可以使用nil来占位。当然，在set()、append()等函数中，由于类型确定也省略了外界传参时对空值的判断 动态数组优化class OPArrayList&lt;T: Equatable&gt; &#123; // 元素数量(只读) private(set) var count: Int = 0 // 使用nil作为占位 private var elements: [T?] // 首位元素索引 private var frontIndex = 0 // 默认10个元素 private let DEFAULT_CAPACITY = 10 private let ELEMENT_NOT_FOUND = -1 // 构造器, 初始化容量为capaticy的数组 init(_ capaticy: Int) &#123; let capaticy = capaticy &lt; DEFAULT_CAPACITY ? DEFAULT_CAPACITY : capaticy elements = [T?](repeating: nil, count: capaticy) &#125; // 是否为空 func isEmpty() -&gt; Bool &#123; return count == 0 &#125; // 插入元素 func insert(_ item: T, _ index: Int) &#123; if index &lt; 0 || index &gt; count &#123; // 越界 fatalError("索引有误, 已经越界") &#125; ensureCapacity() for idx in (index..&lt;count).reversed() &#123; elements[actualIndex(idx + 1)] = elements[actualIndex(idx)] &#125; count += 1 elements[actualIndex(index)] = item &#125; // 追加元素 func append(_ item: T) &#123; insert(item, count) &#125; // 获取索引所在元素 func get(_ index: Int) -&gt; T &#123; checkBounds(index) return elements[actualIndex(index)]! &#125; // 设置元素 func set(_ item: T, _ index: Int) &#123; checkBounds(index) elements[actualIndex(index)] = item &#125; // 移除元素 func remove(_ index: Int) -&gt; T &#123; let ele = elements[actualIndex(index)]! if index == 0 &#123; elements[frontIndex] = nil frontIndex += 1 &#125; else &#123; for idx in index..&lt;count &#123; elements[actualIndex(idx)] = elements[actualIndex(idx + 1)] &#125; elements[actualIndex(count - 1)] = nil &#125; count -= 1 return ele &#125; // 清空元素 func clear() &#123; for idx in 0..&lt;count &#123; elements[actualIndex(idx)] = nil &#125; count = 0 &#125; // 是否包含某个元素 func contains(_ item: T) -&gt; Bool &#123; // item 不可能为nil return indexOf(item) != ELEMENT_NOT_FOUND &#125; // 获取某个元素对应的索引 private func indexOf(_ item: T) -&gt; Int &#123; // 这里的item不可能为nil for idx in 0..&lt;count &#123; if elements[actualIndex(idx)]! == item &#123; return idx &#125; &#125; return ELEMENT_NOT_FOUND &#125; // 获取真实索引: (frontIndex + index) % elements.count private func actualIndex(_ idx: Int) -&gt; Int &#123; return (frontIndex + idx) % elements.count &#125; // 数组扩容 private func ensureCapacity() &#123; if count == elements.count &#123; var elements = self.elements // 扩容1.5倍 let newCapacity = elements.count + elements.count &gt;&gt; 1 self.elements = [T?](repeating: nil, count: newCapacity) for idx in 0..&lt;count &#123; let index = (frontIndex + idx) % elements.count self.elements[idx] = elements[index] &#125; frontIndex = 0 &#125; &#125; // 索引越界检查 private func checkBounds(_ index: Int) &#123; if index &lt; 0 || index &gt;= count &#123; // 越界 fatalError("索引有误, 已经越界") &#125; &#125; // 数组内容打印 public func desc() &#123; var str = "[" for idx in 0..&lt;elements.count &#123; var a = ", " if idx == 0 &#123; a = "" &#125; if elements[idx] != nil &#123; str += "\(a)\(elements[idx]!)" &#125; else &#123; str += "\(a)nil" &#125; &#125; str += "], frontIndex = \(frontIndex), count = \(count)" print(str) &#125;&#125; 2.单向链表class OneWayLinkedList&lt;T: Equatable&gt; &#123; // 元素没有找到 private let ELEMENT_NOT_FOUND = -1 fileprivate var first: Node&lt;T&gt;? fileprivate var count: Int = 0 init(_ firstEle: T?) &#123; if firstEle == nil &#123; first = nil &#125; else &#123; first = Node(ele: firstEle!, next: nil) count += 1 &#125; &#125; // 便利构造 convenience init() &#123; self.init(nil) &#125; // 结点类 fileprivate class Node&lt;T&gt; &#123; var ele: T var next: Node&lt;T&gt;? init(ele: T, next: Node?) &#123; self.ele = ele self.next = next &#125; &#125; // 索引所在元素获取 func get(_ index: Int) -&gt; T &#123; return node(index).ele &#125; // 在某索引处插入元素 func insert(_ item: T, _ index: Int) &#123; if index &lt; 0 || index &gt; count &#123; // 越界 fatalError("索引有误, 已经越界") &#125; if index == 0 &#123; let prev = first let newNode = Node(ele: item, next: prev) first = newNode &#125; else &#123; let prev = node(index - 1) let newNode = Node(ele: item, next: prev.next) prev.next = newNode &#125; count += 1 &#125; // 追加元素 func append(_ item: T) &#123; insert(item, count) &#125; // 移除某索引的元素 func remove(_ index: Int) &#123; checkBounds(index) if index == 0 &#123; first = first?.next &#125; else &#123; let noe = node(index - 1) noe.next = noe.next?.next &#125; count -= 1 &#125; // 获取某元素所在索引 func indexOf(_ item: T) -&gt; Int &#123; var node = first var idx = 0 while node != nil &#123; if node!.ele == item &#123; return idx &#125; node = node!.next idx += 1 &#125; return ELEMENT_NOT_FOUND &#125; // 清空所有元素 func clear() &#123; count = 0 self.first = nil &#125; // 打印 func desc() &#123; var node = first var str = "" for idx in 0..&lt;count &#123; if idx == 0 &#123; str += "first:\(node!.ele)," &#125; if node!.next != nil &#123; str += " [\(node!.ele), \(node!.next!.ele)]" &#125; else &#123; str += " [\(node!.ele), nil]" &#125; node = node!.next if node != nil &#123; str += "," &#125; &#125; print(str) &#125; // 获取索引所在的结点 fileprivate func node(_ index: Int) -&gt; Node&lt;T&gt; &#123; checkBounds(index) var node = self.first for _ in 0..&lt;index &#123; node = node?.next &#125; return node! &#125; // 索引越界检查 fileprivate func checkBounds(_ index: Int) &#123; if index &lt; 0 || index &gt;= count &#123; // 越界 fatalError("索引有误, 已经越界") &#125; &#125;&#125; 3.单向循环链表class OneWayCircularLinkedList&lt;T: Equatable&gt;: OneWayLinkedList&lt;T&gt; &#123; override func insert(_ item: T, _ index: Int) &#123; if index &lt; 0 || index &gt; count &#123; // 越界 fatalError("索引有误, 已经越界") &#125; if index == 0 &#123; let prev = first let newNode = Node(ele: item, next: prev) if prev == nil &#123; // 只有一个元素 newNode.next = newNode &#125; first = newNode &#125; else &#123; let prev = node(index - 1) // 处理添加到最后一个位置 let fir = (index == count) ? first : prev.next let newNode = Node(ele: item, next: fir) prev.next = newNode &#125; count += 1 &#125; override func remove(_ index: Int) &#123; checkBounds(index) if index == 0 &#123; let last = node(count - 1) // 对最后一个元素的处理 first = (count - 1 == index) ? nil : first?.next last.next = first &#125; else &#123; let noe = node(index - 1) noe.next = noe.next?.next &#125; count -= 1 &#125; override func clear() &#123; let last = node(count - 1) // 打破循环引用 last.next = nil // 调用父类 super.clear() &#125;&#125; 4.双向链表class TwoWayLinkedList&lt;T: Equatable&gt; &#123; // 元素没有找到 private let ELEMENT_NOT_FOUND = -1 fileprivate(set) var first: Node&lt;T&gt;? fileprivate(set) var last: Node&lt;T&gt;? fileprivate(set) var count: Int = 0 init(_ ele: T?) &#123; if ele == nil &#123; first = nil last = nil &#125; else &#123; first = Node(ele: ele!, prev: nil, next: nil) last = first count += 1 &#125; &#125; // 便利构造 convenience init() &#123; self.init(nil) &#125; // 结点类 class Node&lt;T&gt; &#123; var ele: T var prev: Node&lt;T&gt;? var next: Node&lt;T&gt;? init(ele: T, prev: Node?, next: Node?) &#123; self.ele = ele self.prev = prev self.next = next &#125; &#125; // 索引所在元素获取 func get(_ index: Int) -&gt; T &#123; checkBounds(index) return node(index).ele &#125; // 在某索引处插入元素 func insert(_ item: T, _ index: Int) &#123; if index &lt; 0 || index &gt; count &#123; // 越界 fatalError("索引有误, 已经越界") &#125; if index == count &#123; let prev = last let newNode = Node(ele: item, prev: prev, next: nil) last = newNode prev?.next = newNode if index == 0 &#123; first = last &#125; &#125; else &#123; let next = node(index) let prev = next.prev let newNode = Node(ele: item, prev: prev, next: next) next.prev = newNode prev?.next = newNode if newNode.prev == nil &#123; first = newNode &#125; &#125; count += 1 &#125; // 追加元素 func append(_ item: T) &#123; insert(item, count) &#125; // 移除某索引的元素 func remove(_ index: Int) -&gt; T &#123; checkBounds(index) let old = node(index) let prev = old.prev let next = old.next if next == nil &#123; last = prev &#125; else &#123; next?.prev = prev &#125; if prev == nil &#123; first = next &#125; else &#123; prev?.next = next &#125; count -= 1 return old.ele &#125; // 获取某元素所在索引 func indexOf(_ item: T) -&gt; Int &#123; var node = first var idx = 0 while node != nil &#123; if node!.ele == item &#123; return idx &#125; node = node!.next idx += 1 &#125; return ELEMENT_NOT_FOUND &#125; // 清空所有元素 func clear() &#123; // 打破循环引用 var first = self.first while first != nil &#123; first?.prev = nil first = first?.next &#125; self.first = nil self.last = nil count = 0 &#125; // 是否为空 func isEmpty() -&gt; Bool &#123; return count == 0 &#125; // 打印 func desc() &#123; var node = first var str = "" for idx in 0..&lt;count &#123; if idx == 0 &#123; str += "first:\(node!.ele)," &#125; if node!.next != nil &#123; str += " [\(node!.ele), \(node!.next!.ele)]" &#125; else &#123; str += " [\(node!.ele), nil]" &#125; if node != nil &#123; str += "," &#125; if idx == count - 1 &#123; str += " last:\(node!.ele)" &#125; node = node!.next &#125; print(str) &#125; // 获取索引所在的结点 fileprivate func node(_ index: Int) -&gt; Node&lt;T&gt; &#123; checkBounds(index) if index &lt; count &gt;&gt; 1 &#123; // 在前半部分查找 var node = self.first for _ in 0..&lt;index &#123; node = node?.next &#125; return node! &#125; else &#123; // 在后半部分查找 var node = self.last for _ in (index + 1..&lt;count).reversed() &#123; node = node?.prev &#125; return node! &#125; &#125; // 索引越界检查 fileprivate func checkBounds(_ index: Int) &#123; if index &lt; 0 || index &gt;= count &#123; // 越界 fatalError("索引有误, 已经越界") &#125; &#125;&#125; 5.双向循环链表class TwoWayCircularLinkedList&lt;T: Equatable&gt;: TwoWayLinkedList&lt;T&gt; &#123; override func insert(_ item: T, _ index: Int) &#123; if index &lt; 0 || index &gt; count &#123; // 越界 fatalError("索引有误, 已经越界") &#125; if index == count &#123; let prev = last let newNode = Node(ele: item, prev: prev, next: first) last = newNode prev?.next = newNode if index == 0 &#123; first = last last?.next = newNode &#125; first?.prev = newNode &#125; else &#123; let next = node(index) let prev = next.prev let newNode = Node(ele: item, prev: prev, next: next) next.prev = newNode prev?.next = newNode if index == 0 &#123; // 首位插入元素 first = newNode &#125; &#125; count += 1 &#125; override func remove(_ index: Int) -&gt; T &#123; checkBounds(index) let old: Node = node(index) var prev = old.prev var next = old.next if count == 1 &amp;&amp; index == 0 &#123; // 只有一个元素 prev = nil next = nil old.next = nil old.prev = nil &#125; if index == 0 &#123; first = next &#125; if index == count - 1 &#123; last = prev &#125; prev?.next = next next?.prev = prev count -= 1 return old.ele &#125; override func clear() &#123; // 打破循环引用 var first = self.first for idx in 0..&lt;count &#123; first?.prev = nil first = first?.next if idx == count - 1 &#123; first?.next = nil &#125; &#125; self.first = nil self.last = nil count = 0 &#125;&#125; 6.栈使用动态数组实现。 class Stack&lt;T: Equatable&gt; &#123; // 设置容量默认为10, 可自动扩容 private var list: ArrayList&lt;T&gt; = ArrayList(10) // 元素数量 func size() -&gt; Int &#123; return list.count &#125; // 是否为空 func isEmpty() -&gt; Bool &#123; return list.isEmpty() &#125; // 入栈 func push(_ item: T) &#123; list.append(item) &#125; // 出栈 func pop() -&gt; T &#123; return list.remove(size() - 1) &#125; // 获取栈顶元素 func top() -&gt; T? &#123; return size() == 0 ? nil : list.get(size() - 1) &#125; // 清空所有元素 func clear() &#123; list.clear() &#125;&#125; 7.队列因为频繁地在开头末尾添加删除元素所以使用链表实现又因为双向链表有头指针和尾指针而单向链表只有头指针所以使用双向链表实现(减少遍历) class Queue&lt;T: Equatable&gt; &#123; private var list: TwoWayLinkedList&lt;T&gt; = TwoWayLinkedList() // 元素数量 func size() -&gt; Int &#123; return list.count &#125; // 是否为空 func isEmpty() -&gt; Bool &#123; return list.isEmpty() &#125; // 入队 func enQueue(_ item: T) &#123; list.append(item) &#125; // 出队 func deQueue() -&gt; T &#123; return list.remove(0) &#125; // 获取队头元素 func front() -&gt; T? &#123; return list.first?.ele &#125; // 清空所有元素 func clear() &#123; list.clear() &#125; // 打印元素 func desc() &#123; list.desc() &#125;&#125; 使用栈实现队列原理: 入队时, 把元素放入inStack中 出队时, 如果outStack为空, 则把inStack中的全部栈顶元素依次放到outStack中, 返回outStack的栈顶元素, 否则, 直接返回outStack的栈顶元素class Queue_UseStack&lt;T: Equatable&gt; &#123; // 维护两个栈 private var inStack: Stack&lt;T&gt; = Stack() private var outStack: Stack&lt;T&gt; = Stack() // 元素数量 func size() -&gt; Int &#123; return inStack.size() + outStack.size() &#125; // 是否为空 func isEmpty() -&gt; Bool &#123; return size() == 0 &#125; // 入队 func enQueue(_ item: T) &#123; inStack.push(item) &#125; // 出队 func deQueue() -&gt; T &#123; if outStack.isEmpty() &#123; while inStack.isEmpty() == false &#123; outStack.push(inStack.pop()) &#125; &#125; return outStack.pop() &#125; // 获取队头元素 func front() -&gt; T? &#123; if outStack.isEmpty() &#123; while inStack.isEmpty() == false &#123; outStack.push(inStack.pop()) &#125; &#125; return outStack.top() &#125; // 清空所有元素 func clear() &#123; inStack.clear() outStack.clear() &#125;&#125; 8.循环队列使用动态数组实现, 且各接口优化到O(1)时间复杂度要点: 有一个指向队头元素的索引frontIndex, 必不可少 接口索引与真实索引的互换: 真实索引 = (frontIndex + index) % elements.count 入队 class CircleQueue&lt;T: Equatable&gt; &#123; // 元素数量 private var count: Int = 0 // 指向队头的索引 private var frontIndex: Int = 0 // 使用nil作为占位 private var elements: [T?] // 默认10个元素 private let DEFAULT_CAPACITY = 10 private let ELEMENT_NOT_FOUND = -1 // 构造器, 初始化容量为capaticy的数组 init(_ capaticy: Int) &#123; let capaticy = capaticy &lt; DEFAULT_CAPACITY ? DEFAULT_CAPACITY : capaticy elements = [T?](repeating: nil, count: capaticy) &#125; // 元素数量 func size() -&gt; Int &#123; return count &#125; // 是否为空 func isEmpty() -&gt; Bool &#123; return count == 0 &#125; // 入队 func enQueue(_ item: T) &#123; ensureCapacity(count + 1) elements[index(count)] = item count += 1 &#125; // 出队 func deQueue() -&gt; T &#123; let ele = elements[frontIndex] if ele == nil &#123; fatalError("队列为空") &#125; elements[frontIndex] = nil // 不是frontIndex += 1, 要考虑frontIndex == elements.count但是elements有空闲位置的情况 // 这时应该是frontIndex = (frontIndex + 1) % elements.count, 也就是index(1) frontIndex = index(1) count -= 1 return ele! &#125; // 获取队头元素 func front() -&gt; T? &#123; return elements[frontIndex] &#125; // 清空所有元素 func clear() &#123; for idx in 0..&lt;elements.count &#123; elements[idx] = nil &#125; frontIndex = 0 count = 0 &#125; // 数组扩容 private func ensureCapacity(_ capacity: Int) &#123; // 不需要扩容 if elements.count &gt;= capacity &#123; return &#125; var elements = self.elements // 扩容1.5倍 let newCapacity = elements.count + elements.count &gt;&gt; 1 var newElements = [T?](repeating: nil, count: newCapacity) for idx in 0..&lt;count &#123; newElements[idx] = elements[index(idx)] &#125; self.elements = newElements frontIndex = 0 &#125; // 获取索引对应真实索引 private func index(_ index: Int) -&gt; Int &#123; return (frontIndex + index) % elements.count &#125; // 打印元素 func desc() &#123; print("frontIndex: \(frontIndex)" + " eles: \(elements)") &#125;&#125; 9.双端队列两端都可以入队和出队 class DoubleEndedQueue&lt;T: Equatable&gt; &#123; private var list: TwoWayLinkedList&lt;T&gt; = TwoWayLinkedList() // 元素数量 func size() -&gt; Int &#123; return list.count &#125; // 是否为空 func isEmpty() -&gt; Bool &#123; return list.isEmpty() &#125; // 从队头入队 func enQueueFront(_ item: T) &#123; list.insert(item, 0) &#125; // 从队尾入队 func enQueueRear(_ item: T) &#123; list.append(item) &#125; // 从队头出队 func deQueueFront() -&gt; T &#123; return list.remove(0) &#125; // 从队尾出队 func deQueueRear() -&gt; T &#123; return list.remove(list.count - 1) &#125; // 获取队头元素 func front() -&gt; T? &#123; return list.first?.ele &#125; // 获取队尾元素 func rear() -&gt; T? &#123; return list.last?.ele &#125; // 清空所有元素 func clear() &#123; list.clear() &#125; // 打印元素 func desc() &#123; list.desc() &#125;&#125; 10.循环双端队列class CircleDoubleEndedQueue&lt;T: Equatable&gt; &#123; // 元素数量 private var count: Int = 0 // 指向队头的索引 private var frontIndex: Int = 0 // 使用nil作为占位 private var elements: [T?] // 默认10个元素 private let DEFAULT_CAPACITY = 10 private let ELEMENT_NOT_FOUND = -1 // 构造器, 初始化容量为capaticy的数组 init(_ capaticy: Int) &#123; let capaticy = capaticy &lt; DEFAULT_CAPACITY ? DEFAULT_CAPACITY : capaticy elements = [T?](repeating: nil, count: capaticy) &#125; // 元素数量 func size() -&gt; Int &#123; return count &#125; // 是否为空 func isEmpty() -&gt; Bool &#123; return count == 0 &#125; // 从队头入队 func enQueueFront(_ item: T) &#123; ensureCapacity(count + 1) frontIndex = index(-1) elements[frontIndex] = item count += 1 &#125; // 从队尾入队 func enQueueRear(_ item: T) &#123; ensureCapacity(count + 1) elements[index(count)] = item count += 1 &#125; // 从队头出队 func deQueueFront() -&gt; T &#123; if count &lt;= 0 &#123; fatalError("队列为空") &#125; let ele = elements[frontIndex] elements[frontIndex] = nil frontIndex = index(1) count -= 1 return ele! &#125; // 从队尾出队 func deQueueRear() -&gt; T &#123; if count &lt;= 0 &#123; fatalError("队列为空") &#125; let ele = elements[index(count - 1)]! elements[index(count - 1)] = nil count -= 1 return ele &#125; // 获取队头元素 func front() -&gt; T? &#123; return elements[frontIndex] &#125; // 获取队尾元素 func rear() -&gt; T? &#123; return elements[index(count - 1)] &#125; // 清空所有元素 func clear() &#123; for idx in 0..&lt;elements.count &#123; elements[idx] = nil &#125; frontIndex = 0 count = 0 &#125; // 数组扩容 private func ensureCapacity(_ capacity: Int) &#123; // 不需要扩容 if elements.count &gt;= capacity &#123; return &#125; var elements = self.elements // 扩容1.5倍 let newCapacity = elements.count + elements.count &gt;&gt; 1 var newElements = [T?](repeating: nil, count: newCapacity) for idx in 0..&lt;count &#123; newElements[idx] = elements[index(idx)] &#125; self.elements = newElements frontIndex = 0 &#125; // 获取索引对应真实索引 private func index(_ index: Int) -&gt; Int &#123; var index = index index += frontIndex if index &lt; 0 &#123; return index + elements.count &#125; // return index % elements.count return index - (index &gt;= elements.count ? elements.count : 0) &#125; // 打印元素 func desc() &#123; print("frontIndex: \(frontIndex)" + ",eles: \(elements)") &#125;&#125; 11. 二叉树class BinaryTree&lt;T: Comparable&gt; &#123; fileprivate var nodeCount = 0 // 结点数量 fileprivate var root: Node&lt;T&gt;? // 根节点 // 二叉树是否为空 func isEmpty() -&gt; Bool &#123; return nodeCount == 0 &#125; // 清空 func clear() &#123; root = nil nodeCount = 0 &#125; // 前序遍历(一般是根左右) func preorderTraversal() &#123; print("---------以下是前序遍历的递归方式结果---------") preorderTraversal(root) print("---------以下是前序遍历的非递归方式结果---------") if root == nil &#123; return &#125; var results = [T]() let stack = Stack&lt;Node&lt;T&gt;&gt;() var p = root while p != nil || stack.size() != 0 &#123; while p != nil &#123; // 先访问 根 results.append(p!.ele) stack.push(p!) // 再访问 左 (持续遍历左子树) p = p?.left &#125; p = stack.pop() // 最后访问 右 p = p?.right &#125; print(results) &#125; fileprivate func preorderTraversal(_ node: Node&lt;T&gt;?) &#123; if node == nil &#123; return &#125; print(node!.ele) preorderTraversal(node!.left) preorderTraversal(node!.right) &#125; // 中序遍历(一般是左根右) func inorderTraversal() &#123; print("---------以下是中序遍历的递归方式结果---------") inorderTraversal(root) print("---------以下是中序遍历的非递归方式结果---------") if root == nil &#123; return &#125; var results = [T]() let stack = Stack&lt;Node&lt;T&gt;&gt;() var p = root while p != nil || stack.size() != 0 &#123; while p != nil &#123; // 持续访问左子树 stack.push(p!) p = p?.left &#125; // 弹出栈顶元素 p = stack.pop() // 先访问左子树 results.append(p!.ele) p = p?.right &#125; print(results) &#125; fileprivate func inorderTraversal(_ node: Node&lt;T&gt;?) &#123; if node == nil &#123; return &#125; inorderTraversal(node!.left) print(node!.ele) inorderTraversal(node!.right) &#125; // 后序遍历(一般是左右根) func postorderTraversal() &#123; print("---------以下是后序遍历的递归方式结果---------") postorderTraversal(root) print("---------以下是后序遍历的非递归方式结果---------") var results = [T]() let stack = Stack&lt;Node&lt;T&gt;&gt;() var p = root var last: Node&lt;T&gt;? = nil while p != nil || stack.size() != 0 &#123; while p != nil &#123; // 持续访问左子树 stack.push(p!) p = p?.left &#125; p = stack.top() if p?.right == nil || p?.right == last &#123; // 没有右子树或者访问过右子树 results.append(p!.ele) _ = stack.pop() last = p p = nil &#125; else &#123; p = p?.right &#125; &#125; print(results) &#125; fileprivate func postorderTraversal(_ node: Node&lt;T&gt;?) &#123; if node == nil &#123; return &#125; postorderTraversal(node!.left) postorderTraversal(node!.right) print(node!.ele) &#125; // 层序遍历--使用队列实现 func levelOrderTranversal() &#123; let queue = Queue&lt;Node&lt;T&gt;&gt;() if root == nil &#123; return &#125; var results = [T]() queue.enQueue(root!) while queue.size() != 0 &#123; let r = queue.deQueue() results.append(r.ele) if r.left != nil &#123; queue.enQueue(r.left!) &#125; if r.right != nil &#123; queue.enQueue(r.right!) &#125; &#125; print("---------以下是层序遍历的结果---------") print(results) &#125; // 是否是一颗完全二叉树 func isComplete() -&gt; Bool &#123; if root == nil &#123; // 树为空 return false &#125; var isAllLeaf = false let queue = Queue&lt;Node&lt;T&gt;&gt;() queue.enQueue(root!) while queue.size() != 0 &#123; let r = queue.deQueue() if isAllLeaf &amp;&amp; !r.isLeaf() &#123; return false &#125; if r.left != nil &#123; queue.enQueue(r.left!) &#125; else if r.left == nil &amp;&amp; r.right != nil &#123; // 左子树为空而右子树不为空, 不是完全二叉树 return false &#125; if r.right != nil &#123; queue.enQueue(r.right!) &#125; else &#123; // 左不为空右为空 或者 左右都为空, 要求之后的必须都是叶子结点 isAllLeaf = true &#125; &#125; return true &#125; // 查找前驱结点 fileprivate func precursor(_ node: Node&lt;T&gt;?) -&gt; Node&lt;T&gt;? &#123; // 1. 空结点, 其前驱为空 if node == nil &#123; return nil &#125; // 2. 前驱结点在左结点的右子树上, 比如找6的前驱 var p = node!.left if p != nil &#123; while p!.right != nil &#123; p = p!.right &#125; return p &#125; // 3. 前驱结点在父节点\祖父结点上, 比如找9的前驱 p = node while p!.parent != nil &amp;&amp; p == p!.parent?.left &#123; p = p!.parent &#125; return p!.parent &#125; // 查找后继结点 fileprivate func successor(_ node: Node&lt;T&gt;?) -&gt; Node&lt;T&gt;? &#123; // 1. 空结点, 其后继为空 if node == nil &#123; return nil &#125; // 2. 后继结点在右结点的左子树上, 比如找7的后继 var p = node!.right if p != nil &#123; while p!.left != nil &#123; p = p!.left &#125; return p &#125; // 3. 后继结点在父节点\祖父结点上, 比如找5的后继 p = node while p!.parent != nil &amp;&amp; p == p!.parent?.right &#123; p = p!.parent &#125; return p!.parent &#125; // 树的高度--迭代写法 func height() -&gt; Int &#123; // 层序遍历法 let queue = Queue&lt;Node&lt;T&gt;&gt;() if root == nil &#123; return 0 &#125; var level = 1 var height = 0 queue.enQueue(root!) while queue.size() != 0 &#123; let r = queue.deQueue() level -= 1 if r.left != nil &#123; queue.enQueue(r.left!) &#125; if r.right != nil &#123; queue.enQueue(r.right!) &#125; if level == 0 &#123; // 这一层遍历结束 level = queue.size() height += 1 &#125; &#125; return height //return height(root) &#125; // 树的高度--递归写法 fileprivate func height(_ node: Node&lt;T&gt;?) -&gt; Int &#123; if node == nil &#123; return 0 &#125; return 1 + max(height(node!.left), height(node!.right)) &#125; // 结点类 fileprivate class Node&lt;T: Equatable&gt;: Equatable &#123; var ele: T var left: Node&lt;T&gt;? var right: Node&lt;T&gt;? var parent: Node&lt;T&gt;? init(_ ele: T, _ parent: Node?) &#123; self.ele = ele self.parent = parent &#125; // 叶子结点, 左右结点均为空 func isLeaf() -&gt; Bool &#123; return left == nil &amp;&amp; right == nil &#125; // 有两个结点 func hasTwoChildren() -&gt; Bool &#123; return left != nil &amp;&amp; right != nil &#125; // 是左子结点 func isLeftChild() -&gt; Bool &#123; // 比较指针是否一致 return parent != nil &amp;&amp; parent?.left === self &#125; // 是右子结点 func isRightChild() -&gt; Bool &#123; // 比较指针是否一致 return parent != nil &amp;&amp; parent?.right === self &#125; // 对等比较 static func == (lhs: Node&lt;T&gt;, rhs: Node&lt;T&gt;) -&gt; Bool &#123; return lhs.ele == rhs.ele &#125; &#125;&#125; 12.二叉搜索树class BinarySearchTree&lt;T: Comparable&gt;: BinaryTree&lt;T&gt; &#123; // 查找结点 fileprivate func findNode(_ ele: T) -&gt; Node&lt;T&gt;? &#123; var p = root while p != nil &#123; if ele == p!.ele &#123; // 元素相等, 直接替换 return p &#125; else if ele &lt; p!.ele &#123; // 位于左子树 p = p!.left &#125; else &#123; // 位于右子树 p = p!.right &#125; &#125; return p &#125; // 添加结点 func addNode(_ ele: T) &#123; // 添加的是根节点 if root == nil &#123; root = Node(ele, nil) nodeCount += 1 afterAdd(root!) return &#125; // 添加的不是根结点 else &#123; var p = root var parent = root while p != nil &#123; parent = p if ele == p!.ele &#123; // 元素相等, 直接替换 p?.ele = ele return &#125; else if ele &lt; p!.ele &#123; // 位于左子树 p = p!.left &#125; else &#123; // 位于右子树 p = p!.right &#125; &#125; // 得到parent结点 let newNode = Node(ele, parent) if ele &gt; parent!.ele &#123; parent?.right = newNode &#125; else &#123; parent?.left = newNode &#125; // 总结点数量加1 nodeCount += 1 afterAdd(newNode) &#125; &#125; // 移除结点 func remove(_ ele: T) &#123; var node: Node&lt;T&gt;? = findNode(ele) if node == nil &#123; // 没有找到需要删除的结点 return &#125; // 结点数量减1 nodeCount -= 1 // 度为2的结点 if node!.hasTwoChildren() &#123; // 找它的后继结点 let p = successor(node) // 用后继结点内容替换待删除结点内容 node!.ele = p!.ele // 需要删的结点就是node结点了 node = p &#125; // node是叶子结点而且也是根结点 if node?.parent == nil &#123; root = nil afterRemove(node!) return &#125; // 需要替换的结点 let replace = node?.left == nil ? node?.right : node?.left if replace == nil &#123; // node没有左子树也没有右子树, 说明node是叶子结点 if node?.parent?.left == node &#123; // node是父结点的左结点 node?.parent?.left = nil &#125; else &#123; // node是父结点的右结点 node?.parent?.right = nil &#125; afterRemove(node!) &#125; else &#123; if node?.parent == nil &#123; // 是根结点 root = replace &#125; else if node?.parent?.left == node &#123; // 是左结点 node?.parent?.left = replace &#125; else &#123; // 是右结点 node?.parent?.right = replace &#125; afterRemove(node!) &#125; &#125; fileprivate func afterAdd(_ node: Node&lt;T&gt;) &#123; &#125; fileprivate func afterRemove(_ node: Node&lt;T&gt;) &#123; &#125;&#125; 13.AVLTreeclass AVLTree&lt;T: Comparable&gt;: BinarySearchTree&lt;T&gt; &#123; fileprivate override func afterAdd(_ node: Node&lt;T&gt;) &#123; print("已经添加\(node)") &#125; fileprivate override func afterRemove(_ node: Node&lt;T&gt;) &#123; print("已经移除\(node)") &#125;&#125; 还木有写完。。。。 14.红黑树15.二叉堆protocol Heap &#123; associatedtype T var size: Int &#123; get set &#125; // 是否为空 func isEmpty() -&gt; Bool // 清空 func clear() // 添加元素 func add(_ ele: T) // 获取堆顶元素 func get() -&gt; T // 删除堆顶元素 func remove() -&gt; T // 删除堆顶元素的同时插入一个新元素 func replace(_ ele: T) -&gt; T?&#125;class BinaryHeap&lt;T: Comparable&gt;: Heap &#123; // 使用nil作为占位 private var list: [T?] // 元素数量 internal var size = 0 // 默认10个元素 private let DEFAULT_CAPACITY = 10 // 构造器 init(_ capaticy: Int) &#123; let capaticy = capaticy &lt; DEFAULT_CAPACITY ? DEFAULT_CAPACITY : capaticy list = [T?](repeating: nil, count: capaticy) &#125; // 数组扩容 private func ensureCapacity(_ count: Int) &#123; if count &gt; list.count &#123; var oldList = self.list // 扩容1.5倍 let newCapacity = oldList.count + oldList.count &gt;&gt; 1 self.list = [T?](repeating: nil, count: newCapacity) for idx in 0..&lt;size &#123; self.list[idx] = oldList[idx] &#125; &#125; &#125; // 是否为空 func isEmpty() -&gt; Bool &#123; return size == 0 &#125; // 清空 func clear() &#123; for idx in 0..&lt;size &#123; list[idx] = nil &#125; size = 0 &#125; // 添加元素 func add(_ ele: T) &#123; ensureCapacity(size + 1) list[size] = ele size += 1 siftUp(size - 1) &#125; // 获取堆顶元素 func get() -&gt; T &#123; if self.isEmpty() &#123; fatalError("堆为空, 无法删除") &#125; return list[0]! &#125; // 删除堆顶元素 func remove() -&gt; T &#123; if self.isEmpty() &#123; fatalError("堆为空, 无法删除") &#125; size -= 1 let first = list[0]! list[0] = list[size] list[size] = nil siftDown(0); return first &#125; // 删除堆顶元素的同时插入一个新元素 func replace(_ ele: T) -&gt; T? &#123; if self.isEmpty() &#123; fatalError("堆为空, 无法删除") &#125; var root: T? if (size == 0) &#123; list[0] = ele size += 1 &#125; else &#123; root = list[0]; list[0] = ele; siftDown(0); &#125; return root; &#125; // 建堆 func heapify(_ eles: [T]) &#123; size = eles.count for idx in 0..&lt;eles.count &#123; list[idx] = eles[idx] &#125; // 自上而下的上滤O(nlogn) /* for idx in 0..&lt;size &#123; siftUp(idx) &#125; */ // 自下而上的上滤O(n) for idx in (0...size &gt;&gt; 1).reversed() &#123; siftDown(idx) &#125; &#125; // index位置的元素下滤 private func siftDown(_ idx: Int) &#123; let ele = list[idx]! var idx = idx while idx &lt; size &gt;&gt; 1 &#123; // 左结点 var childIdx = idx &lt;&lt; 1 + 1 var child = list[childIdx]! // 右结点索引 let rightIdx = childIdx + 1 // 如果右结点存在, 则取出左右结点中较大的一个 if rightIdx &lt; size &amp;&amp; list[rightIdx]! &gt; child &#123; childIdx = rightIdx child = list[childIdx]! &#125; // 如果自己不小于较大子结点, 停止下滤 if ele &gt;= child &#123; break &#125; // 交换自己与较大子结点的位置 list[idx] = child idx = childIdx &#125; list[idx] = ele &#125; // index位置的元素上滤 private func siftUp(_ idx: Int) &#123; var idx = idx let ele = list[idx]! while idx &gt; 0 &#123; let parentIdx = (idx - 1) &gt;&gt; 1 let parent = list[parentIdx]! if parent &gt;= ele &#123; // 父结点不小于自己, 停止上滤 break &#125; // 交换自己与父结点的位置 list[idx] = parent idx = parentIdx &#125; list[idx] = ele &#125; func desc() &#123; print(list) &#125;&#125; 上滤1、当插入一个新元素时，放在最末尾。2、若有父节点，将插入节点和父节点比较，如果插入节点大于父节点，交换位置。3、重复2，直至插入节点不小于父节点或者没有父节点，上滤结束。 下滤1、删除首元素，将最后一个元素移到首节点。2、若有孩子，则比较该节点和最大孩子的值，若小于最大孩子的值，与最大的孩子互换位置。3、重复2，直至该节点的值大于最大孩子的值或者没有孩子，下滤结束，堆序性得以满足。 16.优先级队列使用二叉堆实现。 class PriorityQueue&lt;T: Comparable&gt; &#123; private var heap: BinaryHeap = BinaryHeap&lt;T&gt;(10) func size() -&gt; Int &#123; return heap.size &#125; func isEmpty() -&gt; Bool &#123; return heap.isEmpty() &#125; func clear() &#123; heap.clear() &#125; func enQueue(_ ele: T) &#123; heap.add(ele) &#125; func deQueue() -&gt; T &#123; return heap.remove() &#125; func front() -&gt; T &#123; return heap.get() &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Key-Value Observing源码初探]]></title>
    <url>%2F2019%2F05%2F31%2FKey-Value%20Observing%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[KVO源码阅读。 尝试去读一遍KVO的源码，发现它比KVC复杂的多，只能明白个大概。文章最后按照自己的理解，再结合源码的实现流程自己写了一个KVO，锻炼锻炼。 一、常用接口// KVO的回调@interface NSObject(NSKeyValueObserving)- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;@end// 添加及移除观察者@interface NSObject(NSKeyValueObserverRegistration)- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;@end 二、技巧回顾1.如何使得属性在未改变的情况下不发送通知(手动控制)?示例如下，主要有: 重写automaticallyNotifiesObserversForKey:方法 重写setter方法 @interface YAObject : NSObject@property (nonatomic, copy) NSString *name;@end@implementation YAObject+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123; if ([key isEqualToString:@"name"]) return NO; return [super automaticallyNotifiesObserversForKey:key];&#125;- (void)setName:(NSString *)name &#123; if (name != _name) &#123; [self willChangeValueForKey:@"name"]; _name = name; [self didChangeValueForKey:@"name"]; &#125;&#125;@end 2.如何注册依赖键(多个属性影响到某一个属性)? 重写getter方法，定义依赖关系 重写keyPathsForValuesAffectingValueForKey:方法，添加依赖的key集合 @interface YAObject : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@end@implementation YAObject- (NSString *)name &#123; // 定义依赖关系 return [NSString stringWithFormat:@"firstName is %@ and lastName is %@", self.firstName, self.lastName];&#125;+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123; NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key]; if ([key isEqualToString:@"name"]) &#123; keyPaths = [keyPaths setByAddingObjectsFromArray:@[@"firstName", @"lastName"]]; &#125; return keyPaths;&#125;/* // 也可以命名为keyPathsForValuesAffecting&lt;Key&gt;的类方法来达到同样的目的 + (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingName &#123; return [NSSet setWithObjects:@"firstName", @"lastName", nil]; &#125; */@end 3.当NSMutableArray中元素增加和减少时如何监听到?示例代码: @interface YAObject : NSObject@property (nonatomic, strong) NSMutableArray *nameList;@end@implementation YAObject// 实现集合代理对象: 一般建议-countOf&lt;Key&gt;和-objectIn&lt;Key&gt;AtIndex:- (NSUInteger)countOfNameList &#123; return [_nameList count];&#125;- (id)objectInNameListAtIndex:(NSUInteger)index &#123; return [_nameList objectAtIndex:index];&#125;// 至少实现一个插入方法和一个删除方法- (void)insertObject:(id)object inNameListAtIndex:(NSUInteger)index &#123; [_nameList insertObject:object atIndex:index];&#125;- (void)removeObjectFromNameListAtIndex:(NSUInteger)index &#123; [_nameList removeObjectAtIndex:index];&#125;@end 使用: 务必使用mutableArrayValueForKey获取集合 使用insertObject方法添加元素 比如: NSMutableArray *nameList = [self.obj mutableArrayValueForKey:@"nameList"];[nameList insertObject:obj atIndex:0]; 三、几个问题总结的几个问题。 1.KVO的实现原理是什么? Objective-C依托于强大的runtime机制来实现KVO。当我们第一次观察某个对象的属性时，runtime会创建一个新的继承自这个对象的class的subclass(前缀是NSKVONotifying_)。在这个新的subclass中，它会重写所有被观察的key的setter，然后将object的isa指针指向新创建的class(这个指针告诉Objective-C运行时某个object到底是什么类型的)。所以object神奇地变成了新的子类的实例。 ——摘自南峰子的博客。 新类重写了setter方法、class方法、dealloc方法和_isKVOA方法。如果自己生成重名的NSKVONotifying_XX类，会造成KVO失效。以监听YAPerson对象的age属性为例，主要逻辑的伪代码如下： @interface YAPerson : NSObject@property (nonatomic, assign) NSUInteger age;@end@implementation YAPerson@end@interface NSKVONotifying_YAPerson : YAPerson@end@implementation NSKVONotifying_YAPerson- (void)setAge:(NSUInteger)age &#123; _NSSetUnsignedLongLongValueAndNotify();&#125;void _NSSetUnsignedLongLongValueAndNotify() &#123; [self willChangeValueForKey:@"age"]; [super setAge:age]; [self didChangeValueForKey:@"age"];&#125;- (void)didChangeValueForKey:(NSString *)key &#123; [observer observeValueForKeyPath:@"age" ofObject:self change:change context:context];&#125;@end 2.KVO源码中添加观察者时整体的大致流程是什么? 将keyPath、class等信息封装成NSKeyValueProperty，分别解析一般属性(@&quot;aa&quot;)、可计算属性(@&quot;@aa&quot;)、属性链(@&quot;aa.bb.@cc.dd&quot;)，进行子类化，缓存在CFMutableSet中方便下次快速取出。 将NSKeyValueProperty、context、options、observer等信息封装成NSKeyValueObservance，缓存在NSHashTable中。 倘若设置了NSKeyValueObservingOptionInitial选项，会在注册观察服务时调用一次触发方法。 动态创建名为NSKVONotifying_+原来类名的新类，重写其dealloc、_isKVOA方法，再重写class方法，利用object_setClass()函数将其isa指针指向原先的类。 重写willChangeValueForKey:和didChangeValueForKey:方法，重写被观察属性的setter方法，在setter中先调用willChangeValueForKey:方法，然后调用父类的 setter 方法对成员变量赋值，之后再调用 didChangeValueForKey: 方法。 didChangeValueForKey: 方法中会调用observeValueForKeyPath:ofObject:change:context:方法。 3.KVO中所封装组件的关系是怎样的? 将keyPath、class等信息封装成NSKeyValueProperty，使用CFMutableSet缓存NSKeyValueProperty。 将observer、property、options、context 、originalObservable等信息封装成NSKeyValueObservance，使用NSHashTable(NSKeyValueShareableObservationInfos)缓存。 NSKeyValueObservationInfo与NSKeyValueObservance的关系是: NSKeyValueObservationInfo中有一个observances数组，数组里面是NSKeyValueObservance对象。 每一个object都有一个observationInfo属性(void *类型)，它与NSKeyValueObservationInfo会相互转化。 class和keyPath决定了是否是同一个NSKeyValueProperty。NSKeyValueProperty、Observer、options、context 决定了是否是同一个NSKeyValueObservance。 4.KVO多次使用完全相同的参数进行addObserver操作，也会得到相应次数的回调，如何做到?[self.obj addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:NULL];[self.obj addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:NULL];[self.obj addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:NULL];[self.obj addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:NULL]; 如上面代码，会有四次回调。 在每次添加观察者时，都会获取NSKeyValueObservance对象(可能从缓存中获取也可能新建)，并把它追加到object的observances数组中(即使该数组中已经存在完全相同（指针一致）的NSKeyValueObservance对象)，由此保证了多次addObserver操作会有多次回调。 通过打印可以证明： 5.如何手动触发KVO?手动调用willChangeValueForKey:和didChangeValueForKey:。也即：- (void)invokeKVOForAge &#123; [self.person willChangeValueForKey:@"age"]; [self.person didChangeValueForKey:@"age"];&#125; 只手动调用一个还不行，为什么？由原理可知，didChangeValueForKey:中才真正调用了observeValueForKeyPath:ofObject:change:context方法，所以didChangeValueForKey:毋庸置疑不可或缺。那么为什么还需要willChangeValueForKey:呢？查看文档，苹果一如既往地冷酷： Calls to this method are always paired with a matching call to willChangeValueForKey:. 意思是，这俩是成对存在的，你只管调就是了。好吧，这块源码确实没看明白，先挖个坑吧。 6.通过KVC修改属性会触发KVO吗?当KVC是通过setter方法设值时，无需多言，会触发KVO。当KVC是通过成员变量设值时，也会触发KVO，为什么？阅读源码可知，直接通过成员变量设值，会创建NSKeyValueIvarSetter对象，在该对象的构造方法中会调用_NSSetValueAndNotifyForKeyInIvar()函数，其实现如下：void _NSSetValueAndNotifyForKeyInIvar(id object, SEL selector, id value, NSString *key, Ivar ivar, IMP imp) &#123; [object willChangeValueForKey:key]; ((void (*)(id,SEL,id,NSString *, Ivar))imp)(object,NULL,value,key,ivar); [object didChangeValueForKey:key];&#125; 真相大白了，它调用了willChangeValueForKey:和didChangeValueForKey:方法，正是这个触发了KVO。需要注意的是，直接修改成员变量是不会触发KVO的。 四、添加观察者这一步骤中封装出了许多的类，同时也把产生的许多对象做了进一步的缓存处理。 1.封装1.1接口方法加锁，接口方法中使用pthread中的pthread_mutex_lock()和pthread_mutex_unlock函数。 // 这是个接口方法, 添加观察者分为两个流程: 1，根据class和keyPath获取NSKeyValueProperty对象。2，添加对property的观察。- (void)d_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context &#123; // 加锁 pthread_mutex_lock(&amp;_NSKeyValueObserverRegistrationLock); // 获取当前线程pthread _NSKeyValueObserverRegistrationLockOwner = pthread_self(); // 根据class和keyPath获取NSKeyValueProperty NSKeyValueProperty *property = NSKeyValuePropertyForIsaAndKeyPath(object_getClass(self),keyPath); // 添加对property的观察 [self _d_addObserver:observer forProperty:property options:options context:context]; // 解锁 pthread_mutex_unlock(&amp;_NSKeyValueObserverRegistrationLock);&#125; 1.2.添加对NSKeyValueProperty的观察的具体实现// 添加观察者过程中, 不是单纯地'观察'keyPath, 而是观察对keyPath封装的NSKeyValueProperty- (void)_addObserver:(id)observer forProperty:(NSKeyValueProperty *)property options:(int)options context:(void *)context &#123; if(options &amp; NSKeyValueObservingOptionInitial) &#123; // NSKeyValueObservingOptionInitial: 观察最初的值（在注册观察服务时会调用一次触发方法） NSString *keyPath = [property keyPath]; _NSKeyValueObserverRegistrationLockOwner = NULL; // 解锁 pthread_mutex_unlock(&amp;_NSKeyValueObserverRegistrationLock); id newValue = nil; if (options &amp; NSKeyValueObservingOptionNew) &#123; // newValue就是当前的值 newValue = [self valueForKeyPath:keyPath]; if (!newValue) &#123; newValue = [NSNull null]; // 使用NSNull对象 &#125; &#125; NSKeyValueChangeDictionary *changeDictionary = nil; // 创建NSKeyValueChangeDetails结构体 /* typedef struct &#123; NSKeyValueChange kind; id oldValue; id newValue; NSIndexSet *indexes; id extraData; &#125; NSKeyValueChangeDetails; */ NSKeyValueChangeDetails changeDetails = &#123;0&#125;; changeDetails.kind = NSKeyValueChangeSetting; changeDetails.oldValue = nil; changeDetails.newValue = newValue; changeDetails.indexes = nil; changeDetails.extraData = nil; // 函数1: 通知观察者, 传递结构体changeDetails NSKeyValueNotifyObserver(observer,keyPath, self, context, nil, NO,changeDetails, &amp;changeDictionary); [changeDictionary release]; // 加锁 pthread_mutex_lock(&amp;_NSKeyValueObserverRegistrationLock); // 获取当前pthread _NSKeyValueObserverRegistrationLockOwner = pthread_self(); &#125; // 函数2: 获取oldObservationInfo NSKeyValueObservationInfo *oldObservationInfo = _NSKeyValueRetainedObservationInfoForObject(self,property.containerClass); BOOL cacheHit = NO; NSKeyValueObservance *addedObservance = nil; id originalObservable = nil; if((options &gt;&gt; 8) &amp; 0x01) &#123; // _CFGetTSD: 获取线程信息 // Get some thread specific data from a pre-assigned slot. NSKeyValueObservingTSD *TSD = _CFGetTSD(NSKeyValueObservingTSDKey); if (TSD) &#123; originalObservable = TSD-&gt;implicitObservanceAdditionInfo.originalObservable; &#125; &#125; // 函数3: 获取newObservationInfo NSKeyValueObservationInfo *newObservationInfo = _NSKeyValueObservationInfoCreateByAdding(oldObservationInfo, observer, property, options, context, originalObservable,&amp;cacheHit,&amp;addedObservance); // 函数4: 将self的observationInfo设置为newObservationInfo _NSKeyValueReplaceObservationInfoForObject(self,property.containerClass,oldObservationInfo,newObservationInfo); // - (void)object:(id)object didAddObservance:(NSKeyValueObservance *)observance recurse:(BOOL)recurse &#123;&#125; // 实际上这个方法啥事也没做 [property object:self didAddObservance:addedObservance recurse:YES]; // 核心方法: 获取property中已经修改过的class Class isaForAutonotifying = [property isaForAutonotifying]; if(isaForAutonotifying) &#123; Class cls = object_getClass(self); if(cls != isaForAutonotifying) &#123; // 通过 object_setClass()修改isa指针, 设置自己的class为property的isaForAutonotifying object_setClass(self,isaForAutonotifying); &#125; &#125; [newObservationInfo release]; [oldObservationInfo release];&#125; 函数1: 设置changeDictionary并调用NSKVONotify()函数void NSKeyValueNotifyObserver(id observer,NSString * keyPath, id object, void *context, id originalObservable, BOOL isPriorNotification, NSKeyValueChangeDetails changeDetails, NSKeyValueChangeDictionary **changeDictionary) &#123; if(*changeDictionary) &#123; [*changeDictionary setDetailsNoCopy:changeDetails originalObservable:originalObservable]; &#125; else &#123; *changeDictionary = [[NSKeyValueChangeDictionary alloc] initWithDetailsNoCopy:changeDetails originalObservable:originalObservable isPriorNotification:isPriorNotification]; &#125; NSUInteger retainCountBefore = [*changeDictionary retainCount]; NSKVONotify(observer, keyPath, object, *changeDictionary, context); if(retainCountBefore != (NSUInteger)INTMAX_MAX &amp;&amp; retainCountBefore != [*changeDictionary retainCount]) &#123; [*changeDictionary retainObjects]; &#125;&#125; // NSKVONotify()函数就是调用observeValueForKeyPath方法void NSKVONotify(id observer, NSString *keyPath, id object, NSDictionary *changeDictionary, void *context) &#123; NSKeyValueObservingAssertRegistrationLockNotHeld(); [observer observeValueForKeyPath:keyPath ofObject:object change:changeDictionary context:context];&#125; 函数2: 获取object的observationInfo对象NSKeyValueObservationInfo *_NSKeyValueRetainedObservationInfoForObject(id object, NSKeyValueContainerClass *containerClass) &#123; NSKeyValueObservationInfo *observationInfo = nil; os_lock_lock(&amp;NSKeyValueObservationInfoSpinLock); if (containerClass) &#123; // 调用containerClass的cachedObservationInfoImplementation实现 observationInfo = ((NSKeyValueObservationInfo * (*)(id,SEL))containerClass.cachedObservationInfoImplementation)(object, @selector(observationInfo)); &#125; else &#123; // 直接获取object的d_observationInfo对象 observationInfo = (NSKeyValueObservationInfo *)[object d_observationInfo]; &#125; [observationInfo retain]; os_lock_unlock(&amp;NSKeyValueObservationInfoSpinLock); return observationInfo;&#125; 函数3: 获取’添加观察者’时所需要的NSKeyValueObservationInfo如果baseObservationInfo存在，则一顿封装操作后，会把封装完毕的NSKeyValueObservance“追加”到baseObservationInfo的observances数组中。如果baseObservationInfo不存在，则一顿封装操作后，会把封装完毕的NSKeyValueObservance放到新创建的NSKeyValueObservationInfo对象的observances数组中。最后，cacheHit告诉调用者是否有命中缓存，*addedObservance指向了observance对象。 NSKeyValueObservationInfo *_NSKeyValueObservationInfoCreateByAdding(NSKeyValueObservationInfo *baseObservationInfo, id observer, NSKeyValueProperty *property, int options, void *context, id originalObservable, BOOL *cacheHit, NSKeyValueObservance **addedObservance) &#123; NSKeyValueObservationInfo *createdObservationInfo = nil; os_lock_lock(&amp;NSKeyValueObservationInfoCreationSpinLock); // 使用弱引用表NSKeyValueShareableObservationInfos缓存观察者对象 if(!NSKeyValueShareableObservationInfos) &#123; // 自定义NSPointerFunctions NSPointerFunctions *pointerFunctions = [[NSPointerFunctions alloc] initWithOptions:NSPointerFunctionsWeakMemory]; // 设置hash函数 [pointerFunctions setHashFunction:NSKeyValueShareableObservationInfoNSHTHash]; // 设置判等函数 [pointerFunctions setIsEqualFunction:NSKeyValueShareableObservationInfoNSHTIsEqual]; // 创建NSHashTable NSKeyValueShareableObservationInfos = [[NSHashTable alloc] initWithPointerFunctions:pointerFunctions capacity:0]; &#125; if(!NSKeyValueShareableObservationInfoKeyIsa) &#123; NSKeyValueShareableObservationInfoKeyIsa = [NSKeyValueShareableObservationInfoKey class]; &#125; // 通过这个公共key到缓存表NSKeyValueShareableObservationInfos中查找 static NSKeyValueShareableObservationInfoKey * shareableObservationInfoKey; if(!shareableObservationInfoKey) &#123; // 第一次使用, 为空时创建 shareableObservationInfoKey = [[NSKeyValueShareableObservationInfoKey alloc] init]; &#125; // 设置key的信息 shareableObservationInfoKey.addingNotRemoving = YES; shareableObservationInfoKey.baseObservationInfo = baseObservationInfo; shareableObservationInfoKey.additionObserver = observer; shareableObservationInfoKey.additionProperty = property; shareableObservationInfoKey.additionOptions = options; shareableObservationInfoKey.additionContext = context; shareableObservationInfoKey.additionOriginalObservable = originalObservable; // 根据shareableObservationInfoKey的已有信息进行查找 NSKeyValueObservationInfo * existsObservationInfo = [NSKeyValueShareableObservationInfos member:shareableObservationInfoKey]; // 清空shareableObservationInfoKey的废弃信息(主要是减少对observer的引用计数) shareableObservationInfoKey.additionOriginalObservable = nil; shareableObservationInfoKey.additionObserver = nil; shareableObservationInfoKey.baseObservationInfo = nil; if(!existsObservationInfo) &#123; // 缓存中不存在 // (一般是第一次使用时)NSHashTable为空, 创建 if(!NSKeyValueShareableObservances) &#123; NSKeyValueShareableObservances = [NSHashTable weakObjectsHashTable]; &#125; // 通过这个公共key到缓存表NSKeyValueShareableObservances中查找 static NSKeyValueShareableObservanceKey *shareableObservanceKey; if(!shareableObservanceKey) &#123; // key不存在时创建 shareableObservanceKey = [[NSKeyValueShareableObservanceKey alloc] init]; &#125; // 设置key的信息 shareableObservanceKey.observer = observer; shareableObservanceKey.property = property; shareableObservanceKey.options = options; shareableObservanceKey.context = context; shareableObservanceKey.originalObservable = originalObservable; // 查找Observance缓存 NSKeyValueObservance *existsObservance = [NSKeyValueShareableObservances member:shareableObservanceKey]; // 清空shareableObservanceKey的废弃信息 shareableObservanceKey.originalObservable = nil; shareableObservanceKey.observer = nil; NSKeyValueObservance *observance = nil; if (!existsObservance) &#123; // 没有找到, 则创建observance observance = [[NSKeyValueObservance alloc] _initWithObserver:observer property:property options:options context:context originalObservable:originalObservable]; if(observance.cachedIsShareable) &#123; // 可以缓存, 放入NSKeyValueShareableObservances中 [NSKeyValueShareableObservances addObject:observance]; &#125; &#125; else &#123; // 找到了, observance就指向existsObservance observance = existsObservance; &#125; if (baseObservationInfo) &#123; // 复制baseObservationInfo并追加observance createdObservationInfo = [baseObservationInfo _copyByAddingObservance:observance]; &#125; else &#123; // 创建新的ObservationInfo createdObservationInfo = [[NSKeyValueObservationInfo alloc] _initWithObservances:&amp;observance count:1 hashValue:0]; &#125; if (createdObservationInfo.cachedIsShareable)&#123; // 允许缓存, 添加到NSKeyValueShareableObservationInfos中 [NSKeyValueShareableObservationInfos addObject:createdObservationInfo]; &#125; // 没有命中缓存 *cacheHit = NO; // 设置新添加的Observance *addedObservance = observance; &#125; else &#123; // 缓存中存在 // 设置命中缓存 *cacheHit = YES; // observance必定就是已存在的info.observance列表最后一个, 因为判断equal就是按照这个原则去判断的 // 判等函数: NSKeyValueShareableObservationInfoNSHTIsEqual() *addedObservance = existsObservationInfo.observances.lastObject; // 设置createdObservationInfo createdObservationInfo = existsObservationInfo; &#125; // 解锁 os_lock_unlock(&amp;NSKeyValueObservationInfoCreationSpinLock); return createdObservationInfo;&#125; 函数4:将object的observationInfo设置为newObservationInfovoid _NSKeyValueReplaceObservationInfoForObject(id object, NSKeyValueContainerClass * containerClass, NSKeyValueObservationInfo *oldObservationInfo, NSKeyValueObservationInfo *newObservationInfo) &#123; os_lock_lock(&amp;NSKeyValueObservationInfoSpinLock); if (newObservationInfo) [newObservationInfo retain]; // 不理解?????? /* typedef struct &#123; CFMutableArrayRef pendingArray;//0 ObservationInfoWatcher *firstWatcher;//4 ImplicitObservanceAdditionInfo implicitObservanceAdditionInfo; ImplicitObservanceRemovalInfo implicitObservanceRemovalInfo; &#125; NSKeyValueObservingTSD; */ NSKeyValueObservingTSD *TSD = _CFGetTSD(NSKeyValueObservingTSDKey); if(TSD) &#123; ObservationInfoWatcher *next = TSD-&gt;firstWatcher; while(next) &#123; if (next-&gt;object == object) &#123; [next-&gt;observationInfo release]; next-&gt;observationInfo = [newObservationInfo retain]; break; &#125; next = next-&gt;next; &#125; &#125; if(containerClass) &#123; // 调用object的d_setObservationInfo:方法, 并传参数newObservationInfo containerClass.cacheNSetObservationInfoImplementation(object, @selector(d_setObservationInfo:), newObservationInfo); &#125; else &#123; // 直接设置新值 [object d_setObservationInfo: newObservationInfo]; &#125; os_lock_unlock(&amp;NSKeyValueObservationInfoSpinLock);&#125; 2.缓存缓存查找逻辑是一致的: 确定这些对象的hash和isEqual:方法，通过创建与目标对象判等属性一致的key去查找。 2.1.NSKeyValueProperty的缓存if(!NSKeyValueProperties) &#123; // 创建集合NSKeyValueProperties CFSetCallBacks callbacks = &#123;0&#125;; callbacks.version = kCFTypeSetCallBacks.version; callbacks.retain = kCFTypeSetCallBacks.retain; callbacks.release = kCFTypeSetCallBacks.release; callbacks.copyDescription = kCFTypeSetCallBacks.copyDescription; // 设置CFSet集合中元素判等的依据 callbacks.equal = (CFSetEqualCallBack)NSKeyValuePropertyIsEqual; // 设置CFSet集合中元素的hash值获取函数 callbacks.hash = (CFSetHashCallBack)NSKeyValuePropertyHash; NSKeyValueProperties = CFSetCreateMutable(NULL, 0, &amp;callbacks);&#125;// 把property添加到NSKeyValueProperties集合中CFSetAddValue(NSKeyValueProperties, property); CFSet集合中元素判等的依据 BOOL NSKeyValuePropertyIsEqual(NSKeyValueProperty *property1, NSKeyValueProperty *property2) &#123; return (property1.containerClass == property2.containerClass) &amp;&amp; (property1.keyPath == property2.keyPath || [property1.keyPath isEqual: property2.keyPath]);&#125; 返回NSKeyValueProperty的hash值 NSUInteger NSKeyValuePropertyHash(NSKeyValueProperty *property) &#123; return property.keyPath.hash ^ (NSUInteger)(void *)property.containerClass;&#125; 再次证明了 class和keyPath决定了是否是同一个NSKeyValueProperty。 2.2.NSKeyValueObservance的缓存缓存查找 NSHashTable *NSKeyValueShareableObservances;if(!NSKeyValueShareableObservances) &#123; NSKeyValueShareableObservances = [NSHashTable weakObjectsHashTable];&#125;// observance查找keystatic DNSKeyValueShareableObservanceKey *shareableObservanceKey;if(!shareableObservanceKey) &#123; shareableObservanceKey = [[DNSKeyValueShareableObservanceKey alloc] init];&#125;shareableObservanceKey.observer = observer;shareableObservanceKey.property = property;shareableObservanceKey.options = options;shareableObservanceKey.context = context;shareableObservanceKey.originalObservable = originalObservable;// 查找缓存NSKeyValueObservance *existsObservance = [NSKeyValueShareableObservances member:shareableObservanceKey];shareableObservanceKey.originalObservable = nil;shareableObservanceKey.observer = nil; 重写NSKeyValueObservance的hash和isEqual:方法 - (NSUInteger)hash &#123; return _NSKVOPointersHash(5, _observer, _property, (void *)(NSUInteger)(_options), _context, _originalObservable);&#125;- (BOOL)isEqual:(id)object &#123; if (object == self) return YES; if (![object isKindOfClass: self.class]) return NO; NSKeyValueObservance *other = (NSKeyValueObservance *)object; return other.observer == self.observer &amp;&amp; other.options == self.options &amp;&amp; other.context == self.context &amp;&amp; other.originalObservable == self.originalObservable;&#125; 2.3.NSKeyValueObservationInfo的缓存缓存查找 NSHashTable *NSKeyValueShareableObservationInfos;// observationInfo缓存if(!NSKeyValueShareableObservationInfos) &#123; NSPointerFunctions *pointerFunctions = [[NSPointerFunctions alloc] initWithOptions:NSPointerFunctionsWeakMemory]; [pointerFunctions setHashFunction:NSKeyValueShareableObservationInfoNSHTHash]; [pointerFunctions setIsEqualFunction:NSKeyValueShareableObservationInfoNSHTIsEqual]; NSKeyValueShareableObservationInfos = [[NSHashTable alloc] initWithPointerFunctions:pointerFunctions capacity:0];&#125; 2.4.NSKeyValueObservationInfo的存储(observationInfo)当封装成NSKeyValueObservationInfo时，weak的NSHashTable并不负责存储，那么，谁负责真正的存储呢? Take or return a pointer that identifies information about all of the observers that are registered with the receiver, the options that were used at registration-time, etc. The default implementation of these methoNS store observation info in a global dictionary keyed by the receivers’ pointers. For improved performance, you can override these methoNS to store the opaque data pointer in an instance variable. Overrides of these methoNS must not attempt to send Objective-C messages to the passed-in observation info, including -retain and -release. 这个方法的默认实现是以对象的指针作为key，从一个全局的字典中获取信息。 如何获取对象的指针？这里有个定义：OBSERVATION_INFO_KEY的定义是: #define OBSERVATION_INFO_KEY(object) ((void *)(~(NSUInteger)(object))) CFMutableDictionaryRef NSKeyValueObservationInfoPerObject = NULL;- (void *)observationInfo &#123; return NSKeyValueObservationInfoPerObject ? (void *)CFDictionaryGetValue(NSKeyValueObservationInfoPerObject, OBSERVATION_INFO_KEY(self)) : NULL;&#125;- (void)setObservationInfo:(void *)info &#123; if(!NSKeyValueObservationInfoPerObject) &#123; NSKeyValueObservationInfoPerObject = CFDictionaryCreateMutable(NULL, 0, NULL, NULL); &#125; if (info) &#123; CFDictionarySetValue(NSKeyValueObservationInfoPerObject, OBSERVATION_INFO_KEY(self), info); &#125; else &#123; CFDictionaryRemoveValue(NSKeyValueObservationInfoPerObject, OBSERVATION_INFO_KEY(self)); &#125;&#125; 即这个方法的默认实现是以对象的指针作为key，从一个全局的字典中获取信息。由此，我们可以理解为，KVO的信息是存储在一个全局字典中，而不是存储在对象本身。不过，为了提高效率，我们可以重写observationInfo属性的set和get方法，以将这个不透明的数据指针存储到一个实例变量中。但是，在重写时，我们不应该尝试去向这些数据发送一个Objective-C消息，包括retain和release。 3.新建与重写在这一步骤中，动态创建了原来class的子类，当然，也重写和添加了许多方法。 3.1动态创建子类的核心实现动态创建子类中，重写了dealloc、class、_isKVOA方法。 NSKeyValueNotifyingInfo *_NSKVONotifyingCreateInfoWithOriginalClass(Class originalClass) &#123; static IMP NSObjectWillChange; static IMP NSObjectDidChange; // 构造新的子类名 const char *originalClassName = class_getName(originalClass); size_t size = strlen(originalClassName) + 16; char *newClassName = (char *)malloc(size); // #define NOTIFY_CLASSNAME_PREFIX "NSKVONotifying_" strlcpy(newClassName, NOTIFY_CLASSNAME_PREFIX, size); strlcat(newClassName, originalClassName, size); // 创建子类 Class newSubClass = objc_allocateClassPair(originalClass, newClassName, sizeof(NSKeyValueNotifyingInfo)); objc_registerClassPair(newSubClass); free(newClassName); unsigned char *ivars = object_getIndexedIvars(newSubClass); // 创建NSKeyValueNotifyingInfo对象, 封装子类\原始类等信息 NSKeyValueNotifyingInfo *notifyingInfo = (NSKeyValueNotifyingInfo *)ivars; notifyingInfo-&gt;originalClass = originalClass; notifyingInfo-&gt;newSubClass = newSubClass; notifyingInfo-&gt;notifyingKeys = CFSetCreateMutable(NULL, 0, &amp;kCFCopyStringSetCallBacks); notifyingInfo-&gt;selKeyMap = CFDictionaryCreateMutable(NULL, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); pthread_mutexattr_t mutexattr; pthread_mutexattr_init(&amp;mutexattr); pthread_mutexattr_settype(&amp;mutexattr, PTHREAD_MUTEX_RECURSIVE); pthread_mutex_init(&amp;notifyingInfo-&gt;mutex, &amp;mutexattr); pthread_mutexattr_destroy(&amp;mutexattr); // 获取NSObject类的 willChangeValueForKey 和 didChangeValueForKey实现 static dispatch_once_t NSObjectIMPLookupOnce; dispatch_once(&amp;NSObjectIMPLookupOnce, ^&#123; NSObjectWillChange = class_getMethodImplementation([NSObject class], @selector(d_willChangeValueForKey:)); NSObjectDidChange = class_getMethodImplementation([NSObject class], @selector(d_didChangeValueForKey:)); &#125;); // 判断originalClass类是否重写了 willChangeValueForKey 或 didChangeValueForKey // 就是拿NSObject的实现与originalClass的实现做对比(函数指针IMP比较) notifyingInfo-&gt;overrideWillOrDidChange = class_getMethodImplementation(notifyingInfo-&gt;originalClass, @selector(d_willChangeValueForKey:)) != NSObjectWillChange || class_getMethodImplementation(notifyingInfo-&gt;originalClass, @selector(d_didChangeValueForKey:)) != NSObjectDidChange; // 对notifyingInfo的originalClass添加 _isKVOA方法 NSKVONotifyingSetMethodImplementation(notifyingInfo, ISKVOA_SELECTOR, (IMP)NSKVOIsAutonotifying, NULL); // 对notifyingInfo的originalClass添加 dealloc方法 NSKVONotifyingSetMethodImplementation(notifyingInfo, @selector(dealloc), (IMP)NSKVODeallocate, NULL); // 对notifyingInfo的originalClass添加 class方法 NSKVONotifyingSetMethodImplementation(notifyingInfo, @selector(class), (IMP)NSKVOClass, NULL); return notifyingInfo;&#125; 添加_isKVOA方法BOOL NSKVOIsAutonotifying() &#123; return YES;&#125; 重写class方法Class NSKVOClass(id object, SEL selector) &#123; // 新的class: NSKVONotifying_XXXX Class currentClass = object_getClass(object); // 原先的class: XXXX Class originalClass = _NSKVONotifyingOriginalClassForIsa(currentClass); if (currentClass == originalClass) &#123; // 相同, 返回object的currentClass Method m = class_getInstanceMethod(currentClass, selector); return ((Class (*)(id,Method))method_invoke)(object, m); &#125; else &#123; // 不同, 返回originalClass return [originalClass class]; &#125;&#125; 重写dealloc方法获取object对应的observationInfo(对象)并把它放到结构体中，在调用完object原先的dealloc方法之后判断observationInfo是否还存在，若存在说明observer没有在dealloc之前被移除掉，进而抛出异常。 void NSKVODeallocate(id object, SEL selector) &#123; // 获取object对应的observationInfo NSKeyValueObservationInfo *observationInfo = _NSKeyValueRetainedObservationInfoForObject(object, nil); ObservationInfoWatcher watcher = &#123;object, observationInfo, NULL&#125;; _NSKeyValueAddObservationInfoWatcher(&amp;watcher); // 获取notifyInfo NSKeyValueNotifyingInfo *notifyInfo = (NSKeyValueNotifyingInfo *)object_getIndexedIvars(object_getClass(object)); // 调用object原来的dealloc实现 Method originDellocMethod = class_getInstanceMethod(notifyInfo-&gt;originalClass, selector); ((id (*)(id,Method))method_invoke)(object, originDellocMethod); @try &#123; if(watcher.observationInfo) &#123; // observationInfo不存在才对, 如果还存在, 说明没有正确地移除observer BOOL keyExistsAndHasValidFormat = false; BOOL cleansUpBeforeThrowing = false; cleansUpBeforeThrowing = (BOOL)CFPreferencesGetAppBooleanValue(CFSTR("NSKVODeallocateCleansUpBeforeThrowing"), kCFPreferencesCurrentApplication, (Boolean *)&amp;keyExistsAndHasValidFormat); // key存在且key对应的value为YES cleansUpBeforeThrowing = cleansUpBeforeThrowing &amp;&amp; keyExistsAndHasValidFormat; // dyld_get_program_sdk_version返回系统版本 if (dyld_get_program_sdk_version() &gt; 0x7FFFF || cleansUpBeforeThrowing) &#123; if (cleansUpBeforeThrowing) &#123; _NSKeyValueRemoveObservationInfoForObject(object, watcher.observationInfo); &#125; [NSException raise:NSInternalInconsistencyException format:@"An instance %p of class %@ was deallocated while key value observers were still registered with it. Current observation info: %@", object, notifyInfo-&gt;originalClass, watcher.observationInfo]; &#125; else &#123; NSKVODeallocateBreak(object); &#125; &#125; &#125; @catch (NSException *exception) &#123; [exception raise]; &#125; @finally &#123; // 移除watcher _NSKeyValueRemoveObservationInfoWatcher(&amp;watcher); [watcher.observationInfo release]; &#125;&#125; 4.回调通知上文分析，NSKeyValueNotifyObserver()就是回调的函数，通过它调用observeValueForKeyPath:ofObject:change:context:方法。这里还剩下最后一个问题，回调是怎么处理的? 在NSKVONotifyingEnableForInfoAndKey()函数中重写setter方法，之后在NSSetPrimitiveValueAndNotify()函数中先调用willChangeValueForKey，再调用原先的setter方法，再调用didChangeValueForKey。 static inline void NSSetPrimitiveValueAndNotify(id object,SEL selector, void (^setValueWithImplementation)(IMP imp)) &#123; NSKeyValueNotifyingInfo *info = object_getIndexedIvars(object_getClass(object)); pthread_mutex_lock(&amp;info-&gt;mutex); NSString *key = CFDictionaryGetValue(info-&gt;selKeyMap, selector); key = [key copyWithZone:nil]; pthread_mutex_unlock(&amp;info-&gt;mutex); if (info-&gt;overrideWillOrDidChange) &#123; [object willChangeValueForKey:key]; IMP imp = class_getMethodImplementation(info-&gt;originalClass, selector); setValueWithImplementation(imp); [object didChangeValueForKey:key]; &#125; else &#123; [object changeValueForKey:key key:nil key:nil usingBlock:^&#123; IMP imp = class_getMethodImplementation(info-&gt;originalClass, selector); setValueWithImplementation(imp); &#125;]; &#125; [key release];&#125; 当然，这里的didChangeValueForKey也被重写实现了，它会调用真正的回调observeValueForKeyPath:ofObject:change:context:方法。 五、移除观察者找到NSKeyValueObservance移除即可。 NSKeyValueObservationInfo *_NSKeyValueObservationInfoCreateByRemoving(NSKeyValueObservationInfo *baseObservationInfo, id observer, NSKeyValueProperty *property, void *context, BOOL shouldCompareContext, id originalObservable, BOOL *cacheHit, NSKeyValueObservance **removalObservance) &#123; NSKeyValueObservationInfo *createdObservationInfo = nil; // 当前已经存在的observance的数量 NSUInteger observanceCount = CFArrayGetCount((CFArrayRef)baseObservationInfo.observances); NSKeyValueObservance *observancesBuff[observanceCount]; CFArrayGetValues((CFArrayRef)baseObservationInfo.observances, CFRangeMake(0, observanceCount), (const void **)observancesBuff); NSUInteger removalObservanceIndex = NSNotFound; for (NSInteger i = observanceCount - 1; i &gt;= 0; --i) &#123; // 逐个遍历observancesBuff数组中的元素 NSKeyValueObservance *observance = observancesBuff[i]; // property和observer一致 if (observance.property == property &amp;&amp; observance.observer == observer) &#123; // 不需要比较context或者context一致 if (!shouldCompareContext || observance.context == context) &#123; // originalObservable一致 if (!originalObservable || observance.originalObservable == originalObservable) &#123; // 需要移除的observance *removalObservance = observance; // 确定了将要移除的observance的索引 removalObservanceIndex = i; break; &#125; &#125; &#125; &#125; // 已经找到需要移除的observance if (*removalObservance) &#123; // 原先observance的数量大于1个 if (observanceCount &gt; 1) &#123; os_lock_lock(&amp;NSKeyValueObservationInfoCreationSpinLock); // NSKeyValueShareableObservationInfos缓存不存在, 创建 if (!NSKeyValueShareableObservationInfos) &#123; NSPointerFunctions *functions = [[NSPointerFunctions alloc] initWithOptions:NSPointerFunctionsWeakMemory]; [functions setHashFunction:NSKeyValueShareableObservationInfoNSHTHash]; [functions setIsEqualFunction:NSKeyValueShareableObservationInfoNSHTIsEqual]; NSKeyValueShareableObservationInfos = [[NSHashTable alloc] initWithPointerFunctions:functions capacity:0]; [functions release]; &#125; if (!NSKeyValueShareableObservationInfoKeyIsa) &#123; // 就是NSKeyValueShareableObservationInfoKey.class NSKeyValueShareableObservationInfoKeyIsa = NSKeyValueShareableObservationInfoKey.self; &#125; static NSKeyValueShareableObservationInfoKey * shareableObservationInfoKey = nil; // 构建查找缓存的Key if (!shareableObservationInfoKey) &#123; shareableObservationInfoKey = [[NSKeyValueShareableObservationInfoKey alloc] init]; &#125; shareableObservationInfoKey.addingNotRemoving = NO; shareableObservationInfoKey.baseObservationInfo = baseObservationInfo; shareableObservationInfoKey.removalObservance = *removalObservance; shareableObservationInfoKey.removalObservanceIndex = removalObservanceIndex; shareableObservationInfoKey.cachedHash = NSKeyValueShareableObservationInfoNSHTHash(shareableObservationInfoKey, NULL); // 尝试在缓存中查找NSKeyValueObservationInfo NSKeyValueObservationInfo *existsObservationInfo = [NSKeyValueShareableObservationInfos member:shareableObservationInfoKey]; // 重置key的数据 shareableObservationInfoKey.removalObservance = nil; shareableObservationInfoKey.baseObservationInfo = nil; NSUInteger cachedHash = shareableObservationInfoKey.cachedHash; shareableObservationInfoKey.cachedHash = 0; if (!existsObservationInfo) &#123; // 在缓存中没有找到, 移除removalObservanceIndex对应的元素 memmove(observancesBuff + removalObservanceIndex, observancesBuff + removalObservanceIndex + 1, (observanceCount - (removalObservanceIndex + 1)) * sizeof(NSKeyValueObservance *)); // 重新创建ObservationInfo, 数量为observanceCount - 1 createdObservationInfo = [[NSKeyValueObservationInfo alloc] _initWithObservances:observancesBuff count:observanceCount - 1 hashValue:cachedHash]; if (createdObservationInfo.cachedIsShareable) &#123; // 缓存ObservationInfo [NSKeyValueShareableObservationInfos addObject:createdObservationInfo]; &#125; // 没有命中缓存 *cacheHit = NO; &#125; else &#123; // 命中缓存 *cacheHit = YES; // 直接赋值existsObservationInfo createdObservationInfo = [existsObservationInfo retain]; &#125; os_lock_unlock(&amp;NSKeyValueObservationInfoCreationSpinLock); return createdObservationInfo; &#125; else &#123; // 原先只有一个observance, 命中缓存 *cacheHit = YES; &#125; &#125; // 没有找到需要移除的observance, 返回nil return nil;&#125; 六、KVO自实现有很多同学尝试自己实现了KVO，有按照原生接口的，也有自我发挥直接传递block的。由于之前我已经读过一些开源的代码，见《「KVOController」的封装》，作者就是使用了block很好地封装了KVO的回调。所以，这里还是试着按照原生接口实现一下。 由于对源码理解地不是十分透彻，再加上能力有限，在尝试实现过程中遇到不少问题，幸好都解决了。当然，代码肯定有不少问题的，而且仅仅实现一点核心功能，姑且当做玩具看看吧。 1.接口@interface NSObject(YAKVO)@property void *ya_observationInfo;- (void)ya_willChangeValueForKey:(NSString *)key;- (void)ya_didChangeValueForKey:(NSString *)key;- (void)ya_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;- (void)ya_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(void *)context;- (void)ya_observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context;@end 2.实现#define ClassPrefixCStr "YAKVONotifying_" // 新类的前缀#define ClassPrefix @ ClassPrefixCStr#define OBSERVATION_INFO_KEY(object) ((void *)(~(NSUInteger)(object)))static NSMutableDictionary *YAKeyValueChangeDictionary = nil;/// 一些私有方法和属性@interface NSObject(YAKVOPrivate)@end@implementation NSObject(YAKVOPrivate)- (BOOL)ya_isKVOClass &#123; return NO;&#125;- (void)ya_changeValueForKey:(NSString *)key usingBlock:(void (^)(void))block &#123; [self ya_willChangeValueForKey:key]; if (block) block(); [self ya_didChangeValueForKey:key];&#125;@end/// 包装keyPath和originalClass@interface YAKeyValueProperty : NSObject@property (nonatomic, assign) Class isaForAutonotifying;@property (nonatomic, copy) NSString *keyPath;@property (nonatomic, assign) Class originalClass;- (instancetype)initWithOriginalClass:(Class)originalClass keyPath:(NSString *)keyPath;@end@implementation YAKeyValueProperty- (instancetype)initWithOriginalClass:(Class)originalClass keyPath:(NSString *)keyPath &#123; if (self = [super init]) &#123; _originalClass = originalClass; _keyPath = keyPath; &#125; return self;&#125;- (Class)isaForAutonotifying &#123; // 构造新的子类名 const char *originalClassName = class_getName(_originalClass); size_t size = strlen(originalClassName) + 16; char *newClassName = (char *)malloc(size); strlcpy(newClassName, ClassPrefixCStr, size); strlcat(newClassName, originalClassName, size); // 创建子类 Class newSubClass = objc_allocateClassPair(_originalClass, newClassName, 0); objc_registerClassPair(newSubClass); free(newClassName); // Setter方法替换 NSString *uppercase= [[_keyPath substringToIndex:1] uppercaseString]; NSString *last = [_keyPath substringFromIndex:1]; NSString *setter = [NSString stringWithFormat:@"set%@%@:", uppercase, last]; SEL sel = NSSelectorFromString(setter); Method method = class_getInstanceMethod(newSubClass, sel); if (method) &#123; const char *typeEncoding = method_getTypeEncoding(method); class_replaceMethod(newSubClass, sel, (IMP)YASetValueAndNotifyForKey, typeEncoding); &#125; else &#123; [[NSException exceptionWithName:@"缺少参数" reason:@"没有实现Setter方法" userInfo:nil] raise]; &#125; // class方法替换、ya_isKVOClass方法替换 YAKVONotifyingSetMethodImplementation(newSubClass, @selector(ya_isKVOClass), (IMP)YAKVOIsAutonotifying); YAKVONotifyingSetMethodImplementation(newSubClass, @selector(class), (IMP)YAKVOClass); return newSubClass;&#125;// 对应originalClass的ya_isKVOClass方法BOOL YAKVOIsAutonotifying(id object, SEL sel) &#123; return YES;&#125;// 对应originalClass的class方法Class YAKVOClass(id object, SEL sel) &#123; // 新的class: NSKVONotifying_XXXX Class currentClass = object_getClass(object); if ([object ya_isKVOClass]) &#123; NSString *clsStr = [NSStringFromClass(currentClass) stringByReplacingOccurrencesOfString:ClassPrefix withString:@""]; return NSClassFromString(clsStr); &#125; return currentClass;&#125;// 对应originalClass的setter方法void YASetValueAndNotifyForKey(id obj, SEL sel, id value, IMP imp) &#123; NSString *key = [[NSStringFromSelector(sel) substringFromIndex:3] lowercaseString]; key = [key substringToIndex:key.length - 1]; [obj ya_changeValueForKey:key usingBlock:^&#123; Class cls = [obj class]; // 调用父类的setter方法 IMP superImp = class_getMethodImplementation(cls, sel); ((void (*)(id ,SEL , id))superImp)(obj, sel, value); &#125;];&#125;// 对某个class添加实例方法void YAKVONotifyingSetMethodImplementation(Class cls, SEL sel, IMP imp) &#123; Method originMethod = class_getInstanceMethod(cls, sel); const char *encoding = NULL; if (originMethod) &#123; encoding = method_getTypeEncoding(originMethod); class_addMethod(cls, sel, imp, encoding); &#125;&#125;@end/// 包装property、observer、context、options@interface YAKeyValueObservance : NSObject@property (nonatomic, weak) YAKeyValueProperty *property;@property (nonatomic, weak) id observer;@property (nonatomic, assign) void *context;@property (nonatomic, assign) int options;- (instancetype)initWithObserver:(id)observer property:(YAKeyValueProperty *)property options:(int)options context:(void *)context;@end@implementation YAKeyValueObservance- (instancetype)initWithObserver:(id)observer property:(YAKeyValueProperty *)property options:(int)options context:(void *)context &#123; if (self = [super init]) &#123; _observer = observer; _property = property; _options = options; _context = context; &#125; return self;&#125;- (NSUInteger)hash &#123; NSUInteger observerContextHash = [[NSString stringWithFormat:@"%p-%p", _observer, _context] hash]; return observerContextHash ^ _property.hash ^ _options;&#125;- (BOOL)isEqual:(id)object &#123; if (object == self) return YES; if (![object isKindOfClass:object_getClass(self)]) return NO; YAKeyValueObservance *other = (YAKeyValueObservance *)object; return other.observer == self.observer &amp;&amp; other.options == self.options &amp;&amp; other.context == self.context;&#125;@end/// 包装YAKeyValueObservance数组@interface YAKeyValueObservationInfo : NSObject@property (nonatomic, strong) NSArray &lt;YAKeyValueObservance *&gt; *observances;- (instancetype)initWithObservances:(NSArray &lt;YAKeyValueObservance *&gt; *)observances count:(NSUInteger)count;@end@implementation YAKeyValueObservationInfo- (instancetype)initWithObservances:(NSArray&lt;YAKeyValueObservance *&gt; *)observances count:(NSUInteger)count &#123; if (self = [super init]) &#123; _observances = [[NSArray alloc] initWithArray:observances]; &#125; return self;&#125;@end/// 配置YAKeyValueObservationInfoKey，去查询匹配的YAKeyValueObservationInfo@interface YAKeyValueObservationInfoKey : NSObject@property (nonatomic, strong) YAKeyValueObservationInfo *baseObservationInfo;@property (nonatomic, strong) NSObject *additionObserver;@property (nonatomic, strong) YAKeyValueProperty *additionProperty;@property (nonatomic, assign) NSUInteger additionOptions;@property (nonatomic, assign) void* additionContext;@end@implementation YAKeyValueObservationInfoKey@end#pragma mark - Private methodsBOOL YAKeyValuePropertyIsEqual(YAKeyValueProperty *property1, YAKeyValueProperty *property2) &#123; return (property1.originalClass == property2.originalClass) &amp;&amp; (property1.keyPath == property2.keyPath || [property1.keyPath isEqual: property2.keyPath]);&#125;NSUInteger YAKeyValuePropertyHash(YAKeyValueProperty *property) &#123; return property.keyPath.hash ^ (NSUInteger)(__bridge void *)property.originalClass;&#125;// 获取YAKeyValuePropertystatic inline YAKeyValueProperty *getKeyValueProperty(Class cls, NSString *keyPath) &#123; // 缓存集合 static CFMutableSetRef YAKeyValueProperties; if(!YAKeyValueProperties) &#123; // 创建YAKeyValueProperties CFSetCallBacks callbacks = &#123;0&#125;; callbacks.version = kCFTypeSetCallBacks.version; callbacks.retain = kCFTypeSetCallBacks.retain; callbacks.release = kCFTypeSetCallBacks.release; callbacks.copyDescription = kCFTypeSetCallBacks.copyDescription; callbacks.equal = (CFSetEqualCallBack)YAKeyValuePropertyIsEqual; callbacks.hash = (CFSetHashCallBack)YAKeyValuePropertyHash; YAKeyValueProperties = CFSetCreateMutable(NULL, 0, &amp;callbacks); &#125; static YAKeyValueProperty *finder; if (!finder) finder = [YAKeyValueProperty new]; finder.originalClass = cls; finder.keyPath = keyPath; YAKeyValueProperty *property = CFSetGetValue(YAKeyValueProperties, (__bridge const void *)(finder)); if (!property) &#123; // 缓存中没有找到, 创建 property = [[YAKeyValueProperty alloc] initWithOriginalClass:cls keyPath:keyPath]; // 添加到缓存中 CFSetAddValue(YAKeyValueProperties, (__bridge const void *)(property)); &#125; return property;&#125;// 获取YAKeyValueObservancestatic inline YAKeyValueObservance *getKeyValueObservance(YAKeyValueProperty *property, id observer, void *context, int options) &#123; static NSHashTable *YAKeyValueShareableObservances; if (!YAKeyValueShareableObservances) &#123; YAKeyValueShareableObservances = [NSHashTable weakObjectsHashTable]; &#125; static YAKeyValueObservance *finder; if (!finder) finder = [YAKeyValueObservance new]; finder.property = property; finder.context = context; finder.observer = observer; finder.options = options; YAKeyValueObservance *observance = [YAKeyValueShareableObservances member:finder]; if (!observance) &#123; // 缓存中没有找到, 创建 observance = [[YAKeyValueObservance alloc] initWithObserver:observer property:property options:options context:context]; // 添加到缓存中 [YAKeyValueShareableObservances addObject:observance]; &#125; return observance;&#125;NSUInteger YAKeyValueObservationInfoNSHTHash(const void *item, NSUInteger (*size)(const void *item)) &#123; if (object_getClass((__bridge id)item) == YAKeyValueObservationInfoKey.class) &#123; YAKeyValueObservationInfoKey *key = (__bridge YAKeyValueObservationInfoKey *)item; return key.baseObservationInfo.observances.firstObject.hash; &#125; else &#123; YAKeyValueObservationInfo *info = (__bridge YAKeyValueObservationInfo *)item; return info.observances.firstObject.hash; &#125;&#125;BOOL YAKeyValueObservationInfoNSHTIsEqual(const void *item1, const void *item2, NSUInteger (* size)(const void * item)) &#123; // 这里仅仅写了YAKeyValueObservationInfoKey与YAKeyValueObservationInfo的比较 if (object_getClass((__bridge id)item1) == YAKeyValueObservationInfoKey.class || object_getClass((__bridge id)item2) == YAKeyValueObservationInfoKey.class) &#123; YAKeyValueObservationInfo *info = nil; YAKeyValueObservationInfoKey *key = nil; // 确定哪一个是info, 哪一个是key if (object_getClass((__bridge id)item1) == YAKeyValueObservationInfoKey.class) &#123; info = (__bridge YAKeyValueObservationInfo *)item2; key = (__bridge YAKeyValueObservationInfoKey *)item1; &#125; else &#123; info = (__bridge YAKeyValueObservationInfo *)item1; key = (__bridge YAKeyValueObservationInfoKey *)item2; &#125; NSArray &lt;YAKeyValueObservance *&gt; *observancesInKey = key.baseObservationInfo.observances; NSArray &lt;YAKeyValueObservance *&gt; *observancesInInfo = info.observances; // key中observance的数量 NSUInteger countInkey = observancesInKey.count; // info中observance的数量 NSUInteger countInInfo = observancesInInfo.count; if (countInkey != countInInfo) return NO; for (NSUInteger i = 0; i &lt; countInkey; i++) &#123; // 保证每个observance完全匹配 if (observancesInKey[i] != observancesInInfo[i]) &#123; return NO; &#125; &#125; return YES; &#125; return NO;&#125;#pragma mark - Public methods@implementation NSObject(YAKVO)CFMutableDictionaryRef YAKeyValueObservationInfoPerObject = NULL;- (void *)ya_observationInfo &#123; return YAKeyValueObservationInfoPerObject ? (void *)CFDictionaryGetValue(YAKeyValueObservationInfoPerObject, OBSERVATION_INFO_KEY(self)) : NULL;&#125;- (void)setYa_observationInfo:(void *)info &#123; if (!YAKeyValueObservationInfoPerObject) &#123; CFDictionaryValueCallBacks callbacks = &#123;0&#125;; callbacks.version = kCFTypeDictionaryKeyCallBacks.version; callbacks.retain = kCFTypeDictionaryKeyCallBacks.retain; callbacks.release = kCFTypeDictionaryKeyCallBacks.release; callbacks.copyDescription = kCFTypeDictionaryKeyCallBacks.copyDescription; YAKeyValueObservationInfoPerObject = CFDictionaryCreateMutable(NULL, 0, NULL, &amp;callbacks); &#125; if (info) &#123; CFDictionarySetValue(YAKeyValueObservationInfoPerObject, OBSERVATION_INFO_KEY(self), info); &#125; else &#123; CFDictionaryRemoveValue(YAKeyValueObservationInfoPerObject, OBSERVATION_INFO_KEY(self)); &#125;&#125;- (void)ya_willChangeValueForKey:(NSString *)key &#123; if (!YAKeyValueChangeDictionary) &#123; YAKeyValueChangeDictionary = [NSMutableDictionary dictionary]; &#125; id oldValue = nil; oldValue = [self valueForKeyPath:key]; if (!oldValue) oldValue = [NSNull null]; [YAKeyValueChangeDictionary setObject:oldValue forKey:[NSString stringWithFormat:@"%p-old", self]];&#125;- (void)ya_didChangeValueForKey:(NSString *)key &#123; if (self.ya_isKVOClass) &#123; YAKeyValueProperty *property = getKeyValueProperty(self.class, key); YAKeyValueObservationInfo *observation = self.ya_observationInfo; [observation.observances enumerateObjectsUsingBlock:^(YAKeyValueObservance *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([obj.property isEqual:property]) &#123; NSMutableDictionary *change = [NSMutableDictionary dictionary]; if (obj.options &amp; NSKeyValueObservingOptionOld) &#123; id old = [YAKeyValueChangeDictionary objectForKey:[NSString stringWithFormat:@"%p-old", self]]; [change setObject:old forKey:@"old"]; &#125; else &#123; [YAKeyValueChangeDictionary removeObjectForKey:[NSString stringWithFormat:@"%p-old", self]]; &#125; if (obj.options &amp; NSKeyValueObservingOptionNew) &#123; id newValue = nil; newValue = [self valueForKeyPath:key]; if (!newValue) newValue = [NSNull null]; [YAKeyValueChangeDictionary setObject:newValue forKey:[NSString stringWithFormat:@"%p-new", self]]; [change setObject:newValue forKey:@"new"]; &#125; [obj.observer ya_observeValueForKeyPath:key ofObject:self change:change context:nil]; &#125; &#125;]; &#125;&#125;- (void)ya_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context &#123; YAKeyValueProperty *property = getKeyValueProperty(self.class, keyPath); YAKeyValueObservance *observance = getKeyValueObservance(property, observer, context, options); static NSHashTable *YAKeyValueShareableObservationInfos; if (!YAKeyValueShareableObservationInfos) &#123; NSPointerFunctions *pointerFunctions = [[NSPointerFunctions alloc] initWithOptions:NSPointerFunctionsWeakMemory]; [pointerFunctions setHashFunction:YAKeyValueObservationInfoNSHTHash]; [pointerFunctions setIsEqualFunction:YAKeyValueObservationInfoNSHTIsEqual]; YAKeyValueShareableObservationInfos = [[NSHashTable alloc] initWithPointerFunctions:pointerFunctions capacity:0]; &#125; static YAKeyValueObservationInfoKey *finder; if (!finder) &#123; finder = [YAKeyValueObservationInfoKey new]; &#125; YAKeyValueObservationInfo *info = (__bridge id)[self ya_observationInfo]; finder.baseObservationInfo = info; finder.additionObserver = observer; finder.additionContext = context; finder.additionOptions = options; finder.additionProperty = property; YAKeyValueObservationInfo *observation = [YAKeyValueShareableObservationInfos member:finder]; // 重置finder数据 finder.baseObservationInfo = nil; finder.additionObserver = nil; finder.additionContext = NULL; finder.additionOptions = 0; finder.additionProperty = nil; if (!observation) &#123; // 缓存中没有找到, 创建 observation = [[YAKeyValueObservationInfo alloc] initWithObservances:@[observance] count:1]; // 添加到缓存中 [YAKeyValueShareableObservationInfos addObject:observation]; &#125; else &#123; NSMutableArray *buffer = [NSMutableArray arrayWithArray:observation.observances]; [buffer addObject:observance]; observation.observances = [NSArray arrayWithArray:buffer]; &#125; self.ya_observationInfo = (__bridge void *)(observation); if (!self.ya_isKVOClass) &#123; Class isaForAutonotifying = [property isaForAutonotifying]; // 更改isa指针 object_setClass(self, isaForAutonotifying); &#125; if (options &amp; NSKeyValueObservingOptionInitial) &#123; id newValue = nil; if (options &amp; NSKeyValueObservingOptionNew) &#123; newValue = [self valueForKeyPath:keyPath]; &#125; if (!newValue) newValue = [NSNull null]; // 使用NSNull对象 NSDictionary *change = @&#123;@"new": newValue&#125;; [observer ya_observeValueForKeyPath:keyPath ofObject:self change:change context:context]; &#125;&#125;- (void)ya_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(void *)context &#123; if (self.ya_isKVOClass) &#123; YAKeyValueProperty *property = getKeyValueProperty(self.class, keyPath); YAKeyValueObservationInfo *observation = self.ya_observationInfo; NSMutableArray *diff = [NSMutableArray arrayWithArray:observation.observances]; __block NSInteger removeIdx = -1; [diff enumerateObjectsUsingBlock:^(YAKeyValueObservance *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([obj.property isEqual:property] &amp;&amp; obj.observer == observer &amp;&amp; obj.context == context) &#123; removeIdx = idx; *stop = YES; &#125; &#125;]; if (removeIdx != -1) &#123; // 找到需要移除的元素 [diff removeObjectAtIndex:removeIdx]; observation.observances = [NSArray arrayWithArray:diff]; &#125; &#125;&#125;- (void)ya_observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;&#125;@end 功能check1.添加观察者与设置回调： [self.obj ya_addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:"NULL"]; - (void)ya_observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; NSLog(@"%@", change);&#125;self.obj.name = @"Aaron";self.obj.name = @"Jack"; 打印： 2019-05-30 09:41:23.595046+0800 Aaron[24893:604622] &#123; new = Aaron; old = "&lt;null&gt;";&#125;2019-05-30 09:41:23.595215+0800 Aaron[24893:604622] &#123; new = Jack; old = Aaron;&#125; 2.使用NSKeyValueObservingOptionInitial [self.obj ya_addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionInitial context:"NULL"];self.obj.name = @"Aaron"; 打印2019-05-30 09:45:01.717131+0800 Aaron[25010:609398] &#123; new = "&lt;null&gt;";&#125; 3.多次添加观察者 [self.obj ya_addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:"NULL"];[self.obj ya_addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:"NULL"];[self.obj ya_addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:"NULL"];self.obj.name = @"Aaron"; 打印 2019-05-30 09:47:20.625826+0800 Aaron[25107:613531] &#123; new = Aaron;&#125;2019-05-30 09:47:20.625992+0800 Aaron[25107:613531] &#123; new = Aaron;&#125;2019-05-30 09:47:20.626128+0800 Aaron[25107:613531] &#123; new = Aaron;&#125; 具体的代码放到了github上：https://github.com/ChenYalun/Project/tree/master/KVO 七、小结这里学到一个技巧：如何确认NSUserDefaults中某个key是否存在? 比如 BOOL result = [NSUserDefaults.standardUserDefaults boolForKey:@"key"]; 当result为NO时，怎么判断是存储键@&quot;key&quot;对应的value是NO，还是说压根就没有存过这个key呢?可以使用CFPreferencesGetAppBooleanValue()函数。KVO中有这么一段代码: BOOL keyExistsAndHasValidFormat = false; // key是否存在BOOL cleansUpBeforeThrowing = false; // 存储的值为YES或者NOcleansUpBeforeThrowing = (BOOL)CFPreferencesGetAppBooleanValue(CFSTR("key"), kCFPreferencesCurrentApplication, (Boolean *)&amp;keyExistsAndHasValidFormat);// 能判断出key存在cleansUpBeforeThrowing = cleansUpBeforeThrowing &amp;&amp; keyExistsAndHasValidFormat; 好了，说正题，本文简单总结了KVO的原理，并尝试阅读源码，然而能力有限、时间有限，只能明白个大概。在应用场景方面，就是“观察”，实际开发中，监听UIScrollView（及其子类）的属性比较多。最后，给自己挖了个坑：willChangeValueForKey:和didChangeValueForKey:为什么要成对出现？哪天有时间了，再仔细看一看。 KVO的源码来自：https://github.com/renjinkui2719/DIS_KVC_KVO 。感谢作者。 参考文章Foundation: NSKeyValueObserving(KVO)如何自己动手实现 KVO使用Block实现KVOobjc kvo简单探索KVO 原理详解]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解Key-Value Coding源码]]></title>
    <url>%2F2019%2F05%2F05%2F%E8%AF%A6%E8%A7%A3Key-Value%20Coding%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[KVC源码阅读。 一、接口@interface NSObject(NSKeyValueCoding)// 是否可以直接访问实例变量(实例变量访问开关, 默认YES)@property (class, readonly) BOOL accessInstanceVariablesDirectly;// 通过key访问- (nullable id)valueForKey:(NSString *)key;- (void)setValue:(nullable id)value forKey:(NSString *)key;// 尝试验证将要设定的value(ioValue指针指向的对象)是否合理有效- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;// 获取相对应的精确容器类型- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;- (NSMutableOrderedSet *)mutableOrderedSetValueForKey:(NSString *)key;- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;// 通过keyPath访问- (nullable id)valueForKeyPath:(NSString *)keyPath;- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;- (NSMutableArray *)mutableArrayValueForKeyPath:(NSString *)keyPath;- (NSMutableOrderedSet *)mutableOrderedSetValueForKeyPath:(NSString *)keyPath;- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath;// 查找key失败默认抛出异常, 可重写自行实现- (nullable id)valueForUndefinedKey:(NSString *)key;// 设置value失败默认抛出异常, 可重写自行实现- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;// 设置value为nil时抛出异常, 可重写自行实现- (void)setNilValueForKey:(NSString *)key;// 传入key数组, 返回一个成员变量名和变量值的键值对组成的字典(可用于模型转字典)- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;// 字典转模型- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;@end/// 容器扩展@interface NSArray&lt;ObjectType&gt;(NSKeyValueCoding)- (id)valueForKey:(NSString *)key;- (void)setValue:(nullable id)value forKey:(NSString *)key;@end@interface NSDictionary&lt;KeyType, ObjectType&gt;(NSKeyValueCoding)- (nullable ObjectType)valueForKey:(NSString *)key;@end@interface NSMutableDictionary&lt;KeyType, ObjectType&gt;(NSKeyValueCoding)- (void)setValue:(nullable ObjectType)value forKey:(NSString *)key;@end@interface NSSet&lt;ObjectType&gt;(NSKeyValueCoding)- (id)valueForKey:(NSString *)key;- (void)setValue:(nullable id)value forKey:(NSString *)key;@end@interface NSOrderedSet&lt;ObjectType&gt;(NSKeyValueCoding)- (id)valueForKey:(NSString *)key;- (void)setValue:(nullable id)value forKey:(NSString *)key;@end 集合代理对象这里简单总结集合代理对象的使用。 当我们在对象上调用 -valueForKey: 的时候，它可以返回 NSArray，NSSet 或是 NSOrderedSet 的集合代理对象。这个类没有实现通常的 -&lt;Key&gt; 方法，但是它实现了代理对象所需要使用的很多方法。 NSArray@interface Primes : NSObject@property (nonatomic, copy, readonly) NSArray *primes;@end@implementation Primes@dynamic primes; // 不要生成get方法static int32_t const primes[] = &#123; 2, 101, 233, 383, 3, 103, 239, 389, 5, 107, 241, 397, 7, 109, 251, 401, 11, 113, 257, 409, 13, 127, 263, 419, 17, 131, 269, 421, 19, 137, 271, 431, 23, 139, 277, 433, 29, 149, 281, 439, 31, 151, 283, 443, 37, 157, 293, 449, 41, 163, 307, 457, 43, 167, 311, 461, 47, 173, 313, 463, 53, 179, 317, 467, 59, 181, 331, 479, 61, 191, 337, 487, 67, 193, 347, 491, 71, 197, 349, 499, 73, 199, 353, 503, 79, 211, 359, 509, 83, 223, 367, 521, 89, 227, 373, 523, 97, 229, 379, 541, 547, 701, 877, 1049, 557, 709, 881, 1051, 563, 719, 883, 1061, 569, 727, 887, 1063, 571, 733, 907, 1069, 577, 739, 911, 1087, 587, 743, 919, 1091, 593, 751, 929, 1093, 599, 757, 937, 1097, 601, 761, 941, 1103, 607, 769, 947, 1109, 613, 773, 953, 1117, 617, 787, 967, 1123, 619, 797, 971, 1129, 631, 809, 977, 1151, 641, 811, 983, 1153, 643, 821, 991, 1163, 647, 823, 997, 1171, 653, 827, 1009, 1181, 659, 829, 1013, 1187, 661, 839, 1019, 1193, 673, 853, 1021, 1201, 677, 857, 1031, 1213, 683, 859, 1033, 1217, 691, 863, 1039, 1223, 1229,&#125;;- (NSUInteger)countOfPrimes &#123; return (sizeof(primes) / sizeof(*primes));&#125;- (id)objectInPrimesAtIndex:(NSUInteger)idx &#123; NSParameterAssert(idx &lt; sizeof(primes) / sizeof(*primes)); return @(primes[idx]);&#125;@end 对于NSArray， 实现-countOf&lt;Key&gt;方法，-objectIn&lt;Key&gt;AtIndex:或者-&lt;key&gt;AtIndexes:中的一个即可，当然如果再实现-get&lt;Key&gt;:range:将会增强性能。 上面的例子中，key是“primes”，实际上并没有这个primes数组，而是用了一个C数组代理了。@property (nonatomic, copy, readonly) NSArray *primes;和@dynamic primes; 这两句话可以省略（下文的例子就省略了），这里加上的原因是，便于外界知晓具体的key值。 使用： Primes *primes = [Primes new];// obj is kind of class 'NSKeyValueArray'id obj = [primes valueForKey:@"primes"]; 可见，获得的对象并不是一个NSArray，而是NSKeyValueArray。 NSSet@interface PrimesSet : NSObject@end@implementation PrimesSetstatic NSSet *_numSet;- (instancetype)init &#123; if (self = [super init]) &#123; _numSet = [NSSet setWithObjects:@0, @1, @2, @3, nil]; &#125; return self;&#125;- (NSUInteger)countOfPrimes &#123; return _numSet.count;&#125;- (NSEnumerator *)enumeratorOfPrimes &#123; return _numSet.objectEnumerator;&#125;- (id)memberOfPrimes:(id)obj &#123; return [_numSet member:obj];&#125;@end 对于NSSet，要实现-countOf&lt;Key&gt;、-enumeratorOf&lt;Key&gt;和-memberOf&lt;Key&gt;:这三个方法。 使用： PrimesSet *primesSet = [PrimesSet new];// obj is kind of class 'NSKeyValueSet'id obj = [primesSet valueForKey:@"primes"]; 获取到的对象是NSKeyValueSet。 NSOrderedSet@interface PrimesOrderedSet : NSObject@end@implementation PrimesOrderedSetstatic NSOrderedSet *_numOrderedSet;- (instancetype)init &#123; if (self = [super init]) &#123; _numOrderedSet = [NSOrderedSet orderedSetWithObjects:@0, @1, @2, @3, nil]; &#125; return self;&#125;- (NSUInteger)countOfPrimes &#123; return _numOrderedSet.count;&#125;- (NSUInteger)indexInPrimesOfObject:(id)obj &#123; return [_numOrderedSet indexOfObject:obj];&#125;- (id)objectInPrimesAtIndex:(NSUInteger)idx &#123; return [_numOrderedSet objectAtIndex:idx];&#125;// 用于提高性能- (void)getPrimes:(id __unsafe_unretained *)buffer range:(NSRange)inRange &#123; // 返回提供的缓冲区内指定范围内的数据集合 [_numOrderedSet getObjects:buffer range:inRange];&#125;@end 必须实现的方法是-countOf&lt;Key&gt;和-indexIn&lt;Key&gt;OfObject:。二选一实现的方法是-objectIn&lt;Key&gt;AtIndex:和-&lt;key&gt;AtIndexes:。如果再实现-get&lt;Key&gt;:range:将会增强性能。 使用： PrimesOrderedSet *primesOrderedSet = [PrimesOrderedSet new];// obj is kind of class 'NSKeyValueOrderedSet'id obj = [primesOrderedSet valueForKey:@"primes"]; 获取到的对象是NSKeyValueOrderedSet。 集合操作数组最大值： NSArray *array = @[@1, @8, @5];[array valueForKeyPath:@"@max.self"]; 模型数组最大值： NSArray *array = @[person1, person2, person3];[array valueForKeyPath:@"@max.age"]; 其他操作符： @max @min: 获得数组中最大(或者最小)的一个元素@avg: 将集合中对象转换成double类型，返回数组中指定的平均值的number对象@sum: 将集合中每个对象都转换成double类型，然后计算总和，最后返回一个值为这个总和的NSNumber对象@count：返回集合中对象总数的NSNumber对象返回一个由操作符右边的key path指定的对象属性组成的数组，distincUnionOfObjects会对数组去重。示例：[personList valueForKeyPath:@"@unionOfObjects.name"];[personList valueForKeyPath:@"@distinctUnionOfObjects.name"];操作对象：@unionOfObjects/@distincUnionOfObjects 操作数组：@distinctUnionOfArrays/@unionOfArrays操作集合：@distinctUnionOfSets 和@distinctUnionOfArrays 分类的KVC一般的场景是这样： // 主类@interface Portion : NSObject@end@implementation Portion@end// 分类@interface Portion (PrimitiveAccessors)- (NSNumber *)primitiveVolume;- (void)setPrimitiveVolume:(NSNumber *)value;@end@implementation Portion (PrimitiveAccessors)static NSNumber *gVolume;- (NSNumber *)primitiveVolume &#123; return gVolume;&#125;- (void)setPrimitiveVolume:(NSNumber *)value &#123; gVolume = value;&#125;@end 对于主类中没有的key，分类实现特定的方法后，KVC也将会生效。如果是取值，分类必须实现这样的方法：getPrimitive&lt;key&gt;或者primitive&lt;key&gt;。上面的例子中，key是volume。如果是设值，分类必须实现setPrimitive&lt;key&gt;:方法。 使用： Portion *p = [Portion new];[p setValue:@234 forKey:@"volume"];id m = [p valueForKey:@"volume"]; 当然，本质上来讲，KVC并不介意这些方法在主类还是分类实现的，只要有实现就成。上面的只是一个例子，实际上，完全依靠主类也是无妨的。 @interface Portion : NSObject- (NSNumber *)primitiveVolume;- (void)setPrimitiveVolume:(NSNumber *)value;@end@implementation Portionstatic NSNumber *gVolume;- (NSNumber *)primitiveVolume &#123; return gVolume;&#125;- (void)setPrimitiveVolume:(NSNumber *)value &#123; gVolume = value;&#125;@end 二、取值valueForKey:苹果在接口这里已经给出了其基本原理： The default implementation of this method does the following: Searches the class of the receiver for an accessor method whose name matches the pattern -get&lt;Key&gt;, -&lt;key&gt;, or -is&lt;Key&gt;, in that order. If such a method is found it is invoked. If the type of the method’s result is an object pointer type the result is simply returned. If the type of the result is one of the scalar types supported by NSNumber conversion is done and an NSNumber is returned. Otherwise, conversion is done and an NSValue is returned (new in Mac OS 10.5: results of arbitrary type are converted to NSValues, not just NSPoint, NRange, NSRect, and NSSize). (introduced in Mac OS 10.7). Otherwise (no simple accessor method is found), searches the class of the receiver for methods whose names match the patterns -countOf&lt;Key&gt; and -indexIn&lt;Key&gt;OfObject: and -objectIn&lt;Key&gt;AtIndex:(corresponding to the primitive methods defined by the NSOrderedSet class) and also -&lt;key&gt;AtIndexes: (corresponding to -[NSOrderedSet objectsAtIndexes:]). If a count method and an indexOf method and at least one of the other two possible methods are found, a collection proxy object that responds to all NSOrderedSet methods is returned. Each NSOrderedSet message sent to the collection proxy object will result in some combination of-countOf&lt;Key&gt;, -indexIn&lt;Key&gt;OfObject:, -objectIn&lt;Key&gt;AtIndex:, and -&lt;key&gt;AtIndexes: messages being sent to the original receiver of -valueForKey:. If the class of the receiver also implements an optional method whose name matches the pattern -get:range: that method will be used when appropriate for best performance. Otherwise (no simple accessor method or set of ordered set access methods is found), searches the class of the receiver for methods whose names match the patterns -countOf&lt;Key&gt; and -objectIn&lt;Key&gt;AtIndex:(corresponding to the primitive methods defined by the NSArray class) and (introduced in Mac OS 10.4) also-&lt;key&gt;AtIndexes:(corresponding to -[NSArray objectsAtIndexes:]). If a count method and at least one of the other two possible methods are found, a collection proxy object that responds to all NSArray methods is returned. Each NSArray message sent to the collection proxy object will result in some combination of -countOf&lt;Key&gt;, -objectIn&lt;Key&gt;AtIndex:, and -&lt;key&gt;AtIndexes: messages being sent to the original receiver of -valueForKey:. If the class of the receiver also implements an optional method whose name matches the pattern -get&lt;Key&gt;:range: that method will be used when appropriate for best performance. (introduced in Mac OS 10.4). Otherwise (no simple accessor method or set of ordered set or array access methods is found), searches the class of the receiver for a threesome of methods whose names match the patterns -countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, and -memberOf&lt;Key&gt;: (corresponding to the primitive methods defined by the NSSet class). If all three such methods are found a collection proxy object that responds to all NSSet methods is returned. Each NSSet message sent to the collection proxy object will result in some combination of -countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, and -memberOf&lt;Key&gt;:messages being sent to the original receiver of -valueForKey:. Otherwise (no simple accessor method or set of collection access methods is found), if the receiver’s class’ +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern _&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;, in that order. If such an instance variable is found, the value of the instance variable in the receiver is returned, with the same sort of conversion to NSNumber or NSValue as in step 1. Otherwise (no simple accessor method, set of collection access methods, or instance variable is found), invokes -valueForUndefinedKey: and returns the result. The default implementation of -valueForUndefinedKey: raises an NSUndefinedKeyException, but you can override it in your application. Compatibility notes: For backward binary compatibility, an accessor method whose name matches the pattern -_get&lt;Key&gt;, or -_&lt;key&gt; is searched for between steps 1 and 3. If such a method is found it is invoked, with the same sort of conversion to NSNumber or NSValue as in step 1. KVC accessor methods whose names start with underscores were deprecated as of Mac OS 10.3 though. The behavior described in step 5 is a change from Mac OS 10.2, in which the instance variable search order was &lt;key&gt;, _&lt;key&gt;. For backward binary compatibility, -handleQueryWithUnboundKey: will be invoked instead of -valueForUndefinedKey: in step 6, if the implementation of -handleQueryWithUnboundKey: in the receiver’s class is not NSObject’s. 简单翻译如下： 按照-get&lt;Key&gt;, -&lt;key&gt;, -is&lt;Key&gt;的顺序搜索该类的存取器方法，若找到，则直接调用。如果方法调用的结果是id类型，直接把结果返回。如果方法调用的结果是能够被NSNumber转换的标量类型，则结果会被转为NSNumber返回。否则对于一般的标量类型，这些类型将会被转化为NSValue（在Mac OS 10.5及以后，不仅仅支持NSPoint, NRange, NSRect，以及NSSize这些类型）。 如果简单的存取器方法没有找到，那么搜索该类的-countOf&lt;Key&gt;, -indexIn&lt;Key&gt;OfObject:方法，还有-objectIn&lt;Key&gt;AtIndex:（对应被NSOrderedSet类所定义的方法），-&lt;key&gt;AtIndexes:（对应-[NSOrderedSet objectsAtIndexes:]）方法。如果-countOf&lt;Key&gt;, -indexIn&lt;Key&gt;OfObject:这两个方法被找到，另外两个方法中的至少一个被找到，那么这个能响应NSOrderedSet所有方法的集合代理对象会被返回。发送给原来消息接收者的-valueForKey:消息，将会被这个集合代理对象的-countOf&lt;Key&gt;, -indexIn&lt;Key&gt;OfObject:, -objectIn&lt;Key&gt;AtIndex:, -&lt;key&gt;AtIndexes:这些方法共同处理。如果这个代理对象也实现了可选的-get&lt;Key&gt;:range:方法，这将有助于增强性能。 如果存取器方法和ordered set的代理方法没有被找到，那么搜索该类的-countOf&lt;Key&gt;方法，还有-objectIn&lt;Key&gt;AtIndex:（对应被NSArray类所定义的方法），-&lt;key&gt;AtIndexes:（对应-[NSArray objectsAtIndexes:]）方法。如果-countOf&lt;Key&gt;这个方法被找到，另外两个方法中的至少一个被找到，那么这个能响应NSArray所有方法的集合代理对象会被返回。发送给原来消息接收者的-valueForKey:消息，将会被这个集合代理对象的-countOf&lt;Key&gt;, -objectIn&lt;Key&gt;AtIndex:, -&lt;key&gt;AtIndexes:这些方法共同处理。如果这个代理对象也实现了可选的-get&lt;Key&gt;:range:方法，这将有助于增强性能。 如果存取器方法、ordered set和array的代理方法都没有被找到，那么尝试搜索-countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, -memberOf&lt;Key&gt;:这些(被NSSet类所定义的)方法。如果这三个方法都能被找到，那么这个能响应NSSet所有方法的集合代理对象会被返回。发送给原来消息接收者的-valueForKey:消息，将会被这个集合代理对象的countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, -memberOf&lt;Key&gt;:这些方法共同处理。 如果存取器方法、ordered set、array以及set的代理方法都没有被找到，倘若此时消息接收者的+accessInstanceVariablesDirectly属性返回的是YES（默认实现就是返回YES），那么按照_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;的顺序搜索该类的实例变量。如果找到这个实例变量，那么按照步骤1中的类型转换规则返回这个实例变量的值。 否则(啥也没找到)，调用-valueForUndefinedKey:方法并返回结果。这个方法的默认实现是抛出NSUndefinedKeyException异常，不过你可以重写该方法自行实现。 兼容性： 为了向后兼容，会在步骤1中查找名称为-_get&lt;Key&gt;, -_&lt;key&gt;的存取器方法。如果找到了，会进行调用并按照步骤1中的类型转换规则返回调用的结果。 从Mac OS 10.2开始，步骤5中的实例变量搜索顺序从原先的&lt;key&gt;, _&lt;key&gt;改为现在的_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;。 如果-handleQueryWithUnboundKey:的实现不是NSObject的默认实现（换句话说，自己手动实现了-handleQueryWithUnboundKey:方法），那在步骤6中，-handleQueryWithUnboundKey:方法将会代替-valueForUndefinedKey:方法被调用。 说得清晰明了。流程图如下： 方法一- (id)valueForKey:(NSString *)key &#123; if(key) &#123; OSSpinLockLock(&amp;NSKeyValueCachedAccessorSpinLock); // 创建缓存getter的CFSet集合NSKeyValueCachedGetters if(!NSKeyValueCachedGetters) &#123; // CFSet对象需要的结构体参数, 告诉这个集合怎么管理容器中的对象 // retain\release是内存管理 equal\hash是对象处理 copyDescription是复制处理 CFSetCallBacks callbacks = &#123;0&#125;; callbacks.version = kCFTypeSetCallBacks.version; // 也可以禁用掉retain和release, 这样当对象销毁时需要及时将其从集合中移除否则会崩溃 // callbacks.retain = NULL; // callbacks.release = NULL; callbacks.retain = kCFTypeSetCallBacks.retain; callbacks.release = kCFTypeSetCallBacks.release; callbacks.copyDescription = kCFTypeSetCallBacks.copyDescription; callbacks.equal = (CFSetEqualCallBack)NSKeyValueAccessorIsEqual; callbacks.hash = (CFSetHashCallBack)NSKeyValueAccessorHash; NSKeyValueCachedGetters = CFSetCreateMutable(NULL,0,&amp;callbacks); &#125; // 根据class、key和hash创建唯一的NSKeyValueGetter对象, 作为从缓存集合中查找的"引子" // 只要hashValue一致, 不管其他属性是否一致, 就可以判定这两个对象是一致的 // 这也是为啥首先根据class和key, 创建一个"简单"的finder到缓存集合中查找的原因 NSKeyValueGetter *finder = [NSKeyValueGetter new]; finder.containerClassID = object_getClass(self); finder.key = key; finder.hashValue = CFHash(key) ^ (NSUInteger)(object_getClass(self)); // 缓存集合中是否含有特定的NSKeyValueGetter NSKeyValueGetter *getter = CFSetGetValue(NSKeyValueCachedGetters, finder); if (!getter) &#123; // 缓存中没有找到, 创建getter getter = [object_getClass(self) _createValueGetterWithContainerClassID:object_getClass(self) key:key]; // 这里的getter相比上面的finder更加具体详细, 虽然根据哈希来说, 二者是"相同的对象" // 创建好getter后, 把它放到缓存集合中 CFSetAddValue(NSKeyValueCachedGetters, getter); &#125; OSSpinLockUnlock(&amp;NSKeyValueCachedAccessorSpinLock); // 找到getter, 交给_NSGetUsingKeyValueGetter函数处理 return _NSGetUsingKeyValueGetter(self, getter); &#125; else &#123; // key为空, 抛出异常 [NSException raise:NSInvalidArgumentException format:@"%@: attempt to retrieve a value for a nil key",_NSMethodExceptionProem(self,_cmd)]; &#125; return nil;&#125; 这个方法主要做了四件事: 取值时，使用OSSpinLockLock保证线程安全 根据class和key，生成一个NSKeyValueGetter对象，用于封装信息 取值时，会根据class和key配置一个简单的Getter，首先到CFSet缓存集合中进行查找，以提高查找速度 当key不存在时，直接抛出异常: 参数有误 方法二当缓存集合中不存在时，便进入了更为具体的“查找”流程中。 // 详细的查找流程(此处假定key为"name")+ (NSKeyValueGetter *)_createValueGetterWithContainerClassID:(id)containerClassID key:(NSString *)key &#123; NSKeyValueGetter * getter = nil; // 获取字节长度 NSUInteger keyLen = [key lengthOfBytesUsingEncoding:NSUTF8StringEncoding]; // 这个数组用于存放首字符大写的key, 例如: "Name" char keyCStrUpFirst[keyLen + 1]; // 将key转为C字符串, 存储在keyCStrUpFirst数组中 [key getCString:keyCStrUpFirst maxLength:keyLen + 1 encoding:NSUTF8StringEncoding]; if (key.length) &#123; // 将小写字母转为大写字母 keyCStrUpFirst[0] = toupper(keyCStrUpFirst[0]); &#125; // 这个数组用于存放与key一致的字符, 例如: "name" char keyCStr[keyLen + 16]; // 再将key转为C字符串, 存储在keyCStr数组中 [key getCString:keyCStr maxLength:keyLen + 1 encoding:NSUTF8StringEncoding]; Method getMethod = NULL; // 查询方法指针, 使用'逻辑或'固定了默认顺序:getName==&gt;name==&gt;isName==&gt;_getName==&gt;_name // 此处证明了接口文档中的第一步 // 1. Whose name matches the pattern -get&lt;Key&gt;, -&lt;key&gt;, or -is&lt;Key&gt;, in that order. // 2. For backward binary compatibility, an accessor method whose name matches the pattern -_get&lt;Key&gt;, or -_&lt;key&gt; is searched for between steps 1 and 3. if((getMethod = NSKeyValueMethodForPattern(self,"get%s",keyCStrUpFirst)) || (getMethod = NSKeyValueMethodForPattern(self,"%s",keyCStr)) || (getMethod = NSKeyValueMethodForPattern(self,"is%s",keyCStrUpFirst)) || (getMethod = NSKeyValueMethodForPattern(self,"_get%s",keyCStrUpFirst)) || (getMethod = NSKeyValueMethodForPattern(self,"_%s",keyCStr))) &#123; // 成功找到, 创建NSKeyValueMethodGetter对象, 保存找到的method getter = [[NSKeyValueMethodGetter alloc] initWithContainerClassID:containerClassID key:key method:getMethod]; &#125; else &#123; /* 没有找到, 进入下个流程, 假定key为"name", 则: ountOf_Method 对应 countOfName ObjectIn_AtIndexMethod 对应 objectInNameAtIndex: _AtIndexesMethod 对应 nameAtIndexes: IndexIn_OfObjectMethod 对应 indexInNameOfObject: enumeratorOf_Method 对应 enumeratorOfName memberOf_Method 对应 memberOfName: */ Method ountOf_Method = NSKeyValueMethodForPattern(self, "countOf%", keyCStrUpFirst); Method ObjectIn_AtIndexMethod = NSKeyValueMethodForPattern(self, "objectIn%sAtIndex:", keyCStrUpFirst); Method _AtIndexesMethod = NSKeyValueMethodForPattern(self, "%sAtIndexes:", keyCStr); Method IndexIn_OfObjectMethod = NSKeyValueMethodForPattern(self, "indexIn%sOfObject:", keyCStrUpFirst); Method enumeratorOf_Method = NSKeyValueMethodForPattern(self, "enumeratorOf%s", keyCStrUpFirst); Method memberOf_Method = NSKeyValueMethodForPattern(self, "memberOf%s:", keyCStrUpFirst); if(ountOf_Method &amp;&amp; IndexIn_OfObjectMethod &amp;&amp; (ObjectIn_AtIndexMethod || _AtIndexesMethod)) &#123; // 第二步, 针对NSOrderedSet, ountOf_Method、IndexIn_OfObjectMethod，以及ObjectIn_AtIndexMethod或者_AtIndexesMethod中的一个存在(实现代理集合对象) NSKeyValueNonmutatingOrderedSetMethodSet *methodSet = [[NSKeyValueNonmutatingOrderedSetMethodSet alloc] init]; methodSet.count = ountOf_Method; methodSet.objectAtIndex = ObjectIn_AtIndexMethod; methodSet.indexOfObject = IndexIn_OfObjectMethod; methodSet.objectsAtIndexes = _AtIndexesMethod; // eg: getName:range:方法(用于增强性能) methodSet.getObjectsRange = NSKeyValueMethodForPattern(self, "get%s:range:", keyCStrUpFirst); // NSKeyValueNonmutatingOrderedSetMethodSet就是一个拥有几个属性的简单的对象, 用于保存count、objectAtIndex等方法指针信息 // 成功找到, 创建NSKeyValueCollectionGetter对象, 保存保存好的methodSet对象 getter = [[NSKeyValueCollectionGetter alloc] initWithContainerClassID:containerClassID key:key methods:methodSet proxyClass:NSKeyValueOrderedSet.self]; [methodSet release]; &#125; else if(ountOf_Method &amp;&amp; (ObjectIn_AtIndexMethod || _AtIndexesMethod))&#123; // 第三步, 针对NSArray, ountOf_Method、以及ObjectIn_AtIndexMethod或者_AtIndexesMethod中的一个存在 NSKeyValueNonmutatingArrayMethodSet *methodSet = [[NSKeyValueNonmutatingArrayMethodSet alloc] init]; methodSet.count = ountOf_Method; methodSet.objectAtIndex = ObjectIn_AtIndexMethod; methodSet.objectsAtIndexes = _AtIndexesMethod; methodSet.getObjectsRange = NSKeyValueMethodForPattern(self, "get%s:range:", keyCStrUpFirst); // 同样的, 成功找到, 创建NSKeyValueCollectionGetter对象,保存methodSet getter = [[NSKeyValueCollectionGetter alloc] initWithContainerClassID:containerClassID key:key methods:methodSet proxyClass:NSKeyValueArray.self]; [methodSet release]; &#125; else if(ountOf_Method &amp;&amp; enumeratorOf_Method &amp;&amp; memberOf_Method)&#123; // 第四步, 针对NSSet, ountOf_Method、enumeratorOf_Method以及memberOf_Method NSKeyValueNonmutatingSetMethodSet *methodSet = [[NSKeyValueNonmutatingSetMethodSet alloc] init]; methodSet.count = ountOf_Method; methodSet.enumerator = enumeratorOf_Method; methodSet.member = memberOf_Method; getter = [[NSKeyValueCollectionGetter alloc] initWithContainerClassID:containerClassID key:key methods:methodSet proxyClass:NSKeyValueSet.self]; [methodSet release]; &#125; else if([self accessInstanceVariablesDirectly]) &#123; // 第五步, 如果允许直接访问实例变量, 也即accessInstanceVariablesDirectly为YES, 则直接取出实例变量 // 默认顺序为_name==&gt;_isName==&gt;name==&gt;isName Ivar ivar = NULL; if((ivar = NSKeyValueIvarForPattern(self, "_%s", keyCStr)) || (ivar = NSKeyValueIvarForPattern(self, "_is%s", keyCStrUpFirst)) || (ivar = NSKeyValueIvarForPattern(self, "%s", keyCStr)) || (ivar = NSKeyValueIvarForPattern(self, "is%s", keyCStrUpFirst)) ) &#123; // 此时ivar有值, 创建NSKeyValueIvarGetter getter = [[NSKeyValueIvarGetter alloc] initWithContainerClassID:containerClassID key:key containerIsa:self ivar:ivar]; &#125; &#125; &#125; if(!getter) &#123; // 最后, getter创建失败, 说明方法、实例变量查询失败, 进入下个流程 getter = [self _createValuePrimitiveGetterWithContainerClassID:containerClassID key:key]; &#125; return getter;&#125; 这个方法详细地设定了查找的顺序，值得关注的是，NSKeyValueMethodForPattern()这个函数调用的次数相当的多。 方法三//最后一次查找+ (NSKeyValueGetter *)_createValuePrimitiveGetterWithContainerClassID:(id)containerClassID key:(NSString *)key &#123; NSKeyValueGetter *getter = nil; NSUInteger keyCstrLen = [key lengthOfBytesUsingEncoding:NSUTF8StringEncoding]; char keyCstrUpFirst[keyCstrLen + 1]; [key getCString:keyCstrUpFirst maxLength:keyCstrLen + 1 encoding:NSUTF8StringEncoding]; if(key.length) &#123; keyCstrUpFirst[0] = toupper(keyCstrUpFirst[0]); &#125; char keyCstr[keyCstrLen + 1]; [key getCString:keyCstr maxLength:keyCstrLen + 1 encoding:NSUTF8StringEncoding]; Method getMethod = NULL; // 同样的套路, 查找顺序: getPrimitiveName==&gt;primitiveName if((getMethod = NSKeyValueMethodForPattern(self, "getPrimitive%s", keyCstrUpFirst)) || (getMethod = NSKeyValueMethodForPattern(self, "primitive%s", keyCstrUpFirst)) ) &#123; getter = [[NSKeyValueMethodGetter alloc] initWithContainerClassID:containerClassID key:key method:getMethod]; &#125; else if([self accessInstanceVariablesDirectly]) &#123; Ivar ivar = NULL; // 直接访问实例变量 // 在方法二中找过一遍了, 为啥还要再找一遍? // 说明要么是根本没有找到, 要么是虽然找到了, 但是在创建NSKeyValueIvarGetter或者NSKeyValueMethodGetter的时候失败了, 最终的getter还是nil if ((ivar = NSKeyValueIvarForPattern(self, "_%s", keyCstr)) || (ivar = NSKeyValueIvarForPattern(self, "_is%s", keyCstrUpFirst)) || (ivar = NSKeyValueIvarForPattern(self, "%s", keyCstr)) || (ivar = NSKeyValueIvarForPattern(self, "is%s", keyCstrUpFirst)) ) &#123; getter = [[NSKeyValueIvarGetter alloc] initWithContainerClassID:containerClassID key:key containerIsa:self ivar:ivar]; &#125; &#125; if(!getter) &#123; getter = [self _createOtherValueGetterWithContainerClassID:containerClassID key:key]; &#125; return getter;&#125; 方法四// 转发处理给NSKeyValueUndefinedGetter对象+ (id)_createOtherValueGetterWithContainerClassID:(id)containerClassID key:(NSString *)key &#123; return [[NSKeyValueUndefinedGetter alloc] initWithContainerClassID:containerClassID key:key containerIsa:self];&#125; 方法五// NSKeyValueUndefinedGetter负责调用其父类(NSKeyValueGetter)的构造方法@implementation NSKeyValueUndefinedGetter- (id)initWithContainerClassID:(id)containerClassID key:(NSString *)key containerIsa:(Class)containerIsa &#123; void *arguments[3] = &#123;0&#125;; arguments[0] = key; // 调用valueForUndefinedKey方法, 该方法默认实现抛出异常 return [super initWithContainerClassID:containerClassID key:key implementation:methogetImplementation(class_getInstanceMethod(containerIsa,@selector(valueForUndefinedKey:))) selector:@selector(valueForUndefinedKey:) extraArguments:arguments count:1];&#125;@end 方法怎么查找// NSKeyValueMethodForPatternMethod NSKeyValueMethodForPattern(Class class, const char *pattern,const char *param) &#123; size_t paramLen = strlen(param); size_t patternLen = strlen(pattern); char selName[patternLen + paramLen * 2 + 1]; snprintf(selName, (patternLen + paramLen * 2 + 1), pattern,param,param); // 依赖Runtime的class_getInstanceMethod return class_getInstanceMethod(class, sel_registerName(selName));&#125; 实例变量怎么查找// NSKeyValueIvarForPatternIvar NSKeyValueIvarForPattern(Class class, const char *pattern,const char *param) &#123; size_t paramLen = strlen(param); size_t patternLen = strlen(pattern); char ivarName[paramLen + patternLen + 1]; snprintf(ivarName, paramLen + patternLen + 1, pattern,param); // 依赖Runtime的class_getInstanceVariable return class_getInstanceVariable(class, ivarName);&#125; NSKeyValueMethodGetter如何创建1. NSKeyValueMethodGetter构造方法中生成IMP@implementation NSKeyValueMethodGetter- (id)initWithContainerClassID:(id)containerClassID key:(NSString *)key method:(Method)method &#123; NSUInteger methodArgumentsCount = methogetNumberOfArguments(method); NSUInteger extraAtgumentCount = 1; // 默认两个参数((void (*)(id, SEL))objc_msgSend) if(methodArgumentsCount == 2) &#123; char *returnType = methocopyReturnType(method); IMP imp = NULL; switch (returnType[0]) &#123; case '#': case '@': &#123; // 返回类型是对象时, 直接获取method的函数指针 // 还是以key为"name"举例, 则方法为- (NSString *)name; 这里直接获取其IMP imp = methogetImplementation(method); extraAtgumentCount = 0; &#125; break; case 'B': &#123; /* // 获取将BOOL类型转为NSNumber对象类型的函数指针 NSNumber * _NSGetBoolValueWithMethod(id object, SEL selctor, Method method) &#123; return [[[NSNumber alloc] initWithBool: ((BOOL (*)(id,SEL))methogetImplementation(method))(object, methogetName(method))] autorelease]; &#125; // 比如key为"isMan", 则方法为 - (BOOL)iaMan; // 获取的IMP便是将普通BOOL类型值转化为NSNumber类型对象的函数指针, 其他类似 */ imp = (IMP)_NSGetBoolValueWithMethod; &#125; break; case 'C': &#123;imp = (IMP)_NSGetUnsignedCharValueWithMethod;&#125; break; case 'I': &#123;imp = (IMP)_NSGetUnsignedIntValueWithMethod;&#125; break; case 'Q': &#123;imp = (IMP)_NSGetUnsignedLongLongValueWithMethod;&#125; break; case 'L': &#123;imp = (IMP)_NSGetUnsignedLongValueWithMethod;&#125; break; case 'S': &#123;imp = (IMP)_NSGetUnsignedShortValueWithMethod;&#125; break; case 'c': &#123;imp = (IMP)_NSGetCharValueWithMethod;&#125; break; case 'd': &#123;imp = (IMP)_NSGetDoubleValueWithMethod;&#125; break; case 'f': &#123;imp = (IMP)_NSGetFloatValueWithMethod;&#125; break; case 'i': &#123;imp = (IMP)_NSGetIntValueWithMethod;&#125; break; case 'l': &#123;imp = (IMP)_NSGetLongValueWithMethod;&#125; break; case 'q': &#123;imp = (IMP)_NSGetLongLongValueWithMethod;&#125; break; case 's': &#123;imp = (IMP)_NSGetShortValueWithMethod;&#125; break; case '&#123;': &#123; if (strcmp(returnType, @encode(CGPoint)) == 0)&#123; imp = (IMP)_NSGetPointValueWithMethod; &#125; else if (strcmp(returnType, @encode(NSRange)) == 0)&#123; imp = (IMP)_NSGetRangeValueWithMethod; &#125; else if (strcmp(returnType, @encode(CGRect)) == 0)&#123; imp = (IMP)_NSGetRectValueWithMethod; &#125; else if (strcmp(returnType, @encode(CGSize)) == 0)&#123; imp = (IMP)_NSGetSizeValueWithMethod; &#125; else &#123; imp = (IMP)_NSGetValueWithMethod; &#125; &#125; break; &#125; free(returnType); if(imp) &#123; void *arguments[3] = &#123;0&#125;; if(extraAtgumentCount &gt; 0) &#123; arguments[0] = method; &#125; // 将class key selector imp method 参数 参数数量等信息交给父类处理 return [super initWithContainerClassID:containerClassID key:key implementation:imp selector:methogetName(method) extraArguments:arguments count:extraAtgumentCount]; &#125; else &#123; [self release]; return nil; &#125; &#125; else &#123; [self release]; return nil; &#125;&#125;@end 由于KVC返回的类型为对象(NSObject)，所以需要对方法返回值类型分别进行判断从而为Getter赋值不同的函数指针。也即从BOOL、double、int、CGSize等普通类型转化为NSNumber、NSValue、id等对象类型的函数(指针)。 2. 在父类NSKeyValueAccessor中, 对class key selector imp method 参数 参数数量等信息进行保存@implementation NSKeyValueAccessor- (id)initWithContainerClassID:(id)containerClassID key:(NSString *)key implementation:(IMP)implementation selector:(SEL)selector extraArguments:(void *[3])extraArguments count:(NSUInteger)count &#123; if (self = [super init]) &#123; _containerClassID = containerClassID; _key = key.copy; _implementation = implementation; _selector = selector; NSUInteger hash = 0; if (key) &#123; hash = CFHash(key); &#125; hash ^= (NSUInteger)containerClassID; _hashValue = hash; _extraArgumentCount = count; _extraArgument1 = extraArguments[0]; if (_extraArgument1 == key) &#123; _extraArgument1 = _key; &#125; _extraArgument2 = extraArguments[1]; if (_extraArgument2 == key) &#123; _extraArgument2 = _key; &#125; _extraArgument3 = extraArguments[2]; &#125; return self;&#125;@end NSKeyValueIvarGetter如何创建- (id)initWithContainerClassID:(id)containerClassID key:(NSString *)key containerIsa:(Class)containerIsa ivar:(Ivar)ivar &#123; const char *ivarEncoding = ivar_getTypeEncoding(ivar); IMP imp = NULL; switch (ivarEncoding[0]) &#123; case '#': case '@': &#123; objc_ivar_memory_management_t mngment = objc_ivar_memoryUnknown;//_class_getIvarMemoryManagement(containerIsa, ivar); if(mngment &lt; objc_ivar_memoryWeak) &#123; /* id _NSGetObjectGetAssignValueInIvar(id object, SEL selector, Ivar ivar) &#123; return *(id *)object_getIvarAddress(object, ivar); &#125; */ imp = (IMP)_NSGetObjectGetAssignValueInIvar; &#125; else if (mngment == objc_ivar_memoryWeak) &#123; /* id _NSGetObjectGetWeakValueInIvar(id object, SEL selector, Ivar ivar) &#123; return objc_loadWeak((id *)object_getIvarAddress(object, ivar)); &#125; */ imp = (IMP)_NSGetObjectGetWeakValueInIvar; &#125; else if(mngment == objc_ivar_memoryUnretained) &#123; imp = (IMP)_NSGetObjectGetAssignValueInIvar; &#125; else &#123; imp = (IMP)_NSGetObjectGetIvarValueInIvar; &#125; &#125; break; case 'C': &#123; /* NSNumber * _NSGetUnsignedCharValueInIvar(id object, SEL selector, Ivar ivar) &#123; unsigned char value = *(unsigned char *)object_getIvarAddress(object, ivar); return [[[NSNumber alloc] initWithUnsignedChar:value] autorelease]; &#125; */ imp = (IMP)_NSGetUnsignedCharValueInIvar; &#125; break; case 'B': &#123;imp = (IMP)_NSGetBoolValueInIvar;&#125;break; case 'I': &#123;imp = (IMP)_NSGetUnsignedIntValueInIvar;&#125;break; case 'L': &#123;imp = (IMP)_NSGetUnsignedLongValueInIvar;&#125;break; case 'Q': &#123;imp = (IMP)_NSGetUnsignedLongLongValueInIvar;&#125;break; case 'S': &#123;imp = (IMP)_NSGetUnsignedShortValueInIvar;&#125; break; case '&#123;': &#123; char* idx = index(ivarEncoding, '='); if (idx == NULL) &#123; imp = (IMP)_NSGetValueInIvar; &#125; else if (strncmp(ivarEncoding, @encode(CGPoint), idx - ivarEncoding) == 0)&#123; imp = (IMP)_NSGetPointValueInIvar; &#125; else if (strncmp(ivarEncoding, @encode(NSRange), idx - ivarEncoding) == 0)&#123; imp = (IMP)_NSGetRangeValueInIvar; &#125; else if (strncmp(ivarEncoding, @encode(CGRect), idx - ivarEncoding) == 0)&#123; imp = (IMP)_NSGetRectValueInIvar; &#125; else if (strncmp(ivarEncoding, @encode(CGSize), idx - ivarEncoding) == 0)&#123; imp = (IMP)_NSGetSizeValueInIvar; &#125; else &#123; imp = (IMP)_NSGetValueInIvar; &#125; &#125; break; case 'c': &#123;imp = (IMP)_NSGetCharValueInIvar;&#125;break; case 'd': &#123;imp = (IMP)_NSGetDoubleValueInIvar;&#125;break; case 'f': &#123;imp = (IMP)_NSGetFloatValueInIvar;&#125;break; case 'i': &#123;imp = (IMP)_NSGetIntValueInIvar;&#125;break; case 'l': &#123;imp = (IMP)_NSGetLongValueInIvar;&#125;break; case 'q': &#123;imp = (IMP)_NSGetLongLongValueInIvar;&#125;break; case 's': &#123;imp = (IMP)_NSGetShortValueInIvar;&#125;break; &#125; if(imp) &#123; void *arguments[3] = &#123;0&#125;; arguments[0] = ivar; return [super initWithContainerClassID:containerClassID key:key implementation:imp selector:NULL extraArguments:arguments count:1]; &#125; else &#123; [self release]; return nil; &#125;&#125; 同样地，判断实例变量的类型编码，进而赋值不同的IMP。 怎么根据Getter取值1. 线程校验void NSKeyValueObservingAssertRegistrationLockNotHeld() &#123; if(_NSKeyValueObserverRegistrationEnableLockingAssertions &amp;&amp; _NSKeyValueObserverRegistrationLockOwner == pthreaself()) &#123; assert(pthreaself() != _NSKeyValueObserverRegistrationLockOwner); &#125;&#125; 2. 直接调用Getter中存储的方法实现(getter.implementation)id _NSGetUsingKeyValueGetter(id object, NSKeyValueGetter *getter) &#123; // 线程判断 NSKeyValueObservingAssertRegistrationLockNotHeld(); // 根据其他参数数量extraArgumentCount分别进行函数调用 switch (getter.extraArgumentCount) &#123; case 0: &#123; return ( (id (*)(id,SEL))getter.implementation )(object,getter.selector); &#125; break; case 1: &#123; return ( (id (*)(id,SEL,void*))getter.implementation )(object,getter.selector, getter.extraArgument1); &#125; break; case 2: &#123; return ( (id (*)(id,SEL,void*,void*))getter.implementation )(object,getter.selector, getter.extraArgument1, getter.extraArgument2); &#125; break; case 3: &#123; return ( (id (*)(id,SEL,void*,void*,void*))getter.implementation )(object,getter.selector, getter.extraArgument1, getter.extraArgument2, getter.extraArgument3); &#125; break; default: break; &#125; return nil;&#125; valueForKeyPath:假定这里的keyPath为@&quot;key1.key2.key3.key4&quot;。 - (id)valueForKeyPath:(NSString *)keyPath &#123; if(keyPath) &#123; // 字符串编码判断 CFStringEncoding encoding = __CFDefaultEightBitStringEncoding; if(encoding == kCFStringEncodingInvalidId) &#123; // 编码无效 kCFStringEncodingInvalidId就是 (0xffffffffU) encoding = __CFStringComputeEightBitStringEncoding(); &#125; // 创建C字符串: "key1.key2.key3.key4" const char *cStr = CFStringGetCStringPtr((CFStringRef)keyPath, encoding); if(cStr) &#123; // memchr函数:从头开始搜寻s 所指的内存内容前n 个字节，直到发现第一个值为c 的字节，则返回指向该字节的指针 // 所以最后获取到包含'点符号'的后部分 即firstDotPointers为 ".key2.key3.key4" const char *firstDotPointer = memchr(cStr, '.', keyPath.length); if(firstDotPointer) &#123; // 这里的subKey是 "key1" NSString *subKey = [[keyPath substringWithRange:NSMakeRange(0, firstDotPointer - cStr)] retain]; // 这里的subKeyPathLeft是 "key2.key3.key4" NSString *subKeyPathLeft = [[keyPath substringWithRange:NSMakeRange(firstDotPointer - cStr + 1, keyPath.length - (firstDotPointer - cStr + 1))] retain]; // 先获取到subKey的结果, 然后用它的结果再求subKeyPathLeft, 进入递归中 id value = [[self valueForKey:subKey] valueForKeyPath:subKeyPathLeft]; [subKey release]; [subKeyPathLeft release]; return value; &#125; else &#123; // firstDotPointer不存在, 说明keyPath中没有'点符号', 则直接调用valueForKey return [self valueForKey:keyPath]; &#125; &#125; &#125; // 走到这里, 上面代码没有return, 说明keyPath为nil或者cStr为nil NSRange range = [keyPath rangeOfString:@"." options:NSLiteralSearch range:NSMakeRange(0, keyPath.length)]; if(range.length) &#123; // range.length不为0, 也即keyPath中有'点符号' // subKey为"key1" NSString *subKey = [[keyPath substringWithRange:NSMakeRange(0, range.location)] retain]; // subKeyPathLeft为"key2.key3.key4" NSString *subKeyPathLeft = [[keyPath substringWithRange:NSMakeRange(range.location + 1, keyPath.length - (range.location + 1))] retain]; // 同样的, 先获取到subKey的结果, 然后用它的结果再求subKeyPathLeft, 进入递归中 id value = [[self valueForKey:subKey] valueForKeyPath:subKeyPathLeft]; [subKey release]; [subKeyPathLeft release]; return value; &#125; else &#123; // keyPath为nil或者keyPath中没有'点符号', 直接调用valueForKey return [self valueForKey:keyPath]; &#125;&#125; 这里就有一个问题了，相似的把keyPath拆分逻辑的逻辑为啥要写两个，一个转为C字符串拆分，一个直接拆分? 揣测两者的区别主要是对字符串编码的判断。 三、设值设值的流程就比较简单了。 The default implementation of this method does the following: Searches the class of the receiver for an accessor method whose name matches the pattern -set&lt;Key&gt;:. If such a method is found the type of its parameter is checked. If the parameter type is not an object pointer type but the value is nil -setNilValueForKey: is invoked. The default implementation of -setNilValueForKey: raises an NSInvalidArgumentException, but you can override it in your application. Otherwise, if the type of the method’s parameter is an object pointer type the method is simply invoked with the value as the argument. If the type of the method’s parameter is some other type the inverse of the NSNumber/NSValue conversion done by -valueForKey: is performed before the method is invoked. Otherwise (no accessor method is found), if the receiver’s class’ +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern _&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;, in that order. If such an instance variable is found and its type is an object pointer type the value is retained and the result is set in the instance variable, after the instance variable’s old value is first released. If the instance variable’s type is some other type its value is set after the same sort of conversion from NSNumber or NSValue as in step 1. Otherwise (no accessor method or instance variable is found), invokes -setValue:forUndefinedKey:. The default implementation of -setValue:forUndefinedKey: raises an NSUndefinedKeyException, but you can override it in your application. Compatibility notes: For backward binary compatibility with -takeValue:forKey:‘s behavior, a method whose name matches the pattern -_set&lt;Key&gt;: is also recognized in step 1. KVC accessor methods whose names start with underscores were deprecated as of Mac OS 10.3 though. For backward binary compatibility, -unableToSetNilForKey: will be invoked instead of -setNilValueForKey: in step 1, if the implementation of -unableToSetNilForKey: in the receiver’s class is not NSObject’s. The behavior described in step 2 is different from -takeValue:forKey:‘s, in which the instance variable search order is &lt;key&gt;, _&lt;key&gt;. For backward binary compatibility with -takeValue:forKey:‘s behavior, -handleTakeValue:forUnboundKey: will be invoked instead of -setValue:forUndefinedKey: in step 3, if the implementation of -handleTakeValue:forUnboundKey: in the receiver’s class is not NSObject’s. 翻译如下：这个方法的默认实现是这样的： 搜索该类名称为-set&lt;Key&gt;:的存取器方法，如果找到，检查其参数类型。如果参数为nil，-setNilValueForKey:方法将会被调用。这个方法的默认实现是抛出NSInvalidArgumentException异常，不过你可以重写该方法自行实现。如果参数类型为对象类型，该存取器方法会被直接调用，这个参数也会被直接使用。如果参数能被转化为NSNumber/NSValue类型，参数会在存取器方法被调用之前进行转换。 如果存取器方法没有被找到，倘若此时消息接收者的+accessInstanceVariablesDirectly属性返回的是YES，那么按照_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;的顺序搜索该类的实例变量。如果找到这个实例变量，当其为对象类型时，该实例变量会在旧值释放之后被设置新值。当其为其他类型时，那么按照步骤1中的类型转换规则设置这个实例变量的值。 如果存取器方法和实例变量都没有被找到，-setValue:forUndefinedKey:方法将会被调用。这个方法的默认实现是抛出NSUndefinedKeyException异常，不过你可以重写该方法自行实现。 兼容性： 为了向后兼容-takeValue:forKey:，名称为-_set&lt;Key&gt;:的方法也会在步骤1中被查找。 如果-unableToSetNilForKey:的实现不是NSObject的默认实现（换句话说，自己手动实现了-unableToSetNilForKey:方法），那在步骤1中，-unableToSetNilForKey:方法将会代替-setNilValueForKey:方法被调用。 对于-takeValue:forKey:，其实例变量的查找顺序不同于步骤2所描述的，调用它时，实例变量查找顺序是&lt;key&gt;, _&lt;key&gt;。 为了向后兼容-takeValue:forKey:，如果-handleTakeValue:forUnboundKey:的实现不是NSObject的默认实现（换句话说，自己手动实现了-handleTakeValue:forUnboundKey:方法），那在步骤3中，-handleTakeValue:forUnboundKey:方法将会代替-setValue:forUndefinedKey:方法被调用。 流程图如下： setValue:方法一这里使用NSKeyValueCachedSetters缓存setter。 // 假定key为@"name"- (void)setValue:(id)value forKey:(NSString *)key &#123; if (key) &#123; // 加锁 OSSpinLockLock(&amp;NSKeyValueCachedAccessorSpinLock); if (!NSKeyValueCachedSetters) &#123; CFSetCallBacks callbacks = &#123;0&#125;; callbacks.version = kCFTypeSetCallBacks.version; callbacks.retain = kCFTypeSetCallBacks.retain; callbacks.release = kCFTypeSetCallBacks.release; callbacks.copyDescription = kCFTypeSetCallBacks.copyDescription; callbacks.equal = (CFSetEqualCallBack)NSKeyValueAccessorIsEqual; callbacks.hash = (CFSetHashCallBack)NSKeyValueAccessorHash; NSKeyValueCachedSetters = CFSetCreateMutable(NULL,0,&amp;callbacks); &#125; NSKeyValueSetter *finder = [NSKeyValueSetter new]; finder.containerClassID = object_getClass(self); finder.key = key; finder.hashValue = CFHash((CFTypeRef)key) ^ (NSUInteger)(object_getClass(self)); // 缓存中取Setter NSKeyValueSetter *setter = CFSetGetValue(NSKeyValueCachedSetters, (void *)finder); if (!setter) &#123; setter = [object_getClass(self) _createValueSetterWithContainerClassID:object_getClass(self) key:key]; CFSetAddValue(NSKeyValueCachedSetters, (void*)setter); &#125; // 解锁 OSSpinLockUnlock(&amp;NSKeyValueCachedAccessorSpinLock); // 设值 _NSSetUsingKeyValueSetter(self,setter, value); &#125; else &#123; [NSException raise:NSInvalidArgumentException format:@"%@: attempt to set a value for a nil key",_NSMethodExceptionProem(self,_cmd)]; &#125;&#125; 方法二+ (NSKeyValueSetter *)_createValueSetterWithContainerClassID:(id)containerClassID key:(NSString *)key &#123; NSKeyValueSetter *setter = nil; NSUInteger key_cstr_len = [key lengthOfBytesUsingEncoding:NSUTF8StringEncoding]; // 首字符大写的key char key_cstr_upfirst[key_cstr_len + 1]; [key getCString:key_cstr_upfirst maxLength:key_cstr_len + 1 encoding:NSUTF8StringEncoding]; if (key.length) &#123; key_cstr_upfirst[0] = toupper(key_cstr_upfirst[0]); &#125; // 原来的key char key_cstr[key_cstr_len + 1]; [key getCString:key_cstr maxLength:key_cstr_len + 1 encoding:NSUTF8StringEncoding]; Method method = NULL; // 查找方法顺序, 假定key为@"name" // setName: ==&gt; _setName: ==&gt; setIsName: if ((method = NSKeyValueMethodForPattern(self, "set%s:", key_cstr_upfirst)) || (method = NSKeyValueMethodForPattern(self, "_set%s:", key_cstr_upfirst)) || (method = NSKeyValueMethodForPattern(self, "setIs%s:", key_cstr_upfirst)) ) &#123; setter = [[NSKeyValueMethodSetter alloc] initWithContainerClassID:containerClassID key:key method:method]; &#125; else if ([self accessInstanceVariablesDirectly]) &#123; Ivar ivar = NULL; // 允许直接访问实例变量, 查找顺序为: _name ==&gt; _isName ==&gt; name ==&gt; isName if ((ivar = NSKeyValueIvarForPattern(self, "_%s", key_cstr)) || (ivar = NSKeyValueIvarForPattern(self, "_is%s", key_cstr_upfirst)) || (ivar = NSKeyValueIvarForPattern(self, "%s", key_cstr)) || (ivar = NSKeyValueIvarForPattern(self, "is%s", key_cstr_upfirst)) ) &#123; setter = [[NSKeyValueIvarSetter alloc] initWithContainerClassID:containerClassID key:key containerIsa:self ivar:ivar]; &#125; &#125; if (!setter) &#123; setter = [self _createValuePrimitiveSetterWithContainerClassID:containerClassID key:key]; &#125; return setter;&#125; 方法三+ (NSKeyValueSetter *)_createValuePrimitiveSetterWithContainerClassID:(id)containerClassID key:(NSString *)key &#123; NSKeyValueSetter *setter = nil; NSUInteger keyCstrLen = [key lengthOfBytesUsingEncoding:NSUTF8StringEncoding]; char keyCstrUpFirst[keyCstrLen + 1]; [key getCString:keyCstrUpFirst maxLength:keyCstrLen + 1 encoding:NSUTF8StringEncoding]; if(key.length) &#123; keyCstrUpFirst[0] = toupper(keyCstrUpFirst[0]); &#125; char keyCstr[keyCstrLen + 1]; [key getCString:keyCstr maxLength:keyCstrLen + 1 encoding:NSUTF8StringEncoding]; // 假定key为@"name", 查询 setPrimitiveName:方法 Method method = NSKeyValueMethodForPattern(self,"setPrimitive%s:",keyCstrUpFirst); if(method) &#123; setter = [[NSKeyValueMethodSetter alloc] initWithContainerClassID:containerClassID key:key method:method]; &#125; else &#123; if([self accessInstanceVariablesDirectly]) &#123; Ivar ivar = NULL; if ((ivar = NSKeyValueIvarForPattern(self, "_%s", keyCstr)) || (ivar = NSKeyValueIvarForPattern(self, "_is%s", keyCstrUpFirst)) || (ivar = NSKeyValueIvarForPattern(self, "%s", keyCstr)) || (ivar = NSKeyValueIvarForPattern(self, "is%s", keyCstrUpFirst)) ) &#123; setter = [[NSKeyValueIvarSetter alloc] initWithContainerClassID:containerClassID key:key containerIsa:self ivar:ivar]; &#125; &#125; &#125; if(!setter) &#123; setter = [self _createOtherValueSetterWithContainerClassID:containerClassID key:key]; &#125; return setter;&#125; 方法四+ (NSKeyValueSetter *)_createOtherValueSetterWithContainerClassID:(id)containerClassID key:(NSString *)key &#123; return [[NSKeyValueUndefinedSetter alloc] initWithContainerClassID:containerClassID key:key containerIsa:self];&#125; 怎么根据Setter设值void _NSSetUsingKeyValueSetter(id object, NSKeyValueSetter *setter, id value) &#123; switch (setter.extraArgumentCount) &#123; case 0: &#123; ( (id (*)(id,SEL,id))setter.implementation )(object,setter.selector,value); &#125; break; case 1: &#123; ( (id (*)(id,SEL,id,void*))setter.implementation )(object,setter.selector, value, setter.extraArgument1); &#125; break; case 2: &#123; ( (id (*)(id,SEL,id,void*,void*))setter.implementation )(object,setter.selector, value, setter.extraArgument1, setter.extraArgument2); &#125; break; case 3: &#123; ( (id (*)(id,SEL,id,void*,void*,void*))setter.implementation )(object,setter.selector, value, setter.extraArgument1, setter.extraArgument2, setter.extraArgument3); &#125; break; default: break; &#125;&#125; 直接调用Setter中存储的方法实现(getter.implementation)。 setValue:forKeyPath:- (void)setValue:(id)value forKeyPath:(NSString *)keyPath &#123; if(keyPath) &#123; CFStringEncoding encoding = __CFDefaultEightBitStringEncoding; if(encoding == kCFStringEncodingInvalidId) &#123; encoding = __CFStringComputeEightBitStringEncoding(); &#125; const char *keyPathCStr = CFStringGetCStringPtr((CFStringRef)keyPath, encoding); if(keyPathCStr) &#123; const char *firstDotPointer = memchr(keyPathCStr, '.', keyPath.length); if(firstDotPointer) &#123; NSString *subKey = [[keyPath substringWithRange:NSMakeRange(0, firstDotPointer - keyPathCStr)] retain]; NSString *subKeyPathAfterDot = [[keyPath substringWithRange:NSMakeRange(firstDotPointer - keyPathCStr + 1, keyPath.length - (firstDotPointer - keyPathCStr + 1))] retain]; [[self valueForKey:subKey] setValue:value forKeyPath:subKeyPathAfterDot]; [subKey release]; [subKeyPathAfterDot release]; &#125; else &#123; [self setValue:value forKey:keyPath]; &#125; &#125; &#125; NSRange dotRange = [keyPath rangeOfString:@"." options:NSLiteralSearch range:NSMakeRange(0, keyPath.length)]; if(dotRange.length) &#123; NSString *subKey = [[keyPath substringWithRange:NSMakeRange(0, dotRange.location)] retain]; NSString *subKeyPathAfterDot = [[keyPath substringWithRange:NSMakeRange(dotRange.location + 1, keyPath.length - (dotRange.location + 1))] retain]; [[self valueForKey:subKey] setValue:value forKeyPath:subKeyPathAfterDot]; [subKey release]; [subKeyPathAfterDot release]; &#125; else &#123; [self setValue:value forKey:keyPath]; &#125;&#125; 基本是与取值类似的逻辑。 四、集合对象的KVCNSArray的KVC接口@interface NSArray (NSKeyValueCoding)// 返回Array内每个对象的“key”对应值组成的数组- (id)valueForKey:(NSString *)key;// 如果keyPath中包含集合运算符, 则返回运算结果, 否则返回Array内每个对象的“keyPath”对应值组成的数组- (id)valueForKeyPath:(NSString *)keyPath;// 设置Array里每个对象的key对应值为value- (void)setValue:(id)value forKey:(NSString *)key;@end 实现- (id)valueForKey:(NSString *)key &#123; NSString *operationKey = nil; // 集合运算符:如@count, @firstObject, @lastObject等 if (key.length &amp;&amp; [key characterAtIndex:0] == '@' &amp;&amp; (operationKey = [key substringWithRange:NSMakeRange(1, key.length - 1)])) &#123; // 去掉'@'便是operationKey id value = [super valueForKey:operationKey]; return value; &#125; else &#123; // 创建与自身相等数量的array id *objectsBuff = NSAllocateObjectArray(self.count); // 现在, 指针p与指针objectsBuff指向一致 id *p = objectsBuff; // 遍历自身 for (id object in self) &#123; // 取出容器中的元素对应的value id eachValue = [object valueForKey:key]; // 如果eachValue不存在, 则p的next指针指向的对象设置成 NSNull实例对象 // 如果eachValue有值, 则p的next指针指向的对象设置为eachValue *(p++) = (eachValue ? : [NSNull null]); &#125; // 根据objectsBuff创建一个数组, 这个objectsBuff就是'eachValue'的集合 // 也即假定key为@"name", 遍历容器中所有元素, 取出每个元素key为@"name"对应的值, 这些值的集合就是数组arrayValue NSArray *arrayValue = [[[NSArray alloc] initWithObjects:objectsBuff count:self.count] autorelease]; // 释放objectsBuff NSFreeObjectArray(objectsBuff); return arrayValue; &#125;&#125;- (id)valueForKeyPath:(NSString *)keyPath &#123; // 集合运算符: 如@count, @firstObject, @"@unionOfObjects.friend.name"等 // 这里以 @"@unionOfObjects.friend"为例 if(keyPath.length &amp;&amp; [keyPath characterAtIndex:0] == '@') &#123; // 说明keyPath中有'@符号', 且'@符号'在第0个位置处 NSRange dotRange = [keyPath rangeOfString:@"." options:NSLiteralSearch range:NSMakeRange(0, keyPath.length)]; if(dotRange.length) &#123; // dotRange.length不为0, 说明keyPath中有'@符号', 而且还有'点符号' // 取出包含运算符的那部分,如 @"unionOfObjects" NSString *operator = [keyPath substringWithRange:NSMakeRange(0, dotRange.location)]; // 取出除运算符之外的那部分,如 @"friend" NSString *keyPathForOperator = [keyPath substringWithRange:NSMakeRange(dotRange.location + 1, keyPath.length - (dotRange.location + 1))]; if(keyPathForOperator) &#123; // 说明含运算符的那部分如 @"unionOfObjects" 和除运算符之外的那部分如 @"friend" 都存在 NSUInteger operatorCStrLength = [operator lengthOfBytesUsingEncoding:NSUTF8StringEncoding]; char operatorCStr[operatorCStrLength + 1]; // 转为C字符串operatorCStr, 也即 @"unionOfObjects" 转为 "unionOfObjects" [operator getCString:operatorCStr maxLength:operatorCStrLength + 1 encoding:NSUTF8StringEncoding]; // 查找方法, 即: "unionOfObjectsForKeyPath:" Method operatorMethod = NSKeyValueMethodForPattern(self.class, "%sForKeyPath:", operatorCStr); if(!operatorMethod) &#123; // 上面的方法没找到, 就查找带下划线的那个: "_unionOfObjectsForKeyPath:" operatorMethod = NSKeyValueMethodForPattern(self.class, "_%sForKeyPath:", operatorCStr); &#125; if (operatorMethod) &#123; // 查找成功, 调用运算符对应的方法 id value = ((id (*)(id,Method,NSString *))methoinvoke)(self,operatorMethod,keyPathForOperator); return value; &#125; else &#123; // 没有找到, 说明是不支持的运算符 [NSException raise:NSInvalidArgumentException format:@"[&lt;%@ %p&gt; valueForKeyPath:]: this class does not implement the %@ operation.", self.class,self,operator]; return nil; &#125; &#125; else &#123; // 说明只有包含运算符的那部分如 @"friend", 走NSObject的valueForKey逻辑 id value = [super valueForKey:operator]; return value; &#125; &#125; else &#123; // keyPath中有'@符号', 但是没有'点符号', 取出除'@符号'之外的key NSString *key = [[keyPath substringWithRange:NSMakeRange(1, keyPath.length - 1)] retain]; // 走NSObject的valueForKey逻辑 id value = [super valueForKey:key]; return value; &#125; &#125; else &#123; // 没有'@符号',可能有'点符号', 走NSObject的valueForKeyPath逻辑 return [super valueForKeyPath: keyPath]; &#125;&#125;- (void)setValue:(id)value forKey:(NSString *)key &#123; for (id object in self) &#123; // 对容器内的每一个元素都设值 [object setValue:value forKey:key]; &#125;&#125; 求和// @sum.keyPath, 例如 @"@sum.price", 传递到这个方法中, 参数keyPath为@"price"- (NSNumber *)_sumForKeyPath:(NSString *)keyPath &#123; NSDecimal resultDecimal = &#123;0&#125;; NSDecimalNumber *zero = [NSDecimalNumber zero]; if (zero) resultDecimal = [zero decimalValue]; // 这里使用NSDecimalNumber 保证精确度 NSDecimal eachDecimal = &#123;0&#125;; for (NSUInteger i=0; i&lt;self.count; ++i) &#123; // 获取每个对象的keyPath(如@"price")对应值 id eachValue = [self _valueForKeyPath:keyPath ofObjectAtIndex:i]; if (eachValue) &#123; eachDecimal = [eachValue decimalValue]; // 累加 NSDecimalAdd(&amp;resultDecimal, &amp;resultDecimal, &amp;eachDecimal, NSRoundBankers); &#125; &#125; return [NSDecimalNumber decimalNumberWithDecimal:resultDecimal];&#125; 求平均值// 对 Array中每个对象的keyPath对应值 求平均值// @avg.keyPath- (NSNumber *)_avgForKeyPath:(NSString *)keyPath &#123; if (self.count) &#123; //总和 / 对象数 return [(NSDecimalNumber*)[self _sumForKeyPath:keyPath] decimalNumberByDividingBy:(NSDecimalNumber*)[NSDecimalNumber numberWithUnsignedInteger:self.count]]; &#125; return 0;&#125; 求数量// 获取对象数目// @count- (NSNumber *)_countForKeyPath:(NSString *)keyPath &#123; return [NSNumber numberWithInteger:self.count];&#125; 求最大值// 对 Array中每个对象的keyPath对应值 求最大值// @max.keyPath- (id)_maxForKeyPath:(NSString *)keyPath &#123; id maxValue = nil; for (NSUInteger i=0; i&lt;self.count; ++i) &#123; id eachValue = [self _valueForKeyPath:keyPath ofObjectAtIndex:i]; if (eachValue) &#123; if (!maxValue) &#123; maxValue = eachValue; &#125; else if ([maxValue compare:eachValue] == NSOrderedAscending)&#123; maxValue = eachValue; &#125; &#125; &#125; return maxValue;&#125; 求最小值// 对 Array中每个对象的keyPath对应值 求最小值// @min.keyPath- (id)_minForKeyPath:(NSString *)keyPath &#123; id minValue = nil; for (NSUInteger i=0; i&lt;self.count; ++i) &#123; id eachValue = [self _valueForKeyPath:keyPath ofObjectAtIndex:i]; if (eachValue) &#123; if (!minValue) &#123; minValue = eachValue; &#125; else if ([minValue compare:eachValue] == NSOrderedDescending)&#123; minValue = eachValue; &#125; &#125; &#125; return minValue;&#125; 获取数组// 返回 Array中每个对象的keyPath对应值 组成数组// @unionOfObjects.keyPath- (NSArray *)_unionOfObjectsForKeyPath:(NSString *)keyPath &#123; NSMutableArray *unionArray = [NSMutableArray arrayWithCapacity:self.count]; for (NSUInteger i=0; i&lt;self.count; ++i) &#123; id eachValue = [self _valueForKeyPath:keyPath ofObjectAtIndex:i]; if (eachValue) &#123; [unionArray addObject:eachValue]; &#125; &#125; return unionArray;&#125; 获取去重数组// 返回 Array中每个对象的keyPath对应值 组成去重数组// @distinctUnionOfObjects.keyPath- (NSArray *)_distinctUnionOfObjectsForKeyPath:(NSString *)keyPath &#123; NSArray *unionArray = [self _unionOfObjectsForKeyPath:keyPath]; return [NSSet setWithArray:unionArray].allObjects;&#125; 获取成员数组// 返回 Array中每个对象的keyPath对应数组的每个成员 组成数组 这里每个keyPath对应值是也是数组，获取的是每个数组展开后组成的总数组// @unionOfArrays.keyPath- (NSArray *)_unionOfArraysForKeyPath:(NSString *)keyPath &#123; NSMutableArray *unionArray = [NSMutableArray arrayWithCapacity:self.count]; for (NSUInteger i=0; i&lt;self.count; ++i) &#123; id eachValue = [self _valueForKeyPath:keyPath ofObjectAtIndex:i]; if (eachValue) &#123; [unionArray addObjectsFromArray:eachValue]; &#125; &#125; return unionArray;&#125; 获取去重的成员数组// 返回 Array中每个对象的keyPath对应数组的每个成员 组成的去重复数组.// @distinctUnionOfArrays.keyPath- (NSArray *)_distinctUnionOfArraysForKeyPath:(NSString *)keyPath &#123; NSArray *unionArray = [self _unionOfArraysForKeyPath:keyPath]; return [NSSet setWithArray:unionArray].allObjects;&#125; 获取集合数组// 返回 Array中每个对象的keyPath对应集合的每个成员 组成的数组. 这里每个keyPath对应值是是集合，获取的是每个集合展开后组成的总数组// @unionOfSets.keyPath- (NSArray *)_unionOfSetsForKeyPath:(NSString *)keyPath &#123; NSMutableArray *unionArray = [NSMutableArray arrayWithCapacity:self.count]; for (NSUInteger i=0; i&lt;self.count; ++i) &#123; id eachValue = [self _valueForKeyPath:keyPath ofObjectAtIndex:i]; if (eachValue) &#123; [unionArray addObjectsFromArray:[eachValue allObjects]]; &#125; &#125; return unionArray;&#125; 获取去重的集合数组// 返回 Array中每个对象的keyPath对应集合的每个成员 组成的去重复数组.// @distinctUnionOfSets.keyPath- (NSArray *)_distinctUnionOfSetsForKeyPath:(NSString *)keyPath &#123; NSMutableSet *unionSet = [NSMutableSet setWithCapacity:self.count]; for (NSUInteger i=0; i&lt;self.count; ++i) &#123; id eachValue = [self _valueForKeyPath:keyPath ofObjectAtIndex:i]; if (eachValue) &#123; [unionSet unionSet:eachValue]; &#125; &#125; return unionSet.allObjects;&#125; NSSet的KVC与NSArray的逻辑基本保持一致。 NSOrderedSet的KVC与NSArray的逻辑基本保持一致。 NSDictionary的KVC与NSArray相比，主要区别在于： - (id)valueForKey:(NSString *)key &#123; NSString *operationKey = nil; // key中包含'@字符', 且'@字符'在第0位, 如 @"@count" if(key.length &amp;&amp; [key characterAtIndex:0] == '@' &amp;&amp; (operationKey = [key substringWithRange:NSMakeRange(1, key.length - 1)])) &#123; // 此时, operationKey为 @"count" return [super valueForKey:operationKey]; &#125; else &#123; // 没有'@字符', 走字典的objectForKey逻辑 return [self objectForKey:key]; &#125;&#125; valueForKey:取值逻辑多了对@字符的处理。 valueForKeyPath:与NSArray的逻辑一致。 五、其他分类的KVCNSMutableDictionary的KVC@implementation NSMutableDictionary (NSKeyValueCoding)- (void)setValue:(id)value forKey:(NSString *)key &#123; if(value) &#123; [self setObject:value forKey:key]; &#125; else &#123; [self removeObjectForKey:key]; &#125;&#125;@end 相比主类增加的特性是：在NSMutableDictionary中，如果设置的value为空，则自动将key对应的value移除。 NSUserDefaults的KVC@implementation NSUserDefaults (NSKeyValueCoding)- (id)valueForKey:(NSString *)key &#123; NSString *subKey = nil; if(key.length &amp;&amp; [key characterAtIndex:0] == '@' &amp;&amp; (subKey = [key substringWithRange:NSMakeRange(1, key.length - 1)])) &#123; return [super valueForKey:subKey]; &#125; else &#123; return [self objectForKey:key]; &#125;&#125;- (void)setValue:(id)value forKey:(NSString *)key &#123; if(value) &#123; [self setObject:value forKey:key]; &#125; else &#123; [self removeObjectForKey:key]; &#125;&#125;@end 整合了NSDictionary与NSMutableDictionary的特色。 增加了对@字符的处理。 如果设置的value为空，则自动将key对应的value移除。 NSNull的KVC@implementation NSNull (NSKeyValueCoding)- (id)valueForKey:(NSString *)key &#123; return self;&#125;@end 对于NSNull来说，无论怎么设值，取出来的值总是NSNull对象。 六、总结纵观全流程，使用KVC与直接使用存取器相比，速度方面稍有逊色，揣测主要原因如下： 字符串处理。尤其是含有键路径的时候，使用到递归（函数调用栈）。（当然，含有@字符的集合运算符也算。） 方法查找。流程颇多，尽管有使用CFSet作为缓存。 装箱拆箱。KVC要求设值参数和取值参数均为对象，这就需要一般值类型和对象类型的相互转换。 这也是为啥现在字典转模型都不使用KVC了，参见《读YYModel》。 KVC并没有那么高性能，那么就无用武之地了吗？非也。 1.访问私有成员变量对于只给出存取方法的对象，可以使用KVC直接访问私有成员变量。不过可能会破坏封装性，毕竟人家没暴露私有成员变量说明不想让人访问。更多的其实是体现在对系统库上访问上，“一不留神”就用到私有API了，我是乖孩子，不敢这么用，万一被苹果发现整个手百App就要被打回了。。。不过非私有API倒也可以尝试下，FDFullscreenPopGesture就用到了私有成员变量，极其巧妙地解决了全屏侧滑的问题。 2.集合操作在文章的第四部分【集合对象的KVC】，就已经描述过，求和、求平均值、去重巴拉巴拉，聊胜于无。 3.JSON解析前些日子，图搜进行框架改版，下发接口需要完全重构。这可是个危险的工作，今年后端已经出现两次问题了，主要是字段的类型出现错误，造成端启动的Crash。端上做了大量的防护工作，防不胜防，而且代码越来越难看。于是我想到了使用KVC解析字段，重新整理现有逻辑，脱敏后大致是这样：- (void)handleResponse:(NSDictionary *)response &#123; if (![response isKindOfClass:NSDictionary.class]) &#123; return; &#125; // 处理苹果业务 [self handleAppleConfigWithResponse:[response valueForKeyPath:@"dataset.config1.apple"]]; // 处理香蕉业务 [self handleBananaConfigWithResponse:[response valueForKeyPath:@"dataset.config2.banana"]]; // 处理橘子业务 [self handleOrangeConfigWithResponse:[response valueForKeyPath:@"dataset.config3.orange"]]; /// ...&#125; 使用keyPath对应到具体的处理逻辑，不同字段之间逻辑隔离，一个字段出错，并不影响其他字段；字段、方法、逻辑一一对应，后期增加或者删减很方便，新同学熟悉业务逻辑也清晰明了；response是字典，不会出现valueForUndefinedKey的异常。在每条处理逻辑中做类型保护工作，方便review，不会遗漏。 强烈建议阅读： https://myzerone.com/posts/2016/10/20/KVC(Key-Value-Coding)/KVC 和 KVO 源码来自：https://github.com/renjinkui2719/DIS_KVC_KVO 。感谢作者。 参考资料KVC Collection OperatorsiOS KVCiOS开发之你真的了解了KVC吗？KVC集合操作符KVC原理小记iOS 对象的 setter 方法性能测试]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读「FDFullscreenPopGesture」]]></title>
    <url>%2F2019%2F04%2F25%2F%E8%AF%BB%E3%80%8CFDFullscreenPopGesture%E3%80%8D%2F</url>
    <content type="text"><![CDATA[2019.5.29 修改Method Swizzling部分内容 优雅地开启全屏侧滑手势。 一、使用作者给UINavigationController和UIViewController都添加了分类，并进行了默认的参数设置，因此不做任何配置就能拥有这个功能。 二、原理作者通过方法交换，hook到系统原生push方法中的手势中的target和动画调用selector，创建自己的UIPanGestureRecognizer，并设置它的target和selector。 三、接口 @interface UINavigationController (FDFullscreenPopGesture)// 获取重新实现的侧滑返回手势对象@property (nonatomic, strong, readonly) UIPanGestureRecognizer *fd_fullscreenPopGestureRecognizer;// 是否允许视图控制器单独管理它对应的NavigationBar显示与隐藏.默认是YES// 这个需要配合视图控制器的fd_prefersNavigationBarHidden属性来使用// 也就是说如果把这个属性设置为NO, 视图控制器对应的导航栏的隐藏与否不由视图控制器决定@property (nonatomic, assign) BOOL fd_viewControllerBasedNavigationBarAppearanceEnabled;@end @interface UIViewController (FDFullscreenPopGesture)// 是否禁用全屏侧滑手势(默认NO)@property (nonatomic, assign) BOOL fd_interactivePopDisabled;// 表明当前控制器的导航栏是显示还是隐藏, 默认NO (显示导航栏)@property (nonatomic, assign) BOOL fd_prefersNavigationBarHidden;// 设置能够响应侧滑的最大边界(距离)@property (nonatomic, assign) CGFloat fd_interactivePopMaxAllowedInitialDistanceToLeftEdge;@end 四、源码阅读_FDFullscreenPopGestureRecognizerDelegate_FDFullscreenPopGestureRecognizerDelegate对象。遵循UIGestureRecognizerDelegate协议，主要用于决定控制器是否能响应手势。 @interface _FDFullscreenPopGestureRecognizerDelegate : NSObject &lt;UIGestureRecognizerDelegate&gt;@property (nonatomic, weak) UINavigationController *navigationController;@end@implementation _FDFullscreenPopGestureRecognizerDelegate- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)gestureRecognizer &#123; // 栈的最顶层, 不需要响应手势 if (self.navigationController.viewControllers.count &lt;= 1) &#123; return NO; &#125; // 打开了禁用手势的开关 UIViewController *topViewController = self.navigationController.viewControllers.lastObject; if (topViewController.fd_interactivePopDisabled) &#123; return NO; &#125; // 超过自己设置的left edge CGPoint beginningLocation = [gestureRecognizer locationInView:gestureRecognizer.view]; CGFloat maxAllowedInitialDistance = topViewController.fd_interactivePopMaxAllowedInitialDistanceToLeftEdge; if (maxAllowedInitialDistance &gt; 0 &amp;&amp; beginningLocation.x &gt; maxAllowedInitialDistance) &#123; return NO; &#125; // 正在执行Transition动画 if ([[self.navigationController valueForKey:@"_isTransitioning"] boolValue]) &#123; return NO; &#125; // 手机横屏状态下, 适配侧滑方向 // It tells you how far the touch moved since it was last reset. It resets when the touch goes down or if you reset it yourself. CGPoint translation = [gestureRecognizer translationInView:gestureRecognizer.view]; BOOL isLeftToRight = [UIApplication sharedApplication].userInterfaceLayoutDirection == UIUserInterfaceLayoutDirectionLeftToRight; CGFloat multiplier = isLeftToRight ? 1 : - 1; // 只能是从左向右滑 if ((translation.x * multiplier) &lt;= 0) &#123; return NO; &#125; return YES;&#125;@end UIViewController (FDFullscreenPopGesturePrivate)UIViewController的分类。给其添加关联属性fd_willAppearInjectBlock。hook viewWillAppear方法并在其中调用fd_willAppearInjectBlock回调，hook viewWillDisappear方法，并在其中根据控制器的fd_prefersNavigationBarHidden属性来设置状态栏的显示与否。 typedef void (^_FDViewControllerWillAppearInjectBlock)(UIViewController *viewController, BOOL animated);@interface UIViewController (FDFullscreenPopGesturePrivate)@property (nonatomic, copy) _FDViewControllerWillAppearInjectBlock fd_willAppearInjectBlock;@end@implementation UIViewController (FDFullscreenPopGesturePrivate)+ (void)load &#123; static dispatch_once_t onceToken; // 方法交换, viewWillAppear和fd_viewWillAppear互换, viewWillDisappear和fd_viewWillDisappear互换 dispatch_once(&amp;onceToken, ^&#123; Method viewWillAppear_originalMethod = class_getInstanceMethod(self, @selector(viewWillAppear:)); Method viewWillAppear_swizzledMethod = class_getInstanceMethod(self, @selector(fd_viewWillAppear:)); method_exchangeImplementations(viewWillAppear_originalMethod, viewWillAppear_swizzledMethod); Method viewWillDisappear_originalMethod = class_getInstanceMethod(self, @selector(viewWillDisappear:)); Method viewWillDisappear_swizzledMethod = class_getInstanceMethod(self, @selector(fd_viewWillDisappear:)); method_exchangeImplementations(viewWillDisappear_originalMethod, viewWillDisappear_swizzledMethod); &#125;);&#125;- (void)fd_viewWillAppear:(BOOL)animated &#123; // 主类的实现 Forward to primary implementation. [self fd_viewWillAppear:animated]; if (self.fd_willAppearInjectBlock) &#123; self.fd_willAppearInjectBlock(self, animated); &#125;&#125;- (void)fd_viewWillDisappear:(BOOL)animated &#123; // Forward to primary implementation. [self fd_viewWillDisappear:animated]; // 延迟为0相当于直接调用异步 // dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; UIViewController *viewController = self.navigationController.viewControllers.lastObject; // viewController存在而且它的fd_prefersNavigationBarHidden为NO, 把NavigationBar显示出来 if (viewController &amp;&amp; !viewController.fd_prefersNavigationBarHidden) &#123; [self.navigationController setNavigationBarHidden:NO animated:NO]; &#125; &#125;);&#125;- (_FDViewControllerWillAppearInjectBlock)fd_willAppearInjectBlock &#123; return objc_getAssociatedObject(self, _cmd);&#125;- (void)setFd_willAppearInjectBlock:(_FDViewControllerWillAppearInjectBlock)block &#123; objc_setAssociatedObject(self, @selector(fd_willAppearInjectBlock), block, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;@end UINavigationController (FDFullscreenPopGesture)UINavigationController的分类。hookpushViewController:animated:方法，给响应push手势的view添加自定义的fd_fullscreenPopGestureRecognizer手势。当然，fd_fullscreenPopGestureRecognizer的target和selector与push原生手势的target及selector保持一致。除此之外，fd_fullscreenPopGestureRecognizer手势的代理是上面的_FDFullscreenPopGestureRecognizerDelegate对象，目的是决定是否响应手势。 @implementation UINavigationController (FDFullscreenPopGesture)+ (void)load &#123; // Inject "-pushViewController:animated:" // 交换pushViewController与fd_pushViewController static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(pushViewController:animated:); SEL swizzledSelector = @selector(fd_pushViewController:animated:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (success) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)fd_pushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; // 保证view只添加一次fd_fullscreenPopGestureRecognizer手势 if (![self.interactivePopGestureRecognizer.view.gestureRecognizers containsObject:self.fd_fullscreenPopGestureRecognizer]) &#123; // Add our own gesture recognizer to where the onboard screen edge pan gesture recognizer is attached to. [self.interactivePopGestureRecognizer.view addGestureRecognizer:self.fd_fullscreenPopGestureRecognizer]; // 获取私有变量target和selector NSArray *internalTargets = [self.interactivePopGestureRecognizer valueForKey:@"targets"]; id internalTarget = [internalTargets.firstObject valueForKey:@"target"]; SEL internalAction = NSSelectorFromString(@"handleNavigationTransition:"); // 设置滑动手势的代理 self.fd_fullscreenPopGestureRecognizer.delegate = self.fd_popGestureRecognizerDelegate; [self.fd_fullscreenPopGestureRecognizer addTarget:internalTarget action:internalAction]; // 禁用原生的手势 self.interactivePopGestureRecognizer.enabled = NO; &#125; // 处理navigation bar 的显示与隐藏 [self fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:viewController]; // 调用原来的方法实现(加一个判断, 避免重复push) if (![self.viewControllers containsObject:viewController]) &#123; [self fd_pushViewController:viewController animated:animated]; &#125;&#125;- (void)fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:(UIViewController *)appearingViewController &#123; // 如果fd_viewControllerBasedNavigationBarAppearanceEnabled设置为NO, 直接返回 if (!self.fd_viewControllerBasedNavigationBarAppearanceEnabled) &#123; return; &#125; // 配合fd_prefersNavigationBarHidden来使用 __weak typeof(self) weakSelf = self; _FDViewControllerWillAppearInjectBlock block = ^(UIViewController *viewController, BOOL animated) &#123; __strong typeof(weakSelf) strongSelf = weakSelf; if (strongSelf) &#123; [strongSelf setNavigationBarHidden:viewController.fd_prefersNavigationBarHidden animated:animated]; &#125; &#125;; // 设置appearingViewController、disappearingViewController的fd_willAppearInjectBlock appearingViewController.fd_willAppearInjectBlock = block; UIViewController *disappearingViewController = self.viewControllers.lastObject; if (disappearingViewController &amp;&amp; !disappearingViewController.fd_willAppearInjectBlock) &#123; disappearingViewController.fd_willAppearInjectBlock = block; &#125;&#125;- (_FDFullscreenPopGestureRecognizerDelegate *)fd_popGestureRecognizerDelegate &#123; _FDFullscreenPopGestureRecognizerDelegate *delegate = objc_getAssociatedObject(self, _cmd); // 只初始化delegate一次 if (!delegate) &#123; delegate = [[_FDFullscreenPopGestureRecognizerDelegate alloc] init]; delegate.navigationController = self; objc_setAssociatedObject(self, _cmd, delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return delegate;&#125;- (UIPanGestureRecognizer *)fd_fullscreenPopGestureRecognizer &#123; UIPanGestureRecognizer *panGestureRecognizer = objc_getAssociatedObject(self, _cmd); // 只初始化panGestureRecognizer一次 if (!panGestureRecognizer) &#123; panGestureRecognizer = [[UIPanGestureRecognizer alloc] init]; panGestureRecognizer.maximumNumberOfTouches = 1; objc_setAssociatedObject(self, _cmd, panGestureRecognizer, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return panGestureRecognizer;&#125;- (BOOL)fd_viewControllerBasedNavigationBarAppearanceEnabled &#123; NSNumber *number = objc_getAssociatedObject(self, _cmd); if (number) &#123; // BOOL值被封装成对象了 return number.boolValue; &#125; // 走到这一步说明还没有设置过关联属性, 手动设置 self.fd_viewControllerBasedNavigationBarAppearanceEnabled = YES; return YES;&#125;- (void)setFd_viewControllerBasedNavigationBarAppearanceEnabled:(BOOL)enabled &#123; SEL key = @selector(fd_viewControllerBasedNavigationBarAppearanceEnabled); objc_setAssociatedObject(self, key, @(enabled), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end UIViewController (FDFullscreenPopGesture)UIViewController的分类。给其添加关联属性fd_interactivePopDisabled、fd_interactivePopMaxAllowedInitialDistanceToLeftEdge和fd_prefersNavigationBarHidden。 @implementation UIViewController (FDFullscreenPopGesture)- (BOOL)fd_interactivePopDisabled &#123; // 关于_cmd: 这行代码等价于 return [objc_getAssociatedObject(self, @selector(fd_interactivePopDisabled)) boolValue]; return [objc_getAssociatedObject(self, _cmd) boolValue];&#125;- (void)setFd_interactivePopDisabled:(BOOL)disabled &#123; objc_setAssociatedObject(self, @selector(fd_interactivePopDisabled), @(disabled), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (BOOL)fd_prefersNavigationBarHidden &#123; return [objc_getAssociatedObject(self, _cmd) boolValue];&#125;- (void)setFd_prefersNavigationBarHidden:(BOOL)hidden &#123; // 存储的时候需要把基本数据类型包装成对象 @(hidden) objc_setAssociatedObject(self, @selector(fd_prefersNavigationBarHidden), @(hidden), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (CGFloat)fd_interactivePopMaxAllowedInitialDistanceToLeftEdge &#123;#if CGFLOAT_IS_DOUBLE // CGFLOAT_IS_DOUBLE宏: 64位下是1 否则0, 特别严谨 return [objc_getAssociatedObject(self, _cmd) doubleValue];#else return [objc_getAssociatedObject(self, _cmd) floatValue];#endif&#125;- (void)setFd_interactivePopMaxAllowedInitialDistanceToLeftEdge:(CGFloat)distance &#123; SEL key = @selector(fd_interactivePopMaxAllowedInitialDistanceToLeftEdge); // 使用@(MAX(0, distance), 适配distance被外界设置为负值的情况 objc_setAssociatedObject(self, key, @(MAX(0, distance)), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 五、再谈Method Swizzling实例方法交换@interface ViewController ()@end@implementation ViewController- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; NSLog(@"原始的方法实现");&#125;@end@implementation ViewController (MethodSwizzling1)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class cls = [self class]; SEL originalSel = @selector(viewWillAppear:); SEL swizzledSel = @selector(ya1_viewWillAppear:); Method originalMethod = class_getInstanceMethod(cls, originalSel); Method swizzledMethod = class_getInstanceMethod(cls, swizzledSel); if (class_addMethod(cls, originalSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod(cls, swizzledSel, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)ya1_viewWillAppear:(BOOL)animated &#123; [self ya1_viewWillAppear:animated]; NSLog(@"第一次在分类里面互换");&#125;@end 类方法交换// 交换类方法+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; SEL originalSel = @selector(a); SEL swizzledSel = @selector(b); Class class = object_getClass(self); Method originalMethod = class_getInstanceMethod(class, originalSel); Method swizzledMethod = class_getInstanceMethod(class, swizzledSel); if (class_addMethod(class, originalSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod(class, swizzledSel, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;+ (void)b &#123; NSLog(@"b");&#125; 问题1：实例方法交换与类方法交换有什么区别？没有大的变化，唯一的区别在于获取方法所属的对象上，一个获取的是类对象一个获取的是元类对象。即一个是[self class]或者说[self self]，一个是object_getClass(self)（在类方法load中调用的）。为什么会有这种区别？原因在于，实例方法存储在类对象中，类方法存储在元类对象中。 再一个，看看class的实现： + (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125; 网上许多文章这么说的： object_getClass与self.class的区别self.class:当self是实例对象的时候，返回的是类对象，否则则返回自身。object_getClass:获得的是isa的指向 这个“返回自身”很含糊。 object_getClass()获取isa指向毋庸置疑。实例对象的isa指向类对象，类对象的isa指向元类对象，元类对象的isa指向根元类，根元类的isa指向它自己，耳熟能详。 关键是class，self指向了消息的接收者（“the object that’s received this message”），很自然地，实例方法的消息接收者是实例对象，类方法的消息接收者是类对象。根据代码实现来看，实例方法调用class是获取实例对象的isa指向，即类对象。而类对象调用class返回的消息接收者自己，这个“自身”指的就是类对象。于是，不管是实例对象还是类对象调用class方法，返回的总是类对象。 同样地，在实例方法的交换中，这几种获取类对象的方式是等价的： Class class = [self self];Class class = [self class];Class class = self; 调用self的self方法也没啥奇怪的，源码是这样的： - (id)self &#123; return self;&#125;+ (Class)class &#123; return self;&#125; 问题2：能否做到实例方法与类方法交换？实例方法与实例方法互换、类方法与类方法互换都很容易做到。那一个实例方法与一个类方法互换，或者一个类方法与一个实例方法互换可以做到吗？答案是肯定的。根据上文讨论，关键在于获取方法所属的对象上，即巧妙控制好获取的类对象和元类对象即可。 （1）实例方法与类方法互换（新的实例方法交换原先的类方法）SEL originalSel = @selector(classMethod);SEL swizzledSel = @selector(newInstanceMethod);Class originClass = object_getClass(self);Class swizzleClass = self; （2）类方法与实例方法互换（新的类方法交换原先的实例方法）SEL originalSel = @selector(instanceMethod);SEL swizzledSel = @selector(newClassMethod);Class originClass = self;Class swizzleClass = object_getClass(self); 二者的共同实现是这样的： Method originalMethod = class_getInstanceMethod(originClass, originalSel);Method swizzledMethod = class_getInstanceMethod(swizzleClass, swizzledSel);if (class_addMethod(originClass, originalSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod(originClass, swizzledSel, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));&#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod);&#125; 问题3：方法二次交换是否会影响第一次交换（造成第一次交换失效）？比如： @implementation ViewController (MethodSwizzling2)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; SEL originalSel = @selector(viewWillAppear:); SEL swizzledSel = @selector(ya2_viewWillAppear:); Method originalMethod = class_getInstanceMethod(self, originalSel); Method swizzledMethod = class_getInstanceMethod(self, swizzledSel); if (class_addMethod(self, originalSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod(self, swizzledSel, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)ya2_viewWillAppear:(BOOL)animated &#123; [self ya2_viewWillAppear:animated]; NSLog(@"第二次在分类里面互换");&#125;@end 很明显不会。 原因: Compile Sources中设定了分类的编译顺序为ViewController+MethodSwizzling.m --&gt; ViewController+MethodSwizzling2.m，load方法的调用顺序也是这样。最新先调用主类的viewWillAppear:方法不必多说，接着调用分类ViewController+MethodSwizzling中的方法互换逻辑，使得第一次方法互换成功。紧接着调用分类ViewController+MethodSwizzling2中的方法互换逻辑，这个不会影响第一次方法互换的逻辑，相当于在第一次的方法互换之后再互换一次。 第一次: ya_viewWillAppear的实现与viewWillAppear的实现互换第二次: ya2_viewWillAppear的实现与ya_viewWillAppear的实现互换，因为viewWillAppear的实现被ya_viewWillAppear代替了。所以主类和各个分类的方法都被清晰地调用了。 问题4：为什么需要class_replaceMethod()函数?原先的方法存在(有实现)，自不必说，使用method_exchangeImplementations()直接交换函数指针即可。那么有个问题，假定原先的方法不存在，那直接使用class_addMethod()函数把swizzledMethod方法的实现“交给了”原先的originalMethod方法，此时原先的originalMethod方法和新的swizzledMethod方法都指向了同一个实现：swizzledMethod方法的实现。进行到这一步足够了，class_addMethod()函数既判断了原先的方法是否实现，倘若未实现又自动把新方法的实现“交给了”它，完全解决了问题，还需要class_replaceMethod()函数做啥? 首先要明确：class_addMethod()的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。“原先的方法没有实现”有两种情况，第一种:该方法是仅仅属于这个类的，父类没有。第二种:该方法是继承自这个类的父类的，父类中有实现，而它自己却没有实现。对于第二种情况，倘若仅仅使用class_addMethod()函数而没有使用class_replaceMethod()函数，会造成“丢失掉原先的父类的实现”。 示例代码: @interface MainObject : NSObject@end@implementation MainObject- (void)a &#123; NSLog(@"super-main");&#125;@end// AObject继承自MainObject@interface AObject : MainObject@end@implementation AObject@end@interface AObject (Object)@end@implementation AObject (Object)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; SEL originalSel = @selector(a); SEL swizzledSel = @selector(b); Method originalMethod = class_getInstanceMethod(self, originalSel); Method swizzledMethod = class_getInstanceMethod(self, swizzledSel); if (class_addMethod(self, originalSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; // 什么也不做 &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)b &#123; NSLog(@"b-method");&#125;@end// 调用AObject *obj = [AObject new];[obj performSelector:@selector(a)];[obj performSelector:@selector(b)]; 很明显，打印了两次”b-method”。 2019-05-29 20:01:19.934449+0800 Aaron[35973:604269] b-method2019-05-29 20:01:19.934591+0800 Aaron[35973:604269] b-method 而如果添加上class_replaceMethod()函数，先给originalSel添加上swizzledMethod的实现，再把父类的实现originalMethod替换到swizzledSel中，这样父类的实现就会得到调用: ///......if (class_addMethod(self, originalSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod(self, swizzledSel, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));&#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod);&#125;///...... 打印： 2019-05-29 20:06:39.298454+0800 Aaron[36191:611275] b-method2019-05-29 20:06:39.298605+0800 Aaron[36191:611275] super-main 因此，当“主类本身没有实现需要替换的方法，而是继承了父类的实现”时，比如一开始的例子viewWillAppear方法，就可以调用到父类的实现，避免出现问题。对于完全“无中生有”的比如aaa方法，用不用class_replaceMethod()都无妨。 问题5：方法交换的标准姿势为什么是load方法配合dispatch_once？常与+ (void)load;方法在一起比较的是+ (void)initialize;方法。为什么是+ (void)load;方法？ + (void)load;是在该类被加载到Runtime时调用的，在手动实现之后，一定会被调用，且正常情况下只会被调用一次，子类也不会多次调用父类的load方法（因为load方法时通过函数指针直接调用，而普通方法是通过消息机制调用。）。 + (void)initialize;是在该类收到第一条消息前被调用，如果不向它发送消息（调用类方法或者实例方法），则该方法不会被调用。如果一个子类没有实现+ (void)initialize;方法，那么父类的该方法会被调用多次。 希望方法交换的逻辑一定会被执行，所以选择了load方法。最根本也最具有说服力的原因是initialize是基于消息机制的，如果在主类的initialize方法中实现了方法交换逻辑，在分类中又实现了initialize方法，由于分类中的方法在元类对象方法列表的前面，所以会造成方法交换逻辑并不会生效。而load方法是通过函数指针直接调用，父类、子类、父类的分类和子类的分类的load方法都会被依次调用，同样的情况，方法交换逻辑却依然会生效。再者，假定在父类的initialize方法中实现了方法交换逻辑，子类会调用父类的initialize方法，如果没有使用dispatch_once，会造成方法交换逻辑多次执行。而load方法，不需要也不应该调用[super load]，总而言之就是，“initialize方法会造成方法交换不具备稳定性”。 为什么是dispatch_once？正常情况下load方法只会被执行一次，但是要考虑手动调用的情况（一般来说不需要手动调用）：[ViewController load];。使用dispatch_once更加完备地保证只执行一次。 六、自定义侧滑手势除了全屏侧滑之外，有些情况下需要自定义侧滑手势，这时可以使用UIScreenEdgePanGestureRecognizer实现。 - (void)viewDidLoad &#123; [super viewDidLoad]; UIView *orangeView = [[UIView alloc] initWithFrame:self.view.bounds]; orangeView.backgroundColor = UIColor.orangeColor; [self.view addSubview:orangeView]; UIScreenEdgePanGestureRecognizer *pan = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePop:)]; pan.edges = UIRectEdgeLeft; [orangeView addGestureRecognizer:pan]; self.orangeView = orangeView;&#125;- (void)handlePop:(UIScreenEdgePanGestureRecognizer *)pan &#123; void (^setOriginX)(UIView *, CGFloat) = ^(UIView *view, CGFloat x) &#123; [UIView animateWithDuration:0.15 animations:^&#123; CGRect frame = view.frame; frame.origin.x = x; view.frame = frame; &#125;]; &#125;; UIView *targetView = pan.view; CGFloat offsetX = [pan translationInView:targetView].x; if (pan.state == UIGestureRecognizerStateChanged) &#123; targetView.center = CGPointMake(targetView.center.x + offsetX, targetView.center.y); [pan setTranslation:CGPointZero inView:targetView.superview]; &#125; else if (pan.state == UIGestureRecognizerStateEnded || pan.state == UIGestureRecognizerStateCancelled) &#123; if (targetView.frame.origin.x / targetView.frame.size.width &gt; 0.3) &#123; setOriginX(targetView, targetView.bounds.size.width); &#125; else &#123; setOriginX(targetView, 0); &#125; &#125;&#125; 七、总结作为FDFullscreenPopGesture的源码阅读文章，实际上重心却不在它这。拜读下来，其实都是些常见的东西：关联属性，方法交换。其实解决问题最重要的，是思路。不然可能自己写了一大堆代码，也不能很好高效地解决问题。 以FDFullscreenPopGesture为引子，又重点回顾了方法交换，作为拓展，回答了引出的许多问题，像实例方法与类方法交换完全是脑洞来的，工作中我还没这么用过😂😂。最后简单介绍了UIScreenEdgePanGestureRecognizer，这个很好使的。 参考资料一个丝滑的全屏滑动返回手势iOS利用Runtime自定义控制器POP手势动画iOS-FDFullscreenPopGesture详解]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源项目：PageMenu]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9APageMenu%2F</url>
    <content type="text"><![CDATA[一个使用Swift写的PageMenu。 一个使用Swift写的PageMenu。没有那么多接口，自己可以根据实际需要扩展。写这个的目的一是为了练手，毕竟工作中使用Swift极少，再一个，PageMenu使用场景挺多的，我遇到过好几次，这次做一个总结。 项目地址:https://github.com/ChenYalun/PageMenu 一、思路MenuStyle: 用于标题的样式配置PageTitleView: 私有的单个标题控件PageTitle: 标题区视图PageContent: 内容区视图PageMenu: 继承自UIViewController的视图控制器，用于连接PageTitle和PageContentUIColor+RGB: 一些对UIColor的拓展，主要是支持RGB的方式设置颜色 二、代码MenuStyleclass MenuStyle: UIView &#123; // 标题之间的间距 var margin: CGFloat = 10 // 默认颜色 var defaultColor = UIColor(r: 0, g: 0, b: 0) // 默认字体 var defaultFont = UIFont.systemFont(ofSize: 17) // 选中态颜色 var selectedColor = UIColor(r: 239, g: 154, b: 64) // 选中态字体 var selectedFont = UIFont.systemFont(ofSize: 18) // 指示条高度, 为0表示隐藏 var lineHeight: CGFloat = 2 // 指示条宽度, 为0表示自适应 var lineWidth: CGFloat = 0 // 指示条颜色, 默认与selectedColor保持一致 var lineColor: UIColor? // 是否开启指示条颜色渐变 var lineColorGradual = true // 指示条圆角 var lineCornerRadius: CGFloat = 2 // 标题区的frame var pageTitleFrame = CGRect(x: 0, y: 20, width: UIScreen.main.bounds.width, height: 25) // 标题区与内容区的间距 var titleContentMargin: CGFloat = 5&#125; PageTitleimport UIKit// 代理protocol PageTitleDelegate : class &#123; func pageTitleDidSelected(pageTitle: PageTitle, pageTitleView: PageTitleView)&#125;// 标题视图组件class PageTitleView: UIView &#123; // 索引 var index: Int = 0 // 标题 var title: String? // 渐变颜色 var color: UIColor? &#123; didSet &#123; label.textColor = color &#125; &#125; // 样式 fileprivate var style: MenuStyle // 选中状态 fileprivate var isSelected: Bool = false &#123; didSet &#123; reloadState() &#125;// 刷新数据 &#125; // 自身宽度 fileprivate var width: CGFloat &#123; return title?.size(withAttributes: [NSAttributedString.Key.font: font]).width ?? 0 &#125; // 字体大小 fileprivate var font: UIFont &#123; return isSelected ? style.selectedFont : style.defaultFont &#125; // 字体颜色 fileprivate var fontColor: UIColor &#123; return isSelected ? style.selectedColor : style.defaultColor &#125; // 点击回调 fileprivate var tapCallBack: ((_ view: PageTitleView) -&gt; Void)? private lazy var label: UILabel = &#123; let label = UILabel() let gesture = UITapGestureRecognizer(target: self, action: #selector(action(_:))) label.addGestureRecognizer(gesture) label.isUserInteractionEnabled = true return label &#125;() init(title: String?, isSelected: Bool, style: MenuStyle) &#123; self.title = title self.isSelected = isSelected self.style = style super.init(frame: CGRect.zero) reloadState() self.addSubview(label) &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError("init(coder:) has not been implemented") &#125; // 动态链接 @objc fileprivate func action(_ tap: UITapGestureRecognizer) &#123; if tapCallBack != nil &#123; tapCallBack!(self) &#125; &#125; // 刷新数据 private func reloadState() &#123; label.text = title label.textColor = fontColor label.font = font label.sizeToFit() &#125;&#125;// 标题视图class PageTitle: UIView &#123; // 代理 weak var delegate: PageTitleDelegate? private var titleList: [String] private lazy var scrollView: UIScrollView = &#123; var scrollView = UIScrollView(frame: bounds) scrollView.showsHorizontalScrollIndicator = false addSubview(scrollView) return scrollView &#125;() // 指示器 private lazy var lineView: UIView = &#123; var lineView = UIView() lineView.backgroundColor = menuStyle.lineColor ?? menuStyle.selectedColor lineView.layer.cornerRadius = menuStyle.lineCornerRadius lineView.layer.masksToBounds = true scrollView.addSubview(lineView) return lineView &#125;() // 样式 private var menuStyle: MenuStyle // 当前选中标题 private var currentSelectedView: PageTitleView? // 标题列表 private var titleViewList = [PageTitleView]() init(frame: CGRect, menuStyle: MenuStyle, titleList: [String]) &#123; self.menuStyle = menuStyle self.titleList = titleList super.init(frame: frame) setupSubViews() &#125; private func setupSubViews() &#123; var totalWidth: CGFloat = 0 // 设置子控件 for (idx, title) in titleList.enumerated() &#123; let view = PageTitleView(title: title as String, isSelected: false, style: menuStyle) view.index = idx titleViewList.append(view) let x = CGFloat(idx + 1) * menuStyle.margin + totalWidth view.frame = CGRect(x: x, y: 0, width: view.width, height: frame.height - menuStyle.lineHeight) totalWidth += view.width scrollView.addSubview(view) view.tapCallBack = &#123; [weak self] view in guard let self = self else &#123; return &#125; self.changeToSelectedIndex(idx: view.index) &#125; &#125; scrollView.contentSize = CGSize(width: totalWidth + CGFloat(titleList.count + 1) * menuStyle.margin, height: 0) // 默认选中的索引 0 changeToSelectedIndex() &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError("init(coder:) has not been implemented") &#125;&#125;// MARK: 切换过程中需要调用的函数extension PageTitle &#123; private func changeToSelectedIndex(idx: Int = 0, progress: CGFloat = 1) &#123; // 索引值越界 if idx &gt; titleViewList.count - 1 || idx &lt; 0 || titleViewList.count &lt;= 0 &#123; return &#125; var fromView, toView: PageTitleView if currentSelectedView == nil &#123; fromView = titleViewList.first! toView = fromView &#125; else &#123; fromView = currentSelectedView! toView = titleViewList[idx] // 同一个标题 if fromView == toView &#123; return &#125; &#125; if menuStyle.lineHeight != 0 &#123; refreshBottomLineFrame(fromView.frame, toView.frame, progress) &#125; if menuStyle.lineColorGradual &#123; refreshTitleViewColor(fromView, toView, progress) &#125; if progress == 1 &#123; refreshTitleViewState(fromView, toView) &#125; &#125; // 设置指示条frame private func refreshBottomLineFrame(_ from: CGRect, _ to: CGRect, _ progress: CGFloat) &#123; var from = from var to = to let lineHeight = menuStyle.lineHeight let lineWidth = menuStyle.lineWidth let y = frame.height - lineHeight let isFixedLineWidth = lineWidth != 0 let fromWidth = isFixedLineWidth ? lineWidth : from.width let toWidth = isFixedLineWidth ? lineWidth : to.width let fromMinX = isFixedLineWidth ? from.midX - lineWidth * 0.5 : from.minX let fromMaxX = isFixedLineWidth ? fromMinX + lineWidth : from.maxX let toMinX = isFixedLineWidth ? to.midX - lineWidth * 0.5 : to.minX let toMaxX = isFixedLineWidth ? toMinX + lineWidth : to.maxX from = CGRect(x: fromMinX, y: y, width: fromWidth, height: lineHeight) to = CGRect(x: toMinX, y: y, width: toWidth, height: lineHeight) let isToLeft = toMinX &lt; fromMinX // 向左 if progress &lt; 0.5 &#123; if isToLeft &#123; // 向左移动 let offsetWidth = (fromMinX - toMinX) * 2 * progress lineView.frame = CGRect(x: fromMinX - offsetWidth, y: y, width: fromMaxX - fromMinX + offsetWidth, height: lineHeight) &#125; else &#123; let offsetWidth = (toMaxX - fromMaxX) * 2 * progress lineView.frame = CGRect(x: fromMinX, y: y, width:from.width + offsetWidth, height: lineHeight) &#125; &#125; else &#123; if isToLeft &#123; // 向左移动 let offsetWidth = (fromMaxX - to.maxX) * (1 - (progress - 0.5) * 2) lineView.frame = CGRect(x: toMinX, y: y, width:to.width + offsetWidth, height: lineHeight) &#125; else &#123; let offsetWidth = (toMinX - fromMinX) * (1 - (progress - 0.5) * 2) lineView.frame = CGRect(x: toMinX - offsetWidth, y: y, width:toMaxX - toMinX + offsetWidth, height: lineHeight) &#125; &#125; &#125; // 刷新标题状态 private func refreshTitleViewState(_ fromView: PageTitleView, _ toView: PageTitleView) &#123; // 更新currentSelectedView currentSelectedView?.isSelected = false toView.isSelected = true currentSelectedView = toView // 设置标题居中 let width = scrollView.bounds.width let contentWidth = scrollView.contentSize.width var offsetX = toView.center.x - width * 0.5 offsetX = max(offsetX, 0) offsetX = min(contentWidth - width, offsetX) if contentWidth &lt;= width &#123; // 保持居中 let viewWidth = CGFloat(titleViewList.last?.frame.maxX ?? 0) - CGFloat(titleViewList.first?.frame.minX ?? 0) offsetX = -(width - viewWidth) * 0.5 + menuStyle.margin &#125; scrollView.setContentOffset(CGPoint(x: offsetX, y: 0), animated: true) if delegate != nil &#123; delegate?.pageTitleDidSelected(pageTitle: self, pageTitleView: toView) &#125; &#125; // 标题颜色渐变 private func refreshTitleViewColor(_ fromView: PageTitleView, _ toView: PageTitleView, _ progress: CGFloat) &#123; let toRGB = UIColor.rgbValue(menuStyle.selectedColor) let fromRGB = UIColor.rgbValue(menuStyle.defaultColor) let deltaRGB = (toRGB.0 - fromRGB.0, toRGB.1 - fromRGB.1, toRGB.2 - fromRGB.2) fromView.color = UIColor(r: toRGB.0 - deltaRGB.0 * progress, g: toRGB.1 - deltaRGB.1 * progress, b: toRGB.2 - deltaRGB.2 * progress) toView.color = UIColor(r: fromRGB.0 + deltaRGB.0 * progress, g: fromRGB.1 + deltaRGB.1 * progress, b: fromRGB.2 + deltaRGB.2 * progress) &#125;&#125;// MARK: PageContentDelegateextension PageTitle : PageContentDelegate &#123; func pageContentDidChange(pageContent: PageContent, targetIndex: Int, progress: CGFloat) &#123; changeToSelectedIndex(idx: targetIndex, progress: progress) &#125;&#125; PageContentimport UIKit// 代理protocol PageContentDelegate : class &#123; func pageContentDidChange(pageContent: PageContent, targetIndex: Int, progress: CGFloat)&#125;class PageContent: UIView &#123; weak var delegate: PageContentDelegate? private var controllerList: [UIViewController] private let identifier = "PageMenu_CollectionView_Identifier" private var currentIndex = 0 private var shouldCallDelegate = false private lazy var collectionView: UICollectionView = &#123; let layout = UICollectionViewFlowLayout() layout.itemSize = bounds.size layout.scrollDirection = .horizontal layout.minimumLineSpacing = 0 layout.minimumInteritemSpacing = 0 var collectionView = UICollectionView(frame: bounds, collectionViewLayout: layout) collectionView.dataSource = self as UICollectionViewDataSource collectionView.delegate = self as UICollectionViewDelegate collectionView.showsHorizontalScrollIndicator = false collectionView.scrollsToTop = false collectionView.isPagingEnabled = true collectionView.bounces = false collectionView.backgroundColor = UIColor.white // 注册cell collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: identifier) addSubview(collectionView) return collectionView &#125;() init(frame: CGRect, controllerList: [UIViewController]) &#123; self.controllerList = controllerList super.init(frame: frame) self.collectionView.reloadData() &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError("init(coder:) has not been implemented") &#125;&#125;// MARK: UICollectionViewDataSourceextension PageContent : UICollectionViewDataSource, UICollectionViewDelegate &#123; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return controllerList.count &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let cell = collectionView.dequeueReusableCell(withReuseIdentifier: identifier, for: indexPath) let view = controllerList[indexPath.row].view! view.frame = cell.bounds cell.contentView.addSubview(view) return cell &#125;&#125;// MARK: UIScrollViewDelegateextension PageContent : UIScrollViewDelegate &#123; func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123; let index = Int(scrollView.contentOffset.x / scrollView.bounds.width) currentIndex = index &#125; func scrollViewWillBeginDragging(_ scrollView: UIScrollView) &#123; shouldCallDelegate = true &#125; func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; if !shouldCallDelegate &#123; return &#125; let width = scrollView.bounds.width let offsetX = scrollView.contentOffset.x - CGFloat(currentIndex) * width let offsetIndex = offsetX &gt; 0 ? 1 : -1 let progress = abs(offsetX) / width if delegate != nil &#123; delegate?.pageContentDidChange(pageContent: self, targetIndex: currentIndex + offsetIndex, progress: progress) &#125; &#125;&#125;// MARK: PageTitleDelegateextension PageContent : PageTitleDelegate &#123; internal func pageTitleDidSelected(pageTitle: PageTitle, pageTitleView: PageTitleView) &#123; shouldCallDelegate = false collectionView.scrollToItem(at: IndexPath(item: pageTitleView.index, section: 0), at: .left, animated: false) currentIndex = pageTitleView.index &#125;&#125; PageMenuimport UIKitclass PageMenu : UIViewController &#123; var pageTitle: PageTitle var pageContent: PageContent var menuStyle: MenuStyle private var controllerList: [UIViewController] init(_ menuStyle: MenuStyle, _ controllerList: [UIViewController]) &#123; var titleList = [String]() for controller in controllerList &#123; titleList.append(controller.title ?? "null") &#125; self.pageTitle = PageTitle(frame: menuStyle.pageTitleFrame, menuStyle: menuStyle, titleList: titleList) self.pageContent = PageContent(frame: CGRect(x: pageTitle.frame.minX, y: pageTitle.frame.maxY + menuStyle.titleContentMargin, width: pageTitle.frame.width, height: UIScreen.main.bounds.height - pageTitle.frame.height), controllerList: controllerList) self.menuStyle = menuStyle self.controllerList = controllerList super.init(nibName: nil, bundle: nil) configureComponent() &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError("init(coder:) has not been implemented") &#125; private func configureComponent() &#123; view.addSubview(pageTitle) view.addSubview(pageContent) for controller in controllerList &#123; addChild(controller) &#125; pageTitle.delegate = pageContent pageContent.delegate = pageTitle &#125;&#125; UIColor+RGBimport Foundationimport UIKitextension UIColor &#123; convenience init(r : CGFloat, g : CGFloat, b : CGFloat) &#123; self.init(red: r / 255.0, green: g / 255.0, blue: b / 255.0, alpha: 1.0) &#125; class func rgbValue(_ color : UIColor) -&gt; (CGFloat, CGFloat, CGFloat) &#123; guard let components = color.cgColor.components else &#123; fatalError("颜色按照RGB设置") &#125; return (components[0] * 255, components[1] * 255, components[2] * 255) &#125;&#125; 三、使用简单配置一下MenuStyle，创建自己的视图控制器，就能直接使用了。 override func viewDidLoad() &#123; super.viewDidLoad() var controllerList = [UIViewController]() let style: MenuStyle = MenuStyle() // 创建style并配置样式 style.margin = 30 style.defaultColor = UIColor(r: 135, g: 135, b: 135) style.selectedColor = UIColor(r: 0, g: 0, b: 0) // 创建控制器 let red = UIViewController() red.view.backgroundColor = UIColor.red red.title = "关注" let blue = UIViewController() blue.view.backgroundColor = UIColor.blue blue.title = "热门" controllerList = [red, blue] // 创建PageMenu let pageMenu = PageMenu(style, controllerList) pageMenu.pageTitle.backgroundColor = UIColor(r: 45, g: 184, b: 105) addChild(pageMenu) view.addSubview(pageMenu.view)&#125; 四、效果微博样式： it之家样式： 五、总结处理起来比较麻烦一点的就是，标题区指示条的frame渐变，要考虑左滑和右滑的情况，还要考虑进度progress的问题。不过还好，仔细想想都能解决的。 再一个，PageTitle和PageContent之间互相通信的方案，我选择的是代理。PageTitle是PageContent的代理，同时，PageContent又是PageTitle的代理。由PageMenu负责连接。]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App界面优化Tips]]></title>
    <url>%2F2019%2F03%2F15%2FApp%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96Tips%2F</url>
    <content type="text"><![CDATA[App界面优化的小Tips。 本来这篇文章只是阅读YYAsyncLayer后的体会，后来一再扩充，变成了App界面优化的小Tips。。。 一、列表视图定高Cell1，复用static NSString * const kWBStatusCellIdentifier = @"kWBStatusCellIdentifier";- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; WBStatusCell *cell = [tableView dequeueReusableCellWithIdentifier:kWBStatusCellIdentifier forIndexPath:indexPath]; [cell setLayout:_layouts[indexPath.row]]; return cell;&#125; 标准化的写法是这样的。dequeueReusableCellWithIdentifier:forIndexPath:方法比dequeueReusableCellWithIdentifier:方法多了“自动创建”。cell的重用ID最好使用静态常量，尽管直接使用@&quot;kWBStatusCellIdentifier&quot;，编译器层面也会做优化，帮我们生成静态常量，但是意义不一样。 cell的种类不要太多，尽量通过hidden subview来区别。 2，设置行高_tableView.rowHeight = 60; 由于是固定行高，直接在配置TableView的懒加载中直接设置rowHeight属性即可。如果使用代理，会使TableView多次询问，增加不必要的调用。- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return 60;&#125; 除此之外，能使用整数的地方就不要使用小数，60要比60.2更好一点，CPU不喜欢小数。不仅仅指rowHeight这个属性，其他视图的width、height等属性，在满足UE要求的情况下，都可以尽可能地采用整数。 3，模型生成采用MVVM，需要字典转模型；去Model化，需要格式化字典；无论怎样，都要把数据转换成视图喜欢的样子，这些操作就可以放到子线程中进行。尤其是遇到DateFormatter、stringWithFormat这些稍微耗性能的方法，该缓存就缓存，该替换就替换。 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 字典转模型 WBTimelineItem *item = [WBTimelineItem modelWithJSON:data]; _statuses = item.statuses; // 主线程刷新 dispatch_async(dispatch_get_main_queue(), ^&#123; [_tableView reloadData]; &#125;);&#125;); 4，subviews操作1，子视图越少，出现问题的可能性也越小。所以在构思的时候，一个视图能解决的问题，没必要多写几个视图。比如需要在同一行展示内容a和内容b，可以考虑只使用一个Label。2，视图的动态创建和销毁也是很heavily的，考虑设置hidden属性来控制显示和隐藏。3，尽量选用轻量级的控件，不需要用户响应的可以换成CALayer，比如CALayer替代UIImageView：- (CALayer *)photoImageViewLayer &#123; if (!_photoImageViewLayer) &#123; _photoImageViewLayer = [[CALayer alloc] init]; _photoImageViewLayer.contentsGravity = @"resizeAspectFill"; _photoImageViewLayer.masksToBounds = YES; &#125; return _photoImageViewLayer;&#125;// 设置[self.photoImageViewLayer yy_setImageWithURL:url placeholder:UIImage.randomColorImage options:options completion:nil]; 但是CALayer不能设置约束，这就需要自己计算frame了。 5，触发离屏渲染离屛渲染需要开辟一块新的缓冲区，在渲染的过程中还会有多次的切换上下文，这些很消耗性能。 如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。 1， layer.cornerRadius + layer.masksToBounds一起设置2， 设置图层阴影layer.shadow3， 设置蒙层layer.mask4， layer.allowsGroupOpacity 设置为YES同时layer.opacity小于1.05， layer.shouldRasterize设置为YES。开启 Rasterization 后，GPU 只合成一次内容，然后复用合成的结果；合成的内容超过100ms没有使用会从缓存里移除，所以对于不连续使用的内容进行光栅化是既没有意义又浪费资源的，在更新内容时还会产生更多的离屏渲染。对于内容不发生变化的视图，进行光栅化会使原本拖后腿的离屏渲染就成为了助力；如果视图内容是动态变化的，使用这个方案有可能让性能变得更糟。不要过度使用，系统限制缓存的大小为 2.5x screen size，过度使用的话也会造成离屏渲染。（一般用在单独的视图上，而不是cell的layer）6， 使用UIBlurEffect 即刻App的优化思路是这样：1，对于图片的圆角，统一采用“precomposite”的策略，也就是不经由容器来做剪切，而是预先使用CoreGraphics为图片裁剪圆角2，对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的layer盖住四个角，从视觉上制造圆角的效果3，对于view的圆形边框，如果没有backgroundColor，可以放心使用cornerRadius来做4，对于所有的阴影，使用shadowPath来规避离屏渲染5，对于特殊形状的view，使用layer mask并打开shouldRasterize来对渲染结果进行缓存6，对于模糊效果，不采用系统提供的UIVisualEffect，而是另外实现模糊效果（CIGaussianBlur），并手动管理渲染结果 6，圆角“cornerRadius和maskToBounds一起设置会触发离屏渲染”，这句话需要讨论一下了： 1，UIView这般设置圆角不会产生离屏渲染。2，iOS9.0之后UIImageView中的png图片这般设置圆角不会触发离屏渲染，但是如果UIImageView的backgroundColor不是clearColor或者不是nil，则会触发离屏渲染。 上面两条是我搜了很多资料发现的，亲自验证了一下，在iOS13上第一条是真的。第二条试着不设置backgroundColor果然也没有出现离屏渲染。但是，是不是从iOS9开始的，我没有真机也没法做判断，而且也没有找到官方的说明。 下面是之前的UIImageView设置圆角的处理方式直接使用layer.mask来达到圆角效果同样会触发离屏渲染，对于网络图片的圆角处理通常是先下载后圆角化。下载逻辑（以我喜欢的YYWebImage为例）：NSString *radiusKey = [url.absoluteString stringByAppendingString:@"radiusCache"];UIImage *radiusImage = [YYImageCache.sharedCache getImageForKey:radiusKey];if (radiusImage) &#123; self.photoImageView.image = radiusImage;&#125; else &#123; [YYWebImageManager.sharedManager requestImageWithURL:url options:YYWebImageOptionShowNetworkActivity progress:nil transform:nil completion:^(UIImage *image, NSURL *url, YYWebImageFromType from, YYWebImageStage stage, NSError * error) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (!error &amp;&amp; image) &#123; [YYImageCache.sharedCache setImage:radiusImage imageData:nil forKey:radiusKey withType:YYImageCacheTypeAll]; self.photoImageView.image = image.radiusImage; &#125; &#125;); &#125;];&#125; 图片下载完毕后做圆角处理并保存，但是有几个问题需要思考：1，这张图片的圆角半径在业务上是固定的吗，如果不固定（比如需要10px、20px两种）那就需要存储多份了；2，这张图片的展示效果是否只有圆角一种，是否同时存在有方图和圆角图两种形式？需要保留原图吗； 这个是使用Core Graphics创建圆角图片的不会触发离屏渲染的示例，可以子线程绘制：- (UIImage *)radiusImage &#123; CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height); CGFloat radius = 100.f; // 这个度量是图片的，而不是imageView的 UIGraphicsBeginImageContextWithOptions(rect.size, false, UIScreen.mainScreen.scale); CGContextRef context = UIGraphicsGetCurrentContext(); UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, radius)]; CGContextAddPath(context, path.CGPath); CGContextClip(context); [self drawInRect:rect]; CGContextDrawPath(context, kCGPathFillStroke); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 7，阴影假如需要这么设置阴影效果：button.layer.shadowColor = UIColor.blackColor.CGColor;button.layer.shadowOpacity = 0.5;button.layer.shadowRadius = 10;button.layer.shadowOffset = CGSizeMake(10, 10); 只需要再加上一句话就能避免离屏渲染了：button.layer.shadowPath = [UIBezierPath bezierPathWithRect:button.bounds].CGPath; 但是有个小问题，如果这个具有阴影效果的视图需要做frame动画，那它的shadow效果是不会改变的，这还得再想办法解决：显式指定shadowPath的动画效果。 不定高cell不定高的cell需要计算cell的高度。有两种方式：一是自己在后台根据模型数据配置子视图的布局，手动计算，并把高度存储到对应的模型中；二是借助自动布局，保证子视图“撑满”cell，自动更新cell的高度。 如果对性能要求不高，或者开发周期短，可以直接使用Auto Layout，再配合FDTemplateLayoutCell的高度缓存机制，可以说已经很方便了。不然只能自己计算并做缓存处理。 二、异步渲染TableView和CollectionView的优化也可以借助异步渲染，YYAsyncLayer描述了异步渲染的核心原理。 接口@interface YYAsyncLayer : CALayer// Default is YES.@property BOOL displaysAsynchronously;@end@protocol YYAsyncLayerDelegate &lt;NSObject&gt;@required- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask;@end// 将要绘制、正在绘制、绘制完毕 对应的block@interface YYAsyncLayerDisplayTask : NSObject@property (nullable, nonatomic, copy) void (^willDisplay)(CALayer *layer);@property (nullable, nonatomic, copy) void (^display)(CGContextRef context, CGSize size, BOOL(^isCancelled)(void));@property (nullable, nonatomic, copy) void (^didDisplay)(CALayer *layer, BOOL finished);@end 使用视图在初始化过程之前调用UIView类方法layerClass，并且使用返回的类来创建layer对象。通过创建UIView的子类，重写layerClass类函数可以改变创建图层时的默认的CALayer类。在自定义视图对象中，返回一个YYAsyncLayerDisplayTask，这个task承担着绘制的任务。 异步绘制文字@interface YALabel : UIView &lt;YYAsyncLayerDelegate&gt;@property (nonatomic, copy) NSAttributedString *attributedString;@end@implementation YALabel- (void)setAttributedString:(NSAttributedString *)attributedString &#123; _attributedString = attributedString; // YYTransaction let you perform a selector once before current runloop sleep. [[YYTransaction transactionWithTarget:self selector:@selector(setTextNeedsDisplay)] commit];&#125;- (void)layoutSubviews &#123; [super layoutSubviews]; [[YYTransaction transactionWithTarget:self selector:@selector(setTextNeedsDisplay)] commit];&#125;- (void)setTextNeedsDisplay &#123; [self.layer setNeedsDisplay];&#125;+ (Class)layerClass &#123; return YYAsyncLayer.class;&#125;- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask &#123; YYAsyncLayerDisplayTask *task = [YYAsyncLayerDisplayTask new]; task.display = ^(CGContextRef context, CGSize size, BOOL (^isCancelled)(void)) &#123; if (isCancelled() || self.attributedString.string.length &lt;= 0) return; // 修复绘制文字会颠倒 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; CGContextTranslateCTM(context, 0, self.bounds.size.height); CGContextScaleCTM(context, 1.0, -1.0); &#125;]; NSAttributedString *str = self.attributedString; [str enumerateAttribute:NSFontAttributeName inRange:NSMakeRange(0, str.length) options:NSAttributedStringEnumerationLongestEffectiveRangeNotRequired usingBlock:^(UIFont *font, NSRange range, BOOL *stop) &#123; // 根据字体设置pointSize CGContextSetTextPosition(context, 0, font.pointSize); &#125;]; // 绘制 CTLineRef line = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)str); CTLineDraw(line, context); CFRelease(line); &#125;; return task;&#125;@end 使用的时候很简单了，设置一个AttributedString即可：YALabel *label = [YALabel new];NSAttributedString *str = [[NSAttributedString alloc] initWithString:@"😀😁🤣😂Label的异步绘制" attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:15]&#125;];label.attributedString = str;label.backgroundColor = UIColor.orangeColor;label.frame = CGRectMake(100, 100, 200, 50);[self.view addSubview:label]; 这里的newAsyncDisplayTask比较简单，只绘制了单行文本，如果真的要应用到项目中，可以利用CoreText更加完善些，加上自动换行，自适应size，图文混排等功能。 有前辈写了一个IM的Demo，里面有用到异步绘制：https://github.com/Yuzeyang/GCAsyncDisplayDemo，读一读还是很棒的。 源码阅读源码不是很多，就几个文件，但是跟作者的其他框架一样，代码特别优秀。 YYSentinel这是一个线程安全的计数器，内部维护了一个实例变量。如何做到线程安全? 主要是依赖于原子函数OSAtomicIncrement32()。 如果我们想要初始化一个共享的数据结构，然后自动增加某个变量值来标识初始化操作完成，则我们必须使用OSAtomicIncrement32Barrier来确保数据结构的存储操作在变量自动增加前完成。 使用这个类的目的： 标记某个操作是否完成，也即判断或者标记异步渲染操作的完成情况 #import &lt;libkern/OSAtomic.h&gt;// 线程安全的计数器@interface YYSentinel : NSObject@property (readonly) int32_t value;- (int32_t)increase;@end@implementation YYSentinel &#123; int32_t _value;&#125;- (int32_t)value &#123; return _value;&#125;- (int32_t)increase &#123; return OSAtomicIncrement32(&amp;_value);&#125;@end YYTransaction只有两个方法接口。方法一： 包装target和selector并生成一个YYTransaction对象。方法二： commit这个对象。包装成YYTransaction对象的方法不用多说，其内部使用实例变量引用着传递的参数。最关键的是commit方法。It will perform the selector on the target once before main runloop’s current loop sleep. If the same transaction (same target and same selector) has already commit to runloop in this loop, this method do nothing. 也就是说在Runloop每次休眠之前只调用一次target的selector方法。 commit方法内部使用transactionSet集合添加了这个YYTransaction对象。作者给Runloop添加了一个observer，在 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit这两种状态下会调用指定的YYRunLoopObserverCallBack()函数。这个函数的作用很简单：逐个遍历transactionSet集合中的所有元素，使其target调用对应的selector。 YYTransaction重写了- (NSUInteger)hash方法和- (BOOL)isEqual:(id)object方法来确定“对象相等”。这保证了Set集合中的元素唯一性。 @interface YYTransaction : NSObject+ (YYTransaction *)transactionWithTarget:(id)target selector:(SEL)selector;- (void)commit;@end@interface YYTransaction()@property (nonatomic, strong) id target;@property (nonatomic, assign) SEL selector;@endstatic NSMutableSet *transactionSet = nil;// 逐个遍历transactionSet中的所有元素，使其target调用对应的selectorstatic void YYRunLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123; if (transactionSet.count == 0) return; NSSet *currentSet = transactionSet; transactionSet = [NSMutableSet new]; [currentSet enumerateObjectsUsingBlock:^(YYTransaction *transaction, BOOL *stop) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks" [transaction.target performSelector:transaction.selector];#pragma clang diagnostic pop &#125;];&#125;// 当Runloop处于kCFRunLoopBeforeWaiting或者kCFRunLoopExit的状态的时候调用YYRunLoopObserverCallBack()函数static void YYTransactionSetup() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; transactionSet = [NSMutableSet new]; CFRunLoopRef runloop = CFRunLoopGetMain(); CFRunLoopObserverRef observer; observer = CFRunLoopObserverCreate(CFAllocatorGetDefault(), kCFRunLoopBeforeWaiting | kCFRunLoopExit, true, // repeat 0xFFFFFF, // after CATransaction(2000000) YYRunLoopObserverCallBack, NULL); CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes); CFRelease(observer); &#125;);&#125;@implementation YYTransaction+ (YYTransaction *)transactionWithTarget:(id)target selector:(SEL)selector&#123; if (!target || !selector) return nil; YYTransaction *t = [YYTransaction new]; t.target = target; t.selector = selector; return t;&#125;// 把生成的YYTransaction对象放入transactionSet中- (void)commit &#123; if (!_target || !_selector) return; YYTransactionSetup(); [transactionSet addObject:self];&#125;// isEqual: 是通过hash方法来判等的- (NSUInteger)hash &#123; long v1 = (long)((void *)_selector); long v2 = (long)_target; return v1 ^ v2;&#125;// 只要_target和_selector都一致，就说明'YYTransaction'是同一个- (BOOL)isEqual:(id)object &#123; if (self == object) return YES; if (![object isMemberOfClass:self.class]) return NO; YYTransaction *other = object; return other.selector == _selector &amp;&amp; other.target == _target;&#125;@end YYAsyncLayer最后是YYAsyncLayer的实现，最核心的逻辑就在这里了。我一年之前就曾经读过这块源码，当时有好多疑惑，现在再来看，有的疑惑已经解开了，有的还没有，在这记录一下。 1，子线程的处理异步，自然要放到子线程。主队列对应的是主线程，4个不同优先级的全局队列并不对应4个子线程。毅然放在全局队列不太可取，可能会出现App在同一时刻存在几十个线程同时运行、创建、销毁的情况。“当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。”。使用串行队列又无法充分利用多核CPU的资源。作者在YYAsyncLayer中的思路是：创建和 CPU 数量相同的串行queue（最多16个），放到一个数组中，每次从数组中随机获取其中的一个queue。/// Global display queue, used for content rendering.static dispatch_queue_t YYAsyncLayerGetDisplayQueue() &#123;#define MAX_QUEUE_COUNT 16 static int queueCount; static dispatch_queue_t queues[MAX_QUEUE_COUNT]; static dispatch_once_t onceToken; static int32_t counter = 0; dispatch_once(&amp;onceToken, ^&#123; // 获取运行该进程的系统的处于激活状态的处理器数量, iPhone 6s 是2个 queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount; queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount; for (NSUInteger i = 0; i &lt; queueCount; i++) &#123; dispatch_queue_attr_t attr = // QOS_CLASS_USER_INITIATED 用户发起并等待的优先级 dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0); // 创建串行队列 queues[i] = dispatch_queue_create("com.ibireme.yykit.render", attr); &#125; &#125;); // 大量使用 OSAtomicIncrement32,由于该函数对某个值进行自增计算,而且是线程安全的,所以被用来作为绘制时的标记位(哨兵).异步绘制的关键在于每次调用 setNeedDisplay 时都会将哨兵变量自增,在 display 方法中,根据这个哨兵变量来确定是否继续绘制还是停止绘制.一致则继续绘制, 不一致则停止绘制 int32_t cur = OSAtomicIncrement32(&amp;counter); // counter自增一, 并取出该值, if (cur &lt; 0) cur = -cur; // 啥时候会出现?? counter取INT_MAX的时候出现 return queues[(cur) % queueCount]; // 取余#undef MAX_QUEUE_COUNT&#125; 单纯就子线程绘制这个问题而言，思考一下，既然会出现“同一时刻存在几十个线程同时运行、创建、销毁”的情况，那如果直接操作线程呢，直接创建三五个NSThread对象，让它们处理App中的所有异步渲染操作。如果这样的话，就需要对这三五个NSThread对象进行线程保活，保证它们永远存在。再者只能通过performSelector:onThread:进行方法调用（或者再做一个block方式的封装）。最后也是最重要的是，没办法利用设备多核的优势。单核中的多线程实际上是每个时间片上只有一个线程在运行，而多核实际上是真的多线程，每一个时间片每个核都有一个线程在执行。dispatch_async是多核级别编程框架调度函数，这才真正决定了为啥要使用GCD。 2，异步绘制开关控制// 重写修改CALayer或其子类属性的默认值，key为属性名称，如果没有该属性则返回nil。+ (id)defaultValueForKey:(NSString *)key &#123; if ([key isEqualToString:@"displaysAsynchronously"]) &#123; return @(YES); // 仅仅针对displaysAsynchronously这个属性修改 &#125; else &#123; return [super defaultValueForKey:key]; &#125;&#125;- (instancetype)init &#123; self = [super init]; // 设置屏幕缩放比例 static CGFloat scale; // global static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; scale = [UIScreen mainScreen].scale; &#125;); self.contentsScale = scale; // 计数器, 控制多线程访问 _sentinel = [YYSentinel new]; // 默认是YES _displaysAsynchronously = YES; return self;&#125; 通过displaysAsynchronously来控制是否开启异步渲染。但是这里有个问题想不通，YYAsyncLayer的init方法中已经初始化_displaysAsynchronously的值为YES了，但是作者又重写defaultValueForKey方法并在其中再次设置displaysAsynchronously属性为YES。这两个方式的效果一样呀，会不会多此一举了呢？ 3，绘制时机- (void)dealloc &#123; // layer销毁的时候, 计数器加1, 表示原先的绘制需要取消 [_sentinel increase];&#125;- (void)setNeedsDisplay &#123; // 被标记需要重新绘制, 则取消上次的异步调用 [self _cancelAsyncDisplay]; [super setNeedsDisplay];&#125;// Reload the content of this layer.// Subclasses can override this method and use it to set the layer’s contents property directly. You might do this if your custom layer subclass handles layer updates differently.- (void)display &#123; // 这个赋值是因为这样吗?? // Assigning a value to this property causes the layer to use your image rather than create a separate backing store. super.contents = super.contents; [self _displayAsync:_displaysAsynchronously];&#125;- (void)_cancelAsyncDisplay &#123; // increase增加1, 与目前的不一致了, 表示目前的渲染已取消 [_sentinel increase];&#125; 在实际的绘制逻辑中，是通过判断计数器_sentinel的值来确定是否取消绘制：YYSentinel *sentinel = _sentinel;int32_t value = sentinel.value;BOOL (^isCancelled)(void) = ^BOOL() &#123; // 值相等, 说明正在绘制没有取消, 否则说明已经取消啦 return value != sentinel.value;&#125;; 反过来，只需要把计数器的值自增（[_sentinel increase]）就可以表示目前的绘制操作取消了。在Layer销毁的时候（dealloc）和被标记需要重新绘制的时候（setNeedsDisplay）应该取消原先的绘制操作。 按照苹果的说明，CALayer的子类可以重写display方法并在其中直接设置contents。YYAsyncLayer便在其中做了异步绘制操作。这里的super.contents = super.contents;一句话确实当然没看懂，后来发现也有小伙伴跟我一样没弄明白，然后查阅资料发现了苹果的解释：Assigning a value to this property causes the layer to use your image rather than create a separate backing store. 4，绘制操作最后便是绘制的操作了，写了很详细的注释：// 核心方法- (void)_displayAsync:(BOOL)async &#123; // 强引用代理, 避免释放 __strong id&lt;YYAsyncLayerDelegate&gt; delegate = (id)self.delegate; // 获取一个Display Task YYAsyncLayerDisplayTask *task = [delegate newAsyncDisplayTask]; if (!task.display) &#123; // 没有需要绘制的内容, 设置contents为空 if (task.willDisplay) task.willDisplay(self); self.contents = nil; if (task.didDisplay) task.didDisplay(self, YES); return; &#125; if (async) &#123; // 异步绘制 if (task.willDisplay) task.willDisplay(self); YYSentinel *sentinel = _sentinel; int32_t value = sentinel.value; BOOL (^isCancelled)(void) = ^BOOL() &#123; // 值相等, 说明正在绘制没有取消, 否则说明已经取消啦 return value != sentinel.value; &#125;; CGSize size = self.bounds.size; BOOL opaque = self.opaque; CGFloat scale = self.contentsScale; // 获取背景色 CGColorRef backgroundColor = (opaque &amp;&amp; self.backgroundColor) ? CGColorRetain(self.backgroundColor) : NULL; if (size.width &lt; 1 || size.height &lt; 1) &#123; // 宽或者高小于1的情况 // 获取图片再释放掉, 为啥要多此一举? // 因为赋值给contents的就是一个CGImageRef, 如果直接self.contents = nil;会造成这个image在当前线程(主线程)释放。作者手动把这个image取出来的目的就是把'release'操作放在YYAsyncLayerGetReleaseQueue()这个队列中 CGImageRef image = (__bridge_retained CGImageRef)(self.contents); self.contents = nil; if (image) &#123; dispatch_async(YYAsyncLayerGetReleaseQueue(), ^&#123; CFRelease(image); &#125;); &#125; if (task.didDisplay) task.didDisplay(self, YES); CGColorRelease(backgroundColor); return; &#125; // 从这里开始进入子线程 dispatch_async(YYAsyncLayerGetDisplayQueue(), ^&#123; // 进入子线程后, 第1次取消绘制判断 if (isCancelled()) &#123; CGColorRelease(backgroundColor); return; &#125; // 开启图形上下文 UIGraphicsBeginImageContextWithOptions(size, opaque, scale); CGContextRef context = UIGraphicsGetCurrentContext(); if (opaque) &#123; // UIGraphicsPushContext:压栈当前的绘制对象, 生成新的绘制图层。UIKit的绘制必须在当前的上下文中绘制，而UIGraphicsPushContext可以将当前的参数context转化为可以UIKit绘制的上下文，进行绘制图片。 // CGContextSaveGState:压栈当前的绘制状态 // 这里是为了不"污染"原先的context内容, 保存状态后绘制新的内容 CGContextSaveGState(context); &#123; // 没有背景色或者 透明度小于1, 使用白色填充 if (!backgroundColor || CGColorGetAlpha(backgroundColor) &lt; 1) &#123; CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); CGContextAddRect(context, CGRectMake(0, 0, size.width * scale, size.height * scale)); CGContextFillPath(context); &#125; // 这里使用backgroundColor填充 if (backgroundColor) &#123; CGContextSetFillColorWithColor(context, backgroundColor); CGContextAddRect(context, CGRectMake(0, 0, size.width * scale, size.height * scale)); CGContextFillPath(context); &#125; &#125; CGContextRestoreGState(context); CGColorRelease(backgroundColor); &#125; task.display(context, size, isCancelled); // display完毕后, 第2次取消绘制判断 if (isCancelled()) &#123; // 如果确定已经取消绘制了, 关闭图形上下文 UIGraphicsEndImageContext(); dispatch_async(dispatch_get_main_queue(), ^&#123; if (task.didDisplay) task.didDisplay(self, NO); &#125;); return; &#125; // 从当前上下文中获取生成的新内容 UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); // 从上下文中获取图片后, 第3次取消绘制判断 if (isCancelled()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (task.didDisplay) task.didDisplay(self, NO); &#125;); return; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; // 转到主线程对contents赋值，第4次取消绘制判断 if (isCancelled()) &#123; if (task.didDisplay) task.didDisplay(self, NO); &#125; else &#123; // 在这里对contents赋值 self.contents = (__bridge id)(image.CGImage); if (task.didDisplay) task.didDisplay(self, YES); &#125; &#125;); &#125;); &#125; else &#123; // 非异步绘制 // 不需要进行线程安全判断了 [_sentinel increase]; // 下面的代码都是和异步绘制相同的套路 if (task.willDisplay) task.willDisplay(self); UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, self.contentsScale); CGContextRef context = UIGraphicsGetCurrentContext(); if (self.opaque) &#123; CGSize size = self.bounds.size; size.width *= self.contentsScale; size.height *= self.contentsScale; CGContextSaveGState(context); &#123; if (!self.backgroundColor || CGColorGetAlpha(self.backgroundColor) &lt; 1) &#123; CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height)); CGContextFillPath(context); &#125; if (self.backgroundColor) &#123; CGContextSetFillColorWithColor(context, self.backgroundColor); CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height)); CGContextFillPath(context); &#125; &#125; CGContextRestoreGState(context); &#125; task.display(context, self.bounds.size, ^&#123;return NO;&#125;); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); self.contents = (__bridge id)(image.CGImage); if (task.didDisplay) task.didDisplay(self, YES); &#125;&#125; 看起来貌似很多，实际的绘制原理三行代码可以说清楚： // 1，从当前图形上下文中获取ImageUIImage *image = UIGraphicsGetImageFromCurrentImageContext();// 2，关闭图形上下文UIGraphicsEndImageContext();// 3，将image赋值给layer的contents属性self.contents = (__bridge id)(image.CGImage); 在这之外更多的是 是否取消绘制的判断、没有背景色或者透明度小于1的处理、size极小值的处理等等。 当然还有那个巧妙的子线程异步释放对象的逻辑，记得也见过好多次了：CGImageRef image = (__bridge_retained CGImageRef)(self.contents);self.contents = nil;if (image) &#123; dispatch_async(YYAsyncLayerGetReleaseQueue(), ^&#123; CFRelease(image); &#125;);&#125; 平时的业务开发中我们也可以这么用，比如：// 含有大量元素的数组NSMutableArray *array = self.itemArray;self.itemArray = nil;dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; array = nil; // 子线程释放&#125;); 三、小结《iOS 保持界面流畅的技巧》这篇文章想必很多人都有人阅读过，也都能从中受益。这里回顾一下ibireme大神的微博Demo性能优化技巧：1，预排版这里是指不定高cell的预排版，本文也已经提过，frame布局，可以子线程手动计算并把layout数据缓存在模型中，autolayout布局，可以借助FDTemplateLayoutCell做高度缓存。2，预渲染作者举了一个圆角图片预先裁剪并做缓存处理来避免离屏渲染的例子，也正如上文所说，layer.cornerRadius + layer.masksToBounds一起设置在新版本系统上已经不会触发离屏渲染（大多数人说是iOS9，我还没有确认），但是这个思路可以举一反三，很多可以提前的工作没必要等到cell要展示了才开始做。3，异步绘制+全局并发控制 借助YYDispatchQueuePool把App内所有异步操作按优先级不同放入了全局的 serial queue 中执行，尽量避免了过多线程导致的性能问题。 借助YYAsyncLayer和CoreText实现富文本的异步绘制（当然也可以直接使用功能更强大的YYText，作者把路都给铺好了😂）。4，异步图片加载大多时候，只是显示简单的单张图片，可以直接使用UIView.layer.contents，而不需要使用UIImageView。当然，SDWebImage和YYWebImage把很多工作都做好了。5，不需要触摸事件的UIView换成CALayer可以这么做，但是CALayer没法设置约束了，如果使用自动布局就很蛋疼了。6，多个视觉元素合成一张图也是一种思路，甚至也一定条件下可以把cell的全部内容合成一张图片，但是可能性比较小，需要根据业务来走。以微博为例，“来自iPhone”、会员图标、话题、转发微博原作者昵称、微博内容的链接这些元素都需要响应点击事件，根本不可能用一种图片代替。百度的feed流，很多新闻的样式是相同的，而且不像微博需要处理很多子元素的点击事件，很多情况下只需要处理cell的点击事件就可以了，这才有合成一张图片的可能性。 过早的优化是万恶之源，所有的tips都只是建议，需要具体问题具体分析。很多前辈给我们提供了诸多便利的工具，对于我们，平时踏踏实实写代码，少写bug，不写crash，这才是最重要的。 参考资料：《iOS 保持界面流畅的技巧》《提升UITableView性能-复杂页面的优化》《iOS 阴影，圆角，避免离屏渲染》《UITableView 性能优化》]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSNotificationCenter探索]]></title>
    <url>%2F2019%2F01%2F28%2FNSNotificationCenter%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[2019年10月14日 更新源码 探究NSNotificationCenter的实现并尝试自实现。 一、同步通知接口NSNotification并不复杂，封装了name、object以及userInfo，使用指定构造器初始化即可。@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;@property (readonly, copy) NSNotificationName name;@property (nullable, readonly, retain) id object;@property (nullable, readonly, copy) NSDictionary *userInfo;- (instancetype)initWithName:(NSNotificationName)name object:(nullable id)object userInfo:(nullable NSDictionary *)userInfo;- (nullable instancetype)initWithCoder:(NSCoder *)coder;@end@interface NSNotification (NSNotificationCreation)+ (instancetype)notificationWithName:(NSNotificationName)aName object:(nullable id)anObject;+ (instancetype)notificationWithName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;@end NSNotificationCenter则给我们提供了添加通知接收者、发送通知的接口。NSNotificationName就是NSString *，defaultCenter是单例。@interface NSNotificationCenter : NSObject &#123; @package void *_impl; void *_callback; void *_pad[11];&#125;@property (class, readonly, strong) NSNotificationCenter *defaultCenter;- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;- (void)postNotification:(NSNotification *)notification;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;- (void)removeObserver:(id)observer;- (void)removeObserver:(id)observer name:(nullable NSNotificationName)aName object:(nullable id)anObject;- (id &lt;NSObject&gt;)addObserverForName:(nullable NSNotificationName)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block; // The return value is retained by the system, and should be held onto by the caller in order to remove the observer with removeObserver: later, to stop observation.@end 添加observer- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject; 最常用的就是这个方法，指定observer、selector、name以及object即可。它做了什么呢？苹果官方文档解释如下： Adds an entry to the notification center’s dispatch table with an observer and a notification selector, and an optional notification name and sender.Parameters observer: Object registering as an observer. aSelector: Selector that specifies the message the receiver sends observer to notify it of the notification posting. The method specified by aSelector must have one and only one argument (an instance of NSNotification). aName: The name of the notification for which to register the observer; that is, only notifications with this name are delivered to the observer.If you pass nil, the notification center doesn’t use a notification’s name to decide whether to deliver it to the observer. anObject: The object whose notifications the observer wants to receive; that is, only notifications sent by this sender are delivered to the observer.If you pass nil, the notification center doesn’t use a notification’s sender to decide whether to deliver it to the observer. If your app targets iOS 9.0 and later or macOS 10.11 and later, you don’t need to unregister an observer in its dealloc method. Otherwise, you should call removeObserver:name:object: before observer or any object passed to this method is deallocated 简单解释就是，把必需的observer、selector和可选的name、object注册到通知中心。这个selector有且只有一个参数，参数是NSNotification对象。若指定了通知的name，则observer必须匹配相同的name通知中心才会把消息分发给它，同样，若指定了通知的object，则observer必须匹配相同的object通知中心才会把消息分发给它。在iOS9.0或者macOS 10.11之后，咱们不必要在observer的dealloc方法中取消注册了（现在基本都要求最低是iOS9了）。 再看看坊间GNU的解释： Registers observer to receive notifications with the name notificationName and/or containing object (one or both of these two must be non-nil; nil acts like a wildcard). When a notification of name name containing object is posted, observer receives a selector message with this notification as the argument. The notification center waits for the observer to finish processing the message, then informs the next registree matching the notification, and after all of this is done, control returns to the poster of the notification. Therefore the processing in the selector implementation should be short. The notification center does not retain observer or object. Therefore, you should always send removeObserver: or removeObserver:name:object: to the notification center before releasing these objects. As a convenience, when built with garbage collection, you do not need to remove any garbage collected observer as the system will do it implicitly. NB. For MacOS-X compatibility, adding an observer multiple times will register it to receive multiple copies of any matching notification, however removing an observer will remove all of the multiple registrations. 我们得到的重要信息是： 通知中心会等待所有符合条件的observer把通知消息处理完毕之后才会return，也即发送通知是同步的。这要求我们处理通知消息的逻辑应该“简短”、不会长时间阻塞。 通知中心并不增加observer和object的引用计数，建议我们适时removeObserver。 注册完全一致的observer信息（含name、object、selector）多次，回调也是有多次的，而只移除一次完全一致的observer信息，却会把所有的observer信息都移除掉。 对于第三条这么理解，注册3次，回调也是有三次；而移除一次，所有的该通知都被移除了：[NSNotificationCenter.defaultCenter addObserver:self selector:@selector(dealWithNoti:) name:name object:obj];[NSNotificationCenter.defaultCenter addObserver:self selector:@selector(dealWithNoti:) name:name object:obj];[NSNotificationCenter.defaultCenter addObserver:self selector:@selector(dealWithNoti:) name:name object:obj];[NSNotificationCenter.defaultCenter removeObserver:self name:name object:obj]; 源码逻辑是这样的：- (void)addObserver:(id)observer selector:(SEL)selector name:(NSString *)name object:(id)object &#123; Observation *list; Observation *o; NSIMapTable m; NSIMapNode n; // 加锁 lockNCTable(_table); // 根据observer和selector获取Observation o = obsNew(_table, selector, observer); if (name) &#123; // 根据name在named表中搜索对应的NSIMapNode n = NSIMapNodeForKey(_table-&gt;named, (NSIMapKey)(id)name); if (n == 0) &#123; // 没有在named表中找到 // 优先在_table的缓存中查找, 找不到则创建 m = mapNew(_table); // 将name转换为不可变的name name = [name copyWithZone:NSDefaultMallocZone()]; // 把name作为key, 将新创建的m(NSIMapTable)设置到named表中 NSIMapAddPair(_table-&gt;named, (NSIMapKey)(id)name, (NSIMapVal)(void *)m); NS_CONSUMED(name) &#125; else &#123; // 在named表中找到了, 取出NSIMapNode对应的value m = (NSIMapTable)n-&gt;value.ptr; &#125; // object作为key, 取出其在m表中对应的NSIMapNode n = NSIMapNodeForSimpleKey(m, (NSIMapKey)object); if (n == 0) &#123; o-&gt;next = -1; // m表中取不到object对应的值, 把Observation直接存到m表中 NSIMapAddPair(m, (NSIMapKey)object, (NSIMapVal)o); &#125; else &#123; // object作为key, 取出其在m表中对应的NSIMapNode, 获取node中的链表 list = (Observation *)n-&gt;value.ptr; // 把Observation追加到链表的最前面 o-&gt;next = list-&gt;next; list-&gt;next = o; &#125; &#125; else if (object) &#123; // name不存在, 则从nameless表中搜索对应的NSIMapNode n = NSIMapNodeForSimpleKey(_table-&gt;nameless, (NSIMapKey)object); // 同样的逻辑, 把Observation追加到链表的最前面 if (n == 0) &#123; o-&gt;next = ENDOBS; NSIMapAddPair(_table-&gt;nameless, (NSIMapKey)object, (NSIMapVal)o); &#125; else &#123; list = (Observation *)n-&gt;value.ptr; o-&gt;next = list-&gt;next; list-&gt;next = o; &#125; &#125; else &#123; // name和object都为空, 把Observation追加到wildcard表的最前面 o-&gt;next = _table-&gt;wildcard; _table-&gt;wildcard = o; &#125; // 解锁 unlockNCTable(_table);&#125; named表的结构大致如此： 而nameless表则更简单，object作为key，observer数组作为value。 还有一种是以block的形式添加观察者：- (id)addObserverForName:(NSString *)name object:(id)object queue:(NSOperationQueue *)queue usingBlock:(NSNotificationBlock)block 不需要设置selector，还能方便地在block中执行。 - (id)addObserverForName:(NSString *)name object:(id)object queue:(NSOperationQueue *)queue usingBlock:(NSNotificationBlock)block &#123; NSNotificationObserver *observer = [[NSNotificationObserver alloc] initWithQueue:queue block:block]; [self addObserver:observer selector:@selector(didReceiveNotification:) name:name object:object]; return observer;&#125; 从源码来看，这个方法实际上也是调用了addObserver:selector:name:object方法。observer没有变，但是把selector替换成了didReceiveNotification:，它的实现是这样的： - (void)didReceiveNotification: (NSNotification *)notif &#123; if (_queue != nil) &#123; NSNotificationBlockOperation *op = [[NSNotificationBlockOperation alloc] initWithNotification:notif block:_block]; [_queue addOperation:op]; &#125; else&#123; CALL_BLOCK(_block, notif); &#125;&#125; didReceiveNotification:方法处理了Queue的逻辑。如果Queue不存在，则直接调用block。如果Queue是存在的，继承自NSOperation的NSNotificationBlockOperation封装了需要回调的block和回传的NSNotification，并在main方法中调用了这个block。最后，这个operation被添加到指定的Queue中执行。 发送通知- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo; 发送通知最终是调用这个方法。- (void)postNotificationName:(NSString *)name object:(id)object userInfo:(NSDictionary *)info &#123; NSNotification *notification; notification = (id)NSAllocateObject(concrete, 0, NSDefaultMallocZone()); notification-&gt;_name = [name copyWithZone: [self zone]]; notification-&gt;_object = [object retain]; notification-&gt;_info = [info retain]; [self _postAndRelease: notification];&#125; 关键的是_postAndRelease:的实现：- (void)_postAndRelease:(NSNotification *)notification &#123; Observation *o; unsigned count; NSString *name = [notification name]; id object; GSIMapNode n; GSIMapTable m; GSIArrayItem i[64]; GSIArray_t b; GSIArray a = &amp;b; // 获取object object = [notification object]; GSIArrayInitWithZoneAndStaticCapacity(a, _zone, 64, i); lockNCTable(_table); // 获取没有指定name也没有指定object的所有observer for (o = _table-&gt;wildcard = purgeCollected(WILDCARD); o != ENDOBS; o = o-&gt;next) &#123; GSIArrayAddItem(a, (GSIArrayItem)o); &#125; // 获取指定object但是没有指定name的所有observer if (object) &#123; n = GSIMapNodeForSimpleKey(_table-&gt;nameless, (GSIMapKey)object); if (n != 0) &#123; o = ((Observation *)n-&gt;value.ext) while (o != (Observation *)-1) &#123; GSIArrayAddItem(a, (GSIArrayItem)o); o = o-&gt;next; &#125; &#125; &#125; // 获取指定name而且object也与通知要求的object相匹配的所有observer if (name) &#123; n = GSIMapNodeForKey(_table-&gt;named, (GSIMapKey)((id)name)); if (n) &#123; m = (GSIMapTable)n-&gt;value.ptr; &#125; else &#123; m = 0; &#125; if (m != 0) &#123; // object为空 n = GSIMapNodeForSimpleKey(m, (GSIMapKey)object); if (n != 0) &#123; o = ((Observation *)n-&gt;value.ext) while (o != (Observation *)-1) &#123; GSIArrayAddItem(a, (GSIArrayItem)o); o = o-&gt;next; &#125; &#125; // object不为空, 且匹配 if (object != nil) &#123; n = GSIMapNodeForSimpleKey(m, (GSIMapKey)nil); if (n != 0) &#123; o = ((Observation *)n-&gt;value.ext) while (o != (Observation *)-1) &#123; GSIArrayAddItem(a, (GSIArrayItem)o); o = o-&gt;next; &#125; &#125; &#125; &#125; &#125; // 解锁 unlockNCTable(TABLE); // 遍历数组a, 逐个发送通知 count = GSIArrayCount(a); while (count-- &gt; 0) &#123; o = GSIArrayItemAtIndex(a, count).ext; if (o-&gt;next != 0) &#123; [o-&gt;observer performSelector:o-&gt;selector withObject:notification]; &#125; &#125; // 置空数组a lockNCTable(_table); GSIArrayEmpty(a); unlockNCTable(_table); // release通知对象 RELEASE(notification);&#125; 关键在于从表中获取符合要求的Observation：在wildcard表中获取匿名且没有指定object的Observation；在nameless表中获取匹配object但是匿名的Observation；在named表中获取object为空的Observation和object匹配的Observation。把这些Observation添加到一个数组中，遍历，逐个调用selector。 那么，移除通知自然也是根据name、object、observer，找到匹配的Observation对象，从相应的表中移除，不再赘述。 二、异步通知- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle coalesceMask:(NSNotificationCoalescing)coalesceMask forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask; 通过NSNotificationQueue可以实现异步通知。NSNotificationCoalescing提供了聚合选项，不聚合、根据name聚合以及根据发送者聚合，也即如果在队列中已有该种通知，如果满足选项，则不会进入队列，只保留第一个通知。NSPostingStyle则可以设置通知发送的时机，立即同步发送、尽可能快地发送，以及在Runloop空闲时发送。 场景如下：NSPostWhenIdle：比如当用户正在输入文字，需要在某个控件上实时展示文字的长度的时候，可以用到这个选项。NSPostNow：实时发送通知，但是与同步通知相比，关键在于聚合选项：队列中已有满足选项的通知时，是否只保留一个。NSPostASAP：多个通知进入到缓冲区后，利用聚合选项，只留下一个，并尽可能快地发送通知。 - (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle coalesceMask:(NSUInteger)coalesceMask forModes:(NSArray *)modes &#123; if (modes == nil) modes = defaultMode; // 默认模式 if (coalesceMask != NSNotificationNoCoalescing) &#123; // 需要聚合, 则先把队列中的相应的notification移除 [self dequeueNotificationsMatching:notification coalesceMask:coalesceMask]; &#125; switch (postingStyle) &#123; // 同步发送 case NSPostNow: &#123; NSString *mode = [[NSRunLoop currentRunLoop] currentMode]; // 要求当前Runloop的mode需要匹配, 不然无效 if (mode == nil || [modes indexOfObject:mode] != NSNotFound) &#123; [_center postNotification: notification]; &#125; &#125; break; // 尽可能早发送(as soon as possible) case NSPostASAP: add_to_queue(_asapQueue, notification, modes, _zone); break; // 在Runloop空闲时发送 case NSPostWhenIdle: add_to_queue(_idleQueue, notification, modes, _zone); break; &#125;&#125; 从入口方法来看，关键在于add_to_queue()函数，根据NSPostingStyle选项，把通知添加到_asapQueue队列或者_idleQueue队列。 static void add_to_queue(NSNotificationQueueList *queue, NSNotification *notification, NSArray *modes, NSZone *_zone) &#123; NSNotificationQueueRegistration *item; item = NSZoneCalloc(_zone, 1, sizeof(NSNotificationQueueRegistration)); item-&gt;notification = RETAIN(notification); item-&gt;name = [notification name]; item-&gt;object = [notification object]; item-&gt;modes = [modes copyWithZone: [modes zone]]; item-&gt;next = NULL; item-&gt;prev = queue-&gt;tail; queue-&gt;tail = item; if (item-&gt;prev) item-&gt;prev-&gt;next = item; if (!queue-&gt;head) queue-&gt;head = item;&#125; 可以看到，把notification和modes封装成NSNotificationQueueRegistration，并把它插入到双向链表queue的尾部。 以NSPostWhenIdle选项为例，在Runloop的acceptInputForMode:beforeDate:方法中找到了通知的发送痕迹：GSPrivateNotifyIdle(mode)。 void GSPrivateNotifyIdle(NSString *mode) &#123; NotificationQueueList *item; for (item = currentList(); item; item = item-&gt;next) &#123; if (item-&gt;queue) &#123; notify(item-&gt;queue-&gt;_center, item-&gt;queue-&gt;_idleQueue, mode, item-&gt;queue-&gt;_zone); &#125; &#125;&#125; 接下来就很明朗了，notify()的逻辑是这样的： 从双向链表list中取出所有的结点对象NSNotificationQueueRegistration，并把它放到一个数组中。 遍历该数组，逐个从list中移除：remove_from_queue(list, item, zone);。 遍历该数组，逐个发送通知[NSNotificationCenter.defaultCenter postNotification:notification];，而postNotification:方法本质上还是调用同步通知中的_postAndRelease:方法。 什么时候发送，交由Runloop处理。 三、子线程通知子线程通知苹果给出了标准的解决方案：利用NSMachPort。假定在A线程发送通知，需要在B线程处理通知，那么B线程中注册NSMachPort，A线程中使用此port发送通知，则B线程就能收到消息并进行处理。 简单概述实现思路就是：维护一个NSNotification数组，接收到通知时，如果通知分发的线程与期望的线程（处理通知的线程）不一致，则把这个通知添加到NSNotification数组中，并利用NSMachPort发送一个“信号”到期望的线程（也就是创建NSMachPort对象的线程）中，在期望的线程中收到信号后，把通知从NSNotification数组中移除，并处理。 比如，需要在主线程发送通知，而在子线程接收并处理通知，结合苹果给出的示例代码，可以这么做： // 通知名称const NSNotificationName YADemoNotification = @"YADemoNotification";@interface YAThreadedNotificationHandler: NSObject &lt;NSMachPortDelegate&gt;@property (nonatomic, strong) NSMutableArray *notifications;@property (nonatomic, strong) NSThread *notificationThread;@property (nonatomic, strong) NSLock *notificationLock;@property (nonatomic, strong) NSMachPort *notificationPort;- (void)setUpThreadingSupport;- (void)processNotification:(NSNotification *)notification;// Mach port delegate- (void)handleMachMessage:(void *)msg;@end@implementation YAThreadedNotificationHandler- (instancetype)init &#123; if (self = [super init]) &#123; [self setUpThreadingSupport]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:YADemoNotification object:nil]; &#125; return self;&#125;- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;#pragma mark - Private methods- (void)setUpThreadingSupport &#123; if (self.notifications) return; self.notifications = [[NSMutableArray alloc] init]; self.notificationLock = [[NSLock alloc] init]; // 配置期望线程（当前线程） self.notificationThread = [NSThread currentThread]; // 配置端口消息处理的线程（当前线程） self.notificationPort = [[NSMachPort alloc] init]; [self.notificationPort setDelegate:self]; [[NSRunLoop currentRunLoop] addPort:self.notificationPort forMode:NSRunLoopCommonModes];&#125;// 端口代理- (void)handleMachMessage:(void *)msg &#123; [self.notificationLock lock]; while ([self.notifications count]) &#123; NSNotification *notification = [self.notifications objectAtIndex:0]; [self.notifications removeObjectAtIndex:0]; [self.notificationLock unlock]; [self processNotification:notification]; [self.notificationLock lock]; &#125;; [self.notificationLock unlock];&#125;// 处理通知- (void)processNotification:(NSNotification *)notification &#123; if ([NSThread currentThread] != self.notificationThread) &#123; // Forward the notification to the correct thread. [self.notificationLock lock]; [self.notifications addObject:notification]; [self.notificationLock unlock]; [self.notificationPort sendBeforeDate:[NSDate date] components:nil from:nil reserved:0]; &#125; else &#123; // Process the notification here; NSLog(@"处理通知在%@线程", NSThread.currentThread); &#125;&#125;@end 在控制器中，这样发送通知：@interface ViewController ()@property (nonatomic, strong) NSThread *thread;@property (nonatomic, strong) YAThreadedNotificationHandler *notificationHandler;@end@implementation ViewController- (void)startThread &#123; self.notificationHandler = [YAThreadedNotificationHandler new]; // 主线程发送通知 dispatch_async(dispatch_get_main_queue(), ^&#123; [NSNotificationCenter.defaultCenter postNotificationName:YADemoNotification object:nil]; &#125;); // 子线程手动开启Runloop [NSRunLoop.currentRunLoop run];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(startThread) object:nil]; [self.thread start]; &#125; 四、自实现有几个弱引用容器在日常工作中没有用过，但是又特别想亲手实践一番。偶尔看到一篇文章，说是自己实现了系统中通知中心的功能，出于好奇，自己也尝试一番，便在这里模仿了同步通知的实现。 主要原理就是创建一个字典observerMap，notification name作为key，NSMapTable作为value。在这个NSMapTable中，object作为key，用于存放observer的NSHashSet容器作为value。 接口文件接口与系统保持一致。 #import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGINtypedef NSString *YANotificationName NS_EXTENSIBLE_STRING_ENUM;@interface YANotificationCenter : NSObject@property (class, readonly, strong) YANotificationCenter *defaultCenter;- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable YANotificationName)aName object:(nullable id)anObject;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;- (void)removeObserver:(id)observer;- (void)removeObserver:(id)observer name:(nullable YANotificationName)aName object:(nullable id)anObject;@endNS_ASSUME_NONNULL_END Checklist 不增加observer和object的引用计数 支持携带参数信息userInfo 可以不指定object 添加观察者时指定object，post通知时只有相同的object才会有效 observer为nil，发送通知时没有作用 指定线程发送通知，则在指定线程调用 没有及时移除通知，observer销毁之后继续发送通知不会产生异常(从iOS 9开始，即使不移除观察者对象，程序也不会出现异常。) 支持多个observer监听同一个通知 如果notificationName为nil，object有值，则接收所有指定为object的通知 如果notificationName为nil，且object也为nil，则接收系统内所有通知(也即YANotificationCenter发出的所有通知) 移除所有通知后，相关方法不再调用 移除指定通知后，相关方法不再调用 同步处理通知消息 多次添加observer，发送通知时多次调用 支持异步发布通知（NotificationQueue） 功能测试1. 不对observer和object强引用2. 可以携带参数userInfo3. 添加观察者时object为nil，post通知时object有值，依然有效(表示不限于指定的object)[YANotificationCenter.defaultCenter addObserver:a selector:@selector(print3:) name:@"Noti_1" object:nil];[YANotificationCenter.defaultCenter postNotificationName:@"Noti_1" object:self userInfo:@&#123;@"key": @"value"&#125;];4. 添加观察者时指定object，post通知时相同的object，有效，不同的object，无效// 有效[YANotificationCenter.defaultCenter addObserver:a selector:@selector(print3:) name:@"Noti_2" object:self];[YANotificationCenter.defaultCenter postNotificationName:@"Noti_2" object:self userInfo:@&#123;@"key": @"value"&#125;];// 无效[YANotificationCenter.defaultCenter addObserver:a selector:@selector(print3:) name:@"Noti_3" object:self];[YANotificationCenter.defaultCenter postNotificationName:@"Noti_3" object:a userInfo:@&#123;@"key": @"value"&#125;];5. 可以添加n次observer，发送通知时对应调用n次(不支持)[YANotificationCenter.defaultCenter addObserver:a selector:@selector(print3:) name:@"Noti_4" object:nil];[YANotificationCenter.defaultCenter addObserver:a selector:@selector(print3:) name:@"Noti_4" object:nil];[YANotificationCenter.defaultCenter postNotificationName:@"Noti_4" object:nil userInfo:@&#123;@"key": @"value"&#125;];6. 未添加observer，发送通知时没有作用[YANotificationCenter.defaultCenter postNotificationName:@"Noti_5" object:nil userInfo:@&#123;@"key": @"value"&#125;];7. 指定线程发送通知，则在指定线程调用// print方法是在发送通知的线程中调用的[YANotificationCenter.defaultCenter addObserver:self selector:@selector(print) name:@"Noti_6" object:nil];dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;NSLog(@"当前线程:%@",[NSThread currentThread]);[YANotificationCenter.defaultCenter postNotificationName:@"Noti_6" object:nil userInfo:@&#123;@"key": @"value"&#125;];&#125;);8. 没有在observer的dealloc方法中移除通知，observer销毁之后继续发送通知，无影响(从iOS 9开始，即使不移除观察者对象，程序也不会出现异常。)[YANotificationCenter.defaultCenter addObserver:a selector:@selector(print) name:@"Noti_7" object:nil];// a对象销毁之后继续发送通知[YANotificationCenter.defaultCenter postNotificationName:@"Noti_7" object:nil userInfo:@&#123;@"key": @"value"&#125;];9. 多个observer监听同一个通知，所有observer的相关方法均得到调用[YANotificationCenter.defaultCenter addObserver:a selector:@selector(print) name:@"Noti_8" object:nil];[YANotificationCenter.defaultCenter addObserver:b selector:@selector(print) name:@"Noti_8" object:nil];[YANotificationCenter.defaultCenter addObserver:c selector:@selector(print) name:@"Noti_8" object:nil];[YANotificationCenter.defaultCenter postNotificationName:@"Noti_8" object:nil userInfo:@&#123;@"key": @"value"&#125;];10. 如果notificationName为nil，object有值，则接收所有指定为object的通知// 接收self发送的所有通知[YANotificationCenter.defaultCenter addObserver:self selector:@selector(print1) name:nil object:self];[YANotificationCenter.defaultCenter postNotificationName:@"Noti_9" object:self userInfo:@&#123;@"key": @"value"&#125;];11. 如果notificationName为nil，且object也为nil，则接收系统内所有通知(也即YANotificationCenter发出的所有通知)// 接收系统内所有通知，也即任意一个通知都会触发[YANotificationCenter.defaultCenter addObserver:self selector:@selector(print1) name:nil object:nil];12. 移除所有通知后，相关方法不再调用[YANotificationCenter.defaultCenter addObserver:self selector:@selector(print1) name:@"Noti_10" object:nil];// 移除所有通知后，再次发送通知没有效果[YANotificationCenter.defaultCenter removeObserver:self];[YANotificationCenter.defaultCenter postNotificationName:@"Noti_10" object:nil userInfo:@&#123;@"key": @"value"&#125;];13. 移除指定通知后，相关方法不再调用[YANotificationCenter.defaultCenter addObserver:self selector:@selector(print1) name:@"Noti_11" object:nil];// 移除指定通知后，再次发送通知没有效果[YANotificationCenter.defaultCenter removeObserver:self name:@"Noti_11" object:nil];[YANotificationCenter.defaultCenter postNotificationName:@"Noti_11" object:nil userInfo:@&#123;@"key": @"value"&#125;]; 实现文件#import "YANotificationCenter.h"typedef NS_ENUM(NSUInteger, YANotificationSenderType) &#123; YANotificationSenderTypeObject = 0, // 指定对象 YANotificationSenderTypeObserver = 1, // 观察者&#125;;@interface YANotificationCenter()// Recorder observer.@property (nonatomic, strong) NSMutableDictionary *observerMap;// Recorder all the selector.@property (nonatomic, strong) NSMutableDictionary *selectorMap;@end@implementation YANotificationCenter- (instancetype)init &#123; if (self = [super init]) &#123; _observerMap = [NSMutableDictionary dictionary]; _selectorMap = [NSMutableDictionary dictionary]; &#125; return self;&#125;+ (YANotificationCenter *)defaultCenter &#123; static YANotificationCenter *center = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; center = [[self alloc] init]; &#125;); return center;&#125;- (void)addObserver:(id)observer selector:(SEL)aSelector name:(YANotificationName)aName object:(id)anObject &#123; if (!observer) return; if (!aName) aName = (id)kCFNull; NSMapTable *map = [self.observerMap objectForKey:aName]; if (!map) map = [NSMapTable weakToStrongObjectsMapTable]; if (anObject) &#123; NSHashTable *set = [map objectForKey:observer]; if (!set || ![set isKindOfClass:[NSHashTable class]]) set = [NSHashTable weakObjectsHashTable]; [set addObject:anObject]; [map setObject:set forKey:observer]; &#125; else &#123; [map setObject:(id)kCFNull forKey:observer]; &#125; [self.observerMap setObject:map forKey:aName]; NSString *key = generateKey(observer, anObject, aName); [self.selectorMap setObject:NSStringFromSelector(aSelector) forKey:key];&#125;- (void)postNotificationName:(NSNotificationName)aName object:(id)anObject &#123; [self postNotificationName:aName object:anObject userInfo:nil];&#125;- (void)postNotificationName:(YANotificationName)aName object:(id)anObject userInfo:(NSDictionary *)aUserInfo &#123; // When the notification name is nil. &#123; NSMapTable *map = [self.observerMap objectForKey:(id)kCFNull]; id key = nil; NSEnumerator *enumerator = map.keyEnumerator; while (key = [enumerator nextObject]) &#123; NSHashTable *set = [map objectForKey:key]; NSArray *selectorList = nil; if (set == (id)kCFNull) &#123; selectorList = self.selectorMap.allValues; &#125; else if ([set containsObject:anObject]) &#123; selectorList = selectorListForSender(self, anObject, YANotificationSenderTypeObject); &#125; if (!selectorList) break; [selectorList enumerateObjectsUsingBlock:^(NSString *selector, NSUInteger idx, BOOL * _Nonnull stop) &#123; SEL sel = NSSelectorFromString(selector); ((void (*)(id, SEL, id))[key methodForSelector:sel])(self, sel, aUserInfo); &#125;]; &#125; &#125; // Normal process. NSMapTable *map = [self.observerMap objectForKey:aName]; id key = nil; NSEnumerator *enumerator = map.keyEnumerator; if (anObject) &#123; while (key = [enumerator nextObject]) &#123; NSHashTable *set = [map objectForKey:key]; if (set == (id)kCFNull || [set containsObject:anObject]) &#123; NSString *selector = [self.selectorMap objectForKey:generateKey(key, anObject, aName)]; if (!selector) return; SEL sel = NSSelectorFromString(selector); ((void (*)(id, SEL, id))[key methodForSelector:sel])(self, sel, aUserInfo); &#125; &#125; &#125; else &#123; while (key = [enumerator nextObject]) &#123; NSString *selector = [self.selectorMap objectForKey:generateKey(key, anObject, aName)]; if (!selector) return; SEL sel = NSSelectorFromString(selector); ((void (*)(id, SEL, id))[key methodForSelector:sel])(self, sel, aUserInfo); &#125; &#125;&#125;- (void)removeObserver:(id)observer &#123; [self.observerMap.allValues enumerateObjectsUsingBlock:^(NSMapTable *map, NSUInteger idx, BOOL * _Nonnull stop) &#123; [map removeObjectForKey:observer]; &#125;]; [self.selectorMap removeObjectsForKeys:selectorListForSender(self, observer, YANotificationSenderTypeObserver)];&#125;- (void)removeObserver:(id)observer name:(YANotificationName)aName object:(id)anObject &#123; NSMapTable *map = [self.observerMap objectForKey:aName]; // Remove selector. [self.selectorMap removeObjectForKey:generateKey(observer, anObject, aName)]; if (anObject) &#123; NSHashTable *set = [map objectForKey:observer]; [set removeObject:anObject]; if (set.count == 0) [map removeObjectForKey:observer]; &#125; else &#123; [map removeObjectForKey:observer]; &#125; if (map.count == 0) [self.observerMap removeObjectForKey:aName];&#125;static inline NSString *generateKey(id observer, id anObject, YANotificationName name) &#123; NSString *key = nil; if (anObject) &#123; key = [NSString stringWithFormat:@"%p_%@_%p" ,anObject, name, observer]; &#125; else &#123; key = [NSString stringWithFormat:@"%@_%p", name, observer]; &#125; return key;&#125;static inline NSArray *selectorListForSender(YANotificationCenter *self, id object, YANotificationSenderType type) &#123; NSString *p = [NSString stringWithFormat:@"%p", object]; NSPredicate *predicate = nil; if (type == YANotificationSenderTypeObject) &#123; predicate = [NSPredicate predicateWithFormat:@"SELF BEGINSWITH %@", p]; &#125; else &#123; predicate = [NSPredicate predicateWithFormat:@"SELF ENDSWITH %@", p]; &#125; NSArray *keys = [self.selectorMap.allKeys filteredArrayUsingPredicate:predicate]; NSArray *result = [self.selectorMap objectsForKeys:keys notFoundMarker:(id)kCFNull]; return result.count == 0 ? nil : result;&#125;@end 五、小结 同步通知内部实现是维护了两层映射：第一层name作为key，第二层object作为key，最终把observer保存在数组中。iOS9之后对observer是安全的弱引用。 异步通知内部维护了一个双向链表以满足“聚合（NSNotificationCoalescing）”选项，依赖Runloop的迭代以满足“时机（NSPostingStyle）”选项。 使用子线程通知需要依靠NSMachPort的通信。 日常开发中同步通知能满足绝大多数场景，异步通知的场景有限，苹果给出的几个例子还是很经典的。子线程通知也是常见的，比如子线程发通知主线程处理通知，但是我看大家都习惯直接利用GCD从子线程环境切换到主线程，再发出通知。 参考资料：《Notification与多线程》《NSNotification原理理解》《深入思考NSNotification》《深入理解iOS NSNotification》)]]></content>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weak Associated Object]]></title>
    <url>%2F2019%2F01%2F20%2FWeak%20Associated%20Object%2F</url>
    <content type="text"><![CDATA[给分类添加weak属性的几种方法。 众所周知，通过Runtime的关联属性来给分类添加“属性”，这里的属性缺少了严格意义上的成员变量，而且是自己手动实现了getter方法和setter方法。几种关联策略中并没有与weak效果相媲美的选项，OBJC_ASSOCIATION_ASSIGN策略与weak效果的主要区别在于weak自动能将指向已销毁对象的指针指为nil。 危险的ASSIGN单纯使用ASSIGN容易诱发坏内存访问，原因无需多言。 @interface NSObject(Default)@property (nonatomic) id strongObj;@end@implementation NSObject(Default)- (void)setStrongObj:(id)strongObj &#123; objc_setAssociatedObject(self, @selector(strongObj), strongObj, OBJC_ASSOCIATION_ASSIGN);&#125;- (id)strongObj &#123; return objc_getAssociatedObject(self, @selector(strongObj));&#125;@end// 示例如下&#123; NSObject *obj = [NSObject new]; NSObject *main = [NSObject new]; main.strongObj = obj; obj = nil; NSLog(@"%@", main.strongObj); // Crash&#125; 极简方案这是一种极好的给分类添加weak属性的实现方式。看到这种实现方式后极为兴奋，实在太简洁、巧妙了。__weak本身就会把指针指向nil，那直接利用就是了。使用OBJC_ASSOCIATION_COPY关联策略将block copy到堆上，利用block把持有的weak对象返回，如果对象不存在了，返回的便是空值。 @interface NSObject(Weak)@property (nonatomic) id object;@end@implementation NSObject(Weak)- (void)setObject:(id)object &#123; id __weak weakObject = object; id (^block)(void) = ^&#123; return weakObject; &#125;; objc_setAssociatedObject(self, @selector(object), block, OBJC_ASSOCIATION_COPY);&#125;- (id)object &#123; id (^block)(void) = objc_getAssociatedObject(self, @selector(object)); return (block ? block() : nil);&#125;@end 包装类这种方式是通过包装一个对象实现的。要求设置的关联对象是YAWeakObject类型。当这个对象销毁的时候调用deallocBlock，而在这个block中把关联的对象重新设置为nil(不可使用objc_removeAssociatedObjects直接移除关联对象)，这样访问这个关联对象的时候得到的就是nil值了。 这种方式会污染weak属性，要求被设置为weak属性的对象必须是某种类型，不是太好。当然根据这种思路，还可以进一步封装，最终的落脚点无非是提供新的方法接口替代原生的运行时方法(见参考文章)。@interface NSObject(WeakClass)@property (nonatomic) YAWeakObject *weakObject;@end@implementation NSObject(WeakClass)- (YAWeakObject *)weakObject &#123; return objc_getAssociatedObject(self, @selector(weakObject));&#125;- (void)setWeakObject:(YAWeakObject *)weakObject &#123; objc_setAssociatedObject(self, @selector(weakObject), weakObject, OBJC_ASSOCIATION_ASSIGN); typeof(self) slf = self; void (^block)(void) = ^&#123; typeof(slf) self = slf; objc_setAssociatedObject(self, @selector(weakObject), nil, OBJC_ASSOCIATION_ASSIGN); &#125;; [weakObject setDeallocBlock:block];&#125;@end 使用容器实际上使用支持弱引用的容器如NSHashTable、NSMapTable、NSPointerArray都是可以实现的。原理很简单，使用容器持有关联的对象，当该对象不存在时，容器自身便有自动移除已销毁对象的特性，这样就实现了weak属性。 NSMapTable 可以持有键和值的弱引用，当键或者值当中的一个被释放时，整个这一项就会被移除掉。NSHashTable 可以持有成员的弱引用。NSPointerArray 可以持有成员的弱引用，当成员不存在时自动把所在index置为NULL。 这种做法需要创建一个容器，相对比较麻烦。 @interface NSObject(WeakContainer)@property (nonatomic) id weakObj;@end@implementation NSObject(WeakContainer)static NSPointerArray *gPointerArray = nil;- (id)weakObj &#123; if (!gPointerArray) return nil; // Removes NULL values from the receiver.(sometimes doesn't work as documented) [gPointerArray compact]; for (id obj in gPointerArray) &#123; if (obj != NULL) &#123; return objc_getAssociatedObject(self, @selector(weakObj)); &#125; &#125; gPointerArray = nil; return nil;&#125;- (void)setWeakObj:(id)weakObj &#123; if (weakObj) &#123; if (!gPointerArray) gPointerArray = [NSPointerArray weakObjectsPointerArray]; [gPointerArray addPointer:(__bridge void *)weakObj]; objc_setAssociatedObject(self, @selector(weakObj), weakObj, OBJC_ASSOCIATION_ASSIGN); &#125;&#125;@end 小结其实看到作者的思路（极简方案）确实挺有感触的，完全利用现有的__weak关键字配合block，没有冗余的包装，方法精简且巧妙。去年在想这个问题的时候，也是考虑很多，在《Runtime基础》一文中描述了我当时的思路，基本上也是从把指针置为nil这个角度出发，或者派生子类重写dealloc，或者使用弱引用容器，都不够巧妙。 很多时候，好的思路，灵光一现的想法，真的无比重要。就像bang哥在写JSPatch时： 当时继续苦苦寻找解决方案，若按 JS 语法，这是唯一的方法，但若不按 JS 语法呢？突然脑洞开了下，CoffieScript/JSX 都可以用 JS 实现一个解释器实现自己的语法，我也可以通过类似的方式做到，再进一步想到其实我想要的效果很简单，就是调用一个不存在方法时，能转发到一个指定函数去执行，就能解决一切问题了，这其实可以用简单的字符串替换，把 JS 脚本里的方法调用都替换掉。 还有一个东西在作者的文章里看到，比较有意思，这里提一下。 Weak Singleton + (instancetype)sharedWeakInstance &#123; static __weak id weakObj = nil; id strongObj = weakObj; @synchronized (self) &#123; if (!strongObj) &#123; strongObj = [[self class] new]; weakObj = strongObj; &#125; &#125; return strongObj;&#125; 应用场景:不需要保存公共的信息、用户状态等，符合“用完就走”。如果类似LoginManager管理登录状态，继承自 AFHttpSessionManager的NetworkManager单例，App单例ClientManager等则不适用这种方式。 参考资料：如何使用 Runtime 给现有的类添加 weak 属性iOS给类别添加weak属性iOS weak 关键字漫谈]]></content>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「KVOController」的封装]]></title>
    <url>%2F2019%2F01%2F12%2F%E3%80%8CKVOController%E3%80%8D%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[学习KVO的封装。 KVOController源码只有700行左右，读一遍下来还是比较通畅的。这里做一个记录。 一、使用使用起来极其简便。 // 设置所观察的对象及其keyPath[self.KVOController observe:self.myButton keyPath:@"backgroundColor" options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) &#123; NSLog(@"%@", change[NSKeyValueChangeNewKey]);&#125;]; 这里的self.KVOController可以自己创建，也可以使用默认，因为KVOController是懒加载的。 一般情况下是像上面这样使用的，还有一种情况，不需要强持有被观察者的时候： [self.KVOControllerNonRetaining observe:self.myButton keyPath:@"backgroundColor" options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) &#123; NSLog(@"%@", change[NSKeyValueChangeNewKey]);&#125;]; 只需使用self.KVOControllerNonRetaining即可不增加被观察者self.myButton的引用计数。 二、分类@interface NSObject (FBKVOController)@property (nonatomic, strong) FBKVOController *KVOController;@property (nonatomic, strong) FBKVOController *KVOControllerNonRetaining;@end 要实现以上使用的方式，是给 NSObject 分类添加两个属性:KVOController和KVOControllerNonRetaining。这个比较简单，使用Runtime 的关联属性即可。值得一提的是作者在 getter 方法里使用了懒加载，只有当使用到KVOController或者KVOControllerNonRetaining的时候，才会创建。当然，也可以选择自行创建。 - (FBKVOController *)KVOController &#123; id controller = objc_getAssociatedObject(self, NSObjectKVOControllerKey); // 懒加载KVOController, 用到时才会创建 if (nil == controller) &#123; controller = [FBKVOController controllerWithObserver:self]; self.KVOController = controller; &#125; return controller;&#125;- (FBKVOController *)KVOControllerNonRetaining &#123; id controller = objc_getAssociatedObject(self, NSObjectKVOControllerNonRetainingKey); if (nil == controller) &#123; controller = [[FBKVOController alloc] initWithObserver:self retainObserved:NO]; self.KVOControllerNonRetaining = controller; &#125; return controller;&#125; 以上两个 getter 方法分别对应强引用被观察者和弱引用被观察者。 三、接口由此可以看到，核心功能的实现依赖于FBKVOController。 // 强引用+ (instancetype)controllerWithObserver:(nullable id)observer;- (instancetype)initWithObserver:(nullable id)observer;// 指定构造器- (instancetype)initWithObserver:(nullable id)observer retainObserved:(BOOL)retainObserved NS_DESIGNATED_INITIALIZER;- (instancetype)init NS_UNAVAILABLE;+ (instancetype)new NS_UNAVAILABLE; 构造方法里主要暴露了两种初始化方式，其中通过initWithObserver这个方法可以设置参数retainObserved以表明是否需要强引用被观察者。 @property (nullable, nonatomic, weak, readonly) id observer; 只有一个只读属性，给出被观察者对象。 - (void)observe:(nullable id)object keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(FBKVONotificationBlock)block;- (void)observe:(nullable id)object keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options action:(SEL)action;- (void)observe:(nullable id)object keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context; 作者给出了回调的三个选项：block回调，选择子回调以及 KVO 默认方法回调。可以在添加被观察者的时候自行选择。 - (void)observe:(nullable id)object keyPaths:(NSArray&lt;NSString *&gt; *)keyPaths options:(NSKeyValueObservingOptions)options block:(FBKVONotificationBlock)block;- (void)observe:(nullable id)object keyPaths:(NSArray&lt;NSString *&gt; *)keyPaths options:(NSKeyValueObservingOptions)options action:(SEL)action;- (void)observe:(nullable id)object keyPaths:(NSArray&lt;NSString *&gt; *)keyPaths options:(NSKeyValueObservingOptions)options context:(nullable void *)context; 考虑到不一定只观察一个对象的一个成员变量，因此作者提供了keyPaths选项，可以同时观察一个对象的多个keyPath：传入一个字符串数组即可。 - (void)unobserve:(nullable id)object keyPath:(NSString *)keyPath;- (void)unobserve:(nullable id)object;- (void)unobserveAll; 移除监听提供三种接口：移除某个对象某个keyPath 的监听，移除对某个对象的监听，取消观察者对所有对象的所有监听。 四、FBKVOController实现构造器@implementation FBKVOController &#123; NSMapTable&lt;id, NSMutableSet&lt;_FBKVOInfo *&gt; *&gt; *_objectInfosMap; pthread_mutex_t _lock;&#125; FBKVOController主要维护了一个NSMapTable。key 是所观察的对象，value 是NSMutableSet类型的集合(内部元素是_FBKVOInfo类型)。维护一个NSMapTable的原因是：便于观察一个对象的多个keyPath，这个对象作为 key，这许多个keyPath封装成一个个_FBKVOInfo存入NSMutableSet中。另外一个成员变量_lock主要是保证线程安全。 - (instancetype)initWithObserver:(nullable id)observer retainObserved:(BOOL)retainObserved &#123; self = [super init]; if (nil != self) &#123; _observer = observer; // 根据是否retainObserved，选择NSMapTable的"强-强"或者"弱-强" NSPointerFunctionsOptions keyOptions = retainObserved ? NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPointerPersonality : NSPointerFunctionsWeakMemory|NSPointerFunctionsObjectPointerPersonality; _objectInfosMap = [[NSMapTable alloc] initWithKeyOptions:keyOptions valueOptions:NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPersonality capacity:0]; pthread_mutex_init(&amp;_lock, NULL); &#125; return self;&#125; FBKVOController所有暴露的构造方法接口都指向了上面的那个实现。这个方法只做了三件事: 1，初始化线程锁_lock，2，根据retainObserved参数创建不同类型的NSMapTable，是选择”强-强”还是选择”弱-强”。3，属性observer赋值。 由此可见，FBKVOController本身对被观察者observer是弱引用的(有一个 weak 属性的observer成员变量)，通过维护一个NSMapTable来最终确定对被观察者的强弱引用关系。 接口实现- (void)observe:(nullable id)object keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(FBKVONotificationBlock)block &#123; if (nil == object || 0 == keyPath.length || NULL == block) &#123; return; &#125; // 创建数据结构_FBKVOInfo _FBKVOInfo *info = [[_FBKVOInfo alloc] initWithController:self keyPath:keyPath options:options block:block]; // 添加对object的观察, 并传入info [self _observe:object info:info];&#125; 以添加一个被观察者并且回调是 block 为例。在这个方法里首先是对参数的合理性判断，要求object、keyPath以及block均是合理值。 接着把keyPath、options、block包装成一个数据结构_FBKVOInfo。 最后调用自己的_observe:info:方法，传入object和info。 _FBKVOInfo数据结构@interface _FBKVOInfo : NSObject@end@implementation _FBKVOInfo &#123;@public __weak FBKVOController *_controller; NSString *_keyPath; NSKeyValueObservingOptions _options; SEL _action; void *_context; FBKVONotificationBlock _block; _FBKVOInfoState _state;&#125; _FBKVOInfo是一个数据结构，包含了监听的keyPath、block、选择子、context等等元素。 - (instancetype)initWithController:(FBKVOController *)controller keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(nullable FBKVONotificationBlock)block action:(nullable SEL)action context:(nullable void *)context &#123; self = [super init]; if (nil != self) &#123; _controller = controller; _block = [block copy]; _keyPath = [keyPath copy]; _options = options; _action = action; _context = context; &#125; return self;&#125; 构造方法的实现就是这样，不过有两个关键点:block和keyPath调用一下 copy 方法。keyPath调用一下 copy的原因是，这里的_keyPath是使用__strong修饰的，如果外面传进来的是不可变字符串，自然没有啥问题，可是一旦传进来一个可变字符串，如果直接赋值_keyPath = keyPath;，当这个可变字符串改变就会造成_keyPath也改变，比较容易产生不可控事件，所以调用 copy方法，也即是深复制浅复制的问题。 没有深复制的示例如下： NSMutableString *str = [NSMutableString stringWithString:@"key"];// 假定是_keyPath = keyPath;而不是_keyPath = [keyPath copy];_FBKVOInfo *info = [[_FBKVOInfo alloc] initWithController:self keyPath:str options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) &#123; &#125; action:@selector(push) context:nil];[str appendString:@"new"];NSLog(@"%@", info-&gt;_keyPath); //info-&gt;_keyPath不符合预期的改变了 同样，block 的copy是把block从栈拷贝到堆中，防止被释放。因为block作为参数传入函数不会被 copy，依然在栈上，方法执行完立即释放的。 在ARC下：大部分情况下系统会把Block自动copy到堆上。 Block作为变量：方法中声明一个 block 的时候是在栈上；引用了外部局部变量或成员变量, 并且有赋值操作（有名字），会被 copy 到堆上；赋值给附有__strong修饰符的id类型的类或者Blcok类型成员变量时；赋值给一个 weak 变量不会被 copy； Block作为属性：用 copy 修饰会被 copy； Block作为函数参数：作为参数传入函数不会被 copy，依然在栈上，方法执行完即释放；作为函数的返回值会被 copy 到堆； - (NSUInteger)hash &#123; return [_keyPath hash];&#125;- (BOOL)isEqual:(id)object &#123; if (nil == object) &#123; return NO; &#125; if (self == object) &#123; return YES; &#125; if (![object isKindOfClass:[self class]]) &#123; return NO; &#125; return [_keyPath isEqualToString:((_FBKVOInfo *)object)-&gt;_keyPath];&#125; _FBKVOInfo还做了一点其他的事：1.重写了- (NSUInteger)hash;方法，使用_keyPath的 hash 值来作为_FBKVOInfo的 hash 值。分配的这个hash值(即用于查找集合中成员的位置标识)，就是通过hash方法计算得来的，且hash方法返回的hash值最好唯一。2.重写了- (BOOL)isEqual:(id)object;方法，满足Equal的条件有两个: 首先是类对象一致，再者是_keyPath匹配。换句话说，_keyPath决定了_FBKVOInfo是否是同一个。为了优化判等的效率，基于hash的NSSet和NSDictionary在判断成员是否相等时， 会这样做Step1: 成员的hash值是否和目标hash值相等，如果相同进入Step 2，如果不等，直接判断不相等Step 2: hash值相同(即Step 1)的情况下，再进行对象判等， 作为判等的结果。 hash值是对象判等的必要非充分条件 NSPointerFunctionsObjectPointerPersonality对于 isEqual: 和 hash 使用直接的指针比较。使用移位指针(shifted pointer)来做hash检测及确定两个对象是否相等；同时使用description方法来做描述字符串。 Personalities determine hashing and equality. NSPointerFunctionsObjectPersonality provides the standard Foundation behavior of using hash and isEqual:. You can also use NSPointerFunctionsObjectPointerPersonality, which treats the contents as objects, but uses direct pointer value comparison; this is useful if you need a collection to work with object identity rather than value.NSPointerFunctionsObjectPointerPersonality 使用 ==判断相等NSPointerFunctionsObjectPersonality 使用hash和isEqual:判断相等 _observe:info:方法- (void)_observe:(id)object info:(_FBKVOInfo *)info &#123; // lock pthread_mutex_lock(&amp;_lock); NSMutableSet *infos = [_objectInfosMap objectForKey:object]; // 检查infos是否存在于_objectInfosMap中 _FBKVOInfo *existingInfo = [infos member:info]; if (nil != existingInfo) &#123; // 已经存在了，return pthread_mutex_unlock(&amp;_lock); return; &#125; // 不存在，创建infos并保存于_objectInfosMap中 if (nil == infos) &#123; infos = [NSMutableSet set]; [_objectInfosMap setObject:infos forKey:object]; &#125; // 把info添加到infos中 [infos addObject:info]; pthread_mutex_unlock(&amp;_lock); // _FBKVOSharedController添加观察 [[_FBKVOSharedController sharedController] observe:object info:info];&#125; 首先加锁。把被观察的对象object作为key从自己的_objectInfosMap获取其对应的NSMutableSet类型的集合，如果这个集合包含了已经封装好的info对象，说明已经对这个info添加过监听了，解锁直接 return 就是了。如果这个infos集合不存在，创建。把info元素添加到这个infos集合中。解锁。调用[[_FBKVOSharedController sharedController] observe:object info:info];方法。 可见这个方法主要是使用_objectInfosMap保存了封装好的info对象，具体监听调用逻辑依赖于_FBKVOSharedController。 五、_FBKVOSharedController实现初始化@interface _FBKVOSharedController : NSObject+ (instancetype)sharedController;- (void)observe:(id)object info:(nullable _FBKVOInfo *)info;- (void)unobserve:(id)object info:(nullable _FBKVOInfo *)info;- (void)unobserve:(id)object infos:(nullable NSSet *)infos;@end@implementation _FBKVOSharedController &#123; NSHashTable&lt;_FBKVOInfo *&gt; *_infos; pthread_mutex_t _mutex;&#125; _FBKVOSharedController是一个单例。作用是观察 _FBKVOInfo 中的 keyPath，并给予回调(回调的类型可以是 block、selector、系统回调方法)。 暴露出两个方法: 添加监听，参数为_infos 移除监听，参数为_FBKVOInfo或者NSSet类型的infos(容器内的元素仍然是_FBKVOInfo) 内部维护了一个哈希表(NSHashTable)_infos，用于保存这些_FBKVOInfo。除此之外还有一个锁:_mutex，用于实现线程安全。 哈希表的创建: NSHashTable *infos = [NSHashTable alloc];_infos = [infos initWithOptions:NSPointerFunctionsWeakMemory|NSPointerFunctionsObjectPointerPersonality capacity:0];NSPointerFunctionsWeakMemory: 持弱指针引用着_FBKVOInfo对象。NSPointerFunctionsObjectPointerPersonality 使用==判定相等。 可见_FBKVOSharedController只是单纯地掌管_FBKVOInfo集合，它只需要解析_FBKVOInfo并给observer回调即可，其他的一切都不关心。 添加监听- (void)observe:(id)object info:(nullable _FBKVOInfo *)info &#123; if (nil == info) return; // _infos添加对象 pthread_mutex_lock(&amp;_mutex); [_infos addObject:info]; pthread_mutex_unlock(&amp;_mutex); // 添加观察，传入的context是info [object addObserver:self forKeyPath:info-&gt;_keyPath options:info-&gt;_options context:(void *)info]; if (info-&gt;_state == _FBKVOInfoStateInitial) &#123; info-&gt;_state = _FBKVOInfoStateObserving; // 初始状态转监听状态 &#125; else if (info-&gt;_state == _FBKVOInfoStateNotObserving) &#123; // 未监听状态便移除 // this could happen when `NSKeyValueObservingOptionInitial` is one of the NSKeyValueObservingOptions, // and the observer is unregistered within the callback block. // at this time the object has been registered as an observer (in Foundation KVO), // so we can safely unobserve it. // NSKeyValueObservingOptionInitial：添加观察者时就触发回调，并且在后面赋值时也会触发回调，但是都只返回NSKeyValueChangeKindKey。观察者在callback block中取消观察，所以在这里removeObserver [object removeObserver:self forKeyPath:info-&gt;_keyPath context:(void *)info]; &#125;&#125; 容器中添加 info 元素，添加监听。 移除监听- (void)unobserve:(id)object info:(nullable _FBKVOInfo *)info &#123; if (nil == info) return; // 哈希表中移除info pthread_mutex_lock(&amp;_mutex); [_infos removeObject:info]; pthread_mutex_unlock(&amp;_mutex); // 移除监听 if (info-&gt;_state == _FBKVOInfoStateObserving) &#123; [object removeObserver:self forKeyPath:info-&gt;_keyPath context:(void *)info]; &#125; info-&gt;_state = _FBKVOInfoStateNotObserving;&#125; 容器中移除 info 元素，移除监听。 系统KVO调用- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context &#123; _FBKVOInfo *info; &#123; pthread_mutex_lock(&amp;_mutex); // 看看info是否存在于_infos中，如果存在，返回info info = [_infos member:(__bridge id)context]; pthread_mutex_unlock(&amp;_mutex); &#125; if (nil != info) &#123; // 局部变量强引用controller FBKVOController *controller = info-&gt;_controller; if (nil != controller) &#123; // 局部变量强引用observer id observer = controller.observer; if (nil != observer) &#123; if (info-&gt;_block) &#123; // 回调 block NSDictionary&lt;NSKeyValueChangeKey, id&gt; *changeWithKeyPath = change; if (keyPath) &#123; NSMutableDictionary&lt;NSString *, id&gt; *mChange = [NSMutableDictionary dictionaryWithObject:keyPath forKey:FBKVONotificationKeyPathKey]; [mChange addEntriesFromDictionary:change]; changeWithKeyPath = [mChange copy]; &#125; info-&gt;_block(observer, object, changeWithKeyPath); &#125; else if (info-&gt;_action) &#123; // 回调 selector [observer performSelector:info-&gt;_action withObject:change withObject:object]; &#125; else &#123; // 调用KVO 系统方法 [observer observeValueForKeyPath:keyPath ofObject:object change:change context:info-&gt;_context]; &#125; &#125; &#125; &#125;&#125; 最终在系统方法中给予不同类型的回调。 typedef NS_ENUM(uint8_t, _FBKVOInfoState) &#123; _FBKVOInfoStateInitial = 0, _FBKVOInfoStateObserving, _FBKVOInfoStateNotObserving,&#125;; 作者使用了三个枚举值来记录监听状态。会不会是多此一举呢？不会。作用主要体现在添加监听的方法里有个移除监听操作： // 添加观察，传入的context是info[object addObserver:self forKeyPath:info-&gt;_keyPath options:info-&gt;_options context:(void *)info]; if (info-&gt;_state == _FBKVOInfoStateInitial) &#123; info-&gt;_state = _FBKVOInfoStateObserving; // 初始状态转监听状态 &#125; else if (info-&gt;_state == _FBKVOInfoStateNotObserving) &#123; // 未监听状态便移除 [object removeObserver:self forKeyPath:info-&gt;_keyPath context:(void *)info]; &#125; “未监听状态便移除“是怎么出现的？示例如下： [self.KVOController observe:self.myButton keyPath:@"backgroundColor" options:NSKeyValueObservingOptionInitial block:^(id _Nullable observer, id _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) &#123; [self.KVOController unobserve:self.myButton keyPath:@"backgroundColor"];&#125;]; 包含了NSKeyValueObservingOptionInitial选项且在回调中移除了监听就会出现这种情况。因为如果有NSKeyValueObservingOptionInitial选项，在添加监听的时候就会有回调。调用栈如下：执行到[object addObserver:self forKeyPath:info-&gt;_keyPath options:info-&gt;_options context:(void *)info];这行代码的时候，首先添加监听，接着调用回调，而回调中又移除了观察，这时info的状态被设置为_FBKVOInfoStateNotObserving。接着进入了下面的 if-else 判断中，才有了移除监听的操作。可见逻辑非常严谨。 NSKeyValueObservingOption参考： NSKeyValueObservingOptionNew：接收方法中使用change参数传入变化后的新值，键为：&gt;NSKeyValueChangeNewKey；NSKeyValueObservingOptionOld：接收方法中使用change参数传入变化前的旧值，键为：&gt;NSKeyValueChangeOldKey；NSKeyValueObservingOptionInitial：注册之后立刻调用接收方法，如果配置了&gt;NSKeyValueObservingOptionNew，change参数内容会包含新值，键为：&gt;NSKeyValueChangeNewKey；NSKeyValueObservingOptionPrior：如果加入这个参数，接收方法会在变化前后分别调用一次，共两&gt;次，变化前的通知change参数包含notificationIsPrior = 1。其他内容根据&gt;NSKeyValueObservingOptionNew和NSKeyValueObservingOptionOld的配置确定。 六、一个函数其实不是一个函数，不过是为了实现一个功能，核心还是一个函数。 // 1.枚举字符串化static NSString *describe_option(NSKeyValueObservingOptions option) &#123; switch (option) &#123; case NSKeyValueObservingOptionNew: return @"NSKeyValueObservingOptionNew"; break; case NSKeyValueObservingOptionOld: return @"NSKeyValueObservingOptionOld"; break; case NSKeyValueObservingOptionInitial: return @"NSKeyValueObservingOptionInitial"; break; case NSKeyValueObservingOptionPrior: return @"NSKeyValueObservingOptionPrior"; break; default: NSCAssert(NO, @"unexpected option %tu", option); break; &#125; return nil;&#125;// 2.拼接optionstatic void append_option_description(NSMutableString *s, NSUInteger option) &#123; if (0 == s.length) &#123; [s appendString:describe_option(option)]; &#125; else &#123; [s appendString:@"|"]; [s appendString:describe_option(option)]; &#125;&#125;// 3.NSKeyValueObservingOptions类型值遍历static NSUInteger enumerate_flags(NSUInteger *ptrFlags) &#123; NSCAssert(ptrFlags, @"expected ptrFlags"); if (!ptrFlags) return 0; NSUInteger flags = *ptrFlags; if (!flags) return 0; NSUInteger flag = 1 &lt;&lt; __builtin_ctzl(flags); flags &amp;= ~flag; *ptrFlags = flags; return flag;&#125;// 4.把options所有值都拼出来static NSString *describe_options(NSKeyValueObservingOptions options) &#123; NSMutableString *s = [NSMutableString string]; NSUInteger option; while (0 != (option = enumerate_flags(&amp;options))) &#123; append_option_description(s, option); &#125; return s;&#125; 不使用 switch-case 把位移枚举的值遍历出来了。 // Similar to __builtin_ctz, except the argument type is unsigned long.// __builtin_ctz(x)：x末尾0的个数// 左移__builtin_ctz(x)位得到原先的枚举值NSUInteger flag = 1 &lt;&lt; __builtin_ctzl(flags);// flags 去除已经取到的值flags &amp;= ~flag;// 把更新后的flags赋予指向ptrFlags的指针*ptrFlags = flags; 不失为一个好办法。 七、总结 使用 KVOController 进行键值观测可以说完美地解决了在使用原生 KVO 时遇到的各种问题。 1.不需要手动移除观察者；2.实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；3.使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；4.每一个 keyPath 会对应一个属性，不需要在 block 中使用 if 判断 keyPath； 以上引自draveness。解释如下：1.NSMapTable 可以持有键和值的弱引用，当键或者值当中的一个被释放时，整个这一项就会被移除掉。 // 这里使用被观察者observer作为强引用或者弱引用的key，使用_FBKVOInfo作为强引用的valueNSPointerFunctionsOptions keyOptions = retainObserved ? NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPointerPersonality : NSPointerFunctionsWeakMemory|NSPointerFunctionsObjectPointerPersonality;_objectInfosMap = [[NSMapTable alloc] initWithKeyOptions:keyOptions valueOptions:NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPersonality capacity:0]; 2.因为是在@selector(observeValueForKeyPath:ofObject:change:context:)中处理的回调。3.使用FBKVONotificationBlock。4._FBKVOInfo封装。 纵观全部代码，作者首先给分类添加了两个属性，用于接口调用。这些属性都指向了FBKVOController，FBKVOController主要维护了一个NSMapTable。key 是所观察的对象，value 是NSMutableSet类型的集合，其内部元素是_FBKVOInfo类型对象。一个_FBKVOInfo对象对应一个信息封装。之所以使用NSMapTable集合是便于对同一个对象的多个keyPath进行观察，同时处理被观察者的强弱引用。另外_FBKVOInfo对象是对FBKVOController、keyPath、context、回调block等信息的封装。最后，各个FBKVOController把所有对观察的处理交给单例_FBKVOSharedController，这个单例调用系统KVO方法回调、处理包含所有_FBKVOInfo对象的NSHashTable集合。 参考资料KVOControlleriOS中Block使用注意点isEqual与hashiOS学习笔记——KVO]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读「YYCache」]]></title>
    <url>%2F2019%2F01%2F02%2F%E8%AF%BB%E3%80%8CYYCache%E3%80%8D%2F</url>
    <content type="text"><![CDATA[关于YYCache的简单总结。 阅读YYCache源码有3遍了，自我感觉“需要理解”的部分掌握的差不多了，做个记录。 一、接口API 类似字典，比较容易理解。 1.初始化@property (copy, readonly) NSString *name;@property (strong, readonly) YYMemoryCache *memoryCache;@property (strong, readonly) YYDiskCache *diskCache;- (nullable instancetype)initWithName:(NSString *)name;- (nullable instancetype)initWithPath:(NSString *)path NS_DESIGNATED_INITIALIZER;+ (nullable instancetype)cacheWithName:(NSString *)name;+ (nullable instancetype)cacheWithPath:(NSString *)path;- (instancetype)init UNAVAILABLE_ATTRIBUTE;+ (instancetype)new UNAVAILABLE_ATTRIBUTE; 2.是否存在- (BOOL)containsObjectForKey:(NSString *)key;- (void)containsObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, BOOL contains))block; 3.查询- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;- (void)objectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, id&lt;NSCoding&gt; object))block; 4.设值- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(nullable void(^)(void))block; 5.移除- (void)removeObjectForKey:(NSString *)key;- (void)removeObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key))block;- (void)removeAllObjects;- (void)removeAllObjectsWithBlock:(void(^)(void))block;- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end; 二、实现@implementation YYCache- (instancetype) init &#123; NSLog(@"Use \"initWithName\" or \"initWithPath\" to create YYCache instance."); return [self initWithPath:@""];&#125;- (instancetype)initWithName:(NSString *)name &#123; if (name.length == 0) return nil; NSString *cacheFolder = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]; NSString *path = [cacheFolder stringByAppendingPathComponent:name]; return [self initWithPath:path];&#125;- (instancetype)initWithPath:(NSString *)path &#123; if (path.length == 0) return nil; YYDiskCache *diskCache = [[YYDiskCache alloc] initWithPath:path]; if (!diskCache) return nil; NSString *name = [path lastPathComponent]; YYMemoryCache *memoryCache = [YYMemoryCache new]; memoryCache.name = name; self = [super init]; _name = name; _diskCache = diskCache; _memoryCache = memoryCache; return self;&#125;+ (instancetype)cacheWithName:(NSString *)name &#123; return [[self alloc] initWithName:name];&#125;+ (instancetype)cacheWithPath:(NSString *)path &#123; return [[self alloc] initWithPath:path];&#125;- (BOOL)containsObjectForKey:(NSString *)key &#123; return [_memoryCache containsObjectForKey:key] || [_diskCache containsObjectForKey:key];&#125;- (void)containsObjectForKey:(NSString *)key withBlock:(void (^)(NSString *key, BOOL contains))block &#123; if (!block) return; if ([_memoryCache containsObjectForKey:key]) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; block(key, YES); &#125;); &#125; else &#123; [_diskCache containsObjectForKey:key withBlock:block]; &#125;&#125;- (id&lt;NSCoding&gt;)objectForKey:(NSString *)key &#123; id&lt;NSCoding&gt; object = [_memoryCache objectForKey:key]; if (!object) &#123; object = [_diskCache objectForKey:key]; if (object) &#123; [_memoryCache setObject:object forKey:key]; &#125; &#125; return object;&#125;- (void)objectForKey:(NSString *)key withBlock:(void (^)(NSString *key, id&lt;NSCoding&gt; object))block &#123; if (!block) return; id&lt;NSCoding&gt; object = [_memoryCache objectForKey:key]; if (object) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; block(key, object); &#125;); &#125; else &#123; [_diskCache objectForKey:key withBlock:^(NSString *key, id&lt;NSCoding&gt; object) &#123; if (object &amp;&amp; ![_memoryCache objectForKey:key]) &#123; [_memoryCache setObject:object forKey:key]; &#125; block(key, object); &#125;]; &#125;&#125;- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key &#123; [_memoryCache setObject:object forKey:key]; [_diskCache setObject:object forKey:key];&#125;- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(void (^)(void))block &#123; [_memoryCache setObject:object forKey:key]; [_diskCache setObject:object forKey:key withBlock:block];&#125;- (void)removeObjectForKey:(NSString *)key &#123; [_memoryCache removeObjectForKey:key]; [_diskCache removeObjectForKey:key];&#125;- (void)removeObjectForKey:(NSString *)key withBlock:(void (^)(NSString *key))block &#123; [_memoryCache removeObjectForKey:key]; [_diskCache removeObjectForKey:key withBlock:block];&#125;- (void)removeAllObjects &#123; [_memoryCache removeAllObjects]; [_diskCache removeAllObjects];&#125;- (void)removeAllObjectsWithBlock:(void(^)(void))block &#123; [_memoryCache removeAllObjects]; [_diskCache removeAllObjectsWithBlock:block];&#125;- (void)removeAllObjectsWithProgressBlock:(void(^)(int removedCount, int totalCount))progress endBlock:(void(^)(BOOL error))end &#123; [_memoryCache removeAllObjects]; [_diskCache removeAllObjectsWithProgressBlock:progress endBlock:end]; &#125;- (NSString *)description &#123; if (_name) return [NSString stringWithFormat:@"&lt;%@: %p&gt; (%@)", self.class, self, _name]; else return [NSString stringWithFormat:@"&lt;%@: %p&gt;", self.class, self];&#125;@end 整体来看还是比较容易理解的，YYCache 整合了内存缓存和磁盘缓存，主要做了这些事： 初始化YYCache实例，要求缓存路径要合理。 查询缓存对象先从内存缓存中查找，如果没有，再从磁盘缓存中查找。当磁盘缓存中有而内存缓存中没有的时候，把取得的缓存对象保存在内存缓存中。 缓存对象的存取和移除，内存缓存和磁盘缓存两者保持同步。 1.YYMemoryCache基本属性@property (nullable, copy) NSString *name;@property (readonly) NSUInteger totalCount;@property (readonly) NSUInteger totalCost;#pragma mark - Limit@property NSUInteger countLimit;@property NSUInteger costLimit;@property NSTimeInterval ageLimit;@property NSTimeInterval autoTrimInterval;@property BOOL shouldRemoveAllObjectsOnMemoryWarning;@property BOOL shouldRemoveAllObjectsWhenEnteringBackground;@property (nullable, copy) void(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);@property (nullable, copy) void(^didEnterBackgroundBlock)(YYMemoryCache *cache);@property BOOL releaseOnMainThread;@property BOOL releaseAsynchronously; 类似于NSCache，提供包括缓存数量、缓存花费、缓存时间的管理。除此之外，当接收到内存警告时(shouldRemoveAllObjectsOnMemoryWarning)或者 App 进入到后台时(shouldRemoveAllObjectsWhenEnteringBackground)可以选择释放缓存对象。而对缓存对象释放也可以进行控制，比如可以选择在主线程释放(releaseOnMainThread)或者异步释放(releaseAsynchronously)。 存取接口- (BOOL)containsObjectForKey:(id)key;- (nullable id)objectForKey:(id)key;- (void)setObject:(nullable id)object forKey:(id)key;- (void)setObject:(nullable id)object forKey:(id)key withCost:(NSUInteger)cost;- (void)removeObjectForKey:(id)key;- (void)removeAllObjects;- (void)trimToCount:(NSUInteger)count;- (void)trimToCost:(NSUInteger)cost;- (void)trimToAge:(NSTimeInterval)age; 除了基本的存取方法之外，YYMemoryCache 还暴露了三个移除缓存对象的方法。 trimToCount：根据限制的数量(countLimit)进行移除缓存对象操作，直到满足数量限制要求。 trimToCost：根据限制的花费(costLimit)进行移除缓存对象操作，直到满足花费限制要求。 trimToAge：根据缓存对象的过期时间(ageLimit)进行移除缓存对象操作，直到满足要求。 具体实现在具体实现中，作者考虑了以下要求: 缓存对象的存取。要保证效率就要求存取时间复杂度最好是O(1)。 缓存对象的移除。要保证能按照 cost、age、count 等条件对所有不符合要求的对象进行移除。 线程安全。需要加锁。第一条：要求时间复杂度是 O(1)，那就可以采用哈希表、字典等。作者使用了字典，且是效率更高的CFMutableDictionaryRef。第二条：记录 cost、age、count等属性，肯定需要对缓存对象进行包装。再者需要考虑LRU(Least Recently Used)，就需要保证顺序。而要使得字典中的对象(value)有顺序，必须有一个指向其他对象的指针(属性）。可以使用双向链表包装缓存对象。第三条：存取的线程安全，使用GCD线程锁。 结点@interface _YYLinkedMapNode : NSObject &#123; @package __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic id _key; id _value; NSUInteger _cost; NSTimeInterval _time;&#125;@end 链表的结点中保存着key 和 value，这是对缓存对象的包装。_cost和_time记录着缓存对象的花费和过期时间。而使用__unsafe_unretained修饰的_prev和_next则分别指向前一个对象和后一个对象。由于这些结点已经被字典持有了，所以直接使用__unsafe_unretained修饰，不必再增加它的引用计数，提高效率。这一点与隐式参数self很像，self其实也是使用__unsafe_unretained修饰的。 链表@interface _YYLinkedMap : NSObject &#123; @package CFMutableDictionaryRef _dic; // do not set object directly NSUInteger _totalCost; NSUInteger _totalCount; _YYLinkedMapNode *_head; // MRU, do not change it directly _YYLinkedMapNode *_tail; // LRU, do not change it directly BOOL _releaseOnMainThread; BOOL _releaseAsynchronously;&#125;- (void)insertNodeAtHead:(_YYLinkedMapNode *)node;- (void)bringNodeToHead:(_YYLinkedMapNode *)node;- (void)removeNode:(_YYLinkedMapNode *)node;- (_YYLinkedMapNode *)removeTailNode;- (void)removeAll;@end 一个 YYMemoryCache 对象有一个链表。这个链表使用_dic保存着所有包装好的缓存对象(_YYLinkedMapNode)，记录着总的花费(_totalCost)和总的数量(_totalCount)。当然，还使用_head指着链表的头指针，使用_tail指着链表的尾指针。_releaseOnMainThread和_releaseAsynchronously用于设置对缓存对象释放操作的选项:主线程释放或者异步释放。 _YYLinkedMap暴露出的五个方法很清晰地表明它的作用：每次当缓存取到某个对象时，把它置在头结点的位置。这样随着时间的推移，很轻松地使得那些不经常使用的对象处在链表的后端，经常使用的对象处在链表的前端，这样就实现了 LRU。 操作- (void)insertNodeAtHead:(_YYLinkedMapNode *)node &#123; CFDictionarySetValue(_dic, (__bridge const void *)(node-&gt;_key), (__bridge const void *)(node)); _totalCost += node-&gt;_cost; _totalCount++; if (_head) &#123; node-&gt;_next = _head; _head-&gt;_prev = node; _head = node; &#125; else &#123; _head = _tail = node; &#125;&#125;- (void)bringNodeToHead:(_YYLinkedMapNode *)node &#123; if (_head == node) return; if (_tail == node) &#123; _tail = node-&gt;_prev; _tail-&gt;_next = nil; &#125; else &#123; node-&gt;_next-&gt;_prev = node-&gt;_prev; node-&gt;_prev-&gt;_next = node-&gt;_next; &#125; node-&gt;_next = _head; node-&gt;_prev = nil; _head-&gt;_prev = node; _head = node;&#125;- (void)removeNode:(_YYLinkedMapNode *)node &#123; CFDictionaryRemoveValue(_dic, (__bridge const void *)(node-&gt;_key)); _totalCost -= node-&gt;_cost; _totalCount--; if (node-&gt;_next) node-&gt;_next-&gt;_prev = node-&gt;_prev; if (node-&gt;_prev) node-&gt;_prev-&gt;_next = node-&gt;_next; if (_head == node) _head = node-&gt;_next; if (_tail == node) _tail = node-&gt;_prev;&#125;- (_YYLinkedMapNode *)removeTailNode &#123; if (!_tail) return nil; _YYLinkedMapNode *tail = _tail; CFDictionaryRemoveValue(_dic, (__bridge const void *)(_tail-&gt;_key)); _totalCost -= _tail-&gt;_cost; _totalCount--; if (_head == _tail) &#123; _head = _tail = nil; &#125; else &#123; _tail = _tail-&gt;_prev; _tail-&gt;_next = nil; &#125; return tail;&#125; 对结点的插入、移除、调整位置，是数据结构的基础操作。令人怀念！ _releaseOnMainThread和_releaseAsynchronously这两个选项的实现也很简单。作者自己维护了一个队列: static inline dispatch_queue_t YYMemoryCacheGetReleaseQueue() &#123; return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);&#125; 移除的时候有所判断： if (CFDictionaryGetCount(_dic) &gt; 0) &#123; CFMutableDictionaryRef holder = _dic; _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); if (_releaseAsynchronously) &#123; dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; CFRelease(holder); // hold and release in specified queue &#125;); &#125; else if (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; CFRelease(holder); // hold and release in specified queue &#125;); &#125; else &#123; CFRelease(holder); &#125;&#125; 根据线程、是否异步决定具体的逻辑，把release操作放到相应线程中。这里使用一个临时变量holder，很是巧妙。 核心操作@implementation YYMemoryCache &#123; pthread_mutex_t _lock; _YYLinkedMap *_lru; dispatch_queue_t _queue;&#125; 从这里可以看出YYMemoryCache使用pthread_mutex_t保证线程安全。 最关键的还是对无效缓存对象的释放，以 count 为例，当缓存的对象数量超过了 count 限制，就需要对链表后端不常使用的缓存对象进行移除操作，直到满足 count 限制。 - (void)_trimToCount:(NSUInteger)countLimit &#123; BOOL finish = NO; pthread_mutex_lock(&amp;_lock); if (countLimit == 0) &#123; [_lru removeAll]; finish = YES; &#125; else if (_lru-&gt;_totalCount &lt;= countLimit) &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); if (finish) return; NSMutableArray *holder = [NSMutableArray new]; while (!finish) &#123; if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; if (_lru-&gt;_totalCount &gt; countLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (node) [holder addObject:node]; &#125; else &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); &#125; else &#123; usleep(10 * 1000); //10 ms &#125; &#125; if (holder.count) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [holder count]; // release in queue &#125;); &#125;&#125; 这个方法做了什么？ 使用pthread_mutex_lock(&amp;_lock);pthread_mutex_unlock(&amp;_lock);对操作加锁解锁来保证线程安全。 对参数 countLimit 判断：如果countLimit为0，也就是说缓存数量限制为0，那移除所有缓存对象就是了。如果当前所缓存的对象数量小于countLimit，那说明满足数量限制要求，就不需要移除操作了。 作者创建一个可变字典holder，当不满足countLimit限制要求的时候，对链表尾结点进行移除操作，并把这个尾结点添加到holder中持有。当然，这里有加锁操作。这个 while 循环结束，所有多余的缓存对象就在holder中了。4.对holder中所有元素进行 release 操作。其他的如: - (void)_trimToAge:(NSTimeInterval)ageLimit; - (void)_trimToCost:(NSUInteger)costLimit 操作同理。 内存警告内存警告语 App 进入后台时释放缓存对象的操作，作者接受了系统通知，直接处理即可。 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appDidReceiveMemoryWarningNotification) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appDidEnterBackgroundNotification) name:UIApplicationDidEnterBackgroundNotification object:nil]; 存取实现- (BOOL)containsObjectForKey:(id)key &#123; if (!key) return NO; pthread_mutex_lock(&amp;_lock); BOOL contains = CFDictionaryContainsKey(_lru-&gt;_dic, (__bridge const void *)(key)); pthread_mutex_unlock(&amp;_lock); return contains;&#125;- (id)objectForKey:(id)key &#123; if (!key) return nil; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; node-&gt;_time = CACurrentMediaTime(); [_lru bringNodeToHead:node]; &#125; pthread_mutex_unlock(&amp;_lock); return node ? node-&gt;_value : nil;&#125;- (void)setObject:(id)object forKey:(id)key &#123; [self setObject:object forKey:key withCost:0];&#125; 对缓存对象的读取自然是根据 key 读取到字典中对应的 value，这个 value 是个结点(_YYLinkedMapNode)，再取出这个结点的value 属性，便是最原始的缓存对象了:node-&gt;_value。 2.关键点1.字典CFMutableDictionaryRef的使用 声明: CFMutableDictionaryRef _dic;创建: _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);设值: CFDictionarySetValue(_dic, (__bridge const void *)(node-&gt;_key), (__bridge const void *)(node));取值: CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key));移除: CFDictionaryRemoveValue(_dic, (__bridge const void *)(node-&gt;_key));获取数量: CFDictionaryGetCount(_dic);是否存在: CFDictionaryContainsKey(_lru-&gt;_dic, (__bridge const void *)(key));释放: CFRelease(_dic); 2.容器中对象销毁控制 “对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去…” // 数组中的所有元素在子线程释放&#123; NSArray *holder = tmp; tmp = [NSMutableArray array]; if (holder.count &gt; 0) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [holder count]; &#125;); &#125;&#125;// 数组中的某个元素在子线程释放&#123; id obj = tmp[2]; NSMutableArray *holder = [NSMutableArray array]; [holder addObject:obj]; [tmp removeObject:obj]; if (holder.count &gt; 0) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [holder count]; &#125;); &#125;&#125; 3.线程安全的实现 // 取值线程安全&#123; pthread_mutex_lock(&amp;_lock); BOOL releaseAsynchronously = _lru-&gt;_releaseAsynchronously; pthread_mutex_unlock(&amp;_lock); return releaseAsynchronously;&#125;// 设值线程安全&#123; pthread_mutex_lock(&amp;_lock); _lru-&gt;_releaseAsynchronously = releaseAsynchronously; pthread_mutex_unlock(&amp;_lock);&#125; 4.pthread_mutex_lock使用 声明锁: pthread_mutex_t _lock;创建锁: pthread_mutex_init(&amp;_lock, NULL);加锁: pthread_mutex_lock(&amp;_lock);解锁: pthread_mutex_unlock(&amp;_lock);尝试加锁:if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; pthread_mutex_unlock(&amp;_lock);&#125; else &#123; usleep(10 * 1000); //10 ms&#125;销毁锁: pthread_mutex_destroy(&amp;_lock); 5.if-else 单句 if (_name) return nil;else return nil; 3.YYDiskCacheYYDiskCache主要调用了YYKVStorage的接口，并提供对外 API。 五个函数/// Free disk space in bytes.static int64_t _YYDiskSpaceFree() &#123; NSError *error = nil; NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error]; if (error) return -1; int64_t space = [[attrs objectForKey:NSFileSystemFreeSize] longLongValue]; if (space &lt; 0) space = -1; return space;&#125;/// String's md5 hash.static NSString *_YYNSStringMD5(NSString *string) &#123; if (!string) return nil; NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(data.bytes, (CC_LONG)data.length, result); return [NSString stringWithFormat: @"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7], result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15] ];&#125;static void _YYDiskCacheInitGlobal() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _globalInstancesLock = dispatch_semaphore_create(1); _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; &#125;);&#125;static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123; if (path.length == 0) return nil; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); id cache = [_globalInstances objectForKey:path]; dispatch_semaphore_signal(_globalInstancesLock); return cache;&#125;static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123; if (cache.path.length == 0) return; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); [_globalInstances setObject:cache forKey:cache.path]; dispatch_semaphore_signal(_globalInstancesLock);&#125; _YYDiskSpaceFree()提供剩余磁盘空间的查询。_YYNSStringMD5(NSString *string)提供字符串转 md5。 _YYDiskCacheInitGlobal()用于初始化一个强-弱的NSMapTable，保存YYDiskCache对象。_YYDiskCacheGetGlobal(NSString *path)用于根据路径 path 获取对应的YYDiskCache对象。_YYDiskCacheSetGlobal(YYDiskCache *cache)用于根据路径 path 在NSMapTable保存一个YYDiskCache对象。 主要实现YYDiskCache的功能比如移除过期的对象、移除超过数量限制的对象等，主要通过YYKVStorage实现。作者把保存类型分为三种： typedef NS_ENUM(NSUInteger, YYKVStorageType) &#123; /// file system. YYKVStorageTypeFile = 0, /// in sqlite. YYKVStorageTypeSQLite = 1, /// based on your choice. YYKVStorageTypeMixed = 2,&#125;; 作者指明了原因：Typically, write data to sqlite is faster than extern file, but reading performance is dependent on data size. In my test (on iPhone 6 64G), read data from extern file is faster than from sqlite when the data is larger than 20KB. If you want to store large number of small datas (such as contacts cache),use YYKVStorageTypeSQLite to get better performance. If you want to store large files (such as image cache),use YYKVStorageTypeFile to get better performance. You can use YYKVStorageTypeMixed and choice your storage type for each item. 20kb 以下的持久化，放到文件中。 20kb 以上的持久化，放到数据库sqlite中。也可以选择混合存储。 4.YYKVStorageYYKVStorage没有阅读。乍一看是许多琐碎的 SQL 操作和文件操作，没有纳入阅读计划。 三、小结YYCache属于小家碧玉型的开源作品，代码量不是很多，但是很精美。LRU配合双向链表也是很经典的算法题。我觉得最好玩的是容器元素的异步释放逻辑，以前确实没见过这种写法，作者也给出了解释，很值得学习借鉴。]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读「YYModel」]]></title>
    <url>%2F2018%2F12%2F20%2F%E8%AF%BB%E3%80%8CYYModel%E3%80%8D%2F</url>
    <content type="text"><![CDATA[关于YYModel的简单总结。 尝试阅读YYModel源码，发现有一些细节并不能十分透彻地理解清楚，只能略微窥探到其中主要原理。这里就当做第一遍阅读笔记😂😂😂。 使用分类@interface NSObject (YYModel)+ (nullable instancetype)yy_modelWithJSON:(id)json;+ (nullable instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary;- (BOOL)yy_modelSetWithJSON:(id)json;- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic;- (nullable id)yy_modelToJSONObject;- (nullable NSData *)yy_modelToJSONData;- (nullable NSString *)yy_modelToJSONString;// 自定义- (nullable id)yy_modelCopy;- (void)yy_modelEncodeWithCoder:(NSCoder *)aCoder;- (id)yy_modelInitWithCoder:(NSCoder *)aDecoder;- (NSUInteger)yy_modelHash;- (BOOL)yy_modelIsEqual:(id)model;- (NSString *)yy_modelDescription;@end@interface NSArray (YYModel)// json到模型数组+ (nullable NSArray *)yy_modelArrayWithClass:(Class)cls json:(id)json;@end@interface NSDictionary (YYModel)// json到字典+ (nullable NSDictionary *)yy_modelDictionaryWithClass:(Class)cls json:(id)json;@end 拓展@protocol YYModel &lt;NSObject&gt;@optional// 自定义模型属性与json's key的映射+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelCustomPropertyMapper;+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123; @"name" : @"n", @"count" : @"ext.c", @"desc1" : @"ext.d", @"desc4" : @".ext", @"modelID" : @[@"ID", @"Id", @"id", @"ext.id"]&#125;;&#125;// 黑名单, 若实现该方法, 黑名单之内的key均不作处理+ (nullable NSArray&lt;NSString *&gt; *)modelPropertyBlacklist;+ (NSArray *)modelPropertyBlacklist &#123; return @[@"name", @"age"];&#125;// 白名单, 若实现该方法, 白名单之外的key均不作处理+ (nullable NSArray&lt;NSString *&gt; *)modelPropertyWhitelist;+ (NSArray *)modelPropertyWhitelist &#123; return @[@"name"];&#125;// 1.要在JSON转Model的过程中根据情况创建不同类型的实例+ (nullable Class)modelCustomClassForDictionary:(NSDictionary *)dictionary;+ (Class)modelCustomClassForDictionary:(NSDictionary*)dictionary &#123; if (dictionary[@"localName"]) &#123; return [YYLocalUser class]; &#125; else if (dictionary[@"remoteName"]) &#123; return [YYRemoteUser class]; &#125; return [YYBaseUser class];&#125;// 2.该方法发生在字典转模型之前, 最后对字典做一次处理- (NSDictionary *)modelCustomWillTransformFromDictionary:(NSDictionary *)dic;//- (NSDictionary *)modelCustomWillTransformFromDictionary:(NSDictionary *)dic&#123; if ([dic[@"sex"] isEqualToString:@"Man"]) &#123; return nil; &#125; return dic;&#125;// 3.JSON转为Model后, 进行数据校验- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic;- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic &#123; NSNumber *timestamp = dic[@"timestamp"]; if (![timestamp isKindOfClass:[NSNumber class]]) return NO; _createdAt = [NSDate dateWithTimeIntervalSince1970:timestamp.floatValue]; return YES;&#125;// 模型容器属性中的所需要存放的数据类型+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelContainerPropertyGenericClass;+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@"shadows" : [Shadow class], @"borders" : Border.class, @"attachments" : @"Attachment" &#125;;&#125;// Model转为JSON后, 进行数据校验- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic;- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic &#123; if (!_createdAt) return NO; dic[@"timestamp"] = @(_createdAt.timeIntervalSince1970); return YES;&#125;@end 函数// 函数1: 根据class信息获取其对应的类型static force_inline YYEncodingNSType YYClassGetNSType(Class cls) &#123; if (!cls) return YYEncodingTypeNSUnknown; if ([cls isSubclassOfClass:[NSMutableString class]]) return YYEncodingTypeNSMutableString; if ([cls isSubclassOfClass:[NSString class]]) return YYEncodingTypeNSString; if ([cls isSubclassOfClass:[NSDecimalNumber class]]) return YYEncodingTypeNSDecimalNumber; if ([cls isSubclassOfClass:[NSNumber class]]) return YYEncodingTypeNSNumber; if ([cls isSubclassOfClass:[NSValue class]]) return YYEncodingTypeNSValue; if ([cls isSubclassOfClass:[NSMutableData class]]) return YYEncodingTypeNSMutableData; if ([cls isSubclassOfClass:[NSData class]]) return YYEncodingTypeNSData; if ([cls isSubclassOfClass:[NSDate class]]) return YYEncodingTypeNSDate; if ([cls isSubclassOfClass:[NSURL class]]) return YYEncodingTypeNSURL; if ([cls isSubclassOfClass:[NSMutableArray class]]) return YYEncodingTypeNSMutableArray; if ([cls isSubclassOfClass:[NSArray class]]) return YYEncodingTypeNSArray; if ([cls isSubclassOfClass:[NSMutableDictionary class]]) return YYEncodingTypeNSMutableDictionary; if ([cls isSubclassOfClass:[NSDictionary class]]) return YYEncodingTypeNSDictionary; if ([cls isSubclassOfClass:[NSMutableSet class]]) return YYEncodingTypeNSMutableSet; if ([cls isSubclassOfClass:[NSSet class]]) return YYEncodingTypeNSSet; return YYEncodingTypeNSUnknown;&#125;// 函数2: 判断YYEncodingType是不是一个数字(整形\长整型\浮点型等)static force_inline BOOL YYEncodingTypeIsCNumber(YYEncodingType type) &#123; switch (type &amp; YYEncodingTypeMask) &#123; case YYEncodingTypeBool: case YYEncodingTypeInt8: case YYEncodingTypeUInt8: case YYEncodingTypeInt16: case YYEncodingTypeUInt16: case YYEncodingTypeInt32: case YYEncodingTypeUInt32: case YYEncodingTypeInt64: case YYEncodingTypeUInt64: case YYEncodingTypeFloat: case YYEncodingTypeDouble: case YYEncodingTypeLongDouble: return YES; default: return NO; &#125;&#125;// 函数3: 根据一个id类型的对象创建一个NSNumber类型的对象static force_inline NSNumber *YYNSNumberCreateFromID(__unsafe_unretained id value) &#123; static NSCharacterSet *dot; static NSDictionary *dic; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; dot = [NSCharacterSet characterSetWithRange:NSMakeRange('.', 1)]; dic = @&#123;@"TRUE" : @(YES), @"True" : @(YES), @"true" : @(YES), @"FALSE" : @(NO), @"False" : @(NO), @"false" : @(NO), @"YES" : @(YES), @"Yes" : @(YES), @"yes" : @(YES), @"NO" : @(NO), @"No" : @(NO), @"no" : @(NO), @"NIL" : (id)kCFNull, @"Nil" : (id)kCFNull, @"nil" : (id)kCFNull, @"NULL" : (id)kCFNull, @"Null" : (id)kCFNull, @"null" : (id)kCFNull, @"(NULL)" : (id)kCFNull, @"(Null)" : (id)kCFNull, @"(null)" : (id)kCFNull, @"&lt;NULL&gt;" : (id)kCFNull, @"&lt;Null&gt;" : (id)kCFNull, @"&lt;null&gt;" : (id)kCFNull&#125;; &#125;); // kCFNull单例 if (!value || value == (id)kCFNull) return nil; // NSNumber直接返回 if ([value isKindOfClass:[NSNumber class]]) return value; // NSString, 取出dic中对应的值 if ([value isKindOfClass:[NSString class]]) &#123; NSNumber *num = dic[value]; if (num) &#123; if (num == (id)kCFNull) return nil; return num; &#125; // 这个字符串中含有 ".", 例如 @"12.344" if ([(NSString *)value rangeOfCharacterFromSet:dot].location != NSNotFound) &#123; const char *cstring = ((NSString *)value).UTF8String; if (!cstring) return nil; double num = atof(cstring); // isfinite()测试某个浮点数是不是有限的数 // isinf()测试某个浮点数是否是无限大 // isnan()测试某个浮点数是否是 非数字 if (isnan(num) || isinf(num)) return nil; // num是否是无限大或者是否是非数字 return @(num); // return @(12.344); &#125; else &#123; // 字符串中没有".", 例如 @"1323" const char *cstring = ((NSString *)value).UTF8String;// 转化为C字符串"1323" if (!cstring) return nil; // atoi函数：将字符串转化为int类型变量. atol函数：将字符串转化为long类型变量. // atoll函数：将字符串转化为long long类型变量.atof函数：将字符串转化为double类型变量 return @(atoll(cstring)); // 转换为long long类型变量 &#125; &#125; return nil;&#125;// 函数4: 将字符串转化为日期NSDate// 根据string的length判断需要调用哪一个block, 为了避免效率较低的if-else, 采用block数组的形式, string的length正好对应blocks数组的索引, 即查表法, 效率得到提升.// YYNSDateParseBlock parser = blocks[string.length];static force_inline NSDate *YYNSDateFromString(__unsafe_unretained NSString *string) &#123; typedef NSDate* (^YYNSDateParseBlock)(NSString *string); #define kParserNum 34 // 定义一个block数组, 数组是C数组 static YYNSDateParseBlock blocks[kParserNum + 1] = &#123;0&#125;; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; &#123; /* 2014-01-20 // Google , 10个字符, 对应blocks[10] */ NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter.dateFormat = @"yyyy-MM-dd"; blocks[10] = ^(NSString *string) &#123; return [formatter dateFromString:string]; &#125;; &#125; &#123; /* 2014-01-20 12:24:48 // 19个字符, 对应blocks[19] 2014-01-20T12:24:48 // Google, 19个字符, 对应blocks[19] 2014-01-20 12:24:48.000 // 23个字符, 对应blocks[23] 2014-01-20T12:24:48.000 // 23个字符, 对应blocks[23] */ NSDateFormatter *formatter1 = [[NSDateFormatter alloc] init]; formatter1.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter1.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter1.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss"; NSDateFormatter *formatter2 = [[NSDateFormatter alloc] init]; formatter2.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter2.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter2.dateFormat = @"yyyy-MM-dd HH:mm:ss"; NSDateFormatter *formatter3 = [[NSDateFormatter alloc] init]; formatter3.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter3.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter3.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss.SSS"; NSDateFormatter *formatter4 = [[NSDateFormatter alloc] init]; formatter4.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter4.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter4.dateFormat = @"yyyy-MM-dd HH:mm:ss.SSS"; blocks[19] = ^(NSString *string) &#123; if ([string characterAtIndex:10] == 'T') &#123;// 2014-01-20T12:24:48 return [formatter1 dateFromString:string]; &#125; else &#123;// 2014-01-20 12:24:48 return [formatter2 dateFromString:string]; &#125; &#125;; blocks[23] = ^(NSString *string) &#123; if ([string characterAtIndex:10] == 'T') &#123;// 2014-01-20T12:24:48.000 return [formatter3 dateFromString:string]; &#125; else &#123;// 2014-01-20 12:24:48.000 return [formatter4 dateFromString:string]; &#125; &#125;; &#125; &#123; /* 2014-01-20T12:24:48Z // Github, Apple 2014-01-20T12:24:48+0800 // Facebook 2014-01-20T12:24:48+12:00 // Google 2014-01-20T12:24:48.000Z 2014-01-20T12:24:48.000+0800 2014-01-20T12:24:48.000+12:00 */ NSDateFormatter *formatter = [NSDateFormatter new]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ssZ"; NSDateFormatter *formatter2 = [NSDateFormatter new]; formatter2.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter2.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss.SSSZ"; blocks[20] = ^(NSString *string) &#123; return [formatter dateFromString:string]; &#125;; blocks[24] = ^(NSString *string) &#123; return [formatter dateFromString:string]?: [formatter2 dateFromString:string]; &#125;; blocks[25] = ^(NSString *string) &#123; return [formatter dateFromString:string]; &#125;; blocks[28] = ^(NSString *string) &#123; return [formatter2 dateFromString:string]; &#125;; blocks[29] = ^(NSString *string) &#123; return [formatter2 dateFromString:string]; &#125;; &#125; &#123; /* Fri Sep 04 00:12:21 +0800 2015 // Weibo, Twitter Fri Sep 04 00:12:21.000 +0800 2015 */ NSDateFormatter *formatter = [NSDateFormatter new]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter.dateFormat = @"EEE MMM dd HH:mm:ss Z yyyy"; NSDateFormatter *formatter2 = [NSDateFormatter new]; formatter2.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter2.dateFormat = @"EEE MMM dd HH:mm:ss.SSS Z yyyy"; blocks[30] = ^(NSString *string) &#123; return [formatter dateFromString:string]; &#125;; blocks[34] = ^(NSString *string) &#123; return [formatter2 dateFromString:string]; &#125;; &#125; &#125;); if (!string) return nil; if (string.length &gt; kParserNum) return nil; YYNSDateParseBlock parser = blocks[string.length]; if (!parser) return nil; return parser(string); #undef kParserNum&#125;// 函数5: 获取NSBlock类static force_inline Class YYNSBlockClass() &#123; static Class cls; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; void (^block)(void) = ^&#123;&#125;; cls = ((NSObject *)block).class; while (class_getSuperclass(cls) != [NSObject class]) &#123; cls = class_getSuperclass(cls); &#125; &#125;); return cls; // current is "NSBlock"&#125;// 函数6: 获取ISO NSDateFormatter/** example: 2010-07-09T16:13:30+12:00 2011-01-11T11:11:11+0000 2011-01-26T19:06:43Z length: 20/24/25 */static force_inline NSDateFormatter *YYISODateFormatter() &#123; static NSDateFormatter *formatter = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; formatter = [[NSDateFormatter alloc] init]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ssZ"; &#125;); return formatter;&#125;/*&#123; "version": "1.1", "object": &#123; "data": &#123; "phone": "12332123" &#125; &#125;&#125; */// 函数7: 根据keypath从字典中获取对应的值(这个值是id类型)// keyPaths: @[@"object", @"data", @"phone"] 对应的值是 @"12332123"// keyPaths: @[@"object", @"data"] 对应的值是 @&#123;@"phone": @"12332123"&#125;static force_inline id YYValueForKeyPath(__unsafe_unretained NSDictionary *dic, __unsafe_unretained NSArray *keyPaths) &#123; id value = nil; for (NSUInteger i = 0, max = keyPaths.count; i &lt; max; i++) &#123; value = dic[keyPaths[i]]; if (i + 1 &lt; max) &#123; if ([value isKindOfClass:[NSDictionary class]]) &#123; dic = value; &#125; else &#123; return nil; &#125; &#125; &#125; return value;&#125;// 函数8: 根据可变的keypath从字典中获取对应的值(这个值是id类型)// multiKeys: @[ @[@"object", @"data"], @"phone"] 对应的值是 @&#123;@"phone": @"12332123"&#125;// multiKeys: @[@"object", @"data"] 对应的值是 @&#123;@"data": @&#123;@"phone": @"12332123"&#125;&#125;static force_inline id YYValueForMultiKeys(__unsafe_unretained NSDictionary *dic, __unsafe_unretained NSArray *multiKeys) &#123; id value = nil; for (NSString *key in multiKeys) &#123; if ([key isKindOfClass:[NSString class]]) &#123; value = dic[key]; if (value) break; &#125; else &#123; value = YYValueForKeyPath(dic, (NSArray *)key); if (value) break; &#125; &#125; return value;&#125;// 函数9: 从模型中的属性(_YYModelPropertyMeta类型)中获取NSNumberstatic force_inline NSNumber *ModelCreateNumberFromProperty(__unsafe_unretained id model, __unsafe_unretained _YYModelPropertyMeta *meta) &#123; switch (meta-&gt;_type &amp; YYEncodingTypeMask) &#123; case YYEncodingTypeBool: &#123; return @(((bool (*)(id, SEL))(void *) objc_msgSend)((id)model, meta-&gt;_getter));&#125; //...... &#125;&#125;// 函数10: 对模型中的属性(_YYModelPropertyMeta类型)设值. 和函数9类似static force_inline void ModelSetNumberToProperty(__unsafe_unretained id model, __unsafe_unretained NSNumber *num, __unsafe_unretained _YYModelPropertyMeta *meta) &#123; switch (meta-&gt;_type &amp; YYEncodingTypeMask) &#123; case YYEncodingTypeBool: &#123; ((void (*)(id, SEL, bool))(void *) objc_msgSend)((id)model, meta-&gt;_setter, num.boolValue); &#125; break; // ...... &#125;&#125;// 函数11: 对模型中的属性(_YYModelPropertyMeta类型)设值static void ModelSetValueForProperty(__unsafe_unretained id model, __unsafe_unretained id value, __unsafe_unretained _YYModelPropertyMeta *meta) &#123; //......&#125;typedef struct &#123; void *modelMeta; ///&lt; _YYModelMeta void *model; ///&lt; id (self) void *dictionary; ///&lt; NSDictionary (json)&#125; ModelSetContext;// 函数12: 对模型(_context.modelMeta and _context.model)设置 key-value键值对static void ModelSetWithDictionaryFunction(const void *_key, const void *_value, void *_context) &#123; ModelSetContext *context = _context; __unsafe_unretained _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta); __unsafe_unretained _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge id)(_key)]; __unsafe_unretained id model = (__bridge id)(context-&gt;model); while (propertyMeta) &#123; if (propertyMeta-&gt;_setter) &#123; ModelSetValueForProperty(model, (__bridge __unsafe_unretained id)_value, propertyMeta); &#125; // 有多个属性映射到同一个 key 则指向下一个模型属性元 propertyMeta = propertyMeta-&gt;_next; &#125;;&#125;/** Apply function for model property meta, to set dictionary to model. @param _propertyMeta should not be nil, _YYModelPropertyMeta. @param _context _context.model and _context.dictionary should not be nil. */// 函数13:static void ModelSetWithPropertyMetaArrayFunction(const void *_propertyMeta, void *_context) &#123; ModelSetContext *context = _context; __unsafe_unretained NSDictionary *dictionary = (__bridge NSDictionary *)(context-&gt;dictionary); __unsafe_unretained _YYModelPropertyMeta *propertyMeta = (__bridge _YYModelPropertyMeta *)(_propertyMeta); if (!propertyMeta-&gt;_setter) return; id value = nil; if (propertyMeta-&gt;_mappedToKeyArray) &#123; value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;_mappedToKeyArray); &#125; else if (propertyMeta-&gt;_mappedToKeyPath) &#123; value = YYValueForKeyPath(dictionary, propertyMeta-&gt;_mappedToKeyPath); &#125; else &#123; value = [dictionary objectForKey:propertyMeta-&gt;_mappedToKey]; &#125; if (value) &#123; __unsafe_unretained id model = (__bridge id)(context-&gt;model); ModelSetValueForProperty(model, value, propertyMeta); &#125;&#125;/** Returns a valid JSON object (NSArray/NSDictionary/NSString/NSNumber/NSNull), or nil if an error occurs. @param model Model, can be nil. @return JSON object, nil if an error occurs. */// 函数14: 模型转 jsonstatic id ModelToJSONObjectRecursive(NSObject *model) &#123; if (!model || model == (id)kCFNull) return model; if ([model isKindOfClass:[NSString class]]) return model; if ([model isKindOfClass:[NSNumber class]]) return model; if ([model isKindOfClass:[NSDictionary class]]) &#123; if ([NSJSONSerialization isValidJSONObject:model]) return model; NSMutableDictionary *newDic = [NSMutableDictionary new]; [((NSDictionary *)model) enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) &#123; NSString *stringKey = [key isKindOfClass:[NSString class]] ? key : key.description; if (!stringKey) return; id jsonObj = ModelToJSONObjectRecursive(obj); if (!jsonObj) jsonObj = (id)kCFNull; newDic[stringKey] = jsonObj; &#125;]; return newDic; &#125; if ([model isKindOfClass:[NSSet class]]) &#123; NSArray *array = ((NSSet *)model).allObjects; if ([NSJSONSerialization isValidJSONObject:array]) return array; NSMutableArray *newArray = [NSMutableArray new]; for (id obj in array) &#123; if ([obj isKindOfClass:[NSString class]] || [obj isKindOfClass:[NSNumber class]]) &#123; [newArray addObject:obj]; &#125; else &#123; id jsonObj = ModelToJSONObjectRecursive(obj); if (jsonObj &amp;&amp; jsonObj != (id)kCFNull) [newArray addObject:jsonObj]; &#125; &#125; return newArray; &#125; if ([model isKindOfClass:[NSArray class]]) &#123; if ([NSJSONSerialization isValidJSONObject:model]) return model; NSMutableArray *newArray = [NSMutableArray new]; for (id obj in (NSArray *)model) &#123; if ([obj isKindOfClass:[NSString class]] || [obj isKindOfClass:[NSNumber class]]) &#123; [newArray addObject:obj]; &#125; else &#123; id jsonObj = ModelToJSONObjectRecursive(obj); if (jsonObj &amp;&amp; jsonObj != (id)kCFNull) [newArray addObject:jsonObj]; &#125; &#125; return newArray; &#125; if ([model isKindOfClass:[NSURL class]]) return ((NSURL *)model).absoluteString; if ([model isKindOfClass:[NSAttributedString class]]) return ((NSAttributedString *)model).string; if ([model isKindOfClass:[NSDate class]]) return [YYISODateFormatter() stringFromDate:(id)model]; if ([model isKindOfClass:[NSData class]]) return nil; _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model class]]; if (!modelMeta || modelMeta-&gt;_keyMappedCount == 0) return nil; NSMutableDictionary *result = [[NSMutableDictionary alloc] initWithCapacity:64]; __unsafe_unretained NSMutableDictionary *dic = result; // avoid retain and release in block [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123; if (!propertyMeta-&gt;_getter) return; id value = nil; if (propertyMeta-&gt;_isCNumber) &#123; value = ModelCreateNumberFromProperty(model, propertyMeta); &#125; else if (propertyMeta-&gt;_nsType) &#123; id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = ModelToJSONObjectRecursive(v); &#125; else &#123; switch (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123; case YYEncodingTypeObject: &#123; id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = ModelToJSONObjectRecursive(v); if (value == (id)kCFNull) value = nil; &#125; break; case YYEncodingTypeClass: &#123; Class v = ((Class (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = v ? NSStringFromClass(v) : nil; &#125; break; case YYEncodingTypeSEL: &#123; SEL v = ((SEL (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = v ? NSStringFromSelector(v) : nil; &#125; break; default: break; &#125; &#125; if (!value) return; if (propertyMeta-&gt;_mappedToKeyPath) &#123; NSMutableDictionary *superDic = dic; NSMutableDictionary *subDic = nil; for (NSUInteger i = 0, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123; NSString *key = propertyMeta-&gt;_mappedToKeyPath[i]; if (i + 1 == max) &#123; // end if (!superDic[key]) superDic[key] = value; break; &#125; subDic = superDic[key]; if (subDic) &#123; if ([subDic isKindOfClass:[NSDictionary class]]) &#123; subDic = subDic.mutableCopy; superDic[key] = subDic; &#125; else &#123; break; &#125; &#125; else &#123; subDic = [NSMutableDictionary new]; superDic[key] = subDic; &#125; superDic = subDic; subDic = nil; &#125; &#125; else &#123; if (!dic[propertyMeta-&gt;_mappedToKey]) &#123; dic[propertyMeta-&gt;_mappedToKey] = value; &#125; &#125; &#125;]; if (modelMeta-&gt;_hasCustomTransformToDictionary) &#123; // 当 Model 转为 JSON 完成后，该方法会被调用。 // 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。 // 你也可以在这里做一些自动转换不能完成的工作。 BOOL suc = [((id&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic]; if (!suc) return nil; &#125; return result;&#125;/// 函数15: Add indent to string (exclude first line)static NSMutableString *ModelDescriptionAddIndent(NSMutableString *desc, NSUInteger indent) &#123; for (NSUInteger i = 0, max = desc.length; i &lt; max; i++) &#123; unichar c = [desc characterAtIndex:i]; if (c == '\n') &#123; for (NSUInteger j = 0; j &lt; indent; j++) &#123; [desc insertString:@" " atIndex:i + 1]; &#125; i += indent * 4; max += indent * 4; &#125; &#125; return desc;&#125;/// 函数16: 根据model生成一个描述字符串static NSString *ModelDescription(NSObject *model) &#123; static const int kDescMaxLength = 100; if (!model) return @"&lt;nil&gt;"; if (model == (id)kCFNull) return @"&lt;null&gt;"; if (![model isKindOfClass:[NSObject class]]) return [NSString stringWithFormat:@"%@",model]; _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:model.class]; switch (modelMeta-&gt;_nsType) &#123; case YYEncodingTypeNSString: case YYEncodingTypeNSMutableString: &#123; return [NSString stringWithFormat:@"\"%@\"",model]; &#125; case YYEncodingTypeNSValue: case YYEncodingTypeNSData: case YYEncodingTypeNSMutableData: &#123; NSString *tmp = model.description; if (tmp.length &gt; kDescMaxLength) &#123; tmp = [tmp substringToIndex:kDescMaxLength]; tmp = [tmp stringByAppendingString:@"..."]; &#125; return tmp; &#125; case YYEncodingTypeNSNumber: case YYEncodingTypeNSDecimalNumber: case YYEncodingTypeNSDate: case YYEncodingTypeNSURL: &#123; return [NSString stringWithFormat:@"%@",model]; &#125; case YYEncodingTypeNSSet: case YYEncodingTypeNSMutableSet: &#123; model = ((NSSet *)model).allObjects; &#125; // no break case YYEncodingTypeNSArray: case YYEncodingTypeNSMutableArray: &#123; NSArray *array = (id)model; NSMutableString *desc = [NSMutableString new]; if (array.count == 0) &#123; return [desc stringByAppendingString:@"[]"]; &#125; else &#123; [desc appendFormat:@"[\n"]; for (NSUInteger i = 0, max = array.count; i &lt; max; i++) &#123; NSObject *obj = array[i]; [desc appendString:@" "]; [desc appendString:ModelDescriptionAddIndent(ModelDescription(obj).mutableCopy, 1)]; [desc appendString:(i + 1 == max) ? @"\n" : @";\n"]; &#125; [desc appendString:@"]"]; return desc; &#125; &#125; case YYEncodingTypeNSDictionary: case YYEncodingTypeNSMutableDictionary: &#123; NSDictionary *dic = (id)model; NSMutableString *desc = [NSMutableString new]; if (dic.count == 0) &#123; return [desc stringByAppendingString:@"&#123;&#125;"]; &#125; else &#123; NSArray *keys = dic.allKeys; [desc appendFormat:@"&#123;\n"]; for (NSUInteger i = 0, max = keys.count; i &lt; max; i++) &#123; NSString *key = keys[i]; NSObject *value = dic[key]; [desc appendString:@" "]; [desc appendFormat:@"%@ = %@",key, ModelDescriptionAddIndent(ModelDescription(value).mutableCopy, 1)]; [desc appendString:(i + 1 == max) ? @"\n" : @";\n"]; &#125; [desc appendString:@"&#125;"]; &#125; return desc; &#125; default: &#123; NSMutableString *desc = [NSMutableString new]; [desc appendFormat:@"&lt;%@: %p&gt;", model.class, model]; if (modelMeta-&gt;_allPropertyMetas.count == 0) return desc; // sort property names NSArray *properties = [modelMeta-&gt;_allPropertyMetas sortedArrayUsingComparator:^NSComparisonResult(_YYModelPropertyMeta *p1, _YYModelPropertyMeta *p2) &#123; return [p1-&gt;_name compare:p2-&gt;_name]; &#125;]; [desc appendFormat:@" &#123;\n"]; for (NSUInteger i = 0, max = properties.count; i &lt; max; i++) &#123; _YYModelPropertyMeta *property = properties[i]; NSString *propertyDesc; if (property-&gt;_isCNumber) &#123; NSNumber *num = ModelCreateNumberFromProperty(model, property); propertyDesc = num.stringValue; &#125; else &#123; switch (property-&gt;_type &amp; YYEncodingTypeMask) &#123; case YYEncodingTypeObject: &#123; id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, property-&gt;_getter); propertyDesc = ModelDescription(v); if (!propertyDesc) propertyDesc = @"&lt;nil&gt;"; &#125; break; case YYEncodingTypeClass: &#123; id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, property-&gt;_getter); propertyDesc = ((NSObject *)v).description; if (!propertyDesc) propertyDesc = @"&lt;nil&gt;"; &#125; break; case YYEncodingTypeSEL: &#123; SEL sel = ((SEL (*)(id, SEL))(void *) objc_msgSend)((id)model, property-&gt;_getter); if (sel) propertyDesc = NSStringFromSelector(sel); else propertyDesc = @"&lt;NULL&gt;"; &#125; break; case YYEncodingTypeBlock: &#123; id block = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, property-&gt;_getter); propertyDesc = block ? ((NSObject *)block).description : @"&lt;nil&gt;"; &#125; break; case YYEncodingTypeCArray: case YYEncodingTypeCString: case YYEncodingTypePointer: &#123; void *pointer = ((void* (*)(id, SEL))(void *) objc_msgSend)((id)model, property-&gt;_getter); propertyDesc = [NSString stringWithFormat:@"%p",pointer]; &#125; break; case YYEncodingTypeStruct: case YYEncodingTypeUnion: &#123; NSValue *value = [model valueForKey:property-&gt;_name]; propertyDesc = value ? value.description : @"&#123;unknown&#125;"; &#125; break; default: propertyDesc = @"&lt;unknown&gt;"; &#125; &#125; propertyDesc = ModelDescriptionAddIndent(propertyDesc.mutableCopy, 1); [desc appendFormat:@" %@ = %@",property-&gt;_name, propertyDesc]; [desc appendString:(i + 1 == max) ? @"\n" : @";\n"]; &#125; [desc appendFormat:@"&#125;"]; return desc; &#125; &#125;&#125; 关键点 1.强制内联 #define force_inline __inline__ __attribute__((always_inline)) 2.使用代码块, 节省许多变量名 &#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init];&#125;&#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init];&#125; 3.使用block数组 typedef NSDate* (^YYNSDateParseBlock)(NSString *string);// 定义一个block数组static YYNSDateParseBlock blocks[35] = &#123;0&#125;; 4.获取NSBlock类 void (^block)(void) = ^&#123;&#125;;cls = ((NSObject *)block).class;while (class_getSuperclass(cls) != [NSObject class]) &#123; cls = class_getSuperclass(cls);&#125; 5.函数参数使用__unsafe_unretained 在 ARC 条件下，默认声明的对象是 __strong 类型的，赋值时有可能会产生retain/release调用，如果一个变量在其生命周期内不会被释放，则使用__unsafe_unretained `会节省很大的开销。 访问具有 __weak属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 __weak属性。 创建和使用对象时，要尽量避免对象进入autoreleasepool，以避免额外的资源开销。 6.for循环中定义变量, 使用unsigned for (unsigned i = 0, max = keyPaths.count; i &lt; max; i++) &#123;&#125; 7.可变量创建静态不变量, 静态常量配合dispatch_once使用 static NSSet *types = nil;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;NSMutableSet *set = [NSMutableSet new]; types = set;&#125;); 8.线程安全的缓存字典 static id cacheWithKey(NSString *key) &#123; if (!key) return nil; static CFMutableDictionaryRef cache; static dispatch_once_t onceToken; static dispatch_semaphore_t lock; dispatch_once(&amp;onceToken, ^&#123; cache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); lock = dispatch_semaphore_create(1); &#125;); dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); id obj = CFDictionaryGetValue(cache, (__bridge const void *)(key)); dispatch_semaphore_signal(lock); if (!obj) &#123; obj = [NSObject new]; // Other operation. if (obj) &#123; dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); CFDictionarySetValue(cache, (__bridge const void *)(key), (__bridge const void *)(obj)); dispatch_semaphore_signal(lock); &#125; &#125; return obj;&#125; 9.消息发送调用格式 ((int32_t (*)(id, SEL))(void *) objc_msgSend)((id)model, meta-&gt;_getter) 10.NSNull的单例kCFNull, 推荐使用, 而不是创建[NSNull null] NSNull *null1 = (id)kCFNull;NSNull *null2 = [NSNull null];Class class = Nil;NSDate *date = nil;char *p = NULL; 11.YYClassIvarInfo中的 name 和 typeEncoding 属性都用 strong 修饰。NSString 这类属性在确定其不会在初始化之后被修改的情况下，使用 strong 做一次单纯的强引用在性能上讲比 copy 要高一些。 12.NSString转C字符串 const char *cstring = ((NSString *)value).UTF8String; 实践 YYModel 最核心的便是通过遍历模型的所有属性，根据字典值来调用属性的 setter 方法。没有使用效率低下的 KVC（效率低下的原因可能是需要对方法进行搜索吧，有空深究）。鉴于此，用了300行代码简单写了一个字典转模型的玩具，权当做是读完 YYModel 的实践吧。试了一下，效果还可以😂。 @protocol YAModelProtocol &lt;NSObject&gt;@optional;+ (NSDictionary &lt;NSString *, NSString *&gt; *)customPropertyKey;+ (NSDictionary &lt;NSString *, Class&gt;*)classInArray;@end@interface NSObject (YAModel)+ (instancetype)ya_modelWithDictionary:(NSDictionary *)dict;+ (instancetype)ya_modelWithJSON:(NSData *)data;+ (NSArray *)ya_modelArrayWithKeyValuesArray:(NSArray &lt;NSDictionary *&gt;*)dictArray;@end // 编码类型typedef NS_OPTIONS(NSUInteger, YAType) &#123; YATypeMask = 0xFF, YATypeUnknown = 0, YATypeBOOL = 1, YATypeNSInteger = 2, YATypeNSUInteger = 3, YATypeCGFloat = 4, YATypeObject = 5, YATypeDate = 6, YATypeClass = 7, YATypeSEL = 8, YATypeArray = 9, YATypeMutableArray = 10, YATypeDictionary = 11, YATypeMutableDictionary = 12, YATypeSet = 13, YATypeMutableSet = 14, YATypeString = 15, YATypeMutableString = 16, YATypeData = 17, YATypeNumber = 18, YATypeDecimalNumber = 19,&#125;;@implementation NSObject (YAModel)static NSDictionary *classArrayDict = nil;+ (instancetype)ya_modelWithDictionary:(NSDictionary *)dict &#123; if (!dict || ![dict isKindOfClass:NSDictionary.class]) return nil; NSDictionary *propertyList = PropertyList(self); id obj = [self new]; ObjSetWithKeyValueList(obj, propertyList, dict); classArrayDict = nil; // Clean memory. return obj;&#125;+ (instancetype)ya_modelWithJSON:(NSData *)data &#123; if (!data || ![data isKindOfClass:NSData.class]) return nil; id json = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]; if ([json isKindOfClass:NSDictionary.class]) &#123; return [self ya_modelWithDictionary:json]; &#125; return nil;&#125;+ (NSArray *)ya_modelArrayWithKeyValuesArray:(NSArray&lt;NSDictionary *&gt; *)dictArray &#123; if (!dictArray || ![dictArray isKindOfClass:NSArray.class]) return nil; NSMutableArray *tmp = [NSMutableArray arrayWithCapacity:dictArray.count]; [dictArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([obj isKindOfClass:NSDictionary.class]) &#123; id model = [[self class] ya_modelWithDictionary:obj]; [tmp addObject:model]; &#125; &#125;]; return [NSArray arrayWithArray:tmp] ?: nil;&#125;// 获取属性列表 key:属性名 value: 属性类型static NSDictionary *PropertyList(Class cls) &#123; if (!cls) return nil; unsigned int count; objc_property_t *properties = class_copyPropertyList(cls, &amp;count); NSMutableDictionary *tempDict = [NSMutableDictionary new]; for(int i = 0; i &lt; count; i++) &#123; objc_property_t property = properties[i]; NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)]; NSString *propertyAttr = [NSString stringWithUTF8String:property_getAttributes(property)]; NSString *type = [propertyAttr substringWithRange:NSMakeRange(1, 1)]; if ([type isEqualToString:@"@"]) &#123; NSArray *components = [propertyAttr componentsSeparatedByString:@"\""]; if (components.count &gt; 2) &#123; Class propCls = NSClassFromString(components[1]); if (propCls == NSDate.class) &#123; type = @"1"; &#125; else if (propCls == NSArray.class) &#123; type = @"2"; &#125; else if (propCls == NSMutableArray.class) &#123; type = @"3"; &#125; else if (propCls == NSDictionary.class) &#123; type = @"4"; &#125; else if (propCls == NSMutableDictionary.class) &#123; type = @"5"; &#125; else if (propCls == NSSet.class) &#123; type = @"6"; &#125; else if (propCls == NSMutableSet.class) &#123; type = @"7"; &#125; else if (propCls == NSString.class) &#123; type = @"8"; &#125; else if (propCls == NSMutableString.class) &#123; type = @"9"; &#125; else if (propCls == NSData.class) &#123; type = @"10"; &#125; else if (propCls == NSNumber.class) &#123; type = @"11"; &#125; else if (propCls == NSDecimalNumber.class) &#123; type = @"12"; &#125; else if (propCls == NSObject.class) &#123; type = @"@"; &#125; else &#123; type = components[1]; &#125; &#125; &#125; NSNumber *myType = TypeForProperty(type); [tempDict setObject:myType forKey:propertyName]; if (myType.integerValue == 0) &#123; [tempDict setObject:type forKey:propertyName]; &#125; &#125; free(properties); return [NSDictionary dictionaryWithDictionary:tempDict];&#125;static NSNumber *TypeForProperty(NSString *type) &#123; static NSDictionary *_SELDictionary = nil;; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _SELDictionary = @&#123; @"B": @(YATypeBOOL), @"q": @(YATypeNSInteger), @"Q": @(YATypeNSUInteger), @"d": @(YATypeCGFloat), @"#": @(YATypeClass), @":": @(YATypeSEL), @"@": @(YATypeObject), @"1": @(YATypeDate), @"2": @(YATypeArray), @"3": @(YATypeMutableArray), @"4": @(YATypeDictionary), @"5": @(YATypeMutableDictionary), @"6": @(YATypeSet), @"7": @(YATypeMutableSet), @"8": @(YATypeString), @"9": @(YATypeMutableString), @"10": @(YATypeData), @"11": @(YATypeNumber), @"12": @(YATypeDecimalNumber), &#125;; &#125;); return _SELDictionary[type] ?: @(YATypeUnknown);&#125;static void ObjSetWithArray(Class cls, NSDictionary *propertyDict, NSArray **keyValueArray) &#123; NSMutableArray *tmpArray = [NSMutableArray array]; [*keyValueArray enumerateObjectsUsingBlock:^(id keyValue, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([keyValue isKindOfClass:NSDictionary.class]) &#123; id obj = [cls new]; ObjSetWithKeyValueList(obj, PropertyList([obj class]), keyValue); [tmpArray addObject:obj]; &#125; &#125;]; *keyValueArray = [NSArray arrayWithArray:tmpArray];&#125;static void ObjSetWithKeyValueList(id obj, NSDictionary *propertyDict, NSDictionary *dict) &#123; Class cls = [obj class]; NSDictionary *customPropertyKeyDict = nil; if ([cls respondsToSelector:@selector(customPropertyKey)]) &#123; customPropertyKeyDict = [cls customPropertyKey]; &#125; if ([cls respondsToSelector:@selector(classInArray)] &amp;&amp; !classArrayDict) &#123; classArrayDict = [cls classInArray]; &#125; [propertyDict.allKeys enumerateObjectsUsingBlock:^(NSString *name, NSUInteger idx, BOOL * _Nonnull stop) &#123; SEL setter = SetterSelectorFromString(name); id value = nil; if (customPropertyKeyDict[name]) &#123; value = customPropertyKeyDict[name]; &#125; else &#123; value = dict[name]; &#125; id propType = propertyDict[name]; YAType type = [propType integerValue]; if (value) &#123; switch (type &amp; YATypeMask) &#123; case YATypeBOOL: &#123; ((void (*)(id, SEL, bool))(void *) objc_msgSend)((id)obj, setter, [value boolValue]); &#125; break; case YATypeNSInteger: &#123; ((void (*)(id, SEL, int64_t))(void *) objc_msgSend)((id)obj, setter, (int64_t)[value longLongValue]); &#125; break; case YATypeNSUInteger: &#123; ((void (*)(id, SEL, uint64_t))(void *) objc_msgSend)((id)obj, setter, (uint64_t)[value unsignedLongLongValue]); &#125; break; case YATypeCGFloat: &#123; long double d = [value doubleValue]; if (isnan(d) || isinf(d)) d = 0; ((void (*)(id, SEL, long double))(void *) objc_msgSend)((id)obj, setter, (long double)d); &#125; break; case YATypeDecimalNumber: &#123; if ([value isKindOfClass:NSNumber.class]) &#123; NSDecimalNumber *decNum = [NSDecimalNumber decimalNumberWithDecimal:[value decimalValue]]; ((void (*)(id, SEL, NSDecimalNumber *))(void *) objc_msgSend)((id)obj, setter, decNum); &#125; &#125; break; case YATypeClass: &#123; ((void (*)(id, SEL, Class))(void *) objc_msgSend)((id)obj, setter, NSClassFromString(value)); &#125; break; case YATypeSEL:&#123; ((void (*)(id, SEL, SEL))(void *) objc_msgSend)((id)obj, setter, NSSelectorFromString(value)); &#125; break; case YATypeDate:&#123; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, DateFromString(value)); &#125; break; case YATypeArray: &#123; Class cls = classArrayDict[name]; if (cls) &#123; ObjSetWithArray(cls, PropertyList(cls), &amp;value); &#125; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; case YATypeMutableArray: &#123; NSString *clsStr = classArrayDict[name]; if (clsStr) &#123; Class cls = NSClassFromString(clsStr); ObjSetWithArray(cls, PropertyList(cls), &amp;value); &#125; value = [NSMutableArray arrayWithArray:value]; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; case YATypeSet: &#123; value = [NSSet setWithArray:value]; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; case YATypeMutableSet: &#123; value = [NSMutableSet setWithArray:value]; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; case YATypeMutableString: case YATypeMutableDictionary: &#123; value = [value mutableCopy]; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; case YATypeString: case YATypeDictionary: case YATypeNumber: case YATypeUnknown: case YATypeObject: &#123; if (type == YATypeUnknown &amp;&amp; [propType isKindOfClass:NSString.class]) &#123; // 嵌套模型 Class cls = NSClassFromString(propType); if (cls &amp;&amp; [value isKindOfClass:NSDictionary.class]) &#123; id obj = [cls new]; ObjSetWithKeyValueList(obj, PropertyList(cls), value); value = obj; &#125; &#125; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)obj, setter, value); &#125; break; default: break; &#125; &#125; &#125;];&#125;// name ==&gt; setName:static SEL SetterSelectorFromString(NSString *str) &#123; if (!str || str.length &lt;= 0) return nil; NSString *result = [NSString stringWithFormat:@"set%@%@:", [str substringToIndex:1].uppercaseString, [str substringFromIndex:1]]; return NSSelectorFromString(result);&#125;// date string ==&gt; data // @"2016-7-16 09:33:22"static NSDate *DateFromString(NSString *string) &#123; typedef NSDate* (^DateParseBlock)(NSString *string); static DateParseBlock blocks[20] = &#123;0&#125;; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // @"2016-07-16 09:33:22" // 19个字符, 对应blocks[19] NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; formatter.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter.dateFormat = @"yyyy-MM-dd HH:mm:ss"; blocks[19] = ^(NSString *string) &#123; return [formatter dateFromString:string]; &#125;; &#125;); if (!string || string.length &gt; 19) return nil; DateParseBlock parser = blocks[string.length]; if (!parser) return nil; return parser(string);&#125;@end 具体源码放在了我的代码工具库里，YAKit：https://github.com/ChenYalun/YAKit/tree/master/Util/Model 参考资料 https://juejin.im/post/5a097435f265da431769a49c https://juejin.im/post/5a1296e36fb9a044fb075d5e https://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/ https://blog.csdn.net/game3108/article/details/52416868]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PerformSelector原理]]></title>
    <url>%2F2018%2F09%2F30%2FPerformSelector%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[PerformSelector相关知识。 performSelector系列是个很神奇的存在，能传参，能延迟，还能子线程调，能让任意对象执行任意方法，读了gnustep中有关performSelector的源码后，这里做个总结。 源码地址：https://github.com/gnustep/libs-base/releases/tag/base-1_25_1 基本最基本的performSelector有三个接口方法，可以不传参，传一个参数以及传两个参数。 - (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2; 使用示例: // 无参 id obj1 = [self performSelector:@selector(printString)];// 一个参数id obj2 = [self performSelector:@selector(printString:) withObject:@"string"];// 两个参数id obj3 = [self performSelector:@selector(printString:str2:) withObject:@"string" withObject:@&#123;@"key": @(3)&#125;]; 以传递两个参数为例，它的实现是这样的： - (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2 &#123; IMP msg; if (aSelector == 0) &#123; [NSException raise: NSInvalidArgumentException format: @"%@ null selector given", NSStringFromSelector(_cmd)]; &#125; msg = objc_msg_lookup(self, aSelector); if (!msg) &#123; [NSException raise: NSGenericException format: @"invalid selector '%s' passed to %s", sel_getName(aSelector), sel_getName(_cmd)]; return nil; &#125; return (*msg)(self, aSelector, object1, object2);&#125; 可见就是根据方法名，使用Runtime中的objc_msg_lookup()获取到函数指针IMP，进而进行函数调用。当然，还有对方法名和函数指针的容错处理。 内存泄露performSelector系列颇具有动态性，当使用这三个方法时，编译器很容易就给出警告：PerformSelector may cause a leak because its selector is unknown。为什么会提示有内存泄漏问题呢？ 首先要明确：调用performSelector:编译器会假设调用方法的返回值是一个对象，且不会对返回值进行retain/release。 如果调用的方法是alloc, new, copy, mutableCopy方法家族中的方法(包含以它们开头)，方法调用的结果是开辟了一块内存空间，但是系统仍然按照非retain/release处理，没有对它们的引用计数纳入管理，这时内存空间无法释放，就会产生内存泄露。 当显式调用这些方法时，编译器都能明显分析出来，并给出提示：Error：PerformSelector names a selector which retains the object。告诉我们这不符合引用计数管理的规则，编译不通过。 There are really only 4 things that ARC would consider for the return value:4 Ignore non-object types (void, int, etc) Retain object value, then release when it is no longer used (standard assumption) Release new object values when no longer used (methods in the init/ copy family or attributed with ns_returns_retained) Do nothing &amp; assume returned object value will be valid in local scope (until inner most release pool is drained, attributed with ns_returns_autoreleased) The call to methodForSelector: assumes that the return value of the method it’s calling is an object, but does not retain/release it. So you could end up creating a leak if your object is supposed to be released as in #3 above (that is, the method you’re calling returns a new object). 比如这样：- (id)newObject &#123; return [NSObject new];&#125; // 调用method family中的方法：[str performSelector:@selector(copy)];// 调用以method family中的方法名开头的方法：[self performSelector:@selector(newObject)]; 但是隐式调用的时候，编译器无能为力了，只能给出警告：PerformSelector may cause a leak because its selector is unknown。 // 隐式调用无法分析出错误: 出现内存泄露id obj1 = [str performSelector:NSSelectorFromString(@"copy")];[str performSelector:NSSelectorFromString(@"mutableCopy")];id obj2 = [[NSObject class] performSelector:NSSelectorFromString(@"new")];id obj3 = [self performSelector:NSSelectorFromString(@"newObject")]; 消除waring最简单的，可以利用#pragma消除警告。 #pragma("clang diagnostic push")#pragma("clang diagnostic ignored \"-Warc-performSelector-leaks\"")[person performSelector:selector]; // 插入需要消除警告的代码#pragma("clang diagnostic pop") 或者换种思路，根据performSelector的实现，效果上可以直接使用IMP，也可以使用objc_msgSend()，甚至使用NSInvocation、sendAction等，这样就达到同等实现而没有警告了。 方式1：methodForSelectorif (!person) return;// 获取函数指针IMP imp = [person methodForSelector:selector];// 类型转换void (*func)(id, SEL) = (void *)imp;// 调用func(person, selector); 方式2：methodForSelector简化版((void (*)(id, SEL))[person methodForSelector:selector])(self, selector); 方式3：使用objc_msgSend((void *(*)(id, SEL))objc_msgSend)((id)self, NSSelectorFromString(@"show")); 方式4：NSInvocationSEL selector = NSSelectorFromString(@"show");NSMethodSignature *methodSig = [[self class] instanceMethodSignatureForSelector:selector];NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig];[invocation setSelector:selector];[invocation setTarget:self];[invocation invoke]; 方式5: sendAction[UIApplication.sharedApplication sendAction:NSSelectorFromString(@"show") to:self from:nil forEvent:nil]; 解决内存泄漏当我们一定要调用newObject这类特殊的方法时（可能性极小），怎么解决内存泄漏问题呢？把return的对象的引用计数减少即可，比如： 当使用objc_msgSend()时id obj = CFBridgingRelease(((void *(*)(id, SEL))objc_msgSend)(self, NSSelectorFromString(@"newObject"))); 当使用methodForSelector时id obj = CFBridgingRelease(((void *(*)(id, SEL))[self methodForSelector:NSSelectorFromString(@"newObject")])(self, NSSelectorFromString(@"newObject"))); 延迟- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget; performSelector:withObject:afterDelay:源码实现: - (void)performSelector:(SEL)aSelector withObject:(id)argument afterDelay:(NSTimeInterval)seconds &#123; NSRunLoop *loop = [NSRunLoop currentRunLoop]; GSTimedPerformer *item; // item引用计数+1 item = [[GSTimedPerformer alloc] initWithSelector:aSelector target:self argument:argument delay:seconds]; // 持有item [[loop _timedPerformers] addObject:item]; // item引用计数-1 RELEASE(item); // 持有timer [loop addTimer:item-&gt;timer forMode:NSDefaultRunLoopMode];&#125; 这个方法主要做了这些事: 获取当前线程的Runloop对象。 根据方法名、方法参数、方法调用者及延迟时间等信息创建一个GSTimedPerformer对象，把该对象添加到Runloop的_timedPerformers数组中保存。 把GSTimedPerformer中的定时器timer添加到Runloop中。 如官方文档所说:This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode. 看看GSTimedPerformer做了什么: @interface GSTimedPerformer: NSObject &#123;@public SEL selector; id target; id argument; NSTimer *timer;&#125;- (void)fire;- (id)initWithSelector:(SEL)aSelector target:(id)target argument:(id)argument delay:(NSTimeInterval)delay;- (void)invalidate;@end@implementation GSTimedPerformer- (void)dealloc &#123; [self finalize]; TEST_RELEASE(timer); // 释放target对象 RELEASE(target); RELEASE(argument); [super dealloc];&#125;- (void)finalize &#123; [self invalidate];&#125;- (void)fire &#123; DESTROY(timer); [target performSelector:selector withObject:argument]; [[[NSRunLoop currentRunLoop] _timedPerformers] removeObjectIdenticalTo:self];&#125;- (id)initWithSelector:(SEL)aSelector target:(id)aTarget argument:(id)anArgument delay:(NSTimeInterval)delay &#123; self = [super init]; if (self != nil) &#123; selector = aSelector; // 持有target target = RETAIN(aTarget); argument = RETAIN(anArgument); timer = [[NSTimer allocWithZone:NSDefaultMallocZone()] initWithFireDate:nil interval:delay target:self selector:@selector(fire) userInfo:nil repeats:NO]; &#125; return self;&#125;- (void)invalidate &#123; if (timer != nil) &#123; [timer invalidate]; DESTROY(timer); &#125;&#125;@end The GSTimedPerformer class is used to hold information about messages which are due to be sent to objects at a particular time. 可见，GSTimedPerformer作用就是保存关于消息的信息，具体方法的延迟和调用主要还是依靠其内部的定时器。分析源码可知，Runloop的_timedPerformers数组持有了GSTimedPerformer，Runloop还持有GSTimedPerformer内部的定时器timer，定时器timer持有着target(self)。而GSTimedPerformer持有着target(self)和定时器timer。 引用关系如图所示： 当设置的时间到的时候，GSTimedPerformer内部的fire方法得到调用，此时外界的target便调用了被设置的selector，起到了延迟执行的效果。紧接着，Runloop的_timedPerformers数组移除了对GSTimedPerformer的引用，GSTimedPerformer自然会销毁，它的dealloc方法得到调用。而GSTimedPerformer中的dealloc内部调用了finalize方法，finalize方法的目的是invalidate掉定时器timer并减少它的引用计数。此时，timer只有Runloop持有着它了，关键是timer一旦被invalidate，Runloop也不会再持有它了（Timers are removed automatically when they are invalid）。这样，timer彻底死掉，对target的强引用也没有了，一切恢复如初。 这一切的前提建立在Runloop运行在NSDefaultRunLoopMode模式下并顺利调用fire方法。当延迟方法因种种原因没有执行就可能出现内存泄露。 很经典的例子：从A控制器push到B控制器，B控制器此时执行一个方法：[self performSelector:@selector(printInfo) withObject:nil afterDelay:100];。此时从B控制器pop到A控制器，很明显B控制器并没有销毁，因为Runloop还（间接）强引用着它，可以理解为出现了内存泄露(尽管100s后printInfo方法得到执行，B控制器会销毁)。 performSelector关于内存管理的执行原理是这样的执行 [self performSelector:@selector(method1:) withObject:self afterDelay:3]; 的时候，系统会将self的引用计数加1，执行完这个方法时，还会将self的引用计数减1，当方法还没有执行的时候，要返回父视图释放当前视图的时候，self的计数没有减少到0，而导致无法调用dealloc方法，出现了内存泄露。 比较好的做法是及时取消掉之前的延迟调用:cancelPreviousPerformRequestsWithTarget: selector:object:，那么cancelPreviousPerformRequestsWithTarget: selector:object:做了什么呢? cancelPreviousPerformRequestsWithTarget: selector:object:[NSObject cancelPreviousPerformRequestsWithTarget:self];[NSObject cancelPreviousPerformRequestsWithTarget:self selector:NSSelectorFromString(@"printString:") object:@"str"]; 这两个方法可以取消perform延迟调用，它们内部做了什么？ + (void)cancelPreviousPerformRequestsWithTarget:(id)targe selector:(SEL)aSelector object:(id)arg &#123; NSMutableArray *perf = [[NSRunLoop currentRunLoop] _timedPerformers]; unsigned count = [perf count]; if (count &gt; 0) &#123; GSTimedPerformer *array[count]; IF_NO_GC(RETAIN(target)); IF_NO_GC(RETAIN(arg)); [perf getObjects: array]; while (count-- &gt; 0) &#123; // 遍历查找 GSTimedPerformer *p = array[count]; if (p-&gt;target == target &amp;&amp; sel_isEqual(p-&gt;selector, aSelector) &amp;&amp; (p-&gt;argument == arg || [p-&gt;argument isEqual:arg])) &#123; // target\sel\argument均一致 [p invalidate]; [perf removeObjectAtIndex: count]; &#125; &#125; RELEASE(arg); RELEASE(target); &#125;&#125; 获取Runloop内部持有的_timedPerformers数组(数组中的是GSTimedPerformer对象)。 创建一个C语言数组，并把_timedPerformers数组中的内容copy到这个C语言数组array。 遍历该C语言数组array：如果给定参数中的target、argument、selector均一一对应，那么销毁GSTimedPerformer对象中的定时器，并根据当前的索引移除_timedPerformers数组的GSTimedPerformer对象。 换句话说，如果target、argument、selector中有一个参数没有对应，那么便不会执行销毁定时器操作和移除操作。那么，判定target、argument、selector均一一对应的标准是：Matching of the argument may be either by pointer equality or by use of the [NSObject -isEqual:] method.就是指针比较以及isEqual方法。 if(p-&gt;target == target &amp;&amp; sel_isEqual(p-&gt;selector, aSelector)&amp;&amp; (p-&gt;argument == arg || [p-&gt;argument isEqual:arg])) &#123;&#125; 其实这里的sel_isEqual就等价于==，多说一句，SEL实际上就是根据方法名hash化了的一个字符串（char *），对于字符串的比较只要比较地址就可以了。 同理，+ (void)cancelPreviousPerformRequestsWithTarget:(id)target方法实现原理与上面的方法类似，只是不用比较argument和selector参数，把target有关的所有定时器都销毁，并把所有与之相关的GSTimedPerformer对象都从_timedPerformers数组中移除。while (count-- &gt; 0) &#123; GSTimedPerformer *p = array[count]; if (p-&gt;target == target) &#123; [p invalidate]; [perf removeObjectAtIndex:count]; &#125;&#125; 当手动销毁定时器并把GSTimedPerformer从Runloop中移除时，定时器对target的强引用不存在；GSTimedPerformer销毁，GSTimedPerformer对target的强引用也不存在，这样，内存泄露问题解决了。这也是为什么使用cancelPreviousPerformRequestsWithTarget取消还没有执行的perform就可以解决target无法释放掉的原因。 模式 performSelector:target:argument:order:modes:- (void)performSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg order:(NSUInteger)order modes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)cancelPerformSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg;- (void)cancelPerformSelectorsWithTarget:(id)target; 这里主要看performSelector:target:argument:order:modes:是如何实现的。 Sets up sending of aSelector to target with argument. The selector is sent before the next runloop iteration (unless cancelled before then) in any of the specified modes.The target and argument objects are retained.The order value is used to determine the order in which messages are sent if multiple messages have been set up. Messages with a lower order value are sent first.If the modes array is empty, this method has no effect.说的很明白了，就是在指定模式的Runloop下一次迭代之前把selector、argument等信息丢给target，以便调用。这里的order指定了这个调用的优先级，值越小，越早被调用。 - (void)performSelector:(SEL)aSelector target:(id)target argument:(id)argument order:(NSUInteger)order modes:(NSArray *)modes &#123; unsigned count = [modes count]; if (count &gt; 0) &#123; NSString *array[count]; GSRunLoopPerformer *item; item = [[GSRunLoopPerformer alloc] initWithSelector:aSelector target:target argument:argument order:order]; // 把modes中的内容copy到array if ([modes isProxy]) &#123; unsigned i; for (i = 0; i &lt; count; i++) &#123; array[i] = [modes objectAtIndex:i]; &#125; &#125; else &#123; [modes getObjects:array]; &#125; // 遍历所有mode while (count-- &gt; 0) &#123; NSString *mode = array[count]; unsigned end; unsigned i; GSRunLoopCtxt *context; GSIArray performers; context = NSMapGet(_contextMap, mode); if (context == nil) &#123; context = [[GSRunLoopCtxt alloc] initWithMode:mode extra:_extra]; NSMapInsert(_contextMap, context-&gt;mode, context); RELEASE(context); &#125; // 获取Runloop某个mode下对应的context中的performers performers = context-&gt;performers; // performers的数量 end = GSIArrayCount(performers); for (i = 0; i &lt; end; i++) &#123; // 遍历整个performers数组 GSRunLoopPerformer *p; p = GSIArrayItemAtIndex(performers, i).obj; if (p-&gt;order &gt; order) &#123; // 新添加进来的item的优先级高于当前索引i对应item的优先级, 插入 GSIArrayInsertItem(performers, (GSIArrayItem)((id)item), i); break; &#125; &#125; // 第一种可能: i和end都为0, performers数组为空, 上面的for循环没有执行 // 第二种可能: 新添加进来的item的优先级最低, 上面的for循环没有执行, 把它添加到数组的最后位置 if (i == end) &#123; GSIArrayInsertItem(performers, (GSIArrayItem)((id)item), i); &#125; i = GSIArrayCount(performers); if (i % 1000 == 0 &amp;&amp; i &gt; context-&gt;maxPerformers) &#123; // 更新context中的performer最大数量 context-&gt;maxPerformers = i; NSLog(@"WARNING ... there are %u performers scheduled" @" in mode %@ of %@\n(Latest: [%@ %@])", i, mode, self, NSStringFromClass([target class]), NSStringFromSelector(aSelector)); &#125; &#125; RELEASE(item); &#125;&#125; 根据方法实现来看，这个方法做了这些事: 如果数组modes中没有内容就直接return。 把target、argument、selector、order等信息包装成一个GSRunLoopPerformer对象。 创建一个字符串数组array，把modes中的内容copy到array。 遍历array。找到每一种mode(NSString类型)在_contextMap(NSMapTable类型)表中对应的context(GSRunLoopCtxt类型)，获得context中需要执行的performers(GSIArray类型)数组。 遍历原来的performers数组，根据第2步中包装好的GSRunLoopPerformer对象的优先级order，插入到performers中的合适位置。 总而言之，就是把target、argument、selector、order等信息包装成一个GSRunLoopPerformer对象，并把该对象添加到Runloop（中的_contextMap）里面的performers，供其在合适的时机调用。具体啥时候调用呢？官方文档说是Runloop的下一次迭代的时候。 自不必说，cancelPerformSelector:target:argument:就是根据selector、target和argument移除performers数组中的GSRunLoopPerformer。要求三者完全对应。cancelPerformSelector:target:是根据selector、target移除performers数组中相关的所有的GSRunLoopPerformer对象。原理与上文中所说的cancelPreviousPerformRequestsWithTarget:基本一致。 线程performSelector:onThread:withObject:waitUntilDone:modes:- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;// equivalent to the first method with kCFRunLoopCommonModes- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;// equivalent to the first method with kCFRunLoopCommonModes- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait;- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg; 第二个方法与第一个方法对应，其modes是kCFRunLoopCommonModes，selector在主线程执行。第四个方法与第三个方法对应，其modes是kCFRunLoopCommonModes，selector在指定的子线程执行。第五个方法省略很多参数，selector在内置的子线程执行。 先分析第四个方法即可。具体的实现如下所示: - (void)performSelector:(SEL)aSelector onThread:(NSThread *)aThread withObject:(id)anObject waitUntilDone:(BOOL)aFlag modes:(NSArray*)anArray &#123; GSRunLoopThreadInfo *info; NSThread *t; if ([anArray count] == 0) return; t = GSCurrentThread(); if (aThread == nil) aThread = t; info = GSRunLoopInfoForThread(aThread); if (t == aThread) &#123; // Perform in current thread. if (aFlag == YES || info-&gt;loop == nil) &#123; // Wait until done or no run loop. [self performSelector:aSelector withObject:anObject]; &#125; else &#123; // Don't wait ... schedule operation in run loop. [info-&gt;loop performSelector:aSelector target:self argument:anObject order:0 modes:anArray]; &#125; &#125; else &#123; GSPerformHolder *h; NSConditionLock *l = nil; // 线程Finished判断 if ([aThread isFinished] == YES) &#123; [NSException raise: NSInternalInconsistencyException format: @"perform on finished thread"]; &#125; // 阻塞等待加锁 if (aFlag == YES) &#123; l = [[NSConditionLock alloc] init]; &#125; h = [GSPerformHolder newForReceiver:self argument:anObject selector:aSelector modes:anArray lock:l]; [info addPerformer:h]; // 条件锁创建成功(也即参数aFlag为YES) if (l != nil) &#123; [l lockWhenCondition:1]; // 当条件为1时加锁 [l unlock]; RELEASE(l); // holder已经失效则抛出异常 if ([h isInvalidated] == YES) &#123; RELEASE(h); [NSException raise: NSInternalInconsistencyException format: @"perform on finished thread"]; &#125; // holder自身就产生exception了, 那么再次抛出异常 // If we have an exception passed back from the remote thread, re-raise it. if (nil != h-&gt;exception) &#123; NSException *e = AUTORELEASE(RETAIN(h-&gt;exception)); RELEASE(h); [e raise]; &#125; &#125; RELEASE(h); &#125;&#125; 这个方法主要做了这些什么? 首先对传进来的modes(Runloop模式数组)个数进行判断，如果为0，则直接return。 获取该方法执行上下文中的线程： t，并把它与作为参数传进来的线程aThread进行比较，看是否一致。当然，如果传进来的aThread为空，那么执行aThread = t;，就让selector在当前上下文中的线程中执行。 当两个线程一致时，如果参数aFlag为YES或者线程对应的Runloop为空，说明需要等待，也即这个方法应该等到selector被执行完毕后再return。这就好办了，直接调用[self performSelector: aSelector withObject: anObject];方法，同步执行即可。如果不需要等待呢? 把selector、argument、modes等信息交给线程对应的Runloop再进一步处理（schedule operation in run loop）。 当两个线程不一致时，首先判断aThread有没有finished，线程死了自然selector无法执行，抛出异常。再者判断是否需要阻塞等待，如果需要的话就创建一个条件锁。接着把selector、argument、modes及条件锁等信息封装成一个GSPerformHolder对象，并把它交给封装线程信息的GSRunLoopThreadInfo对象。之后是一些收尾工作：设置条件锁的condition及一些异常判断。 需要着重说明的是参数aFlag： 是否立即返回。如果参数aFlag为YES，则这个方法应该等到selector被执行完毕后再return。如果selector是在当前方法上下文的线程中执行，且该线程对应的Runloop没有run，那么会忽略modes，直接执行：performSelector:aSelector withObject:。 当两个线程一致时，也即selector执行的线程就是当前方法上下文中的线程，这比较好处理，把selector、argument、modes等信息交给线程对应的Runloop即可，就是模式中的方法：performSelector:target:argument:order:modes:。 GSPerformHolder 两个线程不一致时，“把selector、argument、modes及条件锁等信息封装成一个GSPerformHolder对象，并把它交给封装线程信息的GSRunLoopThreadInfo对象”又是怎么做的呢? (GSPerformHolder *)h = [GSPerformHolder newForReceiver:self argument:anObject selector:aSelector modes:anArray lock:l];[(GSRunLoopThreadInfo *)info addPerformer:h]; newForReceiver:argument:selector:modes:lock: 这个方法就是做一些信息封装，无需多言。主要是这个addPerformer，删除#if defined(_WIN32)的代码后具体实现如下: - (void)addPerformer:(id)performer &#123; BOOL signalled = NO; // NSLock加锁 [lock lock]; NSTimeInterval start = 0.0; // 使用write函数向 outputFd 中写入 1 字节数据，数据为: "0"。 while (outputFd &gt;= 0 &amp;&amp; NO == (signalled = (write(outputFd, "0", 1) == 1) ? YES : NO)) &#123; NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate]; if (0.0 == start) &#123; start = now; &#125; else if (now - start &gt;= 1.0) &#123; NSLog(@"Unable to signal %@ within a second; blocked?", self); break; &#125; [lock unlock]; [lock lock]; &#125; // 写入数据成功，把performer添加到GSRunLoopThreadInfo数组中 if (signalled) [performers addObject: performer]; // NSLock解锁 [lock unlock]; // 写入数据失败，销毁performer if (!signalled) [performer invalidate];&#125; 补充write函数知识点: /* * write函数 * ssize_t write(int __fd, const void * __buf, size_t __nbyte) __DARWIN_ALIAS_C(write); * write 函数向 __fd 中写入 __nbyte 字节数据，数据来源为 __buf 。返回值一般总是等于 __nbyte * 返回值如果不是等于__nbyte，就是出错了。常见的出错原因是磁盘空间满了或者超过了文件大小限制。 *//* The write could concievably fail if the pipe is full. * In that case we need to release the lock temporarily to allow the other * thread to consume data from the pipe. It's possible that the thread * and its runloop might stop during that ... so we need to check that * outputFd is still valid. */ 不是十分理解write函数在这里的作用，根据一些异常信息&quot;Failed to set non block flag for perform in thread&quot; &quot;Failed to create event to handle perform in thread&quot;，可能是向文件中写入一些flag表示线程指定事件对象的信号状态吧。 如果信号状态设置成功，就把这个perform对象(GSPerformHolder类型)添加到GSRunLoopThreadInfo的performers数组中。 这个GSRunLoopThreadInfo对象把GSPerformHolder对象添加到自己数组中后，具体最原先的perform什么时候执行呢? 是在调用GSRunLoopThreadInfo对象的fire方法时逐个执行： GSRunLoopThreadInfo对象的fire方法部分实现: for (i = 0; i &lt; c; i++) &#123; GSPerformHolder *h = [toDo objectAtIndex:i]; [loop performSelector:@selector(fire) target:h argument:nil order:0 modes:[h modes]];&#125; 可见是逐个取出数组中的GSPerformHolder对象，一个接一个地调用GSPerformHolder的fire方法，这也是个fire方法，它内部做了什么？就是[receiver performSelector: selector withObject: argument];。 捋一捋: 两个线程不一致时，把selector、argument、modes及条件锁等信息封装成一个GSPerformHolder对象，并把它添加到GSRunLoopThreadInfo对象的performers数组中。当调用GSRunLoopThreadInfo对象的fair方法时会遍历performers数组，然后逐个调用数组中每一个元素的fair方法，而这个fair方法内部就是调用performSelector:withObject方法。 最最关键的一个问题: 什么时候调用GSRunLoopThreadInfo对象的fair方法? 官方文档说: May only be called from the runloop when the event/descriptor is triggered. 我在Runloop的+(BOOL)awakenedBefore:和 -(BOOL)pollUntil:within:方法中找到了调用痕迹。 任意线程调用- (void)performSelector:(SEL)aSelector onThread:(NSThread*)aThread withObject:(id)anObject waitUntilDone:(BOOL)aFlag &#123; [self performSelector:aSelector onThread:aThread withObject:anObject waitUntilDone:aFlag modes:commonModes()];&#125; Runloop的五种mode分别是:NSDefaultRunLoopMode，NSConnectionReplyMode，NSModalPanelRunLoopMode，NSEventTrackingRunLoopMode，NSRunLoopCommonModes。这个方法省略了modes参数，内部使用common mode，也即NSDefaultRunLoopMode和NSConnectionReplyMode(不是NSEventTrackingRunLoopMode)。所以如果有鼠标或者手势事件需要处理，省略modes参数可能不是个好做法。 主线程调用- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)anObject waitUntilDone:(BOOL)aFlag modes:(NSArray*)anArray &#123; if (defaultThread == nil) defaultThread = [NSThread mainThread]; [self performSelector:aSelector onThread:defaultThread withObject:anObject waitUntilDone:aFlag modes:anArray];&#125; 这个方法指定了主线程。 - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)anObject waitUntilDone:(BOOL)aFlag &#123; [self performSelectorOnMainThread:aSelector withObject:anObject waitUntilDone:aFlag modes:commonModes()];&#125; 这两个方法指定了主线程，内部使用common mode。 Background调用- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)anObject &#123; [NSThread detachNewThreadSelector:aSelector toTarget:self withObject:anObject];&#125; 这个方法会创建一条任意的线程执行selector方法。 Q&amp;AprintInfo方法会执行吗GCD调用dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self performSelector:@selector(printInfo) withObject:nil afterDelay:1];&#125;); 很明显是不会的。因为performSelector具体实现中并没有主动触发线程对应Runloop运行。子线程对应的Runloop没有run。怎么让它执行？启动Runloop: dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self performSelector:@selector(printInfo) withObject:nil afterDelay:1]; [[NSRunLoop currentRunLoop] run];&#125;); NSThread调用NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; [self performSelector:@selector(printInfo) withObject:nil afterDelay:1];&#125;];[thread start]; 同理: NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; [self performSelector:@selector(printInfo) withObject:nil afterDelay:1]; [[NSRunLoop currentRunLoop] run];&#125;];[thread start]; 这就有一个问题了。在GCD中[[NSRunLoop currentRunLoop] run];放在performSelector前面或者后面貌似都是可以的，但是在NSThread中[[NSRunLoop currentRunLoop] run];只能放在performSelector的后面。 在NSThread方法中: 因为run方法只是尝试想要开启当前线程中的runloop，但是如果该线程中并没有任何事件(source、timer、observer)的话，并不会成功的开启。 为什么GCD中即使[[NSRunLoop currentRunLoop] run];放在前面printInfo方法还是调用了呢? 代码实际测试，延迟效果没有了，并且有时方法执行，有时方法没有执行。 综上，在子线程中使用performSelector的延迟方法，需要加上[[NSRunLoop currentRunLoop] run];使得Runloop能够运行，并且该方法要放在performSelector的后面来保证Runloop成功运行。 NSThread无效NSThread *thread = [[NSThread alloc] initWithBlock:^&#123;&#125;];[thread start];[self performSelector:@selector(printMainInfo) onThread:thread withObject:nil waitUntilDone:NO]; 上面这段代码为什么没有执行printMainInfo方法? 子线程执行完操作之后就会立即释放，即使我们使用强引用引用子线程使子线程不被释放，也不能给子线程再次添加操作，或者再次开启。这里可以使用Runloop。子线程获取其对应的Runloop对象并使之运行。一般使用常驻子线程。 正确实践：NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; // 执行一次而已 NSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop]; [currentRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];&#125;];[thread start];[self performSelector:@selector(printMainInfo) onThread:thread withObject:nil waitUntilDone:NO]; 小结梳理本文，比较重要的几个小点如下： performSelector内部的实现就是使用IMP直接调用对象的方法。 严格遵守ARC规则，注意方法的命名，不然会为内存泄漏埋下伏笔。 反射NSSelectorFromString()很强大，但是使用@selector()显式告诉编译器将要调用的方法是更优的选择。 performSelector能实现延迟是因为定时器，要及时取消无法执行的延迟方法。 子线程中使用延迟方法，需要主动使Runloop能够运行。 NSTimer在其invalidate方法调用后，Runloop会自动移除对它的引用。 具体在业务上，可以举几个简单的场景。 对于文件或者模型的下载，有时候需要用到进度条提示。这时候可以在子线程下载，跑到主线程更新UI：[self performSelectorOnMainThread:@selector(updateProgress) withObject:nil waitUntilDone:NO]; 有些时候需要进行简单的Tip提示，3秒后自动让它自动隐藏：[self.tipView performSelector:@selector(dismiss) withObject:nil afterDelay:3.f]; 当使用多态的时候，动态调用方法创建实例对象：Class cls = Nil;if (item.isForChinese) &#123; cls = NSClassFromString(@"YAChinesePopView");&#125; else &#123; cls = NSClassFromString(@"YAEnglishPopView");&#125;return [cls performSelector:@selector(popViewWithItem:) withObject:item]; 偶然间发现一个好玩的例子：直接调用某个对象的某个方法，而不导入其头文件。比如手百自定义一个继承自WKWebView的子类，并把这个实例暴露出来，我们想让它执行某段JavaScript，但是又不想导入繁重的头文件： if ([obj respondsToSelector:@selector(evaluateJavaScript:completionHandler:)]) { [obj performSelector:@selector(evaluateJavaScript:completionHandler:) withObject:js withObject:nil]; } 上面的只是冰山一角，其合理性需要结合具体的业务场景具体分析，只是想阐明，performSelector在一些情况下是很有用的。 参考资料Advanced Memory Management Programming GuideObjective-C之performSelector编译器内存泄露警告用performSelector的时候要注意别内存泄露了PerformSelector May Cause a LeakperformSelector 注意问题及原理c/c++ read 函数和 write 函数]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime基础]]></title>
    <url>%2F2018%2F07%2F10%2FRuntime%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[2018.8.26 更新Class定义2019.3.25 更新设置weak关联属性 关于Runtime的简单总结。 简单总结一些比较好玩的用法，但是后来我才发现，南峰子大神的Runtime系列总结的很详细很完整了。文章舍不得删，就当抛砖引玉吧。 一、RuntimeClassObjective-C2.0之前Class的定义struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ // 父类 Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; // 方法缓存 struct objc_cache *cache; struct objc_protocol_list *protocols;#endif&#125;;struct objc_cache &#123; unsigned int mask /* total = mask + 1 */; unsigned int occupied; Method buckets[1];&#125;;根据源码，最新定义大致如下:struct objc_class : objc_object &#123; // Class ISA; Class isa; Class superclass; cache_t cache;// 方法缓存 class_data_bits_t bits; // 用于获取具体的类信息&#125;; 实例演练 YAPerson *person = [[YAPerson alloc] init];Class cls = [person class]; // 获取实例对象对应的ClassClass class1 = object_getClass(person); // 获取指定名称的类对象Class class3 = objc_getClass("YAPerson");Class class2 = objc_getRequiredClass("YAPerson"); // 获取指定名称的元类对象Class class4 = objc_getMetaClass("YAPerson"); // 找到指定名称的类对象Class class5 = objc_lookUpClass("NSObject");NSLog(@"%@%@%@%@%@",class1,class2,class3,class4,class5); // 设置对象对应的Class,返回原先的classClass oriClass = object_setClass(person, [NSObject class]);// 是否是类对象或元类对象BOOL isClass = object_isClass(person); // 是否是元类对象BOOL isMetaClass = class_isMetaClass(class4); // 获取父类Class superClass = class_getSuperclass(cls); // 获取类的版本int version = class_getVersion(cls);// 设置类的版本class_setVersion(cls, 88);// 获取实例大小typedef __SIZE_TYPE__ size_t; size_t size = class_getInstanceSize(cls); // int objc_getClassList(Class *buffer, int bufferCount)// // Class *objc_copyClassList(unsigned int *outCount)// // 获取类的名称const char *name = class_getName(cls); // 动态创建类//Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)//void objc_registerClassPair(Class cls) // 动态废弃类//Class objc_duplicateClass(Class original, const char *name, size_t extraBytes)//void objc_disposeClassPair(Class cls) //id o = objc_storeWeak(&amp;weakObject, weakObject);//id result = objc_loadWeak(&amp;weakObject); Block给block创建一个关联的函数指针IMP imp_implementationWithBlock(id block)获取函数指针关联的blockid imp_getBlock(IMP anImp)移除函数指针对应的blockBOOL imp_removeBlock(IMP anImp) 实例演练 // 声明blocktypedef void (^Block) (); // 定义blockBlock block = ^() &#123; NSLog(@"哈哈哈");&#125;; // 给block创建一个关联的函数指针IMP imp = imp_implementationWithBlock(block);// 调用block(*imp)(); // 获取函数指针关联的blockid blockObject = imp_getBlock(imp);NSLog(@"%@",blockObject); // 移除函数指针对应的blockBOOL isRemoveBlock = imp_removeBlock(imp);if (isRemoveBlock) &#123; NSLog(@"成功移除");&#125; SEL获取SEL的名称(char *类型)const char *sel_getName(SEL sel)注册SELSEL sel_registerName(const char *str)比较SELBOOL sel_isEqual(SEL lhs, SEL rhs) 实例演练 // 获取SEL的名称(char *类型)const char *selName = sel_getName(@selector(viewWillAppear:));printf("%s",selName); // 注册SELSEL newSel = sel_registerName("haha"); // 比较SELBOOL isEqual = sel_isEqual(@selector(viewWillAppear:), newSel);NSLog(@"%d",isEqual); Ivar定义一个objc_ivar结构体指针Ivartypedef struct objc_ivar *Ivar;struct objc_ivar &#123; 成员变量名称 char *ivar_name; 成员变量类型 char *ivar_type; 偏移量 int ivar_offset; #ifdef __LP64__ int space; #endif&#125; 关于偏移量的定义(就是整型)#if defined(__PTRDIFF_TYPE__) typedef __PTRDIFF_TYPE__ __darwin_ptrdiff_t; /* ptr1 - ptr2 */#elif defined(__LP64__) typedef long __darwin_ptrdiff_t; /* ptr1 - ptr2 */#else typedef int __darwin_ptrdiff_t; /* ptr1 - ptr2 */#endif /* __GNUC__ */ #ifndef _PTRDIFF_T#define _PTRDIFF_T typedef __darwin_ptrdiff_t ptrdiff_t;#endif /* _PTRDIFF_T */成员变量列表struct objc_ivar_list &#123; 成员变量数量 int ivar_count;#ifdef __LP64__ int space;#endif /* variable length structure */ struct objc_ivar ivar_list[1];&#125; 获取实例变量Ivar class_getInstanceVariable(Class cls, const char *name) //获取类变量//Ivar class_getClassVariable(Class cls, const char *name) 获取成员变量列表Ivar *class_copyIvarList(Class cls, unsigned int *outCount) 获取Ivar变量的名称const char *ivar_getName(Ivar v) 获取Ivar变量的偏移量ptrdiff_t ivar_getOffset(Ivar v) 获取Ivar变量的编码const char *ivar_getTypeEncoding(Ivar v) 设置成员变量的值void object_setIvarWithStrongDefault(id obj, Ivar ivar, id value)设置成员变量的值void object_setIvar(id obj, Ivar ivar, id value)获取Ivar对应的成员变量对象id object_getIvar(id obj, Ivar ivar)IvarLayout相关const uint8_t *class_getIvarLayout(Class cls)const uint8_t *class_getWeakIvarLayout(Class cls)void class_setIvarLayout(Class cls, const uint8_t *layout)void class_setWeakIvarLayout(Class cls, const uint8_t *layout) 添加成员变量BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types) 实例演示 - (void)viewDidLoad &#123; YAPerson *person = [[YAPerson alloc] init]; Class cls = [person class]; // 获取实例变量 Ivar ivar_num = class_getInstanceVariable(cls, "num"); Ivar ivar_name = class_getInstanceVariable(cls, "name"); //获取类变量 //Ivar class_getClassVariable(Class cls, const char *name) // 获取Ivar变量的名称 const char *name = ivar_getName(ivar_name); printf("%s\n",name); // 获取Ivar变量的偏移量 ptrdiff_t p = ivar_getOffset(ivar_num); printf("%td",p); // 打印16 // 获取Ivar变量的编码 const char *typeEncoding = ivar_getTypeEncoding(ivar_name); printf("%s\n",typeEncoding); // 打印 @"NSString" // 设置成员变量的值 object_setIvarWithStrongDefault(person, ivar_name, @"haha"); NSLog(@"%@",person-&gt;name); // 设置成员变量对应的值 object_setIvar(person, ivar_name, @"hahaaaaaa"); NSLog(@"%@",person-&gt;name); //获取Ivar对应的成员变量对象 id object = object_getIvar(person, ivar_name); NSLog(@"%@",object); // 动态添加成员变量 // 必须在 objc_allocateClassPair 之后 和 在objc_registerClassPair之前调用 // 不能给一个已经存在的类添加成员变量 Class peopleClass = objc_allocateClassPair(cls, "YAPeople", 0); class_addIvar(peopleClass, "_gayFriend", sizeof(id), log2(sizeof(id)), @encode(id)); class_addIvar(peopleClass, "_girlFriend", sizeof(id), log2(sizeof(id)), @encode(id)); class_addIvar(peopleClass, "_company", sizeof(id), log2(sizeof(id)), @encode(id)); objc_registerClassPair(peopleClass); // 打印成员变量列表 NSLog(@"%@", [self ya_getIvarList:peopleClass]); // IvarLayout相关 // ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型 const uint8_t *ivarLayoutArray= class_getIvarLayout(cls); const uint8_t *weakIvarLayoutArray = class_getWeakIvarLayout(cls); if (ivarLayoutArray) &#123; int i = 0; uint8_t value_s = ivarLayoutArray[i]; while (value_s != 0x0) &#123; printf("\\x%02x\n", value_s); value_s = ivarLayoutArray[++i]; &#125; &#125; //void class_setIvarLayout(Class cls, const uint8_t *layout) //void class_setWeakIvarLayout(Class cls, const uint8_t *layout)&#125; 根据class获取成员变量列表/** 根据class获取成员变量列表 @param class 类 @return 成员变量字典(名称:类型) */- (NSDictionary *)ya_getIvarList:(Class)class &#123; // 成员变量数量 unsigned int count = 0; // 获取成员变量列表 Ivar *ivarList = class_copyIvarList(class, &amp;count); // 存储成员变量 NSMutableDictionary *dict = [NSMutableDictionary dictionary]; // 获取成员变量类型与成员变量名称 for (unsigned int i = 0; i &lt; count; i++) &#123; // 成员变量类型 const char *c_ivarType = ivar_getTypeEncoding(ivarList[i]); // 成员变量名称 const char *c_ivarName = ivar_getName(ivarList[i]); // 利用字典存储,格式为 成员变量名称:对应的成员变量类型 NSString *ivarName = [NSString stringWithUTF8String:c_ivarName]; dict[ivarName] = [NSString stringWithUTF8String:c_ivarType]; &#125; // 需要手动free free(ivarList); return [NSDictionary dictionaryWithDictionary:dict];&#125; Method值得一提的是方法编码和类型编码： #define _C_ID '@'#define _C_CLASS '#'#define _C_SEL ':'#define _C_CHR 'c'#define _C_UCHR 'C'#define _C_SHT 's'#define _C_USHT 'S'#define _C_INT 'i'#define _C_UINT 'I'#define _C_LNG 'l'#define _C_ULNG 'L'#define _C_LNG_LNG 'q'#define _C_ULNG_LNG 'Q'#define _C_FLT 'f'#define _C_DBL 'd'#define _C_BFLD 'b'#define _C_BOOL 'B'#define _C_VOID 'v'#define _C_UNDEF '?'#define _C_PTR '^'#define _C_CHARPTR '*'#define _C_ATOM '%'#define _C_ARY_B '['#define _C_ARY_E ']'#define _C_UNION_B '('#define _C_UNION_E ')'#define _C_STRUCT_B '&#123;'#define _C_STRUCT_E '&#125;'#define _C_VECTOR '!'#define _C_CONST 'r' Code Meaning r const n in N inout o out O bycopy R byref V oneway 以上信息在具体应用时，可以自定义一个枚举获取。 typedef struct objc_method *Method;struct objc_method &#123; // 方法的名称 SEL method_name; // 方法的参数类型 char *method_types; // 方法的实现(函数指针) IMP method_imp; &#125; 根据方法名称获取MethodMethod class_getInstanceMethod(Class cls, SEL name)Method class_getClassMethod(Class cls, SEL name)获取Method的方法名称SEL method_getName(Method m)获取Method的方法实现IMP method_getImplementation(Method m) IMP class_getMethodImplementation(Class cls, SEL name) 获取Method的返回值类型(需手动释放)char *method_copyReturnType(Method m)//void method_getReturnType(Method m, char *dst, size_t dst_len)获取指定Method的类型const char *method_getTypeEncoding(Method m) 获取Method的参数数量unsigned int method_getNumberOfArguments(Method m)获取Method中第i个参数的类型(Char *类型)(需手动释放)char *method_copyArgumentType(Method m, unsigned int index) 获取方法列表Method *class_copyMethodList(Class cls, unsigned int *outCount) 设置IMPIMP method_setImplementation(Method m, IMP imp)交换方法实现void method_exchangeImplementations(Method m1, Method m2) 添加方法BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) 替换方法 IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) 标明需要手动释放的动态内存(如返回值类型/参数类型)// 及时释放if (argumentType) free(argumentType); 实例演示 - (void)viewDidLoad &#123; [super viewDidLoad]; YAPerson *person = [[YAPerson alloc] init]; // 获取Method Method method = class_getInstanceMethod([person class] , NSSelectorFromString(@"nameWithArg:arg:arg:arg:arg:")); // 获取Method的方法名称 SEL sel = method_getName(method); NSLog(@"%@",NSStringFromSelector(sel)); // 获取Method的方法实现 IMP imp1 = method_getImplementation(method); IMP imp2 = class_getMethodImplementation([person class],sel); // 获取Method的返回值类型(需手动释放) char *returnType = method_copyReturnType(method); if (returnType) &#123; NSLog(@"%@",[NSString stringWithUTF8String:returnType]); free(returnType); &#125; // 获取指定Method的类型 const char *typeEncoding = method_getTypeEncoding(method); if (typeEncoding) &#123; NSLog(@"%@",[NSString stringWithUTF8String:typeEncoding]); &#125; // 获取Method的参数数量 unsigned int arguementCount = method_getNumberOfArguments(method); if (arguementCount &gt; 0) &#123; for (unsigned int i = 0; i &lt; arguementCount; i++) &#123; //获取Method中第i个参数的类型(Char *类型)(需手动释放) char *arguementType = method_copyArgumentType(method, i); NSLog(@"%@",[NSString stringWithUTF8String:arguementType]); // 手动释放 if (arguementType) &#123; free(arguementType); &#125; &#125; &#125; // 设置新的方法实现IMP,并返回原先的IMP IMP imp3 = method_setImplementation(method, imp2);&#125; Method Swizzling使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全地替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现。 Swizzling应该总是在+load中执行 在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证–事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。 Swizzling应该总是在dispatch_once中执行 与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。 /** Method Swizzling 一般放在load方法中,并且使用dispatch_once,需要调用 class_addMethod 方法 */+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class cls = [self class]; SEL oldSelector = NSSelectorFromString(@"XXXX"); SEL newSelector = NSSelectorFromString(@"XXXXXXXX"); Method oldMethod = class_getInstanceMethod(cls, oldSelector); Method newMethod = class_getInstanceMethod(cls, newSelector); // 尝试给旧的方法oldSelector添加新的方法newSelectot的实现,如果已经存在方法实现,则添加失败 BOOL isSuccess = class_addMethod(cls, oldSelector, method_getImplementation(newMethod), method_getTypeEncoding(newMethod)); if (isSuccess) &#123; // 添加成功,那么用旧的方法实现替换新的方法实现 class_replaceMethod(cls, newSelector, method_getImplementation(oldMethod), method_getTypeEncoding(oldMethod)); &#125; else &#123; // 旧的方法已经有了实现,直接交换即可 method_exchangeImplementations(newMethod, oldMethod); &#125; &#125;);&#125;/** 根据class获取方法列表 @param class 类 @return 方法名称数组 */+ (NSArray *)ya_getMethodList:(Class)class &#123; // 方法列表数量 unsigned int methodCount = 0; // 获取方法列表 Method *methodList = class_copyMethodList(class, &amp;methodCount); // 存储方法名称 NSMutableArray *array = [NSMutableArray array]; if (methodList) &#123; for (unsigned int i = 0; i &lt; methodCount; i ++) &#123; // 获取方法 Method method = methodList[i]; // 获取方法名称 SEL sel = method_getName(method); [array addObject:NSStringFromSelector(sel)]; &#125; // 手动释放 free(methodList); &#125; return [NSArray arrayWithArray:array];&#125;/** 交换实例方法实现 @param class 类 @param aSEL 方法一的名称 @param bSEL 方法二的名称 */+ (void)ya_exchangeInstanceMethod:(Class)class firstMethod:(SEL)aSEL secondMethod:(SEL)bSEL &#123; Method aMethad = class_getInstanceMethod(class, aSEL); Method bMethod = class_getInstanceMethod(class, bSEL); // 交换方法实现 method_exchangeImplementations(aMethad, bMethod);&#125;/** 交换类方法实现 @param class 类 @param aSEL 方法一的名称 @param bSEL 方法二的名称 */+ (void)ya_exchangeClassMethod:(Class)class firstMethod:(SEL)aSEL secondMethod:(SEL)bSEL &#123; Method aMethad = class_getClassMethod(class, aSEL); Method bMethod = class_getClassMethod(class, bSEL); // 交换方法实现 method_exchangeImplementations(aMethad, bMethod);&#125;/** 为类添加名为newSEL的(实例)方法 @param class 类 @param aSEL 新的方法名称 @param bSEL 已经存在的方法名称 @return 是否添加成功 */+ (BOOL)ya_addMethod:(Class)class newSEL:(SEL)aSEL existSEL:(SEL)bSEL &#123; // 获取已经存在的方法 Method method = class_getInstanceMethod(class, bSEL); // 获取已经存在的方法的实现 IMP imp = class_getMethodImplementation(class, bSEL); // 获取type const char *type = method_getTypeEncoding(method); // 给class添加名称为aSEL的方法实现 return class_addMethod(class, aSEL, imp, type); /* 如果父类中已经有该名称的方法,那么调用后将重写该方法 如果本类中已经有了该名称的方法实现,那么将添加失败 */&#125; Propertytypedef struct objc_property *objc_property_t;属性相关信息typedef struct &#123; const char *name; const char *value; &#125; objc_property_attribute_t;获取属性objc_property_t class_getProperty(Class cls, const char *name)获取属性列表objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)获取属性信息列表objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)获取属性信息中某个Valuechar *property_copyAttributeValue(objc_property_t property, const char *attributeName)添加属性BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)替换属性void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)获取属性名称const char *property_getName(objc_property_t property) 获取属性相关信息const char *property_getAttributes(objc_property_t property) 实例演示 - (void)viewDidLoad &#123; YAPerson *person = [[YAPerson alloc] init]; Class cls = [person class]; // 获取属性 objc_property_t property = class_getProperty(cls, "school"); // 获取属性名称 const char *propertyName = property_getName(property); printf("%s\n",propertyName); // 获取属性信息列表 // objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount) // 获取属性相关信息 const char *propertyAttributes = property_getAttributes(property); printf("%s\n",propertyAttributes); // 打印 T@"NSObject",W,N,V_school // 根据获取属性信息中的name获取对应的Value char *propertyValue = property_copyAttributeValue(property, "T"); // 类型 printf("%s\n",propertyValue); /* T 类型 例如:NSObject V 值(成员变量) 例如 _school C copy N nonatommic */ // 添加属性 objc_property_attribute_t type = &#123; "T", [[NSString stringWithFormat:@"@\"%@\"",NSStringFromClass([NSString class])] UTF8String] &#125;; //type objc_property_attribute_t ownership0 = &#123; "C", "" &#125;; // C = copy objc_property_attribute_t ownership = &#123; "N", "" &#125;; //N = nonatomic objc_property_attribute_t backingivar = &#123; "V", [[NSString stringWithFormat:@"_%s", "propertyName"] UTF8String] &#125;; //variable name objc_property_attribute_t attrs[] = &#123; type, ownership0, ownership, backingivar &#125;; if (class_addProperty(cls, "propertyName", attrs, 4)) &#123; NSLog(@"添加成功"); &#125; // 替换属性 //void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)&#125;/** 根据class获取类的属性列表 @param class 类 @return 属性列表数组 */+ (NSArray *)ya_getPropertyList:(Class)class &#123; // 私有/公有/类扩展中的所有属性数量 unsigned int count = 0; // 获取属性列表 objc_property_t *propertyList = class_copyPropertyList(class, &amp;count); // 存储属性名称 NSMutableArray *array = [NSMutableArray array]; for (unsigned int i = 0; i &lt; count; i ++) &#123; const char* c_propertyName = property_getName(propertyList[i]); [array addObject:[NSString stringWithUTF8String:c_propertyName]]; &#125; // 手动释放 free(propertyList); return [NSArray arrayWithArray:array];&#125; Protocol本部分应用较少，未做详细实践。 struct objc_protocol_list &#123; struct objc_protocol_list *next; long count; __unsafe_unretained Protocol *list[1];&#125;;是否遵循协议BOOL class_conformsToProtocol(Class cls, Protocol *protocol)协议列表Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount)Protocol * __unsafe_unretained *objc_copyProtocolList(unsigned int *outCount)Protocol * __unsafe_unretained *protocol_copyProtocolList(Protocol *proto, unsigned int *outCount)动态添加协议BOOL class_addProtocol(Class cls, Protocol *protocol) 获取指定名称的协议Protocol *objc_getProtocol(const char *name)协议A是否遵循协议BBOOL protocol_conformsToProtocol(Protocol *proto, Protocol *other)两个协议是否相等BOOL protocol_isEqual(Protocol *proto, Protocol *other)获取某个协议的名称const char *protocol_getName(Protocol *p)动态生成协议Protocol *objc_allocateProtocol(const char *name)void objc_registerProtocol(Protocol *proto) 给协议添加方法void protocol_addMethodDescription(Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod) 给协议添加协议void protocol_addProtocol(Protocol *proto, Protocol *addition) 给协议添加属性void protocol_addProperty(Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty) 根据class获取遵循的协议列表/** 根据class获取遵循的协议列表 @param class 类 @return 协议名称列表 */+ (NSArray *)ya_getProtocolList:(Class)class &#123; // 协议列表数量 unsigned int count = 0; // 获取协议列表 __unsafe_unretained Protocol **protocolList = class_copyProtocolList(class, &amp;count); // 存储协议 NSMutableArray *array = [NSMutableArray array]; for (NSInteger i = 0; i &lt; count; i ++) &#123; // 获取协议 Protocol *protocol = protocolList[i]; // 获取协议名称 const char *c_protocolName = protocol_getName(protocol); [array addObject:[NSString stringWithUTF8String:c_protocolName]]; &#125; // 手动释放 free(protocolList); return [NSArray arrayWithArray:array];&#125; 二、技能消息转发第一步：+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel_isEqual(sel, NSSelectorFromString(@"ss"))) &#123; // 要求参数要匹配 [YARuntime ya_addMethod:[self class] newSEL:sel existSEL:@selector(printPersonalInfo)]; return YES; &#125; return [super resolveInstanceMethod:sel];&#125; 第二步：- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (sel_isEqual(aSelector, NSSelectorFromString(@"ss"))) &#123; // 转发给已经存在的对象 return [[YAPerson alloc] init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 第三步：- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; // 没有找到signature(方法签名),只能手动提供 if (signature == nil) &#123; signature = [NSMethodSignature signatureWithObjCTypes:"@@:"]; &#125; return signature;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; YAPerson *personClass = [[YAPerson alloc] init]; SEL sel = anInvocation.selector; if ([personClass respondsToSelector:sel]) &#123; // 最后一次机会 [anInvocation invokeWithTarget:personClass]; &#125; else &#123; // 回天乏力 [self doesNotRecognizeSelector:sel]; &#125;&#125; 多重继承 不会做菜的程序员不是好男人。 YADeveloper 继承自 YAMan，想让YADeveloper实例对象同时具备响应 YAMan方法和 YACook方法的能力。 YAMan: @interface YAMan : NSObject- (void)printMan;@end@implementation YAMan- (void)printMan &#123; NSLog(@"我是一个男人");&#125;@end YACook: @interface YACook : NSObject - (void)printCook;@end@implementation YACook- (void)printCook &#123; NSLog(@"我是个会做菜的人");&#125;@end YADeveloper: @class YACook;@interface YADeveloper : YAMan@property (nonatomic,strong) YACook *cook;- (void)printDev;// 声明YACook的方法,使编译通过- (void)printCook;@end@implementation YADeveloper- (void)printDev &#123; NSLog(@"我是个会写程序的人");&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (sel_isEqual(aSelector, NSSelectorFromString(@"printCook"))) &#123; // 需要预先对self.cook初始化 return self.cook; // 或者直接创建 // return [[YACook alloc] init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125;@end 关联引用注意点: objc_removeAssociatedObjects 函数一般不可手动调用，因为这个函数会移除一个对象的所有关联对象，将该对象恢复成“原始”状态。这样做就很有可能把别人添加的关联对象也一并移除，这并不是我们所希望的。所以一般的做法是通过给 objc_setAssociatedObject 函数传入 nil 来移除某个已有的关联对象。 关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的。给分类添加weak属性 给任意对象A 添加 weak属性 B 问题关键点:在属性销毁的时候，将其置为空(或者说在关联对象销毁的时候，使objc_getAssociatedObject得到的是nil)。 方法一通过继承关联对象B ，重写其dealloc方法即可适时把A中的关联对象返回值设置为nil，达到自动置空的目的，这也是最本能的方法。 给NSObject添加分类，也即任何继承自NSObject的对象都可以有weak属性。 @interface NSObject (YAWeakProperty)@property (nonatomic, weak) YAProperty *property;@end@implementation NSObject (YAWeakProperty)// const static char *key = "key";- (id)property &#123; return objc_getAssociatedObject(self, @selector(property));&#125;- (void)setProperty:(YAProperty *)property &#123; objc_setAssociatedObject(self, @selector(property), property, OBJC_ASSOCIATION_ASSIGN); [property setAssociate:self selector:@selector(setProperty:)];&#125;@end 关联引用的key一般使用getter方法的selector，此时get方法中的key也可使用_cmd，二者等效。 属性的实现: @interface YAProperty : NSObject- (void)setAssociate:(NSObject *)associatedObject selector:(SEL)sel;@end// 类扩展@interface YAProperty()&#123; __weak id _associatedObject; SEL _sel;&#125;@end@implementation YAProperty- (void)setAssociate:(NSObject *)associatedObject selector:(SEL)sel &#123; _associatedObject = associatedObject; _sel = sel;&#125;- (void)dealloc &#123; ((void (*)(id, SEL,id)) objc_msgSend)(_associatedObject, _sel, nil);&#125;@end 然而有个问题：添加的属性继承自NSObject时非常完美，但是实际项目中不可能给任意对象添加的属性都是NSObject，有可能是NSString/NSArray/NSDictionary/NSSet等等。那么就只能继承自NSString/NSArray/NSDictionary/NSSet等系统类，这样会出现一系列一系列一系列问题，苹果并不建议我们使用NSString/NSArray/NSDictionary/NSSet等的派生类(这些类已经足够好了，不需要画蛇添足)。 方法二 用一个NSPointerArray（弱引用类型的数组）包一层就可以了。虽然关联属性的policy不支持weak，但是你可以把要关联的对象放入一个弱引用数组里面，然后把这个弱引用数组设置为关联对象，每次取值的时候，只需要从这个弱引用数组里面取就可以了。一样可以达到关联弱引用对象的效果。 方法三A 关联 CB 关联 CC 销毁 通知BB 再告诉 A 方法四阅读大神博客发现的新方法，见2019年新写的文章： Weak Associated Object 三、要点free()free() 函数用来释放动态分配的内存空间，其原型为： void free (void* ptr);free() 可以释放由 malloc()、calloc()、realloc() 分配的内存空间，以便其他程序再次使用。// 及时释放字符串常量if (argumentType) free(argumentType); NONNULLNS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。在这两个宏之间的代码，所有简单指针对象都被假定为 nonnull#define NS_ASSUME_NONNULL_BEGIN _Pragma("clang assume_nonnull begin")#define NS_ASSUME_NONNULL_END _Pragma("clang assume_nonnull end") __covariant__covariant - 协变性，子类型可以强转到父类型（里氏替换原则）__contravariant - 逆变性，父类型可以强转到子类型（WTF） __kindof 内联__attribute__((always_inline)) 的意思是强制内联 参考并感谢青玉伏案南峰子]]></content>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源项目：YAScrollPlaceView]]></title>
    <url>%2F2017%2F10%2F01%2F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9AYAScrollPlaceView%2F</url>
    <content type="text"><![CDATA[2019.8.4 补充内容 可以给UIScrollView、UITableView添加头尾视图。 一、前言百度畅听是我工作后的第一个项目，大概就是手百里面的“喜马拉雅”。 某一天UE提了个需求，大意就是在UITableView底部加个logo图片，要求这张图片能随着UITableViewCell的滑动而跟着滑动。乍一想，可以使用直接使用UITableView的tableFooterView，赋值个UIImageView即可，可是还有一个要求：当数据很少的时候，这个logo图片必须紧挨着屏幕最下方。很显然，tableFooterView自己会跑到顶部，满足不了需求。 关键是，那一阵子刚读了MJRefresh的源码，又痴迷于Runtime的各种魔法，走火入魔的厉害，还特别想写一个开源项目逞能，于是这个能给UIScrollView添加头部、尾部视图的框架产生了。 项目地址:https://github.com/ChenYalun/YAScrollPlaceView 二、思路思路很简单。 使用KVO监听UIScrollView的contentSize和contentOffset。 根据contentSize确定FooterView的位置。 // 伪代码HeaderView.y = -size.height;FooterView.y = contentSize.height; 设置UIScrollView的contentInset，给占位视图腾出空间。 根据contentOffset.y确定当前占位视图是否可以跟着滑动。// 伪代码if (contentOffset.y + scrollView.height - scrollView.contentInset.bottom - scrollView.contentSize.height &gt;= 0) &#123; FooterView.y = contentOffset.y + scrollView.height - scrollView.contentInset.bottom;&#125; 大致就是这样，剩下的就是时机和接口了。 在didMoveToSuperview中添加KVO，在willMoveToSuperview中移除KVO。 这两个成双成对，之所以不放在dealloc里面移除，是考虑到有同一个视图被didMoveToSuperview多次的情况。当然，视图dealloc的时候是会调用willMoveToSuperview方法的，只不过这个newSuperview为空。 给UIScrollView添加关联属性。无需多言，没有侵入性。 - (YAScrollHeaderView *)scrollHeaderView &#123; return objc_getAssociatedObject(self, @selector(scrollHeaderView));&#125;- (void)setScrollHeaderView:(YAScrollHeaderView *)scrollHeaderView &#123; if (scrollHeaderView == self.scrollHeaderView) return ; [self.scrollHeaderView removeFromSuperview]; [self addSubview:scrollHeaderView]; objc_setAssociatedObject(self, @selector(scrollHeaderView), scrollHeaderView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125; 结构设计 YAScrollHeaderView和YAScrollFooterView均继承自YAScrollPlaceView。（这是模仿了MJRefresh）。核心逻辑统一在上层实现。 YAScrollHeaderView在初始化的时候设置自己scrollPlaceViewType为YAScrollPlaceViewTypeHeader。 YAScrollFooterView在初始化的时候设置自己scrollPlaceViewType为YAScrollPlaceViewTypeFooter。这样，YAScrollPlaceView就可以根据子类来确定占位视图的逻辑。 三、使用暴露出来的接口很清晰。isFixed用于设置占位视图是否在offset超出可见区域（过大或者过小）时跟随着滑动。这个占位视图可以动态显示或者隐藏，canAnimate设置其动画效果，showAnimationDuration和dismissAnimationDuration不必多说，是动画时间。 @property (nonatomic, assign) BOOL isFixed; ///&lt; default NO.Fix the place view to the top or bottom.@property (nonatomic, assign) BOOL canAnimate; ///&lt; default YES.@property (nonatomic, assign) CGFloat height; ///&lt; default 0@property (nonatomic, assign, readonly) BOOL isVisible;; ///&lt; default NO.@property (nonatomic, assign) NSTimeInterval showAnimationDuration; ///&lt; default 0.15@property (nonatomic, assign) NSTimeInterval dismissAnimationDuration; ///&lt; default 0.15- (void)showWithCompletion:(YAScrollPlaceViewShowCompletion)completion;- (void)dismissWithCompletion:(YAScrollPlaceViewDismissCompletion)completion; 给ScrollView设置占位图片UIImage *headerImage = [UIImage imageNamed:@"header"];YAScrollHeaderView *headerView = [YAScrollHeaderView scrollHeaderViewWithSize:CGSizeMake(self.view.bounds.size.width, 100) backgroundImage:headerImage];self.scrollView.scrollHeaderView = headerView; 左图：数据较多时，视图固定（也可以配置不固定）；右图：数据极少时，视图不固定、跟着滑动（也可以配置为固定）。 给tableView设置空白占位YAScrollFooterView *footerView = [YAScrollFooterView new];footerView.height = 100;footerView.isFixed = YES;self.tableView.scrollFooterView = footerView; 动态地显示或者隐藏self.tableView.scrollHeaderView = self.header;self.header.showAnimationDuration = 0.8f;self.header.dismissAnimationDuration = 0.8f;[self.header show];// [self.header dismissWithCompletion:nil]; 四、总结整体而言，实现起来还是比较轻松的，没有啥极其复杂的逻辑。不过作为我的第一个开源Framework，还挺有纪念意义的。有一方有二，二生三，三生万物。 后记2018年秋，存在两年的百度畅听正式下线。喜马拉雅、懒人听书，还活着。2019年8月，整理博客时，完善文章内容并修复框架的bug。]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找算法总结]]></title>
    <url>%2F2017%2F04%2F21%2F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于查找算法。 前言 本文”完全二叉树”的定义采用国内定义B-树 即 B树,两者是相同概念,而非指二叉搜索树(百度百科) 争议1.国内早期教材中，满二叉树一般指 perfect binary tree，所以会有满二叉树是完全二叉树的一个特例的说法. 2.树的深度的定义，有的根结点从0开始计数，有的从1开始计数. 3.结点 与 节点 是对Node的翻译,可以看做等同. 维基百科定义1.根二叉树(Rooted Binary Tree)：有一个根结点，每个结点至多有两个孩子。 2.满二叉树(Full Binary Tree)：要么是叶子结点(结点的度为0)，要么结点同时具有左右子树(结点的度为2)。 3.完全二叉树(Complete Binary Tree)：每层结点都完全填满，在最后一层上如果不是满的，则只缺少右边的若干结点。 4.完美二叉树(Perfect Binary Tree)所有的非叶子结点都有两个孩子，所有的叶子结点都在同一层。即每层结点都完全填满。 5.无限完全二叉树(Infinite Complete Binary Tree)： 每个结点都有两个孩子，结点的层数是无限的。 6.平衡二叉树(Balanced Binary Tree)：也称为AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 满二叉树(Full Binary Tree)如果一棵二叉树的结点要么是叶子要么有两个孩子结点,则为满二叉树 性质:1.总结点个数呈现个数为:0 1 3 7 15…满足2^(n) -1,其中n为树的深度(最大层) 2.第k层(k不为0)结点个数:1 2 4 8…满足2^(k - 1) 3.满二叉树是完全二叉树 完全二叉树(Complete Binary Tree)若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。 性质:完全二叉树中度为1的结点数只有两种可能0或1,那么:总结点数为n,有 n0=n/2 或 n0=(n+1)/2 存储顺序存储的排序数组插入和删除的时候时间复杂度达到O(n),顺序存储结构不适于动态的情况 链式存储链表的查找需要O(n) 查找查找表:由同一类型的数据元素构成的集合.关键字:数据元素中某个数据项的值.主关键字:可以唯一地标识一个记录.次关键字:可以识别多个数据元素.查找:根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素(或记录).静态查找表:只作查找操作的查找表.动态查找表:在查找过程中同时插入查找表中不存在的数据元素,或者从查找表中删除已经存在的某个数据元素. 顺序表查找顺序查找(线性查找):从表中第一个记录开始,逐个进行记录的关键字和给定值的比较. # 顺序查找的实现def sequentialSearch(key, numbers): length = len(numbers) for i in xrange(length): # 查找成功返回索引 if key == numbers[i]: return i # 查找失败返回-1 return -1 最好情况:在第一个位置找到,时间复杂度为O(1)最坏情况:在最后一个位置找到,时间复杂度O(n)查找不成功:时间复杂度O(n)平均查找次数:(n+1)/2平均时间复杂度:O(n) 有序表查找1.二分查找 折半查找(二分查找):在线性表中的记录有序的前提下进行查找.取中间元素作为比较对象,若给定值与中间元素相等,则查找成功,若给定值小于中间元素,则在中间元素的左半区继续查找,若给定值大于中间元素,则在中间元素的右半区继续查找,不断重复查找过程,直到查找成功,或查找失败. # 二分查找的实现def binarySearch(key, numbers): # 左边界 low = 0 # 右边界 high = len(numbers) - 1 while low &lt;= high: # 中间元素索引 mid = (low + high) / 2 # 查找成功 if numbers[mid] == key: return mid # 在左区间 if numbers[mid] &gt; key: high = mid - 1 # 在右区间 if numbers[mid] &lt; key: low = mid + 1 # 查找失败返回-1 return -1 最好情况:是中间元素,一次即可找到,时间复杂度O(1)最坏情况:完全二叉树的深度加1,即floor(logn) + 1次,时间复杂度O(logn).(注意:logn这里指以2为底,floor表示向下取整) 2.插值查找二分查找的优化版,核心是插值公式:(key - numbers[low]) / (numbers[high] - numbers[low]) 核心代码: // 插值mid = low + (high - low) * (key - numbers[low]) / (numbers[high] - numbers[low]) # 插值查找的实现def interpolationSearch(key, numbers): # 左边界 low = 0 # 右边界 high = len(numbers) - 1 while low &lt;= high: # 核心代码 mid = low + (high - low) * (key - numbers[low]) / (numbers[high] - numbers[low]) # 查找成功 if numbers[mid] == key: return mid # 在左区间 if numbers[mid] &gt; key: high = mid - 1 # 在右区间 if numbers[mid] &lt; key: low = mid + 1 # 查找失败返回-1 return -1 从时间复杂度上,依然是O(logn),但是对于表长较大,关键字分布比较均匀的查找表,性能相对二分查找更好.但是,分布极不均匀的数据,不是很合适,比如[1,2,4,3000,3003…9988899,8988998] 插值查找在实际使用时，一般要满足两个假设条件： (1)每一次对数据的访问与通常的指令相比，费用都是相当昂贵的。例如，待查找的表一定是在磁盘而非内存中，因而每一次比较都要进行磁盘访问。 (2)数据不仅是已被排好序的，而且呈现均匀分布特征。 3.斐波那契查找利用黄金分割原理实现,折半查找算法来进行修改和改进.对于斐波那契数列,前后两个数字的比值随着数列的增加,越来越接近黄金比值:0.618 0.01.00.50.6666666666670.60.6250.6153846153850.6190476190480.6176470588240.6181818181820.617977528090.6180555555560.6180257510730.6180371352790.6180327868850.6180344478220.61803381340.6180340557280.6180339631670.618033998522...... 对于斐波那契数列:0 1 1 2 3 5 8 13 21 34 55 89 … 原理:比如这里的89，假定它是整个有序表的元素个数，而89是由前面的两个数34和55相加之后的和，也即把元素个数为89的有序表分成由前55个数据元素组成的前半段和由后34个数据元素组成的后半段，那么前半段元素个数和整个有序表长度的比值就接近黄金比值0.618，假如要查找的元素在前半段，那么继续按照斐波那契数列来看，55 = 34 + 21，所以继续把前半段分成前34个数据元素的前半段和后21个元素的后半段，继续查找，如此反复，直到查找成功或失败. 当有序表的元素个数不是斐波那契数列中的某个数字时，需要把有序表的元素个数长度补齐，让它成为斐波那契数列中的一个数值,也即把需要补齐的的元素都赋值为有序表的最大值。 核心:(1)当key == numbers[mid],查找成功(2)当key &lt; numbers[mid],新范围是第low个到第mid-1个,范围个数是F(k-1) - 1个,即有序列表左边的长度(3)当key &gt; numbers[mid]时,新范围是第mid+1到第high个,范围个数是F(k-2) - 1个,即有序列表右边的长度 k 表示列表的长度k-1表示索引F(k-1)表示列表最后一个元素 元素总个数 = 左区间个数 + 右区间个数 + 中间的一个元素,即: F(k)-1 = F(k-1)-1 + F(k-2)-1 + 1 斐波那契查找算法如下： # 斐波那契查找def Fbonacci(index): if index &lt; 0: return a, b = 0, 1 for i in range(index): a, b = b, a + b return a def FbonacciSearch(key, numbers): # 确定该序列在斐波那契数列中的位置 n, length = 0, len(numbers) while length &gt; Fbonacci(n) - 1: n += 1 # 填满元素 for i in xrange(n,Fbonacci(n)): numbers.append(numbers[-1]) low, high = 0, n - 1 while low &lt;= high: # 获取黄金分割下标 mid = low + Fbonacci(n - 1) - 1 # 左区间 #若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1 if key &lt; numbers[mid]: high = mid - 1 n -= 1 # 右区间 #若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1 if key &gt; numbers[mid]: low = mid + 1 n -= 2 # 相等 else: # 成功找到 if mid &lt;= n: return mid # 补全的数,返回n else: return n return -1 4.比较二分查找是加法与除法运算插值查找是复杂的四则运算斐波那契查找是加减法运算 线性索引查找索引:把一个关键字与它对应的记录相关联的过程.线性索引:把索引项集合组织为线性结构,也即索引表 1.稠密索引稠密索引:将数据集的每个记录对应一个索引项,且索引项一定按照关键码有序排列. 2.分块索引对数据集进行分块,使分块有序,然后对每一块建立一个索引项,从而减少索引项的个数. 块需要满足的条件:(1)块内无序:每一块的记录不要求有序.(2)块间有序:比如,要求第二块所有记录的关键字均要大于第一块所有记录的关键字.第三块大于第二块… 分块索引的索引项结构: 最大关键码:存储每一块中点最大关键字 存储块中记录的个数,便于循环 用于指向块首数据元素的指针,便于遍历 查找分两步:(1)在分块索引表中查找关键字所在的块.(2)根据块首指针找到相应的块,并在块中顺序查找关键码. 设n个记录被平均分成m块,每个块t条记录,则n=mt查找索引表的平均查找长度:(1+m)/2查找记录的平均查找长度:(t+1)/2 则块中查找记录的平均查找长度: (1+m)/2 + (t+1)/2 = (m+t)/2+1 = (n/t+t)/2+1 最佳情况:m与t相等,也即n = t^2 = m^2 ,则原式为: = (t*t/t+t)/2+1 = t+1 = n^0.5 + 1 (^ 表示次方) 由此分块索引比顺序查找O(n)提高不少. 3.倒排索引索引项的结构:次关键码与记录号表根据属性(次关键码,字段)的值查找记录.该索引表中的每一项包括一个属性值和具有该属性值的各记录的地址.由于不是由记录确定属性值而是由属性值确定记录,因而称为倒排索引. 优点:生成索引表后不用读取记录就可知道结果,查找非常快缺点:记录号不定长 二叉搜索树如果查找的数据集是有序线性表,并且是顺序存储的,可以使用二分查找/插值查找/斐波那契查找,但是在插入删除操作上耗费大量时间,由此引出既可以使得插入删除效率不错又可以高效率查找的算法====&gt;使用二叉树数据结构:在创建集合时就考虑使用二叉树结果,而且是排好序的二叉树.构造二叉搜索树的目的不是为了排序,而是为了提高插入/删除的效率. 二叉查找树,也称(二叉搜索树,有序二叉树,排序二叉树,二叉排序树）,是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 性质:1.左小于根小于右2.值不重复3.”中序遍历“可以让结点有序4.二叉搜索树有两种结点删除方式:取被删除结点的右子树中的最小元素替代或者取被删除结点的左子树中的最大元素替代 优势:查找、插入的时间复杂度较低。为O(log n)二叉查找树的最坏效率是O(n),此时退化为线性结构 # -*- coding:utf-8 -*-class BinarySearchTreeNode(): def __init__(self,val = 0): self.val = val self.left = None self.right = None # 寻找结点 def find(self, data): if self.val == data: return True elif data &lt; self.val and self.left: return self.left.find(data) elif data &gt; self.val and self.right: return self.right.find(data) else: return False # 寻找最小结点 def findMinData(self): if self.left: return self.left.findMinData() else: return self.val # 寻找最大结点 def findMaxData(self): if self.right: return self.right.findMaxData() else: return self.val # 插入结点 # 当data与二叉搜索树中某结点val相等时不作处理 def insertNode(self, data): # 在右子树上 if self.val &lt; data: if self.right: self.right.insertNode(data) else: self.right = BinarySearchTreeNode(data) # 在左子树上 if self.val &gt; data: if self.left: self.left.insertNode(data) else: self.left = BinarySearchTreeNode(data) # 打印二叉搜索树 # 左根右遍历 def printTree(self): if self.left: self.left.printTree() print self.val, if self.right: self.right.printTree() # 结点的删除 # 当删除一个叶子结点时,直接删除即可 # 当删除的结点只有一个孩子时,用该孩子替换 # 当删除的结点有两个孩子时,寻找该结点右子树中的最小数据代替子节点 def daleteNode(self, data): # 前提是该结点在二叉搜索树中能找到 if not self.find(data): return self if data &lt; self.val: self.left = self.left.daleteNode(data) return self elif data &gt; self.val: self.right = self.right.daleteNode(data) return self elif self.left and self.right: # 找到右子树最小的结点,获取值 val = self.right.findMinData() # 把最小结点的值给自己 self.val = val # 删除右子树中的最小结点,使self.right指向右子树的根节点 # self.right.daleteNode(val)最终返回右子树的根节点 self.right = self.right.daleteNode(val) return self else: # 左结点存在 if self.left: # 直接指向左结点 return self.left # 右结点存在,或不存在结点 else: # 直接指向右结点 return self.righta = BinarySearchTreeNode(10)a.insertNode(8)a.insertNode(12)a.insertNode(6)a.insertNode(9)a.insertNode(11)a.insertNode(14)a.insertNode(7)a.insertNode(13)a.insertNode(5)a.insertNode(2)a.printTree()print "\n"print a.find(11)print a.find(100000)print a.findMaxData()print a.findMinData()a.daleteNode(1000000)a.daleteNode(10)a.daleteNode(14)a.daleteNode(2)a.printTree() 二叉搜索树以链接的方式存储,保持了链接存储结构在执行插入或删除时的优越性. 对于二叉搜索树的查找,比较次数等于给定值的结点在二叉搜索树的层数.最少为1次(为根节点),最多不超过树的深度(最差是极端的右斜树或左斜树). 二叉排序树倘若是平衡的,其深度与完全二叉树相同,均为floor(logn) + 1,查找的时间复杂度为O(logn),近似与折半查找,若不是平衡的,甚至演化为极端的右斜树或左斜树,查找的时间复杂度为O(n),等同于顺序查找. 因此,平衡至关重要. 平衡二叉树(AVL树)平衡二叉搜索树是改进的二叉搜索树,也是二叉搜索树。 一般的二叉搜索树的查询复杂度是跟深度有关，因此当结点的深度普遍较大时，查询的均摊复杂度会上升，为了更高效的查询，平衡树应运而生了。 可以使查找树的高度为 O (log(n)) 定义:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 AVL树中的每个结点都有一个平衡因子（balance factor，BF），它表示这个结点的左、右子树的深度差，也就是左子树的深度减去右子树的深度的结果值。AVL树上所有结点的BF值只能是-1、0、1。反之，只要二叉树上一个结点的BF的绝对值大于1，则该二叉树就不是平衡二叉树。在进行插入和删除的时候找出失去平衡的节点，进行必要的旋转操作保证树的平衡。 查找、插入和删除在平均和最坏情况下都是O（log n） 最少结点设n(h)是高度为h的AVL树，则结点数最少时有:n(h) = n(h-1) + n(h-2) + 1 h(VAL树的高度) 最少结点数 0 1 1 2 2 4 3 7 4 12 5 20 … … 显而易见，满足的关系为:高度为h的AVL树，其最少结点数量为F(h+2) - 1，其中F(x)为斐波那契数列逗号且规定从1开始，即F(0) = 1，F(1) = 2 调整RR(右单旋):麻烦结点在发现结点的右子树的右子树上 RL():麻烦结点在发现结点的右子树的左子树上 LL(左单旋):麻烦结点在发现结点的左子树的左子树上 LR():麻烦结点在发现结点的左子树的右子树上 堆堆:用数组表示的完全二叉树有序性:任一结点的关键字是其子树所有结点的最大值(或者最小值)，从根结点到任意结点路径上结点序列的有序性。最大堆,也称为大顶堆:最大值最小堆,也称为小顶堆:最小值 最大堆的建立:方法一:自底向上调整堆，首先将n个节点按输入顺序存入，使其满足完全二叉树的结构特性，然后调整各节点的位置。 方法二:通过插入操作，将n个元素一个个地相继插入到一个初始为空的堆中，其时间代价最大为O(nlogn)。 堆顶元素的删除元素的插入 哈夫曼树带权路径长度:设二叉树有n个叶子节点，每个叶子节点带有权值W，从根节点到每个叶子节点的长度为L，则每个叶子节点的带权路径长度之和为WPL=∑WL。哈夫曼树即是最优二叉树:WPL最小的二叉树。 性质: 没有度为1的结点(按照构造哈夫曼树的规则，显而易见)。 n个叶子节点的哈夫曼树共有 2 * n - 1个结点。 哈夫曼树的任意非叶子结点的左右子树交换后仍是哈夫曼树。 对同一组权值的，可能存在不同结构的几棵哈夫曼树，但是它们的WPL是相同的。 性质2推导:根据哈夫曼树没有度为1的结点，则 n1 = 0，又根据 n0 = n2 + 1，sum = n0 + n1 + n2，则有: sum = n0 + n1 + n2 = n0 + n2 = n0 + n0 - 1 = 2 * n0 - 1 = 2 * n - 1 // n即n0 图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片 图a的WPL为 5 2 + 7 2 + 2 2 + 13 2 = 54图b的WPL为 13 1 + 7 2 + 2 3 + 5 3 = 48PL的计算方式为:该节点的权值 * 从根节点到该节点的树枝数量 哈夫曼树的构造:每次把权值最小的两个二叉树合并，参照最大堆的调整。 红黑树红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求： （1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]（4）每个红色节点必须有两个黑色的子节点。（5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。 一棵n个结点是红黑树始终保持了logn的高度,所以红黑树的查找、插入、删除的时间复杂度最坏为O(log n) 红黑树之所以是平衡的二叉查找树，是因为每个节点都有表示其颜色的域值：红或黑，在插入和删除操作的时候依据节点的颜色向平衡的方向调整。 “叶结点” 或”NULL结点”，它不包含数据而只充当树在此结束的指示，这些结点以及它们的父结点，在绘图中都会经常被省略。 当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。 为了继续保持红黑树的性质，我们可以通过对结点进行重新着色，以及对树进行相关的旋转操作 左旋:左右左右旋:右左右 多路查找树(B树)B树即为B-树、B_树,又叫平衡多路查找树.多路查找树:其每一个结点的孩子数可以多于两个,每一个结点处可以存储多个元素. 一个节点只能存储一个元素,在元素非常多的时候,就使得要么树的度非常大,要么树的高度非常大,甚至两者都必须足够大才可以,这使得内存存取外村次数非常多,造成了时间效率上的瓶颈,于是引入多路查找树. 树的高度越高，查找文件所需要的磁盘IO读写次数越多，所以为了减少磁盘的IO读写，要想办法进一步降低树的高度。 因此，具有多个孩子的B树便应运而生，因为B树每一个结点可以有几个到几千个孩子，使得在结点数目一定的情况下，树的高度会大大降低，从而有效减少磁盘IO读写消耗。 B+树、B树等的根结点和部分顶层数据存在内存中，大部分下层数据存在磁盘上。 2-3树2-3树是这样一棵多路查找树:其中的每一个结点都具有两个孩子或三个孩子. 一个2结点包含一个元素和两个孩子(或没有孩子),与二叉排序树类似,左子树包含的元素小于该元素,右子树包含的元素大于该元素,与二叉排序树不同的是,这个2结点要么没有孩子,要么就有两个,不能只有一个孩子. 一个3结点包含一小一大两个元素和三个孩子(或没有孩子),一个3结点要么没有孩子,要么具有3个孩子.如果具有3个孩子的话,左子树包含的元素小于较小元素的元素,右子树包含的元素大于较大元素的元素,中间子树包含介于两元素之间的元素. 并且2-3树中所有叶子都在同一层次上. 2-3树的插入 2-3树的删除 2-3-4树2-3树的概念扩展,包括了4结点的使用.一个4结点包含小中大三个元素和四个孩子(或者没有孩子). B树B树是一种平衡的多路查找树,2-3树和2-3-4树都是B树的特例.结点最大的孩子数目称为B树的阶.2-3树是3阶B树,2-3-4树是4阶B树. A B-tree of order m is a tree which satisfies the following properties: Every node has at most m children. Every non-leaf node (except root) has at least ⌈m/2⌉ children. The root has at least two children if it is not a leaf node. A non-leaf node with k children contains k−1 keys. All leaves appear in the same level 一棵m阶的B树满足以下条件1.每个结点至多有m棵子树2.除根结点外,其他分支结点至少有ceil(m/2)棵子树(ceil()函数向上取整3.根结点至少有两棵子树,除非树只包含一个结点4.有k个孩子的非叶结点有k-1个关键码,关键码按递增次序排列5.所有叶子结点在同一层 B树如何做到减少访问外存次数硬盘将信息分割成相等大小的页面,每次硬盘读写都是一个或者多个完整的页面,对一个硬盘来说,一页的长度可能是211到214字节. 在一个典型的B树应用中,要处理的硬盘数据量很大,因此无法一次全部装入内存,因此需要对B树进行调整,使得B树的阶树与硬盘存储的页面大小相匹配.在有限内存的情况下,每一次磁盘的访问我们都可以获得最大量的数据,由于B树每节点可以具有比二叉树多得多的元素,所以减少了必须访问结点和数据块的数量,提高了性能.B树的数据结构就是为内外存的数据交互准备的. B+树B+ 树是一种树数据结构，通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。 B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。 一棵m阶的B+树与B树的区别在于: 有n棵子树的结点包含有n个关键字 所有的叶子节点包含全部的关键字信息,以及指向含这些关键字记录的指针,叶子节点本身依关键字的大小自小而大顺序链接 所有分支结点可以看成是索引,结点中仅含有其子树的最大(最小)关键字. 好处:如果要随机查找,就从根节点出发,与B树的查找方式相同,只不过即使在分支结点找到了待查找的关键字,它也只是用来索引的,不能提供实际记录的访问,还是需要到达包含此关键字的终端结点. 如果需要从最小关键字进行自小而大的顺序查找,可以从最左端的叶子结点出发,不经过分支结点,而是沿着指向下一叶子的指针就可遍历所有的关键字. B+树适合有范围的查找(比如年龄18–22),从根节点出发找到18,再在叶子结点中按顺序找到符合要求的记录. B+树的插入/删除与B树类似,只不过插入删除的元素都是在叶子结点上进行. 散列表查找存储位置 = f(关键字) 记录的存储位置和它的关键字之间建立的一个确定的对应关系.每个关键字key对应一个存储位置f(key),查找时根据这个确定的对应关系找到给定key的映射f(key). f称为散列函数,又称哈希函数,采用散列技术将记录存储在一块连续的存储空间中,这块连续的存储空间称为散列表或哈希表,关键字对应的记录存储位置称为散列地址. 冲突:key1不等于key2,但是f(key1)=f(key2),key1和key2称为散列函数的同义词. 常用的散列函数1.直接定址法f(key) = a * key + b (a,b为常数) 优点:简单均匀,不会产生冲突,但需要事先知道关键字的分布情况,适合查找表较小且连续的情况. 2.数字分析法手机号码等,对数字进行抽取,反转,左环位移,右环位移等方式合理地将关键字分配到散列表的各位置. 适合处理关键字位数比较大的情况,如果事先知道关键字的分布且关键字的若干位分布均匀,可以使用. 3.平方取中法关键字1234—-&gt;平方后:1522756—–&gt;抽取中间的3位——&gt;227,用作散列地址. 适合不知道关键字的分布,而位数又不是很大的情况 4.折叠法从左到右分割成位数相等的几部分,叠加求和,按照散列表长,取后几位作为散列地址. 9876543210—–&gt;987 654 321 0—–&gt;求和987+654+321+0=1962,求后三位:962 适合不需要事先知道关键字的分布.适合关键字位数较多的情况. 5.除留余数法最常用,散列表长为m的公式: f(key) = key mod p (p&lt;=m) 若散列表表长m,通常p为小于或者等于表长的最小质数或不包含小于20质因子的合数. 6.随机数法f(key) = random(key) 当关键字的长度不等时,采用这个方法. 常用的处理冲突方法1.开放定址法线性探测法 f(key) = (f(key) + d) mod m (d = 1,2,3...) 二次探测法 f(key) = (f(key) + d) mod m (d = 1^2,-1^2,2^2,-2^2,3^2,-3^2...q^2,-q^2,其中q&lt;=m/2) 随机探测法 f(key) = (f(key) + d) mod m (d 是一个随机数列) 2.再散列函数法f(key) = RH(key) 每次发生散列冲突时,就换一个散列函数计算. 3.链地址法提供绝不会找不到地址的保障,但是带来查找时需要遍历单链表的性能损耗. 4.公共溢出区法增添溢出表.对给定值通过散列函数计算出散列地址后,先与基本表的相应位置进行比对,如果相等,成功,否则,到溢出表中进行顺序查找. 参考并致谢知乎 灰杉树HAIYANG XUv_JULY_v]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《Objective-C高级编程》]]></title>
    <url>%2F2017%2F04%2F13%2F%E8%AF%BB%E3%80%8AObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[2019.08.21 删除IMP调用示例、删除block中的一些误解 关于ARC/Block/GCD。 读感寒假里就大致看了一遍，但是吸收的不完全。这两三天又赶紧从图书馆借来翻一翻，还是收获满满。这里记下一些比较好玩的问题。 问题一.为什么苹果主要采用散列表管理引用计数GNUstep将引用计数保存在对象占用内存块头部的变量中。优点： 只需少量代码。 能统一管理引用计数用内存块与对象用内存块。 苹果采用散列表（引用计数表，DenseMap 类实现）管理引用计数。优点： 对象用内存块的分配无需考虑内存块头部。 引用计数表记录中存有内存块地址，可追溯各对象的内存块。有助于检测对象的持有者是否存在，可检测内存泄漏。 注：如果设备是 64 位环境并且使用 Objective-C 2.0，那么“一些”对象会使用其 isa 指针的一部分空间来存储它的引用计数。 苹果为什么不采用垃圾回收（GC）？ 苹果曾在OS X 10.5 尝试使用，不过在 10.7 的时候把 GC 换成了 ARC。GC 有个问题让苹果不能忍：垃圾回收的时候，整个程序需要暂停，英文把这个过程叫做：Stop the World。所有的对象都需要一起回收时，造成用户体验不好。 ARC相对于GC所具有的优点： ARC工作在编译期，在运行时没有额外开销（ARC是编译器把retain、release等方法插入到代码中的，所以说是工作在编译期）。 ARC的内存回收是平稳进行的，对象不被使用时会立即被回收。而GC的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。 ARC相对于GC所具有的缺点： 需要额外的空间来记录引用数，对象关系发生变化时需要经常修改引用数。 不能处理循环引用问题。 简单介绍GC的原理 基于事实：大部分的对象的生命期都很短。 GC 将内存中的对象主要分成两个区域：Young 区和 Old 区。对象先在 Young 区被创建，然后如果经过一段时间还存活着，则被移动到Old 区。（其实还有一Perm区，但是内存回收算法通常不涉及这个区域）。 Young区的对象因为大部分生命期都很短，每次回收之后只有少部分能够存活，所以采用的算法叫Copying算法，简单说来就是直接把活着的对象复制到另一个地方。Young 区内部又分成了三块区域：Eden区，From区，To区。每次执行 Copying 算法时，即将存活的对象从 Eden 区和 From 区复制到To区，然后交换 From 区和To区的名字（即From 区变成 To 区，To区变成From区）。 Old区的回收算法叫 Mark-Sweep 算法。简单来说，就是只是把不用的对象先标记（Mark）出来，然后回收（Sweep），活着的对象就不动它了。因为大部分对象都活着，所以回收下来的对象并不多。但是这个算法会有一个问题：它会产生内存碎片，所以它一般还会带有整理内存碎片的逻辑，在算法中叫做 Compact。 –参考自自动引用计数(ARC)和垃圾回收(GC) 二.如何提高Objective-C方法的速度采用IMP Caching。一般而言速度是其他方法的两倍。 id autorelease_class = [NSAutoreleasePool class];SEL autorelease_sel = @selector(addObject:);IMP autorelease_imp = [autorelease_class methodForSelector:autorelease_sel]; - (id) autorelease &#123; (*autorelease_imp)(autorelease_class,autorelease_sel,self);&#125; - (id)autorelease &#123; [NSAutoreleasePool addObject:self];&#125; 注：以上是书中的示例代码，实际上在ARC时代已经不需要调用autorelease方法了。作者是想告诉我们，可以直接通过函数指针IMP调用相关方法，绕过消息发送。比如： // 假定需要多次调用某个实例方法- (void)showWithName:(NSString *)name &#123; NSLog(@"my name is %@", name);&#125;// 正常情况下这样调用[self showWithName:@"Ya"];// 可以通过IMP直接调用typedef id(*_IMP) (id, SEL, ...);SEL sel = @selector(showWithName:);_IMP imp = (_IMP)[self methodForSelector:sel];imp(self, sel, @"Ya"); 如果要调用类方法，传入类对象即可： _IMP imp = (_IMP)[self.class methodForSelector:sel];imp(self.class, sel, @"Ya"); IMP默认是无参数，无返回值类型，且自带_cmd和selector。如果要使用带参数或者带返回值的IMP可以重新定义一个“IMP”：_IMP：typedef id (*_IMP)(id, SEL,...);或者关闭Xcode中的编译选项。 三.非显式使用__autoreleasing的场景有哪些场景一:@autoreleasepool。 编译器会检查@autoreleasepool块中的方法，如果不是以alloc/new/copy/mutableCopy开头，则自动把方法返回值的对象注册到autoreleasepool中。 @autoreleasepool &#123; NSObject *object = [[NSObject alloc] init]; // ==&gt;NSObject __strong *object = [[NSObject alloc] init]; NSArray *array = [NSArray array]; // ==&gt;NSArray __autoreleasing *array = [NSArray array]; &#125; 场景二:方法的返回值。 没有显式指定所有权修饰符，所以默认为__strong。由于return使得变量array超出作用域，强引用对应持有的对象会释放。但是该对象作为方法的返回值，编译器自动将其注册到自动释放池中，延缓释放(否则如果立即释放，那返回值就没有意义了)。 - (id)array &#123; NSArray *array = [NSArray array]; // ==&gt;NSArray __strong *array = [NSArray array]; return array;&#125; 场景三:__weak修饰的变量。__weak修饰的变量会被自动注册到自动释放池中。由于__weak不持有对象的强引用，在访问该对象的时候，该对象有可能已经释放，但是要保证能访问到该对象，所以把它注册到自动释放池中，确保@autoreleasepool块结束之前该对象存在。 id __weak object; 场景四:指向对象的指针的指针。指向对象的指针默认__strong修饰。指向对象的指针的指针默认__autoreleasing修饰。 NSObject *o;// ==&gt;NSObject __strong *o; NSObject **o;// ==&gt;NSObject* __autoreleasing *o; 为什么要使用指向对象的指针的指针?通常是回传值。在C函数中，无法返回多个值，借助指针可以回传值。 // 求两个数的和 积NSInteger sum(NSInteger a, NSInteger b, NSInteger *product) &#123; // 计算乘积 *product = a * b; // 返回求和 return a + b;&#125;// 使用NSInteger a = 3, b = 32, summation, product;summation = sum(a,b,&amp;product); NSLog(@"%ld--%ld",summation,product); 在Objective-C中常用于NSError对象。 NSError *error = nil;NSURL *url = [NSURL URLWithString:@"这里是URL"];[NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; stringWithContentsOfURL:encoding:error:方法返回字符串，但是在获取字符串的时候可能发生错误，于是传入指向NSError对象的指针的指针，用于回传值(error是指向对象的指针，*error是该对象，&amp;error是指向对象的指针的指针)。 赋给对象指针时，变量所有权修饰符必须保持一致，否则会出错。修饰error的是__strong，而这里要求传入的指针的类型是__autoreleasing：(NSError * _Nullable __autoreleasing * _Nullable)，修饰符不一致，不符合规则，但是编译器做了转换。 // 转换所有权修饰符NSError *error = nil;NSError __autoreleasing *tmp = error;BOOL result = [obj performOperationWithError:&amp;tmp];error = tmp; 可是为什么要使用__autoreleasing呢? 实际上不注册到自动释放池也能传(返回)值，就像C函数中的回传乘积值一样。但是这样做不符合内存管理规则，只有作为alloc/new/copy/mutableCopy 开头的方法，能够自己生成并持有。也即其他方法的返回值取得对象(就像场景二中的返回值取得对象一样)需要注册到自动释放池。 如这种不符合内存管理规则的代码: while (CFGetRetainCount(object) != 1) &#123; CFRelease(object);&#125;while (_objc_rootRetainCount(object) != 1) &#123; _objc_rootRelease(object);&#125; 四.内存泄漏的场景有哪些1. Core Fundation的类型转换CFMutableArrayRef array = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL); // 引用计数为1printf("%ld\n",CFGetRetainCount(array)); id obj = (__bridge id)array; // 引用计数为2printf("%ld\n",CFGetRetainCount(array)); // 不要使用_objc_rootRetainCount(),很不准很不准很不准//NSLog(@"%d",_objc_rootRetainCount(fontRef)); // 如果不使用CFRelease()就会造成内存泄漏CFRelease(array);printf("%ld\n",CFGetRetainCount(array)); 主要原因是获取到CF对象后没有对其引用计数做出合适的处理。 2. 使用calloc函数创建动态数组// 声明动态数组// 默认为__autoreleasing修饰,需显式指明为__strongid __strong *array = nil;// 使用calloc分配内存array = (id __strong *)calloc(10, sizeof(id));// 使用array[0] = @"Aaren";// 简单释放内存,造成内存泄漏// 实际上对象array[0]还存在free(array); 正确做法: // 声明动态数组// 默认为__autoreleasing修饰,需显式指明为__strongid __strong *array = nil;// 声明容量NSInteger num = 10;// 使用calloc分配内存array = (id __strong *)calloc(num, sizeof(id));// 使用array[0] = @"Aaren";for (NSInteger i = 0;i &lt; num; i ++)&#123; array[i] = nil;&#125;// 释放内存free(array); 注意:1.不要使用malloc函数分配内存，malloc函数分配内存区域没有被初始化为0，可能产生随机访问导致错误，所以还需要使用memset()函数将内存填充为0。 2.对于NSMutableSet/NSMutableArray/NSMutableDictionary等容器，不需要人为手动管理。 3. MRC下的匿名对象[[NSObject alloc] init]; 匿名对象在MRC下会造成内存泄漏(C++中的匿名对象创建完毕后立即调用析构函数做销毁处理)。 但是在ARC环境下，不会造成内存泄漏。 id temp = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(temp,@selector(init));objc_release(temp); 创建完毕立即销毁，这也解释了为什么使用__weak修饰将要创建的对象会有警告。 NSObject * __weak object = [[NSObject alloc] init]; // 或者id __weak object = [[NSObject alloc] init]; 警告：Assigning retained object to weak variable; object will be released after assignment。 4. block的循环引用block作为类实例的成员变量，block内部又强引用着类实例。 @interface YAUser () &#123; block _block;&#125; - (void)func &#123; // 循环引用 _block = ^() &#123; NSLog(@"%p", self); &#125;; &#125; 五.__weak如何实现weak 表的作用是在对象执行 dealloc 的时候将所有指向该对象的 weak 指针的值设为 nil，避免悬空指针。苹果使用一个全局的 weak 表来保存所有的 weak 引用。并将对象作为键，weak_entry_t 作为值。weak_entry_t 中保存了所有指向该对象的 weak 指针。 struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;&#125;; 六.Core Fundation 与 Foundation如何转换1.__bridge只做类型转换，不修改相关对象的引用计数，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。 CFMutableArrayRef array = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);// 引用计数为1printf("%ld\n",CFGetRetainCount(array));// obj强引用该对象(默认为__strong)id obj = (__bridge id)array;// 引用计数为2printf("%ld\n",CFGetRetainCount(array));// 如果不使用CFRelease()就会造成内存泄漏CFRelease(array);printf("%ld\n",CFGetRetainCount(array)); 2.__bridge_transfer常用在CF对象转化成OC对象时，将CF对象的所有权交给OC对象，此时ARC就能自动管理该内存，作用同CFBridgingRelease()。 CFMutableArrayRef array = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL); // 引用计数为1printf("%ld\n",CFGetRetainCount(array)); // obj持有对象 array放弃持有对象,相当于做了CFRelease() id obj = (__bridge_transfer id)array; 3.__bridge_retained与__bridge_transfer 相反，常用在将OC对象转化成CF对象，且OC对象的所有权也交给CF对象来管理，即OC对象转化成CF对象时，涉及到对象类型和对象所有权的转化，作用同CFBridgingRetain()。 NSMutableArray *obj = [NSMutableArray array];CFMutableArrayRef array2 = (__bridge_retained CFMutableArrayRef)obj;// 引用计数为2,obj持有对象,array2也持有对象printf("%ld\n",CFGetRetainCount(array2));// 使用完毕,手动release,否则内存泄漏CFRelease((array2)); 七.简单介绍blockblock是能持有作用域变量的匿名函数，本质上是Objective-C对象。语法格式:^ 返回值类型 参数列表 表达式，其中返回值类型可省略，无参数时参数列表可省略。声明block与声明函数指针类似，执行block与调用函数类似。 // 返回值类型 (*f) 参数类型int (*f)(int) = &amp;func; // 声明blockint (^blk)(int); // 赋值int (^blk2)(int) = ^(int a)&#123; return 0;&#125;; // 起别名typedef int (^block) (int); block的三种类型 如果block没有访问外部的局部变量，或者访问的局部变量被static修饰，block存储在静态区，是NSConcreteGlobalBlock。 其他情况下，语法生成的block存放在栈中，是NSConcreteStackBlock。 当把栈中的block复制到堆上时，是NSConcreteMallocBlock。 block复制到堆上的情况大部分情况下编译器会将创建在栈上的 block 自动拷贝到堆上，只有当 block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法。也就是说，当方法或者函数中block作为参数传递，而这个block不被作为成员变量赋值，我们需要手动调用copy方法。 编译器或者方法内部已经实现copy代码的情况: block作为函数返回值。 赋值给 __strong id 类型的对象或 block 的成员变量。 Cocoa框架方法名含有usingBlock。 GCD中的API。 其他情况需要手动复制。 // 程序异常:栈上的block被废弃 typedef void(^block) (void); - (id)getBlockArray &#123; int val = 10; return [[NSArray alloc] initWithObjects: ^&#123;NSLog(@"blk0:%d", val);&#125;, ^&#123;NSLog(@"blk1:%d", val);&#125;, nil];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; block b = [self getBlockArray][0]; b();&#125; 手动将block 复制到堆上: typedef void(^block) (void);- (id)getBlockArray &#123; int val = 10; return [[NSArray alloc] initWithObjects: [^&#123;NSLog(@"blk0:%d", val);&#125; copy], [^&#123;NSLog(@"blk1:%d", val);&#125; copy], nil];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; block b = [self getBlockArray][0]; b();&#125; block捕获变量1.对于实例变量、静态全局变量、静态局部变量，全局变量，无论其为基本类型还是对象类型，在block中可读可写。 定义在函数内部的变量称为局部变量（Local Variable）。在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域默认是整个程序，也就是所有的源文件。 // 静态全局变量static NSInteger globalAge = 10;static NSString *globalName = @"Aaren";@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 局部变量 NSInteger age = 12; // 静态局部变量 static NSInteger staticAge = 17; static NSString *staticName = @"Bob"; YAUser *user = [[YAUser alloc] init]; void (^func)() = ^() &#123; // 修改实例变量 user.age = 18; user.name = @"Jack"; NSLog(@"%ld",user.age); NSLog(@"%@",user.name); // 修改静态局部变量 staticAge = 22; staticName = @"Lucy"; NSLog(@"%ld",staticAge); NSLog(@"%@",staticName); // 修改静态全局变量 globalAge = 14; globalName = @"Allen"; NSLog(@"%ld",globalAge); NSLog(@"%@",globalName); &#125;; func(); NSLog(@"%ld",user.age); NSLog(@"%@",user.name); NSLog(@"%ld",staticAge); NSLog(@"%@",staticName); NSLog(@"%ld",globalAge); NSLog(@"%@",globalName);&#125;@end 2.对于局部变量，无论其是基本类型还是对象类型，在block中为只读，当使用__block修饰时，变量可读可写。__block修饰的对象类型变量，在ARC环境下，block对其强引用。在非ARC环境下，block不会对其retain。 - (void)viewDidLoad &#123; [super viewDidLoad]; // 局部变量 __block NSInteger age = 17; __block NSString *name = @"Bob"; void (^func)() = ^() &#123; // 修改局部变量 age = 18; name = @"Jack"; NSLog(@"%ld",age); NSLog(@"%@",name); &#125;; func(); // 修改局部变量 age = 22; name = @"Aaren"; NSLog(@"%ld",age); NSLog(@"%@",name);&#125; block的循环引用Capturing ‘self’ strongly in this block is likely to lead to a retain cycle. .h文件 @interface YAUser : NSObject@property (nonatomic, strong) NSObject *object;- (void)func;@end .m文件 typedef void (^block) ();@interface YAUser () &#123; block _block;&#125;@end@implementation YAUser- (void)func &#123; // 循环引用 self.object = [[NSObject alloc] init]; _block = ^() &#123; NSLog(@"%@", self.object); &#125;; _block();&#125;@end 由于block赋值给了成员变量，所以在栈上生成的block被复制到堆上。而block强引用了self的成员变量object，实际上是持有了self，self持有block的同时block持有self，于是self和block循环引用。 解决方案一：采用__weak修饰。- (void)func &#123; // __weak解决循环引用 self.object = [[NSObject alloc] init]; // 声明了一个self类型的weak指针，名字叫做weakSelf. __weak typeof(self) weakSelf = self; _block = ^() &#123; NSLog(@"%@", weakSelf.object); &#125;; _block();&#125; 更改一方的强引用为弱引用打破了循环引用。但是有瑕疵：block内部可能捕获到空值。 - (void)func &#123; // __weak解决循环引用 self.object = [[NSObject alloc] init]; __weak typeof(self) weakSelf = self; _block = ^() &#123; // 现在立即使用weakSelf.object NSLog(@"%@", weakSelf.object); // 需要异步执行,但是却无法保证weakSelf.object一定存在 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"%@",weakSelf.object); &#125;); &#125;; // 调用block _block(); // 自以为block调用完毕,不再需要self.object的值了,大胆地将self.object改为其他值 self.object = nil;&#125; 这种情况就造成block内部正在使用持有变量的时候，变量的值却意外地改变了，甚至为nil，极易引发问题。最佳方案：弱引用加强引用 - (void)func &#123; // __weak解决循环引用 self.object = [[NSObject alloc] init]; __weak typeof(self) weakSelf = self; _block = ^() &#123; // __strong可以不加,默认为__strong,但最好加上,更醒目 __strong NSObject *strongObject = weakSelf.object; // 最好加上判断,保证strongObject不为空 if (strongObject) &#123; // 现在立即使用weakSelf.object NSLog(@"%@",strongObject); // 需要异步执行,可以保证weakSelf.object的值不改变 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"%@",strongObject); &#125;); &#125; &#125;; // 调用block _block(); // 放心地将self.object改为其他值 self.object = nil;&#125; 这么做可以保证在block执行期间持有的变量不改变。但如果在block执行之前该变量已经为nil，那回天乏力。 评价:这种方式不会造成循环引用：block弱引用的方式持有self.object，即不会影响self.object的释放。在block中是通过局部变量强引用self.object，作用域结束，局部变量销毁，不再强引用，从此你我是路人。 注意事项:1.除了使用typeof()之外，还可以直接声明与self相同类型的变量，但依然需要使用__weak修饰。 __weak YAUser *weakSelf = self; 2.循环引用的本质是block强引用了self。但是如果以 以上代码为例：block持有了self的某个成员变量，且block在同一个作用域内得到调用，完全可以通过以下方式解决（非主流方式，大多数情况下不可能在block中只使用一个成员变量，一个脑洞而已，实际开发不要这么做）。 - (void)func &#123; // 循环引用 self.object = [[NSObject alloc] init]; NSObject *weakObject = self.object; _block = ^() &#123; NSLog(@"%@", weakObject); &#125;; _block();&#125; 使用场景:不需要对block中持有的变量进行写入操作，也即仅仅读取变量。当block异步使用持有的变量时，注意弱引用+强引用配合使用。建议统一采用 typeof(self) + 弱引用 + 强引用的形式。 解决方案二：采用__block修饰。产生循环引用的代码: - (void)func &#123; // 循环引用 _block = ^() &#123; NSLog(@"%p", self); &#125;;&#125;- (void)execBlock &#123; _block();&#125; 解决循环引用: - (void)func &#123; // 解决循环引用 __block id tmp = self; _block = ^() &#123; NSLog(@"%p", tmp); // 关键所在 tmp = nil; &#125;;&#125;- (void)execBlock &#123; _block();&#125; 评价:__block本身不能解决循环引用，关键在于 在block中将__block修饰的变量置为空。当需要对持有的变量进行写入操作时可以使用。 注意事项:block必须执行，否则仍然不会解决循环引用。如下面代码: - (void)func &#123; // 解决循环引用 __block id tmp = self; _block = ^() &#123; NSLog(@"%p",tmp); tmp = nil; &#125;;&#125;- (void)execBlock &#123; // block没有执行,仍然不能解决循环引用 // _block();&#125; 为什么block没有执行就无法解决循环引用呢?在block中出现tmp变量的那刻起(tmp变量即self)，block就已经持有了self，即产生了循环引用，如： _block = ^() &#123;tmp;&#125;; 而只有通过执行block才能把nil赋给tmp，才能打破循环引用。因此，执行block的目的是把nil赋予tmp，而把nil赋予tmp便能解决循环引用的原因是打破了block对self的强引用。 八.简要介绍GCD常用API1.dispatch_async与dispatch_sync// 异步执行dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;); // 同步执行dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;); 2.dispatch_queue_t使用系统提供的queue // 主队列:串行队列dispatch_queue_t mainQueue = dispatch_get_main_queue();// 全局队列:并行队列dispatch_queue_t globalQueue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);dispatch_queue_t globalQueue2 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_queue_t globalQueue3 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);dispatch_queue_t globalQueue4 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0); 自己创建queue // 一般指定这两种类型// DISPATCH_QUEUE_SERIAL// DISPATCH_QUEUE_CONCURRENTdispatch_queue_t createQueue = dispatch_queue_create("com.chenyalun.gcd.createQueue", DISPATCH_QUEUE_SERIAL);dispatch_async(createQueue, ^&#123; NSLog(@" ");&#125;);// If your deployment target is iOS 6.0 or Mac OS X 10.8 or later//dispatch_release(createQueue);// 指定创建的队列与globalQueue享有同一优先级// 不可指定系统的队列dispatch_set_target_queue(createQueue, globalQueue); 注意: 现在适配的版本一般大于iOS6，因此不必也不能对自己创建的queue进行dispatch_release，不需要担心内存泄漏。 自己创建的队列严格按照格式来，尤其是作为第一个参数的queue的名称：”com.chenyalun.gcd.createQueue” 第二个参数设置为NULL，则为串行队列。specify DISPATCH_QUEUE_SERIAL (or NULL) to create a serial queue or specify DISPATCH_QUEUE_CONCURRENT to create a concurrent queue. In earlier versions, you must specify NULL for this parameter. 3.dispatch_resume/dispatch_suspend队列的挂起与恢复 // 全局队列:并行队列dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0); dispatch_async(globalQueue, ^&#123; NSLog(@"队列中的打印");&#125;); // 挂起dispatch_suspend(globalQueue); NSLog(@"主线程的打印"); // 恢复执行dispatch_resume(globalQueue); 4.dispatch_apply// 指定迭代的次数NSArray *array = @[@1, @2, @3, @4, @5, @6, @7];dispatch_apply(array.count, globalQueue, ^(size_t index) &#123; NSLog(@"%@", [array objectAtIndex:index]);&#125;); 5.dispatch_groupdispatch_group_t group = dispatch_group_create();dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"任务一");&#125;);dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"任务二");&#125;);dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"任务三");&#125;); // 保证以上三个任务执行完毕再执行下面的任务dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@"任务一、二、三都已完成");&#125;); 也可以添加wait判断：dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"任务一");&#125;);dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"任务二");&#125;);dispatch_group_async(group, globalQueue, ^&#123; NSLog(@"任务三");&#125;); // 保证以上三个任务执行完毕再执行下面的任务// DISPATCH_TIME_NOW 不等待// DISPATCH_TIME_FOREVER 永久等待NSInteger result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);if (result == 0) &#123; // group中的任务全部执行完毕 NSLog(@"group中的任务全部执行完毕");&#125; else &#123; // 任务没有执行完毕&#125; 最常用的还是这种（参考自cocoa_chen）：dispatch_group_t group = dispatch_group_create();// 请求Feed信息dispatch_group_enter(group);[self fetchFeedInfoWithCompletion:^(NSDictionary *feed, NSError *error) &#123; // do something with FeedInfo dispatch_group_leave(group);&#125;];// 请求Comments信息dispatch_group_enter(group);[self fetchCommentsWithCompletion:^(NSDictionary *feed, NSError *error) &#123; // do something with Comments dispatch_group_leave(group);&#125;]; // 上面的请求都执行完毕之后在主线程刷新UIdispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 刷新UI等 // reloadData...&#125;); 6.dispatch_barrierdispatch_async(globalQueue, ^&#123; NSLog(@"第一个任务");&#125;);dispatch_async(globalQueue, ^&#123; NSLog(@"第二个任务");&#125;);// 栅栏函数dispatch_barrier_async(globalQueue, ^&#123; NSLog(@"----------------------");&#125;);dispatch_async(globalQueue, ^&#123; NSLog(@"第三个任务。");&#125;);dispatch_async(globalQueue, ^&#123; NSLog(@"第四个任务");&#125;); 7.dispatch_once// typedef long dispatch_once_t;// static long onceToken;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; NSLog(@"仅仅执行一次");&#125;); 8.dispatch_afterdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@"把要执行的任务追加到主队列中");&#125;); 指定3秒之后把要执行的任务追加到主队列中。最早3.0秒后执行，最迟3+1/60秒后执行，若主线程有延迟，时间会更长。 // DISPATCH_TIME_NOW// DISPATCH_TIME_FOREVER// 时间的单位为毫微秒dispatch_time_t time = dispatch_time(DISPATCH_TIME_FOREVER, 3000000); 7.dispatch_semaphore更细粒度的排他控制// 全局队列:并行队列dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 设置信号量为1,也即保证同时访问的数量为1dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);NSMutableArray *array = [NSMutableArray array];// 迭代添加对象dispatch_apply(100, globalQueue, ^(size_t index) &#123; // 将要添加元素前一直等待信号量为1 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 放心地给数组添加元素 [array addObject:[NSNumber numberWithInt:(int)index]]; // 添加完成后释放信号量 dispatch_semaphore_signal(semaphore);&#125;);]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《SQL必知必会》]]></title>
    <url>%2F2017%2F04%2F09%2F%E8%AF%BB%E3%80%8ASQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%2F</url>
    <content type="text"><![CDATA[关于SQLite数据库。 采用 SQLite 数据库。所有命令都敲了一遍，没毛病。 一、提要1.语言 数据定义语言CREATE 创建表/视图/其他对象ALTER 修改对象DROP 删除表/视图/其他对象 数据操纵语言SELECT 检索数据INSERT 创建记录UPDATE 修改记录DELETE 删除记录 数据控制语言GRANT 赋予用户特权REVOKE 收回用户特权 2.概念表：某种特定类型数据的结构化清单字段：限定数据中的列(名)记录：水平排列的数据的实体列：表中的一个字段模式：数据库和表的布局及特性NULL值：表中以空白形式出现的值，表示没有设值主键值：不重复，不为空，不能修改，不能重用 3.类型SQLite无类型，在表声明中明确了字段类型，仍然可以在该字段中存储其它类型的数据。 NULL：表示该值为NULL值。INTEGER： 无符号整型值。REAL：浮点值。TEXT：文本字符串，存储使用的编码方式为UTF-8、UTF-16BE、UTF-16LE。BLOB：存储Blob数据，该类型数据和输入数据完全相同。布尔数据类型：SQLite并没有提供专门的布尔存储类型，取而代之的是存储整型1表示true，0表示false。日期和时间数据类型：以TEXT、REAL和INTEGER类型分别不同的格式表示该类型，如：TEXT: "YYYY-MM-DD HH:MM:SS.SSS"REAL: 以Julian日期格式存储INTEGER: 以Unix时间形式保存数据值，即从1970-01-01 00:00:00到当前时间所流经的秒数。 4.注释 正行注释 # 注释内容 多行注释 /* 注释内容 */ 行尾注释 --注释内容 5.提示 多条语句必须以分号分隔。 SQL语句不区分大小写。 空格会被忽略，可以写成多行。 6.约束 NOT NULL：非空约束，不能有NULL值。 ID INTEGER NOT NULL DEFAULT：默认值，数据未指定的默认值，如默认时间:date(&#39;now&#39;)。 SALARY REAL DEFAULT 5000.0 -- 删除默认约束-- 在SQLite中不可用ALTER TABLE tALTER COLUMN SALARY DROP DEFAULT UNIQUE：唯一，列中所有数据各不相同。 AGE INTEGER UNIQUE 主键：唯一标识数据表中的记录，不为空。 PRIMARY KEY(ID,name) -- 增加主键(前提列已经声明为非空)-- 在SQLite中不可用ALTER TABLE t ADD PRIMARY KEY(ID) -- 删除主键-- 在SQLite中不可用ALTER TABLE t DROP PRIMARY KEY 外键：唯一标识其他表中的一条记录。 FOREIGN KEY(name) REFERENCES q(name)-- 增加外键-- 在SQLite中不可用ALTER TABLE tADD FOREIGN KEY (C_ID) REFERENCES USER (ID)-- 删除外键-- 在SQLite中不可用ALTER TABLE t DROP FOREIGN KEY CHECK：保证列中所有值满足某一条件。 AGE INT NOT NULL CHECK(AGE&lt;=18) 增加CHECK-- 在SQLite中不可用ALTER TABLE tMODIFY AGE INT NOT NULL CHECK(AGE&gt;=18)或者ALTER TABLE tADD CONSTRAINT checkConstraint CHECK(AGE&gt;=18) -- 删除CHECK-- 在SQLite中不可用ALTER TABLE tDROP CONSTRAINT checkConstraint 7.范式第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列，如”地址”可以细分为：”省，市”。 第二范式（2NF）：首先是 1NF，其次一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 第三范式（3NF）：首先是 2NF，其次非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 8.函数 传送门：http://www.cnblogs.com/stephen-liu74/archive/2012/02/15/2322027.html 字符串处理:UPPER() ：大写转换LENGTH() ：字符串长度LOWER()：小写转换LTRIM() ：去掉字符串左边的空格RTRIM() ：去掉字符串右边的空格 日期时间处理date(&#39;now&#39;) 返回当前日期。 date(&#39;now&#39;,&#39;start of month&#39;,&#39;1 month&#39;,&#39;-1 day&#39;)返回当前月的最后一天。 数值处理函数ABS() 绝对值COS() 角度的余弦EXP() 数的指数值PI() 返回圆周率SIN() 角度的正弦值SQRT() 平方根TAN() 角度的正切 聚集函数AVG() 平均值，忽略NULL值。COUNT() 某列的行数，若指定列名则会忽略NULL值，而COUNT(*)对表中行的数目进行计数，无论是否为NULL都计数，DISTINCT不能用于COUNT(*)，如COUNT(DISTINCT *)为错误写法。 MAX() 某列的最大值，忽略NULL值MIN() 某列的最小值，忽略NULL值SUM() 某列值的和，忽略NULL值 其他查看版本select sqlite_version(); 9.视图视图只不过是通过相关的名称存储在数据库中的一个 SQLite 语句。视图实际上是一个以预定义的 SQLite 查询形式存在的表的组合。SQLite仅支持只读视图，所以视图可以创建，可以读，但其内容不能更改。 视图的作用:视图是一种虚表，允许用户实现以下几点： 用户或用户组查找结构数据的方式更自然或直观。 限制数据访问，用户只能看到有限的数据，而不是完整的表。 汇总各种表中的数据，用于生成报告。 10.事务事务是一个对数据库执行工作单元，是以逻辑顺序完成的工作单位或序列。事务是指一个或多个更改数据库的扩展。例如，如果正在创建一个记录或者更新一个记录或者从表中删除一个记录，那么正在该表上执行事务。重要的是要控制事务以确保数据的完整性和处理数据库错误。可以把许多的 SQLite 查询联合成一组，把所有这些放在一起作为事务的一部分进行执行。 事务具有以下四个标准属性，通常根据首字母缩写为 ACID： Atomicity（原子性）原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。 Consistency（一致性）一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 Isolation（隔离性）多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。 Durability（持久性）持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 撤销ROLLBACK 命令是用于撤消尚未保存到数据库的事务的事务命令。ROLLBACK 命令只能用于撤销自上次发出 COMMIT 或 ROLLBACK 命令以来的事务。 BEGIN TRANSACTION;DELETE FROM t WHERE ID = 6;ROLLBACK; 提交 BEGIN TRANSACTION;DELETE FROM t WHERE ID = 5;-- 要做的事END TRANSACTION; -- 或者使用以下语法BEGIN;DELETE FROM t WHERE ID = 6;COMMIT; 注意：保存点在 SQLite (≥ 3.6.8)支持保留点越多越好。SAVEPOINT delRow; ROLLBACK TO delRow; 11.索引索引是一种特殊的查找表，数据库搜索引擎用来加快数据检索，简单地说，索引是一个指向表中数据的指针。创建索引CREATE INDEX in_name_age ON t(name, age); 删除索引DROP INDEX in_name; 12.顺序 子句 说明 是否必须使用 SELECT 返回列 是 FROM 检索的表 从表中选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组 按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序 否 妙记： SELECT kindID, COUNT(*) FROM table WHERE PRICE &gt; 10 GROUP BY kindID HAVING COUNT(*) &gt;=2 ORDER BY kindID; 二、命令1.SELECT检索单个列-- SELECT 列名 FROM 表名 SELECT age FROM t; 检索多个列SELECT name, age, groupID FROM t; 检索所有列SELECT * FROM t;-- 检索不必要的列会降低检索和应用程序的性能 检索并返回不同的值SELECT DISTINCT name, age FROM t; -- DISTINCT作用于所有的列,如SELECT DISTINCT groupID, age FROM t;-- 作用于groupID, age两列-- 当groupID, age双双重复,只会返回一个结果 限制结果-- 不超过5行SELECT name, age FROM t LIMIT 5; -- 从第10行开始检索,不超过7行SELECT name, age FROM t LIMIT 5 OFFSET 3; LIMIT限制返回的行数，OFFSET指定从哪开始。 行数指的是索引行，即从第0行开始。 2.ORDEY BYORDEY BY子句要保证放到最后。 单个列排序-- 以age值的字母顺序/大小排列SELECT name FROM t ORDER BY age; 多个列排序-- 首先按照age,在age中按照nameSELECT name, age FROM t ORDER BY age, name; 按列位置排序-- 首先按照age,在age中按照name-- 3对应age, 1对应IDSELECT ID, name, age FROM t ORDER BY 3, 1; 按降序排序-- DESC 只作用在它前面的列SELECT ID, name, age FROM t ORDER BY 3 DESC;SELECT ID, name, age FROM t ORDER BY 1 DESC,3 DESC; 3.WHERE常用操作符:一般：= ! = &lt; &gt; &gt;= &lt;=介于之间：BETWEEN AND为空值：IS NULL 一般使用SELECT age, name FROM table WHERE age &lt; 10;-- 单引号用来限定字符串-- 将值与字符串类型的列比较需要限定引号-- 将值与数值列进行比较不用引号SELECT ID, name, age FROM t WHERE age = 18;SELECT ID, name, age FROM t WHERE name = '张无忌'; 范围筛选SELECT ID, name, age FROM t WHERE age BETWEEN 18 AND 22; 空值检查SELECT ID, name, age FROM t WHERE sex IS NULL; 4.AND ORAND 优先级大于OR组合使用注意加括号SELECT ID, name, age FROM t WHERE age = 18 AND name = '唐僧';SELECT ID, name, age FROM t WHERE age = 18 OR groupID = 1; 组合使用SELECT ID, name, age FROM t WHERE (age = 18 OR ID &lt; 12) AND groupID = 1; 5.IN关键字匹配 -- 18,19岁SELECT ID, name, age FROM t WHERE age IN (18, 19); 6.NOT否定其后的限定条件 SELECT ID, name, age FROM t WHERE age NOT IN (18, 19);SELECT ID, name, age FROM t WHERE NOT age &lt; 22; 7.LIKE% 通配符表示任何字符出现任意次数，不会匹配NULL。 SELECT ID, name, age FROM t WHERE name LIKE '张%';SELECT ID, name, age FROM t WHERE name LIKE '%六'; _通配符匹配单个字符，注意LIKE后的值使用字符串SELECT ID, name, age FROM t WHERE age LIKE '2_'; 注意:SQLite 不支持[] 通配符[] 通配符指定一系列的字符,只要满足这些字符其中之一,且位置出现在“[]”通配符的位置的字符串就满足查询条件SELECT ID, name, age FROM t WHERE name LIKE '[牛]%';-- 否定SELECT ID, name, age FROM t WHERE name LIKE '[^牛]%'; 注意：少使用通配符，尽量不要把通配符置于开始处 8.拼接使用 || 拼接多个列SELECT age || '(' || name || ')' FROM t;-- 结果: 23(牛魔王) 使用RTRIM去除填充列宽的文本值SELECT age || '(' || RTRIM(name) || ')' FROM t; RTRIM() 去掉字符串右边的空格LTRIM() 去掉字符串左边的空格TRIM() 去掉字符串左右两边的空格 使用别名AS 要求得到的是一列SELECT age || '(' || RTRIM(name) || ')' AS Results FROM t; 执行计算SELECT age + 3, name FROM t; 9.GROUP BYGROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前SELECT groupID, COUNT(*) FROM t GROUP BY groupID;/* 含有COUNT(*)的分组的结果不该包含每列独有的字段,如name,ID等,而应该是共性的字段,如分组ID等,因为目的是得知某组的COUNT*/ SELECT name FROM t GROUP BY name; 10.HAVING1.WHERE过滤行，而HAVING过滤分组，HAVING支持所有WHERE操作符。2.WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。 SELECT groupID, COUNT(*) FROM t GROUP BY groupID HAVING COUNT(*) &gt; 5;-- 筛选每组数量大于5 11.ORDER BY排序HAVING常与GROUP BY连用SELECT groupID, COUNT(*) FROM t WHERE age &gt; 18 GROUP BY groupID HAVING COUNT(*) &gt; 2ORDER BY groupID DESC; 12.子查询在SELECT语句中，子查询总是从内向外处理。作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误。SELECT name, age FROM t WHERE age IN (SELECT age FROM t WHERE age &gt; 10 AND sex IS NULL); 13.连接内连接是据根据每个表共有的列的值匹配两个表中的行SELECT t.name, age FROM t INNER JOIN q ON t.ID = q.ID; SELECT t.name, t.age FROM t, q WHERE t.name = q.name; -- 注意表的名称要匹配 自连接，查询中需要的两个表实际上是相同的表SELECT a.name, a.age FROM t AS a, t AS b WHERE a.name = b.name AND b.ID = 10; 外连接1.外连接可以是左向外连接、右向外连接或完整外部连接2.在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表(RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表)。3.左向外连接的结果集包括LEFT OUTER子句中指定的左表的所有行，而不仅仅是连接列所匹配的行。4.右向外连接是左向外连接的反向连接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 SQLite支持左外连接LEFT OUTER JOIN，但不支持RIGHT OUTER JOIN 和 FULL OUTER JOIN语法。 SELECT t.*, q.* FROM t LEFt JOIN q ON t.ID = q.ID; 交叉连接。交叉连接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉连接也称作笛卡尔积。 总结:左外连接显示左表所有行+匹配行右外连接显示右表所有行+匹配行完整外部连接显示左表和右表中的所有行内连接显示根据比较运算符匹配两个表中的行自连接需要的两个表实际上是相同的表交叉连接显示左表所有行+左表每一行与右表所有行的组合连接不匹配时显示空值 14.UNION将结果组合成一个结果集1.UNION中的每个查询必须包含相同的列、表达式或聚集函数2.UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔3.列数据类型必须兼容 SELECT name, age FROM t WHERE name LIKE '张%' UNION SELECT name, age FROM t WHERE age &gt; 22;-- 相当于 "并"在一起 15.INSERT插入记录INSERT INTO t VALUES(13, '白骨精', '1543', 1, NULL, 19, 1.68); INSERT INTOt(ID, name, phone, groupID, sex, age, height) VALUES(14, '白龙马', '1323', 0, NULL, 20, 1.69); VALUES必须以其指定的次序匹配指定的列名，更推荐这种方式。省略列：允许NULL或者有默认值 16.CREATE AS复制表CREATE TABLE c AS SELECT * FROM t; 17.UPDATE更新行UPDATE t SET height = 1.66 WHERE name = '白龙马'; -- 删除某列的值UPDATE t SET height = NULL WHERE name = '韦小宝'; 更新多列，注意逗号UPDATE t SET height = 1.55, phone = '1888', groupID = 0 WHERE name = '唐僧'; 18.DELETE删除行DELETE FROM t WHERE name = '白龙马'; 19.CREATE创建表CREATE TABLE d(ID INTEGER NOT NULL UNIQUE,name TEXT NOT NULL,sex INTEGER DEFAULT 0,height REAL CHECK(height &gt; 0), PRIMARY KEY('ID')FOREIGN KEY(name) REFERENCES q(name)); 主键单独标明。 20.ALTER给表增加一列 ALTER TABLE bADD place TEXT; 重命名表 ALTER TABLE bRENAME TO bbb; 在 SQLite 中，除了重命名表和在已有的表中添加列，ALTER TABLE 命令不支持其他操作,包括删除列,定义主键和外键等. SQLite不支持删除列 ALTER TABLE t DROP COLUMN vend_phone; 21.DROP删除表DROP TABLE t; 22.视图创建视图CREATE VIEW view_b AS SELECT name, age FROM t; 查看视图 SELECT * FROM view_b; 删除视图DROP VIEW view_b; 参考感谢：SQLite外键SQLite学习手册SQLite 语法]]></content>
      <tags>
        <tag>阅读</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《Effective Objective-C 2.0》]]></title>
    <url>%2F2017%2F04%2F05%2F%E8%AF%BB%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[许多小技巧。 读感一晚上加一早上时间读了一遍，很多技巧都屡有耳闻，不过还是收获许多。这里记录一些比较好玩的问题。 钩玄 尽可能在.h文件中使用@class声明类，.m文件中使用import导入其他头文件，而不是只在.h文件中import头文件。 常量使用static const，其他情况(如[NSNotificationCenter defaultCenter])使用宏。 不需要位或运算的枚举使用NS_ENUM，需要使用位或运算的枚举使用NS_OPTIONS，避免C语言中的enum。 switch状态机下避免default分支(确保switch正确处理已知情况，往后增加新的的枚举值会有警告)。 问题1.属性声明为@dynamic后该怎么做手动添加getter和setter实现不表。在运行时添加属性的存取方法的方式如下： .h文件暴露属性： @property (nonatomic, copy) NSString *name; .m文件动态添加方法： @interface YAHeader ()&#123; NSString *_name;&#125;@end@implementation YAHeader@dynamic name;// 添加set方法,要传入参数void dynamicSetMethodIMP(YAHeader *self, SEL _cmd, NSString *prame) &#123; self-&gt;_name = prame;&#125;// 添加get方法,要返回NSString *类型NSString *dynamicGetMethodIMP(YAHeader *self, SEL _cmd) &#123; return self-&gt;_name;&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(setName:)) &#123; class_addMethod([self class], sel, (IMP)dynamicSetMethodIMP, "v@:@"); return YES; &#125; if (sel == @selector(name)) &#123; class_addMethod([self class], sel, (IMP)dynamicGetMethodIMP, "v@:"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;@end 注意: 按照本书所说，使用@dynamic将仅仅生成getter/setter方法的声明，不会生成getter/setter方法的实现，也不会合成成员变量。 由于没有合成成员变量，所以需要手动添加。 使用@property但是却没有合成成员变量的情景有： 同时使用@property和@dynamic； setter和getter方法均手动实现； 分类中的@property； 值得一提的是，当使用@synthesize num;时，将不会生成成员变量_num，而是生成成员变量num。简单总结就是，很久以前： @property会在@interface中生成getter和setter的方法声明； @synthesize一般会在@implementation中生成getter和setter的方法实现及私有的成员变量。 @synthesize num = _num;，意味着当成员变量 _num 不存在时，自动生成一个 @private的成员变量 _num； @synthesize num;，意味着当成员变量 num 不存在时，自动生成一个 @private的成员变量 num； 若手动实现 setter 方法，则只会自动生成 getter 方法； 若手动实现 getter 方法，则只会自动生成 setter 方法； 若同时手动实现 setter 和 getter 方法，则不会自动生成不存在的成员变量。 而现在，@property包揽了@synthesize的功能，默认生成_开头的成员变量。 2.关联对象中为什么使用static修饰的指针static的作用之一便是使变量在内存中只有一份拷贝，由于需要objc_setAssociatedObject和objc_getAssociatedObject中的两个键(void *key)需要匹配同一个值(关联的对象)，所以需要两者是完全相同的指针，故而使用静态全局变量做键。 3.简述Objective-C在发送消息时的动态性静态绑定：将在运行期间调用的函数在编译期间已经确定；动态绑定：发送的消息部分转化为objc_msgSend函数，传入将要调用函数的对象、将要调用的函数以及将要调用的函数的参数，具体调用哪个函数，通过快速映射表、方法列表亦或是消息转发确定；objc_msgSend_stret：消息返回结构体调用objc_msgSend_fpret：消息返回浮点数调用objc_msgSendSuper：给超类发送消息调用 4.如何解决unrecognized selector send to instance作者这里主要指的是在消息转发阶段处理，而不是简单地添加上方法实现。 消息转发的三个流程： 对象收到无法识别的消息，根据是类方法还是对象方法调用+ (BOOL)resolveInstanceMethod:(SEL)selector或者+ (BOOL)resolveClassMethod:(SEL)selector。前提：相关方法的实现代码已经写好。使用：根据类方法还是对象方法，在resolveMethod中为无法响应的selector动态添加方法实现(提供函数指针IMP) class_addMethod(self, selector, (IMP)methodImplemention,"v@:@"); 若没有做出处理，返回NO。 倘若没有相关方法实现，进入- (id)forwardingTargetForSelector:(SEL)selector，将消息转发给其他对象，若找不到，返回nil。 完整的消息转发，调用对象方法- (void)forwardInvocation:(NSInvocation *)invocation。首先发送-methodSignatureForSelector:获取函数的参数和返回值类型，若返回nil，直接挂掉，否则runtime创建一个NSInvocation对象，发送forwardInvocation消息给目标对象。 5.如何实现多重继承让C类产生的对象同时具备A类方法和B类方法的能力： C类继承自A类。 使C类对象中拥有B类对象(组合)，在C类对象中实现对象方法forwardingTargetForSelect:方法，将发送来的关于B类方法转发给所拥有的B类对象处理。 6.怎么实现方法实现的交换一般在load方法中实现交换。+ (void)load &#123; Method lowercaseString = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method uppercaseString = class_getInstanceMethod([NSString class], @selector(uppercaseString)); method_exchangeImplementations(lowercaseString, uppercaseString);&#125; 表面上看是死循环: - (NSString *)lowercaseString &#123; return self.lowercaseString;&#125;- (NSString *)uppercaseString &#123; return self.uppercaseString;&#125; 以上直接交换的示例仅限于不需要调用super的实现，更详细见《再谈Method-Swizzling》。 7.简述为代码加锁的方式同步块: @synchronized(self) {//...} 滥用@synchronized(self)很危险，所有的块都会彼此抢夺同一个锁。 锁对象:_lock = [[NSLock alloc] init];[_lock lock];// ...[_lock unlock]; 8.原子性一定安全吗，如何确保属性的线程安全不一定。原子性能保证存取方法的线程安全，也即读或者写操作是原子性的，在读或者写发生的时候，其他读或者写操作必须等待。然而同一个线程上多次调用get方法，每一次获取到的值未必相同，多次访问期间，其他线程可能会写入新的值。比如当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全。 线程安全：不会出现数据不一致或者数据污染，也即多线程访问时没有出现意料之外的结果。 比如使用atomic修饰的age属性：@interface YACat : NSObject@property (atomic, assign) NSUInteger age;@end 在使用时：// thread Adispatch_async(dispatch_queue_create("A", DISPATCH_QUEUE_CONCURRENT), ^&#123; for (int i = 0; i &lt; 1000; i ++) &#123; gCat.age = gCat.age + 1; NSLog(@"Thread A: %ld\n", gCat.age); &#125;&#125;); // thread Bdispatch_async(dispatch_queue_create("B", DISPATCH_QUEUE_CONCURRENT), ^&#123; for (int i = 0; i &lt; 1000; i ++) &#123; gCat.age = gCat.age + 1; NSLog(@"Thread B: %ld\n", gCat.age); &#125;&#125;); 结果并不一定是1000，出现的结果不符合预期。原因在于，gCat.age = gCat.age + 1;这个读、加一、写的整体操作并不是线程安全的。这时，可以通过加锁来保证线程安全：[_Lock lock];gCat.age = gCat.age + 1;[_Lock unlock]; 9.performSelector的局限性有哪些 由于无法确定将要执行的selector具体是什么，ARC无法将其纳入合适的内存管理方法中，可能有内存泄漏。 selector的返回值类型和参数个数、类型受到限制。建议使用GCD中的dispatch_async/dispatch_after等代替相应的performSelector。 - (void)fetchSelector:(NSInteger)condition &#123; SEL selector; if (condition == 0) &#123; selector = @selector(dismiss); &#125; else if (condition == 1)&#123; selector = @selector(miss:); &#125; else &#123; selector = @selector(love); &#125; [self performSelector:selector];&#125; 会出现警告：/Users/chenyalun/Desktop/iOS/program/Demo170404/Demo170404/YAHeader.m:70:11: PerformSelector may cause a leak because its selector is unknown。 更多performSelector内容见《详解performSelector》。 10.__bridge、__bridge_retained与__bridge_transfer的区别NSArray *array = @[@10, @11, @12];CFArrayRef cfarray = (__bridge CFArrayRef)array; CFArrayRef cfarray2 = (__bridge_retained CFArrayRef)array;CFRelease(cfarray2); NSArray *array2 = (__bridge_transfer NSArray *)cfarray; __bridge：表示ARC仍然具备该对象的所有权。 __bridge_retained：表示ARC交出该对象的所有权(需手动release)。 __bridge_transfer：表示反向转换，同时ARC获取对象所有权。 11.NSCache相较NSDictionary的优点 在系统发出低内存通知时，NSCache自动删减缓存，并且先行删减最久未使用的对象。 增加键的引用计数而不是拷贝它。 NSCache线程安全，可以多线程访问而不出错。 NSPurgeableData是NSMutableData的子类，将它与NSCache搭配使用，当NSPurgeableData对象所占内存为系统所丢弃时，该对象自动从NSCache缓存中清除。 NSPurgeableData使用示例： NSCache *cache = [[NSCache alloc] init]; NSPurgeableData *purgeableData = [NSPurgeableData dataWithBytes:@"ILOVEYOU" length:10];[cache setObject:purgeableData forKey:@00]; // 访问NSPurgeableDataif (purgeableData) &#123; // 开始访问,现在还不应该丢弃自己所占用的内存 [purgeableData beginContentAccess]; [self useData:purgeableData]; // 结束访问,现在可以丢弃自己所占用的内存啦 [purgeableData endContentAccess];&#125; 参考并感谢：乞力马扎罗的雪的博客]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从C++到汇编]]></title>
    <url>%2F2017%2F04%2F02%2F%E4%BB%8EC%2B%2B%E5%88%B0%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[2019.08.18 补充汇编内容 C++和汇编。 本文主要是复习C++时的笔记，主要是语法方面的内容。为加深理解，部分语法尝试使用汇编窥测其实现。 一、基本语法命名空间作用：防止出现变量或函数的命名冲突。 定义及使用// 定义namespace YA &#123;int a;// 变量、类、函数、typedef、#define 等都可以出现在命名空间中&#125;// 使用方式一:域解析操作符// :是域解析操作符,指明要使用的命名空间YA :: a = 20;// 使用方式二:针对变量// 如果以后出现了未指明命名空间的a，就使用YA :: ausing YA :: a;a = 20;// 使用方式三:针对命名空间using namespace YA; // 声明整个命名空间 系统的命名空间对于不带.h的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间std；对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域。 #include &lt;cstdio&gt;using namespace std;//... 全局命名空间在 main() 函数中声明命名空间 std，它的作用范围就位于 main() 函数内部，如果在其他函数中又用到了 std，就需要重新声明。如果希望在所有函数中都使用命名空间 std，可以将它声明在全局范围中。 namespace YA &#123; void func() &#123; cout &lt;&lt; "YA" &lt;&lt; endl; &#125;&#125;void func() &#123; cout &lt;&lt; "YA" &lt;&lt; endl;&#125;int main(int argc, const char * argv[]) &#123; using namespace YA; ::func(); YA::func(); return 0;&#125; extern “C”在C++（.cpp）文件中编译C语言（.c）的函数，出现编译不过，需要用到extern &quot;C&quot;。被 extern &quot;C&quot; 修饰的代码，按照C语言的方式编译。可以放在函数声明前面，也可以使用大括号的形式：extern &quot;C&quot; {/* */}。 extern "C" &#123; #include "cMath.h" // 对应cMath.c&#125; 最好在cMath.h中配合__cplusplus宏使用：// cMath.h:#ifndef __CMATH_H#define __CMATH_H#ifdef __cplusplusextern "C" &#123;#endif // __cplusplus // 函数声明 int sum(int a, int b);#ifdef __cplusplus&#125;#endif // __cplusplus#endif // !__CMATH_H __CMATH_H可以防止整个文件的内容被重复包含，新标准下#pragma once也可以。 cin与coutcout 和 cin 分别是 ostream 和 istream 类的对象，而不是关键字。使用示例：int a,b;cin &gt;&gt; a &gt;&gt; b;cout &lt;&lt; "a是" &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; "b是" &lt;&lt; b &lt;&lt; endl; 其中endl表示end of line。 constconst的作用主要有：1.定义常量const int a = 10; // a不可修改 2.类型检查void f(const int i){} // 对传进来的参数进行类型检查,不匹配则提示 3.保护参数void f(const int i){} // i不可修改 4.节省空间// 替换三次,分配三次内存空间#define pi 3.14double a = pi;double b = pi;double c = pi;const double PI = 3.14// 只分配一次内存空间double d = PI;// 不再分配内存空间double e = PI; 混淆点:指针本身是常量不可变，不可以指向其他：char* const pContent;指针所指向的内容是常量不可变：const char *pContent;两者都不可变：const char* const pContent; 示例如下：struct Person &#123; int mAge;&#125;;Person p1 = &#123; 5 &#125;;Person p2 = &#123; 10 &#125;;const Person *ptr2 = &amp;p1;*ptr2 = p2; //noptr2-&gt;mAge = 16; //no(*ptr2).mAge = 13; //noptr2 = &amp;p2; //yesPerson * const ptr3 = &amp;p1;*ptr3 = p2; //yesptr3-&gt;mAge = 16; //yes(*ptr3).mAge = 13; //yesptr3 = &amp;p2; //no 引用在C++中，使用引用(Reference)可以起到与指针类似的功能。引用相当于是变量的别名(基本数据类型、枚举、结构体、类、指针、数组等，都可以有引用)，对引用做计算，就是对引用所指向的变量做计算。在定义的时候就必须初始化，一旦指向了某个变量，就不可以再改变。可以利用引用初始化另一个引用，相当于某个变量的多个别名。但是不存在引用的引用、指向引用的指针、引用数组。 int age = 10;int &amp;newAge = age; // newAge与age等价，相当于别名age = 20; // age、newAge都是20newAge = 30; // age、newAge都是30 引用比指针更安全、函数返回值可以被赋值。一个引用占用一个指针的大小（64位8个字节或者32位4个字节），引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是弱化了的指针。 int age = 10;01171010 mov dword ptr [ebp-8],0Ah int *pAge = &amp;age; // 指针01171017 lea eax,[ebp-8] 0117101A mov dword ptr [ebp-0Ch],eax int &amp;newAge = age; // 引用0117101D lea ecx,[ebp-8] 01171020 mov dword ptr [ebp-10h],ecx 从汇编看，效果是一样的：ebp-8是变量age的地址，之后都是把这个地址ebp-8存储到一个指针指向的空间中。 指针、引用、数组int array[] = &#123;1, 2, 3&#125;;// 指针数组，数组中的元素是指针类型 int *int *p;int *arr1[3] = &#123;p, p, p&#125;;// 指向数组的指针int (*arr2)[3];// 数组的引用int (&amp;arr3)[3] = array; 指针、引用、constint age = 10;int age2 = 11;// ref1指向不可修改，ref1指向的内容可以修改int &amp; const ref1 = age; // 等价于int &amp;ref1 = age;ref1 = 13; //yes// p1指向不可修改， p1指向的内容可以修改int * const p1 = &amp;age;p1 = &amp;age2; //no*p1 = 13; //yes// ref1指向不可修改，ref1指向的内容不可以修改const int &amp;ref2 = age;ref2 = 13; //no// p2指向可以修改， p2指向的内容不可以修改const int *p2 = &amp;age;p2 = &amp;age2; //yes*p2 = 13; //no 常引用的临时数据 const int &amp;age1 = 20; //直接赋值临时变量int &amp;age1 = 20;//noint &amp;age2 = age;//yes 函数参数是引用类型时，接受const与非const实参 int sum(const int &amp;a, const int &amp;b) &#123; return a + b;&#125;// 接受各种类型的参数sum(10, 20);sum(a, b); 内存布局每个应用都有自己独立的内存空间，其内存空间一般有以下几大区域 ： 代码段(代码区)：用于存放代码（只读）。 数据段(全局区)：用于存放全局变量等。 栈空间：每调用一个函数就会给它分配一段连续的栈空间，等函数调用完毕后会自动回收这段栈空间。会自动分配和回收。 堆空间：需要主动去申请和释放。 函数代码存放在代码段，局部变量存放在栈空间。 对象的内存对象的内存可以存在于3种地方： 全局区(数据段)：全局变量 栈空间：函数里面的局部变量 堆空间：动态申请内存(malloc、new等) // 全局区Person gPer;int main() &#123; // 栈空间 Person per; // 堆空间 Person *p = new Person; return 0;&#125; 对象的创建类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。 存储在栈上的对象 Student stu;Student *p = &amp;stu; 存储在堆上的对象Student *stu = new Student; 使用 new 在堆上创建出来的对象是匿名的，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。 动态分配内存在程序运行过程，为了能够自由控制内存的生命周期、大小，会经常使用堆空间的内存。 堆空间的申请\释放： malloc \ free int *p = (int *)malloc(sizeof(int) * 10);memset(p, 0, sizeof(int) * 10); // 从p地址开始，每一个字节都设值为0； free(p); new \ delete char *p = new char; // 未初始化char *p = new char(); // 将默认初始化delete p; new [] \ delete [] char *p = new char // 未初始化char *p = new char[6] // 将默认初始化delete[] p; 申请堆空间成功后，会返回那一段内存空间的地址。申请和释放必须是1对1的关系，不然可能会存在内存泄露。 memset函数是将较大的数据结构(比如对象、数组等)内存清零的比较快的方法。Person per;per.age = 1;per.num = 2;per.id = 3;memset(&amp;per, 0, sizeof(per));Person persons[] = &#123;&#123;1, 2, 4&#125;, &#123;2, 3, 4&#125;, &#123;4, 5, 6&#125;&#125;;memset(&amp;persons, 0, sizeof(persons)); 内联函数为了消除函数调用的时空开销，在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数。使用inline修饰函数的声明或者实现，将建议编译器使其成为内联函数，在函数定义处添加inline关键字，声明处添加无效，最好声明和实现都增加inline修饰。 若编译器使得函数成为内联函数，编译器会将函数调用直接展开为函数体代码，可以减少函数调用的开销，但是会增大代码体积。编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大。一些函数即使声明为inline，也不一定会被编译器内联，比如递归函数。尽量不要内联超过10行代码的函数。 内联函数和宏，都可以减少函数调用的开销，对比宏，内联函数多了语法检测和函数特性。以func函数为例： int func(int a) &#123; return a + 3;&#125; 没有使用内联时：int a = func(5);01321016 push 5 01321018 call func (01321000h) 0132101D add esp,4 01321020 mov dword ptr [a],eax 使用内联时：int a = func(5);00291006 mov eax,5 0029100B add eax,3 0029100E mov dword ptr [a],eax 可见函数调用call func (01321000h)确实是直接被替换成了函数体的内容：add eax,3。 成员函数在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以建议在类体内部对成员函数作声明，而在类体外部进行定义。 不使用内联函数:class Student &#123;public: int age; void say(); //内联函数声明&#125;; //函数定义void Student::say()&#123; &#125; 函数的默认参数默认参数需要按照从右到左的顺序（与函数参数压栈顺序一致）设置。如果函数同时有声明、实现，默认参数只能放在函数声明中，默认参数的值可以是常量、全局符号(全局变量、函数名)。 本质：编译器隐式传入默认参数，调用函数时依旧是将所有参数压栈。 int func(int a, int b = 7) &#123; return a * b + a + b;&#125;func(2);010B1998 push 7 010B199A push 2 010B199C call func (010B1438h) 010B19A1 add esp,8 虽然调用时只传入一个参数，实际上编译器还是会传递默认参数进行调用：push 7。默认参数并不是包含在函数体中的。 注意：C与C++都可以将函数作为函数参数传递。int func(int a) &#123; return 3 * a;&#125;void func2(int a, int(*p)(int)) &#123; p(a);&#125; 函数的重载重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。重载的结果是让一个函数名拥有了多种用途，使得命名更加方便，调用更加灵活。要求：函数名相同且参数列表不同。仅仅返回类型不同不足以成为函数的重载。//交换 int 变量的值void swap(int *a, int *b) &#123; int temp = *a; *a = *b; *b = temp;&#125;//交换 float 变量的值void swap(float *a, float *b) &#123; float temp = *a; *a = *b; *b = temp;&#125; 重载的本质：在编译时会根据参数列表对函数进行重命名，采用了name mangling或者叫name decoration技术，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。int func(int a) &#123; return a * a + a;&#125;int func(int a, int b) &#123; return a * b + a + b;&#125;func(12);003A18C8 push 0Ch003A18CA call func (03A1433h)003A18CF add esp, 4func(1, 2);003A18D2 push 2003A18D4 push 1003A18D6 call func (03A1438h)003A18DB add esp, 8 func()函数的重载，最终根据不同的参数类型生成不同的函数：func (03A1433h)、func (03A1438h)。注意：调用函数时，实参的隐式类型转换可能会产生二义性。 struct与classC++中可以使用struct、class来定义一个类。struct与class的区别： 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的 class 继承默认是 private 继承，而 struct 继承默认是 public 继承。 class 可以使用模板，而 struct 不能。 struct struct Person &#123; int mAge; int mNum;&#125;;Person per;per.mAge = 10;00811A02 mov dword ptr [ebp-10h],0Ah per.mNum = 101;00811A09 mov dword ptr [ebp-0Ch],65h classclass Person &#123;public: int mAge; int mNum;&#125;;Person per;per.mAge = 10;012D1A02 mov dword ptr[ebp - 10h], 0Ahper.mNum = 101;012D1A09 mov dword ptr[ebp - 0Ch], 65h 对比发现，struct与class在汇编层面（本质上）是一致的。区别主要体现在权限上。 变量名规范参考： 全局变量：gName 成员变量：mName 静态变量：sName 常量：cName this怎么实现C++中函数访问成员变量？函数在代码区，访问其他区的对象（栈、堆、静态区）。可以试着传递对象的地址。比如：struct Person &#123; int mAge; void showAge(Person *per) &#123; // 方法中访问成员变量 cout &lt;&lt; per-&gt;mAge &lt;&lt; endl; &#125;&#125;;Person per;per.mAge = 10;per.showAge(&amp;per); 由这个思路，便产生了this。this是 C++ 中的一个关键字，也是一个 const 指针，它指向当前对象，通过它可以访问当前对象的所有成员。this虽然用在类的内部，但是只有在对象被创建以后才会给this赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给this赋值。 本质上this 是成员函数的一个形参，存储着函数调用者（对象）的地址。this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。this 作为隐式形参，是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。 窥测其实现：struct Person &#123; int mAge; void configAge() &#123; this-&gt;mAge = 5; &#125;&#125;;Person per;per.configAge(); 转成汇编后：Person per;per.configAge();01001A12 lea ecx,[ebp-0Ch] 01001A15 call 01001460 void configAge() &#123;....010019A0 mov dword ptr [ebp-8],ecx .... this-&gt;mAge = 5;010019AD mov eax,dword ptr [ebp-8] 010019B0 mov dword ptr [eax],5 &#125; 把per对象的地址（ebp-0Ch）存储在ecx中，调用per.configAge()函数。在该函数执行过程中，把ecx存储的值（per对象的地址）放到ebp-8指向的内存空间中，也即ebp-8是this指针的地址，这个地址指向的空间存储着per对象的地址。再把ebp-8存储的内容赋值到eax中，那么eax存储的即是per对象的地址，也即per.mAge的地址。赋值即可。 this是指针，this-&gt;表示访问this指针指向的对象。在开发中可以省略this-&gt;，直接使用mAge = 5赋值。实际上是语法糖。编译器会帮我们加上this-&gt;。 利用指针间接访问所指对象的成员变量，先从指针中取出对象的地址，利用对象的地址加上成员变量的偏移量计算出成员变量的地址。 构造函数构造函数(也叫构造器)，在对象创建的时候自动调用，一般用于完成对象的初始化工作。函数名与类同名，无返回值，可以有参数，可以重载，可以有多个构造函数。一旦自定义了构造函数，必须用其中一个自定义的构造函数来初始化对象。通过malloc分配的对象不会调用构造函数。 调用没有参数的构造函数可以省略括号。Student stu();Student stu;Student *stu = new Student();Student *stu = new Student; 构造函数中初始化如果自定义了构造函数，除了全局区，其他内存空间的成员变量默认都不会被初始化，需要开发人员手动初始化。可以理解，自定义构造函数的大多数原因是为了初始化。Person() &#123; memset(this, 0, sizeof(Person));&#125; 易混淆点Person person; // 创建person对象Person person(); // 返回Person类型的函数声明Person person(2); // 创建person对象，自定义构造函数 Person *p = new Person();创建出来的Car对象在堆空间。Person p;创建出来的Car对象在栈空间。 析构函数析构函数(也叫析构器)，在对象销毁的时候自动调用，一般用于完成对象的清理工作。函数名以~开头，与类同名，无返回值，无参，不可以重载，有且只有一个析构函数。通过malloc分配的对象free的时候不会调用析构函数。构造函数、析构函数要声明为public，才能被外界正常使用。 Person() &#123; car = new Car();&#125;~Person() &#123; delete car;&#125; 析构函数清理未被回收的堆空间对象。 初始化列表Person(int age, int id) &#123; mAge = age; mId = id;&#125;// 完全等价于Person(int age, int id) :mAge(age), mId(id) &#123;&#125;// 也可以传入函数int func() &#123; return 10;&#125;Person(int age, int id) :mAge(func()), mId(id) &#123;&#125; 初始化列表的初始化顺序与成员变量声明顺序有关。 带默认参数的初始化列表：// 也可以传入函数Person(int age = 0, int id = 0) :mAge(age), mId(id) &#123;&#125; 如果函数声明和实现是分离的，初始化列表只能写在函数的实现中。默认参数只能写在函数的声明中。 构造函数调用构造函数子类的构造函数默认会调用父类的无参构造函数。如果子类的构造函数显式地调用了父类的有参构造函数，就不会再去默认调用父类的无参构造函数。如果父类缺少无参构造函数，子类的构造函数必须显式调用父类的有参构造函数。 构造函数调用构造函数必须放到初始化列表中。Person(int age, int id) &#123; mAge = age; mId = id;&#125;// 构造函数调用构造函数Person() :Person(10,2) &#123;&#125; 不能像下面这样调用。这样相当于创建一个临时的对象。Person() &#123; Person(10,2);&#125; 在C++中也不能这样调用。Person() &#123; this-&gt;Person(1, 2);&#125; 拷贝构造函数拷贝构造函数是构造函数的一种。当利用已存在的对象创建一个新对象时(类似于拷贝)，就会调用新对象的拷贝构造函数进行初始化。拷贝构造函数的格式是固定的，接收一个const引用作为参数(使用const修饰，则可以接收非const对象和const对象；使用引用，可以避免产生死循环)。class Person &#123; int mID; int mAge;public: // 默认参数与初始化列表 Person(int id = 0, int age = 0) :mID(id), mAge(age) &#123;&#125; // 拷贝构造函数 Person(const Person &amp;per) &#123; this-&gt;mID = per.mID; this-&gt;mAge = per.mAge; &#125; // 打印 void show() &#123; cout &lt;&lt; mID &lt;&lt; endl &lt;&lt; mAge &lt;&lt; endl; &#125;&#125;; 使用拷贝Person per(1,12);per.show();Person per2(per);per2.show(); 当完全省略拷贝构造函数时，x86下汇编为：Person per2(per);009E2076 mov eax,dword ptr [per] 009E2079 mov dword ptr [per2],eax 009E207C mov ecx,dword ptr [ebp-0Ch] 009E207F mov dword ptr [ebp-1Ch],ecx x64下汇编为：Person per2(per);00007FF669AD1AF8 mov rax,qword ptr [per] 00007FF669AD1AFC mov qword ptr [per2],rax 可见，默认实现即是把per指向的内存空间中的8个字节拷贝到per2指向的内存空间中。与this-&gt;mID = per.mID; this-&gt;mAge = per.mAge;相同。x86下，一次操作拷贝4个字节（dword），x64下，一次操作拷贝8个字节（qword）。 调用父类的拷贝构造函数class Student : Person &#123; int mSchoolID;public: Student(int ID = 0, int age = 0, int schoolID = 0) :Person(ID, age), mSchoolID(schoolID) &#123;&#125; // 调用父类的拷贝构造函数 Student(const Student &amp;stu) : Person(stu), mSchoolID(stu.mSchoolID) &#123;&#125;&#125;; 注意：Person per2(per);与Person per2 = per;完全等价，都是拷贝构造。 区分拷贝操作：Person per;Person per2;// 仅仅是拷贝per2 = per; 深复制与浅复制编译器默认的提供的拷贝是浅拷贝(shallow copy)。将一个对象中所有成员变量的值拷贝到另一个对象。如果某个成员变量是个指针，只会拷贝指针中存储的地址值，并不会拷贝指针指向的内存空间。可能会导致堆空间多次free的问题。如果需要实现深拷贝(deep copy)，就需要自定义拷贝构造函数。将指针类型的成员变量所指向的内存空间，拷贝到新的内存空间。 危险的堆空间指针指向栈空间：class Doge &#123;private: int mAge; char *mName;public: Doge(int age, const char* name) :mAge(age), mName(name) &#123;&#125;&#125;;Doge *doge;&#123; char name[] = &#123; 'A', 'a', 'r', 'o', 'n', '\0' &#125;; doge = new Doge(3, name);&#125; name过了作用域会被回收，此时doge中的mName就很危险。需要重写构造函数，将mName存储到堆空间上：Doge(int age, const char* name) :mAge(age) &#123; if (name == NULL) return; // 申请堆空间 &#123;&#125;是清零操作 mName = new char[strlen(name) + 1] &#123;&#125;; // 拷贝 strcpy(mName, name);&#125; 重写析构函数，清除mName：~Dog() &#123; if (mName == NULL) return; delete[] mName; mName = NULL;&#125; 深拷贝：Doge(const Doge&amp; doge) : mAge(doge.mAge) &#123; if (doge.mName == NULL) return; // 申请堆空间 &#123;&#125;是清零操作 mName = new char[strlen(doge.mName) + 1]&#123;&#125;; // 拷贝 strcpy(mName, doge.mName);&#125; 静态成员变量static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只分配一份内存。static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。 static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。// 将 mTotal 声明为静态成员变量//通过类类访问 static 成员变量Student::mTotal = 10; //通过对象来访问 static 成员变量Student stu("小明", 15, 92.5f);stu.mTotal = 20; //通过对象指针来访问 static 成员变量Student *pstu = new Student("李华", 16, 96);pstu -&gt; mTotal = 20; 静态成员变量必须初始化，而且只能在类体外进行。 static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。 静态成员函数普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。 静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。 常成员函数const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。 常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字：class Student&#123;public: //声明常成员函数 int getage() const;private: int m_age;&#125;; //定义常成员函数int Student::getage() const&#123; return m_age;&#125; 友元函数与友元类借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。在当前类以外定义的、不属于当前类的函数可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。 一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。public: // 构造函数 Address(char *province, char *city, char *district); //将Student类中的成员函数show()声明为友元函数 friend void Student::show(Address *addr); 友元类中的所有成员函数都是另外一个类的友元函数。public: // 构造函数 Address(char *province, char *city, char *district); public: //将Student类声明为Address类的友元类 friend class Student; 友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。 继承继承方式包括 public（公有的）、private（私有的）和 protected（受保护的），此项是可选的，如果不写，那么默认为 private。class 派生类名:［继承方式］ 基类名&#123; 派生类新增加的成员&#125;; 不同的继承方式会影响基类成员在派生类中的访问权限。 1) public继承方式 基类中所有 public 成员在派生类中为 public 属性； 基类中所有 protected 成员在派生类中为 protected 属性； 基类中所有 private 成员在派生类中不能使用。 2) protected继承方式 基类中的所有 public 成员在派生类中为 protected 属性； 基类中的所有 protected 成员在派生类中为 protected 属性； 基类中的所有 private 成员在派生类中不能使用。 3) private继承方式 基类中的所有 public 成员在派生类中均为 private 属性； 基类中的所有 protected 成员在派生类中均为 private 属性； 基类中的所有 private 成员在派生类中不能使用。 基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。对象的内存布局：父类的成员变量在前，子类的成员变量在后。 类的构造函数不能被继承； 析构函数也不能被继承； 派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。 多继承C++允许一个类可以有多个父类。同名成员变量访问 class A &#123;public: int mAge;&#125;;class B &#123;public: int mAge;&#125;;class C : A, B &#123;public: int mAge;&#125;;// 访问C c;c.mAge = 10;c.B::mAge = 12;c.A::mAge = 13; 多继承的场景主要是应用在继承协议遵从接口。 虚继承菱形继承假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A –&gt;B–&gt;D 这条路径，还是来自 A–&gt;C–&gt;D 这条路径。因为类 B 和类 C 中都有成员变量 a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了错误。 菱形继承带来的问题：最底下子类从基类继承的成员变量冗余、重复；最底下子类无法访问基类的成员，有二义性。为了解决这个问题，便有了虚继承。 在继承方式前面加上 virtual 关键字就是虚继承：//间接基类Aclass A &#123;protected: int m_a;&#125;;//直接基类Bclass B : virtual public A &#123; //虚继承protected: int m_b;&#125;;//直接基类Cclass C : virtual public A &#123; //虚继承protected: int m_c;&#125;;//派生类Dclass D : public B, public C &#123;public: void seta(int a) &#123; m_a = a; &#125; //正确 void setb(int b) &#123; m_b = b; &#125; //正确 void setc(int c) &#123; m_c = c; &#125; //正确 void setd(int d) &#123; m_d = d; &#125; //正确private: int m_d;&#125;; 在类被构造的时候，先执行虚拟继承的父类的构造函数，然后从左到右执行普通继承的父类的构造函数，然后按照定义的顺序执行数据成员的初始化，最后是自身的构造函数的调用。析构函数与之完全相反，互成镜像。more。 虚继承解决菱形继承问题。虚函数解决多态问题。纯虚函数解决协议问题。 多态默认情况下，编译器只会根据指针类型调用对应的函数，不存在多态。C++中的多态通过虚函数实现。 多态的要素： 子类重写父类的成员函数(override) 父类指针指向子类对象 利用父类指针调用重写的成员函数 // 基类struct Object &#123; void show() &#123; cout &lt;&lt; "Object::show" &lt;&lt; endl; &#125;&#125;;// Person子类struct Person : Object &#123; void show() &#123; cout &lt;&lt;"Person::show" &lt;&lt; endl; &#125;&#125;;// Student子类struct Student : Object &#123; void show() &#123; cout &lt;&lt; "Student::show" &lt;&lt; endl; &#125;&#125;;// 调用Object *p1 = new Student();p1-&gt;show();Object*p2 = new Person();p2-&gt;show();// 打印Object::showObject::show 默认没有实现多态。使用虚函数后： struct Object &#123; virtual void show() &#123; cout &lt;&lt; "Object::show" &lt;&lt; endl; &#125;&#125;;// 打印Student::showPerson::show 虚函数父类添加virtual，声明为虚函数，子类的这些函数将自动成为虚函数。 没有添加virtual关键字时：p2-&gt;show();00AD2AF4 mov ecx,dword ptr [p2] 00AD2AF7 call Object::show (0AD14CEh) 添加virtual关键字时： p2-&gt;show();// 取出p2所指对象的地址给eax000666EF mov eax,dword ptr [p2] // 取出对象最前面的4个字节给edx000666F2 mov edx,dword ptr [eax] // 取出虚表的最前面的4个字节给eax000666F9 mov eax,dword ptr [edx]// 调用函数 000666FB call eax 虚函数的实现原理是虚表，这个虚表里面存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表。同一个基类的所有实例共用一份虚表。父类中的函数有virtual修饰，则子类中的该函数也会有virtual修饰，可省略。 重写后调用父类方法：class Student : Person &#123; func() &#123; Person::func(); &#125;&#125;; 如果存在父类类型指针指向子类对象，应该将析构函数声明为虚函数(虚析构函数)。这样delete父类指针时，才会调用子类的析构函数，保证析构的完整性。 纯虚函数纯虚函数：没有函数体且初始化为0的虚函数，用来定义接口规范。抽象类(Abstract Class)：含有纯虚函数的类，不可以实例化(不可以创建对象) 。抽象类也可以包含非纯虚函数，如果父类是抽象类，子类没有完全实现纯虚函数，那么这个子类依然是抽象类。 class Person &#123; virtual void speak() = 0;&#125;; 运算符重载运算符重载(操作符重载):可以为运算符增加一些新的功能。 struct CGPoint &#123; float mX; float mY; Person(int x, int y) :mX(x), mY(y) &#123;&#125; // 左边的const防止返回值被赋值，如 (p2 + p2) = p; // 右边的const保证返回值能再次调用operator+， 如 p = p1 + p2 + p3; const CGPoint operator+(const CGPoint &amp;p) const &#123; return CGPoint(mX + p.mX, mY + p.mY); &#125;&#125;;CGPoint operator+(const CGPoint &amp;p1, const CGPoint &amp;p2) &#123; return CGPoint(p1.mX + p2.mX, p1.mY + p2.mY);&#125;CGPoint per = CGPoint(2, 3) + CGPoint(3, 4); 内部类局部类如果将类A定义在类C的内部，那么类A就是一个内部类(嵌套类)。内部类的特点 支持public、protected、private权限 成员函数可以直接访问其外部类对象的所有成员(反过来则不行) 成员函数可以直接不带类名、对象名访问其外部类的static成员 不会影响外部类的内存布局 可以在外部类内部声明，在外部类外面进行定义 在一个函数内部定义的类，称为局部类。局部类的特点： 作用域仅限于所在的函数内部 其所有的成员必须定义在类内部，不允许定义static成员变量 成员函数不能直接访问函数的局部变量(static变量除外) void func() &#123; class Person &#123; int mAge; public: static void show() &#123; &#125; &#125; Person::show();// 函数调用&#125; 对象型参数和返回值使用对象类型作为函数的参数或者返回值，可能会产生一些不必要的中间对象。class Person &#123; int mAge;public: Person()&#123;&#125; // 构造 Person(int age) :mAge(age)&#123;&#125; // 初始化列表 Person(const Person &amp;per) :mAge(per.age)&#123;&#125; // 拷贝构造&#125;;// 作为参数void func1(Person per) &#123; // 拷贝构造&#125;// 作为返回值Person func2() &#123; Person per(10); return per;&#125;// 1Person per1(12);func1(per1);// 2Person per2;per2 = func2();// 3Person per3 = func2(); 对于Person per1(12); func1(per1);，当对象作为参数传递到另一个函数栈空间时，调用拷贝构造函数，创建出一个新的临时对象。对于Person per2; per2 = func2();，当对象作为返回值传递到另一个函数栈时，也会调用拷贝构造函数，创建出新的临时对象。对于Person per3 = func2();，原则上也应该调用拷贝构造函数，创建出新的对象。实际上编译器做了优化，在return之前，预先把结果对象的地址传递给函数，函数创建完对象就把该对象放到该地址对象的空间上。 对象作为参数或者返回值时尽量使用引用：func(Person &amp;p) &#123;&#125;Person &amp;func() &#123;&#125; // 返回对象而不是指针 匿名对象void func() &#123; return Person(12);&#125; 隐式构造某些情况下，会隐式调用单参数的构造函数。 Person func() &#123; return 12; // 隐式构造&#125;Person per = 22; // 隐式构造，一次构造Person per2; // 构造per2 = 23; // 拷贝构造 使用关键字explicit禁用掉隐式构造。 仿函数class Sum &#123;public: // 重载运算符: () int operator()(int a, int b) &#123; return a + b; &#125;&#125;;// 使用Sum sum;cout &lt;&lt; sum(1, 2) &lt;&lt; endl; 使用成员函数，可以使用仿函数。对比普通函数，可以作为对象保存状态。 有些运算符不可以被重载，比如： 对象成员访问运算符：. 域运算符：:: 三目运算符：?: sizeof 有些运算符只能重载为成员函数，比如： 赋值运算符：= 下标运算符：[] 函数运算符：() 指针访问成员：-&gt; 模板泛型，是一种将类型参数化以达到代码复用的技术，C++中使用模板来实现泛型。模板的使用格式如下：template &lt;typename\class T&gt;，其中typename和class是等价的。 模板没有被使用时，是不会被实例化出来的。模板的声明和实现如果分离到.h和.cpp中，会导致链接错误。原因是，实现文件不知道外界究竟怎么使用模板，不知道该怎么生成具体的实现，这就导致了多个目标文件链接的时候，无法找到具体的函数实现地址。一般将模板的声明和实现统一放到一个.hpp文件中。这样，使用了哪些函数，编译器就生成哪些实现。 函数模板template &lt;class T&gt;void swap(T &amp;a, T &amp;b) &#123; T tmp = a; a = b; b = tmp;&#125; 多参数模板template &lt;class T1, class T2&gt;void show(const T1 &amp;a, const T2 &amp;b) &#123; &#125; 类模板template &lt;class T&gt;class Person &#123; friend void &lt;&gt;show(T &amp;t); // 类模板中的友元函数 T t;&#125;; 类型转换C语言风格的类型转换符 (type)expression type(expression) C++中有4个类型转换符 static_cast dynamic_cast reinterpret_cast const_cast 使用格式：xx_cast&lt;type&gt;(expression) const_cast一般用于去除const属性，将const转换成非const。const Person *p = new Person();Person *p2 = const_cast&lt;Person *&gt;(p);// 等价于 Person *p2 = (Person *)p; dynamic_cast一般用于多态类型的转换，有运行时安全检测。Person *p1 = new Person();Person *p2 = new Student();// 相比较 Student *s = (Student *)p;，多了安全检测, s1会为空Student *s1 = dynamic_cast&lt;Student *&gt;(p1);// s2正常Student *s2 = dynamic_cast&lt;Student *&gt;(p2); static_cast对比dynamic_cast，缺乏运行时安全检测 不能交叉转换(不是同一继承体系的，无法转换) 常用于基本数据类型的转换、非const转成const 适用范围较广 Person p1 = new Person();// 等价于 const Person *p2 = p1;Person p2 = static_cast&lt;Student *&gt;(p1); reinterpret_cast属于比较底层的强制转换，没有任何类型检查和格式转换，仅仅是简单的二进制数据拷贝。可以交叉转换，可以将指针和整数互相转换。 一个字节为8位。一个十六进制位等于4个二进制位。int a = 10;在计算机存储（小端模式）：二进制： 0000 1010 0000 0000 0000 0000 0000 0000十六进制：0a 00 00 00double b = a; //按照8个字节来说浮点数的存储于整数存储大不相同：十六进制：00 00 00 00 00 00 24 40浮点数存储不是简单把二进制数据拷贝存储。 数据拷贝存储： int a = 10;double b = reinterpret_cast&lt;double&amp;&gt;(a);int *p = reinterpret_cast&lt;int *&gt;(10);int m = reinterpret_cast&lt;int&gt;(p); C++11新特性auto a = 5; 可以从初始化表达式中推断出变量的类型。 int b = 5;decltype(b) c = 6; 可以获取变量的类型。 int *p = &amp;b;p = nullptr; 指针置为空。 int array[] = &#123;1, 2, 3&#125;;for (int item : array) &#123;&#125; 快速遍历。 int array[]&#123;1, 2, 3&#125;; 初始化。 int (*p)(int, int) = [](int a, int b) -&gt; int &#123; return a + b;&#125;int exec(int a, int b, int(*func)(int, int)) &#123; if (func == nullptr) return 0; return func(a, b);&#125;exec(1, 2, [](int a, int b)&#123;return a + b;&#125;);// 值捕获与引用捕获int a = 10;int b = 20;auto func = [&amp;a, b] &#123; // a是引用捕获， b是值捕获 a += 1; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl;&#125;// mutableint c = 10;auto func2 = [c]() mutable &#123; c += 1; // c是11&#125;cout &lt;&lt; c &lt;&lt; endl; //c为10 Lambda表达式。 智能指针auto_ptr(已经废弃)&#123; auto_ptr&lt;Person&gt; p(new Person(1)); p-&gt;show();&#125; // 不需要调用delete函数 自实现：template&lt;class T&gt;class SP &#123; T *mPointer;public: SP(T *pointer) :mPointer(pointer) &#123;&#125; ~SP() &#123; if (mPointer == nullptr) return; // 指针销毁， 释放对象 delete mPointer; &#125; // -&gt;运算符重载 T *operator-&gt;() &#123; return mPointer; &#125;&#125; auto_ptr不支持数组：auto_ptr&lt;Person[]&gt; p(new Person[3]&#123;&#125;); shared_ptr多个shared_ptr可以指向同一个对象，当最后一个shared_ptr在作用域范围内结束时，对象才会被自动释放。原理：一个shared_ptr会对一个对象产生强引用(strong reference)。每个对象都有个与之对应的强引用计数，记录着当前对象被多少个shared_ptr强引用着，可以通过shared_ptr的use_count函数获得强引用计数。当有一个新的shared_ptr指向对象时，对象的强引用计数就会+1，当有一个shared_ptr销毁时(比如作用域结束)，对象的强引用计数就会-1，当一个对象的强引用计数为0时(没有任何shared_ptr指向对象时)，对象就会自动销毁(析构)。 可以支持数组：shared_ptr&lt;Person[]&gt; ptr(new Person[5]&#123;&#125;); 可以多个指针：shared_ptr&lt;Person&gt; ptr(new Person(2));shared_ptr&lt;Person&gt; ptr2 = ptr;shared_ptr&lt;Person&gt; ptr3 = ptr;cout &lt;&lt; ptr.use_count &lt;&lt; endl; weak_ptr weak_ptr会对一个对象产生弱引用，可以指向对象解决shared_ptr的循环引用问题。 循环引用问题：class Car &#123;public: shared_ptr&lt;Person&gt; mPerson;&#125;;class Person &#123;public: shared_ptr&lt;Car&gt; mCar;&#125;;shared_ptr&lt;Person&gt; per(new Person());shared_ptr&lt;Car&gt; car(new Car());per-&gt;mCar = car;car-&gt;mPer = per; 解决循环引用：class Car &#123;public: weak_ptr&lt;Person&gt; mPerson;&#125;;class Person &#123;public: shared_ptr&lt;Car&gt; mCar;&#125;; unique_ptrunique_ptr也会对一个对象产生强引用，它可以确保同一时间只有1个指针指向对象当unique_ptr销毁时(作用域结束时)，其指向的对象也就自动销毁了。可以使用std::move函数转移unique_ptr的所有权。unique_ptr&lt;Person&gt; ptr1(new Person());// 转移unique_ptr&lt;person&gt; ptr2 = std::move(ptr1); 二、其他函数调用的流程创建函数栈空间后，全部填充0xCCCCCCCC，即中断指令。起到断点的作用。函数调用是有时间和空间开销的(递归效率低下)。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。 变量地址每一个字节都有自己的内存地址。一个变量的地址值，是它所有字节地址中的最小的那个地址值。CPU大小端模式，大多数是小端，即地址值低的位置优先（存储）读，高字节放高地址，低字节放低地址。 例：4个字节存储int类型的整数3：16进制： 00 00 00 03H2进制： 00000000 00000000 00000000 00000011 例：int age = 9;的存储实现： // age地址是0x0113FD40int age = 9; 0x0113FD40 09 00 00 00 cc cc cc // 从低到高吞并4个字节 由于是小端，则从右向左读取0x0113FD40 090x0113FD41 000x0113FD42 000x0113FD43 00 寄存器x64汇编兼容x86汇编64位，一个寄存器存8个字节。32位，一个寄存器存4个字节。 64位RAX\RBX\RCX\RDX 通用寄存器32位EAX\EBX\ECX\EDX 通用寄存器 RAX的低4个字节就是EAX。EAX的低2个字节就是AX。AX的低1个字节就是AL，AX的高1个字节就是AH。 c++嵌入汇编__asm &#123; mov ax, 8 mov eax, 12345678H &#125; mov dest, src：将src的内容赋值给dest，类似于dest = src。 [地址值] 中括号[ ]里面放的都是内存地址。word是2字节，dword是4字节(double word)，qword是8字节(quad word) 。 mov eax, dword ptr [1234h]：从1234h开始取出4个字节（往高字节）的内容给eax寄存器。 mov [1234h], 6：表示把6赋值到1234h地址所在的内存空间。 call 函数地址：调用函数。 lea dest, [地址值]：将地址值赋值给dest，类似于dest = 地址值。 ret：函数返回。 xor op1, op2：将op1和op2异或的结果赋值给op1，类似于op1 = op1 ^ op2。 add op1, op2：类似于op1 = op1 + op2。 sub op1, op2：类似于op1 = op1 - op2。 inc op：自增，类似于op = op + 1。 dec op：自减，类似于op = op – 1。 jmp 内存地址：跳转到某个内存地址去执行代码。j开头的一般都是跳转，大多数是带条件的跳转，一般跟test、cmp等指令配合使用。 eax一般存储函数返回值。jne不相等跳转。je相等跳转。int m = 8;012E18C8 mov dword ptr [ebp-8],8 int n = m;012E18CF mov eax,dword ptr [ebp-8] 012E18D2 mov dword ptr [ebp-14h],eax C语言中模拟面向对象void show() &#123; printf("func show\n");&#125;struct Student &#123; // 成员变量 int age; // 方法（指向函数的指针） void (*show)(void);&#125;;int main(int argc, const char * argv[]) &#123; struct Student stu; stu.age = 10; stu.show = show; stu.show(); return 0;&#125; 声明与实现分离头文件#pragma onceclass Person &#123;private: int mAge;public: void setAge(int age); int getAge(); Person(); ~Person();&#125;; 实现文件#include "Person.hpp"void Person::setAge(int age) &#123; mAge = age;&#125;int Person::getAge() &#123; return mAge;&#125;Person::Person() &#123; &#125;Person::~Person() &#123; &#125; string的使用前提:#include &lt;string&gt; 1.输入输出 string s;cin &gt;&gt; s;cou &lt;&lt; s &lt;&lt; endl; 2.通过下标访问string s = "qwert";s[3] = 'd';couy &lt;&lt; s[2]; 3.拼接string s = "i";char *s1 = "love";char s2[] = "you";char s3 = '!'; string rs = s + s1 + s2 + s3; 4.插入string s = "sdf";s.insert(1,"sds"); // 索引/内容 5.删除s1 = s2 = s3 = "1234567890";s2.erase(5);s3.erase(5, 3); // 长度为3 6.提取 s1.substr(6, 6); // 长度为6 7.查找 s.find(&quot;,&quot;,1); // 从索引1开始查找逗号,返回索引 C++中的单例1.构造函数、拷贝构造函数以及析构函数私有。2.定义一个私有的static静态成员变量。3.提供公开访问接口。 class App &#123;public: static App *sharedApp() &#123; // 考虑加锁... if (gApp == NULL) &#123; gApp = new App(); &#125; // 考虑解锁... return gApp; &#125;private: App() &#123;&#125; App(const App &amp;app) &#123;&#125; ~App() &#123;&#125; static App*gApp;&#125;;App *App::gApp = NULL;// 创建单例App *app = App::sharedApp(); 参考博客：C语言中文网]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法实现]]></title>
    <url>%2F2017%2F03%2F05%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[2017.03.25 修改2017.04.24 修改部分代码 排序算法。 前言因为笔试使用的编译器语言为Python2.7，所以以下代码使用Python2实现并规定从小到大为目标顺序。 八大排序：直接插入排序，希尔排序，简单选择排序，堆排序，冒泡排序，快速排序，归并排序，基数排序。 排序的稳定性假定n1 = n2，排序前n1位于n2前面，如果排序后n1扔领先于n2，则称排序算法稳定。 内排序与外排序内排序：排序的整个过程中，待排序的所有记录全部被放置在内存中。外排序：由于排序的记录太多，排序的过程中，需要内外存之间多次交换才能进行。 一、冒泡排序原理：通过相邻元素的比较和交换，把较大的数交换到后面，类似水泡向上面(数组的后面，所以总是靠后的数字有序)升，故称为冒泡排序。如果两数相等，不交换，所以稳定。 普通方式 def bubbleSort(tempList): n = len(tempList) for x in xrange(n): for y in xrange(1, n - x):# 索引n-x之后的数已经排序好了 if tempList[y - 1] &gt; tempList[y]: tempList[y], tempList[y - 1] = tempList[y - 1], tempList[y] return tempListprint bubbleSort([5,10,2,7,0,30]) 优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，无需继续迭代。 #交换排序-冒泡排序优化1def bubbleSort1(tempList): n = len(tempList) for x in xrange(n): #标志位,倘若没有交换,说明已经排序好了 flag = True for y in xrange(1, n - x):# 索引n-x之后的数已经排序好了 if tempList[y - 1] &gt; tempList[y]: tempList[y], tempList[y - 1] = tempList[y - 1], tempList[y] flag = False if flag: # 发现并没有发生交换 return tempList return tempListprint bubbleSort1([5,10,2,7,0,30]) 优化2：记录最后发生交换的位置，位置之后的数据已经井然有序。 #交换排序-冒泡排序优化2def bubbleSort2(tempList): n = len(tempList) # 循环范围 m = n for x in xrange(n): #标志位,倘若没有交换,说明已经排序好了 flag = True for y in xrange(1, m):# 索引m之后的数已经排序好了 if tempList[y - 1] &gt; tempList[y]: tempList[y], tempList[y - 1] = tempList[y - 1], tempList[y] m = y flag = False if flag: # 发现并没有发生交换 return tempList return tempListprint bubbleSort2([5,10,2,7,0,30]) 分析最好情况:数据井然有序,根据优化后的代码,只需要迭代一次,即n-1次的比较,则时间复杂度为O(n)最坏情况:数据逆序,需要比较的次数为1+2+3+4+…+(n-1)=n(n-1)/2次,时间复杂度为O(n^2) 假定有4个数,分别为4 3 2 1,排序过程为:原数据: 4 3 2 1第1次: 3 4 2 1第2次: 3 2 4 1第3次: 3 2 1 4第4次: 2 3 1 4第5次: 2 1 3 4第6次: 1 2 3 4归纳推理:n(n-1)/2次 二、选择排序在未排序序列中找到最小元素，存放到排序序列的起始位置(与第一个元素交换位置)，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾(与第二个元素交换位置)。以此类推，直到所有元素均排序完毕。 通过n-i次关键字间的比较,从n-i+1个记录中选出最小的记录,并和第i个记录交换之. 选择排序的交换操作介于 0 和 ( n − 1 )次之间。选择排序的比较操作为 n ( n − 1 ) / 2次之间。选择排序的赋值操作介于 0 和 3 ( n − 1 )次之间。 当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。 def selectionSort(tempList): n = len(tempList) for x in xrange(n): # 假定索引x对应的是最小值 index = x for y in xrange(x + 1,n): # 如果找到比索引index对应的值还要小的值,交换两者位置 if tempList[index] &gt; tempList[y]: tempList[index], tempList[y] = tempList[y], tempList[index] return tempListprint selectionSort([5,10,2,7,0,30]) 分析特点:交换移动数据次数相当少最好情况与最坏情况:比较次数一样多,为n(n-1)/2次,时间复杂度:O(n^2) 假定有4个数据,分别为 4 3 2 1原数据: 4 3 2 1第1次比较: 4 与 3第2次比较: 4 与 2第3次比较: 4 与 1 (此时数据为1 3 2 4)第4次比较: 3 与 2第5次比较: 3 与 4 (此时数据为 1 2 3 4)第6次比较: 3 与 4最终结果: 1 2 3 4比较次数:6次 选择排序是不稳定的排序算法,比如5 8 5 2 9,显然第1个5最终落到第2个5的后面. 原数据: 5' 8 5 2 9第1次交换: 2 8 5 5' 9第2次交换: 2 5 8 5' 9第3次交换: 2 5 5' 8 9第4次交换: 2 5 5' 8 9最终 5'在 5 的前面. 三、直接插入排序原理:在一个已经有序的数据序列中插入一个数，在插入后此数据序列仍然有序。默认前1个数有序，第二个数与前一个数组成的有序数列比较并插入，第三个数与前两个数组成的有序数列比较并插入……所以总是靠前的数字有序。 遇到相等的数，插入到该数的后面，而不是前面，所以是稳定排序算法。 最好情况：序列已经是升序排列了，需要进行的比较操作需(n-1)次,时间复杂度为O(n)。最坏情况：序列是降序排列，那么此时需要进行的比较共有 n ( n − 1 ) / 2 次。插入排序的赋值操作是比较操作的次数加上(n-1)次。平均来说插入排序算法复杂度为 O ( n^2 )。插入排序不适合对于数据量比较大的排序应用。用于少量元素的排序（通常为8个或以下）。 直接插入 def insertionSort(tempList): # 获取列表的长度 n = len(tempList) for x in xrange(1,n): # 从第1个元素而非第0个元素开始遍历 for y in xrange(x, 0, -1): # 在已经排好序的列表中逐个扫描 if tempList[y - 1] &gt; tempList[y]: # 如果当前元素比前面的小 tempList[y], tempList[y - 1] = tempList[y - 1], tempList[y] # 两者位置互换 return tempList# print insertionSort([])# print insertionSort([8])# print insertionSort([5,2,7,0,1,5,9]) 四、二分插入排序二分查找插入与希尔排序是直接插入排序的优化。 二分查找插入 使用Python模块实现 # bisect模块实现了一个算法, 用于向一个有序列表中插入一个元素,不改变列表的序列# 使用这个模块的函数前先确保操作的列表是已排序的#import bisect def insertionSortBisect(tempList): for i in xrange(1, len(tempList)): bisect.insort(tempList, tempList.pop(i), 0, i) # 排序列表,移除并插入元素,区间开始,区间结束 return tempList# print insertionSortBisect([])# print insertionSortBisect([8])# print insertionSortBisect([5,2,7,0,1,5,9]) 手动实现 #二分查找的前提必须待查找的序列有序# 在有序列表中,返回值m应该所在的索引def indexOfInsertionSort(tempList, m): # 获取列表的长度 n = len(tempList) left, right = 0, n - 1 while left &lt;= right: middle = (left + right) / 2 if tempList[middle] &lt; m:# 右半部分 left = middle + 1 else: #左半部分,含相同元素 right = middle -1 return right +1 def insertionSortbin(tempList): # 获取列表的长度 n = len(tempList) for x in xrange(0,n): # 从头至尾遍历列表中的元素 m = tempList[x] tempList.pop(x) index = indexOfInsertionSort(tempList[0:x],m) tempList.insert(index , m) #第一个参数是索引,第二个参数是数值 return tempList #print insertionSortbin([12,12,16,8,5,10,7]) 五、希尔排序先将待排记录序列分割为若干个子序列，分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序。 采用跳跃分割的策略:把相距某个”增量”的记录组成一个序列，保证在子序列内分别进行直接插入排序后得到的结果是基本有序的。 原始序列 2 5 1 9 8 2 10 4 4步长，分组，每列排序 2 5 1 98 2 10 4 排序后 2 2 1 48 5 10 9 也即 2 2 1 4 8 5 10 9 2步长，再分组 2 21 48 510 9 排序 1 22 48 510 9 也即： 1 2 2 4 8 5 10 9 最后以1步长进行排序（还是直接插入排序）。 一般插入 def insertionSortShell(tempList): n = len(tempList) # 确定分组,假定n = 6 group = n / 2 # 此时group = 3,分成3组,3组元素索引分别为3与3-3,4与4-3,5与5-3 while group &gt; 0: #x从3到5 for x in xrange(group,n): # 每组元素:x,x-group,x-group-group ......插入排序 temp = tempList[x] y = x # 这里使用简单的插入排序 while y &gt;= group and tempList[y - group] &gt; temp: tempList[y] = tempList[y - group] y -= group tempList[y] = temp group /= 2 return tempList 互换法 def insertionSortShellExchange(tempList): n = len(tempList) # 确定分组,假定n = 6 group = n / 2 # 此时group = 3,分成3组,3组元素索引分别为3与3-3,4与4-3,5与5-3 while group &gt; 0: #x从3到5 for x in xrange(group,n): # 每组元素:x,x-group,x-group-group ......插入排序 y = x m = tempList[x] while y &gt;= group and tempList[y - group] &gt; m: # 这里直接交换位置 tempList[y], tempList[y - group] = tempList[y - group], tempList[y] y -= group group /= 2 return tempList#print insertionSortShell([1,8,10,2,4,0])#print insertionSortShellExchange([1,8,10,2,4,0]) 由于记录是跳跃式的，希尔排序是不稳定的排序算法。 六、堆排序堆排序是对简单选择排序的改进。 堆是具有以下性质的完全二叉树:每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 性质:按层遍历的方式给结点编号，则有: k(i) &gt;= k(2i) k(i) &gt;= k(2i+1) 或 k(i) &lt;= k(2i) k(i) &lt;= k(2i+1) 堆排序就是利用堆进行排序的算法，基本思想是:将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根结点。把它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个值重新构造成一个堆，这样就会得到n个元素中的次小值，如此反复执行，便能得到一个有序序列了。 需要解决的两个问题:1. 如何由一个无序序列构建成一个堆2. 如何在获取堆顶元素后，调整剩余元素成为一个新的堆 所谓的将待排序的序列构建成一个大顶堆，其实就是从下往上、从右往左，将每个非叶结点当作根节点，将其和其子树调整成大顶堆。 在正式排序时，第i次取堆顶记录重建需要O(logi)的时间，并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为O(nlogn)。 堆排序对原始状态的排序不敏感，无论是最好最坏还是平均情况时间复杂度总是为O(nlogn)。 注意:由于初始构建堆所需的比较次数较多，因此，它并不适合待排序序列个数较少的情况。 实现 # start是当前需要调整最小堆的位置,end是调整边界def heapAdjust(tempList, start, end): root = start while True: child = root * 2 + 1 if child &gt; end: break if child + 1 &lt;= end and tempList[child] &lt; tempList[child + 1]: child += 1 if tempList[root] &lt; tempList[child]: tempList[root], tempList[child] = tempList[child], tempList[root] root = child else: break def heapSort(tempList): n = len(tempList) # 构造小顶堆 for i in xrange(n / 2, -1, -1): heapAdjust(tempList, i, n - 1) for i in xrange(n - 1, 0, -1): # 将堆顶记录和当前未排序子序列的最后一个记录交换 tempList[0], tempList[i] = tempList[i], tempList[0] # 重新调整为小顶堆 heapAdjust(tempList, 0, i - 1) return tempListprint heapSort([2,4,3,1,6,7,4,2,8]) 七、归并排序归并排序就是利用归并的思想实现的排序算法。原理是:假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两合并，得到n/2的向上取整个长度为2或者为1的有序子序列，然后两两合并，如此重复，直到得到一个长度为n的有序序列。该方法也称为2路归并排序。 比较操作的次数介于 ( nlogn ) / 2 和 nlogn − n + 1。赋值操作的次数是 ( 2 nlogn )。 #归并排序def mergeSort(tempList): length = len(tempList) if length &lt;= 1: return tempList # 二分列表 middle = length / 2 leftList = mergeSort(tempList[:middle]) rightList = mergeSort(tempList[middle:]) return merge(leftList,rightList)def merge(leftList,rightList): leftIndex,rightIndex = 0, 0 result = [] while leftIndex &lt; len(leftList) and rightIndex &lt; len(rightList): if leftList[leftIndex] &lt; rightList[rightIndex]: result.append(leftList[leftIndex]) leftIndex += 1 else: result.append(rightList[rightIndex]) rightIndex += 1 result += leftList[leftIndex:] result += rightList[rightIndex:] return resultprint mergeSort([2,5,1,2,0,6,3]) 一趟归并需要耗费O(n)时间，由完全二叉树的深度可知，整个归并排序需要进行logn次，故，总的时间复杂度为O(logn)，并且最好/最坏/平均时间性能均是如此。 归并排序需要两两比较，不存在跳跃，因此稳定。 八、快速排序20世纪十大算法之一。 关键词:基准 分组 递归 在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较。 快速排序使用分治法策略来把一个序列分为两个子序列。 步骤为： 从数列中挑出一个元素，作为基准数， 分区：把比基准大的放在右边，比基准小的放在左边，等于基准的放在基准列表中。 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 def quickSort(tempList): if len(tempList) &lt;= 1: return tempList # 基准列表 pivotList = [] # 比基准小的列表 lessList = [] # 比基准大的列表 moreList = [] #将第一个值作为基准 pivot = tempList[0] # 遍历tempList for x in tempList: # 比基准大,放入moreList if x &gt; pivot: moreList.append(x) # 比基准小,放入lessList elif x &lt; pivot: lessList.append(x) # 与基准相等,放入基准列表中 else: pivotList.append(x) # 对lessList和moreList递归操作 lessList = quickSort(lessList) moreList = quickSort(moreList) # 返回排序好的列表 return lessList + pivotList + moreList 甚至可以这么写 def quickSort1(tempList): if len(tempList) &lt;= 1: return tempList else: pivot = tempList[0] return quickSort1([x for x in tempList[1:] if x &lt; pivot])\ + [pivot] + \ quickSort1([x for x in tempList[1:] if x &gt;= pivot])print quickSort1([5,7,8,2,6,8,0,5]) 快速排序的时间复杂度取决于快速排序递归的深度，在最优情况下时间复杂度为O(logn)。最坏情况下，待排序为正序或者逆序，时间复杂度为O(n^2) 由于关键字的比较和交换是跳跃进行的，因此快速排序不稳定。 快速排序的优化: 优化选取枢轴三数取中法:取三个关键字先进行排序，将中间数作为枢轴，一般取左端、右端和中间三个数，也可以随机选取，至少枢轴不是最大或者最小的数。 九、计数排序计数排序是用来排序0到100之间的数字的最好的算法。 步骤: 找出待排序的数组中最大和最小的元素统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 #计数排序def countsort(tempList): if len(tempList) &lt;= 1: return tempList maxValue = max(tempList) minValue = min(tempList) # 创建计数列表countList countList = [0] * (maxValue - minValue + 1) # 获取元素出现次数 for e in tempList: countList[e - minValue] += 1 index = 0 # 填值 for a in xrange(maxValue - minValue + 1): for c in xrange(countList[a]): tempList[index] = a + minValue index += 1 return tempList print countsort([1,6,3,2,3]) 那么,以1,6,3,2,3为例最值maxValue = 6minValue = 1 计数列表countList = [0, 0, 0, 0, 0, 0] 元素出现的次数countList = [1, 1, 2, 0, 0, 1] a countList[a] 即遍历次数 tempList[index] 0 1 tempList[0] = 1 1 1 tempList[1] = 2 2 2 tempList[2] = 3以及tempList[3] = 3 3 0 4 0 5 1 tempList[4] = 6 排序成功:1, 2, 3, 3, 6 十、总结算法分析： 代码保存在GitHub上。 参考资料：《大话数据结构》维基百科segmentfaultWuChongbubkoo]]></content>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自定义转场总结]]></title>
    <url>%2F2017%2F02%2F26%2FiOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[自定义转场总结。 一、勾弦转场的本质是下一场景的视图替换当前场景的视图以及相应的控制器的替换，表现为当前视图消失和下一视图出现。容器类 VC 的转场里 fromView 和 toView 是 containerView 的子层次的视图，而 Modal 转场里 presentingView 与ontainerView 是同层次的视图，只有 presentedView 是 containerView 的子层次视图。Custom 模式下 Modal 转场结束时 fromView 并未从视图结构中移除；FullScreen 模式的 Modal 转场结束后 fromView 主动被从视图结构中移除了。Custom 模式下，在 dismiss 中，不要像其他转场中那样将 toView加入 containerView 中，否则 dismiss 结束后本来可见的 presentingView 将会随着 containerView 一起被移除。 在 Modal 转场中，presentingView 并非 containerView 的子视图，这时通过viewForKey:方法来获取presentingView 得到的是 nil，必须通过viewControllerForKey:得到presentingVC 后来获取。当 UIViewController 的modalPresentationStyle属性为.Custom 或.FullScreen时，就有机会定制转场效果，此时modalTransitionStyle指定的转场动画将会被忽略。 容器 VC 的转场的代理由容器 VC 自身提供，Modal 转场的代理由 presentedVC(目标控制器) 提供。Modal 转场在 Custom 模式下必须区分 presentation 和 dismiss 转场，而在 FullScreen 模式下可以不用这么做，因为 UIKit 会在 dismiss 转场结束后自动将 presentingView 放置到原来的位置。转场代理（Transitioning Delegate）根据不同的转场类型提供其所需要的动画控制类和交互控制类。 动画控制类(器)（Animation Controller）遵从UIViewControllerAnimatedTransitioning协议，并且负责执行实际的动画。交互控制类(器)（Interaction Controller）遵从UIViewControllerInteractiveTransition协议来控制可交互的转场动画。转场上下文（Transitioning Context）定义了转场时需要的元数据（比如转场所参与了的视图控制器和视图的属性），其遵从UIViewControllerContextTransitioning协议，并且这是由系统负责生成和提供。 转场协调器（Transition Coordinators）可以在运行转场动画时，并行地运行其他动画。转场协调器遵从UIViewControllerTransitionCoordinator协议。转场动画交互方式分两种，第一种是属于非交互式：必须要实现动画控制类，第二种交互方式：必须要实现动画控制类和交互控制类（例如可以通过手势的滑动距离来控制转场动画的一个进度，一般应用中都可以通过手势的滑动来推出一个视图控制器)。 二、简单转场基本类型 UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。UIViewAnimationOptionRepeat：重复运行动画。UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场动画）。 UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。 动画速度控制（可从其中选择一个设置） UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。UIViewAnimationOptionCurveEaseOut：动画逐渐加速。UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。 转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置） UIViewAnimationOptionTransitionNone：没有转场动画效果。UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。 简单使用作用于fromView的父视图，切换两个view，将formView从其父视图上移除，将toView重新粘在其父视图上，展现一个动画效果。 [UIView transitionFromView:self.view toView:redView duration:5.0 options: UIViewAnimationOptionCurveLinear completion:^(BOOL finished) &#123; kLog(@"转场动画完成");&#125;]; 重绘View视图，任何其子视图的改变或者其自身的改变都会触发转场动画的效果。 [UIView transitionWithView:self.view duration:2.0 options: UIViewAnimationOptionCurveLinear animations:^&#123; self.view.alpha = 0.1;&#125; completion:^(BOOL finished) &#123; kLog(@"动画完成");&#125;]; 三、模态转场源控制器A–&gt;目标控制器B。 (1) 提要可以只使用一个动画控制器Animator，但是要对Present/Dismiss分别实现。模态的类型默认为FullScreen，即在Present时，会移除fromView，而类型设置为Custom时，就会使fromView与toView共存。present时，要把toView加入到container的视图层级，dismiss时，要把fromView从container的视图层级中移除。非交互式转场，需要在动画执行完毕声明complete[transitionContext completeTransition:YES];交互式转场，需要判断转场完成或者取消。 BOOL isCancelled = transitionContext.transitionWasCancelled;// 考虑到转场中途可能取消的情况，转场结束后，恢复视图状态。fromView.transform = CGAffineTransformIdentity;toView.transform = CGAffineTransformIdentity; 在模态中，设置将要跳转到的视图控制器(presentedViewController)的transitioningDelegate。充当代理的对象可以是源视图控制器(presentingViewController)，也可以是自己创建的对象，它需要为转场动画提供一个animator对象。animator对象的animateTransition是整个动画的核心逻辑。 (2) 无交互设置目标控制器B的代理(可以是A，也可以是B)以及模态动画类型(常用UIModalPresentationCustom或UIModalPresentationFullScreen)。 YAShareViewController *shareViewController = [[YAShareViewController alloc] init]; // 设置转场代理shareViewController.transitioningDelegate = self;// 设置转场动画类型shareViewController.modalPresentationStyle = UIModalPresentationCustom;[self presentViewController:shareViewController animated:YES completion:nil]; // 目标控制器的代理遵守UIViewControllerTransitioningDelegate协议并相关实现方法#pragma mark - Transitioning Delegate// 无交互出现动画- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123; YATransitionAnimator *animator = [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPresent]; return animator;&#125; // 无交互消失动画- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed &#123; YATransitionAnimator *animator = [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorDismiss]; return animator;&#125; 代理方法中的动画管理者Animator独立存在，可以新建一继承自NSObject且遵守UIViewControllerAnimatedTransitioning协议的对象担任(仅仅遵守协议实现方法即可，不需设置代理)。 #pragma mark – Life Cycle + (instancetype)transitionAnimatorWithType:(TransitionAnimatorType)transitionAnimatorType &#123; YATransitionAnimator *animator = [[YATransitionAnimator alloc] init]; animator.transitionAnimatorType = transitionAnimatorType; return animator;&#125; #pragma mark - AnimatedTransitioning delegate //返回动画时间- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; return 5.0;&#125; //执行动画的地方- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; // 1.获取动画必要元素 UIView *containerView = [transitionContext containerView]; UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey]; UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey]; toView.origin = CGPointMake(0， kScreenHeight); // 2.动画 // 出场 if (self.transitionAnimatorType == TransitionAnimatorPresent) &#123; // 2.添加toView，不一定是addSubview方式 [containerView addSubview:toView]; [UIView animateWithDuration:2.5 animations:^&#123; toView.origin = CGPointMake(0， 0); &#125; completion:^(BOOL finished) &#123; // 完成 [transitionContext completeTransition:YES]; &#125;]; &#125; // 消失 if (self.transitionAnimatorType == TransitionAnimatorDismiss) &#123; [UIView animateWithDuration:2.5 animations:^&#123; fromView.origin = CGPointMake(0， kScreenHeight); &#125; completion:^(BOOL finished) &#123; // 2.添加toView，不一定是addSubview方式 [fromView removeFromSuperview]; // 完成 [transitionContext completeTransition:YES]; &#125;]; &#125;&#125; (3) 交互(坑多，所以一般不用下列方式，取而代之使用UIPresentationController。) 在目标控制器的代理方法中，实现交互式代理方法: // 2.交互出现动画- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123; return [[YAInteractiveTransition alloc] init];&#125;// 2.交互消失动画- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123; return [[YAInteractiveTransition alloc] init];&#125; 新建一继承自UIPercentDrivenInteractiveTransition的交互组件类(最好这么做，也可以自定义类遵守UIViewControllerInteractiveTransitioning协议，但极不推荐)，实现必须的startInteractiveTransition方法。 - (void)startInteractiveTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;&#125; (4) UIPresentationControlleriOS8后的新API，极其方便。把管理权限交给UIPresentationController。设置模态动画类型后，只需要在目标控制器的代理方法中实现: - (nullable UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(nullable UIViewController *)presenting sourceViewController:(UIViewController *)source &#123; return [[YAPresentationController alloc] initWithPresentedViewController:presented presentingViewController:presenting];&#125; 那么所有的工作就在YAPresentationController控制器中了。实现相应的方法: //在呈现过渡即将开始的时候被调用的- (void)presentationTransitionWillBegin&#123; // 源控制器的View [self.containerView addSubview:self.presentingViewController.view]; // 背景View [self.containerView addSubview:self.backgroundView]; // 目标控制器View [self.containerView addSubview:self.presentedView]; &#125; //在呈现过渡结束时被调用的- (void)presentationTransitionDidEnd:(BOOL)completed&#123; &#125; //在退出过渡即将开始的时候被调用的- (void)dismissalTransitionWillBegin&#123; &#125; //在退出的过渡结束时被调用的- (void)dismissalTransitionDidEnd:(BOOL)completed&#123; &#125; // 调整呈现的View的frame- (CGRect)frameOfPresentedViewInContainerView&#123; &#125; 四、NavigationController转场设置源控制器的导航控制器的代理，遵守UINavigationControllerDelegate协议，根据交互式或者非交互式实现相应方法.在方法中根据Push或者Pop返回相应的自定义动画控制器(或者交互控制器)。 // 交互式- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController &#123; &#125; // 非交互式- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; // Push情况下 if (operation == UINavigationControllerOperationPush) &#123; return [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPush]; &#125; else if (operation == UINavigationControllerOperationPop) &#123; // Pop情况下 return [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPop]; &#125; else &#123; return nil; &#125; &#125; 五、TabBarController转场与导航控制器类似，设置源控制器的tabBarController的代理，遵循UITabBarControllerDelegate，实现相应的方法，只不过它既没有模态的Present和Dismiss，也没有导航控制器的Push和Pop，只有一种方式，更加简单，同样，在方法中返回自定义的动画控制器(或者交互控制器)。 - (id &lt;UIViewControllerInteractiveTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController interactionControllerForAnimationController: (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController &#123;&#125; - (id &lt;UIViewControllerAnimatedTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController animationControllerForTransitionFromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123;&#125;]]></content>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git/LLDB/Linux等常用命令]]></title>
    <url>%2F2017%2F02%2F20%2FGit%3ALLDB%3ALinux%E7%AD%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[2017.4.3 补充Clang指令 Git/SVN/Linux/Vim/LLDB等常用、快忘记的命令总结。 CocoaPodspod install --verbose --no-repo-update Git源代码管理工具能追踪一个项目从诞生一直到定案的过程，记录一个项目的所有内容变化，方便地查阅特定版本的修订情况。 Git与SVN的对比:1.Git是分布式，有本地分支，SVN是集中式，无本地分支。2.git合并操作保留原有的提交过程（即保留了合并来源的作者、提交次数、分离提交的内容）。svn合并操作把来源多个提交合并成了一个合并提交。3.git：可以修正提交(在自己的分支)。svn：一旦提交就到服务器上，实际使用中就是不能修改。4.SVN没有tag和真正意义的分支(它的分支是一个完整的目录。且这个目录拥有完整的实际文件)，Git支持。5.Git有暂存区，提交速度快。 开始1.清除本地以及远程的.DS_Store文件(修复后添加.gitignore) find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch 2.克隆仓库到本地 git clone https://github.com/ChenYalun/a.git 3.添加忽略文件 git add .gitignore 4.提交修改 git commit -m &quot;注释&quot; 5.推送到远程仓库 git push YAKit(仓库名称) origin(分支名称) 初步在git中，版本号是一个由SHA1生成的哈希值。 查看git所有命令的帮助 $ git help 子命令 # 要退出帮助信息，按&quot;q&quot; # 翻看下页，按&quot;空格&quot; # 翻看上页，按&quot;CTRL+B&quot; # 要搜索相关文字，按&quot;/&quot;然后输入&quot;相关文字&quot; 配置以及全局配置 git config user.name &quot;chenyalun&quot; git config user.email iChenYalun@gmail.com git config --global user.name &quot;chenyalun&quot; git config --global user.email iChenYalun@gmail.com 查看当前所有配置 git config -l 编辑(全局)配置文件 git config -e [--global] 在当前目录下初始化仓库 git init 新建一个目录，将其初始化为Git代码库 git init [目录] 添加所有的文件/指定的文件到暂存区 git add . git add a.h，a.m 添加目录到暂存区 git add [dir] 删除工作区文件 git rm a.h a.m 停止追踪指定文件,但是文件会保存在工作区 git rm --cached a.h 改名,并且将这个改名放入暂存区 git mv old.h new.h 提交文件，添加注释，要使用 -m 参数指定修改的备注信息 git commit -m &quot;初始化仓库&quot; 使用git时，每一次修改都需要添加(add)再提交(commit)，这一点是与svn不一样 查询代码库当前状态(已加载，未加载等) git status 查看所有版本库日志 git log 查看指定文件(a.m)的版本库日志 git log a.m 追加提交 git commit -m &apos;initial commit&apos; git add forgotten_file git commit --amend 撤销某次提交 git revert commitId 提交时显示所有diff信息 git commit -v 使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化 git commit --amend a.h a.m 版本恢复暂存区的指定文件到工作区 git checkout a.h 恢复某个commit的指定文件到暂存区和工作区 git checkout [commit] [file] 恢复暂存区的所有文件到工作区 git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 git reset a.h 重置暂存区与工作区，与上一次commit保持一致 git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git reset --keep [commit] 新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支 git revert [commit] 暂时将未提交的变化移除，稍后再移入 git stash git stash pop 查看git的总提交次数 git rev-list head | sort | wc -l 分支列出所有本地分支 git branch 列出所有远程分支 git branch -r 列出所有本地分支和远程分支 git branch -a 新建一个分支，但依然停留在当前分支 git branch [branch-name] 新建一个分支，并切换到该分支 git checkout -b [branch] 新建一个分支，指向指定commit git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区 git checkout [branch-name] 切换到上一个分支 git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch] [remote-branch] 如:git branch --set-upstream dev remotes/origin/dev,名字保持一致 合并指定分支到当前分支 git merge [branch] // 通常使用下面这条: git merge --no-ff [branch] 选择一个commit，合并进当前分支 git cherry-pick [commit] 删除分支 git branch -d [branch-name] 删除远程分支 git push origin --delete [branch-name] git branch -dr [remote/branch] 仓库添加新的远程仓库 git remote add &lt;name&gt; &lt;url&gt; 拉取远程仓库的内容 git fetch &lt;name&gt; [branchName] //不会合并，只拉取 git pull &lt;name&gt; [branchName] //拉取并且合并 移除某个远程仓库 git remote rm &lt;name&gt; 重命名远程仓库 git remote rename oldShortName newShortName 查看远程仓库的url git remote -v 标签列出所有tag git tag 新建一个tag在当前commit git tag [tag] 新建一个tag在指定commit git tag [tag] [commit] 删除本地tag git tag -d [tag] 删除远程tag git push origin :refs/tags/[tagName] 查看tag信息 git show [tag] 提交指定tag git push [remote] [tag] 提交所有tag git push [remote] --tags 新建一个分支，指向某个tag git checkout -b [branch] [tag] 远程下载远程仓库的所有变动 git fetch [remote] 显示所有远程仓库 git remote -v 显示某个远程仓库的信息 git remote show [remote] 增加一个新的远程仓库，并命名 git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 git pull [remote] [branch] 上传本地指定分支到远程仓库 git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --force 推送所有分支到远程仓库 git push [remote] --all 其他设置git别名 git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status git config --global alias.unstage &apos;reset HEAD --&apos; 文件权限不纳入版本管理 git config core.filemode false SVN初步checkout将服务器上最新的代码仓库下载到本地，”只需要做一次” update从服务器上将其他人所做的修改下载到本地 commit将工作提交到服务器 将文件添加到本地版本库中 svn add main.c 将文件提交到服务器的版本库中 svn ci -m &quot;添加了main.c文件&quot; 删除文件 svn rm Person.h 提交删除 svn ci -m &quot;删除了文件&quot; 注意：不要使用文件管理器直接删除文件 撤销文件的修改 svn revert Person.m 恢复到之前的某个版本 svn update -r 5 svn up svn help (查看svn所有命令的帮助) checkoutsvn co http://192.168.1.188/svn/weibo --username=manager --password=manager checkout(co)之后，命令行会记录用户名和密码，后续操作不用再另行指定 基本命令行格式： svn &lt;subcommand&gt; [options] [args] 说明 svn 子命令 [选项] [参数] 提示： [中括号]中包含的内容是可选的 (子命令缩写) 状态查看svn日志 svn log 查看某一个文件的日志 svn log filename 查看某一个文件某个版本的日志 svn log filename@1 查看工作目录状态 svn st SVN st状态说明：描述文件被添加、删除或其他修改 &apos; &apos; 没有修改 &apos;A&apos; 被添加到本地代码仓库 &apos;C&apos; 冲突 &apos;D&apos; 被删除 &apos;I&apos; 被忽略 &apos;M&apos; 被修改 &apos;R&apos; 被替换 &apos;X&apos; 外部定义创建的版本目录 &apos;?&apos; 文件没有被添加到本地版本库内，不在SVN的管理之下 &apos;!&apos; 文件丢失或者不完整(不识别该文件) &apos;~&apos; 受控文件被其他文件阻隔 &apos;U&apos; 更新最新的代码到本地(本地有文件的情况下) &apos;G&apos; 产生冲突后，更新操作去解决冲突，相当于进行合并 目录Trunk目前项目正在开发的版本 Tags存放已经上线的重大版本 Branches当发生重大bug或者有新需求时 Linux文件 读权限（r）写权限（w) 可执行权限（x）。 第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。 文件类型+所有者+用户组+其他用户。 空格:下一屏 回车:一行 q:退出 /word:搜索word (以及tab的自动补全) 初步最基本(不阐述) cd clear pwd mkdir rmdir who whoami exit ping 查看 ls -a(所有) -l(列表) -h(显示大小) 重定向(结果重定向到一个文件，不存在创建，存在覆盖) ls &gt; a.txt 分屏 more 管道(一个命令的结果作为另一个命令的输入) ls -a | more 删除 rm Dir/ -r 递归地删除，删除文件夹必带 rm a.txt -f 强制删除，忽略不存在的文件，无需提示 rm b -i 交互式 链接软链接:软链接不占用磁盘空间，源文件删除则软链接失效。(快捷方式)硬链接:硬链接只能链接普通文件，不能链接目录。两个文件占用相同大小的硬盘空间，不常用。 ln 源文件 链接文件 (硬链接) ln -s 源文件 链接文件 查看或合并 cat q.txt cat 1.txt 2.txt &gt; 3.txt (重定向) 文本搜索可正则 grep -v(选项) &apos;app&apos;(匹配字符串) a.txt(文件名) -v 显示不包含匹配文本的所有行 -n 显示匹配行及行号 -i 忽略大小写 查找 find ./ -name a.txt find ./ -name &apos;*.txt&apos; find ./ -size +10M(大于10M) 拷贝 cp -a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。 -f 强制 -i 交互 -r 递归 -v 进度 移动(重命名) mv -f -v -i 归档与压缩 tar [参数] 打包文件名 文件 gzip [选项] 被压缩文件 切换用户 su 不切换目录 su - 切换目录 su root 到root su -root 到root，同时到/root目录 系统日历 cal 时间 date 网卡 ifconfig 进程 ps -a 所有 -u 详细状态 -x 显示没有控制终端的进程 -w 显示加宽 -r 正在运行 动态进程 top M 内存使用量 排序 P CPU占有率 排序 T 运行时间 排序 U 可以根据后面输入的用户名来筛选进程 K 可以根据后面输入的PID来杀死进程。kill pid q 退出 h 获得帮助 关机重启 reboot 重启 shutdown –r now 重新启动 shutdown -h now 立刻关机 shutdown -h 20:25 在今天的20:25会关机 shutdown -h +10 过十分钟后自动关机 init 0 关机 init 6 重启 磁盘空间 df -a 所有 -m 以1024字节为单位显示 -t 显示各指定文件系统的磁盘空间使用情况 -T 显示文件系统 目录所占磁盘空间 du -a 递归 -s 显示指定文件或目录占用的数据块 -b 以字节为单位显示磁盘占用情况 -l 计算所有文件大小，对硬链接文件计算多次 Vim初步i: 插入光标前一个字符 I: 插入行首 a: 插入光标后一个字符 A: 插入行未 o: 向下新开一行，插入行首 O: 向上新开一行，插入行首 ESC:从插入模式或末行模式进入命令模式 移动光标: h: 左移 j: 下移 k: 上移 l: 右移 M: 光标移动到中间行 L: 光标移动到屏幕最后一行行首 G: 移动到指定行，行号 -G w: 向后一次移动一个字 b: 向前一次移动一个字 {: 按段移动，上移 }: 按段移动，下移 Ctr-d: 向下翻半屏 Ctr-u: 向上翻半屏 Ctr-f: 向下翻一屏 Ctr-b: 向上翻一屏 gg: 光标移动文件开头 G: 光标移动到文件末尾 删除命令: x: 删除光标后一个字符，相当于 Del X: 删除光标前一个字符，相当于 Backspace dd: 删除光标所在行，n dd 删除指定的行数 D: 删除光标后本行所有内容，包含光标所在字符 d0: 删除光标前本行所有内容，不包含光标所在字符 dw: 删除光标开始位置的字，包含光标所在字符 撤销命令: u: 一步一步撤销 Ctr-r: 反撤销 重复命令: .: 重复上一次操作的命令 文本行移动: &gt;&gt;:文本行右移动 &lt;&lt;:文本行左移动 复制粘贴: yy: 复制当前行，n yy 复制 n 行 p: 在光标所在位置向下新开辟一行，粘贴 可视模式: v: 按字符移动，选中文本 V: 按行移动，选中文本可视模式可以配合 d， y， &gt;&gt;， &lt;&lt; 实现对文本块的删除，复制，左右移动 替换操作: r: 替换当前字符 R: 替换当前行光标后的字符 查找命令: /: str查找 n: 下一个 N：上一个 替换命令： 把abc全部替换成123 末行模式下，将光标所在行的abc替换成123 :%s/abc/123/g 末行模式下，将第一行至第10行之间的abc替换成123 :1， 10s/abc/123/g vim里执行 shell 下命令: 末行模式里输入!，后面跟命令 LLDB初步help 输出 p (int)self.view.subviews.count 基本类型 po self.view 对象类型 print self.view 更详细的打印 修改 expr a = 3 expr int $c = 10 声明一个新变量 调用 call self.view.backgroundColor = [UIColor redColor] 方法无返回值时使用call 堆栈 bt 加all可打印所有thread的堆栈 寻址 image lookup --address 0x0000000103aca1e1 寻找栈地址对应的代码位置 查看具体类型 image lookup --type NSURL 断点 breakpoint set -M &lt;method&gt; ( --method &lt;method&gt; ) -S &lt;selector&gt; ( --selector &lt;selector&gt; ) -b &lt;function-name&gt; ( --basename &lt;function-name&gt; ) -f &lt;filename&gt; ( --file &lt;filename&gt; ) -l &lt;linenum&gt; ( --line &lt;linenum&gt; ) -n &lt;function-name&gt; ( --name &lt;function-name&gt; ) Clang初步 编译单个c源文件，并产生一个目标文件 cc -c one.c 编译多个c源文件，并为每个文件产生一个目标文件 cc -c one.c two.c three.c 链接单个目标文件产生一个名为a.out的可执行文件 cc one.o 链接多个目标文件 cc one.o two.o three.o 编译并链接一个c源文件 cc one.c 编译并链接多个c源文件 cc one.c two.c three.c 编译一个c源文件，并把它和现存的目标文件链接在一起 cc one.o two.o three.c 可执行文件重命名加上“-o name”这个选项 cc -o abc one.c 执行可执行文件 ./a.out 编译C++文件 clang++ -Wall -g -std=c++11 -stdlib=libc++ fileName.cpp -o targetFileName]]></content>
      <tags>
        <tag>Git</tag>
        <tag>SVN</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3入门笔记]]></title>
    <url>%2F2016%2F12%2F20%2FPython3%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2017.1.11修改 人生苦短，我用Python。 钩玄 让Python打印出指定的文字，可以用print()函数，然后把希望打印的文字用单引号或者双引号括起来，但不能混用单引号和双引号。 在Python交互式命令行下，可以直接输入代码，然后执行，并立刻得到结果。用exit()退出交互模式。 直接输入Python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。 print()函数也可以接受多个字符串，用逗号,隔开，就可以连成一串输出，会依次打印每个字符串，遇到逗号,会输出一个空格。 Python提供了一个input(&quot;提示文本，可以为空&quot;)函数，可以让用户输入字符串，并存放到一个变量里。 以#开头的语句是注释，Python程序是大小写敏感的。 #!/usr/bin/env python3# -*- coding: utf-8 -*-# 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；# 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 当语句以冒号:结尾时，缩进的语句视为代码块。Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。 一个布尔值只有True、False两种值。布尔值可以用and、or和not运算。 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 在Python中，通常用全部大写的变量名表示常量，事实上仍然是一个变量，Python根本没有任何机制保证不会被改变。 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数（称为地板除，两个整数的除法仍然是整数）。 Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。 ASCII编码是1个字节，而Unicode编码通常是2个字节。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示x = b&#39;ABC&#39;。 bytes的每个字符都只占用一个字节，以Unicode表示的str通过encode()方法可以编码为指定的bytes，&#39;中文&#39;.encode(&#39;utf-8&#39;)，含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法。 计算str包含多少个字符，可以用len()函数，len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数，len(&#39;中文&#39;)。 字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%。 实练1.代码中有中文必须设置utf-8单行注释，以#开头。多行注释使用3个单引号。#coding=utf-8 2.导入模块import time #引入时间模块import randomimport calendar,osimport mathimport urllib.request # 爬取数据from math import sqrt # 指定math模块中的sqrt函数 当导入一个模块，Python解析器对模块位置的搜索顺序是： 1.当前目录。2.如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。3.如果都找不到，Python会查看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。4.模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。创建text.py文件，定义相关函数，import text 即可引用自己的模块。注意：倘若在text.py中定义并执行相关函数，其他文件引用之后，并不会执行。函数代码，应该是单独执行text.py文件时才会执行。 from math import * 3.区分文件是主动执行的，还是被调用执行的。根据__name__变量的结果能够判断出，是直接执行的Python脚本还是被引入执行的，从而能够有选择性的执行测试代码。如果当前文件是主动执行的，__name__ 变量的值就是：__main__，如果是被导入执行的，则是被导入的文件名。 if __name__ == "__main__": print("是直接执行的py脚本, 而非引入") 4.使用print函数进行字符串格式化格式有：%c、%s、%i、%d、%u（无符号十进制整数）、%o、%x（十六进制小写）、%X（十六进制大写 ）、%f等。 print("hello world")a = 12b = 58c = "swe"print("hello %s 这孩子 %s 啊啊啊 %s"%(a,b,c))print("sss",a) 5.输入inputs = input("请输入数字")print("您的数字是:%s"%inputs)if inputs == 12: print("哈哈哈哈") print("嘻嘻嘻嘻")if inputs != 12: print("哦哦哦哦") 5.数据类型在python中，只要定义了一个变量，而且它有数据，那么它的类型就已经确定了。可以使用type(变量的名字)来查看变量的类型，比如：type(a)。 常用的数据类型: Numbers(包括int long float complex) 布尔 True/False String List Tuple(元组) Dictionary… 6.标识符标识符由字符数字下划线组成，没有美元符号，且区分大小写。命名规则：驼峰式或者下划线连接。 7.运算符 % 取余，比如 3%2。 ** 幂，比如3**2表示3的2次方。 // 取整除。 / 正常除法，可有余数。 8.逻辑运算 and or not 与if inputs == 15 and a == 12: print("and") 或if inputs == 15 or b == 58: print("or") 非if not a == 12: print("not") 9.多重判断 if 与 elifscore = 99if score &lt; 60: print("不及格")elif score &lt;80: print("良好")elif score &lt; 90: print("不错")else: print("优秀") 10.if嵌套a = 14if a &gt; 12 and a &lt; 18: if a &gt; 12: print("a&gt;12") else: print("a&lt;18")else: print("a&lt;=12, a&gt;=18") 11.while循环与循环嵌套while a == 12: print("你不好") a = 13while b == 58: print("哈哈哈哈") b = 59 12.for循环:i从0开始,每次自增1for i in range(12): if i == 5: continue#跳过i==5这次 print('i=%s'%i) if i == 10: print("停止break") break 13.定义函数 print1def print1(): print("函数")#调用函数print1print1() 14.常用函数#时间函数import timet = time.time()#取出当前时间,以秒为单位的浮点小数t2 = time.localtime(t)#取出本地时间t3 = time.asctime(t2) #标准格式Fri Jun 10 10:58:53 2016print(t3)#日历函数 import calendarcal = calendar.month(2016,8)print(cal) #打印日历#随机数函数 import randomr = random.randint(1,3)#从1到3范围内的整数,包括1和3print(r)r2 = random.randrange(1,25,5)#从1开始到25结束递增基数为5print(r2)r3 = random.uniform(1,5) #最小值1最大值5,返回浮点数print(r3)random.random() #生成0&lt;=n&lt;=1的浮点数 15.字符串#相当于字符数组,可以通过下标取出字符,ss = "qwertyu"print(ss[1])#取出下标从1到3 的字符,包括上边界,不包括下边界print(ss[1:3])#从下标2开始 取到最后print(ss[2:])#从下标2开始到下标-2,不包括下标-2print(ss[2:-2])#取出最后4个字符print(ss[-4:]) 16.字符串常见操作sub = "my"s = "itismyapple"#查找:检测sub是否在s中:s.find(sub, start=0, end=len(mystr))#查找成功返回开始的索引,否则返回-1s.find(sub)re = s.find(sub,1,8)#从下标1开始查找,到下标为8结束print(re)s.index(sub)#与find相同,只不过没有找到会抛出异常#返回 在start和end之间(包括) 在 s里面出现的次数c = s.count("i", 0,8)print(c)#把 s 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次.s.replace("t","d",2)#以 " " 为分隔符切片 s，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串s.split(" ",5)#把字符串的第一个字符大写s.capitalize()#检查字符串是否是以 obj 开头, 是则返回 True，否则返回 Falses.startswith("i")#检查字符串是否以obj结束，如果是返回True,否则返回 False.s.endswith("d")#转换 s 中所有大写字符为小写s.lower()#转换 s 中的小写字母为大写s.upper()#返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串s.ljust(5) #返回 "itismyapple "#返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串s.rjust(5) #返回" itismyapple"#返回一个原字符串居中,并使用空格填充至长度 width 的新字符串"s".center(10) #" s "#删除 s 左边的空格s.lstrip()#删除 s 字符串末尾的空格s.rstrip()#类似于 find()函数，不过是从右边开始查找."sieiess".rfind("ie") #返回3# 类似于 index()，不过是从右边开始.s.rindex("s")#把"asdeeeads"以str分割成三部分,str前，str和str后"asdeeeads".partition("eee")#类似于 partition()函数,不过是从右边开始."asdeeeads".rpartition("eee")#按照行分隔，返回一个包含各行作为元素的列表"asas\nds".splitlines()#如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False"ssd".isalnum()#如果 mystr 所有字符都是字母 则返回 True,否则返回 False"ssd".isalpha()#如果 mystr 只包含数字则返回 True 否则返回 False."232".isdigit()#如果 mystr 中只包含空格，则返回 True，否则返回 False." ".isspace()#如果 mystr 所有字符都是大写，则返回 True，否则返回 False"sd".isupper()#mystr 中每个字符后面插入str,构造出一个新的字符串"sasd".join("s") 17.列表A = ["ds3s","ds4s","a4sd"]print(A[0])for a in A: print(a)#打印每一个元素# 列表增加元素A.append("asasdad")for a in A: print(a)#打印每一个元素# 修改A[0] = "1"# 查找if "1" in A: print("1存在于a中")if "1" not in A: print("1不存在与a中")# 删除元素#del：根据下标进行删除#pop：删除最后一个元素#remove：根据元素的值进行删除del A[0]A.pop()A.remove("ds4s")for a in A: print(a)#打印每一个元素 18.统计字符个数cstr = input("请输入字符")for c in cstr: print("%c:%d"%(c,cstr.count(c))) 19.字典info = &#123;"name":"zhangsan","age":12&#125;print(info["name"])#增加键值对info["sex"] = "man"#删除元素del info["age"]#清空字典info.clear()#删除整个字典del info#注意删除字典和清空字典的区别#字典常用操作info2 = &#123;"name":"zhangsan","age":12&#125;#测量字典中，键值对的个数len(info2)#返回一个包含字典所有KEY的列表info2.keys()#返回一个包含字典所有value的列表info2.values()#返回一个包含所有（键，值）元组的列表info2.items()#if "name" in info2如果key在字典中，返回True，否则返回Falseif "name" in info2: print("存在")#遍历键/值/键值对for key,value in info2.items(): print(key,value) 20.元组Python的元组与列表类似，不同之处在于元组的元素不能修改。也可进行分片和连接操作。元组使用小括号，列表使用方括号。 atuple = ("as",121,True,False,0)atuple2 = ("a",121,True,False,40)print(atuple[1])#合成新元组atuple3 = atuple + atuple2#删除元素#元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组del atuple3 21.元组运算符与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。(1, 2, 3) + (4, 5, 6)['Hi!'] * 4 #['Hi!', 'Hi!', 'Hi!', 'Hi!']3 in (1, 2, 3) #True 22.元组索引截取因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素比较两个元组元素。#cmp(tuple1, tuple2)tuple2 = (12,234,546,56)tuple2s = [12,23]#计算元组元素个数。len(tuple2)#返回元组中元素最大值。max(tuple2)#返回元组中元素最小值。min(tuple2)#将列表转换为元组。tuple(tuple2s) 23.多维元组tuple3 = [(2,4,5,4),(2,5,6)]tuple3[1] #(2,5,6)tuple3[1][0] #2 24.函数带有参数和有返回值的函数def sum(a,b): return a+bprint(sum(45,1)) 缺省函数def sum2(a,b = 25): return a+bprint(sum2(232))print(sum2(232,1)) 不定长参数加了星号（*）的变量名会存放所有未命名的变量参数。参数以一个*号开头的代表着一个任意长度的元组(tuple)，可以接收连续一串参数。def printinfo(a,b,*cs): print(a,b) for c in cs: print(c)printinfo(23,3,34,4,6,2) 函数的嵌套使用def print3(a,b): print(a,b) print(sum(a,b))print3(2,23) 打印指定条横线def printline(): print("-"*20)def printlinewithnum(a): for i in range(a): printline() print("\n")printlinewithnum(5) 25.变量局部变量，是在函数内部定义的变量。全局变量，能在某一函数中使用，也能在其他函数中使用。全局变量能够在所有的函数中进行访问。如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错。 gol = 12def chnum(): global gol #声明此处的gol是特指全局变量,而非重名的局部变量 gol = 13 print(gol)chnum()print(gol) 26.递归函数示例:计算n的阶乘def calnum(n): i = 1 result = 1 while i &lt;= n: result *= i i += 1 return resultprint(calnum(1))print(calnum(0))def calnum2(n): if n &gt;= 1: return n * calnum2(n-1) else: return 1print(calnum2(1))print(calnum2(0)) 27.匿名函数用lambda关键词能创建小型匿名函数。Lambda函数能接收任何数量的参数但只能返回一个表达式的值。匿名函数不能直接调用print，因为lambda需要一个表达式。sum4 = lambda a,b,c,d:a + b + c + dprint(sum4(1,3,4,6)) 28.位运算:直接操作二进制数&amp; 按位与 只有对应的两个二进位均为1时,结果位才为1| 按位或 只要对应的二个二进位有一个为1时,结果位就为1,否则为0^ 按位异或 不同为1 当对应的二进位相异(不相同)时,结果为1,否则为0~ 按位取反&lt;&lt; 按位左移:左移一位即乘以2,可能改变一个数的正负&gt;&gt; 按位右移::右移一位即除以20b1011 &amp; 0b10010101100b1000110 | 0b100100b11101 ^ 0b110000011~132print(12&lt;&lt;3)print(1024&gt;&gt;4) 进制书写0o377 #八进制0xFF #十六进制0b010010110 #二进制 进制转换print(type(oct(25))) #转八进制字符串hex(25) #转十六进制字符串bin(25) #转二进制字符串 29.数据类型转换int("123") #字符串转数值float("2324.3") #将字符串转换为浮点数print(complex(1.2,3.2)) #创建一个复数,在 Python 中，复数的虚部被表示为 jprint(3.2+1.4j)print(str(23)) #将23转换为字符串print(repr(124)) #转换为表达式字符串tuple([23,3])list((23,234))chr(2)ord("d") 实现乘法表def print6(): i = 1 while i &lt;= 9: j = i while j &lt;= 9: print("%d*%d=%d"%(i,j,i*j)) j += 1 i += 1print6() 30.打开文件使用open函数，可以打开一个已经存在的文件，或者创建一个新文件。open(文件名，访问模式) 返回文件句柄。 f = open("s.txt","w")f.close()#关闭文件 符号 释义 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。 写数据到文件f = open("s1","w")f.write("hello world")f.close() 读数据f = open("s1")content = f.read(5) #读取数据长度,字节为单位print(content)f.close() readlines按照行的方式把整个文件中的内容进行一次性读取，返回的是一个列表，每一行的数据为一个元素。f = open("s")content2 = f.readlines()print(content2[2])f.close() 获取当前读写的位置f = open("222.txt", "r+")f.write("123243454566")str12 = f.read(3)print("读取的数据是 : ",str12) 查找当前位置position = f.tell()print("当前文件位置 : ", position)f.close() 如果在读写文件的过程中，需要从另外一个位置进行操作的话，可以使用seek()，seek(offset, from)有2个参数： offset:偏移量 from:方向 0:表示文件开头 1:表示当前位置 2:表示文件末尾 f = open("s", "r")str33 = f.read(30)print("读取的数据是 : ", str33)# 查找当前位置position = f.tell()print("当前文件位置 : ", position)# 重新设置位置f.seek(5,0)f.close() 31.文件操作文件重命名需要import os，os模块中的rename()可以完成对文件的重命名操作。os.rename(&quot;s1&quot;,&quot;s111&quot;) 删除文件os.remove(&quot;s111&quot;) 创建文件夹os.mkdir(&quot;haha&quot;) 获取当前目录print(os.getcwd()) 改变默认目录os.chdir(&quot;../&quot;) 获取目录中内容列表,返回数组os.listdir(&quot;./&quot;) 删除文件夹os.rmdir(&quot;haha&quot;) 判断是否是目录os.path.isdir(&quot;./react&quot;) 判断是否是文件os.path.isfile(&quot;./s&quot;) 32.捕获异常try: open("ssss","r")#指定异常类型 定义异常变量except IOError as errmsg: print("捕获到异常",errmsg) print("-"*10)#多个异常try: open("ssss","r")#指定异常类型 定义异常变量except (IOError,NameError) as errmsg: print("捕获到异常",errmsg) print("-"*10)#不指定异常try: open("ssss","r")#指定异常类型 定义异常变量except : print("捕获到异常") print("-"*10) 常见异常： 名称 解释 Exception 所有异常的基类 AttributeError 特性应用或赋值失败时引发 IOError 试图打开不存在的文件时引发 IndexError 在使用序列中不存在的索引时引发 KeyError 在使用映射不存在的键时引发 NameError 在找不到名字（变量）时引发 SyntaxError 在代码为错误形式时引发 TypeError 在内建操作或者函数应用于错误类型的对象是引发 SyntaxError 在内建操作或者函数应用于正确类型的对象，但是该对象使用不合适的值时引发 ZeroDivisionError 在除法或者模除操作的第二个参数为0时引发 finally语句try: open("ssss","r") 指定异常类型 定义异常变量except : print("捕获到异常") print("-"*10)finally: print("一定执行的语句") else应用try: num = 100 print(num)except NameError as errorMsg: print('产生错误了:%s'%errorMsg)else: print('没有捕获到异常，真高兴')finally: print('我一定会执行的哦') 33.类class Person: #属性列表 #公有属性 name = "AB" #私有属性,私有属性是不能够在类外通过对象名来进行访问的 __age = 20 #在类中定义的方法至少会有一个参数，，一般以名为self的变量作为该参数，而且需要作为第一个参数。 #公有方法列表 def getName(self): print(self.name) #私有方法 def __getAge(self): print(self.__age) #def get():报错 #print("无参数方法") #构造器方法:在创建对象后执行 #def __init__(): #self.name = "QWE" #传递参数的构造器方法 def __init__(self,name): self.name = name #析构方法 def __del__(self): print("析构方法被调用")#创建对象p = Person("zhangsan")print(p.name)p.getName() 34.继承class Student(Person): def setName(self,name): self.name = name def print(self): print("学生的姓名是",self.name)stu = Student("zhangsan")stu.setName("李四")stu.print() python中是可以多继承的。父类中的方法、属性，子类会继承。多继承:class HighStudent(Student,Worker)假设A,B中都有方法test()若C继承A与B，class C(A,B)，则调用A中的方法。若C继承A与B，class C(B,A)，则调用B中的方法。若C继承A与B，class C(A,B)，且C中也有test()方法，则调用C中重写的方法。 35.重写class Ani: def print(self): print("调用Ani的方法")class Dog(Ani): def print(self): print("调用Dog的方法") dog = Dog()dog.print() #调用自己的方法 36.多态class A: passclass A1(A): def show(self): print("A1")class A2(A): def show(self): print("A2")a1 = A1()a2 = A2()def showFunc(a): a.show() showFunc(a1)showFunc(a2) 37.类属性类属性就是类对象所拥有的属性，它被所有类对象的实例对象所共有，内存中只存在一个副本，对于公有的类属性，在类外可以通过类对象和实例对象访问。 class object: name = "object"obj1 = object()obj2 = object()print(obj1.name) #实例没有name,会查找类的name,结果:objectobject.name = "lisi"print(obj2.name) #显示 lisiprint(obj1.name) #显示 lisi 给实例obj1增加实例属性obj1.name = "ads"print(obj1.name) #屏蔽掉类属性,显示adsprint(object.name) #显示 lisi 结论:相同名称的实例属性将屏蔽掉类属性。但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。Python是动态语言，可以动态增加属性。想要修改类属性，如果在类外，可以通过类对象修改，如果在类里面，只有在类方法中进行修改。 38.类方法是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数。当然可以用其他名称的变量作为其第一个参数。但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了，能够通过实例对象和类对象去访问。class people: country = 'china' #类方法，用classmethod来进行修饰 @classmethod def getCountry(cls): return cls.countryclass Car: #类属性 price = "1000" #类方法 @classmethod def getPrice(cls,price): cls.price = price return cls.pricecar1 = Car()print(car1.getPrice(200)) 39.静态方法通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数。class Cat: name = "Tom" @staticmethod #静态方法 def getName(): print(Cat.name)Cat.getName() 40.爬取数据response = urllib.request.urlopen("http://acm.hit.edu.cn")html = response.read()#中文转码htmlC = html.decode("utf-8")print(htmlC)#将网页存入文本f = open("t.html","wb")#python是types格式，得用二进制读写. f.write(html) #写入原始文件,不需要解码f.close() get参数拼接query = &#123;&#125;query["key"] = "python3"queryURL = urllib.parse.urlencode(query) #得到key=python3url = "http://chenyalun.com/s?" + queryURLprint(url) 40.使用BeautifulSouphtml = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and &lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;; and they lived at the bottom of a well.&lt;/p&gt; &lt;p class="story"&gt;...&lt;/p&gt; """from bs4 import BeautifulSoupsoup = BeautifulSoup(html)print(soup.prettify())#打印标签print("标题是:",soup.title)print("头部是",soup.head)print("第一个a标签",soup.a)print("第一个p标签",soup.p)#它查找的是在所有内容中的第一个符合要求的标签#标签的两个重要的属性:name 和 attrsprint(soup.a.name)print(soup.p.attrs)#属性的值print("属性的值",soup.p.attrs["name"]) print("属性的值",soup.p["name"])#attrs可以省略#用 .string获取文字print(soup.p.string)#利用"CSS选择器"查找标签#通过标签名查找print(soup.select("title"))#通过类名查找print(soup.select(".sister"))#通过id查找print(soup.select("#link1"))#组合查找print(soup.select("p #link1")) #格式同CSS#直接子标签查找print(soup.select("head &gt; title"))#属性查找#属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格print(soup.select('a[class="sister"]'))print(soup.select('a[href="http://example.com/elsie"]'))print(soup.select('p a[href="http://example.com/elsie"]'))# select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容for title in soup.select("title"): print(title.get_text)]]></content>
      <tags>
        <tag>Python</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛读博客笔记]]></title>
    <url>%2F2016%2F10%2F28%2F%E6%B3%9B%E8%AF%BB%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2017.04.03 修改2016.12.04 修改2019.08.15 完善 C语言和Objective-C语言。 读感一口气把前辈博客里面的所有文章都读完了，文章质量都特别高，在此做个记录。 钩玄1.C语言中怎么控制输入与输出格式printf("My height is %8.1f", 179.95f);// 左对齐,小数点后1位 printf("My height is %-4d", 60); // 左对齐，右边填空格scanf("%d-%d-%d", &amp;a, &amp;b, &amp;c);scanf("%d %d %d", &amp;a, &amp;b, &amp;c); // putchar一次只能输出一个字符，而printf可以同时输出多个字符int a = 65;putchar(a); 2.getchar/scanf/gets的区别 gets和getchar函数可以读入空格、TAB，直到遇到回车为止。scanf不能读入空格和TAB。 gets一次只能读取一个字符串，getchar一次只能读入一个字符。scanf则可以同时接收多个字符。 getchar还能读入回车换行符，这时候要敲2次回车键。第1次敲的回车换行符被getchar读入，第2次敲的回车键代表输入结束。 3.puts/prints/putchar的区别 putchar一次只能输出一个字符，puts函数一次只能输出一个字符串，printf函数则可以同时输出多个字符串。 printf与puts函数会首地址开始输出字符，一直到\0字符为止。 4.介绍指针 计算机中的内存是以字节为单位的存储空间，内存的每一个字节都有一个唯一的编号，这个编号就称为地址。 凡存放在内存中的程序和数据都有一个地址，也就是说，一个函数也有自己的内存地址。变量存储单元的第一个字节的地址就是该变量的地址。 通过变量名引用变量，由系统自动完成变量名和其存储地址之间的转换，称为变量的“直接引用”方式。首先将变量a的地址存放在另一个变量中，比如存放在变量b中，然后通过变量b来间接引用变量a，间接读写变量a的值。这就是“间接引用”。 在指针变量没有指向确定地址之前，不要对它所指的内容赋值。 int *p; *p = 10; //这是错误的 // 正确做法int a = 10; // 也可以int *b = &amp;a;int *b; //b是指针变量b = &amp;a; // 通过*b间接修改a的值*b = 15; // 根据b地址访问对应的存储值 指针操作中，数组名a是个常量，不能进行赋值运算 char s[10];s = "mj";// 错误! s是常量 5.常见字符串处理函数的用法包含string.h头文件后，strlen\strcpy\strcat\strcmp函数的用法// 测量字符串的字符个数，不包括\0// 长度为7int size = strlen("abcdefg");// 长度为2char s[] = &#123;'a', 'b', '\0','c'&#125;; // 右边拷贝到左边,char s[10];strcpy(s, "abcdefg");// 遇到\0截断char c[] = &#123;'a', 'b', '\0','c'&#125;;strcpy(s,c);// 结果ab// 右边拼接到左边,遇到\0截断char s1[30] = &#123;'a', 'b', '\0', 'd'&#125;;strcat(s1, "OC");// 结果abOC // 左减右,逐字符比较ASCII码差值,直到字符不相同或者遇见'\0'为止strcmp(s1, s2); 注意:strcpy中若数组长度不足以容纳整个字符串，则程序运行崩溃。 6.如何使一个函数有多个返回值int test(int a, int b,int *c) &#123; // 赋值给指针指向的变量 *c = a + b; return a * b;&#125; int main(int argc, const char * argv[]) &#123; int m = 2,n = 4,s1,s2; s1 = test(m, n, &amp;s2); printf("%d---%d",s1,s2); return 0;&#125; 7.字符串常量与字符串变量char *s = "mj";*s = "like"; 两个错误: s指向的是“mj”的首字符“m”，只有一个字节，要“like”存进1个字节的空间内，肯定内存溢出。 s指向的是字符串常量“mj”，不能再通过指针来修改字符串内容(字符数组可以修改)。 char a[] = "lmj"; // 定义的是一个字符串变量char *p2 = "lmj"; // 定义的是一个字符串常量 8.返回指针的函数// 将字符串str中的小写字母变成大写字母，并返回改变后的字符串// 注意的是：这里的参数要传字符串变量，不能传字符串常量char * upper(char *str) &#123; // 先保留最初的地址。因为等会str指向的位置会变来变去的。 char *dest = str; // 如果还不是空字符 while (*str != '\0') &#123; // 如果是小写字母 if (*str &gt;= 'a' &amp;&amp; *str &lt;= 'z') &#123; // 变为大写字母。小写和大写字母的ASCII值有个固定的差值 *str -= 'a' - 'A'; &#125; // 遍历下一个字符 str++; &#125; // 返回字符串 return dest;&#125; // 调用:int main() &#123; // 定义一个字符串变量 char str[] = "lmj"; // 调用函数 char *dest = upper(str); printf("%s", dest); return 0;&#125; 9.指向函数的指针函数名的本质就是函数的地址。假定函数的名称为func，返回类型是整型。则，int *a = func; // 指针a与指针func一致 调用的三种方式:func(); // 原先的调用方式:通过指针func调用*a(); // *a指向函数本身a(); // 相当于func(); 实例: int sum(int a, int b) &#123; return a + b;&#125; int main()&#123;// 定义一个指针变量p，指向sum函数// 把函数名替换为(*p)即可,*p就相当于sumint (*p)(int a, int b) = sum; // 或者 int (*p)(int, int) = sum; // 或者 int (*p)() = sum; // *p就相当于sum int result = (*p)(1, 3); // 或者 int result = p(1, 3); printf("%d", result); return 0;&#125; 10.将函数作为参数在函数间传递// 减法运算int minus(int a, int b) &#123; return a - b;&#125; // 加法运算int sum(int a, int b) &#123; return a + b;&#125; // 这个counting函数是用来做a和b之间的计算，至于做加法还是减法运算，由函数的第1个参数决定void counting(int (*p)(int, int) , int a, int b) &#123; int result = p(a, b); printf("计算结果为：%d\n", result);&#125; int main()&#123; // 进行加法运算,传进来函数指针sum counting(sum, 6, 4); // 进行减法运算 counting(minus, 6, 4); return 0;&#125; 11.宏的使用 所有预处理指令都以符号“#”开头，并且结尾不用分号，作用范围是从它出现的位置到文件尾，主要有：宏定义、文件包含、条件编译等。 使用带参数的宏定义，最好将参数和结果都用括号括起来。 宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题，宏替换只在编译预处理阶段进行，带参数的宏比函数具有更高的执行效率。 条件编译 #if 条件1...code1...#elif 条件2...code2...#else...code3...#endif#if defined(MAX) ...code...#endif #if !defined(MAX) ...code...#endif 12.include中&lt;&gt;与“”的区别#include &lt;文件名&gt;到C语言库函数头文件所在的目录中寻找文件。#include &quot;文件名&quot;系统会先在源程序当前目录下寻找，若找不到，再到操作系统的path路径中查找，最后才到C语言库函数头文件所在目录中查找。 13.如何避免#include重复包含同一个头文件使用条件编译#ifndef _ONE_H_#define _ONE_H_ void one(); #endif 14.变量的作用域 在函数内部定义的变量，称为局部变量。形式参数也属于局部变量，在所有函数外部定义的变量，称为全局变量。 所有的局部变量在默认情况下都是自动变量，是存储在堆栈中的。所有的全局变量和被关键字static修饰的局部变量都是静态变量，是存储在静态内存中的，也就是不属于堆栈。 静态变量在程序运行之前创建，在程序的整个运行期间始终存在，直到程序结束。在程序执行到声明自动变量的代码块(函数)时，自动变量才被创建；当自动变量所在的代码块(函数)执行完毕后，这些自动变量就会自行销毁。 被关键字register修饰的自动变量都是寄存器变量，是存储在硬件寄存器中的，其生命周期即是自动变量的生命周期。寄存器变量只限于int、char和指针类型变量使用，将一些频繁使用的自动变量定义为寄存器变量，这样程序尽可能地为它分配寄存器存放，而不用内存。 register int a;register char b;register int *c; 15.编译链接流程 如果一个程序中有多个源文件(.c)，编译成功会生成对应的多个目标文件(.obj)，这些目标文件不能单独运行，因为这些目标文件之间可能会有关联。将这些相关联的目标文件链接在一起后才能生成可执行文件。 所谓编译，就是单独检查每个源文件的语法是否合理，并不会检查每个源文件之间的关联关系，一个源文件编译成功就生成一个目标文件。所谓链接，就是检查目标文件的关联关系，将相关联的目标文件组合在一起，生成可执行文件。 根据在当前文件中定义的函数是否允许其他文件访问，可将函数分为内部函数和外部函数。默认情况下，所有的函数都是外部函数。不允许重复定义同一个外部函数。 16.extern与static关键字的作用使用extern关键字，表示引用其他文件的“外部函数”: extern void test();，然而extern可以省略，故直接声明即可。正规的项目里面，把“外部函数”的声明另写到一个头文件中，使用时直接包含头文件即可。 在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，不允许其他文件访问。不同的文件中有同名的内部函数，则互不干扰。 默认情况下，一个函数不可以访问在它后面定义的全局变量。不同源文件中的同名全局变量代表着同一个变量。 // a文件int ss =10; // b文件extern int ss ;printf("%d", ss);// 是10 在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰。 17.如何定义结构体定义结构体的三种形式(枚举变量的定义与之类似) struct Student &#123; char *name; int age;&#125;;// 利用上面结构体定义结构体变量stustruct Student stu; // 直接定义结构体变量stustruct Student &#123; char *name; int age;&#125; stu; // 定义结构体变量stu后,此结构体永不再用struct &#123; char *name; int age;&#125; stu; // 特殊:struct前放置typedef表示声明此"匿名"结构体的名字为Studenttypedef struct &#123; char *name; int age;&#125; Student; 注意: 定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间。 将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。 18.结构体指针的使用结构体指针变量的定义形式：struct 结构体名称 *指针变量名，三种访问方式: 结构体变量名.成员名(*指针变量名).成员名指针变量名-&gt;成员名 19.typedef的主要使用 typedef给指针起别名 // 相当于char *str = "This is a string!";String str = "This is a string!"; typedef给结构体起别名 struct CGRect &#123; CGPoint origin; CGSize size;&#125;;typedef struct CGRect CGRect;// 为 struct CGRect 起别名叫作 CGRect typedef给指向结构体的指针起别名 #include &lt;stdio.h&gt; // 定义一个结构体并起别名typedef struct &#123; float x; float y;&#125; Point; // 给Point *起别名PPtypedef Point *PP; int main(int argc, const char * argv[]) &#123; // 定义结构体变量 Point point = &#123;10, 20&#125;; // 定义指针变量Point *p = &amp;point; PP p = &amp;point; // 利用指针变量访问结构体成员 printf("x=%f，y=%f", p-&gt;x, p-&gt;y); return 0;&#125; typedef与枚举类型 // 定义枚举类型enum Season &#123;spring, summer, autumn, winter&#125;;// 给枚举类型enum Season起别名为Seasontypedef enum Season Season; int main(int argc, const char * argv[]) &#123; // 定义枚举变量 Season s = spring; return 0;&#125; typedef给指向函数的指针类型起别名 #include &lt;stdio.h&gt;// 定义一个sum函数，计算a跟b的和int sum(int a, int b) &#123; int c = a + b; printf("%d + %d = %d", a, b, c); return c;&#125;typedef int (*MySum)(int, int);int main(int argc, const char * argv[]) &#123; // 定义一个指向sum函数的指针变量p MySum p = sum; // 利用指针变量p调用sum函数 (*p)(4, 5); return 0; &#125; typedef与#define，给类型起别名，最好使用typedef，而不是使用#define typedef char *String1;#define String2 char * // 相当于char *str1;char *str2;String1 str1, str2;// 相当于char *str3;char str4;产生误会String2 str3, str4; 20.import与include的区别 #import是一个预处理指令，作用跟C语言的#include类似，都是 包含(拷贝)某个文件的内容 到 预处理指令所在的位置。在Objective-C中，使用#import来包含头文件，可以自动防止同一个头文件被包含多次。#import &lt;...&gt;表示包含系统自带的文件，#import &quot;...&quot;表示包含开发人员自己创建的文件。 21.UIView显示的过程UIView之所以能显示在屏幕上，完全是因为它内部的一个层(CALayer对象)。当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了UIView的显示。当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法。 22.position与anchorPointposition可以用来设置CALayer在父层中的位置，它是以父层的左上角为坐标原点(0, 0);anchorPoint称为“定位点”，它决定着CALayer身上的哪个点会在position属性所指的位置。它的x、y取值范围都是0~1，默认值为(0.5, 0.5)。 23.Core Animation会阻塞主线程吗Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程，而且是直接作用在CALayer上的，并非UIView。 24.空指针没有存储任何内存地址的指针就称为空指针(NULL指针，指向nil)，空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。可以给空指针发送消息，但消息发送不出去。“野指针”不是NULL指针，是指向“垃圾”内存（不可用内存）的指针。 25.不同编译器下各类型所占字节 26.self与superself 是方法的隐藏的参数，指向当前调用方法的对象，另一个隐藏参数是 _cmd，代表当前方法的 selector。super 只是一个“编译器指示符”(编译器特性)，它和 self 指向的是相同的消息接收者。不同的是，super 告诉编译器，要先去调用父类的方法，而不是本类里的。当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则先从父类的方法列表中开始找，然后调用父类的这个方法。 27.消息发送id objc_msgSend(id theReceiver, SEL theSelector, ...) 以[self setName:] 为例，编译器会替换成调用objc_msgSend 的函数调用，其中 theReceiver 是 self，theSelector 是 @selector(setName:)，这个 selector 是从当前 self 的 class 的方法列表开始找的 setName，当找到后把对应的 selector 传递过去。id objc_msgSendSuper(struct objc_super *super, SEL op, ...)struct objc_super &#123; id receiver; Class superClass;&#125;; 而当使用[super setName] 调用时，会使用 objc_msgSendSuper 函数，结构体包含了两个成员，一个是 receiver，这个类似objc_msgSend 的第一个参数 receiver，第二个成员是记录所谓的“父类”。从 objc_super 结构体指向的 superClass 的方法列表开始找 setName 的 selector，找到后再以 objc_super-&gt;receiver 去调用这个 selector。 28.通知NSNotification使用的是同步操作，如果想让NSNotification的post处和observer处异步执行，可以通过NSNotificationQueue实现。对于同一个通知，如果注册了多个观察者，则这多个观察者的执行顺序和他们的注册顺序是保持一致的。observer的回调方法执行线程和post的线程保持一致，如果想让post的线程和转发的线程不同，可以通过NSNotification重定向技术实现。addObserver和removeObserver必须成对出现，或者说添加了Observer必须适时移除Observer。因为通知中心并不retain Observer，若不移除，会极易造成给释放的对象发送消息，出现坏内存访问。 29.屏幕普屏中1点 = 1像素，Retina屏：1点 = 2像素。人手指的最小点击范围是44pixels，所以在iPhone的很多细节上都是44 pixels。使用图片资源时，方法：[UIImage imageNamed:@&quot;adflower.png&quot;]]，在实际运行时，如果发现当前的设备是Retina屏，会自动寻找图片名为adflower@ 2x.png的图片。 [UIScreen mainScreen].applicationFrame获取app尺寸(去掉状态栏)，[UIScreen mainScreen].bounds获取屏幕尺寸，[[UIApplicationsharedApplication] statusBarFrame]获取状态栏尺寸。 30.程序启动在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个“描述其定义的对象”，也就是类对象(class object)，它是一个单例(singleton)，这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。任何直接或间接继承了NSObject的类，它的实例对象(instance objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个 实例对象(instace object) 所属的类的定义的一切：包括变量、方法、遵守的协议等等。 类对象并不是类的实例本身。它没有自己的实例变量，也不能执行类的实例的方法。类对象是一个功能完整的对象，也能被动态识别（dynamically typed），接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量），只是在运行时产生实例的代理。类对象是元类对象的一个实例，元类是根元类(root class’s metaclass)的实例，而根元类是其自身的实例，即根元类的isa指针指向自身。 一个消息发送给任何一个对象， 方法的检查 从对象的 isa 指针开始，然后是父类。实例方法在类中定义， 类方法 在元类和根类中定义。（根类的元类就是根类自己）。类对象(class object)中包含了类的实例变量、实例方法的定义，而元类对象(metaclass object)中包括了类的类方法的定义。类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。 ①object_getClass跟随实例的isa指针，返回此实例所属的类，对于实例对象(instance)返回的是类(class)，对于类(class)则返回的是元类(metaclass)。②- class方法对于实例对象(instance)会返回类(class)，但对于类(class)则不会返回元类(metaclass)，而只会返回类本身。③class_isMetaClass可判断某类是否为元类。④使用objc_allocateClassPair可在运行时创建新的类与元类对，使用class_addMethod和class_addIvar可向类中增加方法和实例变量，最后使用objc_registerClassPair注册后，就可以使用此类了。 31.alloc方法通过alloc或allocWithZone方法创建对象时， cocoa会遍历该对象所有的成员变量，通过成员变量的类型来计算所需占用的内存返回一个未“初使化”过的对象。 将该新对象的引用计数(Retain Count)设置成1。 该新对象的isa成员变量指向它的类对象。 将该新对象的所有其它成员变量的值设置成零。（根据成员变量类型的不同，零有可能是指nil或0） 返回指向该对象的一个指针。 32.init方法大部分情况下，我们都不希望所有成员变量都是零，所以①init方法做初使化工作，让对象的成员变量的值符合我们程序逻辑中的初始化状态。②返回真正可以使用的指向该对象的指针某些情况下，init会造成alloc的原本空间不够用，而进行第二次分配内存空间。所以下面的写法是错的：NSString *s = [NSString alloc];[s init];// 这儿init返回的地址可能会变。s原本的指针地址可能是无效的地址。 正确的写法是NSString *s = [[NSString alloc] init];new简单地等价于 alloc + init，但不能指定init的参数，很少用。NSInteger是一个有符号型int，它与int的区别就在于NSInteger可以自动识别机器是32位还是64位。NSInteger的无符号版本是NSUInteger。 33.运行时消息只有到运行时才会和函数实现绑定起来，而不是按照编译好的逻辑一成不变的执行。编译阶段只是确定了要去向receiver对象发送message消息，但是却没有发送，真正发送是等到运行的时候进行。NSObject 类定义了description方法，返回该类内容的字符串表示。某些 NSObject 的方法只是简单地从运行时系统中获得信息，从而允许对象进行一定程度的自我检查。 例如，class 返回对象的类;isKindOfClass:和 isMemberOfClass:则检查对象是否在指定的 类继承体系中;respondsToSelector:检查对象能否响应指定的消息;conformsToProtocol: 检查对象是否实现了指定协议类的方法;methodForSelector:则返回指定方法实现的地址。 ①message（消息）message 是一种抽象，包括了函数名+参数列表，并没有实际的实体存在。②method（方法）method是真正的存在的代码。如：- (int)meaning { return 42; }③selector（方法选择器）selector 通过SEL类型存在，描述一个特定的method 或者说 message。在实际编程中，可以通过selector进行检索方法等操作。 34.方法选择器它是一个char *指针，仅仅表示它所代表的方法名字。typedef struct objc_selector *SEL; SEL selector = @selector(message); // @selector不是函数调用，只是给编译器的一个提示 NSLog (@"%s", (char *)selector); //print message Objective-C在编译的时候，会根据方法的名字，生成一个用来区分这个方法的唯一的一个ID，这个ID就是SEL类型的（生成唯一的SEL）。只要方法的名字相同，那么它们的ID都是相同的。编译器会根据，这个Set简单的说就是一个经过了优化过的hash表。SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，从而加快方法的查询速度。 35.IMPtypedef id (*IMP)(id, SEL, ...);由于每个方法都对应唯一的SEL，可以通过SEL方便、快速、准确的获得它所对应的IMP（也就是函数指针），而在取得了函数指针之后，也就意味着取得了执行这段方法的代码的入口，这样就可以像普通的C语言函数调用一样使用这个函数指针。 void (*performMessage)(id,SEL); //定义一个IMP（函数指针） performMessage = (void (*)(id,SEL))// 通过methodForSelector方法根据SEL获取对应的函数指针 [self methodForSelector:@selector(message)];//通过取到的IMP（函数指针）跳过runtime消息传递机制，直接执行message方法。performMessage(self,@selector(message)); 用IMP 的方式，省去了runtime消息传递过程中所做的一系列动作，比直接向对象发送消息高效一些。 36.消息调用流程消息表达式[receiver message]在被转换成objc_msgSend(receiver, SEL)后，在运行时，runtime system会做以下事情： 1、检查忽略的selector（比如将会忽略retain和release消息）。 2、检查receiver是否为nil。（如果receiver为空，则会将 selector也设置为空，并且直接返回到消息调用的地方。）如果对象非空，就继续下一步。 3、根据SEL到当前类中查找对应的IMP，首先会在cache中检索它，如果找到了就根据函数指针跳转到这个函数执行，否则进行下一步。 4、检索当前类对象中的方法表（method list），如果找到了，加入cache中，并且就跳转到这个函数执行，否则进行下一步。 5、从父类中寻找，直到根类：NSObject类。找到了就将方法加入对应类的cache表中，如果仍未找到，则要进入动态方法决议。 6、如果动态方法决议仍不能解决问题，只能进行最后一次尝试，进入消息转发流程。 注意：cache的原则就是缓存那些可能要执行的函数地址，下次调用的时候，速度就可以快速很多。 类方法和实例方法中，都可以访问self和_cmd这两个属性，因为它们都不属于类的实例变量，而是形参。objc_msgSend找到方法对应的实现时，将直接调用该方法实现，并将消息中所有的参数都传递给方法实现，同时，它还将传递两个隐藏的参数:接收消息的对象（也就是self指向的内容），方法选标（_cmd指向的内容） 隐藏：因为它们并没有在定义方法的源代码中声明，而是在代码编译时是插入方法的实现中的。在方法中可以通过 self 来引用消息接收者对象，通过选标_cmd来引用方法本身。- (void)message &#123; self.name = @"James";//通过self关键字给当前对象的属性赋值 SEL currentSel = _cmd;//通过_cmd关键字取到当前函数对应的SEL NSLog(@"currentSel is :%s",(char *)currentSel); &#125; 当被调用的方法实现部分没有找到，而消息转发机制启动之前的这个中间时刻(动态添加方法)。+(BOOL) resolveInstanceMethod:(SEL) sel将被调用。这是NSObject根类提供的类方法。 void dynamicMethodIMP(id self, SEL _cmd) &#123; // implementation .... &#125; + (BOOL)resolveInstanceMethod:(SEL)sel &#123; NSLog(@"sel is %@", NSStringFromSelector(sel)); if (sel == @selector(setName:)) &#123; class_addMethod([self class],sel,(IMP)dynamicMethodIMP,"v@:"); return YES; &#125; return [super resolveInstanceMethod:sel]; &#125; @dynamic关键字的作用:①告诉编译器不要创建实现属性所用的实例变量；②告诉编译器不要创建该属性的get和setter方法。让编译器相信存取方法会在运行时找到。// 声明文件中@property(nonatomic, copy) NSString *name; // 实现文件中@dynamic name; 37.@synthesize默认情况下，编译器会为当前类自动生成一个NSString *_name的实例变量（如果想改变实例变量的名称可以用@synthesize关键字），同时会生成两个名为- (NSString *)name和- (void)setName:(NSString *)aName的存取方法。 38.消息转发外部调用的某个方法对象没有实现，而且resolveInstanceMethod方法中也没有做重定向处理时，就会触发- (void)forwardInvocation:(NSInvocation *)anInvocation方法。这个方法通常用来将不能处理的消息转发给其它的对象。 - (void)forwardInvocation:(NSInvocation *)invocation &#123; SEL invSEL = invocation.selector; if ([someOtherObject respondsToSelector:invSEL]) [anInvocation invokeWithTarget:someOtherObject]; &#125; else &#123; [self doesNotRecognizeSelector:invSEL]; &#125; &#125; 39.Cocoa它是一个面向对象的软件组件——类的集成套件，它使开发者可以快速创建强壮和全功能的 Mac OS X （iOS）应用程序。Cocoa包含了很多框架，其中最最核心的是Foundation框架和Application Kit（AppKit）框架（Cocoa Touch中叫UIKit框架）。 40.Runloop它是为了线程而生，是线程的基础架构部分，每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。主线程的run loop默认是启动的。UIApplicationMain()函数，会为main thread设置一个NSRunLoop对象。NSRunLoop类并不是线程安全的，不能在一个线程中去操作另外一个线程的run loop对象，CFRunLoopRef是线程安全的。获取到当前线程的run loop:[NSRunLoop currentRunLoop];获取对应的CFRunLoopRef类：- (CFRunLoopRef)getCFRunLoop; 一个run loop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。对消息处理过程进行了更好的抽象和封装，在NSRunLoop中每一个消息就被打包在input source或者是timer source中了。使用run loop可以使线程在有工作的时候工作，没有工作的时候休眠，这可以大大节省系统资源。创建输入源的时候，需要将其分配给run loop中的一个或多个模式。定时源在预设的时间点同步方式传递消息，这些消息都会发生在特定时间或者重复的时间间隔。定时源则直接传递消息给处理例程，不会立即退出run loop。 41.创建NSTimer// 方式一:自动把timer加入MainRunloop的NSDefaultRunLoopMode中NSTimer *timer = [NSTimer scheduledTimerWithTimeInteral:1.0 target:self selector:@selector(action:) userInfo:ni] repeat:NO]; // 停止[timer invalidate];// 方式二(需手动加到run loop中)NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self seletor:@selector(timerAction) userInfo:nil repeats:YES];[[NSRunloop mainRunloop] addTimer:timer forMode:NSDefaultRunloopMode]; 调用创建方法后，target对象的引用计数会+1，直到执行完毕，自动-1。如果RunLoop正在执行一个连续的运算，timer就会被延迟触发。 42.响应者对象（Responder Object）指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。 43.响应者链通常是由视图（UIView）构成的。 一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）。 视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图。 单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者。 单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。 第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:。 44.响应者链方法的处理流程首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；若返回NO，则hitTest:withEvent:返回nil;若返回YES，则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；如所有子视图都返回空对象，则hitTest:withEvent:方法返回自身(self)。 45.类别与类扩展的区别：①类别中只能增加方法。②类扩展不仅可以增加方法，还可以增加实例变量（或者合成属性），只是该实例变量默认是@private类型的。③类扩展中声明的方法没被实现，编译器会警告，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中。④类扩展所声明的方法必须依托对应类的实现部分来实现。⑤定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。 46.KVC全称是Key-value coding，翻译成键值编码。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。KVO全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。KVO机制很适合实现model和controller类之间的通讯。KVC是不会自动调用键值验证方法的，我们需要手动验证：- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;KVC可以自动的将数值或结构体型的数据打包或解包成NSNumber或NSValue对象，以达到适配的目的。 47.内存管理规则ARC的英文全名是：Automatic Reference Counting，是编译器提供的管理Objective-C对象内存的一个机制。它并不是像垃圾回收机制那样，有一个负责内存回收的系统，而是仍然以引用计数为基础：在编译阶段，编译器会在需要retain或release对象的地方自动为我们加上对应的代码。一个对象存在strong类型的指针指向时，该对象就不会被释放。 采用散列表来管理引用计数，统一存储所有对象的引用计数，不用考虑每个对象内存块中引用计数所占的内存，在引用计数表中存储各个对象的内存地址。 ①strong该属性值对应 __strong关键字，即该属性所声明的指针变量将成为对象的持有者。strong是指向对象指针的默认属性。②weak该属性对应__weak关键字，与__weak定义的变量一致，该属性所声明的变量将没有对象的所有权，并且当对象被破弃之后，指针将被自动赋值nil。④copy也是对象的所有者，与strong的区别是声明的指针变量是拷贝对象的持有者。⑤assign一般数值型变量用该属性声明，比如，int、BOOL，但无需显示写出，因为数值型变量的默认属性类型就是assign。 使用关键字声明指针类型规范写法://规范的写法MyClass * __weak myWeakReference; 48.weak和assign的异同相同点：指向的对象都是随时有可能被释放，即不拥有指向的对象。不同点：①weak只能用来修饰对象，assign既可以用来声明对象，也可以用来声明数值型变量；②很关键的一点区别，当一个weak关键字声明的指针指向的对象被释放掉得时候，该指针会自动的被指向nil，而assign不存在该特性。 使用@property声明或作为普通实例变量声明的指向对象的指针属性默认都是strong；而使用@property声明的数值型变量属性默认的是assign。 属性 关键字 所有权 strong __strong 有 copy __strong 有 retain __strong 有 weak __weak 无 assign __unsafe_unretained 无 unsafe_unretained __unsafe_unretained 无 49.使用ARC需要遵守的新规则①不要在dealloc方法中调用[super dealloc];。②不能使用 retain/release/retainCount/autorelease③不能使用 NSAllocateObject/NSDeallocateObject④不能使用 NSZone⑤对象不能作为C语言结构体（struct/union）的成员 50.instancetype表示某个方法返回的某种类型的对象，instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型，能够确定对象的类型。有利于开发者在编译阶段发现错误。关联返回类型（related result types）1、类方法中，以alloc或new开头；2、实例方法中，以autorelease，init，retain或self开头； instancetype和id的异同:1、相同点:都可以作为方法的返回类型2、不同点①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；②instancetype只能作为返回值，不能像id那样作为参数； 51.沙盒目录：1、MyApp.app存放应用程序本身的数据，整个目录是只读的，不能被iTunes同步。2、Documents存放不可再生的的数据文件，会被iTunes同步。3、Library存放默认设置或其它状态信息。除了Caches子目录外，会被iTunes同步。4、Library/Caches存放缓存文件，保存那些可再生的文件，不会被iTunes同步。5、Library/Preferences存放应用程序的偏好设置文件。我们使用NSUserDefaults写的设置数据都会保存到该目录下的一个plist文件中，会被iTunes同步。6、tmp存放各种临时文件，不会被iTunes同步。 52.空NULL本质上是：(void*)0，表示C指针为空，如charchar *string = NULL;。nil本质上是：(void *)0，表示指向对象的指针为空。Nil本质上也是：(void *)0,表示Class类型的变量值为空，Class anyClass = Nil;。 53.NSNull是一个Objective-C类，该类通常用于在集合对象中保存一个空的占位对象。 // 遇到nil截断NSArray *arr = [NSArray arrayWithObjects:@"wang",@"zz",nil,@"foogry"]; // 存储空的占位对象NSArray *arr = [NSArray arrayWithObjects:@"wang",@"zz",[NSNull null], @"foogry"]; 54.imageNamedimageNamed的优点在于可以缓存已经加载的图片。这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回。imageWithContentsOfFile方法只是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到程序。当不需要重用该图像，或者需要将图像以数据方式存储到数据库，又或者要通过网络下载一个很大的图像时，可以使用这种方式。 读完他们的博客，仿佛看到未来的自己…… 向前辈致谢：王中周的个人博客M了个J参考：C语言中文网]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>C语言</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言交换两个数值的八种方法]]></title>
    <url>%2F2016%2F10%2F23%2FC%E8%AF%AD%E8%A8%80%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%80%BC%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单总结，以鞭笞岁月。 编译器:XCode8.0 异或int main(int argc， const char * argv[]) &#123; int m = 5， n = 3; m = m ^ n; n = m ^ n; m = m ^ n; printf("m:%d---n:%d"，m，n); return 0;&#125; 异或一般是针对二进制数. 两数异或，相同则得0，不同则得1。 x ^ x = 0，x ^ 0 = x第二行: m:0101 n:0011第三行: m:0110 n:0011第四行: n:0101 m:0110第五行: m:0011 n:0101此时，已完成交换. 运算符int main(int argc， const char * argv[]) &#123; int m = 2147483648， n = 2147483647; m = m + n - (n = m); printf("m:%d---n:%d"，m，n); return 0;&#125; 从左向右依次进行，首先获取m与n的和，接着利用()运算符直接将m的值赋予n，此时n完成交换。 同时()内的值是m的值，两数之和减去m值便是n的值，再将n的值赋予m，到这里m完成交换。 位运算int main(int argc， const char * argv[]) &#123; int m = 5， n = 3; n = (long)((long)m &lt;&lt; 32 | (m = n)) &gt;&gt; 32; printf("m:%d---n:%d"，m，n); return 0;&#125; 注:__int64表示64位整型变量，Xcode中用long代替，VC6.0可直接使用__int64，即: b = (__int64)((__int64)a &lt;&lt; 32 | (a = b)) &gt;&gt; 32； (m = n):完成m的交换，()内的值是n。 (long)((long)m &lt;&lt; 32 | n):得到的结果是 00...0 0101 00...0 11第一部分28个0，第三部分30个0 。 ((long)((long)m &lt;&lt; 32 ) &gt;&gt; 32:得到的结果:把第三第四部分去掉，即00...0 0101 正好32位，且此值为m的值，再将其赋予n，完成n的交换。 宏定义#define swap(x， y， z) ((z) = (x)， (x) = (y)， (y) = (z)) int main(int argc， const char * argv[]) &#123; int m = 5， n = 3，t = 0; swap(m， n， t); printf("m:%d---n:%d"，m，n); return 0;&#125; 比较巧妙，把中间变量放在宏中。 两数之和int main(int argc， char *argv[]) &#123; int m = 5， n = 3; m = m + n; n = m - n; m = m - n; printf("m:%d---n:%d"，m，n); return 0;&#125; 算是一种数学方法吧，但可能溢出。 两数之积int main(int argc， const char * argv[]) &#123; int m = 5， n = 3; m = m * n; n = m / n; m = m / n; printf("m:%d---n:%d"，m，n); return 0;&#125; 两数之和方法的变形，n不能为0，m更可能溢出。 取址void swap(int *a， int *b) &#123; int temp = 0; temp = *a; *a = *b; *b = temp;&#125; int main(int argc， const char * argv[]) &#123; int m = 2147483648， n = 2147483647; swap(&amp;m，&amp;n); printf("m:%d---n:%d"，m，n); return 0;&#125; 引用void swap(int &amp;a, int &amp;b) &#123; int temp = a; a = b; b = temp;&#125;int main(int argc， const char * argv[]) &#123; int m = 2019， n = 2010; swap(m，n); printf("m:%d---n:%d"，m，n); return 0;&#125; 知识int最大值，根据编译器类型不同而变化。 对于16位编译器，int占16位(2字节)。int的最大值为32767。 对于32位和64位编译器，int占32位(4字节)。int的最大值为2147483647。 可以通过打印sizeof(int)查看平台对应的int占用字节数。乘8后即为位数。最高位为符号位，如位数为n，则最大值为2^(n-1) 即2的n-1次幂。 printf("%lu"，sizeof(int));int a = 2147483648; 做了一次标题党。。。 参考并致谢:C语言交换两个变量数值的几种方法一道面试题：用多种方法实现两个数的交换]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods的安装与使用]]></title>
    <url>%2F2016%2F10%2F10%2FCocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CocoaPods是非常好用的第三方库管理工具。 升级Gemsudo gem update --system 切换CocoaPods的数据源# 1.删除gem sources --remove https://rubygems.org/ # 2.添加淘宝数据源gem sources -a https://ruby.taobao.org/ # 3.查看gem sources -l 安装CocoaPodssudo gem install CocoaPods或者（如10.11系统）sudo gem install -n /usr/local/bin CocoaPods 报错解决Error installing pods:activesupport requires Ruby version &gt;= 2.2.2 解决方式: 安装 RVMcurl -L get.rvm.io | bash -s stable 等待。 source ~/.bashrc source ~/.bash_profile 测试是否安装成功。 rvm -v 用RVM升级Ruby# 1.查看当前ruby版本 ruby -v # 显示 ruby 1.8.7 # 2.列出已知的ruby版本 rvm list known # 3.安装ruby 2.3 rvm install 2.3 安装完成之后ruby -v查看是否安装成功。 更换托管地址 将Podspec文件托管地址从github切换到国内的oschina或者coding。 注意:如果pod setup 可以将github的代码下载得动，那就不用去更换托管地址了。 # 1.先移除pod repo remove master # 2.再添加pod repo add master https://git.coding.net/CocoaPods/Specs.git # 3.再更新pod repo update 设置pod仓库(初始化CocoaPods)pod setup # 会将Specs.git的代码下载到~/.CocoaPods/repo/master,自己前往查看是否有文件# 如果还是太慢，尝试下pod install --verbose 报错解决[!] To setup the master specs repo, please run `pod setup`. 手动下载代码解决:# 1.手动克隆文件至该目录git clone https://git.coding.net/CocoaPods/Specs.git ~/.CocoaPods/repos/master # 2.初始化,完成后显示Setup completedpod setup 测试# 如果有版本号，则说明已经pod安装成功pod --version# 如果~/.CocoaPods/repo/master目录下有文件,说明文件下载成功 使用介绍利用CocoaPods来安装第三方框架。 进入要安装框架的项目的.xcodeproj同级文件夹。 在该文件夹中新建一个文件podfile。 在文件中告诉CocoaPods需要安装的框架信息。 a.该框架支持的平台b.适用的iOS版本c.框架的名称d.框架的版本 Podfile文件格式platform :ios, '9.0'target '你的项目名称' dopod 'AFNetworking', '~&gt; 3.0'end 创建Podfile文件进入.xcodeproj同级文件夹下 # 初始化:会生成模板的Podfile文件pod init # 或者手动创建Podfile文件touch Podfile 添加自己需要的第三方库pod 'AFNetworking', '~&gt; 3.0' # If you are using Swift, be sure to add use_frameworks! and set your target to iOS 8+:pod 'SDWebImage', '~&gt;3.8'use_frameworks! pod 'Masonry' pod 'MBProgressHUD', '~&gt; 1.0.0' pod 'MJExtension' pod 'MJRefresh' pod 'SVProgressHUD' 开始安装pod install --verbose --no-repo-update# 显示# Pod installation complete! There is 1 dependency from the Podfile and 1 total pod installed. Start!以后打开项目点击xcworksapce后缀的文件，不要点击原来的项目文件。导入头文件应该使用: #import &lt;&lt;#header#&gt;&gt; 说明platform :ios, ‘9.0’ 用来设置所有第三方库所支持的iOS最低版本pod ‘SDWebImage’,’~&gt;2.6’ 设置框架的名称和版本号 版本号的规则：‘&gt;1.0’ 可以安装任何高于1.0的版本‘&gt;=1.0’ 可以安装任何高于或等于1.0的版本‘&lt;1.0’ 任何低于1.0的版本‘&lt;=1.0’ 任何低于或等于1.0的版本‘~&gt;0.1’ 任何高于或等于0.1的版本，但是不包含高于1.0的版本‘~&gt;0’ 任何版本，相当于不指定版本，默认采用最新版本号 pod install过程 分析依赖:该步骤会分析Podfile,查看不同类库之间的依赖情况。如果有多个类库依赖于同一个类库，但是依赖于不同的版本，那么CocoaPods会自动设置一个兼容的版本。 下载依赖:根据分析依赖的结果，下载指定版本的类库到本地项目中。 生成Pods项目：创建一个Pods项目专门用来编译和管理第三方框架，CocoaPods会将所需的框架，库等内容添加到项目中，并且进行相应的配置。 整合Pods项目：将Pods和项目整合到一个工作空间中，并且设置文件链接。 补充Mac显示隐藏的文件： defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder Mac取消显示隐藏文件： defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder 参考并致谢:Mac上更新Rubycocoapods的安装和使用以及版本升级遇到的问题]]></content>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C学习笔记]]></title>
    <url>%2F2016%2F05%2F12%2FObjective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2016.10.28 更正部分错误2019.03.29 整合所有关于Objective-C的笔记 关于Objective-C的学习笔记。 1.类的设计三要素：事物名称（类名）；属性；行为（功能）。具有相同（或者类似）属性和行为的对象可以抽象出一个类。 2.类的声明类名1，首字母大写；2，不能有下划线；3，多个英文单词，使用驼峰标识； 行为哪个对象最清楚行为怎么做，就把行为设计在哪个对象身上。 @interface Person : NSObject &#123;@public int _age; bool _sex;&#125; - (void)print;@end 大括号内用来声明对象的成员变量（也即实例变量），@public让外界指针可以间接访问对象内部的成员变量。值类型的成员变量默认会初始化为0，引用类型的成员变量默认会初始化为nil。nil表示指向一个对象的空指针，Nil表示指向一个类的空指针。 : NSObject：表示继承自NSObject类。 3.类的实现需要导入声明文件#import &quot;Person.h&quot; @implementation Person- (void)print &#123; NSLog(@"输出内容");&#125;@end 类的实现主要是方法的实现。 4.创建对象Person *p = [[Person alloc] init];[p print]; 对象的本质是结构体，对象需要通过指针操纵。 类在内存中也占据存储空间，在创建对象之前为类分配一份内存空间，将类加载进内存，而且只存储方法列表，其中由类产生的对象，都有一个isa指针指向类。 方法调用：[行为执行者 行为名称]; [Person new]执行Person这个类的new行为，创建对象，返回对象地址。 Person *p = [Person new];定义一个Person 类型的指针变量p，指向Person类型的对象。指针的类型是Person *，指针指向的类型是Person。 [p print];表示给p指向的对象发送一条print消息。 Person p = [Person new];等价于 Person p; p = [Person new];另外Person *p2 = p;表示p2、p指向同一个内容。p2 = p:将p存储的指针交给p2，使p2存储的也是p存储的内容。 5.方法与函数的区别以及注意 方法只能声明在@interface和@end之间，只能实现在@implementation和@end之间。也就是说方法不能独立于类存在。 C函数不属于类，跟类没有联系，C函数只归定义函数的文件所有。 C函数不能访问对象的成员变量。 对象方法归类／对象所有，函数属于整个文件所有，任何地方都可以放置函数（如果放在@interface与@end之间，将会忽略掉函数，即未定义）。 方法只有声明，没有实现（经典错误） 方法没有声明，只有实现（编译器警告，但是能调用，弱语法）。 编译的时候：访问没有的成员变量直接报错，访问没有的方法，只是警告。 同一个类中不允许两个对象方法同名。 6.匿名对象属性访问 [Car new]-&gt;speed = 200;方法调用[[Car new] run]; 7.对象方法不带参数的对象方法： // 方法名 print- (void)print; 带一个参数的对象方法： // 方法名 print:- (void)print:(int) a; 带多个参数的对象方法： // 方法名 print:WithOther:- (void)print:(int)a WithOther:(int)b; 8.枚举C语言中的枚举：typedef enum｛ SexMan, SexWoman｝Sex; 建议使用Objective-C风格的枚举，示例：typedef NS_ENUM(NSInteger, YAViewType) &#123; YAViewTypeDefault = 0, // 默认 value YAViewTypeButton = 1, YAViewTypeCell = 2&#125;; 9.结构体typedef struct&#123; int year; int month; int day;&#125; Date; 访问枚举：s-&gt;sex = SexMan;访问结构体：s-&gt;birthday.year = 2016;定义结构体：Date d = {2016,4,30};访问结构体： s-&gt;birthday.year = 2016;s-&gt;birthday.month = 4;s-&gt;birthday.day = 16; 等价于： Date d = &#123;2016,4,16&#125;; s-&gt;birthday = d; 10.注意事项 在使用打印函数NSLog时注意％与%的区别。 定义枚举、结构体等建议放在@interface的前面使用。 方法中一个参数对应一个冒号。 对象中的成员变量指向另一个对象： @interface Student : NSObject &#123;@public// 狗Dog *dog;&#125; - (void)letDogRun &#123; [dog run];&#125; // main.m文件Student *stu = [Student new];Dog *dog = [Dog new];stu-&gt;dog = dog;[stu letDogRun]; 11.封装过滤不合理的值，屏蔽内部的赋值过程，让外界不必关注内部的细节。 成员变量的命名：以下划线开头。用于区分get方法名称和局部变量名称。尽量不设置为@public公有属性，如： &#123; int _speed;&#125; set方法：设置成员变量，过滤一些不符合要求的值。以set开头，返回类型为void，后面跟上成员变量名，形参不与成员变量重名，形参类型与成员变量相同，成员变量的首字母大写。- (void)setSpeed:(int)s;- (void)setSpeed:(int)s &#123; _speed = s+20;&#125; get方法：获取对象内部的成员变量，不接收参数，返回类型与成员变量类型相同，方法名称与成员变量名称相同（不含下划线）。不推荐以get开头。 - (int)speed; - (int)speed &#123; return _speed; &#125; 只读：只提供get方法。可读可写：提供get和set方法。 12.调用未声明、未实现的对象方法编译报错： No visible @interface for ‘Dog’ declares the selector ‘ssss’。链接运行报错：reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1002014a0’，表示给Dog对象发送不能识别的消息。 13.调用已声明、未实现的对象方法编译警告：Method definition for ‘ssss’ not found 未实现方法。链接正常，运行报错：reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1001002a0’。 14.调用未声明、已实现的对象方法编译错误： No visible @interface for ‘Dog’ declares the selector ‘ssss’。 15.类方法类本身在内存中占据存储空间，里面有类\对象方法列表。直接通过类名执行的方法以+开头，只能由类名调用，类方法中不能访问成员变量（实例变量）。允许类方法与对象方法重名。使用场合：当不需要访问成员变量的时候，尽量使用类方法，提升效率。 输出类的名称： + (void)showClassName;+ (void)showClassName &#123; NSLog(@"类的名称是：%@",NSStringFromClass([self class]));&#125; 调用：[Dog showClassName]; 16.self关键字self是指针，指向当前对象方法或类方法的调用者。出现在对象方法中，代表当前对象，出现在类方法中，代表当前类。不能出现在函数中（会报错：Use of undeclared identifier ‘self’使用未声明的标识符）。 用途： self-&gt;成员变量名 在对象方法中访问当前方法调用的成员变量，也即当成员变量与局部变量同名时，用来区分同名的局部变量。 - (void)showSelfOfObject;- (void)showSelfOfObject &#123; NSLog(@"showSelfOfObject方法被调用"); int _speed; self-&gt;_speed=200; _speed += 1000; int result = self-&gt;_speed+10; NSLog(@"result的值是：%i",result); NSLog(@"_speed的值是：%i",_speed);&#125; 当成员变量与局部变量同名时（编译警告Local declaration of ‘_speed’ hides the instance variable局部变量隐藏了成员变量），采用就近原则，访问局部变量。因此需要用self访问成员变量。 方法的调用:在对象方法中调用当前对象的对象方法以及在类方法中调用当前类的类方法。 在对象方法中调用当前对象的对象方法： - (void)showSelfOfObject;- (void)showTestObject;- (void)showSelfOfObject &#123; NSLog(@"showSelfOfObject方法被调用");&#125; - (void)showTestObject &#123; [self showSelfOfObject];&#125; 在类方法中调用当前类的类方法： + (void)showSelfOfClass;+ (void)showTestClass;+ (void)showSelfOfClass &#123; NSLog(@"showSelfOfClass方法被调用");&#125; + (void)showTestClass &#123; [self showSelfOfClass];&#125; 常见错误： 在对象方法中调用类方法（编译错误No visible @interface for ‘Dog’ declares the selector ‘showSelfOfClass‘）错误相当于未声明未定义却调用这个方法。 在类方法中调用对象方法（编译错误No known class method for selector ‘showSelfOfObject‘）未知的类方法。 self的死循环:调用本身 - (void)showSelfOfObject &#123; NSLog(@"showSelfOfObject方法被调用"); [self showSelfOfObject];&#125; 调用函数 函数不依赖对象。void f(); [self f] 错误。 17.继承场景：当两个类拥有相同的属性和方法时，将相同的内容抽取到父类中。当A类完全拥有B类的部分属性或方法时，考虑A类作为父类。 父类必须声明在子类前面。 不允许子类和父类拥有相同的成员变量（如果子类有和父类拥有相同的成员变量，意味着，同一成员变量声明定义两次，编译错误 Duplicute member ‘_age’，哪怕成员变量的访问属性不同，子类公开父类私有，或者父类公开子类私有，都不行！） 子类方法和属性的访问过程：如果子类没有，再访问父类。即由子类开始。 Objective-C中只有单继承（与C＋＋不同）。 方法的重写:父类和子类拥有相同签名的类方法或者对象方法（子类重新实现了父类中的方法），则优先调用子类的同名方法。 // 父类Person：- (void)show &#123; NSLog(@"调用了Person的show方法");&#125; // 子类Student：- (void)show &#123;// [super show];NSLog(@"调用了Student的show方法");&#125; // 调用：Student *p = [[Student alloc] init]; [p show]; 很明显，调用的是重写的子类Student的show方法。 18.super场景：子类重写父类的方法时，想调用父类的方法（包括类方法和对象方法）。 效果与self类似，super在对象方法中就调用父类的对象方法，在类方法中就调用父类的类方法。 继承可以在不改变原来模型的基础上拓充方法，抽取公共代码，建立类与类之间的联系，减少代码的冗余性，但是，会增加耦合性。 19.多态某一种事物的多种形态。在实现继承的前提下，父类类型指针指向子类对象，指向子类对象的父类指针可以调用子类中重写父类的方法，但是指向子类对象的父类指针不能调用子类中拓展的方法（父类中没有的方法）。 Person *p = [[Student alloc] init]; [p show]; Student是Person，show方法在子类和父类中都有，这里调用的是子类的show方法。当子类拓展了一个showStudent对象方法，如果还想调用，则强制转换：将指向子类对象的父类指针强制转化为子类指针。 Person *p = [[Student alloc] init];Student *p2 = (Student *)p;[p2 showStudent]; 将父类指针p强制转换为子类指针，使它可以调用子类Student拓展的showStudent方法。 如果不做强制转换，而直接调用子类拓展的方法 Person *p = [[Student alloc] init];[p showStudent]; 编译报错： No visible @interface for ‘Person’ declares the selector ‘showStudent’ 主要应用：动态绑定如果参数使用父类类型，可以传入父类、子类对象，调用相应的方法（如将子类对象传递给参数，调用子类的方法；将父类对象传递给参数，则调用父类的方法） 20.NSString的使用 创建字符串与输出字符串 NSString *s = @"Sometimes";NSLog(@"%@",s); 格式化字符串 int age = 85;NSString *s = [NSString stringWithFormat:@"传入的年龄参数是%d",age];NSLog(@"%@",s); 调用NSString类方法。 length返回字数（不是字符数），返回的是7，包括空格。 NSString *s = @"123 456"; NSLog(@"%@",s);NSUInteger size = [s length];NSLog(@"%lu",(unsigned long)size); 21.点语法本质是方法调用，不访问成员变量。前提是已经存在get和set方法(否则报错：Property ‘age’ not found on object of type ‘Person *’)。 [p setAge:50];int result = [p age];NSLog(@"result的结果是：%i",result); 相当于： p.age = 50;int result = p.age;NSLog(@"result的结果是：%i",result); 22.方法的展开原理：[p setAge:50];对应 p.age = 50; 而int result = [p age];对应int result = p.age; 23.死循环set方法中 - (void)setAge:(int)a &#123; self.age=a;&#125; 实际上是在set方法中调用set方法。 - (int)age &#123; return self.age;&#125; 在get方法中调用get方法。以上编译链接均无警告、无错误，但是运行会报错。 24.成员变量的作用域@private私有。只能在当前类的对象方法中直接访问（当前类的对象方法的@implementation中访问），子类虽然继承（内存中存在），但无权限访问。 @protected保护（默认是保护，不是私有）。可以在当前类和子类的对象方法中直接访问（当前类和子类的@implementation中访问）。假设父类Person有保护的成员变量_number，子类继承，什么变量都不增加，那么子类对象方法中访问的是父类的_number。 - (void)show &#123; self-&gt;_number = 1000; int result = self-&gt;_number; _number = 5000; int result2 = _number; NSLog(@"self-&gt;_number的值是：%i",result); NSLog(@"_number的值是：%i",result2);&#125; @public公开。任何地方都可以访问。一般用不到。 @package同一个框架内可以访问，介于@public和@private之间。 注意点 在类方法中不可能访问成员变量。 也可以在@implementation中声明成员变量。 @implementation Student:NSObject &#123; @public int age; @private int number; @protected int no;&#125;@end 25.@property和@synthesize属性合成@property用在@interface中，代替get和set方法如：@property int age;等价于 - (int)age;- (void)setAge:(int)age; 即便是@property int _age;那也会生成 - (int)_age;- (void)setAge:(int)_age; 而@synthesize用在@implementation实现中：@synthesize age = 成员变量名; 不允许对成员变量进行条件过滤，如@synthesize age = _age+100; @synthesize age=_age; 等价于 - (int)age &#123; return _age;&#125;- (void)setAge:(int)age &#123; _age=age;&#125; 总结 1，如果.h文件中没有这个_age成员变量。那么，利用@property可以自动生成私有@private的_age。而默认的_age却是@protected的。 2，@synthesize age将会访问age这个成员变量而非_age。 3，若手动实现getter方法，编译器只会自动生成setter方法；若手动实现setter方法，编译器只会自动生成getter方法。 新特性@property已经独揽@synthesize的实现了，也即 @synthesize age=_age;可以省略。只用写@property int age就好了。（当然，前提是不对参数进行过滤，直接传到成员变量中，如果要过滤，还是要自己生成相应的方法。） 26.id相当于NSObject * ，是万能指针。 id类型的定义typedef struct objc_object &#123; Class isa;&#125;*id; 27.构造方法用来初始化对象的方法，完整地创建一个可用对象。 Person *p = [Person alloc];+alloc方法分配存储空间，返回对象。 p = [p init];-init方法初始化。 28.init方法的重写目的：在对象创建完毕之后，使成员变量就有了一些默认的值。注意：一定要先调用父类的构造方法，再进行子类内部成员变量的初始化。在@implementation中进行重写： - (id)init &#123; // 一定要先调用super的init方法，这是为了初始化父类的一些成员变量和其他属性 self = [super init]; // 判断对象是否初始化成功，如果对象初始化成功，再进行接下来的自定义初始化 if(self != nil) &#123; _age=10086; &#125; // 返回一个已经初始化完毕的对象 return self;&#125; 上面代码不够简化，一般用下面代码。 - (id)init &#123; // 简化版 if([super init]) &#123; _age=10086; &#125; return self;&#125; 29.自定义构造方法要求：是对象方法（对象的初始化），返回值是id类型，方法名以initWith开头。注意：-init方法重写不需要在@interface中声明，因为已经声明过了，而自定义的构造方法需要在@interface中显式声明。 // 声明- (id)initWithAge:(int)age; // 实现- (id)initWithAge:(int)age &#123; if([super init]) &#123; _age=age+100; &#125; return self;&#125; 调用示例： Person *p = [Person alloc];p = [p init];int r = p.age;NSLog(@"r的值是%i",r); p= [p initWithAge:110];int r2 = p.age;NSLog(@"r2的值是%i",r2); 含有多个参数的构造方法：- (id)initWithAge:(int)age andNumber:(int)number; 30. .h文件和.m文件每个类分布在不同的文件中类的声明放在.h文件中，类的实现放在.m文件中若想使用某个类，就包含某个类的.h文件即可。 31.分类场合：在不修改原来类模型的情况下，给类扩充一些方法，且仅是方法，不扩充成员变量。可以给系统自带的类添加分类，扩充方法。（注意引入分类文件）当添加分类的方法是重写原来类中的方法时,不需要引入分类文件。声明文件的命名方式 【类+分类.h】 @interface 类名 (分类名)@end 实现文件的命名方式 【类+分类.m】@implementation 类名 (分类名)@end 特征：用括号括住添加的分类好处：一个庞大的类可以分模块开发、由多个人编写，有利于团队合作。 注意点1，分类可以访问原来类中的成员变量，但不能增加成员变量（若要增加成员变量，可以使用继承）。 2，分类的优先级最高，当调用类中的一个方法时，优先去分类中查找，再去原类中查找，最后去父类中查找。也即，倘若在分类中重写了原类中的方法，会“覆盖”掉原来的方法，导致原来的方法无法使用。（不建议重写原来类中的方法）重写会出现警告：Category is implementing a method which will also be implemented by its primary class. 3，如果多个分类中有相同（方法签名相同，但不一样）的方法，则调用的是最后编译的方法。 32.类的私有方法 方式1，直接在.m文件中写方法实现，不要在.h文件中进行方法声明 方式2，在.m文件中定义一个category，然后在category中声明一些方法，最后在@implementation和@end之间作方法实现。 33.类的本质类也是一个对象，是Class类型的对象，简称类对象，类对象就是类。class类型的定义:typedef struct objc_class *Class;类名代表着类对象，每个类只有一个类对象。 34.+load在程序启动的时候，就会加载所有的类和分类，并调用一次所有类和分类的+load方法。 先加载父类，再加载子类，也即先调用父类的+load方法，再调用子类的+load方法。 先加载原始类，再加载分类（顺序也即父类——父类的分类——子类）。 不管程序运行过程中有没有用到这个类，都会调用+load加载。 35.+initialize在第一次使用某个类时（比如创建对象），就会调用一次+initialize方法。一个类只会调用一次+initialize方法，先调用父类的，再调用子类的。获取类对象的两种方式 Class c = [Person class];//类方法 或者 Person *p = [Person new];Class c = [p class];//对象方法 很明显，[p class]和[Person class]方法返回的都是是class类型类对象调用类方法： Class c = [Person class];Person *p2 = [c new]; 36.description方法类似其他语言的ToString方法，NSObject自带的方法。返回值类型是NSString ＊。默认情况下，使用NSLog和%@打印一个对象，输出的是&lt;类名:内存地址&gt;，如：&lt;Person: 0x1002070a0&gt;，而NSLog(@&quot;%@&quot;,p)会调用-description方法。 -description方法使用NSLog和%@输出某个对象时，会调用对象的-description方法。 +description方法使用NSLog和%@输出某个类对象时，会调用类对象的+description方法。 可以重写+description和-description方法修改NSLog的默认输出注意：如果在-description方法中使用NSLog打印self，会造成死循环。 // 重写-description方法- (NSString *)description &#123; return [NSString stringWithFormat:@"%@", self]; &#125; 编译无警告，无报错，运行出错。真正重写： // 重写-description方法- (NSString *)description &#123; return [NSString stringWithFormat:@"姓名：%@ 年龄：%d", _name,_age];&#125; 37.SEL每个类的方法列表都存储在类对象中，每个方法都有一个与之对应的SEL，根据一个SEL就可以找到方法的地址，进而调用方法。SEL类型定义 typedef struct objc_selector *SEL;SEL的获取： SEL s = @selector(test);SEL s2 = NSSelectorFromString(@"test"); 将SEL转换为NSString对象:NSString *s3=NSStringFromSelector(s); 调用对象p的show方法： // 创建p对象Person *p = [[Person alloc] init];// 将show方法封装为SEL类型数据的sSEL s = @selector(show);// 调用s间接调用show方法[p performSelector:s]; 38. [p test]原理解释 把test包装成SEL类型的数据。 根据SEL数据找到对应的方法地址。 根据方法地址调用相应的方法。消息就是SEL。 39.NSLog方法总结 打印对象的内存地址 NSLog(@&quot;%p&quot;,p); 打印指针的内存地址（&amp;p取出地址） NSLog(@&quot;%p&quot;,&amp;p); 打印某一对象（默认返回类名+内存地址，可以通过重写-description方法改变输出内容） NSLog(@&quot;%@&quot;,p); 打印代码行号 NSLog(@&quot;%d&quot;,__LINE__); 打印文件路径 NSLog(@&quot;%d&quot;,__FILE__); 注意：如果文件路径中存在中文，则无法输出这时可以使用： printf(&quot;%s\n&quot;__FILE__);输出包含中文字符的路径（\n只是为了观看清晰） 打印当前函数名称 NSLog(@&quot;%s&quot;,__func__); 40.代理一系列方法的列表（不能增加成员变量）。其中声明的方法可以被任何类实现，这种模式一般称作代理（delegation）。如果一些类之间没有继承的关系，但是有某些相同的行为，这时要考虑使用代理。代理的定义：当一代理只针对某个类中，代理最好放在一个类的.h文件中，使用时引入即可。（假定在Person.h文件中） #import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@end // 要在@interface之外设置代理@protocol MyProtocol &lt;NSObject&gt;// 必须实现的方法@required- (void)show;- (void)myShow;// 可选实现的方法@optional+ (void)herShow;@end 在Dog.h文件中遵守协议： #import &lt;Foundation/Foundation.h&gt;// 声明协议@protocol MyProtocol;@protocol MyProtocol; @interface Dog : NSObject&lt;MyProtocol&gt;// 遵守某个协议// 注意导入协议文件#import "Person.h"或者声明协议@protocol MyProtocol;- (void)show;- (void)myShow;@end 当某一代理用在多个类中，协议需要放在单独创建的.h文件中此时创建的只有一个名为BigProtocol的.h文件。 #import &lt;Foundation/Foundation.h&gt; @protocol BigProtocol &lt;NSObject&gt;@required- (void)bigShow;@optional- (void)bigShow2;@end 在Cat.h文件中遵守协议 #import &lt;Foundation/Foundation.h&gt;//@protocol BigProtocol;#import "BigProtocol.h"@interface Cat : NSObject&lt;BigProtocol&gt;- (void)bigShow;@end 在Dog.h文件中遵守协议 #import &lt;Foundation/Foundation.h&gt;//@protocol BigProtocol;#import "BigProtocol.h"@interface _Dog : NSObject&lt;BigProtocol&gt;- (void)bigShow;- (void)bigShow2;@end 注意点 在遵守协议时，如果使用@protocol BigProtocol;编译器会警告：无法找到协议的定义而使用#import &quot;BigProtocol.h&quot;，则完全没有问题。 如果某个类遵守多个协议，协议之间用逗号分隔： @interface Cat : NSObject&lt;BigProtocol,MyProtocol&gt; 一个协议本身可以遵守其他协议，如遵守名字叫NSObject的协议（默认是这种情况，基协议NSObject）如果A协议遵守B协议，这时A协议就能拥有B协议的所有方法声明。 @protocol BigProtocol &lt;NSObject&gt; @end BigProtocol拥有NSObject协议的所有方法声明。 约定框架中后缀为Delegate的都是协议。（协议类似其他语言的接口，就像C#中默认以I开头的都是接口 ） 要求某个对象必须遵守某个协议（如要求obj保存的对象遵守协议MyProtocol，并且继承Person） Person&lt;MyProtocol&gt; *obj = [[Person alloc] init]; 利用conformsToProtocol:判断某个类是否实现了某个协议 Cat *c = [[Cat alloc] init ]; bool result = [c conformsToProtocol:@protocol(BigProtocol)]; NSLog(@&quot;%@&quot;,result?@&quot;YES&quot;:@&quot;NO&quot;); [c conformsToProtocol:@protocol(BigProtocol)];返回的是bool类型。 41.block块。有返回值（void也可以）、有形参。block封装了一段代码，可以在任何时候执行。block可以作为函数参数或者函数返回值，而其本身又可以带输入参数和返回值。在多线程，异步任务，集合遍历，集合排序，动画专场使用较多。 定义: 返回值类型 (^+block名称)(参数类型列表)=^(参数列表){ 代码内容 }; 注意大括号后面有分号 对比函数 int (^MySum)(int ,int )=^(int a,int b)&#123; return a+b;&#125;;int MySum (int a,int b)&#123;return a+b;&#125; block可以访问局部变量，但不能更改局部变量。如果更改则报错：Variable is not assignable (missing__block type specifier)，如： int c = 10;// Block的定义int (^MySum)(int ,int ) = ^(int a,int b) &#123; c = 21; return a + b + c;&#125;;NSLog(@"%i",MySum(10,20)); 如果硬是要修改：在局部变量前面加上__block ，如 __block int c=21;这时，便可以在block中修改局部变量了。 __block int c=10;// Block的定义int (^MySum)(int ,int ) = ^(int a,int b) &#123; c = 21; return a + b + c;&#125;;NSLog(@"%i",MySum(10,20)); block的调用，和函数一样，使用名称即可：MySum(形参列表); 如果block没有形参，则可以省略等号后面的()如： int (^SomeSum)()=^{return 25;};但是等号前面的两对括号不可省略。 利用typedef声明类型 格式：typedef 返回值类型 (^block块名称)(参数_类型列表)例如：typedef int (^MyBlock)(int,int); 以后就可以用MyBlock这种类型定义Block变量MyBlock m = ^(int a,int b)&#123;return a+b;&#125;;int c = m(15,25);NSLog(@"%i",c);]]></content>
      <tags>
        <tag>Objective-C</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
