<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ya</title>
  <subtitle>Write Less, Do More.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.chenyalun.com/"/>
  <updated>2016-12-24T08:31:30.000Z</updated>
  <id>http://blog.chenyalun.com/</id>
  
  <author>
    <name>Ya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python3入门笔记</title>
    <link href="http://blog.chenyalun.com/2016/12/20/Python3%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.chenyalun.com/2016/12/20/Python3入门笔记/</id>
    <published>2016-12-20T10:22:17.000Z</published>
    <updated>2016-12-24T08:31:30.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 人生苦短,我用Python. </p>

<a id="more"></a>
<h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><ul>
<li>让Python打印出指定的文字，可以用print()函数，然后把希望打印的文字用单引号或者双引号括起来，但不能混用单引号和双引号</li>
<li>用exit()退出Python</li>
<li>在Python交互式命令行下，可以直接输入代码，然后执行，并立刻得到结果。</li>
<li>直接输入python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。</li>
<li>print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出,会依次打印每个字符串，遇到逗号“,”会输出一个空格</li>
<li>Python提供了一个input(“提示文本,可以为空”)，可以让用户输入字符串，并存放到一个变量里。</li>
<li>以#开头的语句是注释,Python程序是大小写敏感的</li>
<li>当语句以冒号:结尾时，缩进的语句视为代码块。Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。</li>
<li>Python还允许用r’’表示’’内部的字符串默认不转义:<code>print(r&#39;\\\n&#39;)</code></li>
<li>Python允许用<code>’’’…’’’</code>的格式表示多行内容</li>
<li>一个布尔值只有True、False两种值</li>
<li>布尔值可以用and、or和not运算。</li>
<li>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</li>
<li>在Python中，通常用全部大写的变量名表示常量,事实上仍然是一个变量，Python根本没有任何机制保证不会被改变</li>
<li>/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数,//称为地板除，两个整数的除法仍然是整数</li>
<li>Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。</li>
<li>ASCII编码是1个字节，而Unicode编码通常是2个字节。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。</li>
<li>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言</li>
<li>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符</li>
<li>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示<code>x = b&#39;ABC&#39;</code></li>
<li>bytes的每个字符都只占用一个字节,以Unicode表示的str通过encode()方法可以编码为指定的bytes,<code>&#39;中文&#39;.encode(&#39;utf-8&#39;)</code>,含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错</li>
<li>在bytes中，无法显示为ASCII字符的字节，用\x##显示</li>
<li>果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法</li>
<li><p>计算str包含多少个字符，可以用len()函数,len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数,<code>len(&#39;中文&#39;)</code></p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；
第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。
</code></pre><p>字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%</p>
</li>
</ul>
<h1 id="实练"><a href="#实练" class="headerlink" title="实练"></a>实练</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div><div class="line">793</div><div class="line">794</div><div class="line">795</div><div class="line">796</div><div class="line">797</div><div class="line">798</div><div class="line">799</div><div class="line">800</div><div class="line">801</div><div class="line">802</div><div class="line">803</div><div class="line">804</div><div class="line">805</div><div class="line">806</div><div class="line">807</div><div class="line">808</div><div class="line">809</div><div class="line">810</div><div class="line">811</div><div class="line">812</div><div class="line">813</div><div class="line">814</div><div class="line">815</div><div class="line">816</div><div class="line">817</div><div class="line">818</div><div class="line">819</div><div class="line">820</div><div class="line">821</div><div class="line">822</div><div class="line">823</div><div class="line">824</div><div class="line">825</div><div class="line">826</div><div class="line">827</div><div class="line">828</div><div class="line">829</div><div class="line">830</div><div class="line">831</div><div class="line">832</div><div class="line">833</div><div class="line">834</div><div class="line">835</div><div class="line">836</div><div class="line">837</div><div class="line">838</div><div class="line">839</div><div class="line">840</div><div class="line">841</div><div class="line">842</div><div class="line">843</div><div class="line">844</div><div class="line">845</div><div class="line">846</div><div class="line">847</div><div class="line">848</div><div class="line">849</div><div class="line">850</div><div class="line">851</div><div class="line">852</div><div class="line">853</div><div class="line">854</div><div class="line">855</div><div class="line">856</div><div class="line">857</div><div class="line">858</div><div class="line">859</div><div class="line">860</div><div class="line">861</div><div class="line">862</div><div class="line">863</div><div class="line">864</div><div class="line">865</div><div class="line">866</div><div class="line">867</div><div class="line">868</div><div class="line">869</div><div class="line">870</div><div class="line">871</div><div class="line">872</div><div class="line">873</div><div class="line">874</div><div class="line">875</div><div class="line">876</div><div class="line">877</div><div class="line">878</div><div class="line">879</div><div class="line">880</div><div class="line">881</div><div class="line">882</div><div class="line">883</div><div class="line">884</div><div class="line">885</div><div class="line">886</div><div class="line">887</div><div class="line">888</div><div class="line">889</div><div class="line">890</div><div class="line">891</div><div class="line">892</div><div class="line">893</div><div class="line">894</div><div class="line">895</div><div class="line">896</div><div class="line">897</div><div class="line">898</div><div class="line">899</div><div class="line">900</div><div class="line">901</div><div class="line">902</div><div class="line">903</div><div class="line">904</div><div class="line">905</div><div class="line">906</div><div class="line">907</div><div class="line">908</div><div class="line">909</div><div class="line">910</div><div class="line">911</div><div class="line">912</div><div class="line">913</div><div class="line">914</div><div class="line">915</div><div class="line">916</div><div class="line">917</div><div class="line">918</div><div class="line">919</div><div class="line">920</div><div class="line">921</div><div class="line">922</div><div class="line">923</div><div class="line">924</div><div class="line">925</div><div class="line">926</div><div class="line">927</div><div class="line">928</div><div class="line">929</div><div class="line">930</div><div class="line">931</div><div class="line">932</div><div class="line">933</div><div class="line">934</div><div class="line">935</div><div class="line">936</div><div class="line">937</div><div class="line">938</div><div class="line">939</div><div class="line">940</div><div class="line">941</div><div class="line">942</div><div class="line">943</div><div class="line">944</div><div class="line">945</div><div class="line">946</div><div class="line">947</div><div class="line">948</div><div class="line">949</div><div class="line">950</div><div class="line">951</div><div class="line">952</div><div class="line">953</div><div class="line">954</div><div class="line">955</div><div class="line">956</div><div class="line">957</div><div class="line">958</div><div class="line">959</div><div class="line">960</div><div class="line">961</div><div class="line">962</div><div class="line">963</div><div class="line">964</div><div class="line">965</div><div class="line">966</div><div class="line">967</div><div class="line">968</div><div class="line">969</div><div class="line">970</div><div class="line">971</div><div class="line">972</div><div class="line">973</div><div class="line">974</div></pre></td><td class="code"><pre><div class="line"><span class="string">'''</span></div><div class="line">1,代码中有中文必须设置utf-8</div><div class="line">'''</div><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"></div><div class="line"><span class="comment">#2,单行注释,以#开头</span></div><div class="line"><span class="keyword">import</span> time <span class="comment">#引入时间模块</span></div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> calendar,os</div><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"><span class="comment">#爬取数据</span></div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line"><span class="comment">#指定math模块中的sqrt函数</span></div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">当你导入一个模块，Python解析器对模块位置的搜索顺序是：</div><div class="line"></div><div class="line">1.当前目录</div><div class="line">2.如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。</div><div class="line">3.如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/</div><div class="line">4.模块搜索路径存储在system模块的sys.path变量中。</div><div class="line">变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。</div><div class="line"></div><div class="line"></div><div class="line">  在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。</div><div class="line">  创建text.py文件,定义相关函数,import text 即可引用自己的模块</div><div class="line">  注意,倘若在text.py中定义并执行相关函数,其他文件引用之后,并不会执行</div><div class="line">  测试函数代码，应该是单独执行text.py文件时才会执行</div><div class="line"></div><div class="line">  from math import *</div><div class="line"></div><div class="line">  可以根据__name__变量的结果能够判断出，是直接执行的python脚本还是被引入执行的，</div><div class="line">  从而能够有选择性的执行测试代码</div><div class="line"> ''' </div><div class="line"></div><div class="line"><span class="comment">#区分文件是主动执行的，还是被调用执行的。</span></div><div class="line">如果当前文件是主动执行的，__name__ 变量的值就是：__main__，</div><div class="line">如果是被导入执行的，则是被导入的文件名</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	print(<span class="string">"是直接执行的py脚本,而非引入"</span>)</div><div class="line"><span class="comment">#3,多行注释,使用3个单引号</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#3,输出,使用print函数,字符串格式化]</span></div><div class="line"><span class="string">'''</span></div><div class="line">%c %s %i %d %u无符号十进制整数</div><div class="line">%o %x十六进制小写 %X十六进制大写 %f</div><div class="line"></div><div class="line">'''</div><div class="line"></div><div class="line">print(<span class="string">"hello world"</span>)</div><div class="line"></div><div class="line">a = <span class="number">12</span></div><div class="line">b = <span class="number">58</span></div><div class="line">c = <span class="string">"swe"</span></div><div class="line">print(<span class="string">"hello %s 这孩子 %s 啊啊啊 %s"</span>%(a,b,c))</div><div class="line"></div><div class="line">print(<span class="string">"sss"</span>,a)</div><div class="line"></div><div class="line"><span class="comment">#4,输入</span></div><div class="line">inputs = input(<span class="string">"请输入数字"</span>)</div><div class="line">print(<span class="string">"您的数字是:%s"</span>%inputs)</div><div class="line"></div><div class="line"><span class="keyword">if</span> inputs == <span class="number">12</span>:</div><div class="line">	print(<span class="string">"哈哈哈哈"</span>)</div><div class="line">	print(<span class="string">"嘻嘻嘻嘻"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> inputs != <span class="number">12</span>:</div><div class="line">	print(<span class="string">"哦哦哦哦"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#5,数据类型</span></div><div class="line"><span class="string">'''</span></div><div class="line">在python中，只要定义了一个变量，而且它有数据，那么它的类型就已经确定了</div><div class="line">可以使用type(变量的名字)，来查看变量的类型:type(a)</div><div class="line">常用的数据类型:</div><div class="line">* Numbers(包括int long float complex)</div><div class="line">* 布尔 True/False</div><div class="line">* String </div><div class="line">* List</div><div class="line">* Tuple(元组)</div><div class="line">* Dictionary</div><div class="line">'''</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#6,标识符</span></div><div class="line"><span class="comment"># 标识符由字符数字下划线组成,没有美元符号,且区分大小写</span></div><div class="line"><span class="comment"># 命名规则:驼峰式或者下划线连接</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#7,运算符</span></div><div class="line"><span class="string">'''</span></div><div class="line">* %取余 3%2</div><div class="line">* **幂 3**2  3的2次方</div><div class="line">* // 取整除</div><div class="line">* / 正常除法,可有余数</div><div class="line">* //=  **/ </div><div class="line">'''</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#8,逻辑运算 and or not</span></div><div class="line"><span class="comment"># 与</span></div><div class="line"><span class="keyword">if</span> inputs == <span class="number">15</span> <span class="keyword">and</span> a == <span class="number">12</span>:</div><div class="line">	print(<span class="string">"and"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 或</span></div><div class="line"><span class="keyword">if</span> inputs == <span class="number">15</span> <span class="keyword">or</span> b == <span class="number">58</span>:</div><div class="line">	print(<span class="string">"or"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 非</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> a == <span class="number">12</span>:</div><div class="line">	print(<span class="string">"not"</span>)</div><div class="line"></div><div class="line"><span class="comment">#9,多重判断 if 与 elif</span></div><div class="line">score = <span class="number">99</span></div><div class="line"><span class="keyword">if</span> score &lt; <span class="number">60</span>:</div><div class="line">	print(<span class="string">"不及格"</span>)</div><div class="line"><span class="keyword">elif</span> score &lt;<span class="number">80</span>:</div><div class="line">	print(<span class="string">"良好"</span>)</div><div class="line"><span class="keyword">elif</span> score &lt; <span class="number">90</span>:</div><div class="line">	print(<span class="string">"不错"</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">	print(<span class="string">"优秀"</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#10,if嵌套</span></div><div class="line"><span class="keyword">if</span> a == <span class="number">12</span>:</div><div class="line">	print(<span class="string">"a==12"</span>)</div><div class="line">	<span class="keyword">if</span> a &gt; <span class="number">12</span>:</div><div class="line">		print(<span class="string">"a&gt;12"</span>)</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		print(<span class="string">"a&lt;=12"</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">	print(<span class="string">"a!=12"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#11,while循环与循环嵌套</span></div><div class="line"><span class="keyword">while</span> a == <span class="number">12</span>:</div><div class="line">	print(<span class="string">"你不好"</span>)</div><div class="line">	a = <span class="number">13</span></div><div class="line">	<span class="keyword">while</span> b == <span class="number">58</span>:</div><div class="line">		print(<span class="string">"哈哈哈哈"</span>)</div><div class="line">		b = <span class="number">59</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#12,for循环:i从0开始,每次自增1</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</div><div class="line">	<span class="keyword">if</span> i == <span class="number">5</span>:</div><div class="line">		<span class="keyword">continue</span><span class="comment">#跳过i==5这次</span></div><div class="line">	print(<span class="string">'i=%s'</span>%i)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> i == <span class="number">10</span>:</div><div class="line">		print(<span class="string">"停止break"</span>)</div><div class="line">		<span class="keyword">break</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#13,定义函数 print1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print1</span><span class="params">()</span>:</span></div><div class="line">	print(<span class="string">"函数"</span>)</div><div class="line">	print(<span class="string">"函数"</span>)</div><div class="line"></div><div class="line">	print(<span class="string">"函数"</span>)</div><div class="line"></div><div class="line"><span class="comment">#调用函数print1</span></div><div class="line">print1()</div><div class="line"></div><div class="line"><span class="comment">#14,常用函数</span></div><div class="line"><span class="comment">#时间函数import time</span></div><div class="line">t = time.time()<span class="comment">#取出当前时间,以秒为单位的浮点小数</span></div><div class="line">t2 = time.localtime(t)<span class="comment">#取出本地时间</span></div><div class="line">t3 = time.asctime(t2) <span class="comment">#标准格式Fri Jun 10 10:58:53 2016</span></div><div class="line">print(t3)</div><div class="line"></div><div class="line"><span class="comment">#日历函数 import calendar</span></div><div class="line">cal = calendar.month(<span class="number">2016</span>,<span class="number">8</span>)</div><div class="line">print(cal) <span class="comment">#打印日历</span></div><div class="line"></div><div class="line"><span class="comment">#随机数函数 import random</span></div><div class="line">r = random.randint(<span class="number">1</span>,<span class="number">3</span>)<span class="comment">#从1到3范围内的整数,包括1和3</span></div><div class="line">print(r)</div><div class="line"></div><div class="line">r2 = random.randrange(<span class="number">1</span>,<span class="number">25</span>,<span class="number">5</span>)<span class="comment">#从1开始到25结束递增基数为5</span></div><div class="line">print(r2)</div><div class="line"></div><div class="line">r3 = random.uniform(<span class="number">1</span>,<span class="number">5</span>) <span class="comment">#最小值1最大值5,返回浮点数</span></div><div class="line">print(r3)</div><div class="line"></div><div class="line">random.random() <span class="comment">#生成0&lt;=n&lt;=1的浮点数</span></div><div class="line"></div><div class="line"><span class="comment">#15,字符串,相当于字符数组,可以通过下标取出字符,</span></div><div class="line">ss = <span class="string">"qwertyu"</span></div><div class="line">print(ss[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment">#取出下标从1到3 的字符,包括上边界,不包括下边界</span></div><div class="line">print(ss[<span class="number">1</span>:<span class="number">3</span>])</div><div class="line"></div><div class="line"><span class="comment">#从下标2开始 取到最后</span></div><div class="line">print(ss[<span class="number">2</span>:])</div><div class="line"></div><div class="line"><span class="comment">#从下标2开始到下标-2,不包括下标-2</span></div><div class="line">print(ss[<span class="number">2</span>:<span class="number">-2</span>])</div><div class="line"></div><div class="line"><span class="comment">#取出最后4个字符</span></div><div class="line">print(ss[<span class="number">-4</span>:])</div><div class="line"></div><div class="line"><span class="comment">#16,字符串常见操作</span></div><div class="line">sub = <span class="string">"my"</span></div><div class="line">s = <span class="string">"itismyapple"</span></div><div class="line"></div><div class="line"><span class="comment">#查找:检测sub是否在s中:s.find(sub, start=0, end=len(mystr))</span></div><div class="line"><span class="comment">#查找成功返回开始的索引,否则返回-1</span></div><div class="line">s.find(sub)</div><div class="line">re = s.find(sub,<span class="number">1</span>,<span class="number">8</span>)<span class="comment">#从下标1开始查找,到下标为8结束</span></div><div class="line">print(re)</div><div class="line"></div><div class="line">s.index(sub)<span class="comment">#与find相同,只不过没有找到会抛出异常</span></div><div class="line"></div><div class="line"><span class="comment">#返回 在start和end之间(包括) 在 s里面出现的次数</span></div><div class="line">c = s.count(<span class="string">"i"</span>, <span class="number">0</span>,<span class="number">8</span>)</div><div class="line">print(c)</div><div class="line"></div><div class="line"><span class="comment">#把 s 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次.</span></div><div class="line">s.replace(<span class="string">"t"</span>,<span class="string">"d"</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">#以 " " 为分隔符切片 s，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串</span></div><div class="line">s.split(<span class="string">" "</span>,<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="comment">#把字符串的第一个字符大写</span></div><div class="line">s.capitalize()</div><div class="line"></div><div class="line"><span class="comment">#检查字符串是否是以 obj 开头, 是则返回 True，否则返回 False</span></div><div class="line">s.startswith(<span class="string">"i"</span>)</div><div class="line"></div><div class="line"><span class="comment">#检查字符串是否以obj结束，如果是返回True,否则返回 False.</span></div><div class="line">s.endswith(<span class="string">"d"</span>)</div><div class="line"></div><div class="line"><span class="comment">#转换 s 中所有大写字符为小写</span></div><div class="line">s.lower()</div><div class="line"></div><div class="line"><span class="comment">#转换 s 中的小写字母为大写</span></div><div class="line">s.upper()</div><div class="line"></div><div class="line"><span class="comment">#返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</span></div><div class="line">s.ljust(<span class="number">5</span>) <span class="comment">#返回 "itismyapple     "</span></div><div class="line"></div><div class="line"><span class="comment">#返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</span></div><div class="line">s.rjust(<span class="number">5</span>) <span class="comment">#返回"     itismyapple"</span></div><div class="line"></div><div class="line"><span class="comment">#返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</span></div><div class="line"><span class="string">"s"</span>.center(<span class="number">10</span>) <span class="comment">#"    s     "</span></div><div class="line"></div><div class="line"><span class="comment">#删除 s 左边的空格</span></div><div class="line">s.lstrip()</div><div class="line"></div><div class="line"><span class="comment">#删除 s 字符串末尾的空格</span></div><div class="line">s.rstrip()</div><div class="line"></div><div class="line"><span class="comment">#类似于 find()函数，不过是从右边开始查找.</span></div><div class="line"><span class="string">"sieiess"</span>.rfind(<span class="string">"ie"</span>) <span class="comment">#返回3</span></div><div class="line"></div><div class="line"><span class="comment"># 类似于 index()，不过是从右边开始.</span></div><div class="line">s.rindex(<span class="string">"s"</span>)</div><div class="line"></div><div class="line"><span class="comment">#把"asdeeeads"以str分割成三部分,str前，str和str后</span></div><div class="line"><span class="string">"asdeeeads"</span>.partition(<span class="string">"eee"</span>)</div><div class="line"></div><div class="line"><span class="comment">#类似于 partition()函数,不过是从右边开始.</span></div><div class="line"><span class="string">"asdeeeads"</span>.rpartition(<span class="string">"eee"</span>)</div><div class="line"></div><div class="line"><span class="comment">#按照行分隔，返回一个包含各行作为元素的列表</span></div><div class="line"><span class="string">"asas\nds"</span>.splitlines()</div><div class="line"></div><div class="line"><span class="comment">#如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False</span></div><div class="line"><span class="string">"ssd"</span>.isalnum()</div><div class="line"></div><div class="line"><span class="comment">#如果 mystr 所有字符都是字母 则返回 True,否则返回 False</span></div><div class="line"><span class="string">"ssd"</span>.isalpha()</div><div class="line"></div><div class="line"><span class="comment">#如果 mystr 只包含数字则返回 True 否则返回 False.</span></div><div class="line"><span class="string">"232"</span>.isdigit()</div><div class="line"></div><div class="line"><span class="comment">#如果 mystr 中只包含空格，则返回 True，否则返回 False.</span></div><div class="line"><span class="string">" "</span>.isspace()</div><div class="line"></div><div class="line"><span class="comment">#如果 mystr 所有字符都是大写，则返回 True，否则返回 False</span></div><div class="line"><span class="string">"sd"</span>.isupper()</div><div class="line"></div><div class="line"><span class="comment">#mystr 中每个字符后面插入str,构造出一个新的字符串</span></div><div class="line"><span class="string">"sasd"</span>.join(<span class="string">"s"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#17,列表</span></div><div class="line">A = [<span class="string">"ds3s"</span>,<span class="string">"ds4s"</span>,<span class="string">"a4sd"</span>]</div><div class="line">print(A[<span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</div><div class="line">	print(a)<span class="comment">#打印每一个元素</span></div><div class="line"></div><div class="line"><span class="comment">#18,列表增加元素</span></div><div class="line">A.append(<span class="string">"asasdad"</span>)</div><div class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</div><div class="line">	print(a)<span class="comment">#打印每一个元素</span></div><div class="line"></div><div class="line"><span class="comment">#19,修改</span></div><div class="line">A[<span class="number">0</span>] = <span class="string">"1"</span></div><div class="line"></div><div class="line"><span class="comment">#20,查找</span></div><div class="line"><span class="keyword">if</span> <span class="string">"1"</span> <span class="keyword">in</span> A:</div><div class="line">	print(<span class="string">"1存在于a中"</span>)</div><div class="line"><span class="keyword">if</span> <span class="string">"1"</span> <span class="keyword">not</span> <span class="keyword">in</span> A:</div><div class="line">	print(<span class="string">"1不存在与a中"</span>)</div><div class="line"></div><div class="line"><span class="comment">#21,删除元素</span></div><div class="line"><span class="string">'''</span></div><div class="line">    del：根据下标进行删除</div><div class="line">    pop：删除最后一个元素</div><div class="line">    remove：根据元素的值进行删除</div><div class="line">'''</div><div class="line"><span class="keyword">del</span> A[<span class="number">0</span>]</div><div class="line">A.pop()</div><div class="line">A.remove(<span class="string">"ds4s"</span>)</div><div class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</div><div class="line">	print(a)<span class="comment">#打印每一个元素</span></div><div class="line"></div><div class="line"><span class="comment">#21,统计字符个数</span></div><div class="line">cstr = input(<span class="string">"请输入字符"</span>)</div><div class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cstr:</div><div class="line">	print(<span class="string">"%c:%d"</span>%(c,cstr.count(c)))</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#22,字典</span></div><div class="line">info = &#123;<span class="string">"name"</span>:<span class="string">"zhangsan"</span>,<span class="string">"age"</span>:<span class="number">12</span>&#125;</div><div class="line">print(info[<span class="string">"name"</span>])</div><div class="line"><span class="comment">#增加键值对</span></div><div class="line">info[<span class="string">"sex"</span>] = <span class="string">"man"</span></div><div class="line"></div><div class="line"><span class="comment">#删除元素</span></div><div class="line"><span class="keyword">del</span> info[<span class="string">"age"</span>]</div><div class="line"></div><div class="line"><span class="comment">#清空字典</span></div><div class="line">info.clear()</div><div class="line"></div><div class="line"><span class="comment">#删除整个字典</span></div><div class="line"><span class="keyword">del</span> info</div><div class="line"><span class="comment">#注意删除字典和清空字典的区别</span></div><div class="line"></div><div class="line"><span class="comment">#字典常用操作</span></div><div class="line">info2 = &#123;<span class="string">"name"</span>:<span class="string">"zhangsan"</span>,<span class="string">"age"</span>:<span class="number">12</span>&#125;</div><div class="line"><span class="comment">#测量字典中，键值对的个数</span></div><div class="line">len(info2)</div><div class="line"></div><div class="line"><span class="comment">#返回一个包含字典所有KEY的列表</span></div><div class="line">info2.keys()</div><div class="line"></div><div class="line"><span class="comment">#返回一个包含字典所有value的列表</span></div><div class="line">info2.values()</div><div class="line"></div><div class="line"><span class="comment">#返回一个包含所有（键，值）元组的列表</span></div><div class="line">info2.items()</div><div class="line"></div><div class="line"><span class="comment">#if "name" in info2如果key在字典中，返回True，否则返回False</span></div><div class="line"><span class="keyword">if</span> <span class="string">"name"</span> <span class="keyword">in</span> info2:</div><div class="line">	print(<span class="string">"存在"</span>)</div><div class="line"></div><div class="line"><span class="comment">#遍历键/值/键值对</span></div><div class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> info2.items():</div><div class="line">	print(key,value)</div><div class="line"></div><div class="line"><span class="comment">#23,Python的元组与列表类似，不同之处在于元组的元素不能修改。</span></div><div class="line">也可进行分片 和 连接操作. 元组使用小括号，列表使用方括号。</div><div class="line">atuple = (<span class="string">"as"</span>,<span class="number">121</span>,<span class="keyword">True</span>,<span class="keyword">False</span>,<span class="number">0</span>)</div><div class="line">atuple2 = (<span class="string">"a"</span>,<span class="number">121</span>,<span class="keyword">True</span>,<span class="keyword">False</span>,<span class="number">40</span>)</div><div class="line">print(atuple[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment">#合成新元组</span></div><div class="line">atuple3 = atuple + atuple2</div><div class="line"></div><div class="line"><span class="comment">#删除元素</span></div><div class="line"><span class="comment">#元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组</span></div><div class="line"><span class="keyword">del</span> atuple3</div><div class="line"></div><div class="line"><span class="comment">#24,元组运算符</span></div><div class="line"><span class="comment">#与字符串一样，元组之间可以使用 + 号和 * 号进行运算。</span></div><div class="line">这就意味着他们可以组合和复制，运算后会生成一个新的元组。</div><div class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) + (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line">[<span class="string">'Hi!'</span>] * <span class="number">4</span> <span class="comment">#['Hi!', 'Hi!', 'Hi!', 'Hi!']</span></div><div class="line"><span class="number">3</span> <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">#True</span></div><div class="line"></div><div class="line"><span class="comment">#25,元组索引截取</span></div><div class="line"><span class="comment">#因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素</span></div><div class="line"><span class="comment">#比较两个元组元素。</span></div><div class="line"></div><div class="line"><span class="comment">#cmp(tuple1, tuple2)</span></div><div class="line">tuple2 = (<span class="number">12</span>,<span class="number">234</span>,<span class="number">546</span>,<span class="number">56</span>)</div><div class="line">tuple2s = [<span class="number">12</span>,<span class="number">23</span>]</div><div class="line"><span class="comment">#计算元组元素个数。</span></div><div class="line">len(tuple2)</div><div class="line"><span class="comment">#返回元组中元素最大值。</span></div><div class="line">max(tuple2)</div><div class="line"><span class="comment">#返回元组中元素最小值。</span></div><div class="line">min(tuple2)</div><div class="line"><span class="comment">#将列表转换为元组。</span></div><div class="line">tuple(tuple2s)</div><div class="line"></div><div class="line"><span class="comment">#25,多维元组</span></div><div class="line">tuple3 = [(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>)]</div><div class="line">tuple3[<span class="number">1</span>] <span class="comment">#(2,5,6)</span></div><div class="line">tuple3[<span class="number">1</span>][<span class="number">0</span>] <span class="comment">#2</span></div><div class="line"></div><div class="line"><span class="comment">#26,带有参数和有返回值的函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a,b)</span>:</span></div><div class="line">	<span class="keyword">return</span> a+b</div><div class="line"></div><div class="line">print(sum(<span class="number">45</span>,<span class="number">1</span>))</div><div class="line"></div><div class="line"><span class="comment">#27,缺省函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">(a,b = <span class="number">25</span>)</span>:</span></div><div class="line">	<span class="keyword">return</span> a+b</div><div class="line">print(sum2(<span class="number">232</span>))</div><div class="line">print(sum2(<span class="number">232</span>,<span class="number">1</span>))</div><div class="line"></div><div class="line"><span class="comment">#28,不定长参数</span></div><div class="line"><span class="comment">#加了星号（*）的变量名会存放所有未命名的变量参数。</span></div><div class="line"><span class="comment">#参数以一个＊号开头的代表着一个任意长度的元组(tuple)，可以接收连续一串参数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">(a,b,*cs)</span>:</span></div><div class="line">	print(a,b)</div><div class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> cs:</div><div class="line">		print(c)</div><div class="line">printinfo(<span class="number">23</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#29,函数的嵌套使用</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print3</span><span class="params">(a,b)</span>:</span></div><div class="line">	print(a,b)</div><div class="line">	print(sum(a,b))</div><div class="line">print3(<span class="number">2</span>,<span class="number">23</span>)</div><div class="line"></div><div class="line"><span class="comment">#30,打印指定条横线</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printline</span><span class="params">()</span>:</span></div><div class="line">	print(<span class="string">"-"</span>*<span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printlinewithnum</span><span class="params">(a)</span>:</span></div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(a):</div><div class="line">		printline()</div><div class="line">		print(<span class="string">"\n"</span>)</div><div class="line"></div><div class="line">printlinewithnum(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="comment">#31,变量</span></div><div class="line"><span class="comment">#局部变量,是在函数内部定义的变量</span></div><div class="line"><span class="comment">#全局变量,能在某一函数中使用,也能在其他函数中使用</span></div><div class="line"><span class="comment">#全局变量能够在所以的函数中进行访问</span></div><div class="line"><span class="comment">#如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错</span></div><div class="line">gol = <span class="number">12</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">chnum</span><span class="params">()</span>:</span></div><div class="line">	<span class="keyword">global</span> gol <span class="comment">#声明此处的gol是特指全局变量,而非重名的局部变量</span></div><div class="line">	gol = <span class="number">13</span></div><div class="line">	print(gol)</div><div class="line">chnum()</div><div class="line">print(gol)</div><div class="line"></div><div class="line"><span class="comment">#32,递归函数,一个函数在内部调用自己</span></div><div class="line"><span class="comment">#示例:计算n的阶乘</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calnum</span><span class="params">(n)</span>:</span></div><div class="line">	i = <span class="number">1</span></div><div class="line">	result = <span class="number">1</span></div><div class="line">	<span class="keyword">while</span> i &lt;= n:</div><div class="line">		result *= i</div><div class="line">		i += <span class="number">1</span></div><div class="line">	<span class="keyword">return</span> result</div><div class="line">print(calnum(<span class="number">1</span>))</div><div class="line">print(calnum(<span class="number">0</span>))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calnum2</span><span class="params">(n)</span>:</span></div><div class="line">	<span class="keyword">if</span> n &gt;= <span class="number">1</span>:</div><div class="line">		<span class="keyword">return</span> n * calnum2(n<span class="number">-1</span>)</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span></div><div class="line">print(calnum2(<span class="number">1</span>))</div><div class="line">print(calnum2(<span class="number">0</span>))</div><div class="line"></div><div class="line"><span class="comment">#33,匿名函数</span></div><div class="line"><span class="comment">#用lambda关键词能创建小型匿名函数。</span></div><div class="line"><span class="comment">#Lambda函数能接收任何数量的参数但只能返回一个表达式的值</span></div><div class="line"><span class="comment">#匿名函数不能直接调用print，因为lambda需要一个表达式</span></div><div class="line">sum4 = <span class="keyword">lambda</span> a,b,c,d:a + b + c + d</div><div class="line">print(sum4(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>))</div><div class="line"></div><div class="line"><span class="comment">#34,位运算:直接操作二进制数</span></div><div class="line"><span class="string">'''</span></div><div class="line">&amp; 按位与 只有对应的两个二进位均为1时,结果位才为1</div><div class="line">| 按位或 只要对应的二个二进位有一个为1时,结果位就为1,否则为0</div><div class="line">^ 按位异或 不同为1 当对应的二进位相异(不相同)时,结果为1,否则为0</div><div class="line">~ 按位取反</div><div class="line">&lt;&lt; 按位左移:左移一位即乘以2,可能改变一个数的正负</div><div class="line">&gt;&gt; 按位右移::右移一位即除以2</div><div class="line">'''</div><div class="line"><span class="number">0b1011</span> &amp; <span class="number">0b1001010110</span></div><div class="line"><span class="number">0b1000110</span> | <span class="number">0b10010</span></div><div class="line"><span class="number">0b11101</span> ^ <span class="number">0b110000011</span></div><div class="line">~<span class="number">132</span></div><div class="line">print(<span class="number">12</span>&lt;&lt;<span class="number">3</span>)</div><div class="line">print(<span class="number">1024</span>&gt;&gt;<span class="number">4</span>)</div><div class="line"><span class="comment">#进制书写</span></div><div class="line"><span class="number">0o377</span> <span class="comment">#八进制</span></div><div class="line"><span class="number">0xFF</span> <span class="comment">#十六进制</span></div><div class="line"><span class="number">0b010010110</span> <span class="comment">#二进制</span></div><div class="line"></div><div class="line"><span class="comment">#进制转换</span></div><div class="line">print(type(oct(<span class="number">25</span>))) <span class="comment">#转八进制字符串</span></div><div class="line">hex(<span class="number">25</span>) <span class="comment">#转十六进制字符串</span></div><div class="line">bin(<span class="number">25</span>) <span class="comment">#转二进制字符串</span></div><div class="line"></div><div class="line"><span class="comment">#35,数据类型转换</span></div><div class="line">int(<span class="string">"123"</span>) <span class="comment">#字符串转数值</span></div><div class="line">float(<span class="string">"2324.3"</span>) <span class="comment">#将字符串转换为浮点数</span></div><div class="line">print(complex(<span class="number">1.2</span>,<span class="number">3.2</span>)) <span class="comment">#创建一个复数,在 Python 中，复数的虚部被表示为 j</span></div><div class="line">print(<span class="number">3.2</span>+<span class="number">1.4j</span>)</div><div class="line"></div><div class="line">print(str(<span class="number">23</span>)) <span class="comment">#将23转换为字符串</span></div><div class="line">print(repr(<span class="number">124</span>)) <span class="comment">#转换为表达式字符串</span></div><div class="line">tuple([<span class="number">23</span>,<span class="number">3</span>])</div><div class="line">list((<span class="number">23</span>,<span class="number">234</span>))</div><div class="line">chr(<span class="number">2</span>)</div><div class="line">ord(<span class="string">"d"</span>)</div><div class="line"></div><div class="line"><span class="comment">#35,实现乘法表</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print6</span><span class="params">()</span>:</span></div><div class="line">	i = <span class="number">1</span></div><div class="line">	<span class="keyword">while</span> i &lt;= <span class="number">9</span>:</div><div class="line">		j = i</div><div class="line">		<span class="keyword">while</span> j &lt;= <span class="number">9</span>:</div><div class="line">			print(<span class="string">"%d*%d=%d"</span>%(i,j,i*j))</div><div class="line">			j += <span class="number">1</span></div><div class="line">		i += <span class="number">1</span></div><div class="line"></div><div class="line">print6()</div><div class="line">		</div><div class="line"><span class="comment">#36,打开文件</span></div><div class="line"><span class="comment">#使用open函数，可以打开一个已经存在的文件，或者创建一个新文件</span></div><div class="line"><span class="comment">#open(文件名，访问模式) 返回文件句柄</span></div><div class="line">f = open(<span class="string">"s.txt"</span>,<span class="string">"w"</span>)</div><div class="line">f.close()<span class="comment">#关闭文件</span></div><div class="line"><span class="string">'''</span></div><div class="line">r 	以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</div><div class="line">w 	打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><div class="line">a 	打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。</div><div class="line">也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</div><div class="line"></div><div class="line">rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</div><div class="line"></div><div class="line">wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。</div><div class="line">如果该文件不存在，创建新文件。</div><div class="line"></div><div class="line">ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。</div><div class="line">也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</div><div class="line"></div><div class="line">r+ 打开一个文件用于读写。文件指针将会放在文件的开头。</div><div class="line">w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><div class="line"></div><div class="line">a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。</div><div class="line">文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</div><div class="line">rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</div><div class="line">wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><div class="line"></div><div class="line">ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。</div><div class="line">如果该文件不存在，创建新文件用于读写。</div><div class="line">'''</div><div class="line"></div><div class="line"><span class="comment">#37,写数据到文件</span></div><div class="line">f = open(<span class="string">"s1"</span>,<span class="string">"w"</span>)</div><div class="line">f.write(<span class="string">"hello world"</span>)</div><div class="line">f.close()</div><div class="line"></div><div class="line"><span class="comment">#38,读数据</span></div><div class="line">f = open(<span class="string">"s1"</span>)</div><div class="line">content = f.read(<span class="number">5</span>) <span class="comment">#读取数据长度,字节为单位</span></div><div class="line">print(content)</div><div class="line">f.close()</div><div class="line"></div><div class="line"><span class="comment">#readlines按照行的方式把整个文件中的内容进行一次性读取，返回的是一个列表，每一行的数据为一个元素</span></div><div class="line">f = open(<span class="string">"s"</span>)</div><div class="line">content2 = f.readlines()</div><div class="line">print(content2[<span class="number">2</span>])</div><div class="line">f.close()</div><div class="line"></div><div class="line"><span class="comment">#38,获取当前读写的位置</span></div><div class="line">f = open(<span class="string">"222.txt"</span>, <span class="string">"r+"</span>)</div><div class="line">f.write(<span class="string">"123243454566"</span>)</div><div class="line">str12 = f.read(<span class="number">3</span>)</div><div class="line">print(<span class="string">"读取的数据是 : "</span>,str12)</div><div class="line"></div><div class="line"><span class="comment"># 查找当前位置</span></div><div class="line">position = f.tell()</div><div class="line">print(<span class="string">"当前文件位置 : "</span>, position)</div><div class="line">f.close()</div><div class="line"><span class="comment">#如果在读写文件的过程中，需要从另外一个位置进行操作的话，可以使用seek()</span></div><div class="line"><span class="string">'''</span></div><div class="line">seek(offset, from)有2个参数</div><div class="line"></div><div class="line">    offset:偏移量</div><div class="line">    from:方向</div><div class="line">        0:表示文件开头</div><div class="line">        1:表示当前位置</div><div class="line">        2:表示文件末尾</div><div class="line"></div><div class="line">'''</div><div class="line">f = open(<span class="string">"s"</span>, <span class="string">"r"</span>)</div><div class="line">str33 = f.read(<span class="number">30</span>)</div><div class="line">print(<span class="string">"读取的数据是 : "</span>, str33)</div><div class="line"></div><div class="line"><span class="comment"># 查找当前位置</span></div><div class="line">position = f.tell()</div><div class="line">print(<span class="string">"当前文件位置 : "</span>, position)</div><div class="line"></div><div class="line"><span class="comment"># 重新设置位置</span></div><div class="line">f.seek(<span class="number">5</span>,<span class="number">0</span>)</div><div class="line">f.close()</div><div class="line"></div><div class="line"><span class="comment">#39,文件操作</span></div><div class="line"><span class="comment">#文件重命名</span></div><div class="line"><span class="comment">#需要import os</span></div><div class="line"><span class="string">'''</span></div><div class="line">#os模块中的rename()可以完成对文件的重命名操作</div><div class="line">os.rename("s1","s111")</div><div class="line"></div><div class="line">#删除文件</div><div class="line">os.remove("s111")</div><div class="line"></div><div class="line">#创建文件夹</div><div class="line">os.mkdir("haha")</div><div class="line"></div><div class="line">#获取当前目录</div><div class="line">print(os.getcwd())</div><div class="line"></div><div class="line">#改变默认目录</div><div class="line">os.chdir("../")</div><div class="line"></div><div class="line">#获取目录中内容列表,返回数组</div><div class="line">os.listdir("./")</div><div class="line"></div><div class="line">#删除文件夹</div><div class="line">os.rmdir("haha")</div><div class="line"></div><div class="line">#判断是否是目录</div><div class="line">os.path.isdir("./react")</div><div class="line"></div><div class="line">#判断是否是文件</div><div class="line">os.path.isfile("./s")</div><div class="line">'''</div><div class="line"><span class="comment">#40,捕获异常</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">	open(<span class="string">"ssss"</span>,<span class="string">"r"</span>)</div><div class="line"><span class="comment">#指定异常类型 定义异常变量</span></div><div class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> errmsg:</div><div class="line">	print(<span class="string">"捕获到异常"</span>,errmsg)</div><div class="line">	print(<span class="string">"-"</span>*<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="comment">#多个异常</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">	open(<span class="string">"ssss"</span>,<span class="string">"r"</span>)</div><div class="line"><span class="comment">#指定异常类型 定义异常变量</span></div><div class="line"><span class="keyword">except</span> (IOError,NameError) <span class="keyword">as</span> errmsg:</div><div class="line">	print(<span class="string">"捕获到异常"</span>,errmsg)</div><div class="line">	print(<span class="string">"-"</span>*<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="comment">#不指定异常</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">	open(<span class="string">"ssss"</span>,<span class="string">"r"</span>)</div><div class="line"><span class="comment">#指定异常类型 定义异常变量</span></div><div class="line"><span class="keyword">except</span> :</div><div class="line">	print(<span class="string">"捕获到异常"</span>)</div><div class="line">	print(<span class="string">"-"</span>*<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">常见异常：</div><div class="line"></div><div class="line">Exception           所有异常的基类</div><div class="line"></div><div class="line">AttributeError      特性应用或赋值失败时引发</div><div class="line"></div><div class="line">IOError             试图打开不存在的文件时引发</div><div class="line"></div><div class="line">IndexError          在使用序列中不存在的索引时引发</div><div class="line"></div><div class="line">KeyError            在使用映射不存在的键时引发</div><div class="line"></div><div class="line">NameError           在找不到名字（变量）时引发</div><div class="line"></div><div class="line">SyntaxError         在代码为错误形式时引发</div><div class="line"></div><div class="line">TypeError          在内建操作或者函数应用于错误类型的对象是引发</div><div class="line"></div><div class="line">ValueError:       </div><div class="line">在内建操作或者函数应用于正确类型的对象，但是该对象使用不合适的值时引发</div><div class="line"></div><div class="line">ZeroDivisionError  在除法或者摸除操作的第二个参数为0时引发</div><div class="line">'''</div><div class="line"><span class="comment">#finally语句</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">	open(<span class="string">"ssss"</span>,<span class="string">"r"</span>)</div><div class="line"><span class="comment">#指定异常类型 定义异常变量</span></div><div class="line"><span class="keyword">except</span> :</div><div class="line">	print(<span class="string">"捕获到异常"</span>)</div><div class="line">	print(<span class="string">"-"</span>*<span class="number">10</span>)</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">	print(<span class="string">"一定执行的语句"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#else应用</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    num = <span class="number">100</span></div><div class="line">    print(num)</div><div class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> errorMsg:</div><div class="line">        print(<span class="string">'产生错误了:%s'</span>%errorMsg)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'没有捕获到异常，真高兴'</span>)</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">        print(<span class="string">'我一定会执行的哦'</span>)</div><div class="line"></div><div class="line"><span class="comment">#41,定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line"></div><div class="line">	<span class="comment">#属性列表</span></div><div class="line">	<span class="comment">#公有属性</span></div><div class="line">	name = <span class="string">"AB"</span></div><div class="line"></div><div class="line">	<span class="comment">#私有属性,私有属性是不能够在类外通过对象名来进行访问的</span></div><div class="line">	__age = <span class="number">20</span></div><div class="line"></div><div class="line">	<span class="comment">#在类中定义的方法至少会有一个参数，，一般以名为self的变量作为该参数，而且需要作为第一个参数。</span></div><div class="line">	<span class="comment">#公有方法列表</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getName</span><span class="params">(self)</span>:</span></div><div class="line">		print(self.name)</div><div class="line"></div><div class="line">	<span class="comment">#私有方法</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getAge</span><span class="params">(self)</span>:</span></div><div class="line">		print(self.__age)</div><div class="line"></div><div class="line">	<span class="comment">#def get():报错</span></div><div class="line">	<span class="comment">#	print("无参数方法")</span></div><div class="line"></div><div class="line">	<span class="comment">#构造器方法:在创建对象后执行</span></div><div class="line">	<span class="comment">#def __init__():</span></div><div class="line">	<span class="comment">#	self.name = "QWE"</span></div><div class="line"></div><div class="line">	<span class="comment">#传递参数的构造器方法</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></div><div class="line">		self.name = name</div><div class="line"></div><div class="line">	<span class="comment">#析构方法</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">"析构方法被调用"</span>)</div><div class="line"></div><div class="line"><span class="comment">#创建对象</span></div><div class="line">p = Person(<span class="string">"zhangsan"</span>)</div><div class="line">print(p.name)</div><div class="line">p.getName()</div><div class="line"></div><div class="line"><span class="comment"># 提示找不到该属性p.__age</span></div><div class="line"><span class="comment"># 提示找不到该方法p.__getAge()</span></div><div class="line"><span class="comment">#self是对象自身的意思，在用某个对象调用该方法时，就将该对象作为第一个参数传递给self。</span></div><div class="line"></div><div class="line"><span class="keyword">del</span> p</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#42,继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">setName</span><span class="params">(self,name)</span>:</span></div><div class="line">		self.name = name</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">"学生的姓名是"</span>,self.name)</div><div class="line"></div><div class="line">stu = Student(<span class="string">"zhangsan"</span>)</div><div class="line">stu.setName(<span class="string">"李四"</span>)</div><div class="line">stu.print()</div><div class="line"></div><div class="line"><span class="comment">#  python中是可以多继承的</span></div><div class="line"><span class="comment">#  父类中的方法、属性，子类会继承</span></div><div class="line"><span class="comment">#  多继承:class HighStudent(Student,Worker)</span></div><div class="line"><span class="comment"># 假设A,B中都有方法test()</span></div><div class="line"><span class="comment">#若C继承A与B class C(A,B)  则调用A中的方法</span></div><div class="line"><span class="comment">#若C继承A与B class C(B,A)  则调用B中的方法</span></div><div class="line"><span class="comment">#若C继承A与B class C(A,B)  且C中也有test()方法,则调用C中重写的方法</span></div><div class="line"></div><div class="line"><span class="comment">#43,重写</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ani</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">"调用Ani的方法"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Ani)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">"调用Dog的方法"</span>)</div><div class="line"></div><div class="line">		</div><div class="line">dog = Dog()</div><div class="line">dog.print() <span class="comment">#调用自己的方法</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#44,多态</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">	<span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span><span class="params">(A)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">"A1"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span><span class="params">(A)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">"A2"</span>)</div><div class="line"></div><div class="line">a1 = A1()</div><div class="line">a2 = A2()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">showFunc</span><span class="params">(a)</span>:</span></div><div class="line">	a.show()</div><div class="line">		</div><div class="line">showFunc(a1)</div><div class="line">showFunc(a2)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#45,类属性</span></div><div class="line"><span class="comment">#类属性就是类对象所拥有的属性，它被所有类对象的实例对象所共有，</span></div><div class="line"><span class="comment">#内存中只存在一个副本，对于公有的类属性，在类外可以通过类对象和实例对象访问</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">object</span>:</span></div><div class="line">	name = <span class="string">"object"</span></div><div class="line"></div><div class="line">obj1 = object()</div><div class="line">obj2 = object()</div><div class="line">print(obj1.name) <span class="comment">#实例没有name,会查找类的name,结果:object</span></div><div class="line">object.name = <span class="string">"lisi"</span></div><div class="line">print(obj2.name) <span class="comment">#显示 lisi</span></div><div class="line">print(obj1.name) <span class="comment">#显示 lisi</span></div><div class="line"></div><div class="line"><span class="comment">#给实例obj1增加实例属性</span></div><div class="line">obj1.name = <span class="string">"ads"</span></div><div class="line">print(obj1.name) <span class="comment">#屏蔽掉类属性,显示ads</span></div><div class="line">print(object.name) <span class="comment">#显示 lisi</span></div><div class="line"></div><div class="line"><span class="comment">#结论:</span></div><div class="line"><span class="comment">#相同名称的实例属性将屏蔽掉类属性</span></div><div class="line"><span class="comment">#但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</span></div><div class="line"><span class="comment">#Python是动态语言,可以动态增加属性</span></div><div class="line"><span class="comment">#想要修改类属性，如果在类外，可以通过类对象修改，如果在类里面，只有在类方法中进行修改。</span></div><div class="line"></div><div class="line"><span class="comment">#46,类方法</span></div><div class="line"><span class="string">'''</span></div><div class="line">是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法</div><div class="line">对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数</div><div class="line">当然可以用其他名称的变量作为其第一个参数.</div><div class="line">但是大部分人都习惯以'cls'作为第一个参数的名字，就最好用'cls'了</div><div class="line">能够通过实例对象和类对象去访问。</div><div class="line">'''</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></div><div class="line">    country = <span class="string">'china'</span></div><div class="line"></div><div class="line">    <span class="comment">#类方法，用classmethod来进行修饰</span></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCountry</span><span class="params">(cls)</span>:</span></div><div class="line">        <span class="keyword">return</span> cls.country</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></div><div class="line">    <span class="comment">#类属性</span></div><div class="line">    price = <span class="string">"1000"</span></div><div class="line"></div><div class="line">	<span class="comment">#类方法</span></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPrice</span><span class="params">(cls,price)</span>:</span></div><div class="line">        cls.price = price</div><div class="line">        <span class="keyword">return</span> cls.price</div><div class="line"></div><div class="line">car1 = Car()</div><div class="line">print(car1.getPrice(<span class="number">200</span>))</div><div class="line"></div><div class="line"><span class="comment">#47,静态方法</span></div><div class="line"><span class="comment">#通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line">	name = <span class="string">"Tom"</span></div><div class="line"></div><div class="line"><span class="meta">	@staticmethod</span></div><div class="line">	<span class="comment">#静态方法</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getName</span><span class="params">()</span>:</span></div><div class="line">		print(Cat.name)</div><div class="line"></div><div class="line">Cat.getName()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#48,爬取数据</span></div><div class="line">response = urllib.request.urlopen(<span class="string">"http://acm.hit.edu.cn"</span>)</div><div class="line">html = response.read()</div><div class="line"><span class="comment">#中文转码</span></div><div class="line">htmlC = html.decode(<span class="string">"utf-8"</span>)</div><div class="line">print(htmlC)</div><div class="line"></div><div class="line"><span class="comment">#将网页存入文本</span></div><div class="line">f = open(<span class="string">"t.html"</span>,<span class="string">"wb"</span>)<span class="comment">#python是types格式，得用二进制读写. </span></div><div class="line">f.write(html) <span class="comment">#写入原始文件,不需要解码</span></div><div class="line">f.close()</div><div class="line"></div><div class="line"><span class="comment">#49,get参数拼接</span></div><div class="line">query = &#123;&#125;</div><div class="line">query[<span class="string">"key"</span>] = <span class="string">"python3"</span></div><div class="line">queryURL = urllib.parse.urlencode(query) <span class="comment">#得到key=python3</span></div><div class="line">url = <span class="string">"http://chenyalun.com/s?"</span> + queryURL</div><div class="line">print(url)</div><div class="line"></div><div class="line"><span class="comment">#50,使用BeautifulSoup</span></div><div class="line">html = <span class="string">"""&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></div><div class="line">    &lt;body&gt;</div><div class="line">    &lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</div><div class="line">    &lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</div><div class="line">    &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</div><div class="line">    &lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</div><div class="line">    &lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</div><div class="line">    and they lived at the bottom of a well.&lt;/p&gt;</div><div class="line">    &lt;p class="story"&gt;...&lt;/p&gt;</div><div class="line">    """</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line">soup = BeautifulSoup(html)</div><div class="line">print(soup.prettify())</div><div class="line"></div><div class="line"><span class="comment">#打印标签</span></div><div class="line">print(<span class="string">"标题是:"</span>,soup.title)</div><div class="line"></div><div class="line">print(<span class="string">"头部是"</span>,soup.head)</div><div class="line"></div><div class="line">print(<span class="string">"第一个a标签"</span>,soup.a)</div><div class="line"></div><div class="line">print(<span class="string">"第一个p标签"</span>,soup.p)</div><div class="line"></div><div class="line"><span class="comment">#它查找的是在所有内容中的第一个符合要求的标签</span></div><div class="line"><span class="comment">#标签的两个重要的属性:name 和 attrs</span></div><div class="line">print(soup.a.name)</div><div class="line">print(soup.p.attrs)</div><div class="line"><span class="comment">#属性的值</span></div><div class="line">print(<span class="string">"属性的值"</span>,soup.p.attrs[<span class="string">"name"</span>]) </div><div class="line">print(<span class="string">"属性的值"</span>,soup.p[<span class="string">"name"</span>])<span class="comment">#attrs可以省略</span></div><div class="line"></div><div class="line"><span class="comment">#用 .string获取文字</span></div><div class="line">print(soup.p.string)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#利用"CSS选择器"查找标签</span></div><div class="line"><span class="comment">#通过标签名查找</span></div><div class="line">print(soup.select(<span class="string">"title"</span>))</div><div class="line"></div><div class="line"><span class="comment">#通过类名查找</span></div><div class="line">print(soup.select(<span class="string">".sister"</span>))</div><div class="line"></div><div class="line"><span class="comment">#通过id查找</span></div><div class="line">print(soup.select(<span class="string">"#link1"</span>))</div><div class="line"></div><div class="line"><span class="comment">#组合查找</span></div><div class="line">print(soup.select(<span class="string">"p #link1"</span>)) <span class="comment">#格式同CSS</span></div><div class="line"></div><div class="line"><span class="comment">#直接子标签查找</span></div><div class="line">print(soup.select(<span class="string">"head &gt; title"</span>))</div><div class="line"></div><div class="line"><span class="comment">#属性查找</span></div><div class="line"><span class="comment">#属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格</span></div><div class="line">print(soup.select(<span class="string">'a[class="sister"]'</span>))</div><div class="line">print(soup.select(<span class="string">'a[href="http://example.com/elsie"]'</span>))</div><div class="line">print(soup.select(<span class="string">'p a[href="http://example.com/elsie"]'</span>))</div><div class="line"></div><div class="line"><span class="comment"># select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容</span></div><div class="line"><span class="keyword">for</span> title <span class="keyword">in</span> soup.select(<span class="string">"title"</span>):</div><div class="line">	print(title.get_text)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 人生苦短,我用Python. &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.chenyalun.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.chenyalun.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>HTML/CSS/JavaScript学习笔记</title>
    <link href="http://blog.chenyalun.com/2016/12/06/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20/"/>
    <id>http://blog.chenyalun.com/2016/12/06/前端学习笔记 /</id>
    <published>2016-12-06T04:22:17.000Z</published>
    <updated>2016-12-24T09:21:36.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 大前端时代. </p>

<a id="more"></a>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul>
<li><code>&lt;html&gt;&lt;/html&gt;</code>是根标签,<code>&lt;heal&gt;</code>定义文档的头部,常包含<code>&lt;title&gt; &lt;script&gt;</code></li>
<li><code>&lt;style&gt; &lt;meta&gt; &lt;link&gt;</code></li>
<li><code>&lt;em&gt;</code>表示强调，<code>&lt;strong&gt;</code> 表示更强烈的强调。并且在浏览器中<code>&lt;em&gt;</code> 默认用斜体表示，<code>&lt;strong&gt;</code>用粗体表示。</li>
<li><code>&lt;span&gt;</code>标签是没有语义的，它的作用就是为了设置单独的样式用的。</li>
<li>用<code>&lt;q&gt;</code>标签引用别人的语句,是对简短文本的引用:加上双引号</li>
<li><code>&lt;blockquote</code>是长文本引用:整体缩进</li>
<li>空标签现在一般使用 xhtml1.0 的版本的写法,如<code>&lt;br/&gt; &lt;img/&gt; &lt;hr/&gt;</code></li>
<li>在html代码中输入空格、回车都是没有作用的。要想输入空格，必须写入<code>&amp;nbsp;</code>。</li>
<li><code>&lt;adress&gt;</code>标签,添加地址:显示为斜体</li>
<li><code>&lt;code&gt;</code>标签:添加一行代码,<code>&lt;pre&gt;</code>预显示格式标签,被包围在 pre 元素中的文本通常会保留空格和换行符:添加一段代码(会转换其中的<code>&lt;br/&gt;</code>等)</li>
<li>ul-li是没有前后顺序的信息列表:每项li前都自带一个圆点</li>
<li>ol-li是有前后顺序的信息列表:每项li前都自带一个序号,序号默认从1开始</li>
<li>容器标签<code>&lt;div&gt;</code>,为网页划分独立的版块,给div命名:添加唯一的id属性，使逻辑更加清晰<br>创建表格的五个元素：`table、tr(一行)、th(表格表头)、td(一个单元格,有几个说明就有几列,表格中列的个数，取决于一行中数据单元格的个数。),</li>
<li>注意<code>tbody</code>:当表格内容非常多时，表格会下载一点显示一点，但如果加上<tbody>标签后，这个表格就要等表格内容全部下载完才会显示。注意1、table表格在没有添加css样式之前，在浏览器中显示是没有表格线的 2、表头，也就是th标签中的文本默认为粗体并且居中显示</tbody></li>
<li><code>&lt;table summary=&quot;表格简介文本&quot;&gt;</code>添加表格摘要,表格摘要并不会显示,<code>&lt;caption&gt;标题文本&lt;/caption&gt;</code>添加表格标题,显示在表格上方居中,需要包含在table标签中</li>
<li><code>&lt;a  href=&quot;目标网址&quot;  title=&quot;鼠标滑过显示的文本&quot;&gt;链接显示的文本&lt;/a&gt;</code>,title属性的作用，鼠标滑过链接文字时会显示这个属性的文本内容。加入a标签后，文字的颜色就会自动变为蓝色（被点击过的文本颜色为紫色）</li>
<li>新窗口打开超链接<code>&lt;a href=&quot;目标网址&quot; target=&quot;_blank&quot;&gt;click here!&lt;/a&gt;</code></li>
<li>使用mailto协议发送电子邮件,<code>mailto://abc@qq.com?&amp;cc=abcd@qq.com&amp;bcc=ab@qq.com&amp;subject=主题&amp;body=邮件内容</code>,其中,cc表示抄送,bcc表示密件抄送</li>
<li>插入图片语法<code>&lt;img src=&quot;图片地址&quot; alt=&quot;下载失败时的替换文本&quot; title = &quot;提示文本&quot;&gt;</code></li>
<li>表单是可以把浏览者输入的数据传送到服务器端,语法:<code>&lt;form   method=&quot;传送方式&quot;   action=&quot;服务器文件&quot;&gt;</code>,action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。method ： 数据传送的方式（get/post）</li>
<li><p>文本输入框input的类型:<code>text：文本框 password：密码框 raido：单选按钮 checkbox：复选框 file：文件选择框 submit：提交按钮,reset:重置</code></p>
<pre><code>&lt;form&gt;
   &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt;
&lt;/form&gt;`其中name为文本框命名,方便后台使用,value为文本框设置默认值,一般起提示作用

文本输入域`&lt;textarea  rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt;`,在&lt;textarea&gt;&lt;/textarea&gt;标签之间可以输入默认值。注意这两个属性可用css样式的width和height来代替：col用width、row用height来代替。
</code></pre></li>
<li>单选框与复选框:注意:同一组的单选按钮，name 取值一定要一致</li>
<li><p>下拉列表:</p>
<pre><code>&lt;select&gt;
  &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt;
  &lt;option value=&quot;旅游&quot;&gt;旅游&lt;/option&gt;
  &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt;
  &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt;
&lt;/select&gt;` value为向服务器提交的值,设置selected=“selected”属性,则默认选中.
</code></pre></li>
<li>下拉列表也可以进行多选操作，在<code>&lt;select&gt;</code>标签中设置multiple=”multiple”属性，就可以实现多选功能，在 windows 操作系统下，进行多选时按下Ctrl键同时进行单击（在 Mac下使用 Command +单击），可以选择多个选项。</li>
<li><p>form表单中的label标签:用于显示提示文本,并且当用户点击label时,将焦点转移到与之对应的控件(常用输入框)上,但是标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。 </p>
<pre><code>&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;
&lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt;
</code></pre></li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><ul>
<li>css 样式由选择符和声明组成，而声明又由属性和值组成,属性和值之间用英文冒号“：”分隔。当有多条声明时，中间可以英文分号“;”分隔,最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号。</li>
<li>CSS中有注释语句：用<code>/*</code>注释语句<code>*/</code>来标明,（Html中使用<code>&lt;!--注释语句--&gt;</code>)</li>
<li>内联式css样式表就是把css代码直接写在现有的HTML标签中，注意要写在元素的开始标签里,css样式代码要写在style=””双引号中，如果有多条css样式代码设置可以写在一起，中间用分号隔开</li>
<li><p>嵌入式css样式，写在当前的文件中.嵌入式css样式必须写在<code>&lt;style&gt;&lt;/style&gt;之间</code>，并且一般情况下嵌入式css样式写在<code>&lt;head&gt;&lt;/head&gt;</code>之间。注意设置style的type属性.</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
span{
   color:blue;
}
&lt;/style&gt;
</code></pre></li>
<li>外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以“.css”为扩展名，在<code>&lt;head&gt;</code>内（不是在<code>&lt;style&gt;</code>标签内）使用<code>&lt;link&gt;</code>标签将css样式文件链接到HTML文件内,<code>&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</code>,<code>rel=&quot;stylesheet&quot; type=&quot;text/css&quot;</code>是固定写法不可修改。<code>&lt;link&gt;</code>标签位置一般写在<code>&lt;head&gt;</code>标签之内。</li>
<li>标签选择器; <code>标签名称{css样式代码;}</code></li>
<li>类选择器:<code>.类选器名称{css样式代码;}</code></li>
<li>ID选择器:<code>#id名称{css样式代码;}</code></li>
<li>子选择器:即大于符号(&gt;),用于选择指定标签元素的第一代子元素(只能是孩子)。<code>.food&gt;li{border:1px solid red;}</code></li>
<li>包含选择器:加入空格,用于选择指定标签元素下的后辈元素。<code>.first  span{color:red;}</code></li>
<li>通用选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素</li>
<li>伪类选择符:<code>a:hover{color:red;}</code></li>
<li>分组选择符:为html中多个<strong>标签元素</strong>设置同一个样式（，)<code>h1,span{color:red;}</code></li>
<li>类选择器和ID选择器的区别:1.ID选择器只能在文档中使用一次,类选择器可以使用多次,也即id选择器(名称)具有唯一性;2.可以使用类选择器词列表方法为一个元素同时设置多个样式。也即一个元素可以具有多个类,但只能有一个id:<code>&lt;span class=&quot;stress bigsize&quot;&gt;三年级&lt;/span&gt;</code></li>
<li><code>border:1px solid red;相当于border-width:1px;//边框宽度    border-style:solid; //边框风格    border-color:red; //边框颜色</code></li>
<li>继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。<code>border:1px solid red;</code>无法继承.</li>
<li>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于最后面的css样式会被应用。</li>
<li>继承是指标签的样式可以由子代继承，但有些标签是不能继承的，eg：border。<br>特殊性指用用权重来确定最后起作用的样式，id=100，class=10，标签=1，继承=0.1；<br>层叠指当权重相同时，后面的样式覆盖前面的样式。<br>important的使用。</li>
<li>浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式，但记住!important优先级样式是个例外，权值高于用户自己设置的样式。<code>p{color:red !important;}</code>注意分号放在!important的后面</li>
<li>任意浏览器的默认字体高度16px（16像素）。所有未经调整的浏览器都符合:1em=16px。为了简化font-size的换算，需要在css中的body选择器中声明font-size=62.5%，这就使em值变为16px*62.5%=10px,这样12px=1.2em,10px=1em,也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。注：建议不要使用em作为中文站点的文字单位，会导致文字变形十分严重的。em的值并不是固定的； em会继承父级元素的字体大小。</li>
<li><p>图片居中，不能直接对img标签使用<code>text-align:center;</code>而是对该img标签所在的div或者其他块级元素使用才会达到这种效果。</p>
<pre><code>字体:`font-family:”Microsoft Yahei”;`
文字颜色,字号:`font-size:12px;color:#666`
文字粗体:`font-weight:bold;`
文字斜体:`font-style:italic;`
文字下划线;`text-decoration:underline;`
文字删除线:`text-decoration:line-through;`
文本缩进:`text-indent:2em;`两个空格
行间距(行高):`line-height:2em;`
设置文字间隔或者字母间隔:`letter-spacing:50px;`注意：这个样式使用在英文单词时，是设置字母与字母之间的间距。
单词间距:`word-spacing:50px;`
为块状元素中的文本、图片设置居中样式:`text-align:center;`
常用的块状元素有：`&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;`
常用的内联元素有：`&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;`
常用的内联块状元素有：`&lt;img&gt;、&lt;input&gt;`
</code></pre></li>
<li>块状元素都自带换行效果；内联元素都是定义行内小区域且不换行，但如果没有内容就没有意义，不占空间；内联块状元素除了不换行，即使没有内容也会占空间。</li>
<li>在html中<code>&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;</code>就是块级元素。设置<code>display:block</code>就是将元素显示为块级元素。</li>
<li>将内联元素转换为块级元素:<code>a{display:block;}</code></li>
<li>块级元素特点：1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）2、元素的高度、宽度、行高以及顶和底边距都可设置。3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</li>
<li>在html中，<code>&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;</code>就是典型的内联元素（行内元素）（inline）元素。当然块状元素也可以通过代码<code>display:inline</code>将元素设置为内联元素。<code>display:inline;</code></li>
<li>内联元素特点：1、和其他元素都在一行上；2、元素的高度、宽度及顶部和底部边距不可设置；3、元素的宽度就是它包含的文字或图片的宽度，不可改变。</li>
<li>联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码<code>display:inline-block</code>就是将元素设置为内联块状元素。(css2.1新增)，<code>&lt;img&gt;、&lt;input&gt;</code>标签就是这种内联块状标签。</li>
<li>inline-block 元素特点：1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置。</li>
<li>边框:<code>border:2px  solid  red;</code>对应:<code>border-width:2px;border-style:solid;border-color:red;</code>border-style（边框样式）常见样式有：<br>dashed（虚线）| dotted（点线）| solid（实线）。border-width（边框宽度）中的宽度也可以设置为：thin | medium | thick（但不是很常用），最常还是用像素（px）</li>
<li>单独设置下边框:<code>border-bottom:1px solid red;</code> top right left bottom</li>
<li>css内定义的宽（width）和高（height），指的是填充以里的内容范围。因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</li>
<li>元素与其它元素之间的距离可以使用边界（margin）来设置。</li>
<li>元素内容与边框之间是可以设置距离的，称之为“填充”<code>padding-top</code>。 顺时针:上 右 下 左  或者 上下 左右 或者 上下左右</li>
<li>CSS包含3种基本的布局模型，用英文概括为：Flow、Layer 和 Float。在网页中，元素有三种布局模型：1、流动模型（Flow）2、浮动模型 (Float)3、层模型（Layer）</li>
<li>流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。流动布局模型具有2个比较典型的特征：第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）</li>
<li>块状元素这么霸道都是独占一行，设置元素浮动就可以实现让两个块状元素并排显示。<br>任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动.<code>float:left;</code></li>
<li>层布局模型就像是图像软件PhotoShop中非常流行的图层编辑功能一样，每个图层能够精确定位操作.CSS定义了一组定位（positioning）属性来支持层布局模型。层模型有三种形式：1、绝对定位(position: absolute)2、相对定位(position: relative)3、固定定位(position: fixed)</li>
<li>设置position:absolute(表示绝对定位)，作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。对于以前位置(<strong>右上角</strong>）向左移动100像素，向下移动20像素。<code>right:100px;   top:20px;</code>right的是让right的margin变为100px，同理top是让top的margin变为20px，所以要向右和向下移。</li>
<li>如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。<code>position:relative;    left:100px;    top:50px;</code>（相对于以前位置<strong>左上角</strong>）向右移动100像素，向下移动50像素。</li>
<li>absolute表里如一，移动了就是移动了。relative只是表面显示移动了，但实际还在文档流中原有位置，别的元素无法占据。</li>
<li>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与<code>background-attachment:fixed;</code>属性功能相同。</li>
<li>使用<code>position:relative</code>,相对于其它元素进行定位,参照定位的元素必须是相对定位元素的前辈元素;参照定位的元素必须加入position:relative;定位元素加入position:absolute，便可以使用top、bottom、left、right来进行偏移定位了</li>
<li><p>参照物不是浏览器</p>
<pre><code>#box1{
    width:200px;
    height:200px;
    position:relative;        
    }

#box2{
    position:absolute;
    top:20px;
    left:30px;
    } //box2就可以相对于父元素box1定位
</code></pre></li>
<li><p>设置的颜色是16进制的色彩值时，如果每两位的值相同，可以缩写一半。<code>p{color:#000000;} == p{color:#000;} p{color: #336699;}==p{color: #369;}</code></p>
</li>
<li>字体的缩写<code>body{    font:12px/1.5em  &quot;宋体&quot;,sans-serif;}</code>1、使用这一简写方式你至少要指定 font-size 和 font-family 属性，其他的属性(如 font-weight、font-style、font-varient、line-height)如未指定将自动使用默认值。2、在缩写时 font-size 与 line-height 中间要加入“/”斜扛。</li>
<li>设置颜色值的三种方式:1,英文命令.2.RGB <code>p{color:rgb(133,45,200);}</code>每一项在0-255之间,也可以是百分数<code>p{color:rgb(20%,33%,25%);}</code>.3.十六进制(较普遍)<code>p{color:#00ffff;}</code></li>
<li><p>长度单位</p>
<pre><code>目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。
1、像素
像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS规范中假设“90像素=1英寸”）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。
2、em
就是本元素给定字体的 **font-size 值**，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。如下代码：
p{font-size:12px;text-indent:2em;}
上面代码就是可以实现段落首行缩进 24px（也就是两个字体大小的距离）。
下面注意一个特殊情况：
但当给 font-size 设置单位为 em 时，此时计算的标准以 p 的父元素的 font-size 为基础。如下代码：
html:
&lt;p&gt;以这个&lt;span&gt;例子&lt;/span&gt;为例。&lt;/p&gt;
css:
p{font-size:14px}
span{font-size:0.8em;}
结果 span 中的字体“例子”字体大小就为 11.2px（14 * 0.8 = 11.2px）。
3、百分比
p{font-size:12px;line-height:130%}
设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。
</code></pre></li>
<li><p>水平居中设置-行内元素:如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 <code>text-align:center</code>来实现的。</p>
</li>
<li>水平居中设置-定宽块状元素:当被设置元素为 块状元素 时用 <code>text-align：center</code>就不起作用了，这时也分两种情况：定宽块状元素和不定宽块状元素。定宽块状元素：块状元素的宽度width为固定值。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。</li>
<li><p>水平居中设置-不定宽块状元素方法（一）:(不定宽块状元素：块状元素的宽度width不固定。)不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）:1.加入 table 标签,为这个 table 设置“左右 margin 居中”（这个和定宽块状元素的方法一样,利用table标签的长度自适应性,可以看做一个定宽度块元素)<br>2.设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置3.设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的</p>
<pre><code>&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;&lt;td&gt;
    &lt;ul&gt;
        &lt;li&gt;我是第一行文本&lt;/li&gt;
        &lt;li&gt;我是第二行文本&lt;/li&gt;
        &lt;li&gt;我是第三行文本&lt;/li&gt;
    &lt;/ul&gt;
    &lt;/td&gt;&lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
或者直接设置`display:table; margin:0 auto;
`也即 .wrap{background:#ccc;display:table;margin:0 auto;
}
</code></pre></li>
<li><p>水平居中设置-不定宽块状元素方法（二）:改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。它将块状元素的 display 类型改为 inline，变成了行内元素，所以少了一些功能，比如设定长度值。</p>
</li>
<li>水平居中设置-不定宽块状元素方法（三）:通过给父元素设置 float值为left，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。</li>
<li>垂直居中-父元素高度确定的单行文本:设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。这种文字行高与块高一致带来了一个弊端：当文字内容的长度大于块的宽时，就有内容脱离了块。</li>
<li>垂直居中-父元素高度确定的多行文本（方法一）:插入 table标签，同时设置 vertical-align：middle。</li>
<li>垂直居中-父元素高度确定的多行文本（方法二）:设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式, 兼容性比较差。    <code>display:table-cell;/*IE8以上及Chrome、Firefox*/    vertical-align:middle;/*IE8以上及Chrome、Firefox*/</code></li>
<li>隐性改变display类型:有一个有趣的现象就是当为元素（不论之前是什么类型元素，display:none 除外）设置以下 2 个句之一： 1. position : absolute  2. float : left 或 float:right 简单来说，只要html代码中出现以上两句之一，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。</li>
</ul>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><ul>
<li>我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。放在<head>部分最常用的方式是在页面中head部分放置script&gt;元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。</head></li>
<li><p>放在<body>部分JavaScript代码在网页读取到该语句的时候就会执行。注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。</body></p>
<pre><code> &lt;script type=&quot;text/javascript&quot;&gt;
  document.write(&quot;I love JS&quot;)
&lt;/script&gt;
</code></pre></li>
<li>单行注释，在注释内容前加符号 “//”。多行注释以”/<em>“开始，以”</em>/“结束。</li>
<li>1.变量必须使用字母、下划线(<em>)或者美元符(<code>$</code>)开始。2.然后可以使用任意多个英文字母、数字、下划线(</em>)或者美元符(<code>$</code>)组成。 3.不能使用JavaScript关键词与JavaScript保留字。变量要先声明再赋值，JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。</li>
<li>document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。第一种:输出内容用””括起，直接输出””号内的内容。第二种:通过变量，输出内容.第三种:输出多项内容，内容之间用+号连接。第四种:输出HTML标签，并起作用，标签使用<code>&quot;&quot;</code>括起来。<code>document.write(mystr+&quot;&lt;br&gt;&quot;);</code></li>
<li>js输出空格:<code>&quot;&amp;nbsp;”</code>或者<code>document.write(&quot;&lt;span style=&#39;white-space:pre;&#39;&gt;&quot;+&quot;  1        2    3    &quot;+&quot;&lt;/span&gt;”);</code>输出时添加<code>“white-space:pre;”</code>样式属性。这个样式表示”空白会被浏览器保留”</li>
<li>JavaScript-警告（alert 消息对话框）</li>
<li><p>JavaScript-确认（confirm 消息对话框）弹出对话框(包括一个确定按钮和一个取消按钮)。 <code>confirm(str);</code>当用户点击”确定”按钮时，返回true当用户点击”取消”按钮时，返回false</p>
<pre><code>function rec(){
   var mymessage=confirm(&quot;你好棒&quot;)         ;
   if(mymessage==true)
   {
       document.write(&quot;你是女士!&quot;);
   }
   else
   {
       document.write(&quot;你是男士!&quot;);
   }
 }    
</code></pre></li>
<li><p>JavaScript-提问（prompt 消息对话框）弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。<code>prompt(str1, str2);</code>str1: 要显示在消息对话框中的文本，不可修改,str2：文本框中的内容，可以修改.1. 点击确定按钮，文本框中的内容将作为函数返回值2. 点击取消按钮，将返回null.注:在用户点击对话框的按钮前，不能进行任何其它操作。</p>
<pre><code>score =  prompt(&quot;哈喽哈&quot;,&quot;默认值&quot;);
if(score&gt;=90)
{
   document.write(&quot;你很棒!&quot;);
}
</code></pre></li>
<li><p>JavaScript-打开新窗口（window.open）<code>window.open([URL], [窗口名称], [参数字符串])</code></p>
<pre><code>           URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。
          窗口名称：可选参数，被打开窗口的名称。                  

 1.该名称由字母、数字和下划线字符组成。
 2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。
    _blank：在新窗口显示目标网页
    _self：在当前窗口显示目标网页
    _top：框架网页中在上部窗口中显示目标网页
 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。
4.name 不能包含有空格。
</code></pre></li>
<li><p>参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。toolbar工具栏,scrollbars滚动条,status状态栏menubar菜单栏 值为yes/no 窗口宽高度width/height以及窗口顶部/左端距离屏幕顶部的像素数top/left  </p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt; window.open(&apos;http://www.imooc.com&apos;,
&apos;_blank&apos;,&apos;width=300,height=200,
menubar=no,toolbar=no, status=no,scrollbars=yes’)
    &lt;/script&gt;
</code></pre></li>
</ul>
<ul>
<li><p>JavaScript-关闭窗口（window.close）</p>
<pre><code> window.close();   //关闭本窗口
 &lt;窗口对象&gt;.close();   //关闭指定的窗口
 &lt;script type=&quot;text/javascript&quot;&gt;
   var mywin=window.open(&apos;http://www.imooc.com&apos;); //将新打的窗口对象，存储在变量mywin中
   mywin.close();
&lt;/script&gt;
</code></pre></li>
<li>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</li>
<li><p>HTML文档可以说由节点构成的集合，三种常见的DOM节点:1. 元素节点：上图中<code>&lt;html&gt;、&lt;body&gt;、&lt;p&gt;</code>等都是元素节点，即标签。2. 文本节点:向用户展示的内容，如<code>&lt;li&gt;...&lt;/li&gt;</code>中的JavaScript、DOM、CSS等文本。3. 属性节点:元素属性，如<code>&lt;a&gt;</code>标签的链接属性<code>href=&quot;http://www.chenyalun.com&quot;</code>。</p>
</li>
<li><p>通过ID获取元素:<code>document.getElementById(“id”)</code>,返回<code>[object HTMLParagraphElement]</code> ,注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。用<code>document.getELementById().innerHTML;</code>才可以获取到其中的内容.</p>
</li>
<li>innerHTML 属性用于获取或替换 HTML 元素的内容。Object.innerHTML,1.Object是获取的元素对象，如通过document.getElementById(“ID”)获取的元素。2.注意书写，innerHTML区分大小写。</li>
<li>改变 HTML 样式:<code>Object.style.property=new style;</code>例如:<code>mychar.style.color=red;</code></li>
<li>显示和隐藏（display属性）Object.style.display = value,其中value为none隐藏,value为block块级元素显示.其中none与block要加上引号</li>
<li>控制类名（className 属性）className 属性设置或返回元素的class 属性。<code>object.className = classname</code>作用:1.获取元素的class 属性2. 为网页内的某个元素指定一个css样式来更改该元素的外观</li>
<li>删除修改的样式:<code>document.getElementById(&quot;txt&quot;).removeAttribute(&quot;style&quot;);</code></li>
<li>外部引入JS <code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></li>
<li>变量:字母数字下划线美元符,变量名区分大小写,不允许使用关键字保留字</li>
<li>变量也可以不声明，直接使用，但为了规范，需要先声明，后使用。</li>
<li>“+”连接字符串时,符号两边不能有空格</li>
<li><code>jq1=numa + 30 &gt;10 &amp;&amp; numb * 3&lt;20;</code>算术操作符 → 比较操作符 → 逻辑操作符 → “=”赋值符号</li>
<li>定义数组: <code>var myarr=new Array();  myarr[0]=80;</code>实际上数组都是变长的,即使指定了长度为8，仍然可以将元素存储在规定长度以外。</li>
<li>创建数组:<code>var myarr = new Array(11,25,35); var myarr = [12,25,416];</code></li>
<li>只需使用下一个未用的索引，任何时刻可以不断向数组增加新元素。<code>myarray[5]=88; //使用一个新索引，为数组增加一个新元素</code></li>
<li>数组的属性:length长度</li>
<li>二维数组的表示:<code>myarray[ ][ ]</code>,简单定义:<code>var Myarr = [[0 , 1 , 2 ],[1 , 2 , 3]]</code>,也可以使用循环,myarr[0][1]=5; //将5的值传入到数组中，覆盖原有值。</li>
<li><code>==先转换类型再比较，===先判断类型，如果不是同一类型直接为false。</code></li>
<li>函数调用的两种情况:1.script标签中直接调用,2.点击按钮调用onClick事件</li>
<li>有参数的函数:<code>function 函数名(参数1,参数2){     函数代码}</code>,参数不要声明类型</li>
<li><code>function add2(x,y){   sum = x + y;   return sum; //返回函数值,return后面的值叫做返回值。}</code></li>
<li>事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。</li>
<li><p>常用JS事件:</p>
<pre><code>onclick鼠标单击事件
onmouseover鼠标经过事件
onmouseout鼠标移开事件
onchange文本框**内容**改变事件,一般是textarea
onselect文本框**内容**选中事件,一般是textarea
onfocus光标聚焦
onblur光标移开
onload网页加载后,事件会在页面加载完成后，立即发生，同时执行被调用的程序。
加载页面时，触发onload事件，**事件写在&lt;body&gt;标签内**。
onunload卸载事件,当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，
同时执行被调用的程序。该事件目前只对IE起作用。
</code></pre></li>
<li><p>使用parseInt()函数可解析一个字符串,并返回一个整数。</p>
</li>
<li>JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。对象的属性：反映该对象某些特定的性质的，如：字符串的长度、图像的长宽等；对象的方法：能够在对象上执行的动作。例如，表单的“提交”(Submit)，时间的“获取”(getYear)等；</li>
</ul>
<h2 id="Date日期对象"><a href="#Date日期对象" class="headerlink" title="Date日期对象"></a>Date日期对象</h2><ul>
<li><p>日期对象,使用关键字new，Date()的首字母必须大写。</p>
<pre><code>// 日期的相关属性与方法
get/setDate() 返回设置日期
get/setFullYear()  返回设置年份,用四位数表示
get/setYear() 返回/设置年份
get/setMonth() 返回/设置月份
get/setHours() 返回/设置小时,24小时制
get/setMinutes() 返回/设置分钟数
get/setSeconds() 返回/设置秒钟数
get/setTime() 返回/设置时间(毫秒为单位)
getDay() 返回星期，返回的是0-6的数字，0 表示星期天。
</code></pre></li>
<li><p>使用 String 对象的 toUpperCase() 方法来将字符串小写字母转换为大写.使用toLowerCase()方法，将字符串所有大写字母都变成小写的字符串</p>
</li>
<li>charAt() 方法可返回指定位置的字符。返回的字符是长度为 1 的字符串。</li>
<li>注意：1.字符串中第一个字符的下标是 0。最后一个字符的下标为字符串长度减一（string.length-1）。2.如果参数 index 不在 0 与 string.length-1 之间，该方法将返回一个空字符串。</li>
<li>indexOf(,) 方法可返回某个指定的字符串值在字符串中首次出现的位置。1.该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 substring。2.可选参数，从stringObject的startpos位置开始查找substring，如果没有此参数将从stringObject的开始位置查找。3.如果找到一个 substring，则返回 substring 的第一次出现的位置。stringObject 中的字符位置是从 0 开始的。</li>
<li>split(separator,limit) 方法将字符串分割为字符串数组，并返回此数组。注意：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。separator必须,从该参数指定的地方分割stringObject,limite,可选参数,分割的次数,如果设置该参数,则返回的子串不会多于这个参数指定的数组,如果无参数,则不限定次数</li>
<li>substring(起始位置,可选的结束位置(不包含该位置的字符)) 方法用于提取字符串中介于两个指定下标之间的字符。注意：1. 返回的内容是从 start开始(包含start位置的字符)到 stop-1 处的所有字符，其长度为 stop 减start。2. 如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。3. 如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。</li>
<li>substr() 方法从字符串中提取从 startPos位置开始的指定数目的字符串。<code>stringObject.substr(startPos,length)</code>  注意：如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。如果startPos为负数且绝对值大于字符串长度，startPos为0。</li>
<li>string.substring( 起点 ， 终点 )  string.substr( 起点 ，长度 )</li>
<li>Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。</li>
</ul>
<h2 id="MATH常用属性方法"><a href="#MATH常用属性方法" class="headerlink" title="MATH常用属性方法"></a>MATH常用属性方法</h2><ul>
<li><p>MATH</p>
<pre><code>E 返回算数常量e(约为2.71828)
LN2 返回2的自然对数
LN10 返回10的自然对数
LOG2E 返回以2为底的e的对数
LOG10E 返回以10为底的e的对数
PI 圆周率
SQRT1_2 返回2的平方根的倒数
SQRT2 返回2 的平方根
MATH常用方法
abs(x) 返回数的绝对值
acos(x) 返回数的反余弦值
asin(x) 返回数的反正弦值
atan(x) 返回数的反正切值
atan2(y,x)返回由x轴到点(x,y)的角度(以弧度为单位)
ceil(x)对数进行上舍入
cos(x) 返回数的余弦
exp(x) 返回e的指数
floor(x)对数进行下舍入
log(x) 返回数的自然对数
max(x,y) 返回最高值
min(x,y) 返回最小值
pow(x,y) 返回x的y 次方
random() 返回0--1之间的随机数
round(x) 把数四舍五入最为接近的数
sin(x) 正弦
cos(x) 余弦
tan(x) 正切
sqrt(x) 平方根
toSourse() 返回该对象的源代码
value() 返回MATH对象的原始值
</code></pre></li>
</ul>
<h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><ul>
<li><p>数组</p>
<pre><code>concat() 连接两个或更多的数组,并返回结果
join() 把数组的所有元素放入一个字符串,元素通过指定的分隔符分割
pop() 删除并返回数组的最后一个元素
push() 向数组的末尾添加一个或更多元素,并返回新的长度
reverse() 颠倒数组元素的顺序
shift() 删除并返回数组的第一个元素
slice(start,可选的end) 从某个已有的数组返回选定的元素
sort() 对数组的元素进行排序
splice() 删除元素,并向数组添加新元素
toSource() 返回该对象的源代码
toString() 把数组转换为字符串,并返回结果
toLocalString() 把数组转化为本地数组,并返回结果
unshift() 向数组的开头添加一个或者更多元素,并返回新的长度()
valueOf() 返回数组对象的原始值
</code></pre></li>
</ul>
<h2 id="window对象方法"><a href="#window对象方法" class="headerlink" title="window对象方法"></a>window对象方法</h2><ul>
<li><p>window</p>
<pre><code>alert() 显示带有一段消息和一个确定按钮的警告框
prompt() 显示可以提示用户输入的对话框
confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框
open() 打开一个新的浏览器窗口或者查找一个已命名的窗口
close() 关闭浏览器窗口
print() 打印当前窗口的内容
focus() 把键盘焦点给予一个窗口
blur() 把键盘焦点从顶层窗口移开
moveBy() 相对窗口的当前坐标移动指定的像素
moveTo() 把窗口的左上角移动一个指定的坐标
resizeBy() 按照指定的像素调整窗口的大小
resizeTo() 把窗口的大小调整到指定的宽度和高度
scrollBy() 按照指定的像素滚动内容
scrollTo() 把内容滚动到指定的坐标
setInterval(代码,间隔时间) 每隔一定时间执行代码(间隔性触发计时器),在执行时,从载入页面后每隔指定的时间执行代码。代码:函数或代码串,如”clock()”或者clock,交互时间:以毫秒为单位.返回该定时器
setTimeout() 在指定的时间延迟后指定代码(一次性计时器)
clearInterval() 取消setInterval() 的设置,传入定时器
clearTimeout() 取消setTimeout() 的设置
</code></pre></li>
</ul>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><ul>
<li><p>history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。<code>window.history.[属性|方法]</code></p>
<pre><code>length 返回浏览器历史列表的URL数量
back() 加载history列表中前一个URL
forward() 加载history列表下一个URL
go(number) 加载history列表某一个具体的页面,0:当前页面
back()相当于go(-1),forward()相当于go(1)
</code></pre></li>
</ul>
<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><ul>
<li><p>location用于获取或设置窗体的URL，并且可以用于解析URL。<code>location.[属性|方法]</code></p>
<pre><code>hash 设置或返回从#开始的URL(锚点)
host 设置或返回主机名和当前URL的端口号
hostname 设置或返回当前URL的主机名
href 设置或返回完成的URL
pathname 设置或返回当前URL的路径部分
port 设置或返回当前URL的端口号
protocol 设置或返回当前URL的协议
search 设置或者返回从?开始的URL(查询部分)
assign() 加载新的文档
reload() 重新加载当前文档
replace() 用新的文档替换当前文档
</code></pre></li>
</ul>
<h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><ul>
<li><p>navigator 对* navigator 对象包含有关浏览器的信息</p>
<pre><code>appCodeName 浏览器代码名的字符串表示
appName 浏览器的名称
appVersion 浏览器平台以及版本
platform 运行浏览器的操作系统平台
userAgent 返回user-agent头部的值
</code></pre></li>
</ul>
<h2 id="window中的screen-对象"><a href="#window中的screen-对象" class="headerlink" title="window中的screen 对象"></a>window中的screen 对象</h2><ul>
<li>window.screen 对象在编写时可以不使用 window 这个前缀。</li>
<li><p>screen对象用于获取用户的屏幕信息。<code>window.screen.属性</code>    </p>
<pre><code>height 屏幕的高度,单位像素
width  屏幕的宽度,单位像素
availHeight 窗口可用的屏幕高度,单位像素,减去界面特性，比如任务栏。
availWidth 窗口可用的屏幕宽度,单位像素,减去界面特性，比如任务栏。
colorDepth 用户浏览器表示的颜色位数,通常32位(每像素的位数)
pixelDepth 浏览器颜色位数,通常32位(每像素的位数)(IE不支持)
</code></pre></li>
</ul>
<h2 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h2><ul>
<li><p>节点属性与方法</p>
<pre><code>nodeName 返回一个字符串,其内容是给定节点的名字
nodeType 返回一个整数,这个数值代表给定节点的类型
nodeValue 返回给定节点的当前值
innerHTML 节点内置文本
childNodes 返回一个数组,这个数组由给定元素节点的子节点构成
firstChild 返回第一个子节点
lastChild 返回最后一个子节点
parentNode 返回一个给定节点的父节点
nextSibling返回给定节点的下一个子节点
previousSibling 返回给定节点的上一个子节点
document.createElement(&quot;elementType&quot;) 创建一个新的元素节点

document.cr    document.createTextNode(&quot;text&quot;) 创建一个包含着给定文本的新文本节点,text为文本
appendChild(node) 指定节点的最后一个子节点列表后添加一个新的子节点
insertBefore(newnode,node) 将一个给定节点插入到一个给定元素节点的给定节点前面
removeChild(node) 从一个给定元素中删除一个子节点
replaceChild(newnode,oldnew) 把一个给定元素里的一个子节点替换为另外一个节点
</code></pre><h3 id="docuument常用方法"><a href="#docuument常用方法" class="headerlink" title="docuument常用方法"></a>docuument常用方法</h3></li>
<li>document.getElementsByName(name) 返回带有指定名称的节点对象的集合。与getElementById() 方法不同的是，通过元素的 name 属性查询元素，而不是通过 id 属性</li>
<li>document.getElementsByTagName(Tagname)  Tagname是标签的名称，如p、a、img等标签名。和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。</li>
<li>elementNode.getAttribute(name),其中elementNode：使用getElementById()、getElementsByTagName()等方法，获取到的元素节点.name：要想查询的元素节点的属性名字.</li>
<li>elementNode.setAttribute(name,value),name: 要设置的属性名。value: 要设置的属性值。把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。</li>
<li><p>在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：nodeName : 节点的名称,nodeValue ：节点的值,nodeType ：节点的类型</p>
</li>
<li><p>nodeName 属性: 节点的名称，是只读的。</p>
<pre><code>1. 元素节点的 nodeName 与标签名相同
2. 属性节点的 nodeName 是属性的名称
3. 文本节点的 nodeName 永远是 #text
4. 文档节点的 nodeName 永远是 #document
</code></pre></li>
<li><p>nodeValue 属性：节点的值</p>
<pre><code>1. 元素节点的 nodeValue 是 undefined 或 null
2. 文本节点的 nodeValue 是文本自身
3. 属性节点的 nodeValue 是属性的值
</code></pre></li>
<li><p>nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型:</p>
<pre><code>元素类型    节点类型
  元素          1
  属性          2
  文本          3
  注释          8
  文档          9
</code></pre></li>
<li><p>elementNode.childNodes,访问子节点.</p>
</li>
<li>node.firstChild,node.lastChild,访问子节点的第一项,最后一项,如果选定的节点没有子节点，则该属性返回 NULL。</li>
<li>elementNode.parentNode,获取指定节点的父节点,父节点只能有一个。览器兼容问题，chrome、firefox等浏览器标签之间的空白也算是一个文本节点。</li>
<li><code>nodeObject.nextSibling,nodeObject.previousSibling</code>,访问兄弟节点</li>
<li>appendChild(newnode),在指定节点的最后一个子节点列表之后添加一个新的子节点。</li>
<li>removeChild(),把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。如果要完全删除对象，给 x 赋 null 值</li>
<li><code>document.documentElement.clientHeight</code>表示HTML文档所在窗口的当前高度。,<code>window.innerHeight</code>- 浏览器窗口的内部高度,<code>document.body.clientHeight</code>,Document对象的body属性对应HTML文档的<body>标签</body></li>
<li><p>通用解决方案:</p>
<pre><code>var w=document.documentElement.scrollWidth
   || 
   document.body.scrollWidth;
var h=document.documentElement.scrollHeight
   || 
   document.body.scrollHeight;
</code></pre></li>
</ul>
<ul>
<li>网页尺寸:scrollHeight和scrollWidth，获取网页内容高度和宽度。scrollHeight 是网页内容实际高度，可以小于 clientHeight。scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。</li>
<li><p>通用解决方案:</p>
<pre><code>var w=document.documentElement.scrollWidth || 
document.body.scrollWidt h;
var h=document.documentElement.scrollHeight || 
document.body.scrollHeight;
</code></pre></li>
<li><p>offsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。</p>
</li>
<li><p>通用解决方案</p>
<pre><code>var w= document.documentElement.offsetWidth || 
document.body.offsetWidth;
var h= document.documentElement.offsetHeight || 
document.body.offsetHeight;       
</code></pre></li>
<li><p>scrollLeft:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。</p>
</li>
<li>scrollTop:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。</li>
<li>offsetLeft:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。</li>
<li>offsetTop:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。</li>
<li>offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。</li>
<li>clientHeight,大家对 clientHeight 都没有什么异议，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个工具条以下到状态栏以上的这个区域，与页面内容无关。</li>
<li>offsetHeight,IE、Opera 认为 offsetHeight = clientHeight + 滚动条 + 边框。,NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。</li>
<li>scrollHeight,IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。,NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。</li>
<li>浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;</li>
<li>JavaScript不区分整数和浮点数，统一用Number表示</li>
<li>NaN;NaN表示Not a Number，当无法计算结果时用NaN表示.Infinity;Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</li>
<li><code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；<br>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。始终坚持使用===比较</li>
<li>NaN这个特殊的Number与所有其他值都不相等，包括它自己,唯一能判断NaN的方法是通过isNaN()函数,<code>isNaN(NaN); // true</code></li>
<li>Swift用nil，Python用None表示,JavaScript用null</li>
<li>JavaScript的数组可以包括任意数据类型。</li>
<li>JavaScript的对象是一组由键-值组成的无序集合,JavaScript对象的键都是字符串类型，值可以是任意数据类型。</li>
<li>变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。</li>
<li>如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量,在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误,启用strict模式的方法是在JavaScript代码的第一行写上：<code>&#39;use strict&#39;;</code></li>
<li><code>`你好, ${name}, 你今年${age}岁了!</code>;`注意不是单引号</li>
<li>直接给Array的length赋一个新的值会导致Array大小的变化,如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化</li>
<li>空数组继续pop不会报错，而是返回undefined,如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉</li>
<li>空数组继续shift不会报错，而是返回undefined</li>
<li>splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素,从索引2开始删除3个元素,然后再添加两个元素:<code>arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook’);</code></li>
<li>concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里</li>
<li>unshift()和push()对应,头部添加若干元素,shift()和pop()对应删除末尾元素.</li>
<li><p>声明对象</p>
<pre><code>var person = {
name : “AA”,
age : 12,
&apos;m-s&apos;: &apos;No&apos;,// 非有效变量
sex : true
};
// 访问:person.name;  person[&apos;m-s&apos;]; person.a;
// 访问不存在的属性不报错，而是返回undefined
// 自由增加属性:person.b = 12;
// 删除属性 delete person.age;
// 检测对象以及父类具有某属性 &apos;name&apos; in person 返回布尔
// 检测某对象具有某属性 person.hasOwnProperty(&apos;name&apos;); 返回布尔
</code></pre></li>
<li><p>JavaScript把null、undefined、0、NaN和空字符串’’视为false，其他值一概视为true</p>
</li>
<li>for (var index in array) {// 此处的index是索引而非array中的元素}</li>
<li><p>Map是一组键值对的结构，具有极快的查找速度。<br><code>var m = new Map([[&#39;Michael&#39;, 95], [&#39;Bob&#39;, 75], [&#39;Tracy&#39;, 85]]); m.get(&#39;Michael&#39;); // 95</code><br>常用操作:</p>
<pre><code>var m = new Map(); // 空Map
m.set(&apos;Adam&apos;, 67); // 添加新的key-value
m.set(&apos;Bob&apos;, 59);
m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: true
m.get(&apos;Adam&apos;); // 67
m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;
m.get(&apos;Adam&apos;); // undefined
</code></pre></li>
<li><p>Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。<code>var s2 = new Set([1, 2, 3]); // 含1, 2, 3</code>.通过add(key)方法可以添加元素到Set中,通过delete(key)方法可以删除元素</p>
</li>
<li>遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for … of循环来遍历。</li>
<li>for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。索引+属性</li>
<li>for … of循环则完全修复了这些问题，它只循环集合本身的元素,元素本身</li>
<li><p>forEach遍历</p>
<pre><code>var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];
a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
    alert(element);
});

var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);
s.forEach(function (element, sameElement, set) {
    alert(element);
});

var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);
m.forEach(function (value, key, map) {
    alert(value);
});
</code></pre></li>
<li>JavaScript允许传入任意个参数而不影响调用,传入的参数比定义的少也没有问题</li>
<li>JavaScript还有一个关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。类似数组不是数组</li>
<li><p>不在任何函数内定义的变量就具有全局作用域。全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。</p>
<pre><code>// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = &apos;myapp&apos;;
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return &apos;foo&apos;;
};
</code></pre></li>
<li>JavaScript的变量作用域实际上是函数内部,用let替代var可以申明一个块级作用域的变量,const来定义常量，const与let都具有块级作用域</li>
<li>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字</li>
<li>非strict环境下:直接使用this没毛病,strict环境下:函数内部首先写上var that = this;之后使用that</li>
<li>据是否是strict模式，this指向undefined或window</li>
<li>apply()把参数打包成Array再传入；  call()把参数按顺序传入。</li>
<li>简单的高阶函数:一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</li>
<li><p>map():对<strong>数组</strong>中的每一个且仅是单独的元素执行操作,</p>
<pre><code>// 把每一个元素转化为字符串 ,得到的仍是数组
array.map(String)

// 执行pow()
function pow(x) {
    return x * x;
}
array.map(pow),得到的仍是数组
</code></pre></li>
<li><p>reduce():对<strong>数组</strong>中的最开始两个元素进行操作,将结果与第三个元素操作,以此类推</p>
<pre><code>// 数组求和
arr.reduce(function (x, y) {
    return x + y;
});
</code></pre></li>
<li><p>filter():根据传入的函数,作用于每一个元素,返回true或false,把数组中的某些元素过滤掉,返回剩余的元素</p>
<pre><code>var r = arr.filter(function (s) {
    return  x % 2 !== 0; 
            });
arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]
</code></pre></li>
<li>sort():排序,默认把所有元素先转换为String再排序,传入的排序函数,根据返回-1进行排序</li>
<li><p>箭头函数:在箭头函数中,可以直接使用this,而非that</p>
<pre><code>x =&gt; x*x
// 相当于
function (x) {
return x*x;
}
// 含有多条语句,多个参数时
(x,y) =&gt; {
if (x &gt;0 ) {
return 0;
}
return x*y;
}
// 不能省略{}
// 特别注意返回一个对象:
x =&gt; ({ foo: x })
</code></pre></li>
<li><p>generator和函数不同的是，generator由function*定义,除了return语句，还可以用yield返回多次。调用generator对象有两个方法，一是不断地调用generator对象的next()方法,第二个方法是直接用for … of循环迭代generator对象</p>
</li>
<li>用typeof操作符获取对象的类型，它总是返回一个字符串:’number’,’boolean’,’string’,’function’,’object’,’undefined’,特别注意null的类型是object，Array的类型也是object</li>
<li>包装对象:<code>var n = new Number(123);</code>,返回object</li>
<li>JavaScript的月份范围用整数表示是0~11，0表示一月，1表示二月</li>
<li>RegExp中:在正则表达式中，如果直接给出字符，就是精确匹配。<code>用\d可以匹配一个数字，\w可以匹配一个字母或数字,.可以匹配任意字符，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符,\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格</code></li>
<li>更精确的匹配,[]表示范围:<code>[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线,[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串,[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）,A|B可以匹配A或B,^表示行的开头，^\d表示必须以数字开头。$表示行的结束，\d$表示必须以数字结束。js也可以匹配&#39;jsp&#39;，但是加上^js$就变成了整行匹配，就只能匹配&#39;js&#39;了</code></li>
<li><p>JavaScript有两种方式创建一个正则表达式：第一种方式是直接通过/正则表达式/写出来，第二种方式是通过new RegExp(‘正则表达式’)创建一个RegExp对象。</p>
<pre><code>var re1 = /as\_32/; // 最好,不用考虑转义问题
var re2 = new RegExp(“as\\_32”);
// 如果使用第二种写法，因为字符串的转义问题，字符串的两个\\实际上是一个\

//RegExp对象的test()方法用于测试给定的字符串是否符合条件
re1.test(&apos;sfdf&apos;);// 返回false
</code></pre></li>
<li><p>用()表示的就是要提取的分组（Group）,exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。exec()方法在匹配失败时返回null</p>
<pre><code>var re = /^(\d{3})-(\d{3,8})$/;
re.exec(&apos;010-12345&apos;); // [&apos;010-12345&apos;, &apos;010&apos;, &apos;12345&apos;]
</code></pre></li>
<li>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符,加个?就可以让\d+采用非贪婪匹配</li>
<li><code>g表示全局匹配,var r1 = /test/g;// 等价于:var r2 = new RegExp(&#39;test&#39;, &#39;g&#39;);指定i标志，表示忽略大小写，m标志，表示执行多行匹配</code></li>
<li>注意,在范围匹配[]中,字符要加上反斜杠\,在一般匹配中不需要</li>
<li><code>[a-zA-Z_]其实就是\w</code></li>
<li>JSON序列化:JSON.stringify(object,[propertyName:value],’  ‘); 第二个参数用于控制如何筛选对象的键值，标明指定属性可以输出指定的属性,也可以传入函数进行处理,可以不写,第三个参数是缩进</li>
<li>反序列化:JSON.parse()把它变成一个JavaScript对象</li>
<li>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。<code>xiaoming.__proto__ = Student;</code></li>
<li>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</li>
<li>如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;</li>
<li>造函数首字母应当大写，而普通函数首字母应当小写</li>
</ul>
<p><br></p>
<p>花了一个周末学习一下前端方面的知识,笔记略微粗糙,复习时再做修正.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 大前端时代. &lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.chenyalun.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://blog.chenyalun.com/tags/HTML/"/>
    
      <category term="CSS" scheme="http://blog.chenyalun.com/tags/CSS/"/>
    
      <category term="JavaScript" scheme="http://blog.chenyalun.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>读「王中周博客」</title>
    <link href="http://blog.chenyalun.com/2016/11/10/%E8%AF%BB%E7%8E%8B%E4%B8%AD%E5%91%A8%E5%8D%9A%E5%AE%A2/"/>
    <id>http://blog.chenyalun.com/2016/11/10/读王中周博客/</id>
    <published>2016-11-10T08:02:17.000Z</published>
    <updated>2016-12-28T10:03:08.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 许多鞭辟入里的文章. </p>

<a id="more"></a>
<p>标注的文章:<br><a href="http://blog.csdn.net/wzzvictory/article/details/22417181" target="_blank" rel="external">Core Animation系列之CADisplayLink</a> </p>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/17694129" target="_blank" rel="external">Objective-C高级编程：iOS与OS X多线程和内存管理</a> </p>
<h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>零零碎碎花了一个多星期才把博客看完,文章比较详细,许多底层的东西我读了好几遍才理解,受益匪浅,把重要的知识点记下来,作复习之用.</p>
<h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><ol>
<li><p>self 是类的隐藏的参数，指向当前调用方法的类，另一个隐藏参数是 _cmd，代表当前类方法的 selector。</p>
</li>
<li><p>super 只是一个“编译器指示符”(编译器特性)，它和 self 指向的是相同的消息接收者。不同的是，super 告诉编译器，要去调用父类的方法，而不是本类里的。</p>
</li>
<li><p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法。</p>
</li>
<li><p>消息发送</p>
</li>
</ol>
<p><code>id objc_msgSend(id theReceiver, SEL theSelector, ...)</code></p>
<p>以<code>[self setName:]</code> 为例，编译器会替换成调用<code>objc_msgSend</code> 的函数调用，其中 theReceiver 是 self，theSelector 是 <code>@selector(setName:)</code>，这个 selector 是从当前 self 的 class 的方法列表开始找的 setName，当找到后把对应的 selector 传递过去。</p>
<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
struct objc_super {
    id receiver;
   Class superClass;
};
</code></pre><p> 而当使用<code>[super setName]</code> 调用时，会使用 <code>objc_msgSendSuper</code> 函数，结构体包含了两个成员，一个是 receiver，这个类似objc_msgSend 的第一个参数 receiver，第二个成员是记录所谓的“父类”。从 objc_super 结构体指向的 superClass 的方法列表开始找 setName 的 selector，找到后再以 <code>objc_super-&gt;receiver</code> 去调用这个 selector。</p>
<ol>
<li><p>NSNotification使用的是同步操作，如果想让NSNotification的post处和observer处异步执行，可以通过NSNotificationQueue实现。</p>
</li>
<li><p>对于同一个通知，如果注册了多个观察者，则这多个观察者的执行顺序和他们的注册顺序是保持一致的。observer的回调方法执行线程和post的线程保持一致，如果想让post的线程和转发的线程不同，可以通过NSNotification重定向技术实现。</p>
</li>
<li><p>addObserver和removeObserver必须成对出现，或者说添加了Observer必须适时移除Observer。因为通知中心并不retain Observer，若不移除，会极易给释放的对象发送消息。</p>
</li>
</ol>
<ol>
<li><p>普屏中1点 = 1像素，Retina屏：1点 = 2像素。人手指的最小点击范围是44pixels，所以在iPhone的很多细节上都是44 pixels。</p>
</li>
<li><p>使用图片资源时，方法：<code>[UIImage imageNamed:@&quot;adflower.png&quot;]]</code>，在实际运行时，如果发现当前的设备是Retina屏，会自动寻找图片”adflower@2x.png”。</p>
</li>
<li><p><code>[UIScreen mainScreen].applicationFrame</code>获取app尺寸(去掉状态栏)，<code>[ UIScreen mainScreen].bounds</code>获取屏幕尺寸，<code>[[UIApplicationsharedApplication] statusBarFrame]</code>状态栏尺寸。</p>
</li>
</ol>
<ol>
<li><p>在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是类对象(class object),它是一个单例(singleton),这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。</p>
</li>
<li><p>任何直接或间接继承了NSObject的类，它的实例对象(instance objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个  <strong>实例对象(instace object)</strong>  所属的类的定义的一切：包括变量，方法，遵守的协议等等。</p>
</li>
<li><p>类对象并不是类的实例本身。它没有自己的实例变量，也不能执行类的实例的方法。</p>
</li>
<li><p>类对象是一个功能完整的对象，也能被动态识别（dynamically typed），接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量），只是在运行时产生实例的代理。</p>
</li>
<li><p>类对象是元类对象的一个实例，元类是根元类(root class’s metaclass)的实例,而根元类是其自身的实例，即根元类的isa指针指向自身。</p>
</li>
<li><p>一个消息发送给任何一个对象， 方法的检查 从对象的 isa 指针开始，然后是父类。实例方法在类中定义， 类方法 在元类和根类中定义。（根类的元类就是根类自己）。</p>
</li>
<li><p>类对象(class object)中包含了类的实例变量、实例方法的定义，而元类对象(metaclass object)中包括了类的类方法的定义。类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。</p>
</li>
<li><p>①object_getClass跟随实例的isa指针，返回此实例所属的类，对于实例对象(instance)返回的是类(class),对于类(class)则返回的是元类(metaclass),<br>②<code>- class</code>方法对于实例对象(instance)会返回类(class),但对于类(class)则不会返回元类(metaclass),而只会返回类本身。<br>③class_isMetaClass可判断某类是否为元类.<br>④使用objc_allocateClassPair可在运行时创建新的类与元类对，使用class_addMethod和class_addIvar可向类中增加方法和实例变量，最后使用objc_registerClassPair注册后，就可以使用此类了。</p>
</li>
</ol>
<ol>
<li>alloc方法</li>
</ol>
<p>通过alloc或allocWithZone方法创建对象时，</p>
<ol>
<li>cocoa会遍历该对象所有的成员变量，通过成员变量的类型来计算所需占用的内存返回一个未”初使化“过的对象。</li>
<li>将该新对象的引用计数(Retain Count)设置成1。</li>
<li>该新对象的isa成员变量指向它的类对象。</li>
<li>将该新对象的所有其它成员变量的值设置成零。（根据成员变量类型的不同，零有可能是指nil或0）</li>
<li>返回指向该对象的一个指针。</li>
</ol>
<ol>
<li>init方法</li>
</ol>
<p>大部分情况下，我们都不希望所有成员变量都是零，所以</p>
<p>①init方法做初使化工作，让对象的成员变量的值符合我们程序逻辑中的初始化状态。<br>②返回真正可以使用的指向该对象的指针</p>
<p>某些情况下，init会造成alloc的原本空间不够用，而进行第二次分配内存空间。所以下面的写法是错的：</p>
<pre><code>NSString  *s=[NSString alloc];

[s init];// 这儿init返回的地址可能会变。s原本的指针地址可能是无效的地址。
</code></pre><p>正确的写法是<code>NSString  *s=[[NSString alloc] init];</code></p>
<p>new简单地等价于 alloc + init，但不能指定init的参数，很少用。</p>
<ol>
<li>NSInteger是一个有符号型int，它与int的区别就在于NSInteger可以自动识别机器是32位还是64位。NSInteger的无符号版本是NSUInteger。</li>
</ol>
<ol>
<li><p>运行时<br>消息只有到运行时才会和函数实现绑定起来，而不是按照编译好的逻辑一成不变的执行。编译阶段只是确定了要去向receiver对象发送message消息，但是却没有发送，真正发送是等到运行的时候进行。 </p>
</li>
<li><p>NSObject 类定义了description方法,返回该类内容的字符串表示。</p>
</li>
<li><p>某些 NSObject 的方法只是简单地从运行时系统中获得信息,从而允许对象进行一定程度的自我检查。<br>例如,class 返回对象的类;<code>isKindOfClass:</code>和 <code>isMemberOfClass:</code>则检查对象是否在指定的 类继承体系中;<code>respondsToSelector:</code>检查对象能否响应指定的消息;<code>conformsToProtocol:</code> 检查对象是否实现了指定协议类的方法;<code>methodForSelector:</code>则返回指定方法实现的地址。</p>
</li>
</ol>
<p>①message（消息）<br>message 是一种抽象，包括了函数名+参数列表，并没有实际的实体存在。<br>②method（方法）<br>method是真正的存在的代码。如：<code>- (int)meaning { return 42; }</code><br>③selector（方法选择器）<br>selector 通过SEL类型存在，描述一个特定的method 或者说 message。在实际编程中，可以通过selector进行检索方法等操作。</p>
<ol>
<li><p>方法选择器仅仅是一个<code>char *</code>指针，仅仅表示它所代表的方法名字。</p>
<pre><code>typedef struct objc_selector *SEL;  
    SEL selector = @selector(message); //@selector不是函数调用，只是给编译器的一个提示   
    NSLog (@&quot;%s&quot;, (char *)selector); //print message   
</code></pre></li>
<li><p>Objective-C在编译的时候，会根据方法的名字，生成一个用来区分这个方法的唯一的一个ID，这个ID就是SEL类型的（生成唯一的SEL）。只要方法的名字相同，那么它们的ID都是相同的。</p>
</li>
</ol>
<ol>
<li>编译器会根据每个方法的方法名为那个方法生成唯一的SEL，这些SEL组成了一个Set集合，这个Set简单的说就是一个经过了优化过的hash表。SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，从而加快方法的查询速度。</li>
</ol>
<ol>
<li>IMP <code>typedef id (*IMP)(id, SEL, ...);</code><br>由于每个方法都对应唯一的SEL，可以通过SEL方便、快速、准确的获得它所对应的IMP（也就是函数指针），而在取得了函数指针之后，也就意味着取得了执行这段方法的代码的入口，这样就可以像普通的C语言函数调用一样使用这个函数指针。</li>
</ol>
<pre><code>void (* performMessage)(id,SEL);//定义一个IMP（函数指针）   
performMessage = (void (*)(id,SEL))
[self methodForSelector:@selector(message)];
//通过methodForSelector方法根据SEL获取对应的函数指针   

performMessage(self,@selector(message));
//通过取到的IMP（函数指针）跳过runtime消息传递机制，直接执行message方法。
</code></pre><ol>
<li>用IMP 的方式，省去了runtime消息传递过程中所做的一系列动作，比直接向对象发送消息高效一些。</li>
</ol>
<ol>
<li>消息调用流程<br>消息表达式[receiver message]在被转换成objc_msgSend(receiver, SEL)后，在运行时，runtime system会做以下事情：</li>
</ol>
<ul>
<li><p>1、检查忽略的Selector（比如将会忽略retain和release消息）。</p>
</li>
<li><p>2、检查receiver是否为nil。（如果receiver为空，则会将 selector也设置为空，并且直接返回到消息调用的地方。）如果对象非空，就继续下一步。</p>
</li>
<li><p>3、根据SEL到当前类中查找对应的IMP，首先会在cache中检索它，如果找到了就根据函数指针跳转到这个函数执行，否则进行下一步。</p>
</li>
<li><p>4、检索当前类对象中的方法表（method list），如果找到了，加入cache中，并且就跳转到这个函数执行，否则进行下一步。</p>
</li>
<li><p>5、从父类中寻找,直到根类：NSObject类。找到了就将方法加入对应类的cache表中，如果仍未找到，则要进入动态方法决议。</p>
</li>
<li><p>6、如果动态方法决议仍不能解决问题，只能进行最后一次尝试，进入消息转发流程。</p>
</li>
</ul>
<p>注意：cache的原则就是缓存那些可能要执行的函数地址，下次调用的时候，速度就可以快速很多。</p>
<ol>
<li><p>类方法和实例方法中，都可以访问self和_cmd这两个属性，因为它们都不属于类的实例变量，而是形参。</p>
</li>
<li><p>objc_msgSend找到方法对应的实现时,将直接调用该方法实现,并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:<br><em>接收消息的对象（也就是self指向的内容）
</em>方法选标（_cmd指向的内容）</p>
</li>
</ol>
<p>”隐藏“：因为它们并没有在定义方法的源代码中声明,而是在代码编译时是插入方法的实现中的。在方法中可以通过 self 来引用消息接收者对象,通过选标_cmd 来引用方法本身。</p>
<pre><code>- (void)message  
{  
    self.name = @&quot;James&quot;;//通过self关键字给当前对象的属性赋值  
    SEL currentSel = _cmd;//通过_cmd关键字取到当前函数对应的SEL  
    NSLog(@&quot;currentSel is :%s&quot;,(char *)currentSel);  
} 
</code></pre><ol>
<li>当被调用的方法实现部分没有找到，而消息转发机制启动之前的这个中间时刻(动态添加方法)。<code>+(BOOL) resolveInstanceMethod:(SEL) sel</code>将被调用。这是NSObject根类提供的类方法。</li>
<li><p>@dynamic关键字的作用:①告诉编译器不要创建实现属性所用的实例变量；②告诉编译器不要创建该属性的get和setter方法。让编译器相信存取方法会在运行时找到。</p>
<pre><code>// 声明文件中
@property(nonatomic,retain) NSString    *name; 

// 实现文件中
@dynamic name;  
</code></pre></li>
<li><p>默认情况下，编译器会为当前类自动生成一个NSString   <em>_name的实例变量（如果想改变实例变量的名称可以用@synthesize关键字），同时会生成两个名为` - (NSString </em>)name<code>和</code>- (void)setName:(NSString *)aName`的存取方法。</p>
<pre><code>void dynamicMethodIMP(id self, SEL _cmd)  
{  
    // implementation ....  
}  

+ (BOOL)resolveInstanceMethod:(SEL)sel  
{  
    NSLog(@&quot;sel is %@&quot;, NSStringFromSelector(sel));  
    if(sel == @selector(setName:)){  
        class_addMethod([self class],sel,(IMP)dynamicMethodIMP,&quot;v@:&quot;);  
        return YES;  
    }  
    return [super resolveInstanceMethod:sel];  
}  
</code></pre></li>
<li><p>消息转发.外部调用的某个方法对象没有实现，而且resolveInstanceMethod方法中也没有做重定向处理时，就会触发<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>方法。这个方法通常用来将不能处理的消息转发给其它的对象。</p>
<pre><code>-(void)forwardInvocation:(NSInvocation *)invocation  
{  
    SEL invSEL = invocation.selector;  
    if ([someOtherObject respondsToSelector:invSEL])  
        [anInvocation invokeWithTarget:someOtherObject];  
    } else {  
        [self doesNotRecognizeSelector:invSEL];   
    }                                                                            
}  
</code></pre></li>
<li><p>Cocoa（iOS上的叫Cocoa Touch）是一个面向对象的软件组件——类的集成套件，它使开发者可以快速创建强壮和全功能的 Mac OS X （IOS）应用程序。Cocoa包含了很多框架，其中最最核心的是Foundation框架和Application Kit（AppKit）框架（Cocoa Touch中叫UIKit框架）。</p>
</li>
<li><p>imageNamed的优点在于可以缓存已经加载的图片。这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回.</p>
</li>
<li>imageWithContentsOfFile方法只是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到程序。当不需要重用该图像，或者需要将图像以数据方式存储到数据库，又或者要通过网络下载一个很大的图像时，可以使用这种方式。</li>
<li>run loop是为了线程而生,是线程的基础架构部分，每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。主线程的run loop默认是启动的。</li>
<li>UIApplicationMain()函数，会为main thread设置一个NSRunLoop对象.</li>
<li>NSRunLoop类并不是线程安全的,不能在一个线程中去操作另外一个线程的run loop对象,CFRunLoopRef是线程安全的.</li>
<li>获取到当前线程的run loop:<code>[NSRunLoop currentRunLoop];</code>获取对应的CFRunLoopRef类<code>- (CFRunLoopRef)getCFRunLoop;</code></li>
<li>一个run loop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。对消息处理过程进行了更好的抽象和封装，在NSRunLoop中每一个消息就被打包在input source或者是timer source中了。使用run loop可以使线程在有工作的时候工作，没有工作的时候休眠，这可以大大节省系统资源。</li>
<li>创建输入源的时候，需要将其分配给run loop中的一个或多个模式.</li>
<li>定时源在预设的时间点同步方式传递消息，这些消息都会发生在特定时间或者重复的时间间隔。定时源则直接传递消息给处理例程，不会立即退出run loop。</li>
<li>创建NSTimer</li>
</ol>
<pre><code>// 方式一:自动把timer加入MainRunloop的NSDefaultRunLoopMode中
NSTimer *timer = [NSTimer scheduledTimerWithTimeInteral:1.0 target:self selector:@selector(action:) userInfo:ni] repeat:NO];

// 停止
[timer invalidate];


// 方式二(需手动加到run loop中)
   NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self seletor:@selector(timerAction) userInfo:nil repeats:YES];

   [[NSRunloop mainRunloop] addTimer:timer forMode:NSDefaultRunloopMode];
</code></pre><p>特点:调用创建方法后,target对象的引用计数会+1,直到执行完毕,自动-1.如果RunLoop正在执行一个连续的运算,timer就会被延迟触发</p>
<ol>
<li>响应者对象（Responder Object），指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。</li>
</ol>
<ul>
<li><p>响应者链通常是由视图（UIView）构成的；</p>
</li>
<li><p>一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）；</p>
</li>
<li><p>视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图；</p>
</li>
<li><p>单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者.</p>
</li>
<li><p>单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。</p>
</li>
</ul>
<ol>
<li><p>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。</p>
</li>
<li><p>UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。</p>
</li>
<li><p>UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:</p>
</li>
</ol>
<ol>
<li>方法的处理流程如下:<br>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；<br>若返回NO,则hitTest:withEvent:返回nil;<br>若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；<br>若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；<br>如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。</li>
</ol>
<ol>
<li><p>非正式协议通常定义为NSObject的类别。</p>
</li>
<li><p>类别与类扩展的区别：<br>①类别中只能增加方法；<br>②类扩展不仅可以增加方法，还可以增加实例变量（或者合成属性），只是该实例变量默认是@private类型的；<br>③类扩展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中。<br>④类扩展所声明的方法必须依托对应类的实现部分来实现。<br>⑤定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。</p>
</li>
<li><p>KVC全称是Key-value coding，翻译成键值编码。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。KVO全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。KVO机制很适合实现model和controller类之间的通讯。</p>
</li>
<li>KVC是不会自动调用键值验证方法的，我们需要手动验证。<code>- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</code></li>
<li>KVC可以自动的将数值或结构体型的数据打包或解包成NSNumber或NSValue对象，以达到适配的目的。</li>
<li>代码片段存放路径<code>~/Library/Developer/Xcode/UserData/CodeSnippets</code></li>
<li>ARC的英文全名是：Automatic Reference Counting，是编译器提供的管理Objective-C对象内存的一个机制。它并不是像垃圾回收机制那样，有一个负责内存回收的系统，而是仍然以引用计数为基础：在编译阶段，编译器会在需要retain或release对象的地方自动为我们加上对应的代码。</li>
<li>内存管理规则：一个Object-C对象存在strong类型的指针指向时，该对象就不会被释放。</li>
<li><p>①strong<br>该属性值对应 <code>__strong</code>关键字，即该属性所声明的指针变量将成为对象的持有者。strong是指向Objective-C对象指针的默认属性。<br>②weak<br>该属性对应<code>__weak</code>关键字，与<code>__weak</code>定义的变量一致，该属性所声明的变量将没有对象的所有权，并且当对象被破弃之后，对象将被自动赋值nil。<br>④copy<br>也是对象的所有者，与strong的区别是声明的指针变量是拷贝对象的持有者。<br>⑤assign<br>一般数值型变量用该属性声明，比如,int, BOOL，但无需显示写出，因为数值型变量的默认属性类型就是assign</p>
</li>
<li><p>使用关键字声明指针类型规范写法:</p>
<pre><code>//规范的写法
MyClass * __weak myWeakReference;
</code></pre></li>
<li><p>weak和assign的异同</p>
</li>
</ol>
<p>相同点：指向的对象都是随时有可能被释放，即不拥有指向的对象<br>不同点：①weak只能用来声明Objective-C对象，assign既可以用来声明对象，也可以用来声明数值型变量；②很关键的一点区别，当一个weak关键字声明的指针指向的对象被释放掉得时候，该指针会自动的被指向nil而assign不存在该特性.</p>
<ol>
<li>使用@property声明或作为普通实例变量声明的指向Objective-C对象的指针属性默认都是strong；而使用@property声明的数值型变量属性默认的是assign，普通的数值型变量的属性是__unsafe_unretaind。</li>
</ol>
<table>
<thead>
<tr>
<th>属性</th>
<th>关键字</th>
<th>所有权</th>
</tr>
</thead>
<tbody>
<tr>
<td>strong</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>copy</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
<td>无</td>
</tr>
<tr>
<td>assign</td>
<td>__unsafe_unretained</td>
<td>无</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe_unretained</td>
<td>无</td>
</tr>
</tbody>
</table>
<ol>
<li><p>使用ARC需要遵守的新规则<br>①不要在dealloc方法中调用[super dealloc];<br>②不能使用 retain/release/retainCount/autorelease<br>③不能使用 NSAllocateObject/NSDeallocateObject<br>④不能使用 NSZone<br>⑤Objective-C 对象不能作为C语言结构体（struct/union）的成员</p>
</li>
<li><p>instancetype表示某个方法返回的未知类型的Objective-C对象,instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型,能够确定对象的类型.有利于开发者在编译阶段发现错误。</p>
</li>
<li>关联返回类型（related result types）1、类方法中，以alloc或new开头2、实例方法中，以autorelease，init，retain或self开头.</li>
<li><p>instancetype和id的异同: 1、相同点:都可以作为方法的返回类型<br>2、不同点<br>①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；<br>②instancetype只能作为返回值，不能像id那样作为参数</p>
</li>
<li><p>每个应用的沙盒目录都是相似的，主要包含4个目录：<br>1、MyApp.app<br>存放应用程序本身的数据,整个目录是只读的,不能被iTunes同步<br>2、Documents<br>存放不可再生的的数据文件,会被iTunes同步.<br>3、Library<br>存放默认设置或其它状态信息。<br>除了Caches子目录外,会被iTunes同步.<br>4、Library/Caches<br>存放缓存文件，保存那些可再生的文件,不会被iTunes同步<br>5、Library/Preferences<br>存放应用程序的偏好设置文件。我们使用NSUserDefaults写的设置数据都会保存到该目录下的一个plist文件中，会被iTunes同步<br>6、tmp<br>存放各种临时文件,不会被iTunes同步</p>
</li>
</ol>
<ol>
<li>runtime采用散列表来管理引用计数,统一存储所有对象的引用计数,不用考虑每个对象内存块中引用计数所占的内存,在引用计数表中存储各个对象的内存地址.</li>
<li>NULL本质上是：(void<em>)0,表示C指针为空,如`charchar </em>string = NULL; `</li>
<li>nil本质上是：(void *)0,表示指向Objective-C中对象的指针为空</li>
<li>Nil本质上也是：(void *)0,表示Objective-C中Class类型的变量值为空,<code>Class anyClass = Nil;</code></li>
<li><p>NSNull是一个Objective-C类,该类通常用于在集合对象中保存一个空的占位对象</p>
<pre><code>// 遇到nil截断
NSArray *arr = [NSArray arrayWithObjects:@&quot;wang&quot;,@&quot;zz&quot;,nil,@&quot;foogry&quot;];

// 存储空的占位对象
NSArray *arr = [NSArray arrayWithObjects:@&quot;wang&quot;,@&quot;zz&quot;,[NSNull null],@&quot;foogry&quot;];
</code></pre></li>
</ol>
<blockquote>
<p>向作者致谢!<br>王中周的个人博客:<a href="http://blog.csdn.net/wzzvictory" target="_blank" rel="external">http://blog.csdn.net/wzzvictory</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 许多鞭辟入里的文章. &lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="ios开发" scheme="http://blog.chenyalun.com/tags/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>读「李明杰博客」</title>
    <link href="http://blog.chenyalun.com/2016/10/28/%E8%AF%BB%E6%9D%8E%E6%98%8E%E6%9D%B0%E5%8D%9A%E5%AE%A2/"/>
    <id>http://blog.chenyalun.com/2016/10/28/读李明杰博客/</id>
    <published>2016-10-28T11:22:17.000Z</published>
    <updated>2016-12-28T10:02:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.12.4 修改并回顾</p>
</blockquote>
<p align="center"> 李明杰老师是我很尊敬的iOS启蒙老师. </p>

<a id="more"></a>
<h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>这次零零碎碎花了一周时间拜读老师的博客,很多知识点理解地更透彻了,尤其是C语言方面的.不太熟悉或将近遗忘的知识点记录下来,做复习巩固之用.</p>
<h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><ol>
<li><p>loadView、viewDidLoad及viewDidUnload的关系是怎样的?</p>
</li>
<li><p>为什么默认情况下UIImageView内的按钮无法点击?忽略视图的四种方法?</p>
</li>
<li><p>只声明一个局部int类型变量与只声明一个全局的int类型变量,却不初始化,其值是?</p>
</li>
<li><p>使用char存储大写字母A有哪两种赋值方式?</p>
</li>
<li><p>逗号表达式的运算过程<code>c = (++a, a *= 2, b = a * 5);</code>是怎样的?</p>
</li>
<li>枚举与结构体定义的三种方式?</li>
<li>为何不要在description方法中同时使用%@和self?</li>
</ol>
<h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><ol>
<li><p>不要在UIViewController的loadView方法中改变状态栏的可视性,会导致重复调用2次loadView和viewDidLoad方法.</p>
</li>
<li><p>控制打印格式</p>
<p> printf(“My height is %8.1f”, 179.95f);</p>
<p> scanf(“%d-%d-%d”, &amp;a, &amp;b, &amp;c);<br> scanf(“%d %d %d”, &amp;a, &amp;b, &amp;c);</p>
</li>
</ol>
<ol>
<li><p>计算机中的内存是以字节为单位的存储空间.<br>内存的每一个字节都有一个唯一的编号，这个编号就称为地址.<br>凡存放在内存中的程序和数据都有一个地址，也就是说，一个函数也有自己的内存地址。变量存储单元的第一个字节的地址就是该变量的地址.</p>
</li>
<li><p>二维数组的&amp;a[i] == (a+i)</p>
</li>
<li><p>gets可以读入包含空格、tab的字符串，直到遇到回车为止；<br>getchar函数可以读入空格、TAB，直到遇到回车为止。scanf则不能读入空格和TAB。scanf不能用来读取空格、tab.</p>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    char a[10];
    char b[10];
    gets(a);
    puts(a);

    scanf(&quot;%s&quot;,b);
    puts(b);
    return 0;
}
</code></pre></li>
</ol>
<pre><code>putchar(65); // A

putchar(&apos;A&apos;); // A

int a = 65;
putchar(a); // A

char c;
c = getchar();
</code></pre><ol>
<li><p>包含string.h头文件后,strlen\strcpy\strcat\strcmp函数的用法</p>
<pre><code>// 长度为2,遇空字符\0断!
int size = strlen(&quot;mj&quot;);

// 遇空字符\0断!
char s[10];
strcpy(s, &quot;lmj&quot;);

// 遇空字符\0断!
char s1[30] = &quot;LOVE&quot;;
strcat(s1, &quot;OC&quot;);

// 左减右,比字符ASCII码差值
strcmp(s1, s2);
</code></pre></li>
<li><p>通过变量名引用变量，由系统自动完成变量名和其存储地址之间的转换，称为变量的”直接引用”方式.<br>首先将变量a的地址存放在另一个变量中，比如存放在变量b中，然后通过变量b来间接引用变量a，间接读写变量a的值。这就是”间接引用”.</p>
</li>
<li><p>在指针变量没有指向确定地址之前，不要对它所指的内容赋值。<code>int *p; *p = 10; //这是错误的</code>.</p>
</li>
<li>基本数据类型作为函数实参时，只是纯粹地将值传递给形参，形参的改变并不影响实参。</li>
<li><p>如何使一个函数有多个返回值.</p>
<pre><code>int test(int a, int b,int *c) {
    // 赋值给指针指向的变量
    *c = a + b;
    return a * b;
}

int main(int argc, const char * argv[]) {
    int m = 2,n = 4,s1,s2;
    s1 =  test(m, n, &amp;s2);

    printf(&quot;%d---%d&quot;,s1,s2);
    return 0;
}
</code></pre></li>
<li>二维数组中,可以根据a[0]的地址获取其他元素的地址，使p=&amp;a[0],p+1就是a[1]的地址。这里的p+1不一定代表p的值加1，也可能是加2、加4或者加8。究竟加多少，这跟指针的类型有关.</li>
<li>指针操作中,数组名a是个常量,不能进行赋值运算！<code>*(p+i)和*(a+i)都表示数组元素a[i]</code><pre><code>char s[10];
s = &quot;mj&quot;;// 错误! s是常量
</code></pre></li>
<li>用数组名作为函数实参时，是把实参数组的首地址传递给形参数组，两个数组共同占用同一段内存空间，这样形参数组中的元素值发生变化就会使实参数组的元素值也同时变化.</li>
<li><code>char *s = &quot;mj&quot;;3 *s = &quot;like&quot;;</code>的两个错误:1,s指向的是”mj”的首字符’m’,只有一个字节,要”like”存进1个字节的空间内，肯定内存溢出.2,s指向的是字符串常量”mj”,不能再通过指针来修改字符串内容(字符数组可以修改).</li>
<li><p>分辨:</p>
<pre><code>char a[] = &quot;lmj&quot;;定义的是一个字符串变量
char *p2 = &quot;lmj&quot;;定义的是一个字符串常量
</code></pre></li>
<li><p>返回指针的函数</p>
<pre><code>   // 将字符串str中的小写字母变成大写字母，并返回改变后的字符串
   // 注意的是：这里的参数要传字符串变量，不能传字符串常量
   char * upper(char *str) {
       // 先保留最初的地址。因为等会str指向的位置会变来变去的。
       char *dest = str;

   // 如果还不是空字符
   while (*str != &apos;\0&apos;) {
       // 如果是小写字母
       if (*str &gt;= &apos;a&apos; &amp;&amp; *str &lt;= &apos;z&apos;) {
           // 变为大写字母。小写和大写字母的ASCII值有个固定的差值
           *str -= &apos;a&apos; - &apos;A&apos;;
       }

       // 遍历下一个字符
       str++;
   }

   // 返回字符串
   return dest;
}
// 调用:
   int main()
   {
       // 定义一个字符串变量
       char str[] = &quot;lmj&quot;;

       // 调用函数
       char *dest = upper(str);

       printf(&quot;%s&quot;, dest);
       return 0;
   }
</code></pre></li>
<li><p>指向函数的指针</p>
<pre><code>int sum(int a, int b) {
    return a + b;
}

int main()
{
    // 定义一个指针变量p，指向sum函数
    int (*p)(int a, int b) = sum;
    // 或者 int (*p)(int, int) = sum;
    // 或者 int (*p)() = sum;

    // 利用指针变量p调用函数
    int result = (*p)(1, 3);
    // 或者 int result = p(1, 3);

    printf(&quot;%d&quot;, result);
    return 0;
}
</code></pre></li>
</ol>
<ol>
<li><p>将函数作为参数在函数间传递</p>
<pre><code> // 减法运算
 int minus(int a, int b) {
    return a - b;
 }

// 加法运算
int sum(int a, int b) {
    return a + b;
}

// 这个counting函数是用来做a和b之间的计算，至于做加法还是减法运算，由函数的第1个参数决定
void counting( int (*p)(int, int) , int a, int b) {
    int result = p(a, b);
    printf(&quot;计算结果为：%d\n&quot;, result);
}

int main()
{
    // 进行加法运算
    counting(sum, 6, 4);

    // 进行减法运算
    counting(minus, 6, 4);

    return 0;
 }
</code></pre></li>
<li><p>所有预处理指令都以符号”#”开头，并且结尾不用分号,作用范围是从它出现的位置到文件尾,主要有：宏定义、文件包含、条件编译.</p>
</li>
<li>使用带参数的宏定义,最好将参数和结果都用括号括起来.</li>
<li>宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题,宏替换只在编译预处理阶段进行,带参数的宏比函数具有更高的执行效率.</li>
<li><p>条件编译</p>
<pre><code>#if 条件1
 ...code1...
#elif 条件2
 ...code2...
#else
 ...code3...
#endif

#if defined(MAX)
     ...code...
#endif

#if !defined(MAX)
     ...code...
#endif
</code></pre></li>
<li><p><code>#include　&lt;文件名&gt;</code>到C语言库函数头文件所在的目录中寻找文件,<code>#include　&quot;文件名&quot;</code>系统会先在源程序当前目录下寻找，若找不到，再到操作系统的path路径中查找，最后才到C语言库函数头文件所在目录中查找.</p>
</li>
<li><p>避免#include重复包含同一个头文件:使用条件编译</p>
<pre><code>#ifndef _ONE_H_
#define _ONE_H_

void one();

#endif
</code></pre></li>
<li>在函数内部定义的变量，称为局部变量。形式参数也属于局部变量,在所有函数外部定义的变量，称为全局变量.</li>
<li>所有的局部变量在默认情况下都是自动变量,是存储在堆栈中的.所有的全局变量和被关键字static修饰的局部变量都是静态变量,是存储在静态内存中的，也就是不属于堆栈.</li>
<li>静态变量在程序运行之前创建，在程序的整个运行期间始终存在，直到程序结束。在程序执行到声明自动变量的代码块(函数)时，自动变量才被创建；当自动变量所在的代码块(函数)执行完毕后，这些自动变量就会自行销毁.</li>
<li><p>被关键字register修饰的自动变量都是寄存器变量,是存储在硬件寄存器中的,其生命周期即是自动变量的生命周期.寄存器变量只限于int、char和指针类型变量使用,将一些频繁使用的自动变量定义为寄存器变量，这样程序尽可能地为它分配寄存器存放，而不用内存.</p>
<pre><code>register int a;
register char b;
register int *c;
</code></pre></li>
<li>如果一个程序中有多个源文件(.c)，编译成功会生成对应的多个目标文件(.obj)，这些目标文件不能单独运行，因为这些目标文件之间可能会有关联。将这些相关联的目标文件链接在一起后才能生成可执行文件。</li>
<li>所谓编译，就是单独检查每个源文件的语法是否合理，并不会检查每个源文件之间的关联关系，一个源文件编译成功就生成一个目标文件。所谓链接，就是检查目标文件的关联关系，将相关联的目标文件组合在一起，生成可执行文件。</li>
<li>根据在当前文件中定义的函数是否允许其他文件访问,可将函数分为内部函数和外部函数.默认情况下，所有的函数都是外部函数,不允许重复定义同一个外部函数.</li>
<li><p>使用extern关键字，表示引用其他文件的”外部函数”: <code>extern void test();</code>,然而extern可以省略,故直接声明即可.正规的项目里面，把”外部函数”的声明另写到一个头文件中,使用时直接包含头文件即可.</p>
<pre><code>#ifndef one_h
#define one_h

#include &lt;stdio.h&gt;
void test();
#endif /* one_h */
</code></pre></li>
<li><p>在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数),不允许其他文件访问.不同的文件中有同名的内部函数，则互不干扰。</p>
</li>
<li><p>默认情况下，一个函数不可以访问在它后面定义的全局变量.不同源文件中的同名全局变量代表着同一个变量</p>
<pre><code>// a文件
int ss =10;

// b文件
extern int  ss ;
printf(&quot;%d&quot;, ss);// 是10
</code></pre></li>
<li>在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰</li>
<li><p>定义结构体的三种形式(枚举变量的定义与之类似)</p>
<pre><code>struct Student {
    char *name;
    int age;
};
// 利用上面结构体定义结构体变量stu
struct Student stu;
</code></pre></li>
</ol>
<pre><code>// 直接定义结构体变量stu
struct Student {
    char *name;
    int age;
} stu;


// 定义结构体变量stu后,此结构体永不再用
struct {
    char *name;
    int age;
} stu;


// 特殊:struct前放置typedef表示声明此&quot;匿名&quot;结构体的名字为Student
typedef struct {
    char *name;
    int age;
} Student;
</code></pre><ol>
<li>定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量.结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列.</li>
<li>将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参.</li>
<li>结构体指针变量的定义形式：<code>struct 结构体名称 *指针变量名</code>,三种访问方式:<ul>
<li>结构体变量名.成员名</li>
<li>(*指针变量名).成员名</li>
<li>指针变量名-&gt;成员名</li>
</ul>
</li>
<li><p>typedef也可以给指针起别名:<code>typedef char *String;</code></p>
<pre><code>// 相当于char *str = &quot;This is a string!&quot;;
String str = &quot;This is a string!&quot;;
</code></pre></li>
<li><p>typedef给结构体起别名</p>
</li>
</ol>
<pre><code>    struct CGRect {
    CGPoint origin;
    CGSize size;
};
typedef struct CGRect CGRect;
</code></pre><ol>
<li><p>typedef给指向结构体的指针起别名</p>
<pre><code>#include &lt;stdio.h&gt;

// 定义一个结构体并起别名
typedef struct {
    float x;
    float y;
} Point;

// 起别名
typedef Point *PP;

int main(int argc, const char * argv[]) {
    // 定义结构体变量
    Point point = {10, 20};

    // 定义指针变量Point *p = &amp;point;
    PP p = &amp;point;

    // 利用指针变量访问结构体成员
    printf(&quot;x=%f，y=%f&quot;, p-&gt;x, p-&gt;y);
    return 0;
 }
</code></pre></li>
<li><p>typedef与枚举类型</p>
<pre><code>// 定义枚举类型
 enum Season {spring, summer, autumn, winter};
 // 给枚举类型起别名
 typedef enum Season Season;

 int main(int argc, const char * argv[]) {
     // 定义枚举变量
     Season s = spring;

     return 0;
 }
</code></pre><p>43.typedef给指向函数的指针类型起别名</p>
<pre><code>#include &lt;stdio.h&gt;

// 定义一个sum函数，计算a跟b的和
int sum(int a, int b) {
    int c = a + b;
    printf(&quot;%d + %d = %d&quot;, a, b, c);
    return c;
}

typedef int (*MySum)(int, int);

int main(int argc, const char * argv[]) {
    // 定义一个指向sum函数的指针变量p
    MySum p = sum;

    // 利用指针变量p调用sum函数
    (*p)(4, 5);

    return 0;
 }
</code></pre></li>
</ol>
<ol>
<li><p>typedef与#define,给类型起别名，最好使用typedef，而不是使用#define.</p>
<pre><code>typedef char *String1;
#define String2 char *

// 相当于char *str1;char *str2;
String1 str1, str2;
// 相当于char *str3;char  str4;产生误会
String2 str3, str4;
</code></pre></li>
<li><p>C语言的源文件拓展名为”.c”，OC的源文件拓展名为”.m”,编译器会将.m文件编译为.o目标文件.编译器只会编译.m文件，并不会编译.h文件.</p>
</li>
<li><code>#import</code>是一个预处理指令，作用跟C语言的<code>#include</code>类似，都是 包含(拷贝)某个文件的内容 到 预处理指令所在的位置。在OC中，使用#import来包含头文件，可以自动防止同一个头文件被包含多次。<code>#import &lt;...&gt;</code>表示包含系统自带的文件，<code>#import &quot;...&quot;</code>表示包含开发人员自己创建的文件.</li>
<li><code>+</code>表示静态方法,<code>-</code>表示动态方法,在.h中声明的所有方法作用域都是public类型，不能更改.成员变量默认作用域是@protected,成员变量必须写在大括号{ }里面.</li>
<li>OC建议get方法的名字跟成员变量保持一致</li>
<li>静态方法alloc分配存储空间,返回分配好内存的对象;对象的构造方法init进行初始化.</li>
<li>访问公共变量age:对象-&gt;成员变量,<code>stu-&gt;_age = 10; int a = stu-&gt;_age;</code></li>
<li>OC点语法的本质是方法调用，不是直接访问成员变量.</li>
<li>UIView之所以能显示在屏幕上，完全是因为它内部的一个层(CALayer对象)。当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了UIView的显示。</li>
<li>通过layer属性可以设置shadowColor\shadowOffset\shadowOpacity\cornerRadius\borderWidth\borderColor等;maskToBounds=YES：是强制内部的所有子层支持圆角效果，少了这个设置，是不会有圆角效果的,如果设置了maskToBounds=YES，那将不会有阴影效果.</li>
<li>CALayer是定义在QuartzCore框架中的；CGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的；UIColor、UIImage是定义在UIKit框架中的.</li>
<li>每一个UIView内部都默认关联着一个CALayer，这个Layer为Root Layer（根层）;所有的非Root Layer，也就是手动创建的CALayer对象，都存在着隐式动画。当对非Root Layer的部分属性进行相应的修改时，默认会自动产生一些动画效果，这些属性称为Animatable Properties(可动画属性)。<ul>
<li>bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画</li>
<li>backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画</li>
<li>position：用于设置CALayer的位置。修改这个属性会产生平移动画</li>
</ul>
</li>
<li>position可以用来设置CALayer在父层中的位置，它是以父层的左上角为坐标原点(0, 0);anchorPoint称为”定位点”，它决定着CALayer身上的哪个点会在position属性所指的位置。它的x、y取值范围都是0~1，默认值为(0.5, 0.5).</li>
<li>不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate.</li>
<li>当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法.</li>
<li>平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕.</li>
<li>Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程,而且是直接作用在CALayer上的，并非UIView.</li>
<li>没有存储任何内存地址的指针就称为空指针(NULL指针,指向nil),空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。可以给空指针发送消息,但消息发送不出去.”野指针”不是NULL指针，是指向”垃圾”内存（不可用内存）的指针.</li>
<li>源文件编译成功后，会生成一个.o目标文件，这就是一个二进制文件.</li>
<li><p>clang指令汇总</p>
<pre><code>编译单个c源文件，并产生一个目标文件  cc -c one.c
编译多个c源文件，并为每个文件产生一个目标文件  cc -c one.c two.c three.c
链接单个目标文件产生一个名为a.out的可执行文件  cc one.o
链接多个目标文件  cc one.o two.o three.o
编译并链接一个c源文件  cc one.c
编译并链接多个c源文件  cc one.c two.c three.c
编译一个c源文件，并把它和现存的目标文件链接在一起  cc one.o two.o three.c
可执行文件重命名加上“-o name”这个选项  cc -o abc one.c
执行可执行文件  ./a.out
</code></pre></li>
<li>当使用基本数据类型（char、int、float等）作为实参时，实参和形参之间只是值传递，修改形参的值并不影响到实参</li>
</ol>
<blockquote>
<p>向作者致谢!<br>M了个J:<a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">http://www.cnblogs.com/mjios/</a></p>
<p>参考博客<br>C语言中文网:<a href="http://c.biancheng.net/cpp/html/88.html" target="_blank" rel="external">http://c.biancheng.net/cpp/html/88.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.12.4 修改并回顾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 李明杰老师是我很尊敬的iOS启蒙老师. &lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="C语言" scheme="http://blog.chenyalun.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="ios开发" scheme="http://blog.chenyalun.com/tags/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C语言交换两个数值的八种方法</title>
    <link href="http://blog.chenyalun.com/2016/10/23/C%E8%AF%AD%E8%A8%80%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%80%BC%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.chenyalun.com/2016/10/23/C语言交换两个数值的八种方法/</id>
    <published>2016-10-23T02:20:17.000Z</published>
    <updated>2016-10-25T14:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 在回顾C语言的时候,偶遇此题,因曾被其深虐,特意搜寻多种解决办法,以鞭笞岁月. </p><br><a id="more"></a><p></p>
<blockquote>
<p>编译器:XCode8.0</p>
</blockquote>
<h1 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h1><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, const <span class="built_in">char</span> * argv[]) &#123;</div><div class="line">   <span class="built_in">int</span> m = <span class="number">5</span>, <span class="built_in">n</span> = <span class="number">3</span>;</div><div class="line">   m = m ^ <span class="built_in">n</span>;</div><div class="line">   <span class="built_in">n</span> = m ^ <span class="built_in">n</span>;</div><div class="line">   m = m ^ <span class="built_in">n</span>;</div><div class="line">   </div><div class="line">   printf(<span class="string">"m:%d---n:%d"</span>,m,<span class="built_in">n</span>);</div><div class="line">   return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>异或一般是针对二进制数.</p>
<ol>
<li>两数异或,相同则得0,不同则得1</li>
<li>x ^ x = 0,x ^ 0 = x<br>第二行:  m:0101 n:0011<br>第三行:  m:0110 n:0011<br>第四行:  n:0101 m:0110<br>第五行:  m:0011 n:0101<br>此时,已完成交换.</li>
</ol>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><pre><code>int main(int argc, const char * argv[]) {
    int m = 2147483648, n = 2147483647;
    m = m + n - (n = m);
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><ol>
<li>从左向右依次进行,首先获取m与n的和,接着利用()运算符直接将m的值赋予n,此时n完成交换</li>
<li>同时()内的值是m的值,两数之和减去m值便是n的值,再将n的值赋予m,到这里m完成交换</li>
</ol>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><pre><code>int main(int argc, const char * argv[]) {
int m = 5, n = 3;
n = (long)((long)m &lt;&lt; 32 | (m = n)) &gt;&gt; 32;
printf(&quot;m:%d---n:%d&quot;,m,n);
return 0;
}
</code></pre><p>注:<code>__int64表示64位整型变量,Xcode中用long代替,VC6.0可直接使用__int64,即: b = (__int64)((__int64)a &lt;&lt; 32 | (a = b)) &gt;&gt; 32；</code></p>
<ol>
<li>(m = n):完成m的交换,()的值是n</li>
<li>(long)((long)m &lt;&lt; 32 | n):得到的结果是 <code>00...0  0101   00...0  11</code>第一部分28个0,第三部分30个0 </li>
<li>((long)((long)m &lt;&lt; 32 ) &gt;&gt; 32:得到的结果:把第三第四部分去掉,即<code>00...0  0101</code> 正好32位,且此值为m的值,再将其赋予n,完成n的交换.</li>
</ol>
<h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><pre><code>#define swap(x, y, z) ((z) = (x), (x) = (y), (y) = (z))

int main(int argc, const char * argv[]) {
    int m = 5, n = 3,t = 0;
    swap(m, n, t);
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><p>比较巧妙,把中间变量放在宏中.</p>
<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><pre><code>int main(int argc, char *argv[]) {
int m = 5, n = 3;
m = m + n;
n = m - n;
m = m - n;

printf(&quot;m:%d---n:%d&quot;,m,n);
return 0;
}
</code></pre><p>算是一种数学方法吧,但可能溢出.</p>
<h1 id="两数之积"><a href="#两数之积" class="headerlink" title="两数之积"></a>两数之积</h1><pre><code>int main(int argc, const char * argv[]) {
    int m = 5, n = 3;
    m = m * n;
    n = m / n;
    m = m / n;

    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><p>两数之和方法的变形,n不能为0,m更可能溢出.</p>
<h1 id="经典的交换函数"><a href="#经典的交换函数" class="headerlink" title="经典的交换函数"></a>经典的交换函数</h1><pre><code>void swap(int *a, int *b) {
    int temp = 0;
    temp = *a;
    *a = *b;
    *b = temp;
}

int main(int argc, const char * argv[]) {
    int m = 2147483648, n = 2147483647;
    swap(&amp;m,&amp;n);
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><h1 id="直接添加变量"><a href="#直接添加变量" class="headerlink" title="直接添加变量"></a>直接添加变量</h1><pre><code>int main(int argc, const char * argv[]) {
    int m = 2147483648, n = 2147483647,temp = 0;
    temp = m;
    m = n;
    n = temp;
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><p>int最大值，根据编译器类型不同而变化。<br>1 对于16位编译器，int占16位(2字节)。<br>int的最大值为32767.<br>2 对于32位和64位编译器，int占32位(4字节)。<br>int的最大值为2147483647</p>
<p>3 可以通过打印sizeof(int)查看平台对应的int占用字节数。乘8后即为位数。<br>最高位为符号位，如位数为n，则最大值为<br>2^(n-1)<br>即2的n-1次幂。</p>
<pre><code>printf(&quot;%lu&quot;,sizeof(int));
int a = 2147483648;
</code></pre><blockquote>
<p>参考并致谢:<br><a href="http://blog.csdn.net/ljx_5489464/article/details/50042571" target="_blank" rel="external">http://blog.csdn.net/ljx_5489464/article/details/50042571</a><br><a href="http://kiya.space/2013/07/26/c%E8%AF%AD%E8%A8%80swap(a,b)%E5%80%BC%E4%BA%A4%E6%8D%A2%E7%9A%844%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E2%80%A6/" target="_blank" rel="external">http://kiya.space/2013/07/26/c%E8%AF%AD%E8%A8%80swap(a,b)%E5%80%BC%E4%BA%A4%E6%8D%A2%E7%9A%844%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E2%80%A6/</a><br><a href="http://www.itdadao.com/articles/c15a428576p0.html" target="_blank" rel="external">http://www.itdadao.com/articles/c15a428576p0.html</a><br><a href="http://www.cnblogs.com/kubixuesheng/p/4104800.html" target="_blank" rel="external">http://www.cnblogs.com/kubixuesheng/p/4104800.html</a><br><a href="https://www.byvoid.com/blog/c-int64" target="_blank" rel="external">https://www.byvoid.com/blog/c-int64</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;p align = &quot;center&quot;&gt; 在回顾C语言的时候,偶遇此题,因曾被其深虐,特意搜寻多种解决办法,以鞭笞岁月. &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://blog.chenyalun.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="C语言" scheme="http://blog.chenyalun.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS学习笔记一：Cocoapods的安装与使用</title>
    <link href="http://blog.chenyalun.com/2016/10/10/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9ACocoapods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.chenyalun.com/2016/10/10/iOS学习笔记一：Cocoapods的安装与使用/</id>
    <published>2016-10-10T04:50:17.000Z</published>
    <updated>2016-10-25T14:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> Cocoapods是非常好用的第三方库管理工具. </p>

<a id="more"></a>
<h1 id="升级Gem"><a href="#升级Gem" class="headerlink" title="升级Gem"></a>升级Gem</h1><pre><code>sudo gem update --system
</code></pre><h1 id="切换Cocoapods的数据源"><a href="#切换Cocoapods的数据源" class="headerlink" title="切换Cocoapods的数据源"></a>切换Cocoapods的数据源</h1><pre><code># 1.删除
gem sources --remove https://rubygems.org/

# 2.添加淘宝数据源
gem sources -a https://ruby.taobao.org/

# 3.查看
gem sources -l
</code></pre><h1 id="安装Cocoapods"><a href="#安装Cocoapods" class="headerlink" title="安装Cocoapods"></a>安装Cocoapods</h1><pre><code>sudo gem install cocoapods
或者（如10.11系统）
sudo gem install -n /usr/local/bin cocoapods
</code></pre><h2 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h2><pre><code>Error installing pods:activesupport requires Ruby version &gt;= 2.2.2
</code></pre><p>解决方式:</p>
<h3 id="安装-RVM"><a href="#安装-RVM" class="headerlink" title="安装 RVM"></a>安装 RVM</h3><pre><code>curl -L get.rvm.io | bash -s stable  
</code></pre><p>等待。</p>
<pre><code>source ~/.bashrc  
source ~/.bash_profile  
</code></pre><p>测试是否安装成功。</p>
<pre><code>rvm -v  
</code></pre><h3 id="用RVM升级Ruby"><a href="#用RVM升级Ruby" class="headerlink" title="用RVM升级Ruby"></a>用RVM升级Ruby</h3><pre><code># 1.查看当前ruby版本  
ruby -v  
# 显示 ruby 1.8.7  

# 2.列出已知的ruby版本  
rvm list known  

# 3.安装ruby 2.3  
rvm install 2.3  
</code></pre><p>安装完成之后ruby -v查看是否安装成功。</p>
<h1 id="更换托管地址"><a href="#更换托管地址" class="headerlink" title="更换托管地址"></a>更换托管地址</h1><ul>
<li><p>将Podspec文件托管地址从github切换到国内的oschina或者coding。</p>
</li>
<li><p>注意:如果pod setup 可以将github的代码下载得动，那就不用去更换托管地址了。</p>
<pre><code># 1.先移除
pod repo remove master

# 2.再添加
pod repo add master https://git.coding.net/CocoaPods/Specs.git

# 3.再更新
pod repo update
</code></pre></li>
</ul>
<h1 id="设置pod仓库-初始化Cocoapods"><a href="#设置pod仓库-初始化Cocoapods" class="headerlink" title="设置pod仓库(初始化Cocoapods)"></a>设置pod仓库(初始化Cocoapods)</h1><pre><code>pod setup 
# 会将Specs.git的代码下载到~/.cocoapods/repo/master,自己前往查看是否有文件
# 如果还是太慢，尝试下
pod install --verbose
</code></pre><h2 id="报错解决-1"><a href="#报错解决-1" class="headerlink" title="报错解决"></a>报错解决</h2><pre><code>[!] To setup the master specs repo, please run `pod setup`.
</code></pre><p>手动下载代码解决:</p>
<pre><code># 1.手动克隆文件至该目录
git clone https://git.coding.net/CocoaPods/Specs.git ~/.cocoapods/repos/master

# 2.初始化,完成后显示Setup completed
pod setup  
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code># 如果有版本号，则说明已经pod安装成功
pod --version
# 如果~/.cocoapods/repo/master目录下有文件,说明文件下载成功
</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>利用Cocoapods来安装第三方框架</p>
<ol>
<li>进入要安装框架的项目的.xcodeproj同级文件夹</li>
<li>在该文件夹中新建一个文件podfile</li>
<li><p>在文件中告诉cocoapods需要安装的框架信息</p>
<p>a.该框架支持的平台<br>b.适用的iOS版本<br>c.框架的名称<br>d.框架的版本</p>
</li>
</ol>
<h2 id="Podfile文件格式"><a href="#Podfile文件格式" class="headerlink" title="Podfile文件格式"></a>Podfile文件格式</h2><pre><code>platform :ios, &apos;9.0&apos;
target &apos;你的项目名称&apos; do
pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;
end     
</code></pre><h2 id="创建Podfile文件"><a href="#创建Podfile文件" class="headerlink" title="创建Podfile文件"></a>创建Podfile文件</h2><p>进入.xcodeproj同级文件夹下</p>
<pre><code># 初始化:会生成模板的Podfile文件
pod init  

# 或者手动创建Podfile文件
touch Podfile
</code></pre><h2 id="添加自己需要的第三方库"><a href="#添加自己需要的第三方库" class="headerlink" title="添加自己需要的第三方库"></a>添加自己需要的第三方库</h2><pre><code>pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;

# If you are using Swift, be sure to add use_frameworks! and set your target to iOS 8+:
pod &apos;SDWebImage&apos;, &apos;~&gt;3.8&apos;
use_frameworks!

pod &apos;Masonry&apos;

pod &apos;MBProgressHUD&apos;, &apos;~&gt; 1.0.0&apos;

pod &apos;MJExtension&apos;

pod &apos;MJRefresh&apos;

pod &apos;SVProgressHUD&apos;
</code></pre><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><pre><code>pod install --verbose --no-repo-update
# 显示
# Pod installation complete! There is 1 dependency from the Podfile and 1 total pod installed.
</code></pre><h2 id="Start"><a href="#Start" class="headerlink" title="Start!"></a>Start!</h2><p>以后打开项目点击xcworksapce后缀的文件，不要点击原来的项目文件。<br>导入头文件应该使用:</p>
<pre><code>#import &lt;&lt;#header#&gt;&gt;
</code></pre><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>platform :ios, ‘9.0’ 用来设置所有第三方库所支持的iOS最低版本<br>pod ‘SDWebImage’,’~&gt;2.6’ 设置框架的名称和版本号</p>
<p>版本号的规则：<br>‘&gt;1.0’    可以安装任何高于1.0的版本<br>‘&gt;=1.0’   可以安装任何高于或等于1.0的版本<br>‘<1.0' 任何低于1.0的版本="" '<="1.0'" 任何低于或等于1.0的版本="" '~="">0.1’   任何高于或等于0.1的版本，但是不包含高于1.0的版本<br>‘~&gt;0’     任何版本，相当于不指定版本，默认采用最新版本号</1.0'></p>
<h1 id="pod-install过程"><a href="#pod-install过程" class="headerlink" title="pod install过程"></a>pod install过程</h1><ol>
<li>分析依赖:该步骤会分析Podfile,查看不同类库之间的依赖情况。如果有多个类库依赖于同一个类库，但是依赖于不同的版本，那么cocoaPods会自动设置一个兼容的版本。</li>
<li><p>下载依赖:根据分析依赖的结果，下载指定版本的类库到本地项目中。</p>
</li>
<li><p>生成Pods项目：创建一个Pods项目专门用来编译和管理第三方框架，CocoaPods会将所需的框架，库等内容添加到项目中，并且进行相应的配置。</p>
</li>
<li>整合Pods项目：将Pods和项目整合到一个工作空间中，并且设置文件链接。</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>Mac显示隐藏的文件</p>
<pre><code>defaults write com.apple.finder AppleShowAllFiles -boolean true ; 
killall Finder
</code></pre><p>Mac取消显示隐藏文件</p>
<pre><code>defaults write com.apple.finder AppleShowAllFiles -boolean false ; 
killall Finder
</code></pre><blockquote>
<p>参考并致谢:<br><a href="http://blog.csdn.net/lissdy/article/details/9191351" target="_blank" rel="external">http://blog.csdn.net/lissdy/article/details/9191351</a><br><a href="http://www.cnblogs.com/yan520/p/5583362.html" target="_blank" rel="external">http://www.cnblogs.com/yan520/p/5583362.html</a><br><a href="http://www.jianshu.com/p/32d9cfb91471" target="_blank" rel="external">http://www.jianshu.com/p/32d9cfb91471</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; Cocoapods是非常好用的第三方库管理工具. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://blog.chenyalun.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="ios开发" scheme="http://blog.chenyalun.com/tags/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记四：分类与代理</title>
    <link href="http://blog.chenyalun.com/2016/07/16/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9A%E5%88%86%E7%B1%BB/"/>
    <id>http://blog.chenyalun.com/2016/07/16/Objective-C学习笔记四：分类/</id>
    <published>2016-07-16T09:50:17.000Z</published>
    <updated>2016-10-25T14:37:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.16更正部分错别字</p>
</blockquote>
<p></p><p align="center"> 一些琐碎的笔记,关于分类、代理和block. </p><br><a id="more"></a> <p></p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>场合：在不修改原来类模型的情况下，给类扩充一些方法，且仅是方法，不扩充成员变量。可以给系统自带的类添加分类，扩充方法。（注意引入分类文件）<br>当添加分类的方法是重写原来类中的方法时,不需要引入分类文件。<br>声明文件的命名方式 【类+分类.h】</p>
<pre><code>@interface 类名 (分类名)
@end
</code></pre><p>实现文件的命名方式 【类+分类.m】</p>
<pre><code>@implementation 类名 (分类名)
@end
</code></pre><p>特征：用括号括住添加的分类<br>好处：一个庞大的类可以分模块开发、由多个人编写，有利于团队合作。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>1，分类可以访问原来类中的成员变量，但不能增加成员变量。（若要增加成员变量，可以使用继承）</p>
<p>2，分类的优先级最高，当调用类中的一个方法时，优先去分类中查找，再去原类中查找，最后去父类中查找。也即，倘若在分类中重写了原类中的方法，会覆盖掉原来的方法，导致原来的方法无法使用。（不建议重写原来类中的方法）<br>重写会出现警告：Category is implementing a method which will also be implemented by its primary class.</p>
<p>3，如果多个分类中有相同（方法签名相同，但不一样）的方法，则调用的是最后编译的方法。</p>
<h2 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h2><ul>
<li>方式1，直接在.m文件中写方法实现，不要在.h文件中进行方法声明</li>
<li>方式2，在.m文件中定义一个category，然后在category中声明一些方法，最后在@implementation和@end之间作方法实现。</li>
</ul>
<h1 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h1><p>类也是一个对象，是Class类型的对象，简称类对象，类对象就是类。<br>class类型的定义:<code>typedef struct objc_class *Class;</code><br>类名代表着类对象，每个类只有一个类对象。</p>
<h2 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h2><p>在程序启动的时候，就会加载所有的类和分类，并调用一次所有类和分类的+load方法；</p>
<ul>
<li>先加载父类，再加载子类，也即先调用父类的+load方法，再调用子类的+load方法;</li>
<li>先加载原始类，再加载分类（顺序也即父类——父类的分类——子类）。</li>
<li>不管程序运行过程中有没有用到这个类，都会调用+load加载。</li>
</ul>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h2><p>在第一次使用某个类时（比如创建对象），就会调用一次+initialize方法<br>一个类只会调用一次+initialize方法，先调用父类的，再调用子类的<br>获取类对象的两种方式</p>
<pre><code>Class c = [Person class];//类方法
</code></pre><p>或者</p>
<pre><code>Person *p = [Person new];
Class c = [p class];//对象方法
</code></pre><p>很明显，[p class]和[Person class]方法返回的都是是class类型<br>类对象调用类方法：</p>
<pre><code>Class c=[Person class];
  Person *p2=[c new];
</code></pre><h2 id="description方法"><a href="#description方法" class="headerlink" title="description方法"></a>description方法</h2><p>类似其他语言的ToString方法，NSObject自带的方法。返回值类型是<code>NSString ＊</code><br>默认情况下，使用NSLog和%@打印一个对象，输出的是&lt;类名:内存地址&gt;<br>如：<code>&lt;Person: 0x1002070a0&gt;</code><br>而NSLog(@”%@”,p)会调用-description方法</p>
<h3 id="description方法-1"><a href="#description方法-1" class="headerlink" title="-description方法"></a>-description方法</h3><p>使用NSLog和%@输出某个对象时，会调用对象的-description方法</p>
<h3 id="description方法-2"><a href="#description方法-2" class="headerlink" title="+description方法"></a>+description方法</h3><p>使用NSLog和%@输出某个类对象时，会调用类对象的+description方法</p>
<p>可以重写+description和-description方法修改NSLog的默认输出<br>注意：如果在-description方法中使用NSLog打印self，会造成死循环。</p>
<pre><code>// 重写-description方法
-(NSString *)description
{
  return [NSString stringWithFormat:@”%@”, self];    
}
</code></pre><p>编译无警告，无报错，运行出错。<br>真正重写：<br>假设属性为</p>
<pre><code>// 重写-description方法
-(NSString *)description
{
  return [NSString stringWithFormat:@”姓名：%@ 年龄：%d”, _name,_age];
}
</code></pre><h1 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h1><p>每个类的方法列表都存储在类对象中,每个方法都有一个与之对应的SEL类型的对象<br>根据一个SEL对象就可以找到方法的地址，进而调用方法<br>SEL类型定义</p>
<pre><code>typedef struct objc_selector *SEL;
</code></pre><p>SEL对象的创建：</p>
<pre><code>SEL s=@selector(test);
SEL s2=NSSelectorFromString(@”test”);
</code></pre><p>将SEL对象转换为NSString对象</p>
<pre><code>NSString *s3=NSStringFromSelector(s);
</code></pre><p>调用对象p的show方法：</p>
<pre><code>// 创建p对象
Person *p=[[Person alloc] init];
// 将show方法封装为SEL类型数据的s
SEL s=@selector(show);
// 调用s间接调用show方法
  [p performSelector:s];
</code></pre><h2 id="p-test-原理解释"><a href="#p-test-原理解释" class="headerlink" title="[p test]原理解释"></a>[p test]原理解释</h2><ol>
<li>把test包装成SEL类型的数据</li>
<li>根据SEL数据找到对应的方法地址</li>
<li>根据方法地址调用相应的方法<br>消息就是SEL。</li>
</ol>
<h1 id="NSLog方法总结"><a href="#NSLog方法总结" class="headerlink" title="NSLog方法总结"></a>NSLog方法总结</h1><ol>
<li><p>打印对象的内存地址</p>
<pre><code>NSLog(@”%p”,p);
</code></pre></li>
<li><p>打印指针的内存地址（&amp;p取出地址）</p>
<pre><code>NSLog(@”%p”,&amp;p);
</code></pre></li>
<li><p>打印某一对象（默认返回类名+内存地址，可以通过重写-description方法改变输出内容）</p>
<pre><code>NSLog(@”%@”,p);
</code></pre></li>
<li><p>打印代码行号</p>
<pre><code>NSLog(@”%d”,__LINE__);
</code></pre></li>
<li><p>打印文件路径</p>
<pre><code>NSLog(@”%d”,__FILE__);
</code></pre><p>注意：如果文件路径中存在中文，则无法输出<br>这时可以使用：</p>
<pre><code>printf(“%s\n”__FILE__);输出包含中文字符的路径（\n只是为了观看清晰）
</code></pre></li>
<li><p>打印当前函数名称</p>
<pre><code>NSLog(@”%s”,__func__);
</code></pre><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1></li>
</ol>
<p>一系列方法的列表（不能增加成员变量）。其中声明的方法可以被任何类实现，这种模式一般称作代理（delegation）。<br>如果一些类之间没有继承的关系，但是有某些相同的行为，这时要考虑使用代理。<br>代理的定义：<br>当一代理只针对某个类中，代理最好放在一个类的.h文件中，使用时引入即可。（假定在Person.h文件中）</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface Person : NSObject
@end

// 要在@interface之外设置代理
@protocol MyProtocol &lt;NSObject&gt;
// 必须实现的方法
@required
-(void)show;
-(void)myShow;
// 可选实现的方法
@optional
+(void)herShow;
@end
</code></pre><p>在Dog.h文件中遵守协议：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
// 声明协议@protocol  MyProtocol;
@protocol  MyProtocol;

@interface Dog : NSObject&lt;MyProtocol&gt;
// 遵守某个协议
// 注意导入协议文件#import &quot;Person.h&quot;或者声明协议@protocol  MyProtocol;
-(void)show;
-(void)myShow;
@end
</code></pre><p>当某一代理用在多个类中，协议需要放在单独创建的.h文件中<br>此时创建的只有一个名为BigProtocol的.h文件。</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt; 
@protocol BigProtocol &lt;NSObject&gt;
@required
-(void)bigShow;
@optional
-(void)bigShow2;
@end
</code></pre><p>在Cat.h文件中遵守协议</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
//@protocol BigProtocol;
#import &quot;BigProtocol.h&quot;
 @interface Cat : NSObject&lt;BigProtocol&gt;
-(void)bigShow;
@end
</code></pre><p>在Dog.h文件中遵守协议</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
//@protocol BigProtocol;
#import &quot;BigProtocol.h&quot;
@interface _Dog : NSObject&lt;BigProtocol&gt;
-(void)bigShow;
-(void)bigShow2;
@end
</code></pre><h2 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li><p>在遵守协议时，如果使用@protocol BigProtocol;编译器会警告：无法找到协议的定义<br>而使用<code>#import “BigProtocol.h“</code>，则完全没有问题。</p>
</li>
<li><p>如果某个类遵守多个协议，协议之间用逗号分隔：</p>
<pre><code>@interface Cat : NSObject&lt;BigProtocol,MyProtocol&gt;
</code></pre></li>
<li><p>一个协议本身可以遵守其他协议，如遵守名字叫NSObject的协议（默认是这种情况，基协议NSObject）<br>如果A协议遵守B协议，这时A协议就能拥有B协议的所有方法声明。</p>
<pre><code>@protocol BigProtocol &lt;NSObject&gt;
@end
</code></pre></li>
</ol>
<p>BigProtocol拥有NSObject协议的所有方法声明。</p>
<ol>
<li><p>约定框架中后缀为Delegate的都是协议。（协议类似其他语言的接口，就像C#中默认以I开头的都是接口 ）</p>
</li>
<li><p>要求某个对象必须遵守某个协议（如要求obj保存的对象遵守协议MyProtocol，并且继承Person）</p>
<pre><code>Person&lt;MyProtocol&gt; *obj=[[Person alloc] init];
</code></pre></li>
<li><p>利用conformsToProtocol:判断某个类是否实现了某个协议</p>
<pre><code>Cat *c=[[Cat alloc] init ];
bool result=  [c conformsToProtocol:@protocol(BigProtocol)];
NSLog(@&quot;%@&quot;,result?@&quot;YES&quot;:@&quot;NO&quot;);
[c conformsToProtocol:@protocol(BigProtocol)];返回的是bool类型。
</code></pre></li>
</ol>
<h1 id="block"><a href="#block" class="headerlink" title="block"></a>block</h1><p>块。<br>有返回值（void也可以）、有形参。block封装了一段代码，可以在任何时候执行。block可以作为函数参数或者函数返回值，而其本身又可以带输入参数和返回值。<br>在多线程，异步任务，集合遍历，集合排序，动画专场使用较多。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>返回值类型  (^+block名称)(参数类型列表)=^(参数列表){   代码内容  };
</code></pre><ol>
<li><p>注意大括号后面有分号</p>
</li>
<li><p>对比函数</p>
<pre><code>int (^MySum)(int ,int )=^(int a,int b){ return a+b;};
int     MySum (int a,int b){return a+b;}
</code></pre></li>
<li><p>block可以访问局部变量，但不能更改局部变量。<br>如果更改则报错：Variable is not assignable (missing__block type specifier)，如：</p>
<pre><code>int c=10;
// Block的定义
int (^MySum)(int ,int )=^(int a,int b)
{
  c=21;
  return a+b+c;
};
NSLog(@&quot;%i&quot;,MySum(10,20));
</code></pre></li>
</ol>
<p>如果硬是要修改：在局部变量前面加上<code>__block</code> ，如   <code>__block int c=21;</code>这时，便可以在block中修改局部变量了。</p>
<pre><code>__block  int c=10;
        // Block的定义
        int (^MySum)(int ,int )=^(int a,int b)
        {
             c=21;
            return a+b+c;
        };
        NSLog(@&quot;%i&quot;,MySum(10,20));
</code></pre><p>4 . block的调用，和函数一样，使用名称即可：<code>MySum(_形参列表);</code></p>
<p>5 . 如果block没有形参，则可以省略等号后面的()<br>如：  </p>
<pre><code>int (^SomeSum)()=^{return 25;};
</code></pre><p>但是等号前面的两对括号不可省略。</p>
<p>6 . 利用typedef声明类型</p>
<pre><code>格式：typedef  返回值类型 (^block块名称)(参数_类型列表)
例如：typedef int (^MyBlock)(int,int);

以后就可以用MyBlock这种类型定义Block变量
  MyBlock m=^(int a,int b){return a+b;};
        int c=m(15,25);
        NSLog(@”%i”,c);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.16更正部分错别字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;p align = &quot;center&quot;&gt; 一些琐碎的笔记,关于分类、代理和block. &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://blog.chenyalun.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://blog.chenyalun.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记三：点语法与自动属性</title>
    <link href="http://blog.chenyalun.com/2016/05/18/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E7%82%B9%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7/"/>
    <id>http://blog.chenyalun.com/2016/05/18/Objective-C学习笔记三：点语法与自动属性/</id>
    <published>2016-05-17T21:00:07.000Z</published>
    <updated>2016-10-25T14:09:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.16更正部分错别字<br>2016.05.24更正@private相关错误</p>
</blockquote>
<p align="center"> 点语法和自动属性的一些笔记. </p>



<a id="more"></a> 
<h3 id="点语法"><a href="#点语法" class="headerlink" title="点语法"></a>点语法</h3><p>本质是方法调用，不访问成员变量。前提是已经存在get和set方法(否则报错：Property ‘age’ not found on object of type ‘Person *’)。</p>
<pre><code>[p setAge:50];
int result=[p age];
NSLog(@”result的结果是：%i”,result);
</code></pre><p>相当于：</p>
<pre><code>p.age=50;
int result=p.age;
NSLog(@”result的结果是：%i”,result);
</code></pre><p>注意：此处的result未必等于50，因为在set方法中，age的值可能改变。</p>
<h4 id="方法的展开原理："><a href="#方法的展开原理：" class="headerlink" title="方法的展开原理："></a>方法的展开原理：</h4><p>[p        setAge   :      50];</p>
<p>对应</p>
<p>p     .     age=        50;</p>
<p>而<br>int result=[p       age];</p>
<p>对应<br>int result=p       .       age;</p>
<h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>1，set方法中</p>
<pre><code>-(void)setAge:(int)a
{
    self.age=a;
}
</code></pre><p>实际上是在set方法中调用set方法。</p>
<pre><code>-(int)age
{
    return self.age;
}
</code></pre><p>在get方法中调用get方法。<br>以上编译链接均无警告、无错误，但是运行会报错。</p>
<h3 id="成员变量的作用域"><a href="#成员变量的作用域" class="headerlink" title="成员变量的作用域"></a>成员变量的作用域</h3><h4 id="private"><a href="#private" class="headerlink" title="@private"></a>@private</h4><p>私有。<br>只能在当前类的对象方法中直接访问（当前类的对象方法的@implementation中访问），子类虽然继承（内存中存在），但无权限访问（感觉貌似没有继承，一层网给过滤掉。</p>
<h4 id="protected"><a href="#protected" class="headerlink" title="@protected"></a>@protected</h4><p>保护（默认是保护，不是私有）。<br>可以在当前类和子类的对象方法中直接访问（当前类和子类的@implementation中访问）。<br>假设父类Person有保护的成员变量_number，子类继承，什么变量都不增加，那么子类对象方法中访问的是父类的_number。</p>
<pre><code>-(void)show
{
    self-&gt;_number=1000;
    int result=self-&gt;_number;
    _number=5000;
    int result2= _number;
    NSLog(@”self-&gt;_number的值是：%i”,result);
    NSLog(@”_number的值是：%i”,result2);
}
</code></pre><h4 id="public"><a href="#public" class="headerlink" title="@public"></a>@public</h4><p>公开。任何地方都可以访问。一般用不到。</p>
<h4 id="package"><a href="#package" class="headerlink" title="@package"></a>@package</h4><p>同一个框架内可以访问，介于@public和@private之间。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>1,在类方法中不可能访问成员变量。<br>2,也可以在@implementation中声明成员变量。</p>
<pre><code>@implementation Student:NSObject
{
    @public int age;
    @private int number;
    @protected int no;
}
@end
</code></pre><p>然而.m文件一般不会被包含，也即一般没有必要访问，故而一般不把成员变量放在实现文件中。</p>
<h4 id="property和-synthesize属性合成"><a href="#property和-synthesize属性合成" class="headerlink" title="@property和@synthesize属性合成"></a>@property和@synthesize属性合成</h4><p>@property用在@interface中，代替get和set方法<br>如：<code>@property int age;</code><br>等价于</p>
<pre><code>-(int)age;
-(void)setAge:(int)age;
</code></pre><p>即便是<code>@property int _age;</code>那也会生成</p>
<pre><code>-(int)_age;
-(void)setAge:(int)_age;
</code></pre><p>而@synthesize用在@implementation实现中：@synthesize  age=成员变量名; 不允许对成员变量进行条件过滤，如@synthesize age=_age+100;</p>
<p><code>@synthesize age=_age;</code></p>
<p>等价于</p>
<pre><code>-(int)age
{
    return _age;
}
-(void)setAge:(int)age
{
    _age=age;
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> 1，如果.h文件中没有这个_age成员变量。那么，利用@property可以自动生成私有@private的_age。而默认的_age却是@protected的。<br> 2，@synthesize age将会访问age这个成员变量而非_age。<br> 3，若手动实现getter方法，编译器只会自动生成setter方法；若手动实现setter方法，编译器只会自动生成getter方法。</p>
<h5 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h5><p>@property已经独揽@synthesize的实现了，也即</p>
<p><code>@synthesize age=_age;</code>可以省略。只用写<code>@property int  age</code>就好了。（当然，前提是不对参数进行过滤，直接传到成员变量中，如果要过滤，还是要自己生成相应的方法。）</p>
<p> 4，默认情况下，getter和setter方法中的实现会访问下划线开头的成员变量。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>相当于<code>NSObject  *</code>  ，是万能指针。</p>
<h4 id="id类型的定义"><a href="#id类型的定义" class="headerlink" title="id类型的定义"></a>id类型的定义</h4><pre><code>typedef struct objc_object {
Class isa;
}*id;
</code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>用来初始化对象的方法，完整地创建一个可用对象。</p>
<p><code>Person *p=[Person alloc];</code><br>+alloc方法分配存储空间，返回对象。</p>
<p><code>p=[p init];</code><br>-init方法初始化</p>
<h4 id="init方法的重写"><a href="#init方法的重写" class="headerlink" title="init方法的重写"></a>init方法的重写</h4><p>目的：在对象创建完毕之后，使成员变量就有了一些默认的值。<br>注意：一定要先调用父类的构造方法，再进行子类内部成员变量的初始化<br>在@implementation中进行重写：</p>
<pre><code>-(id)init
{
    // 一定要先调用super的init方法，这是为了初始化父类的一些成员变量和其他属性
    self=[super init];
    // 判断对象是否初始化成功，如果对象初始化成功，再进行接下来的自定义初始化
    if(self!=nil)
    {
           _age=10086;
    }
    // 返回一个已经初始化完毕的对象
    return self;
}
</code></pre><p>上面代码不够简化，一般用下面代码。</p>
<pre><code>-(id)init
{
       // 简化版
    if([super init])
    {
        _age=10086;
    }
    return self;
}
</code></pre><h4 id="自定义构造方法"><a href="#自定义构造方法" class="headerlink" title="自定义构造方法"></a>自定义构造方法</h4><p>要求：是对象方法（对象的初始化），返回值是id类型，方法名以initWith开头。<br>注意：-init方法重写不需要在@interface中声明，因为已经声明过了，而自定义的构造方法需要在@interface中显式声明。</p>
<pre><code>// 声明
-(id)initWithAge:(int)age;




// 实现
-(id)initWithAge:(int)age
{
    if([super init])
    {
        _age=age+100;
    }
    return self;
}
</code></pre><p>调用示例：</p>
<pre><code>Person *p=[Person alloc];
p=[p init];
int r=p.age;
NSLog(@”r的值是%i”,r);

p= [p initWithAge:110];
int r2=p.age;
NSLog(@”r2的值是%i”,r2);
</code></pre><p>显而易见一个对象可以初始化多次。</p>
<p>含有多个参数的构造方法：<br><code>-(id)initWithAge:(int)age andNumber:(int)number;</code></p>
<h3 id="h文件和-m文件"><a href="#h文件和-m文件" class="headerlink" title=".h文件和.m文件"></a>.h文件和.m文件</h3><p>每个类分布在不同的文件中<br>类的声明放在.h文件中，类的实现放在.m文件中<br>若想使用某个类，就包含某个类的.h文件即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.16更正部分错别字&lt;br&gt;2016.05.24更正@private相关错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 点语法和自动属性的一些笔记. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://blog.chenyalun.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://blog.chenyalun.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记二：继承与属性</title>
    <link href="http://blog.chenyalun.com/2016/05/16/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7/"/>
    <id>http://blog.chenyalun.com/2016/05/16/Objective-C学习笔记二：继承与属性/</id>
    <published>2016-05-16T11:22:17.000Z</published>
    <updated>2016-10-28T13:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.25 回顾</p>
</blockquote>
<p align="center"> 关于继承与属性的笔记. </p>

<a id="more"></a>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>优点：过滤不合理的值，屏蔽内部的赋值过程，让外界不必关注内部的细节。</p>
<p>成员变量的命名：以下划线开头。用于区分get方法名称和局部变量名称。尽量不设置为@public公有属性</p>
<pre><code>{
  int _speed;
}
</code></pre><p>set方法：设置成员变量，过滤一些不符合要求的值。以set开头，返回类型为void，后面跟上成员变量名，形参不与成员变量重名，形参类型与成员变量相同，成员变量的首字母大写。在set方法中设置行为，监听属性的改变。</p>
<pre><code>-(void)setSpeed:(int)s;

-(void)setSpeed:(int)s

{

_speed=s+20;

}
</code></pre><p> get方法：获取对象内部的成员变量，不接收参数，返回类型与成员变量类型相同，方法名称与成员变量名称相同（不含下划线）。不推荐以get开头。</p>
<pre><code>-(int)speed;

-(int)speed

{

return _speed;

}
</code></pre><p>只读：只提供get方法。可读可写：提供get和set方法。</p>
<h1 id="OC的弱语法"><a href="#OC的弱语法" class="headerlink" title="OC的弱语法"></a>OC的弱语法</h1><h2 id="调用未声明、未实现的对象方法"><a href="#调用未声明、未实现的对象方法" class="headerlink" title="调用未声明、未实现的对象方法"></a>调用未声明、未实现的对象方法</h2><p>编译 报错 <code>No visible @interface for ‘Dog’ declares the selector ‘ssss’</code>，链接运行 报错。</p>
<p><code>reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1002014a0’</code></p>
<p>给Dog对象发送不能识别的消息。</p>
<h2 id="调用已声明、未实现的对象方法"><a href="#调用已声明、未实现的对象方法" class="headerlink" title="调用已声明、未实现的对象方法"></a>调用已声明、未实现的对象方法</h2><p>编译警告：<code>Method definition for ‘ssss’ not found</code> 未实现方法 链接正常，运行报错</p>
<p><code>reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1001002a0’</code></p>
<h2 id="调用未声明、已实现的对象方法"><a href="#调用未声明、已实现的对象方法" class="headerlink" title="调用未声明、已实现的对象方法"></a>调用未声明、已实现的对象方法</h2><p>编译 链接运行 错误 <code>No visible @interface for ‘Dog’ declares the selector ‘ssss’</code></p>
<p>在Dog的@interface中，对于ssss的声明是不可见的。</p>
<h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><p>类本身在内存中占据存储空间，里面有类\对象方法列表。直接通过类名执行的方法。</p>
<p>以+开头，只能由类名调用，类方法中不能访问成员变量（实例变量）。允许类方法与对象方法重名。(执行者不同，当然可以重名！)</p>
<p>使用场合：当不需要访问成员变量的时候，尽量使用类方法，提升效率。</p>
<p>输出类的名称：</p>
<pre><code>+(void)showClassName;

+(void)showClassName

{

NSLog(@”类的名称是：%@”,NSStringFromClass([self class]));

}
</code></pre><p>调用：<code>[Dog showClassName];</code></p>
<h1 id="self关键字"><a href="#self关键字" class="headerlink" title="self关键字"></a>self关键字</h1><p>self是指针，指向当前对象或类的调用者。出现在对象方法中，代表当前对象，出现在类方法中，代表当前类。不能出现在函数中（会报错：<code>Use of undeclared identifier ‘self’</code>使用未声明的标识符）。</p>
<p>用途：</p>
<ol>
<li><p>self-&gt;成员变量名 在对象方法中访问当前方法调用的成员变量，也即当成员变量与局部变量同名时，用来区分同名的局部变量。</p>
<pre><code>-(void)showSelfOfObject;

-(void)showSelfOfObject

{

NSLog(@”showSelfOfObject方法被调用”);

int _speed;

self-&gt;_speed=200;

_speed+=1000;

int result= self-&gt;_speed+10;

NSLog(@”result的值是：%i”,result);

NSLog(@”_speed的值是：%i”,_speed);

}
</code></pre></li>
</ol>
<p>当成员变量与局部变量同名时（编译警告<code>Local declaration of ‘_speed’ hides the instance variable</code>局部变量隐藏了成员变量），采用就近原则，访问局部变量。因此需要用self访问成员变量。</p>
<ol>
<li>方法的调用:在对象方法中调用当前对象的对象方法以及在类方法中调用当前类的类方法</li>
</ol>
<p>在对象方法中调用当前对象的对象方法</p>
<pre><code>-(void)showSelfOfObject;

-(void)showTestObject;

-(void)showSelfOfObject

{

NSLog(@”showSelfOfObject方法被调用”);

}

-(void)showTestObject

{

[self showSelfOfObject];

}
</code></pre><p>在类方法中调用当前类的类方法</p>
<pre><code>+(void)showSelfOfClass;

+(void)showTestClass;

+(void)showSelfOfClass

{

NSLog(@”showSelfOfClass方法被调用”);

}

+(void)showTestClass

{

[self showSelfOfClass];

}
</code></pre><p>常见错误：</p>
<ol>
<li><p>在对象方法中调用类方法（编译错误<code>No visible @interface for ‘Dog’ declares the selector ‘showSelfOfClass‘</code>）错误相当于未声明未定义却调用这个方法。</p>
</li>
<li><p>在类方法中调用对象方法（编译错误<code>No known class method for selector ‘showSelfOfObject‘</code>）未知的类方法</p>
</li>
</ol>
<p>3，self的死循环:调用本身</p>
<pre><code>-(void)showSelfOfObject

{

NSLog(@”showSelfOfObject方法被调用”);

[self showSelfOfObject];

}
</code></pre><p>4，调用函数</p>
<p>函数不依赖对象。<code>void f(); [self f]</code> 错误</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>场景：当两个类拥有相同的属性和方法时，将相同的内容抽取到父类中。当A类完全拥有B类的部分属性或方法时，考虑A类作为父类。</p>
<ol>
<li><p>父类必须声明在子类前面。</p>
</li>
<li><p>不允许子类和父类拥有相同的成员变量（如果子类有和父类拥有相同的成员变量，意味着，同一成员变量声明定义两次，编译错误 <code>Duplicute member ‘_age’</code>，哪怕成员变量的访问属性不同，子类公开父类私有，或者父类公开子类私有，都不行！）</p>
</li>
<li><p>子类方法和属性的访问过程：如果子类没有，再访问父类。即由子类开始。</p>
</li>
<li><p>Objective-C中只有单继承（与C＋＋不同）</p>
</li>
</ol>
<p>方法的重写:父类和子类拥有相同签名的类方法或者对象方法（子类重新实现了父类中的方法），则优先调用子类的同名方法。</p>
<pre><code>父类Person：

-(void)show

{

NSLog(@”调用了Person的show方法”);

}

子类Student：

-(void)show

{

//[super show];

NSLog(@”调用了Student的show方法”);

}

调用：

Student *p=[[Student alloc] init]; [p show];
</code></pre><p>很明显，调用的是重写的子类Student的show方法。</p>
<h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><p>场景：子类重写父类的方法时，想调用父类的方法（包括类方法和对象方法）。</p>
<p>效果与self类似，super在对象方法中就调用父类的对象方法，在类方法中就调用父类的类方法。</p>
<p>继承可以在不改变原来模型的基础上拓充方法，抽取公共代码，建立类与类之间的联系，减少代码的冗余性，但是，会增加耦合性。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>某一种事物的多种形态。<br>在实现继承的前提下，父类类型指针指向子类对象（右边是左边），指向子类对象的父类指针可以调用子类中重写父类的方法，但是指向子类对象的父类指针不能调用子类中拓展的方法（父类中没有的方法）。</p>
<pre><code>Person *p=[[Student alloc] init];

[p show];
</code></pre><p>Student是Person，show方法在子类和父类中都有，这里调用的是子类的show方法。</p>
<p>当子类拓展了一个showStudent对象方法，如果还想调用，则强制转换：将指向子类对象的父类指针强制转化为子类指针。</p>
<pre><code>Person *p=[[Student alloc] init];

Student p2=(Student )p;

[p2 showStudent];
</code></pre><p>将父类指针p强制转换为子类指针，使它可以调用子类Student拓展的showStudent方法。</p>
<p>如果不做强制转换，而直接调用子类拓展的方法</p>
<pre><code>Person *p=[[Student alloc] init];

[p showStudent];
</code></pre><p>编译报错： <code>No visible @interface for ‘Person’ declares the selector ‘showStudent’</code></p>
<p>转换语法： { 相应子类名 p=(父类名 )指向子类对象的父类指针；}</p>
<p>主要应用：<strong>动态绑定</strong><br>如果参数使用父类类型，可以传入父类、子类对象，调用相应的方法（如将子类对象传递给参数，调用子类的方法；将父类对象传递给参数，则调用父类的方法）</p>
<p>例如，Person和Student中都有同名show对象方法，可以通过test函数传入的参数判断调用哪个方法。</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

#import “Person.h”

#import “Student.h”

void test(Person * p)

{

[p show];

}

int main(int argc, const char * argv[]) {

@autoreleasepool {

Person *p=[[Person alloc] init];

Student *s=[[Student alloc] init];

test(p);

test(s);

}

return 0;

}
</code></pre><h1 id="NSString的使用"><a href="#NSString的使用" class="headerlink" title="NSString的使用"></a>NSString的使用</h1><ol>
<li><p>创建字符串与输出字符串</p>
<pre><code>NSString *s=@”Sometimes”;

NSLog(@”%@”,s);
</code></pre></li>
<li><p>格式化字符串</p>
<pre><code>int age=85;

NSString *s=[NSString stringWithFormat:@”传入的年龄参数是%d”,age];

NSLog(@”%@”,s);
</code></pre></li>
<li><p>调用NSString类方法。<br>length返回字数（不是字符数）</p>
<pre><code>NSString *s=@”123 456”;

NSLog(@”%@”,s);

NSUInteger size=[s length];

NSLog(@”%lu”,(unsigned long)size);
</code></pre></li>
</ol>
<p>返回的是7，包括空格。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.25 回顾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 关于继承与属性的笔记. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://blog.chenyalun.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://blog.chenyalun.com/tags/Objective-C/"/>
    
      <category term="ios开发" scheme="http://blog.chenyalun.com/tags/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记一：类</title>
    <link href="http://blog.chenyalun.com/2016/05/12/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E7%B1%BB/"/>
    <id>http://blog.chenyalun.com/2016/05/12/Objective-C学习笔记一：类/</id>
    <published>2016-05-11T21:00:49.000Z</published>
    <updated>2016-10-28T13:22:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.28 回顾</p>
</blockquote>
<p align="center"> 万物皆是对象. </p>

<a id="more"></a>
<h1 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h1><p>三要素：事物名称（类名）；属性；行为（功能）</p>
<p>具有相同（或者类似）属性和行为的对象可以抽象出一个类。</p>
<h1 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h1><p>类名<br>1，首字母大写；2，不能有下划线；3，多个英文单词，使用驼峰标识</p>
<p>行为<br>哪个对象最清楚行为怎么做，就把行为设计在哪个对象身上</p>
<pre><code>@interface Person : NSObject

{

@public

int _age;

bool _sex;

}

-(void)print;

@end
</code></pre><p>大括号内用来声明对象属性（成员变量也即实例变量）,@public让外界指针可以间接访问对象内部的成员变量。成员变量默认会初始化为0.</p>
<p><code>: NSObject</code>（继承基类）使声明的类具有创建对象的能力。</p>
<h1 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h1><pre><code>@implementation Person

-(void)print

{

NSLog(@”输出内容”);

}

@end
</code></pre><p>已经导入声明文件<code>#import “Person.h”</code><br>类的实现即方法的实现。</p>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><pre><code>Person *p=[[Person alloc] init];

[p print];
</code></pre><p>对象的本质是结构体，对象需要通过指针操纵。</p>
<p>类在内存中也占据存储空间，在创建对象之前为类分配一份内存空间，将类加载进内存。而且只存储方法列表，其中由类产生的对象，都有一个isa指针指向类。</p>
<p>方法调用：<code>[行为执行者   行为名称]</code>;</p>
<p><code>[Person new]</code>执行Person这个类的new行为创建对象，返回对象地址。</p>
<p><code>Person *p=[Person new];</code>定义一个Person 类型的指针变量p，指向Person类型的对象。指针的类型是Person *，指针指向的类型是Person。</p>
<p><code>[p print];</code>表示给p指向的对象发送一条print消息。</p>
<p><code>Person p=[Person new];</code>等价于 <code>Person p;p=[Person new];</code>另外<code>Person *p2=p;</code>表示p2、p指向同一个内容。<code>p=p2</code>:将p2存储的指针交给p，使p存储的也是p2存储的内容。</p>
<h1 id="方法与函数的区别以及注意"><a href="#方法与函数的区别以及注意" class="headerlink" title="方法与函数的区别以及注意"></a>方法与函数的区别以及注意</h1><ul>
<li><p>OC方法只能声明在@interface和@end之间，只能实现在@implementation和@end之间。也就是说OC方法不能独立于类存在</p>
</li>
<li><p>C函数不属于类，跟类没有联系，C函数只归定义函数的文件所有</p>
</li>
<li><p>C函数不能访问OC对象的成员</p>
</li>
<li><p>对象方法归类／对象所有，函数属于整个文件所有，任何地方都可以放置函数（如果放在@interface与@end之间，将会忽略掉函数，即未定义）</p>
</li>
<li><p>方法只有声明，没有实现（经典错误）</p>
</li>
<li>方法没有声明，只有实现（编译器警告，但是能调用，OC的弱语法）</li>
<li>编译的时候：访问没有的成员变量直接报错，访问没有的方法，只是警告</li>
<li>同一个类中不允许两个对象方法同名</li>
</ul>
<h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><p>属性访问 <code>[Car new]-&gt;speed = 200;</code></p>
<p>方法调用<code>[ [Car new] run];</code></p>
<h1 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h1><p>不带参数的对象方法：</p>
<p><code>-(void)print; 方法名print</code></p>
<p>带一个参数的对象方法：</p>
<p><code>-(void)print:(int) a; 方法名print :</code></p>
<p>带多个参数的对象方法：</p>
<p><code>-(void)print:(int) a WithOther:(int) b;</code>方法名</p>
<p><code>print : WithOther:</code></p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><pre><code>typedef enum｛

SexMan,

SexWoman

｝Sex;
</code></pre><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><pre><code>typedef struct{

int year;

int month;

int day;

} Date;
</code></pre><p>访问枚举：<code>s-&gt;sex=SexMan;</code></p>
<p>访问结构体：<code>s-&gt;birthday.year=2016;</code></p>
<p>定义结构体：</p>
<p><code>Date d={2016,4,30};</code></p>
<p>访问结构体：</p>
<pre><code>s-&gt;birthday.year=2016;

s-&gt;birthday.month=4;

s-&gt;birthday.day=16;
</code></pre><p>等价于：</p>
<pre><code>Date d={2016,4,16};

s-&gt;birthday=d;
</code></pre><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>打印函数中注意％与%的区别</li>
<li>定义枚举、结构体等必需放在@interface的前面方可使用</li>
<li>OC方法中一个参数一个冒号</li>
<li>对象中有对象</li>
</ul>
<pre><code>@interface Student : NSObject

{

@public

//狗

Dog *dog;

}

-(void)letDogRun

{

[dog run];

}


// main.m文件

Student *stu=[Student new];

Dog *dog=[Dog new];

stu-&gt;dog=dog;

[stu letDogRun];
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.28 回顾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 万物皆是对象. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://blog.chenyalun.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://blog.chenyalun.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记八：简单的RSS阅读器</title>
    <link href="http://blog.chenyalun.com/2016/05/04/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%85%AB%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84RSS%E9%98%85%E8%AF%BB%E5%99%A8/"/>
    <id>http://blog.chenyalun.com/2016/05/04/UWP开发笔记八：简单的RSS阅读器/</id>
    <published>2016-05-03T21:00:23.000Z</published>
    <updated>2016-10-28T13:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>一个简单的RSS阅读器. </p>

<a id="more"></a>
<p>一个简单的RSS阅读器，实现任意开启RSS网站内容订阅，不过，只能在阅读器中搜集到标题、日期。后期再补充。</p>
<p>这次起，把所有功能代码放在类中，MainPage不能再那么随便了。</p>
<p>新建RSSClass类：</p>
<pre><code>    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    // ItemsControl
    using Windows.UI.Xaml.Controls;
    // KeyRoutedEventArgs 
    using Windows.UI.Xaml.Input;
    // SyndicationClient 
    using Windows.Web.Syndication;

    namespace RSS阅读器
    {
      public   class RssClass
        {
            // 下载指定url的feed条目，逐一将其整合到集合控件ItemsControl中
            private async void Load(ItemsControl list,Uri url)
            {
                // 从URL异步检索源
                SyndicationClient client = new SyndicationClient();
                // 开始一个异步操作以下载从给定的URI的聚合feed。
                SyndicationFeed feed =await client.RetrieveFeedAsync(url);
                // 遍历feed中的所有item，将其添加到list中
                foreach (var item in feed.Items)
                {
                    list.Items.Add(item);
                }
            }

            // 
            public void Start(ref ItemsControl list,string url,KeyRoutedEventArgs args)
            {
                // 当按下回车键时
                if (args.Key== Windows.System.VirtualKey.Enter)
                {
                    try
                    {
                        Load(list, new Uri(url));
                    }
                    catch (Exception)
                    {

                        throw;
                    }
                    // 设置控件的焦点
                    list.Focus(Windows.UI.Xaml.FocusState.Keyboard);
                }
            }
        }
}
</code></pre><p>页面代码：</p>
<pre><code>&lt;Grid.RowDefinitions&gt;
           &lt;RowDefinition Height=&quot;Auto&quot;/&gt;
           &lt;RowDefinition Height=&quot;*&quot;/&gt;
       &lt;/Grid.RowDefinitions&gt;
       &lt;TextBox Name=&quot;URLTextBox&quot;
                Margin=&quot;10&quot;
                KeyDown=&quot;URLTextBox_KeyDown&quot;
                PlaceholderText=&quot;请输入RSS地址&quot;/&gt;
       &lt;ScrollViewer VerticalScrollBarVisibility=&quot;Auto&quot;
                     HorizontalScrollBarVisibility=&quot;Auto&quot;
                     Margin=&quot;20&quot;
                     Grid.Row=&quot;1&quot;&gt;

           &lt;ItemsControl Name=&quot;ListItemsControl&quot;&gt;
                   &lt;ItemsControl.ItemTemplate&gt;
                       &lt;!--数据模板--&gt;
                       &lt;DataTemplate&gt;
                       &lt;StackPanel&gt;
                           &lt;!--超链接--&gt;
                           &lt;HyperlinkButton NavigateUri=&quot;{Binding Path=Links[0].Uri}&quot;&gt;
                               &lt;!--超链接标题--&gt;
                               &lt;HyperlinkButton.Content&gt;
                                   &lt;TextBlock Text=&quot;{Binding Path=Title.Text}&quot;/&gt;
                               &lt;/HyperlinkButton.Content&gt;
                           &lt;/HyperlinkButton&gt;

                           &lt;!--文章日期--&gt;
                           &lt;TextBlock Text=&quot;{Binding Path=PublishedDate}&quot;/&gt;
                       &lt;/StackPanel&gt;
                       &lt;/DataTemplate&gt;
                   &lt;/ItemsControl.ItemTemplate&gt;
               &lt;/ItemsControl&gt;

       &lt;/ScrollViewer&gt;
</code></pre><p>cs逻辑代码：</p>
<pre><code>private RssClass rss = new RssClass();
       private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
       {
           rss.Start(ref ListItemsControl, URLTextBox.Text, e);
       }
</code></pre><p>明显清晰许多。</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>ItemsControl的数据绑定：</p>
<pre><code>&lt;ItemsControl Name=&quot;ListItemsControl&quot;&gt;
            &lt;ItemsControl.ItemTemplate&gt;
                             &lt;DataTemplate&gt;

                              &lt;/DataTemplate&gt;
             &lt;/ItemsControl.ItemTemplate&gt;
&lt;/ItemsControl&gt;
</code></pre><p>ScrollViewer的两个属性：</p>
<pre><code>VerticalScrollBarVisibility=”Auto”
HorizontalScrollBarVisibility=”Auto”
</code></pre><p>绑定RSS内容：</p>
<p>链接：<br>        <code>&lt;HyperlinkButton NavigateUri=”{Binding Path=Links[0].Uri}”&gt;</code></p>
<p>链接标题：<code>&lt;TextBlock Text=”{Binding Path=Title.Text}”/&gt;</code></p>
<p>文章日期：<br>        <code>&lt;TextBlock Text=”{Binding Path=PublishedDate}”/&gt;</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;一个简单的RSS阅读器. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://blog.chenyalun.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://blog.chenyalun.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记七：WebView与简单浏览器</title>
    <link href="http://blog.chenyalun.com/2016/05/02/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%EF%BC%9AWebView%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://blog.chenyalun.com/2016/05/02/UWP开发笔记七：WebView与简单浏览器/</id>
    <published>2016-05-01T21:00:18.000Z</published>
    <updated>2016-10-28T13:33:09.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>利用webview控件可以简单制作一个浏览器. </p>

<a id="more"></a>
<p>利用webview控件可以简单制作一个浏览器，实现基本的前进、后退、刷新、停止等功能。不过需要注意的是，如果网页是在新窗口打开，那就承受不了了，将自动用系统默认浏览器打开。所以，前进、后退功能的前提是：打开的网页是在同一个窗口。</p>
<p>命令栏代码：</p>
<pre><code>&lt;Page.BottomAppBar&gt;
        &lt;AppBar IsOpen=”True”&gt;
            &lt;StackPanel Orientation=”Horizontal”&gt;
                &lt;AppBarButton Name=”BackAppBarButton”
                              Click=”BackAppBarButton_Click”
                              Label=”返回”
                              Icon=”Back”/&gt;
                &lt;AppBarButton Name=”ForwardAppBarButton”
                              Label=”前进”
                              Icon=”Forward”
                              Click=”ForwardAppBarButton_Click”/&gt;
                &lt;AppBarButton Name=”RefreshAppBarButton”
                              Label=”刷新”
                              Icon=”Refresh”
                              Click=”RefreshAppBarButton_Click”/&gt;
                &lt;AppBarButton Name=”StopAppBarButton”
                              Click=”StopAppBarButton_Click”
                              Label=”停止”
                              Icon=”Stop”/&gt;
            &lt;/StackPanel&gt;
        &lt;/AppBar&gt;
    &lt;/Page.BottomAppBar&gt;
</code></pre><p>页面：</p>
<pre><code>&lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height=”Auto”/&gt;
            &lt;RowDefinition Height=”*”/&gt;
        &lt;/Grid.RowDefinitions&gt;
        &lt;TextBox Name=”URLTextBox”
                 InputScope=”Url”
                 KeyDown=”URLTextBox_KeyDown”
                 Margin=”20”/&gt;
        &lt;WebView Name=”Web”
                 Grid.Row=”1”
                 NavigationCompleted=”Web_NavigationCompleted”/&gt;

&lt;/Grid&gt;
</code></pre><p>后台逻辑：</p>
<pre><code>     // 返回处理
            private void BackAppBarButton_Click(object sender, RoutedEventArgs e)
            {
                if (Web.CanGoBack)
                {
                    Web.GoBack();
                }
            }

    // 前进处理
    private void ForwardAppBarButton_Click(object sender, RoutedEventArgs e)
    {
        if (Web.CanGoForward)
        {
            Web.GoForward();
        }
    }

    // 刷新
    private void RefreshAppBarButton_Click(object sender, RoutedEventArgs e)
    {
        Web.Refresh();
    }

    // 停止
    private void StopAppBarButton_Click(object sender, RoutedEventArgs e)
    {
        Web.Stop();
    }

    // 按（回车）键处理
    private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
    {
        // 如果按下的键是回车键
        if (e.Key== Windows.System.VirtualKey.Enter)
        {
            // 导航到文本框中的地址
            Web.Navigate(new Uri(URLTextBox.Text));
        }

        // 处理焦点
        Web.Focus(FocusState.Keyboard);
    }

    // 导航完成事件处理
    private void Web_NavigationCompleted(WebView sender, WebViewNavigationCompletedEventArgs args)
    {
        // 导航是否成功
        if (args.IsSuccess)
        {
            // 参数传递到地址栏
            URLTextBox.Text = args.Uri.ToString();
    }

}&lt;/pre&gt;
</code></pre><p>可以看到效果(原谅我无耻地用了自己的博客）：</p>
<p>初始页面：<img src="http://images.chenyalun.cn/2016/04/23/001.png" alt=""></p>
<p>打开新链接：</p>
<p><img src="http://images.chenyalun.cn/2016/04/23/002.png" alt=""></p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>对键盘的按键（回车）键处理：</p>
<pre><code>private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
{
// 如果按下的键是回车键
if (e.Key== Windows.System.VirtualKey.Enter)
{
// 导航到文本框中的地址
Web.Navigate(new Uri(URLTextBox.Text));
}
}
</code></pre><p>对焦点的处理：<br><code>Web.Focus(FocusState.Keyboard);</code></p>
<p>还有就是，文本框（地址栏）输入的文本必须是URL，即 <a href="http://chenyalun.com/" target="_blank" rel="external">http://chenyalun.com/</a> 如果是chenyalun.com那就会报错了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;利用webview控件可以简单制作一个浏览器. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://blog.chenyalun.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://blog.chenyalun.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记六：幸运彩色小球</title>
    <link href="http://blog.chenyalun.com/2016/04/30/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9A%E5%B9%B8%E8%BF%90%E5%BD%A9%E8%89%B2%E5%B0%8F%E7%90%83/"/>
    <id>http://blog.chenyalun.com/2016/04/30/UWP开发笔记六：幸运彩色小球/</id>
    <published>2016-04-29T21:00:46.000Z</published>
    <updated>2016-10-28T13:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>幸运彩色小球游戏. </p>

<a id="more"></a>
<p>这个和随机数与筛子游戏有异曲同工之妙，通过随机函数产生一定范围大小的数字，根据数字大小设定不同的颜色，点击命令栏的新建按钮，面板清空，重新产生一轮数字。</p>
<p>命令栏：</p>
<pre><code>&lt;Page.BottomAppBar&gt;
        &lt;AppBar&gt;
            &lt;StackPanel Orientation=”Horizontal”&gt;
                &lt;AppBarButton Name=”NewAppBarButton”
                              Label=”新建”
                              Icon=”NewFolder”
                              Click=”NewAppBarButton_Click”/&gt;
            &lt;/StackPanel&gt;
        &lt;/AppBar&gt;
    &lt;/Page.BottomAppBar&gt;
</code></pre><p>页面代码：</p>
<pre><code>&lt;StackPanel HorizontalAlignment=”Center”
            VerticalAlignment=”Center”
            Name=”DisplayStackPanel”
                    Orientation=”Horizontal”/&gt;
</code></pre><p>当然，为了方便起见，创建一个ShowBall类：需要引入的命名空间有：</p>
<pre><code>//Thickness
using Windows.UI.Xaml;
//控件
using Windows.UI.Xaml.Controls;
//SolidColorBrush
using Windows.UI.Xaml.Media;
//球
using Windows.UI.Xaml.Shapes;
</code></pre><p>完整代码：</p>
<pre><code>    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    //color
    using Windows.UI;

    //Thickness
    using Windows.UI.Xaml;
    //控件
    using Windows.UI.Xaml.Controls;
    //SolidColorBrush
    using Windows.UI.Xaml.Media;
    //球
    using Windows.UI.Xaml.Shapes;

    namespace Lucky_Lotto
    {
    public class ShowBall
    {
    // 定义随机数(种子为日期和时间的计时周期）
    private Random random = new Random((int)DateTime.Now.Ticks);

        // 定义获取数字集合方法
        private List&amp;lt;int&amp;gt; GetNumbers()
        {
            int Number;
            // 定义Numbers集合
            List&amp;lt;int&amp;gt; Numbers = new List&amp;lt;int&amp;gt;();
            // 当Numbers集合中整数个数小于6时，自动增加
            while (Numbers.Count &amp;lt; 6)
            {
                // 随机获取1到50之间的整数赋予Number（Number可以取1，不可取50）
                Number = random.Next(1, 50);
                // 将产生的随机数添加到集合之中
                // 处理当集合中的整数与产生的随机数相同的情况
                if (!Numbers.Contains(Number)||Number&amp;lt;1)
                {
                    Numbers.Add(Number);
                }
                // 对集合中的数字进行有序整理（美观起见）
                Numbers.Sort();
            }

            return Numbers;

        }
        // 对StackPanel进行处理：创建小球，增添颜色等
        // 将每个小球分别放在Canva中s，6个Canvas放在一个StackPanel中
        public void PlayBall(ref StackPanel stackpanel)
        {
            // 清空原先讯在的元素
            stackpanel.Children.Clear();

            // 对数字集合遍历
            foreach(int number in GetNumbers())
            {
                // 定义Canvas
                Canvas canvas = new Canvas();
                canvas.Width = 48;
                canvas.Height = 48;
                canvas.Margin = new Thickness(2);

                // 定义球
                Ellipse ellipse = new Ellipse();
                ellipse.Width = canvas.Width;
                ellipse.Height = canvas.Height;
                // 设置小球边框颜色是黑色
                ellipse.Stroke = new SolidColorBrush(Colors.Black);

                // 根据数字的大小设置小球的填充颜色
                if (number &amp;gt;= 1 &amp;amp;&amp;amp; number &amp;lt;= 9)
                {
                    ellipse.Fill = new SolidColorBrush(Colors.White);
                }
                else if (number &amp;gt; 9 &amp;amp;&amp;amp; number &amp;lt;= 19)
                {
                    ellipse.Fill = new SolidColorBrush(Color.FromArgb(255, 112, 200, 236));
                }
                else if (number &amp;gt; 19 &amp;amp;&amp;amp; number &amp;lt;= 29)
                {
                    ellipse.Fill = new SolidColorBrush(Colors.Magenta);
                }
                else if (number &amp;gt; 29 &amp;amp;&amp;amp; number &amp;lt;= 39)
                {
                    ellipse.Fill = new SolidColorBrush(Color.FromArgb(255, 112, 255, 0));
                }
                else if (number &amp;gt; 39 &amp;amp;&amp;amp; number &amp;lt;= 49)
                {
                    ellipse.Fill = new SolidColorBrush(Colors.Yellow);
                }

                // 定义球中的文本（数字）
                TextBlock textBlock = new TextBlock();
                textBlock.Text = number.ToString();
                textBlock.FontSize = 16;
                textBlock.Foreground = new SolidColorBrush(Colors.Black);
                textBlock.Margin = new Thickness(16, 12, 16, 12);

                // 将文本（数字）、小球添加到canvas中，将canvas添加到stackpanel中
                // 一定先添加球，再添加文本，否则文本不会显示
                canvas.Children.Add(ellipse);
                canvas.Children.Add(textBlock);
                stackpanel.Children.Add(canvas);
        }
    }
}

}
</code></pre><p>这样主页面的后台代码就可以轻松的调用了：</p>
<pre><code> // 新建类的实例
        public  ShowBall showball = new ShowBall();
        private void NewAppBarButton_Click(object sender, RoutedEventArgs e)
        {

  showball.PlayBall(ref DisplayStackPanel);
}&lt;/pre&gt;
</code></pre><p>演示：</p>
<p><img src="http://images.chenyalun.cn/2016/04/22/001.png" alt=""><img src="http://images.chenyalun.cn/2016/04/22/002.png" alt=""></p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><pre><code>// 对数字集合遍历
foreach(int number in GetNumbers())  {}

// 设置小球边框颜色是黑色
ellipse.Stroke = new SolidColorBrush(Colors.Black);

//设置margin

textBlock.Margin = new Thickness(16, 12, 16, 12);

// 一定先添加球，再添加文本，否则文本不会显示
canvas.Children.Add(ellipse);
canvas.Children.Add(textBlock);
stackpanel.Children.Add(canvas);

// 清空原先存在的元素
stackpanel.Children.Clear();

// 对集合中的数字进行有序整理（美观起见）
Numbers.Sort();

// 定义随机数(种子为日期和时间的计时周期）
private Random random = new Random((int)DateTime.Now.Ticks);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;幸运彩色小球游戏. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://blog.chenyalun.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://blog.chenyalun.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记五：应用数据本地存储</title>
    <link href="http://blog.chenyalun.com/2016/04/28/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%9A%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://blog.chenyalun.com/2016/04/28/UWP开发笔记五：应用数据本地存储/</id>
    <published>2016-04-27T21:00:59.000Z</published>
    <updated>2016-10-28T13:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>应用数据存储. </p>

<a id="more"></a>
<p>应用数据存储有两种形式，一种存储在本地，另一种是漫游到云端。输入信息，保存在本地，点击显示按钮，重新显现刚刚输入的信息。</p>
<p>命令栏代码：</p>
<p><pre class="lang:default decode:true ">&lt;Page.BottomAppBar&gt;<br>        &lt;AppBar&gt;<br>            &lt;StackPanel Orientation=”Horizontal”&gt;<br>                &lt;AppBarButton Name=”NewAppBarButton”<br>                              Icon=”Page”<br>                              Label=”新建”<br>                              Click=”NewAppBarButton_Click”/&gt;<br>                &lt;AppBarButton Name=”LoadAppBarButton”<br>                              Icon=”Folder”<br>                              Label=”显示”<br>                              Click=”LoadAppBarButton_Click”/&gt;<br>                &lt;AppBarButton Name=”SaveAppBarButton”<br>                              Icon=”Save”<br>                              Label=”保存”<br>                              Click=”SaveAppBarButton_Click”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.BottomAppBar&gt;</pre><br>页面代码：</p>
<p><pre class="lang:default decode:true "> &lt;StackPanel&gt;<br>            &lt;TextBox Name=”Email”<br>                     PlaceholderText=”邮箱”<br>                     Margin=”20”<br>                     InputScope=”EmailSmtpAddress”/&gt;<br>            &lt;TextBox Name=”Web”<br>                     PlaceholderText=”网址”<br>                     Margin=”20”<br>                     InputScope=”Url”/&gt;<br>            &lt;TextBox Name=”Tel”<br>                     PlaceholderText=”手机号码”<br>                     Margin=”20”<br>                     InputScope=”TelephoneNumber”/&gt;<br>        &lt;/StackPanel&gt;</pre><br>后台逻辑：</p>
<p><pre class="lang:default decode:true ">  //  新建存储<br>        private void NewAppBarButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            Email.Text = string.Empty;<br>            Web.Text = string.Empty;<br>            Tel.Text = string.Empty;<br>        }</pre></p>
<pre><code>// 保存信息
private void SaveAppBarButton_Click(object sender, RoutedEventArgs e)
{
    Save(&quot;Email&quot;, Email.Text);
    Save(&quot;Web&quot;, Web.Text);
    Save(&quot;Tel&quot;, Tel.Text);
}

// 加载存储信息
private void LoadAppBarButton_Click(object sender, RoutedEventArgs e)
{
    Email.Text = Load(&quot;Email&quot;);
    Web.Text = Load(&quot;Web&quot;);
    Tel.Text = Load(&quot;Tel&quot;);
}

// 应用本地设置信息存储:保存 键 值
public void Save(string key,string value)
{
    ApplicationData.Current.LocalSettings.Values[key] = value;
}

// 加载应用本地设置存储的信息
public string Load(string key)
{
    if (ApplicationData.Current.LocalSettings.Values[key]!=null)
    {
        return ApplicationData.Current.LocalSettings.Values[key].ToString();
    }

    return string.Empty;
}&lt;/pre&gt;
</code></pre><p>输入信息并保存：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/005.png" alt=""></p>
<p>点击新建清空数据，点击显示：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/006.png" alt=""></p>
<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><ul>
<li>空字符串：string.Empty</li>
<li>保存的方式为键值对：key和value</li>
<li>本地设置类： ApplicationData.Current.LocalSettings.Values[key] = value;其中key一般是字符串，value是保存的值</li>
<li>需要引入命名空间：应用数据存储  using Windows.Storage;</li>
<li>删除存储 ApplicationData.Current.LocalSettings.Values.Remove(“key”); 其中key是键<br>&nbsp;</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;应用数据存储. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://blog.chenyalun.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://blog.chenyalun.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记四：随机数与筛子游戏</title>
    <link href="http://blog.chenyalun.com/2016/04/26/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E7%AD%9B%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <id>http://blog.chenyalun.com/2016/04/26/UWP开发笔记四：随机数与筛子游戏/</id>
    <published>2016-04-25T21:00:25.000Z</published>
    <updated>2016-10-28T13:41:18.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>随机数与筛子游戏<br>. </p>

<a id="more"></a>
<p>点击方块，方块随机出现类似筛子的点数，连续点击，连续出现随机的数。当然，是有两个方块的。点击底部命令栏的刷新按钮，两块“筛子”均恢复空白状态。</p>
<p>命令栏：</p>
<p><pre class="lang:default decode:true ">&lt;Page.BottomAppBar&gt;<br>        &lt;AppBar&gt;<br>            &lt;StackPanel Orientation=”Horizontal”&gt;<br>                    &lt;AppBarButton Name=”NewAppBarButton”<br>                                  Icon=”Page”<br>                                  Click=”NewAppBarButton_Click”<br>                                  Label=”刷新”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.BottomAppBar&gt;</pre><br>页面代码：</p>
<p><pre class="lang:default decode:true "> &lt;Grid.ColumnDefinitions&gt;<br>            &lt;ColumnDefinition Width=”<em>“/&gt;<br>            &lt;ColumnDefinition Width=”Auto”/&gt;<br>            &lt;ColumnDefinition Width=”</em>“/&gt;<br>            &lt;ColumnDefinition Width=”Auto”/&gt;<br>            &lt;ColumnDefinition Width=”*”/&gt;<br>        &lt;/Grid.ColumnDefinitions&gt;</pre></p>
<pre><code>    &amp;lt;Grid Name=&quot;FirstGrid&quot;
          Tapped=&quot;FirstGrid_Tapped&quot;
          Width=&quot;100&quot;
          Height=&quot;100&quot;
          Background=&quot;HotPink&quot;
          Grid.Column=&quot;1&quot;&amp;gt;
        &amp;lt;Grid.RowDefinitions&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;/Grid.RowDefinitions&amp;gt;
        &amp;lt;Grid.ColumnDefinitions&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;/Grid.ColumnDefinitions&amp;gt;
    &amp;lt;/Grid&amp;gt;

&amp;lt;Grid Name=&quot;SecondGrid&quot;
          Tapped=&quot;SecondGrid_Tapped&quot;
          Width=&quot;100&quot;
          Height=&quot;100&quot;
          Background=&quot;HotPink&quot;
          Grid.Column=&quot;3&quot;&amp;gt;
    &amp;lt;Grid.RowDefinitions&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
    &amp;lt;/Grid.RowDefinitions&amp;gt;
    &amp;lt;Grid.ColumnDefinitions&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
    &amp;lt;/Grid.ColumnDefinitions&amp;gt;

&amp;lt;/Grid&amp;gt;&lt;/pre&gt;
</code></pre><p>后台代码MainPage.xaml.cs：</p>
<p>引入命名空间：</p>
<p><pre class="lang:default decode:true ">//颜色<br>using Windows.UI;<br>//图形<br>using Windows.UI.Xaml.Shapes;</pre><br>逻辑代码：</p>
<p><pre class="lang:default decode:true"> private void NewAppBarButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            //刷新页面<br>            FirstGrid.Children.Clear();<br>            SecondGrid.Children.Clear();<br>        }</pre></p>
<pre><code>    private void FirstGrid_Tapped(object sender, TappedRoutedEventArgs e)
    {
        // 移除面板上所有元素
        FirstGrid.Children.Clear();
        switch (Number())
        {
            case 0:
            case 1:
                Add(FirstGrid, 1, 1);
                break;
            case 2:
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 0);
                break;
            case 3:
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 1, 1);
                Add(FirstGrid, 2, 0);
                break;
            case 4:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 0);
                Add(FirstGrid, 2, 2);
                break;
            case 5:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 2);
                Add(FirstGrid, 1, 1);
                Add(FirstGrid, 2, 0);
                break;
            case 6:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 1, 0);
                Add(FirstGrid, 1, 2);
                Add(FirstGrid, 2, 0);
                Add(FirstGrid, 2, 2);
                break;
        }
    }

// 设置随机数
    public int Number()
    {
        // 返回0到7之间的随机整数
        return new Random().Next(0, 7);
    }

    // 设置添加圆点
    public void Add(Grid grid, int row, int col)
    {

        Ellipse ell = new Ellipse();
        // 设置填充颜色
        ell.Fill = new SolidColorBrush(Colors.White);
        // 设置宽高度
        ell.Width = 20;
        ell.Height = 20;
        // 设置圆点的在表格上的位置
        ell.SetValue(Grid.RowProperty, row);
        ell.SetValue(Grid.ColumnProperty, col);
        // 获取面板元素（把ell元素添加到面板中）
        grid.Children.Add(ell);
    }

    private void SecondGrid_Tapped(object sender, TappedRoutedEventArgs e)
    {
        // 移除面板上所有元素
        SecondGrid.Children.Clear();
        switch (Number())
        {
            case 0:
            case 1:
                Add(SecondGrid, 1, 1);
                break;
            case 2:
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 0);
                break;
            case 3:
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 1, 1);
                Add(SecondGrid, 2, 0);
                break;
            case 4:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 0);
                Add(SecondGrid, 2, 2);
                break;
            case 5:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 2);
                Add(SecondGrid, 1, 1);
                Add(SecondGrid, 2, 0);
                break;
            case 6:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 1, 0);
                Add(SecondGrid, 1, 2);
                Add(SecondGrid,2, 0);
                Add(SecondGrid, 2, 2);
                break;
        }
    }&lt;/pre&gt;
</code></pre><p>点击出现筛子点数：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/001.png" alt=""></p>
<p>点击刷新按钮，清空所有元素：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/002.png" alt=""></p>
<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><ul>
<li><h3 id="随机数："><a href="#随机数：" class="headerlink" title="随机数："></a>随机数：</h3></li>
</ul>
<p>Random()与时间相关的种子；</p>
<p>Random(seed)指定种子；</p>
<p>Random().NextDouble返回大于或等于0.0且小于1.0的随机浮点数；</p>
<p>Random().Next()返回非负随机整数；</p>
<p>Random().Next(下限，上限)返回指定范围非负随机整数（可取下限，不可取上限）；</p>
<h3 id="设置图形依赖属性："><a href="#设置图形依赖属性：" class="headerlink" title="设置图形依赖属性："></a>设置图形依赖属性：</h3><p>Ellipse ell = new Ellipse();</p>
<p>// 设置填充颜色<br>ell.Fill = new SolidColorBrush(Colors.White);</p>
<p>// 设置圆点的在表格上的位置<br>ell.SetValue(Grid.RowProperty, row);<br>ell.SetValue(Grid.ColumnProperty, col);<br>// 获取面板元素（把ell元素添加到面板中）<br>grid.Children.Add(ell);</p>
<p>// 移除面板上所有元素<br>SecondGrid.Children.Clear();</p>
<p>总结：代码比较琐碎，而且不是很令人满意，xaml创建图形很方便，可是处理逻辑的时候没有思路，只好把图形创建的代码写在后台。本想写个方法同时处理两个方块，然而并没有成功〒_〒</p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;随机数与筛子游戏&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://blog.chenyalun.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://blog.chenyalun.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记三：动画编程之图形的翻转</title>
    <link href="http://blog.chenyalun.com/2016/04/24/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E5%8A%A8%E7%94%BB%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9B%BE%E5%BD%A2%E7%9A%84%E7%BF%BB%E8%BD%AC/"/>
    <id>http://blog.chenyalun.com/2016/04/24/UWP开发笔记三：动画编程之图形的翻转/</id>
    <published>2016-04-23T21:00:40.000Z</published>
    <updated>2016-10-28T13:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>动画编程小尝试<br>. </p>

<a id="more"></a>
<p>动画编程可以实现很酷的很炫的效果，能让开发出的App散发无穷无尽的魅力，在颜值至上的时代，好看是检验UI的唯一标准。图形的翻转主要有三种形式：RotationX，RotationY，RotationZ，就是获取或设置围绕旋转的 X 轴或Y轴或Z轴旋转对象的角度。</p>
<p>计划在文本框中键入图片的地址源，按回车载入图片，点击命令栏中按钮，图片做出相应变换。</p>
<p>XAML代码：</p>
<pre class="lang:default decode:true ">&lt;!--命令栏--&gt;
    &lt;Page.BottomAppBar&gt;
        &lt;AppBar IsSticky="True"&gt;
            &lt;StackPanel Orientation="Horizontal" HorizontalAlignment="Right"&gt;
            &lt;AppBarButton Name="XRotateAppBarButton"
                          Icon="RepeatAll"
                          Label="Pitch"
                          Click="XRotateAppBarButton_Click"/&gt;
            &lt;AppBarButton Name="YRotateAppButton"
                          Icon="Rotate"
                          Label="Roll"
                          Click="YRotateAppButton_Click"/&gt;
            &lt;AppBarButton Name="ZRotateAppBarButton"
                          Icon="Refresh"
                          Label="Yaw"
                          Click="ZRotateAppBarButton_Click"/&gt;
            &lt;/StackPanel&gt;

        &lt;/AppBar&gt;
    &lt;/Page.BottomAppBar&gt;

    &lt;!--动画--&gt;
    &lt;Page.Resources&gt;
        &lt;!--X方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardX"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationX)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;

        &lt;!--Y方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardY"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationY)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;

        &lt;!--Z方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardZ"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationZ)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;
    &lt;/Page.Resources&gt;

    &lt;Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height="Auto"/&gt;
            &lt;RowDefinition Height="Auto"/&gt;
            &lt;RowDefinition Height="*"/&gt;
        &lt;/Grid.RowDefinitions&gt;
        &lt;TextBlock Text="请输入图片的地址"
                   HorizontalAlignment="Center"
                   Height="30"/&gt;
        &lt;TextBox  Grid.Row="1"
                  Name="URLTextBox"
                   FontSize="20"
                   HorizontalAlignment="Stretch"
                   Height="40"
                   Margin="20"
                   InputScope="Url"
                   KeyDown="URLTextBox_KeyDown"/&gt;
        &lt;Image Grid.Row="2"
               Name="ResultImage"
               Margin="60"
               Stretch="Uniform"&gt;
            &lt;!--注意一定要声明-Projection属性--&gt;
            &lt;Image.Projection&gt;
                &lt;PlaneProjection /&gt;
            &lt;/Image.Projection&gt;
        &lt;/Image&gt;
    &lt;/Grid&gt;</pre>
原图：

![](http://images.chenyalun.cn/2016/04/20/101.png)

X轴翻转:

![](http://images.chenyalun.cn/2016/04/20/102.gif)

&nbsp;

Y轴翻转：![](http://images.chenyalun.cn/2016/04/20/103.gif)

以及Z轴翻转：![](http://images.chenyalun.cn/2016/04/20/104.gif)

CS 代码（主要是获取文本框中的URL，以及处理按钮事件）：
<pre class="lang:default decode:true "> // TextBox输入完毕按下回车后，得到图片来源
        private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
        {
            // 判断与事件关联的输入按钮是否为虚拟按键的Enter键
            if (e.Key==Windows.System.VirtualKey.Enter)
            {
                ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(new Uri(URLTextBox.Text));
            }
        }

        // 设置按下按钮后的翻转效果
        private   void XRotateAppBarButton_Click(object sender, RoutedEventArgs e)
        {
             StoryBoardX.Begin();
        }

        private void YRotateAppButton_Click(object sender, RoutedEventArgs e)
        {
            StoryBoardY.Begin();
        }

        private void ZRotateAppBarButton_Click(object sender, RoutedEventArgs e)
        {
            StoryBoardZ.Begin();
        }</pre>

<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><h3 id="1-处理文本框的回车事件中，"><a href="#1-处理文本框的回车事件中，" class="headerlink" title="1,处理文本框的回车事件中，"></a>1,处理文本框的回车事件中，</h3><p>文本框输入类型：InputScope=”Url”   键盘按键属性KeyDown=”URLTextBox_KeyDown”</p>
<p>获取文本框内容并转换为URL：</p>
<p>// 判断与事件关联的按键是否为虚拟按键的Enter键<br>if (e.Key==Windows.System.VirtualKey.Enter)<br>{<br>ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(new Uri(URLTextBox.Text));</p>
<p>等同于：</p>
<pre class="lang:default decode:true ">Uri url = new Uri(URLTextBox.Text);
ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(url);</pre>
}

当然，如果引入命名空间了，那就更好了  using Windows.UI.Xaml.Media.Imaging;
<pre class="lang:default decode:true ">Uri url = new Uri(URLTextBox.Text);
ResultImage.Source = new BitmapImage(url);</pre>

<h3 id="2，关于动画"><a href="#2，关于动画" class="headerlink" title="2，关于动画"></a>2，关于动画</h3><p>首先目标图片要声明Projection属性，即添加：</p>
<pre class="lang:default decode:true ">&lt;Image.Projection&gt;
   &lt;PlaneProjection /&gt;
&lt;/Image.Projection&gt;</pre>
其次在 &lt;Page.Resources&gt;中添加故事板：
<pre class="lang:default decode:true ">&lt;Storyboard x:Name="StoryBoardX"&gt;
&lt;DoubleAnimation Storyboard.TargetName="ResultImage"
Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationX)"
From="0.0"
To="360.0"
AutoReverse="True"
RepeatBehavior="Forever"&gt;
&lt;/DoubleAnimation&gt;
&lt;/Storyboard&gt;
</pre>

<ul>
<li>命名：方便后台代码调用</li>
<li>类：DoubleAnimation针对Double属性，还有ColorAnimation针对Color属性，以及PointAnimation针对Point，这里图形翻转目标属性是PlaneProjection   值是double类型</li>
<li>Storyboard.TargetName：执行动画的对象名称</li>
<li>Storyboard.TargetProperty：执行动画的对象属性，此处是PlaneProjection.RotationX，写成Storyboard.TargetProperty=”PlaneProjection.RotationX”也没有关系</li>
<li>From：起始值</li>
<li>To：终点值</li>
<li>By：变化值</li>
<li>AutoReverse：自动重置（返回原状）</li>
<li>RepeatBehavior：播放次数</li>
<li>Duration：持续时间（值的格式为时分秒，即0.0.3  3秒）<br>以上是通过XAML写出界面，当然，完全可以在后台代码中，完成StoryBoard的设置：<br><pre class="lang:default decode:true ">            DoubleAnimation animation = new DoubleAnimation();<pre><code>animation.From = 0.0;
animation.To = 360.0;
animation.BeginTime = TimeSpan.FromSeconds(1);
animation.RepeatBehavior = RepeatBehavior.Forever;
Storyboard.SetTarget(animation, target);
Storyboard.SetTargetProperty(animation, &quot;(UIElement.Projection).(PlaneProjection.Rotation&quot; + axis + &quot;)&quot;);
rotation.Children.Clear();
rotation.Children.Add(animation);
rotation.Begin();
rotating = true;&lt;/pre&gt;
</code></pre>不过看个人爱好了，我还是喜欢XAML。</pre></li>
</ul>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;动画编程小尝试&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://blog.chenyalun.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://blog.chenyalun.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记二：AppBar和CommandBar</title>
    <link href="http://blog.chenyalun.com/2016/04/22/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AAppBar%E5%92%8CCommandBar/"/>
    <id>http://blog.chenyalun.com/2016/04/22/UWP开发笔记二：AppBar和CommandBar/</id>
    <published>2016-04-21T21:00:36.000Z</published>
    <updated>2016-10-28T13:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>AppBar和CommandBar<br>. </p>

<a id="more"></a>
<p>AppBar和CommandBar也算是比较常用的控件了，不过个人不太喜欢这些，主要是觉得很非主流，我还是喜欢把功能都做到汉堡菜单里。</p>
<p>1，CommandBar被包裹住了，一般放在页面顶部或底部。</p>
<p><pre class="lang:default decode:true ">&lt;Page<br>    x:Class=”ApplicationBar.MainPage”<br>    xmlns=”<a href="http://schemas.microsoft.com/winfx/2006/xaml/presentation" target="_blank" rel="external">http://schemas.microsoft.com/winfx/2006/xaml/presentation</a>“<br>    xmlns:x=”<a href="http://schemas.microsoft.com/winfx/2006/xaml" target="_blank" rel="external">http://schemas.microsoft.com/winfx/2006/xaml</a>“<br>    xmlns:local=”using:ApplicationBar”<br>    xmlns:d=”<a href="http://schemas.microsoft.com/expression/blend/2008" target="_blank" rel="external">http://schemas.microsoft.com/expression/blend/2008</a>“<br>    xmlns:mc=”<a href="http://schemas.openxmlformats.org/markup-compatibility/2006" target="_blank" rel="external">http://schemas.openxmlformats.org/markup-compatibility/2006</a>“<br>    mc:Ignorable=”d”&gt;</pre></p>
<p>  &lt;Page.BottomAppBar&gt;<br>        &lt;CommandBar&gt;</p>
<pre><code>    &amp;lt;/CommandBar&amp;gt;
&amp;lt;/Page.BottomAppBar&amp;gt;
&amp;lt;Grid Background=&quot;{ThemeResource ApplicationPageBackgroundThemeBrush}&quot;&amp;gt;
&amp;lt;/Grid&amp;gt;
</code></pre><p>&lt;/Page&gt;<br>所以就是这种效果，在CommandBar中有两种菜单可选</p>
<p>图标文字：添加AppBarButton即可</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/001.png" alt=""></p>
<p><pre class="lang:default decode:true ">&lt;AppBarButton Name=”FirstAppBarButton”<br>    Icon=”Account”<br>     Label=”主页”<br>    Click=”FirstAppBarButton_Click”/&gt;</pre><br>文字列表：需要夹在&lt;CommandBar.SecondaryCommands&gt;&lt;/CommandBar.SecondaryCommands&gt;中间</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/002.png" alt=""></p>
<p><pre class="lang:default decode:true ">&lt;CommandBar.SecondaryCommands&gt;<br>                &lt;AppBarButton Name=”TextAppBarButton1”<br>                              Label=”文字1”<br>                              Click=”TextAppBarButton1_Click”/&gt;<br>&lt;/CommandBar.SecondaryCommands&gt;</pre><br>2,AppBar 的话，可能更强大一点，它可以嵌套着命令栏CommandBar，不过也是需要放在页面顶部或者底部</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/005.png" alt=""></p>
<p><pre class="lang:default decode:true">&lt;Page.TopAppBar&gt;<br>        &lt;AppBar  &gt;</pre></p>
<pre><code>    &amp;lt;/AppBar&amp;gt;
&amp;lt;/Page.TopAppBar&amp;gt;&lt;/pre&gt;
</code></pre><p>对于每个命令栏按钮，依然可以添加Click事件进行处理。</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/003.png" alt=""></p>
<p><img src="http://images.chenyalun.cn/2016/04/20/004.png" alt=""></p>
<hr>
<hr>
<h3 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h3><p>1,</p>
<p><pre class="lang:default decode:true ">&lt;Page.TopAppBar&gt;<br>        &lt;AppBar  IsSticky=”True” &gt;<br>            &lt;StackPanel Orientation=”Horizontal” &gt;<br>                &lt;CommandBar&gt;<br>                    &lt;!–第二命令栏–&gt;<br>                    &lt;CommandBar.SecondaryCommands&gt;<br>                        &lt;AppBarButton Name=”Hide” Icon=”Cancel” Label=”文本” Visibility=”Collapsed” Click=”Show_Click”/&gt;<br>                    &lt;/CommandBar.SecondaryCommands&gt;<br>                     &lt;!–设置命令栏内容–&gt;<br>                    &lt;CommandBar.Content&gt;<br>                        &lt;TextBlock Text=”Now playing…” Margin=”12,14”/&gt;<br>                    &lt;/CommandBar.Content&gt;<br>                &lt;/CommandBar&gt;<br>                     &lt;!–分割线–&gt;<br>                &lt;AppBarSeparator/&gt;<br>                &lt;AppBarButton Name=”Show”<br>                              Icon=”Accept”<br>                              Label=”Show Other”<br>                              Click=”Show_Click”<br>                              IsCompact=”True”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.TopAppBar&gt;</pre><br>如上所示，AppBar中包裹命令栏。若菜单栏中只包含AppBarButton（普通按钮）、AppBarToggleButton（切换按钮）、AppBarSeparator（分割线） 这几个控件，且没有特殊布局格式要求，CommandBar 控件可以解决大多数问题。</p>
<p>第二命令栏需要使用：CommandBar.SecondaryCommands</p>
<p>命令栏内容：CommandBar.Content</p>
<p>命令按钮分割线： &lt;AppBarSeparator/&gt;</p>
<p>标签：label</p>
<p>图标: icon</p>
<p>顶部命令栏：&lt;Page.TopAppBar&gt;&lt;/Page.TopAppBar&gt;</p>
<p>底部命令栏： &lt;Page.BottomAppBar&gt; &lt;/Page.BottomAppBar&gt;</p>
<p>单词：toggle 切换   Separator分隔符</p>
<p>在AppBar属性中：IsSticky=”True”表示打开命令栏后，除非用户显式地点击鼠标右键或按Win+z, 或用手指从屏幕顶端或底端划过才会隐藏，否则AppBar会一直显示。一般不设置。</p>
<p>IsOpen=”True” 一直完全显示图标+文字，一般不设置。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;AppBar和CommandBar&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://blog.chenyalun.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://blog.chenyalun.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记一：Hello UWP与对话框</title>
    <link href="http://blog.chenyalun.com/2016/04/20/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9AHello_UWP%E4%B8%8E%E5%AF%B9%E8%AF%9D%E6%A1%86/"/>
    <id>http://blog.chenyalun.com/2016/04/20/UWP开发笔记一：Hello_UWP与对话框/</id>
    <published>2016-04-19T21:00:51.000Z</published>
    <updated>2016-10-28T13:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>Hello World UWP<br>. </p>

<a id="more"></a>
<p>这段时间在悄悄地学习UWP开发，不过担心会忘记，所以感觉还是记下笔记比较好。一来自己没事可以翻着看看，可解闷了，二来欢迎志同道合的童鞋一起交流。</p>
<p>1，假定PC装好VS2015，文件–新建–项目–windows通用应用</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/001.png" alt=""></p>
<p>设置版本：</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/002.png" alt=""></p>
<p>2，右侧解决方案中，打开MainPage.xaml，写入xaml代码：</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/003.png" alt=""></p>
<p><pre class="lang:default decode:true ">  &lt;Button Name=”HelloUWPButton”<br>                Content=”显示”<br>                HorizontalAlignment=”Center”<br>                VerticalAlignment=”Center”<br>        Click=”HelloUWPButton_Click”/&gt;</pre><br>或者拖入Button控件，属性中设置Click事件：HelloUWPButton_Click，内容设置为：显示。</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/004.png" alt=""></p>
<p>3，处理click事件：</p>
<p><pre class="lang:default decode:true ">private async void HelloUWPButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            await new Windows.UI.Popups.MessageDialog(“Hello UWP”).ShowAsync();</pre></p>
<pre><code>}&lt;/pre&gt;
</code></pre><p>4，调试运行即可。</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/005.png" alt=""></p>
<hr>
<hr>
<h3 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;<strong>笔记</strong></h3><p>1，其实点击事件的代码和下面两行等价：</p>
<p><pre class="lang:default decode:true ">var message = new MessageDialog(“Hello UWP”);<br>await  message.ShowAsync();</pre><br>&nbsp;</p>
<p>2，消息对话框引入的命名空间：<strong>using Windows.UI.Popups;</strong></p>
<p>&nbsp;</p>
<p>3，消息对话框的使用</p>
<p>创建对话框并设置内容：</p>
<p><pre class="lang:default decode:true ">var messageDialog = new MessageDialog(“消息对话框的内容”, “可省略的对话框标题”);</pre><br>设置对话框中的命令,最多有3个：</p>
<p><pre class="lang:default decode:true ">UICommand cmd1 = new UICommand();<br>UICommand cmd2 = new UICommand();<br>UICommand cmd3 = new UICommand();</pre><br>设置命令的标签文本：</p>
<p><pre class="lang:default decode:true ">cmd1.Label = “标签1”;<br>cmd2.Label = “标签2”;<br>cmd3.Label = “标签3”;</pre><br>设置命令的唯一标识符：</p>
<p><pre class="lang:default decode:true ">cmd1.Id = 1;<br>cmd2.Id = 2;<br>cmd3.Id = 3;</pre><br>设置消息对话框命令的默认ID（直接按下回车键就可以执行的命令）<br>三个命令默认从左到右DefaultCommandIndex依次是0，1，2，大于2或者不设置则DefaultCommandIndex的值为0</p>
<p><pre class="lang:default decode:true "> messageDialog.DefaultCommandIndex = 1;</pre><br>设置调用（点击）命令时引发的事件：OnCommend</p>
<p><pre class="lang:default decode:true ">cmd1.Invoked = new UICommandInvokedHandler(OnCommend);<br>cmd2.Invoked = new UICommandInvokedHandler(OnCommend);<br>cmd3.Invoked = new UICommandInvokedHandler(OnCommend);</pre><br>将3个命令添加到对话框中</p>
<p><pre class="lang:default decode:true ">messageDialog.Commands.Add(cmd1);<br>messageDialog.Commands.Add(cmd2);<br>messageDialog.Commands.Add(cmd3);</pre><br>显示消息对话框(异步)</p>
<p><pre class="lang:default decode:true ">await messageDialog.ShowAsync();</pre><br>截至目前，上面的代码可以简化为：</p>
<p><pre class="lang:default decode:true">var messageDialog = new MessageDialog(“消息对话框的内容”);<br>messageDialog.DefaultCommandIndex = 1;<br>messageDialog.Commands.Add(new UICommand(“标签1”, OnCommend, 1));<br>messageDialog.Commands.Add(new UICommand(“标签2”, OnCommend, 2));<br>messageDialog.Commands.Add(new UICommand(“标签3”, OnCommend, 3));<br>await messageDialog.ShowAsync();</pre><br>处理调用命令的事件：</p>
<p>一般通过命令的ID进行不同的处理，将object类型的command.Id转化为int32类型</p>
<p><pre class="lang:default decode:true "> private void OnCommend(IUICommand command)<br>        {<br>            var ID = Convert.ToInt32(command.Id);</pre></p>
<pre><code>    // 处理不同的命令
    if (ID == 1)
    {
        ResultTextBlock.Text = &quot;你点击了命令1：标签1&quot;;
    }
    else if (ID == 2)
    {
        ResultTextBlock.Text = &quot;你点击了命令2：标签2&quot;;
    }
    else
    {
        ResultTextBlock.Text = &quot;你点击了命令3：标签3&quot;;
    }

}&lt;/pre&gt;
</code></pre><p><img src="http://images.chenyalun.cn/2016/04/19/006.png" alt=""></p>
<p>4，单词积累：</p>
<p>popups：弹出窗口；弹出式视窗</p>
<p>invoked：恳求；实行；引起</p>
<p>5,github: <a href="http://www.chenyalun.cn/go/?url=https://github.com/chenyalun/UWP-Notes.git" target="_blank" rel="external">https://github.com/chenyalun/UWP-Notes.git</a></p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;Hello World UWP&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://blog.chenyalun.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://blog.chenyalun.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>泛谈单链表的插入与删除</title>
    <link href="http://blog.chenyalun.com/2015/11/04/%E6%B3%9B%E8%B0%88%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4/"/>
    <id>http://blog.chenyalun.com/2015/11/04/泛谈单链表的插入与删除/</id>
    <published>2015-11-03T21:00:32.000Z</published>
    <updated>2016-10-28T13:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>简单探讨单链表的插入与删除<br>. </p>

<a id="more"></a>
<p>其实单链表也是比较有意思的，可惜我弄了好久才些微明白些。在顺序表中，一个数组就将近定义一个结构，但在单链表中，却又要和指针扯上关系了。</p>
<p>定义：</p>
<pre><code>typedef struct LNode{
    int data;
    struct LNode next;
}LNode;
</code></pre><p>江湖传言LNode *p等价于LinkList p，不知道有木有人认同呢？</p>
<pre><code>    #include&lt;stdio.h&gt;

    #include&lt;malloc.h&gt;
    //定义并初始化单链表
    typedef struct LNode{
    int data;
    struct LNode *next;
    }LNode;

    //单链表的创建与初始化，设定共n个节点（不含头节点）
    void CreateLinkList(LNode a,int n) {
    LNode p,q;
    p=a;
    while(n–){
    q=(LNode )malloc(sizeof(LNode *));
    scanf(“%d”,&amp;q-&gt;data);
    q-&gt;next=NULL;
    p-&gt;next=q;
    p=q;
    }
    }

    //查找是否存在一个值为x的节点，若存在，删之，并返回OK，否则返回NOT FOUND
    char SearchAndDelete(LNode c,int x){
    LNode p,q;
    p=c;
    //开始查找
    while(p-&gt;next!=NULL)
    {
    if(p-&gt;next-&gt;data==x)
    break;
    p=p-&gt;next;
    }
    //若找到则开始删除
    if(p-&gt;next==NULL)
    return “NOT FOUND”;
    else
    {
    q=p-&gt;next;
    p-&gt;next=p-&gt;next-&gt;next;
    free(q);
    return “OK”;
    }
    }

    //在链表c中第n个节点位置插入元素e
    void Insert(LNode c,int n,int e){
    LNode p=( LNode )malloc(sizeof(LNode )),
    q=( LNode )malloc(sizeof(LNode ));//插入的节点
    p=c;
    q-&gt;data=e;
    //找到要插入节点的位置
    for(int i=1;i&lt;n;i++){
    p=p-&gt;next;
    }
    //插入节点
    q-&gt;next=p-&gt;next;
    p-&gt;next=q;
    }
    //打印单链表
    void Print(LNode a){
    LNode p=( LNode )malloc(sizeof(LNode *));
    p=a-&gt;next;
    while(p!=NULL){
    printf(“%d\n”,p-&gt;data);
    p=p-&gt;next;
    }
    }

    int main(){
    LNode a=( LNode )malloc(sizeof(LNode *));
    CreateLinkList(a,5);
    Insert(a,3,10086);//假定在第3个位置插入数值为10086的节点
    Print(a);
    printf(“—————-\n”);
    SearchAndDelete(a,13);//查找并执行删除数值为13的节点
    Print(a);
    return 0;
}
</code></pre><p>说明如下：</p>
<p>1，假定输入的是11 12 13 14 15五个数值。在第三个位置（13的位置）插入一个数据域为10086的节点。此时原来的数值已经变成了11 12 10086 13 14 15</p>
<p>2，完事后，我为了方便不再另写代码，在11 12 10086 13 14 15的基础上假定查找并删除数据域为13的节点。</p>
<p><img src="http://source.chenyalun.cn/images/201511/5110101.jpg" alt=""></p>
<p>当然还有值得体会的是，把节点的内存分配放在主函数里.</p>
<p>像这样：</p>
<pre><code>LNode a=( LNode )malloc(sizeof(LNode *));
</code></pre><p>当然，清晰一点就是</p>
<pre><code>LNode a;
a=( LNode )malloc(sizeof(LNode *));
</code></pre><p>两者效果一样。</p>
<pre><code>void Print(LNode *a){

}
和

void Print(LNode &amp;a){
    a=( LNode )malloc(sizeof(LNode *));

}
</code></pre><p>这才是重点，和小伙伴研究一下，决定采取有违伦理惨无人道的第一种方式。最后在主函数中再调用malloc觉得还是蛮灵活轻便的。</p>
<p>当然，上面的代码不是为了解题，只是提供一个思路，具体可视情况修改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;简单探讨单链表的插入与删除&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="编程技巧" scheme="http://blog.chenyalun.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>泛谈顺序表的插入与删除</title>
    <link href="http://blog.chenyalun.com/2015/11/02/%E6%B3%9B%E8%B0%88%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4/"/>
    <id>http://blog.chenyalun.com/2015/11/02/泛谈顺序表的插入与删除/</id>
    <published>2015-11-01T21:00:11.000Z</published>
    <updated>2016-10-28T13:54:12.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>简单探讨顺序表的插入与删除<br>. </p>

<a id="more"></a>
<p>所谓的顺序表，在严版的书中，定义的异常专业巧妙。存储空间基址、当前长度、分配的存储容量，这三部分融合而成线性表之顺序表。</p>
<pre><code>typedef struct{
    Elemtype *elem;
    int length;
    int listsize;
}SqList;
</code></pre><p>翻翻资料。发现还有一种更巧妙而且容易理解的方式：</p>
<pre><code>typedef struct{
    int data[Max];
    int length;
}SqList;
</code></pre><p>这样一来，整个顺序表就与数组特别特别相似啦。</p>
<p>那么，声明一个很长很长但是彼此知道的Max长度数组，作为默认“表长”（其实不是表长），再给它一个长度length，如此，顺序表横空出世了。</p>
<p>既然如此，那关于什么插入、删除操作就不在话下了。</p>
<p>1 已知顺序表的所有元素值（自行输入），在元素e的位置插入元素m</p>
<p>题目很清楚，插入元素m后，后面的元素自然往后移动啦。</p>
<pre><code>    #include&lt;stdio.h&gt;
    //#include&lt;malloc.h&gt;
    //#include&lt;stdlib.h&gt;   //一般这两个是需要的

    #define Max 200
    //定义并初始化顺序表
    typedef struct{
    int data[Max];
    int length=10;
    }SqList;
    //顺序表l中查找元素e的位置
    int LocatElem(SqList l,int e){
    int i=0;
    for(;i&lt;l.length;++i)
    if(l.data[i]==e)
    return i+1;
    }

    //在元素e的位置插入元素m
    void Insert(SqList &amp;l,int e,int m) {
    int i=l.length,p=LocatElem(l,e);
    for(;i&gt;=p;–i){
    l.data[i]=l.data[i-1];
    }
    l.data[i]=m;
    l.length++;
    }

    int main(){
    int i=0,e=18,m=200;
    SqList a;
    for(;i&lt;a.length;++i)
    scanf(“%d”,&amp;a.data[i]);
    Insert(a,e,m);
    for(int i=0;i&lt;a.length;++i)
    printf(“%d\n”,a.data[i]);
    return 0;
}
</code></pre><p>这里假设我们输入从11，12一直到20的整数值，首先查找元素e=18的值的位置，插入m的值200。</p>
<p>原来：11 12 13 14 15 16 17 18 19 20</p>
<p>run后：11 12 13 14 15 16 17 200 18 19 20</p>
<p><img src="http://source.chenyalun.cn/images/201510/5103102.jpg" alt=""></p>
<p>2 已知顺序表所有元素的值（自行输入），删除顺序表中值为e的元素</p>
<pre><code>    #include&lt;stdio.h&gt;
    //#include&lt;malloc.h&gt;
    //#include&lt;stdlib.h&gt;

    #define Max 200
    //定义并初始化顺序表
    typedef struct{
    int data[Max];
    int length=10;
    }SqList;
    //顺序表l中查找元素e的位置
    int LocatElem(SqList l,int e){
    int i=0;
    for(;i&lt;l.length;++i)
    if(l.data[i]==e)
    return i+1;
    }

    //删除顺序表中值为e的元素
    void Delete(SqList &amp;l,int e){
    int i=LocatElem(l,e);
    for(;i&lt;=l.length;++i)
    l.data[i-1]=l.data[i];
    l.length–;
    }
    int main(){
    int i=0, e=15;//e的值自己说了算
    SqList a;
    for(;i&lt;a.length;++i)
    scanf(“%d”,&amp;a.data[i]);
    Delete(a,e);
    for(int i=0;i&lt;a.length;++i)
    printf(“%d\n”,a.data[i]);
    return 0;
}
</code></pre><p>改动不大，添加个函数而已。这里删除的是15，具体题目具体分析。</p>
<p>原来：11 12 13 14 15 16 17 18 19 20</p>
<p>run后：11 12 13 14 16 17 18 19 20<br><img src="http://source.chenyalun.cn/images/201510/5103101.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;简单探讨顺序表的插入与删除&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="编程技巧" scheme="http://blog.chenyalun.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
