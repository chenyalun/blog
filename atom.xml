<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈亚伦</title>
  <subtitle>Write Less, Do More.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-12T02:03:23.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>陈亚伦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读「王中周博客」</title>
    <link href="http://yoursite.com/2016/11/10/%E8%AF%BB%E7%8E%8B%E4%B8%AD%E5%91%A8%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/11/10/读王中周博客/</id>
    <published>2016-11-10T08:02:17.000Z</published>
    <updated>2016-11-12T02:03:23.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 许多鞭辟入里的文章. </p>

<a id="more"></a>
<p>标注的文章:<br><a href="http://blog.csdn.net/wzzvictory/article/details/22417181" target="_blank" rel="external">Core Animation系列之CADisplayLink</a> </p>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/17694129" target="_blank" rel="external">Objective-C高级编程：iOS与OS X多线程和内存管理</a> </p>
<h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>零零碎碎花了一个多星期才把博客看完,文章比较详细,许多底层的东西我读了好几遍才理解,受益匪浅,把重要的知识点记下来,作复习之用.</p>
<h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><ol>
<li><p>self 是类的隐藏的参数，指向当前调用方法的类，另一个隐藏参数是 _cmd，代表当前类方法的 selector。</p>
</li>
<li><p>super 只是一个“编译器指示符”(编译器特性)，它和 self 指向的是相同的消息接收者。不同的是，super 告诉编译器，要去调用父类的方法，而不是本类里的。</p>
</li>
<li><p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法。</p>
</li>
<li><p>消息发送</p>
</li>
</ol>
<p><code>id objc_msgSend(id theReceiver, SEL theSelector, ...)</code></p>
<p>以<code>[self setName:]</code> 为例，编译器会替换成调用<code>objc_msgSend</code> 的函数调用，其中 theReceiver 是 self，theSelector 是 <code>@selector(setName:)</code>，这个 selector 是从当前 self 的 class 的方法列表开始找的 setName，当找到后把对应的 selector 传递过去。</p>
<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
struct objc_super {
    id receiver;
   Class superClass;
};
</code></pre><p> 而当使用<code>[super setName]</code> 调用时，会使用 <code>objc_msgSendSuper</code> 函数，结构体包含了两个成员，一个是 receiver，这个类似objc_msgSend 的第一个参数 receiver，第二个成员是记录所谓的“父类”。从 objc_super 结构体指向的 superClass 的方法列表开始找 setName 的 selector，找到后再以 <code>objc_super-&gt;receiver</code> 去调用这个 selector。</p>
<ol>
<li><p>NSNotification使用的是同步操作，如果想让NSNotification的post处和observer处异步执行，可以通过NSNotificationQueue实现。</p>
</li>
<li><p>对于同一个通知，如果注册了多个观察者，则这多个观察者的执行顺序和他们的注册顺序是保持一致的。observer的回调方法执行线程和post的线程保持一致，如果想让post的线程和转发的线程不同，可以通过NSNotification重定向技术实现。</p>
</li>
<li><p>addObserver和removeObserver必须成对出现，或者说添加了Observer必须适时移除Observer。因为通知中心并不retain Observer，若不移除，会极易给释放的对象发送消息。</p>
</li>
</ol>
<ol>
<li><p>普屏中1点 = 1像素，Retina屏：1点 = 2像素。人手指的最小点击范围是44pixels，所以在iPhone的很多细节上都是44 pixels。</p>
</li>
<li><p>使用图片资源时，方法：<code>[UIImage imageNamed:@&quot;adflower.png&quot;]]</code>，在实际运行时，如果发现当前的设备是Retina屏，会自动寻找图片”adflower@2x.png”。</p>
</li>
<li><p><code>[UIScreen mainScreen].applicationFrame</code>获取app尺寸(去掉状态栏)，<code>[ UIScreen mainScreen].bounds</code>获取屏幕尺寸，<code>[[UIApplicationsharedApplication] statusBarFrame]</code>状态栏尺寸。</p>
</li>
</ol>
<ol>
<li><p>在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是类对象(class object),它是一个单例(singleton),这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。</p>
</li>
<li><p>任何直接或间接继承了NSObject的类，它的实例对象(instance objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个  <strong>实例对象(instace object)</strong>  所属的类的定义的一切：包括变量，方法，遵守的协议等等。</p>
</li>
<li><p>类对象并不是类的实例本身。它没有自己的实例变量，也不能执行类的实例的方法。</p>
</li>
<li><p>类对象是一个功能完整的对象，也能被动态识别（dynamically typed），接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量），只是在运行时产生实例的代理。</p>
</li>
<li><p>类对象是元类对象的一个实例，元类是根元类(root class’s metaclass)的实例,而根元类是其自身的实例，即根元类的isa指针指向自身。</p>
</li>
<li><p>一个消息发送给任何一个对象， 方法的检查 从对象的 isa 指针开始，然后是父类。实例方法在类中定义， 类方法 在元类和根类中定义。（根类的元类就是根类自己）。</p>
</li>
<li><p>类对象(class object)中包含了类的实例变量、实例方法的定义，而元类对象(metaclass object)中包括了类的类方法的定义。类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。</p>
</li>
<li><p>①object_getClass跟随实例的isa指针，返回此实例所属的类，对于实例对象(instance)返回的是类(class),对于类(class)则返回的是元类(metaclass),<br>②<code>- class</code>方法对于实例对象(instance)会返回类(class),但对于类(class)则不会返回元类(metaclass),而只会返回类本身。<br>③class_isMetaClass可判断某类是否为元类.<br>④使用objc_allocateClassPair可在运行时创建新的类与元类对，使用class_addMethod和class_addIvar可向类中增加方法和实例变量，最后使用objc_registerClassPair注册后，就可以使用此类了。</p>
</li>
</ol>
<ol>
<li>alloc方法</li>
</ol>
<p>通过alloc或allocWithZone方法创建对象时，</p>
<ol>
<li>cocoa会遍历该对象所有的成员变量，通过成员变量的类型来计算所需占用的内存返回一个未”初使化“过的对象。</li>
<li>将该新对象的引用计数(Retain Count)设置成1。</li>
<li>该新对象的isa成员变量指向它的类对象。</li>
<li>将该新对象的所有其它成员变量的值设置成零。（根据成员变量类型的不同，零有可能是指nil或0）</li>
<li>返回指向该对象的一个指针。</li>
</ol>
<ol>
<li>init方法</li>
</ol>
<p>大部分情况下，我们都不希望所有成员变量都是零，所以</p>
<p>①init方法做初使化工作，让对象的成员变量的值符合我们程序逻辑中的初始化状态。<br>②返回真正可以使用的指向该对象的指针</p>
<p>某些情况下，init会造成alloc的原本空间不够用，而进行第二次分配内存空间。所以下面的写法是错的：</p>
<pre><code>NSString  *s=[NSString alloc];

[s init];// 这儿init返回的地址可能会变。s原本的指针地址可能是无效的地址。
</code></pre><p>正确的写法是<code>NSString  *s=[[NSString alloc] init];</code></p>
<p>new简单地等价于 alloc + init，但不能指定init的参数，很少用。</p>
<ol>
<li>NSInteger是一个有符号型int，它与int的区别就在于NSInteger可以自动识别机器是32位还是64位。NSInteger的无符号版本是NSUInteger。</li>
</ol>
<ol>
<li><p>运行时<br>消息只有到运行时才会和函数实现绑定起来，而不是按照编译好的逻辑一成不变的执行。编译阶段只是确定了要去向receiver对象发送message消息，但是却没有发送，真正发送是等到运行的时候进行。 </p>
</li>
<li><p>NSObject 类定义了description方法,返回该类内容的字符串表示。</p>
</li>
<li><p>某些 NSObject 的方法只是简单地从运行时系统中获得信息,从而允许对象进行一定程度的自我检查。<br>例如,class 返回对象的类;<code>isKindOfClass:</code>和 <code>isMemberOfClass:</code>则检查对象是否在指定的 类继承体系中;<code>respondsToSelector:</code>检查对象能否响应指定的消息;<code>conformsToProtocol:</code> 检查对象是否实现了指定协议类的方法;<code>methodForSelector:</code>则返回指定方法实现的地址。</p>
</li>
</ol>
<p>①message（消息）<br>message 是一种抽象，包括了函数名+参数列表，并没有实际的实体存在。<br>②method（方法）<br>method是真正的存在的代码。如：<code>- (int)meaning { return 42; }</code><br>③selector（方法选择器）<br>selector 通过SEL类型存在，描述一个特定的method 或者说 message。在实际编程中，可以通过selector进行检索方法等操作。</p>
<ol>
<li><p>方法选择器仅仅是一个<code>char *</code>指针，仅仅表示它所代表的方法名字。</p>
<pre><code>typedef struct objc_selector *SEL;  
    SEL selector = @selector(message); //@selector不是函数调用，只是给编译器的一个提示   
    NSLog (@&quot;%s&quot;, (char *)selector); //print message   
</code></pre></li>
<li><p>Objective-C在编译的时候，会根据方法的名字，生成一个用来区分这个方法的唯一的一个ID，这个ID就是SEL类型的（生成唯一的SEL）。只要方法的名字相同，那么它们的ID都是相同的。</p>
</li>
</ol>
<ol>
<li>编译器会根据每个方法的方法名为那个方法生成唯一的SEL，这些SEL组成了一个Set集合，这个Set简单的说就是一个经过了优化过的hash表。SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，从而加快方法的查询速度。</li>
</ol>
<ol>
<li>IMP <code>typedef id (*IMP)(id, SEL, ...);</code><br>由于每个方法都对应唯一的SEL，可以通过SEL方便、快速、准确的获得它所对应的IMP（也就是函数指针），而在取得了函数指针之后，也就意味着取得了执行这段方法的代码的入口，这样就可以像普通的C语言函数调用一样使用这个函数指针。</li>
</ol>
<pre><code>void (* performMessage)(id,SEL);//定义一个IMP（函数指针）   
performMessage = (void (*)(id,SEL))
[self methodForSelector:@selector(message)];
//通过methodForSelector方法根据SEL获取对应的函数指针   

performMessage(self,@selector(message));
//通过取到的IMP（函数指针）跳过runtime消息传递机制，直接执行message方法。
</code></pre><ol>
<li>用IMP 的方式，省去了runtime消息传递过程中所做的一系列动作，比直接向对象发送消息高效一些。</li>
</ol>
<ol>
<li>消息调用流程<br>消息表达式[receiver message]在被转换成objc_msgSend(receiver, SEL)后，在运行时，runtime system会做以下事情：</li>
</ol>
<ul>
<li><p>1、检查忽略的Selector（比如将会忽略retain和release消息）。</p>
</li>
<li><p>2、检查receiver是否为nil。（如果receiver为空，则会将 selector也设置为空，并且直接返回到消息调用的地方。）如果对象非空，就继续下一步。</p>
</li>
<li><p>3、根据SEL到当前类中查找对应的IMP，首先会在cache中检索它，如果找到了就根据函数指针跳转到这个函数执行，否则进行下一步。</p>
</li>
<li><p>4、检索当前类对象中的方法表（method list），如果找到了，加入cache中，并且就跳转到这个函数执行，否则进行下一步。</p>
</li>
<li><p>5、从父类中寻找,直到根类：NSObject类。找到了就将方法加入对应类的cache表中，如果仍未找到，则要进入动态方法决议。</p>
</li>
<li><p>6、如果动态方法决议仍不能解决问题，只能进行最后一次尝试，进入消息转发流程。</p>
</li>
</ul>
<p>注意：cache的原则就是缓存那些可能要执行的函数地址，下次调用的时候，速度就可以快速很多。</p>
<ol>
<li><p>类方法和实例方法中，都可以访问self和_cmd这两个属性，因为它们都不属于类的实例变量，而是形参。</p>
</li>
<li><p>objc_msgSend找到方法对应的实现时,将直接调用该方法实现,并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:<br><em>接收消息的对象（也就是self指向的内容）
</em>方法选标（_cmd指向的内容）</p>
</li>
</ol>
<p>”隐藏“：因为它们并没有在定义方法的源代码中声明,而是在代码编译时是插入方法的实现中的。在方法中可以通过 self 来引用消息接收者对象,通过选标_cmd 来引用方法本身。</p>
<pre><code>- (void)message  
{  
    self.name = @&quot;James&quot;;//通过self关键字给当前对象的属性赋值  
    SEL currentSel = _cmd;//通过_cmd关键字取到当前函数对应的SEL  
    NSLog(@&quot;currentSel is :%s&quot;,(char *)currentSel);  
} 
</code></pre><ol>
<li>当被调用的方法实现部分没有找到，而消息转发机制启动之前的这个中间时刻(动态添加方法)。<code>+(BOOL) resolveInstanceMethod:(SEL) sel</code>将被调用。这是NSObject根类提供的类方法。</li>
<li><p>@dynamic关键字的作用:①告诉编译器不要创建实现属性所用的实例变量；②告诉编译器不要创建该属性的get和setter方法。让编译器相信存取方法会在运行时找到。</p>
<pre><code>// 声明文件中
@property(nonatomic,retain) NSString    *name; 

// 实现文件中
@dynamic name;  
</code></pre></li>
<li><p>默认情况下，编译器会为当前类自动生成一个NSString   <em>_name的实例变量（如果想改变实例变量的名称可以用@synthesize关键字），同时会生成两个名为` - (NSString </em>)name<code>和</code>- (void)setName:(NSString *)aName`的存取方法。</p>
<pre><code>void dynamicMethodIMP(id self, SEL _cmd)  
{  
    // implementation ....  
}  

+ (BOOL)resolveInstanceMethod:(SEL)sel  
{  
    NSLog(@&quot;sel is %@&quot;, NSStringFromSelector(sel));  
    if(sel == @selector(setName:)){  
        class_addMethod([self class],sel,(IMP)dynamicMethodIMP,&quot;v@:&quot;);  
        return YES;  
    }  
    return [super resolveInstanceMethod:sel];  
}  
</code></pre></li>
<li><p>消息转发.外部调用的某个方法对象没有实现，而且resolveInstanceMethod方法中也没有做重定向处理时，就会触发<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>方法。这个方法通常用来将不能处理的消息转发给其它的对象。</p>
<pre><code>-(void)forwardInvocation:(NSInvocation *)invocation  
{  
    SEL invSEL = invocation.selector;  
    if ([someOtherObject respondsToSelector:invSEL])  
        [anInvocation invokeWithTarget:someOtherObject];  
    } else {  
        [self doesNotRecognizeSelector:invSEL];   
    }                                                                            
}  
</code></pre></li>
<li><p>Cocoa（iOS上的叫Cocoa Touch）是一个面向对象的软件组件——类的集成套件，它使开发者可以快速创建强壮和全功能的 Mac OS X （IOS）应用程序。Cocoa包含了很多框架，其中最最核心的是Foundation框架和Application Kit（AppKit）框架（Cocoa Touch中叫UIKit框架）。</p>
</li>
<li><p>imageNamed的优点在于可以缓存已经加载的图片。这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回.</p>
</li>
<li>imageWithContentsOfFile方法只是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到程序。当不需要重用该图像，或者需要将图像以数据方式存储到数据库，又或者要通过网络下载一个很大的图像时，可以使用这种方式。</li>
<li>run loop是为了线程而生,是线程的基础架构部分，每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。主线程的run loop默认是启动的。</li>
<li>UIApplicationMain()函数，会为main thread设置一个NSRunLoop对象.</li>
<li>NSRunLoop类并不是线程安全的,不能在一个线程中去操作另外一个线程的run loop对象,CFRunLoopRef是线程安全的.</li>
<li>获取到当前线程的run loop:<code>[NSRunLoop currentRunLoop];</code>获取对应的CFRunLoopRef类<code>- (CFRunLoopRef)getCFRunLoop;</code></li>
<li>一个run loop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。对消息处理过程进行了更好的抽象和封装，在NSRunLoop中每一个消息就被打包在input source或者是timer source中了。使用run loop可以使线程在有工作的时候工作，没有工作的时候休眠，这可以大大节省系统资源。</li>
<li>创建输入源的时候，需要将其分配给run loop中的一个或多个模式.</li>
<li>定时源在预设的时间点同步方式传递消息，这些消息都会发生在特定时间或者重复的时间间隔。定时源则直接传递消息给处理例程，不会立即退出run loop。</li>
<li>创建NSTimer</li>
</ol>
<pre><code>// 方式一:自动把timer加入MainRunloop的NSDefaultRunLoopMode中
NSTimer *timer = [NSTimer scheduledTimerWithTimeInteral:1.0 target:self selector:@selector(action:) userInfo:ni] repeat:NO];

// 停止
[timer invalidate];


// 方式二(需手动加到run loop中)
   NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self seletor:@selector(timerAction) userInfo:nil repeats:YES];

   [[NSRunloop mainRunloop] addTimer:timer forMode:NSDefaultRunloopMode];
</code></pre><p>特点:调用创建方法后,target对象的引用计数会+1,直到执行完毕,自动-1.如果RunLoop正在执行一个连续的运算,timer就会被延迟触发</p>
<ol>
<li>响应者对象（Responder Object），指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。</li>
</ol>
<ul>
<li><p>响应者链通常是由视图（UIView）构成的；</p>
</li>
<li><p>一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）；</p>
</li>
<li><p>视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图；</p>
</li>
<li><p>单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者.</p>
</li>
<li><p>单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。</p>
</li>
</ul>
<ol>
<li><p>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。</p>
</li>
<li><p>UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。</p>
</li>
<li><p>UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:</p>
</li>
</ol>
<ol>
<li>方法的处理流程如下:<br>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；<br>若返回NO,则hitTest:withEvent:返回nil;<br>若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；<br>若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；<br>如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。</li>
</ol>
<ol>
<li><p>非正式协议通常定义为NSObject的类别。</p>
</li>
<li><p>类别与类扩展的区别：<br>①类别中只能增加方法；<br>②类扩展不仅可以增加方法，还可以增加实例变量（或者合成属性），只是该实例变量默认是@private类型的；<br>③类扩展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中。<br>④类扩展所声明的方法必须依托对应类的实现部分来实现。<br>⑤定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。</p>
</li>
<li><p>KVC全称是Key-value coding，翻译成键值编码。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。KVO全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。KVO机制很适合实现model和controller类之间的通讯。</p>
</li>
<li>KVC是不会自动调用键值验证方法的，我们需要手动验证。<code>- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</code></li>
<li>KVC可以自动的将数值或结构体型的数据打包或解包成NSNumber或NSValue对象，以达到适配的目的。</li>
<li>代码片段存放路径<code>~/Library/Developer/Xcode/UserData/CodeSnippets</code></li>
<li>ARC的英文全名是：Automatic Reference Counting，是编译器提供的管理Objective-C对象内存的一个机制。它并不是像垃圾回收机制那样，有一个负责内存回收的系统，而是仍然以引用计数为基础：在编译阶段，编译器会在需要retain或release对象的地方自动为我们加上对应的代码。</li>
<li>内存管理规则：一个Object-C对象存在strong类型的指针指向时，该对象就不会被释放。</li>
<li><p>①strong<br>该属性值对应 <code>__strong</code>关键字，即该属性所声明的指针变量将成为对象的持有者。strong是指向Objective-C对象指针的默认属性。<br>②weak<br>该属性对应<code>__weak</code>关键字，与<code>__weak</code>定义的变量一致，该属性所声明的变量将没有对象的所有权，并且当对象被破弃之后，对象将被自动赋值nil。<br>④copy<br>也是对象的所有者，与strong的区别是声明的指针变量是拷贝对象的持有者。<br>⑤assign<br>一般数值型变量用该属性声明，比如,int, BOOL，但无需显示写出，因为数值型变量的默认属性类型就是assign</p>
</li>
<li><p>使用关键字声明指针类型规范写法:</p>
<pre><code>//规范的写法
MyClass * __weak myWeakReference;
</code></pre></li>
<li><p>weak和assign的异同</p>
</li>
</ol>
<p>相同点：指向的对象都是随时有可能被释放，即不拥有指向的对象<br>不同点：①weak只能用来声明Objective-C对象，assign既可以用来声明对象，也可以用来声明数值型变量；②很关键的一点区别，当一个weak关键字声明的指针指向的对象被释放掉得时候，该指针会自动的被指向nil而assign不存在该特性.</p>
<ol>
<li>使用@property声明或作为普通实例变量声明的指向Objective-C对象的指针属性默认都是strong；而使用@property声明的数值型变量属性默认的是assign，普通的数值型变量的属性是__unsafe_unretaind。</li>
</ol>
<table>
<thead>
<tr>
<th>属性</th>
<th>关键字</th>
<th>所有权</th>
</tr>
</thead>
<tbody>
<tr>
<td>strong</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>copy</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
<td>有</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
<td>无</td>
</tr>
<tr>
<td>assign</td>
<td>__unsafe_unretained</td>
<td>无</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe_unretained</td>
<td>无</td>
</tr>
</tbody>
</table>
<ol>
<li><p>使用ARC需要遵守的新规则<br>①不要在dealloc方法中调用[super dealloc];<br>②不能使用 retain/release/retainCount/autorelease<br>③不能使用 NSAllocateObject/NSDeallocateObject<br>④不能使用 NSZone<br>⑤Objective-C 对象不能作为C语言结构体（struct/union）的成员</p>
</li>
<li><p>instancetype表示某个方法返回的未知类型的Objective-C对象,instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型,能够确定对象的类型.有利于开发者在编译阶段发现错误。</p>
</li>
<li>关联返回类型（related result types）1、类方法中，以alloc或new开头2、实例方法中，以autorelease，init，retain或self开头.</li>
<li><p>instancetype和id的异同: 1、相同点:都可以作为方法的返回类型<br>2、不同点<br>①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；<br>②instancetype只能作为返回值，不能像id那样作为参数</p>
</li>
<li><p>每个应用的沙盒目录都是相似的，主要包含4个目录：<br>1、MyApp.app<br>存放应用程序本身的数据,整个目录是只读的,不能被iTunes同步<br>2、Documents<br>存放不可再生的的数据文件,会被iTunes同步.<br>3、Library<br>存放默认设置或其它状态信息。<br>除了Caches子目录外,会被iTunes同步.<br>4、Library/Caches<br>存放缓存文件，保存那些可再生的文件,不会被iTunes同步<br>5、Library/Preferences<br>存放应用程序的偏好设置文件。我们使用NSUserDefaults写的设置数据都会保存到该目录下的一个plist文件中，会被iTunes同步<br>6、tmp<br>存放各种临时文件,不会被iTunes同步</p>
</li>
</ol>
<ol>
<li>runtime采用散列表来管理引用计数,统一存储所有对象的引用计数,不用考虑每个对象内存块中引用计数所占的内存,在引用计数表中存储各个对象的内存地址.</li>
<li>NULL本质上是：(void<em>)0,表示C指针为空,如`charchar </em>string = NULL; `</li>
<li>nil本质上是：(void *)0,表示指向Objective-C中对象的指针为空</li>
<li>Nil本质上也是：(void *)0,表示Objective-C中Class类型的变量值为空,<code>Class anyClass = Nil;</code></li>
<li><p>NSNull是一个Objective-C类,该类通常用于在集合对象中保存一个空的占位对象</p>
<pre><code>// 遇到nil截断
NSArray *arr = [NSArray arrayWithObjects:@&quot;wang&quot;,@&quot;zz&quot;,nil,@&quot;foogry&quot;];

// 存储空的占位对象
NSArray *arr = [NSArray arrayWithObjects:@&quot;wang&quot;,@&quot;zz&quot;,[NSNull null],@&quot;foogry&quot;];
</code></pre></li>
</ol>
<blockquote>
<p>向作者致谢!<br>王中周的个人博客:<a href="http://blog.csdn.net/wzzvictory" target="_blank" rel="external">http://blog.csdn.net/wzzvictory</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 许多鞭辟入里的文章. &lt;/p&gt;
    
    </summary>
    
      <category term="博记" scheme="http://yoursite.com/categories/%E5%8D%9A%E8%AE%B0/"/>
    
    
      <category term="ios开发" scheme="http://yoursite.com/tags/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>读「李明杰博客」</title>
    <link href="http://yoursite.com/2016/10/28/%E8%AF%BB%E6%9D%8E%E6%98%8E%E6%9D%B0%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/10/28/读李明杰博客/</id>
    <published>2016-10-28T11:22:17.000Z</published>
    <updated>2016-11-10T07:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 李明杰老师是我很尊敬的iOS启蒙老师. </p>

<a id="more"></a>
<h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>这次零零碎碎花了一周时间拜读老师的博客,很多知识点理解地更透彻了,尤其是C语言方面的.不太熟悉或将近遗忘的知识点记录下来,做复习巩固之用.</p>
<h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><ol>
<li><p>loadView、viewDidLoad及viewDidUnload的关系是怎样的?</p>
</li>
<li><p>为什么默认情况下UIImageView内的按钮无法点击?忽略视图的四种方法?</p>
</li>
<li><p>只声明一个局部int类型变量与只声明一个全局的int类型变量,却不初始化,其值是?</p>
</li>
<li><p>使用char存储大写字母A有哪两种赋值方式?</p>
</li>
<li><p>逗号表达式的运算过程<code>c = (++a, a *= 2, b = a * 5);</code>是怎样的?</p>
</li>
<li>枚举与结构体定义的三种方式?</li>
<li>为何不要在description方法中同时使用%@和self?</li>
</ol>
<h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><ol>
<li><p>不要在UIViewController的loadView方法中改变状态栏的可视性,会导致重复调用2次loadView和viewDidLoad方法.</p>
</li>
<li><p>控制打印格式</p>
<p> printf(“My height is %8.1f”, 179.95f);</p>
<p> scanf(“%d-%d-%d”, &amp;a, &amp;b, &amp;c);<br> scanf(“%d %d %d”, &amp;a, &amp;b, &amp;c);</p>
</li>
</ol>
<ol>
<li><p>计算机中的内存是以字节为单位的存储空间.<br>内存的每一个字节都有一个唯一的编号，这个编号就称为地址.<br>凡存放在内存中的程序和数据都有一个地址，也就是说，一个函数也有自己的内存地址。变量存储单元的第一个字节的地址就是该变量的地址.</p>
</li>
<li><p>二维数组的&amp;a[i] == (a+i)</p>
</li>
<li><p>gets可以读入包含空格、tab的字符串，直到遇到回车为止；<br>getchar函数可以读入空格、TAB，直到遇到回车为止。scanf则不能读入空格和TAB。scanf不能用来读取空格、tab.</p>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    char a[10];
    char b[10];
    gets(a);
    puts(a);

    scanf(&quot;%s&quot;,b);
    puts(b);
    return 0;
}
</code></pre></li>
</ol>
<pre><code>putchar(65); // A

putchar(&apos;A&apos;); // A

int a = 65;
putchar(a); // A

char c;
c = getchar();
</code></pre><ol>
<li><p>包含string.h头文件后,strlen\strcpy\strcat\strcmp函数的用法</p>
<pre><code>// 长度为2,遇空字符\0断!
int size = strlen(&quot;mj&quot;);

// 遇空字符\0断!
char s[10];
strcpy(s, &quot;lmj&quot;);

// 遇空字符\0断!
char s1[30] = &quot;LOVE&quot;;
strcat(s1, &quot;OC&quot;);

// 左减右,比字符ASCII码差值
strcmp(s1, s2);
</code></pre></li>
<li><p>通过变量名引用变量，由系统自动完成变量名和其存储地址之间的转换，称为变量的”直接引用”方式.<br>首先将变量a的地址存放在另一个变量中，比如存放在变量b中，然后通过变量b来间接引用变量a，间接读写变量a的值。这就是”间接引用”.</p>
</li>
<li><p>在指针变量没有指向确定地址之前，不要对它所指的内容赋值。<code>int *p; *p = 10; //这是错误的</code>.</p>
</li>
<li>基本数据类型作为函数实参时，只是纯粹地将值传递给形参，形参的改变并不影响实参。</li>
<li><p>如何使一个函数有多个返回值.</p>
<pre><code>int test(int a, int b,int *c) {
    // 赋值给指针指向的变量
    *c = a + b;
    return a * b;
}

int main(int argc, const char * argv[]) {
    int m = 2,n = 4,s1,s2;
    s1 =  test(m, n, &amp;s2);

    printf(&quot;%d---%d&quot;,s1,s2);
    return 0;
}
</code></pre></li>
<li>二维数组中,可以根据a[0]的地址获取其他元素的地址，使p=&amp;a[0],p+1就是a[1]的地址。这里的p+1不一定代表p的值加1，也可能是加2、加4或者加8。究竟加多少，这跟指针的类型有关.</li>
<li>指针操作中,数组名a是个常量,不能进行赋值运算！<code>*(p+i)和*(a+i)都表示数组元素a[i]</code><pre><code>char s[10];
s = &quot;mj&quot;;// 错误! s是常量
</code></pre></li>
<li>用数组名作为函数实参时，是把实参数组的首地址传递给形参数组，两个数组共同占用同一段内存空间，这样形参数组中的元素值发生变化就会使实参数组的元素值也同时变化.</li>
<li><code>char *s = &quot;mj&quot;;3 *s = &quot;like&quot;;</code>的两个错误:1,s指向的是”mj”的首字符’m’,只有一个字节,要”like”存进1个字节的空间内，肯定内存溢出.2,s指向的是字符串常量”mj”,不能再通过指针来修改字符串内容(字符数组可以修改).</li>
<li><p>分辨:</p>
<pre><code>char a[] = &quot;lmj&quot;;定义的是一个字符串变量
char *p2 = &quot;lmj&quot;;定义的是一个字符串常量
</code></pre></li>
<li><p>返回指针的函数</p>
<pre><code>   // 将字符串str中的小写字母变成大写字母，并返回改变后的字符串
   // 注意的是：这里的参数要传字符串变量，不能传字符串常量
   char * upper(char *str) {
       // 先保留最初的地址。因为等会str指向的位置会变来变去的。
       char *dest = str;

   // 如果还不是空字符
   while (*str != &apos;\0&apos;) {
       // 如果是小写字母
       if (*str &gt;= &apos;a&apos; &amp;&amp; *str &lt;= &apos;z&apos;) {
           // 变为大写字母。小写和大写字母的ASCII值有个固定的差值
           *str -= &apos;a&apos; - &apos;A&apos;;
       }

       // 遍历下一个字符
       str++;
   }

   // 返回字符串
   return dest;
}
// 调用:
   int main()
   {
       // 定义一个字符串变量
       char str[] = &quot;lmj&quot;;

       // 调用函数
       char *dest = upper(str);

       printf(&quot;%s&quot;, dest);
       return 0;
   }
</code></pre></li>
<li><p>指向函数的指针</p>
<pre><code>int sum(int a, int b) {
    return a + b;
}

int main()
{
    // 定义一个指针变量p，指向sum函数
    int (*p)(int a, int b) = sum;
    // 或者 int (*p)(int, int) = sum;
    // 或者 int (*p)() = sum;

    // 利用指针变量p调用函数
    int result = (*p)(1, 3);
    // 或者 int result = p(1, 3);

    printf(&quot;%d&quot;, result);
    return 0;
}
</code></pre></li>
</ol>
<ol>
<li><p>将函数作为参数在函数间传递</p>
<pre><code> // 减法运算
 int minus(int a, int b) {
    return a - b;
 }

// 加法运算
int sum(int a, int b) {
    return a + b;
}

// 这个counting函数是用来做a和b之间的计算，至于做加法还是减法运算，由函数的第1个参数决定
void counting( int (*p)(int, int) , int a, int b) {
    int result = p(a, b);
    printf(&quot;计算结果为：%d\n&quot;, result);
}

int main()
{
    // 进行加法运算
    counting(sum, 6, 4);

    // 进行减法运算
    counting(minus, 6, 4);

    return 0;
 }
</code></pre></li>
<li><p>所有预处理指令都以符号”#”开头，并且结尾不用分号,作用范围是从它出现的位置到文件尾,主要有：宏定义、文件包含、条件编译.</p>
</li>
<li>使用带参数的宏定义,最好将参数和结果都用括号括起来.</li>
<li>宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题,宏替换只在编译预处理阶段进行,带参数的宏比函数具有更高的执行效率.</li>
<li><p>条件编译</p>
<pre><code>#if 条件1
 ...code1...
#elif 条件2
 ...code2...
#else
 ...code3...
#endif

#if defined(MAX)
     ...code...
#endif

#if !defined(MAX)
     ...code...
#endif
</code></pre></li>
<li><p><code>#include　&lt;文件名&gt;</code>到C语言库函数头文件所在的目录中寻找文件,<code>#include　&quot;文件名&quot;</code>系统会先在源程序当前目录下寻找，若找不到，再到操作系统的path路径中查找，最后才到C语言库函数头文件所在目录中查找.</p>
</li>
<li><p>避免#include重复包含同一个头文件:使用条件编译</p>
<pre><code>#ifndef _ONE_H_
#define _ONE_H_

void one();

#endif
</code></pre></li>
<li>在函数内部定义的变量，称为局部变量。形式参数也属于局部变量,在所有函数外部定义的变量，称为全局变量.</li>
<li>所有的局部变量在默认情况下都是自动变量,是存储在堆栈中的.所有的全局变量和被关键字static修饰的局部变量都是静态变量,是存储在静态内存中的，也就是不属于堆栈.</li>
<li>静态变量在程序运行之前创建，在程序的整个运行期间始终存在，直到程序结束。在程序执行到声明自动变量的代码块(函数)时，自动变量才被创建；当自动变量所在的代码块(函数)执行完毕后，这些自动变量就会自行销毁.</li>
<li><p>被关键字register修饰的自动变量都是寄存器变量,是存储在硬件寄存器中的,其生命周期即是自动变量的生命周期.寄存器变量只限于int、char和指针类型变量使用,将一些频繁使用的自动变量定义为寄存器变量，这样程序尽可能地为它分配寄存器存放，而不用内存.</p>
<pre><code>register int a;
register char b;
register int *c;
</code></pre></li>
<li>如果一个程序中有多个源文件(.c)，编译成功会生成对应的多个目标文件(.obj)，这些目标文件不能单独运行，因为这些目标文件之间可能会有关联。将这些相关联的目标文件链接在一起后才能生成可执行文件。</li>
<li>所谓编译，就是单独检查每个源文件的语法是否合理，并不会检查每个源文件之间的关联关系，一个源文件编译成功就生成一个目标文件。所谓链接，就是检查目标文件的关联关系，将相关联的目标文件组合在一起，生成可执行文件。</li>
<li>根据在当前文件中定义的函数是否允许其他文件访问,可将函数分为内部函数和外部函数.默认情况下，所有的函数都是外部函数,不允许重复定义同一个外部函数.</li>
<li><p>使用extern关键字，表示引用其他文件的”外部函数”: <code>extern void test();</code>,然而extern可以省略,故直接声明即可.正规的项目里面，把”外部函数”的声明另写到一个头文件中,使用时直接包含头文件即可.</p>
<pre><code>#ifndef one_h
#define one_h

#include &lt;stdio.h&gt;
void test();
#endif /* one_h */
</code></pre></li>
<li><p>在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数),不允许其他文件访问.不同的文件中有同名的内部函数，则互不干扰。</p>
</li>
<li><p>默认情况下，一个函数不可以访问在它后面定义的全局变量.不同源文件中的同名全局变量代表着同一个变量</p>
<pre><code>// a文件
int ss =10;

// b文件
extern int  ss ;
printf(&quot;%d&quot;, ss);// 是10
</code></pre></li>
<li>在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰</li>
<li><p>定义结构体的三种形式(枚举变量的定义与之类似)</p>
<pre><code>struct Student {
    char *name;
    int age;
};
struct Student stu;
</code></pre></li>
</ol>
<pre><code>struct Student {
    char *name;
    int age;
} stu;



struct {
    char *name;
    int age;
} stu;
</code></pre><ol>
<li>定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量.结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列.</li>
<li>将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参.</li>
<li>结构体指针变量的定义形式：<code>struct 结构体名称 *指针变量名</code>,三种访问方式:<ul>
<li>结构体变量名.成员名</li>
<li>(*指针变量名).成员名</li>
<li>指针变量名-&gt;成员名</li>
</ul>
</li>
<li><p>typedef也可以给指针起别名:<code>typedef char *String;</code></p>
<pre><code>// 相当于char *str = &quot;This is a string!&quot;;
String str = &quot;This is a string!&quot;;
</code></pre></li>
<li><p>typedef给结构体起别名</p>
</li>
</ol>
<pre><code>    struct CGRect {
    CGPoint origin;
    CGSize size;
};
typedef struct CGRect CGRect;
</code></pre><ol>
<li><p>typedef给指向结构体的指针起别名</p>
<pre><code>#include &lt;stdio.h&gt;

// 定义一个结构体并起别名
typedef struct {
    float x;
    float y;
} Point;

// 起别名
typedef Point *PP;

int main(int argc, const char * argv[]) {
    // 定义结构体变量
    Point point = {10, 20};

    // 定义指针变量Point *p = &amp;point;
    PP p = &amp;point;

    // 利用指针变量访问结构体成员
    printf(&quot;x=%f，y=%f&quot;, p-&gt;x, p-&gt;y);
    return 0;
 }
</code></pre></li>
<li><p>typedef与枚举类型</p>
<pre><code>// 定义枚举类型
 enum Season {spring, summer, autumn, winter};
 // 给枚举类型起别名
 typedef enum Season Season;

 int main(int argc, const char * argv[]) {
     // 定义枚举变量
     Season s = spring;

     return 0;
 }
</code></pre><p>43.typedef给指向函数的指针类型起别名</p>
<pre><code>#include &lt;stdio.h&gt;

// 定义一个sum函数，计算a跟b的和
int sum(int a, int b) {
    int c = a + b;
    printf(&quot;%d + %d = %d&quot;, a, b, c);
    return c;
}

typedef int (*MySum)(int, int);

int main(int argc, const char * argv[]) {
    // 定义一个指向sum函数的指针变量p
    MySum p = sum;

    // 利用指针变量p调用sum函数
    (*p)(4, 5);

    return 0;
 }
</code></pre></li>
</ol>
<ol>
<li><p>typedef与#define,给类型起别名，最好使用typedef，而不是使用#define.</p>
<pre><code>typedef char *String1;
#define String2 char *

// 相当于char *str1;char *str2;
String1 str1, str2;
// 相当于char *str3;char  str4;产生误会
String2 str3, str4;
</code></pre></li>
<li><p>C语言的源文件拓展名为”.c”，OC的源文件拓展名为”.m”,编译器会将.m文件编译为.o目标文件.编译器只会编译.m文件，并不会编译.h文件.</p>
</li>
<li><code>#import</code>是一个预处理指令，作用跟C语言的<code>#include</code>类似，都是 包含(拷贝)某个文件的内容 到 预处理指令所在的位置。在OC中，使用#import来包含头文件，可以自动防止同一个头文件被包含多次。<code>#import &lt;...&gt;</code>表示包含系统自带的文件，<code>#import &quot;...&quot;</code>表示包含开发人员自己创建的文件.</li>
<li><code>+</code>表示静态方法,<code>-</code>表示动态方法,在.h中声明的所有方法作用域都是public类型，不能更改.成员变量默认作用域是@protected,成员变量必须写在大括号{ }里面.</li>
<li>OC建议get方法的名字跟成员变量保持一致</li>
<li>静态方法alloc分配存储空间,返回分配好内存的对象;对象的构造方法init进行初始化.</li>
<li>访问公共变量age:对象-&gt;成员变量,<code>stu-&gt;_age = 10; int a = stu-&gt;_age;</code></li>
<li>OC点语法的本质是方法调用，不是直接访问成员变量.</li>
<li>UIView之所以能显示在屏幕上，完全是因为它内部的一个层(CALayer对象)。当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了UIView的显示。</li>
<li>通过layer属性可以设置shadowColor\shadowOffset\shadowOpacity\cornerRadius\borderWidth\borderColor等;maskToBounds=YES：是强制内部的所有子层支持圆角效果，少了这个设置，是不会有圆角效果的,如果设置了maskToBounds=YES，那将不会有阴影效果.</li>
<li>CALayer是定义在QuartzCore框架中的；CGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的；UIColor、UIImage是定义在UIKit框架中的.</li>
<li>每一个UIView内部都默认关联着一个CALayer，这个Layer为Root Layer（根层）;所有的非Root Layer，也就是手动创建的CALayer对象，都存在着隐式动画。当对非Root Layer的部分属性进行相应的修改时，默认会自动产生一些动画效果，这些属性称为Animatable Properties(可动画属性)。<ul>
<li>bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画</li>
<li>backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画</li>
<li>position：用于设置CALayer的位置。修改这个属性会产生平移动画</li>
</ul>
</li>
<li>position可以用来设置CALayer在父层中的位置，它是以父层的左上角为坐标原点(0, 0);anchorPoint称为”定位点”，它决定着CALayer身上的哪个点会在position属性所指的位置。它的x、y取值范围都是0~1，默认值为(0.5, 0.5).</li>
<li>不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate.</li>
<li>当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法.</li>
<li>平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕.</li>
<li>Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程,而且是直接作用在CALayer上的，并非UIView.</li>
<li>没有存储任何内存地址的指针就称为空指针(NULL指针,指向nil),空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。可以给空指针发送消息,但消息发送不出去.”野指针”不是NULL指针，是指向”垃圾”内存（不可用内存）的指针.</li>
<li>源文件编译成功后，会生成一个.o目标文件，这就是一个二进制文件.</li>
<li><p>clang指令汇总</p>
<pre><code>编译单个c源文件，并产生一个目标文件  cc -c one.c
编译多个c源文件，并为每个文件产生一个目标文件  cc -c one.c two.c three.c
链接单个目标文件产生一个名为a.out的可执行文件  cc one.o
链接多个目标文件  cc one.o two.o three.o
编译并链接一个c源文件  cc one.c
编译并链接多个c源文件  cc one.c two.c three.c
编译一个c源文件，并把它和现存的目标文件链接在一起  cc one.o two.o three.c
可执行文件重命名加上“-o name”这个选项  cc -o abc one.c
执行可执行文件  ./a.out
</code></pre></li>
<li>当使用基本数据类型（char、int、float等）作为实参时，实参和形参之间只是值传递，修改形参的值并不影响到实参</li>
</ol>
<blockquote>
<p>向作者致谢!<br>M了个J:<a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">http://www.cnblogs.com/mjios/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 李明杰老师是我很尊敬的iOS启蒙老师. &lt;/p&gt;
    
    </summary>
    
      <category term="博记" scheme="http://yoursite.com/categories/%E5%8D%9A%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="ios开发" scheme="http://yoursite.com/tags/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C语言交换两个数值的八种方法</title>
    <link href="http://yoursite.com/2016/10/23/C%E8%AF%AD%E8%A8%80%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%80%BC%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/10/23/C语言交换两个数值的八种方法/</id>
    <published>2016-10-23T02:20:17.000Z</published>
    <updated>2016-10-25T14:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 在回顾C语言的时候,偶遇此题,因曾被其深虐,特意搜寻多种解决办法,以鞭笞岁月. </p><br><a id="more"></a><p></p>
<blockquote>
<p>编译器:XCode8.0</p>
</blockquote>
<h1 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">   int m = 5, n = 3;</div><div class="line">   m = m ^ n;</div><div class="line">   n = m ^ n;</div><div class="line">   m = m ^ n;</div><div class="line">   </div><div class="line">   printf(&quot;m:%d---n:%d&quot;,m,n);</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>异或一般是针对二进制数.</p>
<ol>
<li>两数异或,相同则得0,不同则得1</li>
<li>x ^ x = 0,x ^ 0 = x<br>第二行:  m:0101 n:0011<br>第三行:  m:0110 n:0011<br>第四行:  n:0101 m:0110<br>第五行:  m:0011 n:0101<br>此时,已完成交换.</li>
</ol>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><pre><code>int main(int argc, const char * argv[]) {
    int m = 2147483648, n = 2147483647;
    m = m + n - (n = m);
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><ol>
<li>从左向右依次进行,首先获取m与n的和,接着利用()运算符直接将m的值赋予n,此时n完成交换</li>
<li>同时()内的值是m的值,两数之和减去m值便是n的值,再将n的值赋予m,到这里m完成交换</li>
</ol>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><pre><code>int main(int argc, const char * argv[]) {
int m = 5, n = 3;
n = (long)((long)m &lt;&lt; 32 | (m = n)) &gt;&gt; 32;
printf(&quot;m:%d---n:%d&quot;,m,n);
return 0;
}
</code></pre><p>注:<code>__int64表示64位整型变量,Xcode中用long代替,VC6.0可直接使用__int64,即: b = (__int64)((__int64)a &lt;&lt; 32 | (a = b)) &gt;&gt; 32；</code></p>
<ol>
<li>(m = n):完成m的交换,()的值是n</li>
<li>(long)((long)m &lt;&lt; 32 | n):得到的结果是 <code>00...0  0101   00...0  11</code>第一部分28个0,第三部分30个0 </li>
<li>((long)((long)m &lt;&lt; 32 ) &gt;&gt; 32:得到的结果:把第三第四部分去掉,即<code>00...0  0101</code> 正好32位,且此值为m的值,再将其赋予n,完成n的交换.</li>
</ol>
<h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><pre><code>#define swap(x, y, z) ((z) = (x), (x) = (y), (y) = (z))

int main(int argc, const char * argv[]) {
    int m = 5, n = 3,t = 0;
    swap(m, n, t);
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><p>比较巧妙,把中间变量放在宏中.</p>
<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><pre><code>int main(int argc, char *argv[]) {
int m = 5, n = 3;
m = m + n;
n = m - n;
m = m - n;

printf(&quot;m:%d---n:%d&quot;,m,n);
return 0;
}
</code></pre><p>算是一种数学方法吧,但可能溢出.</p>
<h1 id="两数之积"><a href="#两数之积" class="headerlink" title="两数之积"></a>两数之积</h1><pre><code>int main(int argc, const char * argv[]) {
    int m = 5, n = 3;
    m = m * n;
    n = m / n;
    m = m / n;

    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><p>两数之和方法的变形,n不能为0,m更可能溢出.</p>
<h1 id="经典的交换函数"><a href="#经典的交换函数" class="headerlink" title="经典的交换函数"></a>经典的交换函数</h1><pre><code>void swap(int *a, int *b) {
    int temp = 0;
    temp = *a;
    *a = *b;
    *b = temp;
}

int main(int argc, const char * argv[]) {
    int m = 2147483648, n = 2147483647;
    swap(&amp;m,&amp;n);
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><h1 id="直接添加变量"><a href="#直接添加变量" class="headerlink" title="直接添加变量"></a>直接添加变量</h1><pre><code>int main(int argc, const char * argv[]) {
    int m = 2147483648, n = 2147483647,temp = 0;
    temp = m;
    m = n;
    n = temp;
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><p>int最大值，根据编译器类型不同而变化。<br>1 对于16位编译器，int占16位(2字节)。<br>int的最大值为32767.<br>2 对于32位和64位编译器，int占32位(4字节)。<br>int的最大值为2147483647</p>
<p>3 可以通过打印sizeof(int)查看平台对应的int占用字节数。乘8后即为位数。<br>最高位为符号位，如位数为n，则最大值为<br>2^(n-1)<br>即2的n-1次幂。</p>
<pre><code>printf(&quot;%lu&quot;,sizeof(int));
int a = 2147483648;
</code></pre><blockquote>
<p>参考并致谢:<br><a href="http://blog.csdn.net/ljx_5489464/article/details/50042571" target="_blank" rel="external">http://blog.csdn.net/ljx_5489464/article/details/50042571</a><br><a href="http://kiya.space/2013/07/26/c%E8%AF%AD%E8%A8%80swap(a,b)%E5%80%BC%E4%BA%A4%E6%8D%A2%E7%9A%844%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E2%80%A6/" target="_blank" rel="external">http://kiya.space/2013/07/26/c%E8%AF%AD%E8%A8%80swap(a,b)%E5%80%BC%E4%BA%A4%E6%8D%A2%E7%9A%844%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E2%80%A6/</a><br><a href="http://www.itdadao.com/articles/c15a428576p0.html" target="_blank" rel="external">http://www.itdadao.com/articles/c15a428576p0.html</a><br><a href="http://www.cnblogs.com/kubixuesheng/p/4104800.html" target="_blank" rel="external">http://www.cnblogs.com/kubixuesheng/p/4104800.html</a><br><a href="https://www.byvoid.com/blog/c-int64" target="_blank" rel="external">https://www.byvoid.com/blog/c-int64</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;p align = &quot;center&quot;&gt; 在回顾C语言的时候,偶遇此题,因曾被其深虐,特意搜寻多种解决办法,以鞭笞岁月. &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS学习笔记一：Cocoapods的安装与使用</title>
    <link href="http://yoursite.com/2016/10/10/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9ACocoapods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/10/10/iOS学习笔记一：Cocoapods的安装与使用/</id>
    <published>2016-10-10T04:50:17.000Z</published>
    <updated>2016-10-25T14:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> Cocoapods是非常好用的第三方库管理工具. </p>

<a id="more"></a>
<h1 id="升级Gem"><a href="#升级Gem" class="headerlink" title="升级Gem"></a>升级Gem</h1><pre><code>sudo gem update --system
</code></pre><h1 id="切换Cocoapods的数据源"><a href="#切换Cocoapods的数据源" class="headerlink" title="切换Cocoapods的数据源"></a>切换Cocoapods的数据源</h1><pre><code># 1.删除
gem sources --remove https://rubygems.org/

# 2.添加淘宝数据源
gem sources -a https://ruby.taobao.org/

# 3.查看
gem sources -l
</code></pre><h1 id="安装Cocoapods"><a href="#安装Cocoapods" class="headerlink" title="安装Cocoapods"></a>安装Cocoapods</h1><pre><code>sudo gem install cocoapods
或者（如10.11系统）
sudo gem install -n /usr/local/bin cocoapods
</code></pre><h2 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h2><pre><code>Error installing pods:activesupport requires Ruby version &gt;= 2.2.2
</code></pre><p>解决方式:</p>
<h3 id="安装-RVM"><a href="#安装-RVM" class="headerlink" title="安装 RVM"></a>安装 RVM</h3><pre><code>curl -L get.rvm.io | bash -s stable  
</code></pre><p>等待。</p>
<pre><code>source ~/.bashrc  
source ~/.bash_profile  
</code></pre><p>测试是否安装成功。</p>
<pre><code>rvm -v  
</code></pre><h3 id="用RVM升级Ruby"><a href="#用RVM升级Ruby" class="headerlink" title="用RVM升级Ruby"></a>用RVM升级Ruby</h3><pre><code># 1.查看当前ruby版本  
ruby -v  
# 显示 ruby 1.8.7  

# 2.列出已知的ruby版本  
rvm list known  

# 3.安装ruby 2.3  
rvm install 2.3  
</code></pre><p>安装完成之后ruby -v查看是否安装成功。</p>
<h1 id="更换托管地址"><a href="#更换托管地址" class="headerlink" title="更换托管地址"></a>更换托管地址</h1><ul>
<li><p>将Podspec文件托管地址从github切换到国内的oschina或者coding。</p>
</li>
<li><p>注意:如果pod setup 可以将github的代码下载得动，那就不用去更换托管地址了。</p>
<pre><code># 1.先移除
pod repo remove master

# 2.再添加
pod repo add master https://git.coding.net/CocoaPods/Specs.git

# 3.再更新
pod repo update
</code></pre></li>
</ul>
<h1 id="设置pod仓库-初始化Cocoapods"><a href="#设置pod仓库-初始化Cocoapods" class="headerlink" title="设置pod仓库(初始化Cocoapods)"></a>设置pod仓库(初始化Cocoapods)</h1><pre><code>pod setup 
# 会将Specs.git的代码下载到~/.cocoapods/repo/master,自己前往查看是否有文件
# 如果还是太慢，尝试下
pod install --verbose
</code></pre><h2 id="报错解决-1"><a href="#报错解决-1" class="headerlink" title="报错解决"></a>报错解决</h2><pre><code>[!] To setup the master specs repo, please run `pod setup`.
</code></pre><p>手动下载代码解决:</p>
<pre><code># 1.手动克隆文件至该目录
git clone https://git.coding.net/CocoaPods/Specs.git ~/.cocoapods/repos/master

# 2.初始化,完成后显示Setup completed
pod setup  
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code># 如果有版本号，则说明已经pod安装成功
pod --version
# 如果~/.cocoapods/repo/master目录下有文件,说明文件下载成功
</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>利用Cocoapods来安装第三方框架</p>
<ol>
<li>进入要安装框架的项目的.xcodeproj同级文件夹</li>
<li>在该文件夹中新建一个文件podfile</li>
<li><p>在文件中告诉cocoapods需要安装的框架信息</p>
<p>a.该框架支持的平台<br>b.适用的iOS版本<br>c.框架的名称<br>d.框架的版本</p>
</li>
</ol>
<h2 id="Podfile文件格式"><a href="#Podfile文件格式" class="headerlink" title="Podfile文件格式"></a>Podfile文件格式</h2><pre><code>platform :ios, &apos;9.0&apos;
target &apos;你的项目名称&apos; do
pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;
end     
</code></pre><h2 id="创建Podfile文件"><a href="#创建Podfile文件" class="headerlink" title="创建Podfile文件"></a>创建Podfile文件</h2><p>进入.xcodeproj同级文件夹下</p>
<pre><code># 初始化:会生成模板的Podfile文件
pod init  

# 或者手动创建Podfile文件
touch Podfile
</code></pre><h2 id="添加自己需要的第三方库"><a href="#添加自己需要的第三方库" class="headerlink" title="添加自己需要的第三方库"></a>添加自己需要的第三方库</h2><pre><code>pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;

# If you are using Swift, be sure to add use_frameworks! and set your target to iOS 8+:
pod &apos;SDWebImage&apos;, &apos;~&gt;3.8&apos;
use_frameworks!

pod &apos;Masonry&apos;

pod &apos;MBProgressHUD&apos;, &apos;~&gt; 1.0.0&apos;

pod &apos;MJExtension&apos;

pod &apos;MJRefresh&apos;

pod &apos;SVProgressHUD&apos;
</code></pre><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><pre><code>pod install --verbose --no-repo-update
# 显示
# Pod installation complete! There is 1 dependency from the Podfile and 1 total pod installed.
</code></pre><h2 id="Start"><a href="#Start" class="headerlink" title="Start!"></a>Start!</h2><p>以后打开项目点击xcworksapce后缀的文件，不要点击原来的项目文件。<br>导入头文件应该使用:</p>
<pre><code>#import &lt;&lt;#header#&gt;&gt;
</code></pre><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>platform :ios, ‘9.0’ 用来设置所有第三方库所支持的iOS最低版本<br>pod ‘SDWebImage’,’~&gt;2.6’ 设置框架的名称和版本号</p>
<p>版本号的规则：<br>‘&gt;1.0’    可以安装任何高于1.0的版本<br>‘&gt;=1.0’   可以安装任何高于或等于1.0的版本<br>‘<1.0' 任何低于1.0的版本="" '<="1.0'" 任何低于或等于1.0的版本="" '~="">0.1’   任何高于或等于0.1的版本，但是不包含高于1.0的版本<br>‘~&gt;0’     任何版本，相当于不指定版本，默认采用最新版本号</1.0'></p>
<h1 id="pod-install过程"><a href="#pod-install过程" class="headerlink" title="pod install过程"></a>pod install过程</h1><ol>
<li>分析依赖:该步骤会分析Podfile,查看不同类库之间的依赖情况。如果有多个类库依赖于同一个类库，但是依赖于不同的版本，那么cocoaPods会自动设置一个兼容的版本。</li>
<li><p>下载依赖:根据分析依赖的结果，下载指定版本的类库到本地项目中。</p>
</li>
<li><p>生成Pods项目：创建一个Pods项目专门用来编译和管理第三方框架，CocoaPods会将所需的框架，库等内容添加到项目中，并且进行相应的配置。</p>
</li>
<li>整合Pods项目：将Pods和项目整合到一个工作空间中，并且设置文件链接。</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>Mac显示隐藏的文件</p>
<pre><code>defaults write com.apple.finder AppleShowAllFiles -boolean true ; 
killall Finder
</code></pre><p>Mac取消显示隐藏文件</p>
<pre><code>defaults write com.apple.finder AppleShowAllFiles -boolean false ; 
killall Finder
</code></pre><blockquote>
<p>参考并致谢:<br><a href="http://blog.csdn.net/lissdy/article/details/9191351" target="_blank" rel="external">http://blog.csdn.net/lissdy/article/details/9191351</a><br><a href="http://www.cnblogs.com/yan520/p/5583362.html" target="_blank" rel="external">http://www.cnblogs.com/yan520/p/5583362.html</a><br><a href="http://www.jianshu.com/p/32d9cfb91471" target="_blank" rel="external">http://www.jianshu.com/p/32d9cfb91471</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; Cocoapods是非常好用的第三方库管理工具. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="ios开发" scheme="http://yoursite.com/tags/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记四：分类与代理</title>
    <link href="http://yoursite.com/2016/07/16/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9A%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/07/16/Objective-C学习笔记四：分类/</id>
    <published>2016-07-16T09:50:17.000Z</published>
    <updated>2016-10-25T14:37:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.16更正部分错别字</p>
</blockquote>
<p></p><p align="center"> 一些琐碎的笔记,关于分类、代理和block. </p><br><a id="more"></a> <p></p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>场合：在不修改原来类模型的情况下，给类扩充一些方法，且仅是方法，不扩充成员变量。可以给系统自带的类添加分类，扩充方法。（注意引入分类文件）<br>当添加分类的方法是重写原来类中的方法时,不需要引入分类文件。<br>声明文件的命名方式 【类+分类.h】</p>
<pre><code>@interface 类名 (分类名)
@end
</code></pre><p>实现文件的命名方式 【类+分类.m】</p>
<pre><code>@implementation 类名 (分类名)
@end
</code></pre><p>特征：用括号括住添加的分类<br>好处：一个庞大的类可以分模块开发、由多个人编写，有利于团队合作。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>1，分类可以访问原来类中的成员变量，但不能增加成员变量。（若要增加成员变量，可以使用继承）</p>
<p>2，分类的优先级最高，当调用类中的一个方法时，优先去分类中查找，再去原类中查找，最后去父类中查找。也即，倘若在分类中重写了原类中的方法，会覆盖掉原来的方法，导致原来的方法无法使用。（不建议重写原来类中的方法）<br>重写会出现警告：Category is implementing a method which will also be implemented by its primary class.</p>
<p>3，如果多个分类中有相同（方法签名相同，但不一样）的方法，则调用的是最后编译的方法。</p>
<h2 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h2><ul>
<li>方式1，直接在.m文件中写方法实现，不要在.h文件中进行方法声明</li>
<li>方式2，在.m文件中定义一个category，然后在category中声明一些方法，最后在@implementation和@end之间作方法实现。</li>
</ul>
<h1 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h1><p>类也是一个对象，是Class类型的对象，简称类对象，类对象就是类。<br>class类型的定义:<code>typedef struct objc_class *Class;</code><br>类名代表着类对象，每个类只有一个类对象。</p>
<h2 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h2><p>在程序启动的时候，就会加载所有的类和分类，并调用一次所有类和分类的+load方法；</p>
<ul>
<li>先加载父类，再加载子类，也即先调用父类的+load方法，再调用子类的+load方法;</li>
<li>先加载原始类，再加载分类（顺序也即父类——父类的分类——子类）。</li>
<li>不管程序运行过程中有没有用到这个类，都会调用+load加载。</li>
</ul>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h2><p>在第一次使用某个类时（比如创建对象），就会调用一次+initialize方法<br>一个类只会调用一次+initialize方法，先调用父类的，再调用子类的<br>获取类对象的两种方式</p>
<pre><code>Class c = [Person class];//类方法
</code></pre><p>或者</p>
<pre><code>Person *p = [Person new];
Class c = [p class];//对象方法
</code></pre><p>很明显，[p class]和[Person class]方法返回的都是是class类型<br>类对象调用类方法：</p>
<pre><code>Class c=[Person class];
  Person *p2=[c new];
</code></pre><h2 id="description方法"><a href="#description方法" class="headerlink" title="description方法"></a>description方法</h2><p>类似其他语言的ToString方法，NSObject自带的方法。返回值类型是<code>NSString ＊</code><br>默认情况下，使用NSLog和%@打印一个对象，输出的是&lt;类名:内存地址&gt;<br>如：<code>&lt;Person: 0x1002070a0&gt;</code><br>而NSLog(@”%@”,p)会调用-description方法</p>
<h3 id="description方法-1"><a href="#description方法-1" class="headerlink" title="-description方法"></a>-description方法</h3><p>使用NSLog和%@输出某个对象时，会调用对象的-description方法</p>
<h3 id="description方法-2"><a href="#description方法-2" class="headerlink" title="+description方法"></a>+description方法</h3><p>使用NSLog和%@输出某个类对象时，会调用类对象的+description方法</p>
<p>可以重写+description和-description方法修改NSLog的默认输出<br>注意：如果在-description方法中使用NSLog打印self，会造成死循环。</p>
<pre><code>// 重写-description方法
-(NSString *)description
{
  return [NSString stringWithFormat:@”%@”, self];    
}
</code></pre><p>编译无警告，无报错，运行出错。<br>真正重写：<br>假设属性为</p>
<pre><code>// 重写-description方法
-(NSString *)description
{
  return [NSString stringWithFormat:@”姓名：%@ 年龄：%d”, _name,_age];
}
</code></pre><h1 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h1><p>每个类的方法列表都存储在类对象中,每个方法都有一个与之对应的SEL类型的对象<br>根据一个SEL对象就可以找到方法的地址，进而调用方法<br>SEL类型定义</p>
<pre><code>typedef struct objc_selector *SEL;
</code></pre><p>SEL对象的创建：</p>
<pre><code>SEL s=@selector(test);
SEL s2=NSSelectorFromString(@”test”);
</code></pre><p>将SEL对象转换为NSString对象</p>
<pre><code>NSString *s3=NSStringFromSelector(s);
</code></pre><p>调用对象p的show方法：</p>
<pre><code>// 创建p对象
Person *p=[[Person alloc] init];
// 将show方法封装为SEL类型数据的s
SEL s=@selector(show);
// 调用s间接调用show方法
  [p performSelector:s];
</code></pre><h2 id="p-test-原理解释"><a href="#p-test-原理解释" class="headerlink" title="[p test]原理解释"></a>[p test]原理解释</h2><ol>
<li>把test包装成SEL类型的数据</li>
<li>根据SEL数据找到对应的方法地址</li>
<li>根据方法地址调用相应的方法<br>消息就是SEL。</li>
</ol>
<h1 id="NSLog方法总结"><a href="#NSLog方法总结" class="headerlink" title="NSLog方法总结"></a>NSLog方法总结</h1><ol>
<li><p>打印对象的内存地址</p>
<pre><code>NSLog(@”%p”,p);
</code></pre></li>
<li><p>打印指针的内存地址（&amp;p取出地址）</p>
<pre><code>NSLog(@”%p”,&amp;p);
</code></pre></li>
<li><p>打印某一对象（默认返回类名+内存地址，可以通过重写-description方法改变输出内容）</p>
<pre><code>NSLog(@”%@”,p);
</code></pre></li>
<li><p>打印代码行号</p>
<pre><code>NSLog(@”%d”,__LINE__);
</code></pre></li>
<li><p>打印文件路径</p>
<pre><code>NSLog(@”%d”,__FILE__);
</code></pre><p>注意：如果文件路径中存在中文，则无法输出<br>这时可以使用：</p>
<pre><code>printf(“%s\n”__FILE__);输出包含中文字符的路径（\n只是为了观看清晰）
</code></pre></li>
<li><p>打印当前函数名称</p>
<pre><code>NSLog(@”%s”,__func__);
</code></pre><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1></li>
</ol>
<p>一系列方法的列表（不能增加成员变量）。其中声明的方法可以被任何类实现，这种模式一般称作代理（delegation）。<br>如果一些类之间没有继承的关系，但是有某些相同的行为，这时要考虑使用代理。<br>代理的定义：<br>当一代理只针对某个类中，代理最好放在一个类的.h文件中，使用时引入即可。（假定在Person.h文件中）</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface Person : NSObject
@end

// 要在@interface之外设置代理
@protocol MyProtocol &lt;NSObject&gt;
// 必须实现的方法
@required
-(void)show;
-(void)myShow;
// 可选实现的方法
@optional
+(void)herShow;
@end
</code></pre><p>在Dog.h文件中遵守协议：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
// 声明协议@protocol  MyProtocol;
@protocol  MyProtocol;

@interface Dog : NSObject&lt;MyProtocol&gt;
// 遵守某个协议
// 注意导入协议文件#import &quot;Person.h&quot;或者声明协议@protocol  MyProtocol;
-(void)show;
-(void)myShow;
@end
</code></pre><p>当某一代理用在多个类中，协议需要放在单独创建的.h文件中<br>此时创建的只有一个名为BigProtocol的.h文件。</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt; 
@protocol BigProtocol &lt;NSObject&gt;
@required
-(void)bigShow;
@optional
-(void)bigShow2;
@end
</code></pre><p>在Cat.h文件中遵守协议</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
//@protocol BigProtocol;
#import &quot;BigProtocol.h&quot;
 @interface Cat : NSObject&lt;BigProtocol&gt;
-(void)bigShow;
@end
</code></pre><p>在Dog.h文件中遵守协议</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
//@protocol BigProtocol;
#import &quot;BigProtocol.h&quot;
@interface _Dog : NSObject&lt;BigProtocol&gt;
-(void)bigShow;
-(void)bigShow2;
@end
</code></pre><h2 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li><p>在遵守协议时，如果使用@protocol BigProtocol;编译器会警告：无法找到协议的定义<br>而使用<code>#import “BigProtocol.h“</code>，则完全没有问题。</p>
</li>
<li><p>如果某个类遵守多个协议，协议之间用逗号分隔：</p>
<pre><code>@interface Cat : NSObject&lt;BigProtocol,MyProtocol&gt;
</code></pre></li>
<li><p>一个协议本身可以遵守其他协议，如遵守名字叫NSObject的协议（默认是这种情况，基协议NSObject）<br>如果A协议遵守B协议，这时A协议就能拥有B协议的所有方法声明。</p>
<pre><code>@protocol BigProtocol &lt;NSObject&gt;
@end
</code></pre></li>
</ol>
<p>BigProtocol拥有NSObject协议的所有方法声明。</p>
<ol>
<li><p>约定框架中后缀为Delegate的都是协议。（协议类似其他语言的接口，就像C#中默认以I开头的都是接口 ）</p>
</li>
<li><p>要求某个对象必须遵守某个协议（如要求obj保存的对象遵守协议MyProtocol，并且继承Person）</p>
<pre><code>Person&lt;MyProtocol&gt; *obj=[[Person alloc] init];
</code></pre></li>
<li><p>利用conformsToProtocol:判断某个类是否实现了某个协议</p>
<pre><code>Cat *c=[[Cat alloc] init ];
bool result=  [c conformsToProtocol:@protocol(BigProtocol)];
NSLog(@&quot;%@&quot;,result?@&quot;YES&quot;:@&quot;NO&quot;);
[c conformsToProtocol:@protocol(BigProtocol)];返回的是bool类型。
</code></pre></li>
</ol>
<h1 id="block"><a href="#block" class="headerlink" title="block"></a>block</h1><p>块。<br>有返回值（void也可以）、有形参。block封装了一段代码，可以在任何时候执行。block可以作为函数参数或者函数返回值，而其本身又可以带输入参数和返回值。<br>在多线程，异步任务，集合遍历，集合排序，动画专场使用较多。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>返回值类型  (^+block名称)(参数类型列表)=^(参数列表){   代码内容  };
</code></pre><ol>
<li><p>注意大括号后面有分号</p>
</li>
<li><p>对比函数</p>
<pre><code>int (^MySum)(int ,int )=^(int a,int b){ return a+b;};
int     MySum (int a,int b){return a+b;}
</code></pre></li>
<li><p>block可以访问局部变量，但不能更改局部变量。<br>如果更改则报错：Variable is not assignable (missing__block type specifier)，如：</p>
<pre><code>int c=10;
// Block的定义
int (^MySum)(int ,int )=^(int a,int b)
{
  c=21;
  return a+b+c;
};
NSLog(@&quot;%i&quot;,MySum(10,20));
</code></pre></li>
</ol>
<p>如果硬是要修改：在局部变量前面加上<code>__block</code> ，如   <code>__block int c=21;</code>这时，便可以在block中修改局部变量了。</p>
<pre><code>__block  int c=10;
        // Block的定义
        int (^MySum)(int ,int )=^(int a,int b)
        {
             c=21;
            return a+b+c;
        };
        NSLog(@&quot;%i&quot;,MySum(10,20));
</code></pre><p>4 . block的调用，和函数一样，使用名称即可：<code>MySum(_形参列表);</code></p>
<p>5 . 如果block没有形参，则可以省略等号后面的()<br>如：  </p>
<pre><code>int (^SomeSum)()=^{return 25;};
</code></pre><p>但是等号前面的两对括号不可省略。</p>
<p>6 . 利用typedef声明类型</p>
<pre><code>格式：typedef  返回值类型 (^block块名称)(参数_类型列表)
例如：typedef int (^MyBlock)(int,int);

以后就可以用MyBlock这种类型定义Block变量
  MyBlock m=^(int a,int b){return a+b;};
        int c=m(15,25);
        NSLog(@”%i”,c);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.16更正部分错别字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;p align = &quot;center&quot;&gt; 一些琐碎的笔记,关于分类、代理和block. &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记三：点语法与自动属性</title>
    <link href="http://yoursite.com/2016/05/18/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E7%82%B9%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/05/18/Objective-C学习笔记三：点语法与自动属性/</id>
    <published>2016-05-17T21:00:07.000Z</published>
    <updated>2016-10-25T14:09:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.16更正部分错别字<br>2016.05.24更正@private相关错误</p>
</blockquote>
<p align="center"> 点语法和自动属性的一些笔记. </p>



<a id="more"></a> 
<h3 id="点语法"><a href="#点语法" class="headerlink" title="点语法"></a>点语法</h3><p>本质是方法调用，不访问成员变量。前提是已经存在get和set方法(否则报错：Property ‘age’ not found on object of type ‘Person *’)。</p>
<pre><code>[p setAge:50];
int result=[p age];
NSLog(@”result的结果是：%i”,result);
</code></pre><p>相当于：</p>
<pre><code>p.age=50;
int result=p.age;
NSLog(@”result的结果是：%i”,result);
</code></pre><p>注意：此处的result未必等于50，因为在set方法中，age的值可能改变。</p>
<h4 id="方法的展开原理："><a href="#方法的展开原理：" class="headerlink" title="方法的展开原理："></a>方法的展开原理：</h4><p>[p        setAge   :      50];</p>
<p>对应</p>
<p>p     .     age=        50;</p>
<p>而<br>int result=[p       age];</p>
<p>对应<br>int result=p       .       age;</p>
<h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>1，set方法中</p>
<pre><code>-(void)setAge:(int)a
{
    self.age=a;
}
</code></pre><p>实际上是在set方法中调用set方法。</p>
<pre><code>-(int)age
{
    return self.age;
}
</code></pre><p>在get方法中调用get方法。<br>以上编译链接均无警告、无错误，但是运行会报错。</p>
<h3 id="成员变量的作用域"><a href="#成员变量的作用域" class="headerlink" title="成员变量的作用域"></a>成员变量的作用域</h3><h4 id="private"><a href="#private" class="headerlink" title="@private"></a>@private</h4><p>私有。<br>只能在当前类的对象方法中直接访问（当前类的对象方法的@implementation中访问），子类虽然继承（内存中存在），但无权限访问（感觉貌似没有继承，一层网给过滤掉。</p>
<h4 id="protected"><a href="#protected" class="headerlink" title="@protected"></a>@protected</h4><p>保护（默认是保护，不是私有）。<br>可以在当前类和子类的对象方法中直接访问（当前类和子类的@implementation中访问）。<br>假设父类Person有保护的成员变量_number，子类继承，什么变量都不增加，那么子类对象方法中访问的是父类的_number。</p>
<pre><code>-(void)show
{
    self-&gt;_number=1000;
    int result=self-&gt;_number;
    _number=5000;
    int result2= _number;
    NSLog(@”self-&gt;_number的值是：%i”,result);
    NSLog(@”_number的值是：%i”,result2);
}
</code></pre><h4 id="public"><a href="#public" class="headerlink" title="@public"></a>@public</h4><p>公开。任何地方都可以访问。一般用不到。</p>
<h4 id="package"><a href="#package" class="headerlink" title="@package"></a>@package</h4><p>同一个框架内可以访问，介于@public和@private之间。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>1,在类方法中不可能访问成员变量。<br>2,也可以在@implementation中声明成员变量。</p>
<pre><code>@implementation Student:NSObject
{
    @public int age;
    @private int number;
    @protected int no;
}
@end
</code></pre><p>然而.m文件一般不会被包含，也即一般没有必要访问，故而一般不把成员变量放在实现文件中。</p>
<h4 id="property和-synthesize属性合成"><a href="#property和-synthesize属性合成" class="headerlink" title="@property和@synthesize属性合成"></a>@property和@synthesize属性合成</h4><p>@property用在@interface中，代替get和set方法<br>如：<code>@property int age;</code><br>等价于</p>
<pre><code>-(int)age;
-(void)setAge:(int)age;
</code></pre><p>即便是<code>@property int _age;</code>那也会生成</p>
<pre><code>-(int)_age;
-(void)setAge:(int)_age;
</code></pre><p>而@synthesize用在@implementation实现中：@synthesize  age=成员变量名; 不允许对成员变量进行条件过滤，如@synthesize age=_age+100;</p>
<p><code>@synthesize age=_age;</code></p>
<p>等价于</p>
<pre><code>-(int)age
{
    return _age;
}
-(void)setAge:(int)age
{
    _age=age;
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> 1，如果.h文件中没有这个_age成员变量。那么，利用@property可以自动生成私有@private的_age。而默认的_age却是@protected的。<br> 2，@synthesize age将会访问age这个成员变量而非_age。<br> 3，若手动实现getter方法，编译器只会自动生成setter方法；若手动实现setter方法，编译器只会自动生成getter方法。</p>
<h5 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h5><p>@property已经独揽@synthesize的实现了，也即</p>
<p><code>@synthesize age=_age;</code>可以省略。只用写<code>@property int  age</code>就好了。（当然，前提是不对参数进行过滤，直接传到成员变量中，如果要过滤，还是要自己生成相应的方法。）</p>
<p> 4，默认情况下，getter和setter方法中的实现会访问下划线开头的成员变量。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>相当于<code>NSObject  *</code>  ，是万能指针。</p>
<h4 id="id类型的定义"><a href="#id类型的定义" class="headerlink" title="id类型的定义"></a>id类型的定义</h4><pre><code>typedef struct objc_object {
Class isa;
}*id;
</code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>用来初始化对象的方法，完整地创建一个可用对象。</p>
<p><code>Person *p=[Person alloc];</code><br>+alloc方法分配存储空间，返回对象。</p>
<p><code>p=[p init];</code><br>-init方法初始化</p>
<h4 id="init方法的重写"><a href="#init方法的重写" class="headerlink" title="init方法的重写"></a>init方法的重写</h4><p>目的：在对象创建完毕之后，使成员变量就有了一些默认的值。<br>注意：一定要先调用父类的构造方法，再进行子类内部成员变量的初始化<br>在@implementation中进行重写：</p>
<pre><code>-(id)init
{
    // 一定要先调用super的init方法，这是为了初始化父类的一些成员变量和其他属性
    self=[super init];
    // 判断对象是否初始化成功，如果对象初始化成功，再进行接下来的自定义初始化
    if(self!=nil)
    {
           _age=10086;
    }
    // 返回一个已经初始化完毕的对象
    return self;
}
</code></pre><p>上面代码不够简化，一般用下面代码。</p>
<pre><code>-(id)init
{
       // 简化版
    if([super init])
    {
        _age=10086;
    }
    return self;
}
</code></pre><h4 id="自定义构造方法"><a href="#自定义构造方法" class="headerlink" title="自定义构造方法"></a>自定义构造方法</h4><p>要求：是对象方法（对象的初始化），返回值是id类型，方法名以initWith开头。<br>注意：-init方法重写不需要在@interface中声明，因为已经声明过了，而自定义的构造方法需要在@interface中显式声明。</p>
<pre><code>// 声明
-(id)initWithAge:(int)age;




// 实现
-(id)initWithAge:(int)age
{
    if([super init])
    {
        _age=age+100;
    }
    return self;
}
</code></pre><p>调用示例：</p>
<pre><code>Person *p=[Person alloc];
p=[p init];
int r=p.age;
NSLog(@”r的值是%i”,r);

p= [p initWithAge:110];
int r2=p.age;
NSLog(@”r2的值是%i”,r2);
</code></pre><p>显而易见一个对象可以初始化多次。</p>
<p>含有多个参数的构造方法：<br><code>-(id)initWithAge:(int)age andNumber:(int)number;</code></p>
<h3 id="h文件和-m文件"><a href="#h文件和-m文件" class="headerlink" title=".h文件和.m文件"></a>.h文件和.m文件</h3><p>每个类分布在不同的文件中<br>类的声明放在.h文件中，类的实现放在.m文件中<br>若想使用某个类，就包含某个类的.h文件即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.16更正部分错别字&lt;br&gt;2016.05.24更正@private相关错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 点语法和自动属性的一些笔记. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记二：继承与属性</title>
    <link href="http://yoursite.com/2016/05/16/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/05/16/Objective-C学习笔记二：继承与属性/</id>
    <published>2016-05-16T11:22:17.000Z</published>
    <updated>2016-10-28T13:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.25 回顾</p>
</blockquote>
<p align="center"> 关于继承与属性的笔记. </p>

<a id="more"></a>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>优点：过滤不合理的值，屏蔽内部的赋值过程，让外界不必关注内部的细节。</p>
<p>成员变量的命名：以下划线开头。用于区分get方法名称和局部变量名称。尽量不设置为@public公有属性</p>
<pre><code>{
  int _speed;
}
</code></pre><p>set方法：设置成员变量，过滤一些不符合要求的值。以set开头，返回类型为void，后面跟上成员变量名，形参不与成员变量重名，形参类型与成员变量相同，成员变量的首字母大写。在set方法中设置行为，监听属性的改变。</p>
<pre><code>-(void)setSpeed:(int)s;

-(void)setSpeed:(int)s

{

_speed=s+20;

}
</code></pre><p> get方法：获取对象内部的成员变量，不接收参数，返回类型与成员变量类型相同，方法名称与成员变量名称相同（不含下划线）。不推荐以get开头。</p>
<pre><code>-(int)speed;

-(int)speed

{

return _speed;

}
</code></pre><p>只读：只提供get方法。可读可写：提供get和set方法。</p>
<h1 id="OC的弱语法"><a href="#OC的弱语法" class="headerlink" title="OC的弱语法"></a>OC的弱语法</h1><h2 id="调用未声明、未实现的对象方法"><a href="#调用未声明、未实现的对象方法" class="headerlink" title="调用未声明、未实现的对象方法"></a>调用未声明、未实现的对象方法</h2><p>编译 报错 <code>No visible @interface for ‘Dog’ declares the selector ‘ssss’</code>，链接运行 报错。</p>
<p><code>reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1002014a0’</code></p>
<p>给Dog对象发送不能识别的消息。</p>
<h2 id="调用已声明、未实现的对象方法"><a href="#调用已声明、未实现的对象方法" class="headerlink" title="调用已声明、未实现的对象方法"></a>调用已声明、未实现的对象方法</h2><p>编译警告：<code>Method definition for ‘ssss’ not found</code> 未实现方法 链接正常，运行报错</p>
<p><code>reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1001002a0’</code></p>
<h2 id="调用未声明、已实现的对象方法"><a href="#调用未声明、已实现的对象方法" class="headerlink" title="调用未声明、已实现的对象方法"></a>调用未声明、已实现的对象方法</h2><p>编译 链接运行 错误 <code>No visible @interface for ‘Dog’ declares the selector ‘ssss’</code></p>
<p>在Dog的@interface中，对于ssss的声明是不可见的。</p>
<h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><p>类本身在内存中占据存储空间，里面有类\对象方法列表。直接通过类名执行的方法。</p>
<p>以+开头，只能由类名调用，类方法中不能访问成员变量（实例变量）。允许类方法与对象方法重名。(执行者不同，当然可以重名！)</p>
<p>使用场合：当不需要访问成员变量的时候，尽量使用类方法，提升效率。</p>
<p>输出类的名称：</p>
<pre><code>+(void)showClassName;

+(void)showClassName

{

NSLog(@”类的名称是：%@”,NSStringFromClass([self class]));

}
</code></pre><p>调用：<code>[Dog showClassName];</code></p>
<h1 id="self关键字"><a href="#self关键字" class="headerlink" title="self关键字"></a>self关键字</h1><p>self是指针，指向当前对象或类的调用者。出现在对象方法中，代表当前对象，出现在类方法中，代表当前类。不能出现在函数中（会报错：<code>Use of undeclared identifier ‘self’</code>使用未声明的标识符）。</p>
<p>用途：</p>
<ol>
<li><p>self-&gt;成员变量名 在对象方法中访问当前方法调用的成员变量，也即当成员变量与局部变量同名时，用来区分同名的局部变量。</p>
<pre><code>-(void)showSelfOfObject;

-(void)showSelfOfObject

{

NSLog(@”showSelfOfObject方法被调用”);

int _speed;

self-&gt;_speed=200;

_speed+=1000;

int result= self-&gt;_speed+10;

NSLog(@”result的值是：%i”,result);

NSLog(@”_speed的值是：%i”,_speed);

}
</code></pre></li>
</ol>
<p>当成员变量与局部变量同名时（编译警告<code>Local declaration of ‘_speed’ hides the instance variable</code>局部变量隐藏了成员变量），采用就近原则，访问局部变量。因此需要用self访问成员变量。</p>
<ol>
<li>方法的调用:在对象方法中调用当前对象的对象方法以及在类方法中调用当前类的类方法</li>
</ol>
<p>在对象方法中调用当前对象的对象方法</p>
<pre><code>-(void)showSelfOfObject;

-(void)showTestObject;

-(void)showSelfOfObject

{

NSLog(@”showSelfOfObject方法被调用”);

}

-(void)showTestObject

{

[self showSelfOfObject];

}
</code></pre><p>在类方法中调用当前类的类方法</p>
<pre><code>+(void)showSelfOfClass;

+(void)showTestClass;

+(void)showSelfOfClass

{

NSLog(@”showSelfOfClass方法被调用”);

}

+(void)showTestClass

{

[self showSelfOfClass];

}
</code></pre><p>常见错误：</p>
<ol>
<li><p>在对象方法中调用类方法（编译错误<code>No visible @interface for ‘Dog’ declares the selector ‘showSelfOfClass‘</code>）错误相当于未声明未定义却调用这个方法。</p>
</li>
<li><p>在类方法中调用对象方法（编译错误<code>No known class method for selector ‘showSelfOfObject‘</code>）未知的类方法</p>
</li>
</ol>
<p>3，self的死循环:调用本身</p>
<pre><code>-(void)showSelfOfObject

{

NSLog(@”showSelfOfObject方法被调用”);

[self showSelfOfObject];

}
</code></pre><p>4，调用函数</p>
<p>函数不依赖对象。<code>void f(); [self f]</code> 错误</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>场景：当两个类拥有相同的属性和方法时，将相同的内容抽取到父类中。当A类完全拥有B类的部分属性或方法时，考虑A类作为父类。</p>
<ol>
<li><p>父类必须声明在子类前面。</p>
</li>
<li><p>不允许子类和父类拥有相同的成员变量（如果子类有和父类拥有相同的成员变量，意味着，同一成员变量声明定义两次，编译错误 <code>Duplicute member ‘_age’</code>，哪怕成员变量的访问属性不同，子类公开父类私有，或者父类公开子类私有，都不行！）</p>
</li>
<li><p>子类方法和属性的访问过程：如果子类没有，再访问父类。即由子类开始。</p>
</li>
<li><p>Objective-C中只有单继承（与C＋＋不同）</p>
</li>
</ol>
<p>方法的重写:父类和子类拥有相同签名的类方法或者对象方法（子类重新实现了父类中的方法），则优先调用子类的同名方法。</p>
<pre><code>父类Person：

-(void)show

{

NSLog(@”调用了Person的show方法”);

}

子类Student：

-(void)show

{

//[super show];

NSLog(@”调用了Student的show方法”);

}

调用：

Student *p=[[Student alloc] init]; [p show];
</code></pre><p>很明显，调用的是重写的子类Student的show方法。</p>
<h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><p>场景：子类重写父类的方法时，想调用父类的方法（包括类方法和对象方法）。</p>
<p>效果与self类似，super在对象方法中就调用父类的对象方法，在类方法中就调用父类的类方法。</p>
<p>继承可以在不改变原来模型的基础上拓充方法，抽取公共代码，建立类与类之间的联系，减少代码的冗余性，但是，会增加耦合性。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>某一种事物的多种形态。<br>在实现继承的前提下，父类类型指针指向子类对象（右边是左边），指向子类对象的父类指针可以调用子类中重写父类的方法，但是指向子类对象的父类指针不能调用子类中拓展的方法（父类中没有的方法）。</p>
<pre><code>Person *p=[[Student alloc] init];

[p show];
</code></pre><p>Student是Person，show方法在子类和父类中都有，这里调用的是子类的show方法。</p>
<p>当子类拓展了一个showStudent对象方法，如果还想调用，则强制转换：将指向子类对象的父类指针强制转化为子类指针。</p>
<pre><code>Person *p=[[Student alloc] init];

Student p2=(Student )p;

[p2 showStudent];
</code></pre><p>将父类指针p强制转换为子类指针，使它可以调用子类Student拓展的showStudent方法。</p>
<p>如果不做强制转换，而直接调用子类拓展的方法</p>
<pre><code>Person *p=[[Student alloc] init];

[p showStudent];
</code></pre><p>编译报错： <code>No visible @interface for ‘Person’ declares the selector ‘showStudent’</code></p>
<p>转换语法： { 相应子类名 p=(父类名 )指向子类对象的父类指针；}</p>
<p>主要应用：<strong>动态绑定</strong><br>如果参数使用父类类型，可以传入父类、子类对象，调用相应的方法（如将子类对象传递给参数，调用子类的方法；将父类对象传递给参数，则调用父类的方法）</p>
<p>例如，Person和Student中都有同名show对象方法，可以通过test函数传入的参数判断调用哪个方法。</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

#import “Person.h”

#import “Student.h”

void test(Person * p)

{

[p show];

}

int main(int argc, const char * argv[]) {

@autoreleasepool {

Person *p=[[Person alloc] init];

Student *s=[[Student alloc] init];

test(p);

test(s);

}

return 0;

}
</code></pre><h1 id="NSString的使用"><a href="#NSString的使用" class="headerlink" title="NSString的使用"></a>NSString的使用</h1><ol>
<li><p>创建字符串与输出字符串</p>
<pre><code>NSString *s=@”Sometimes”;

NSLog(@”%@”,s);
</code></pre></li>
<li><p>格式化字符串</p>
<pre><code>int age=85;

NSString *s=[NSString stringWithFormat:@”传入的年龄参数是%d”,age];

NSLog(@”%@”,s);
</code></pre></li>
<li><p>调用NSString类方法。<br>length返回字数（不是字符数）</p>
<pre><code>NSString *s=@”123 456”;

NSLog(@”%@”,s);

NSUInteger size=[s length];

NSLog(@”%lu”,(unsigned long)size);
</code></pre></li>
</ol>
<p>返回的是7，包括空格。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.25 回顾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 关于继承与属性的笔记. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
      <category term="ios开发" scheme="http://yoursite.com/tags/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记一：类</title>
    <link href="http://yoursite.com/2016/05/12/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/05/12/Objective-C学习笔记一：类/</id>
    <published>2016-05-11T21:00:49.000Z</published>
    <updated>2016-10-28T13:22:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.28 回顾</p>
</blockquote>
<p align="center"> 万物皆是对象. </p>

<a id="more"></a>
<h1 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h1><p>三要素：事物名称（类名）；属性；行为（功能）</p>
<p>具有相同（或者类似）属性和行为的对象可以抽象出一个类。</p>
<h1 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h1><p>类名<br>1，首字母大写；2，不能有下划线；3，多个英文单词，使用驼峰标识</p>
<p>行为<br>哪个对象最清楚行为怎么做，就把行为设计在哪个对象身上</p>
<pre><code>@interface Person : NSObject

{

@public

int _age;

bool _sex;

}

-(void)print;

@end
</code></pre><p>大括号内用来声明对象属性（成员变量也即实例变量）,@public让外界指针可以间接访问对象内部的成员变量。成员变量默认会初始化为0.</p>
<p><code>: NSObject</code>（继承基类）使声明的类具有创建对象的能力。</p>
<h1 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h1><pre><code>@implementation Person

-(void)print

{

NSLog(@”输出内容”);

}

@end
</code></pre><p>已经导入声明文件<code>#import “Person.h”</code><br>类的实现即方法的实现。</p>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><pre><code>Person *p=[[Person alloc] init];

[p print];
</code></pre><p>对象的本质是结构体，对象需要通过指针操纵。</p>
<p>类在内存中也占据存储空间，在创建对象之前为类分配一份内存空间，将类加载进内存。而且只存储方法列表，其中由类产生的对象，都有一个isa指针指向类。</p>
<p>方法调用：<code>[行为执行者   行为名称]</code>;</p>
<p><code>[Person new]</code>执行Person这个类的new行为创建对象，返回对象地址。</p>
<p><code>Person *p=[Person new];</code>定义一个Person 类型的指针变量p，指向Person类型的对象。指针的类型是Person *，指针指向的类型是Person。</p>
<p><code>[p print];</code>表示给p指向的对象发送一条print消息。</p>
<p><code>Person p=[Person new];</code>等价于 <code>Person p;p=[Person new];</code>另外<code>Person *p2=p;</code>表示p2、p指向同一个内容。<code>p=p2</code>:将p2存储的指针交给p，使p存储的也是p2存储的内容。</p>
<h1 id="方法与函数的区别以及注意"><a href="#方法与函数的区别以及注意" class="headerlink" title="方法与函数的区别以及注意"></a>方法与函数的区别以及注意</h1><ul>
<li><p>OC方法只能声明在@interface和@end之间，只能实现在@implementation和@end之间。也就是说OC方法不能独立于类存在</p>
</li>
<li><p>C函数不属于类，跟类没有联系，C函数只归定义函数的文件所有</p>
</li>
<li><p>C函数不能访问OC对象的成员</p>
</li>
<li><p>对象方法归类／对象所有，函数属于整个文件所有，任何地方都可以放置函数（如果放在@interface与@end之间，将会忽略掉函数，即未定义）</p>
</li>
<li><p>方法只有声明，没有实现（经典错误）</p>
</li>
<li>方法没有声明，只有实现（编译器警告，但是能调用，OC的弱语法）</li>
<li>编译的时候：访问没有的成员变量直接报错，访问没有的方法，只是警告</li>
<li>同一个类中不允许两个对象方法同名</li>
</ul>
<h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><p>属性访问 <code>[Car new]-&gt;speed = 200;</code></p>
<p>方法调用<code>[ [Car new] run];</code></p>
<h1 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h1><p>不带参数的对象方法：</p>
<p><code>-(void)print; 方法名print</code></p>
<p>带一个参数的对象方法：</p>
<p><code>-(void)print:(int) a; 方法名print :</code></p>
<p>带多个参数的对象方法：</p>
<p><code>-(void)print:(int) a WithOther:(int) b;</code>方法名</p>
<p><code>print : WithOther:</code></p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><pre><code>typedef enum｛

SexMan,

SexWoman

｝Sex;
</code></pre><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><pre><code>typedef struct{

int year;

int month;

int day;

} Date;
</code></pre><p>访问枚举：<code>s-&gt;sex=SexMan;</code></p>
<p>访问结构体：<code>s-&gt;birthday.year=2016;</code></p>
<p>定义结构体：</p>
<p><code>Date d={2016,4,30};</code></p>
<p>访问结构体：</p>
<pre><code>s-&gt;birthday.year=2016;

s-&gt;birthday.month=4;

s-&gt;birthday.day=16;
</code></pre><p>等价于：</p>
<pre><code>Date d={2016,4,16};

s-&gt;birthday=d;
</code></pre><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>打印函数中注意％与%的区别</li>
<li>定义枚举、结构体等必需放在@interface的前面方可使用</li>
<li>OC方法中一个参数一个冒号</li>
<li>对象中有对象</li>
</ul>
<pre><code>@interface Student : NSObject

{

@public

//狗

Dog *dog;

}

-(void)letDogRun

{

[dog run];

}


// main.m文件

Student *stu=[Student new];

Dog *dog=[Dog new];

stu-&gt;dog=dog;

[stu letDogRun];
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.28 回顾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 万物皆是对象. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>浅谈负债哲学</title>
    <link href="http://yoursite.com/2016/05/06/%E6%B5%85%E8%B0%88%E8%B4%9F%E5%80%BA%E5%93%B2%E5%AD%A6/"/>
    <id>http://yoursite.com/2016/05/06/浅谈负债哲学/</id>
    <published>2016-05-05T21:00:45.000Z</published>
    <updated>2016-10-25T14:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 哲学上的负债,关于人性. </p>


<a id="more"></a>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p><span style="color: #000000;">首先抛出一个问题，银行放贷最关心的是什么？<br>并不是还贷的能力，而是抽贷的时机。</span></p>
<p>即使资不抵债，银行照样敢放出贷款，如果您不能理解，那么请往下看：</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">“信用卡体系的根基并非持卡人的信用，而是银行的不守信用”，这是我最初接触到信用卡时的第一想法。说来奇怪，当我第一次接触到信用卡的时候，并没有任何信用卡，甚至没有申请信用卡的想法；那年我大三，或者说大四，总之暑假还没有开学。</span></p>
<p><span style="color: #000000;">本来，作为一名实习生只能担任一些非核心的岗位，但因为父亲的原因，免除了基础性的工作，直接进入了能够接触到信用逻辑的技术部门；那是我最初接触到银行的信贷逻辑，并使我后来决定远离银行体系的原因。银行只是一台冷血的机器，这里只有利益的竞逐和赤裸裸的博弈，银行与用户，银行与银行，而没有理解与帮助。<!-- more --> </span></p>
<table class="t_table" cellspacing="0"><br><tbody><br><tr><br><td><br><br><span style="color: #000000;">银行客户分类服务标准：</span><br><br><span style="font-size: small; color: #000000;">贵宾客户：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供周到满意的全方位服务</span></span><br><br><span style="font-size: small; color: #000000;">高值客户：</span><br><div align="right"><span style="color: #000000;"><span style="font-size: xx-small;">提供周到满意的品质服务</span></span></div><br><span style="font-size: small; color: #000000;">金卡客户：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供客户满意的便捷服务</span></span><br><br><span style="color: #000000;"><span style="font-size: small;">基础客户</span><span style="font-size: xx-small;">：</span></span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供便捷舒适的基础业务</span></span><br><br><span style="font-size: small; color: #000000;">政策客户：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供政策要求的服务质量</span></span><br><br></td><br><td><br><br><span style="color: #000000;">银行关于不同类型投诉的处理方式：</span><br><br><span style="font-size: small; color: #000000;">重大过失投诉：</span><br><br><span style="font-size: xx-small; color: #000000;">指银监会可能亲审的投诉(比如身份冒用、账务冲正等)，由实权部门优先受理</span><br><br><span style="font-size: small; color: #000000;">终止合作投诉：</span><br><br><span style="font-size: xx-small; color: #000000;">指客户要求与银行互相拉黑，并按合同依法索赔的投诉，由实权部门直接受理</span><br><br><span style="color: #000000;"><span style="font-size: small;">贵宾客户</span><span style="font-size: small;">投诉：</span><span style="font-size: small;"><br></span></span><br><br><span style="font-size: xx-small; color: #000000;">指贵宾卡达标客户的各类(合理或无理的)投诉，由实权贵宾投诉部门特殊受理</span><br><br><span style="font-size: small; color: #000000;">一般类别投诉：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">指普通投诉(</span><span style="font-size: xx-small;">包括</span><span style="font-size: xx-small;">客户执意要求管理层受理的投诉)，</span><span style="font-size: xx-small;">转回</span><span style="font-size: xx-small;">直接管理部门</span><span style="font-size: xx-small;">自行处理</span></span><br><br><span style="color: #000000;"><span style="font-size: small;">反复多次</span><span style="font-size: small;">投诉：</span><span style="font-size: small;"><br></span></span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">指针对同一情节投诉3次及以上的客户，转由兼职大学生</span><span style="font-size: xx-small;">接听投</span><span style="font-size: xx-small;">诉(只许说套话)</span></span><br><br></td><br></tr><br><tr><br><td colspan="2"><br><div align="left"><span style="color: #000000;">垃圾客户：提供便捷的存取款业务<span style="font-size: xx-small;">(即:个人储蓄账户业务)</span>，并避免该客户影响其他储户的客户体验</span></div></td><br></tr><br></tbody><br></table><br><div align="left"><span style="color: #000000;"><span style="font-size: xx-small;">其中低保户、</span><span style="font-size: xx-small;">五保户</span><span style="font-size: xx-small;">等属于政策客户</span><span style="font-size: xx-small;">，</span>除政策客户外，行内资产在15K以下的属于垃圾客户，</span></div><br><span style="color: #000000;">除重大过错外，垃圾客户所有投诉均属于无效投诉，包括柜员态度和拒绝服务。简而言之，银行对这类客户的态度是<span style="font-family: 宋体;"><span style="font-size: xx-small;">：(</span></span><span style="font-size: xx-small;">淘汰低端客户是目的，不属于客户流失，特别是垃圾客户)</span></span><br><br><span style="color: #000000;"><span style="font-size: medium;">要么忍着，要么滚，爱存不存，这点存款的盈利还挣不回服务成本。</span>另一方面，</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">银监对于</span>非重大过失是转回银行<span style="font-size: xx-small;">(投诉转申诉)</span>自行处理的<span style="font-size: xx-small;">，</span><span style="font-size: xx-small;">银行并</span>不害怕<span style="font-size: xx-small;">垃圾</span><span style="font-size: xx-small;">客户</span>投诉到银监会</span><br><div id="code_dc1"><br><br>1.  <span style="color: #000000;">注：关于日均存款，银行一般有两种计算方式：账面日均(一般24:00结算)和公允日均(一般22:00结算)</span><br>2.  <span style="color: #000000;">账面日均：每日某时刻的行内资产/行内负债作为数据单位，计算平均数。</span><br>3.  <span style="color: #000000;">公允日均：每日某时刻及之前42小时内，行内资产最低值/行内负债最高值作为数据单位，计算平均数。</span><br>4.  <span style="color: #000000;">借记类业务一般采用前一种，贷记类业务一般采用后一种（但支行签字承担责任的业务可以采用前一种）</span><br></div><br><br># 二<br><br>银行的收益不是柜员的：即使大闹银行，那帮人也没什么损失，只要高柜玻璃不碎根本不算事故，撑死算个意外<br><br>无效投诉，一只三不：只道歉(不认错)，不处罚，不整改，不赔偿(所有不反馈处罚决定的投诉,都是无效投诉)<br><div align="right"><br><br>无法理解”一只三不”?体会一下这句话:”对不起,先生,我们已经打烊了.”道歉是因为造成了不便(包括自身没有任何过错)<br><br></div><br><br>一方面，引入更多债权方，可以稀释已发卡行的资金风险，而逾期记录会阻碍其他债权方的加入或追加额度；<br>另一方面，持卡人一而再的利用逾期宽容策略是银行更加不能容忍的，没有银行能容忍自己成为风险转嫁终端。<br><br>银行不会(因为不愿意)上报持卡人的短期逾期，除非持卡人预见到银行不会上报该笔逾期。<br><br>与逾期记录相对的另一个扣分项是信报查询记录：<br>其中比较常见的是信用卡审批、本人查询、贷款审批和贷后管理。<br>其中扣分最严重的依次是：<br><br><table class="t_table" cellspacing="0"><br><tbody><br><tr><br><td><span style="color: #000000;">1.不知名机构的贷款审批<span style="font-size: xx-small;">(尤其是没有贷款记录的)</span></span></td><br><td><span style="color: #000000;">3.未持卡机构的信用卡审批</span></td><br></tr><br><tr><br><td><span style="color: #000000;">2.非冷冻机构的贷后管理</span></td><br><td><span style="color: #000000;">4.个人明细版的本人查询</span></td><br></tr><br></tbody><br></table>

<p>四大行或者其他著名银行的贷款审批是不会扣分的，而已持卡行的信用卡审批记录也是根本无所谓的。<br>特别需要注意的是：（贷后管理是不需要持卡人主动申请的，而银行方面为了防止贷后管理被投诉，）<br>银行卡部对贷后管理统一口径(不影响系统评分)，但实际执行中贷后管理比(已持卡行)信用卡审批扣分更多</p>
<p><span style="color: #000000;">对于明知资不抵债的人，银行依旧敢于放款，并不是信任持卡人或者贷款人的还款能力，而是豪赌其他贷款方像自己一样认为持卡人还有榨取空间而不会抢先抽贷。银行对于自己的批卡或者放款有自信（或者说盲目自信的相信）自己不会成为击鼓传花的最后一棒；换言之，银行有自信在用户可用资金不足之前及时抽贷或者停卡，而把坏账留给其他债权人。越没有信用的银行越敢于放贷，同样也是这些银行更急于抽贷。</span></p>
<p><span style="color: #000000;">说到抽贷，就不得不提到催收。</span><br><span style="color: #000000;">首先，催收的威逼利诱是不需要害怕的，没有打工者会为了那点提成冒着自己违法的风险。</span><br><span style="color: #000000;">但是同样的，催收也不害怕你的强硬威胁，同样因为大部分人不敢把狠话付诸行动。</span><br><span style="color: #000000;">记住关于催收的三个基本：</span><br><span style="color: #000000;">1.催收的利诱不能信，即使如约先还部分款，后续仍会一如既往的强硬。</span><br><span style="color: #000000;">2.催收总是试图诱导你对他动用武力，因为你的打手被认定共同受益，可以追究欠款的连带赔偿。</span><br><span style="color: #000000;">3.有资格做某事的人数超过总人口的8%，以这种行为做威胁必定没用；除非你有足够的专业背景。</span><br><span style="color: #000000;">简而言之：</span><br><span style="color: #000000;">催收不过是不敢付诸行动的苍蝇，不过你对他的强硬同样没用<span style="font-size: xx-small;">，除非你是土豪、律师或者暴力犯罪在逃犯</span></span><br><span style="color: #000000;"><span style="font-size: xx-small;">以上是常见的外包催收，还有一种连催收人员都鲜有耳闻的催收队伍：污点催收。<br>这类催收一般是对付那些想为家人保住财产的逾期者(或者说是想一人做事一人当的汉子)；<br>一言以蔽之：</span>直系亲属(及配偶)无钱可出则采用外包催收，而直系亲属不愿倾其所有的采用污点催收。</span><br><span style="color: #000000;">污点催收人是银行招安的一部分逾期特别巨大且确实走投无路的铤而走险者，一般具备以下协议：</span></p>
<div class="blockcode" style="text-align: justify;"><br><div id="code_DYg"><br><br>1.  <span style="color: #000000;">协议禁止催收时使用违法手段，否则造成的一切后果及法律责任自负，与银行无关；</span><br>2.  <span style="color: #000000;">不能达到签约的催收指标则视为违约，银行将继续依法对信用卡诈骗报案追究刑事责任；</span><br>3.  <span style="color: #000000;">达到催收指标满XX年后，可以不再追究刑事及民事责任，并发放一定金额的奖励；</span><br>4.  <span style="color: #000000;">因催收冲突或暴力袭击原因导致死亡的，向其子女发放优厚的死亡赔偿金(不属于死者的遗产)</span><br></div><br></div>

<p><span style="color: #000000;">但是，实际执行中：由于逾期者的亲属不存在法律上的连带责任，</span></p>
<div style="text-align: justify;" align="right"><span style="color: #000000;">银行摊派给污点催收的一定是通过合法手段<span style="font-size: xx-small;">(含法律渠道)</span>不可能回收的债务。</span></div>

<p><span style="color: #000000;">此种关系模式下：银行把自己最大的威胁<span style="font-size: xx-small;">(包括暴力压力和舆论压力)</span>变成了自己最锋利的刀，</span></p>
<div style="text-align: justify;" align="right"><span style="color: #000000;">催收和被催收的关系是：除非被催收者的父母妻儿倾家荡产，否则污点催收人必定家破人亡。</span></div>

<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p><span style="color: #000000;">进场自由，愿赌服输，<u>希望回本的赌徒永远都是loser</u>。</span></p>
<p><span style="color: #000000;">  所谓进场自由，当被抢先抽贷或者资金断流，信用卡所谓催收不过是迫使持卡人把烂账转嫁到亲友或其他债权方，而非让你尽早赚回本金，不要说什么没有钱，银行之所以催收恰是因为你没有资金，银行试图引入更多的债权人使自己完成抽贷全身而退。</span></p>
<p><span style="color: #000000;">  所谓愿赌服输，如果短期内无法全身而退，银行唯一要做的就是甩掉黑锅，把自己塑造成受害者，而隐藏面具下的魔鬼；作为赌局的输家，银行并不是妄图回本的loser，根本不在乎收回本金（沉没成本的收益期望小于风险成本+机会成本），让持卡人背负欺骗银行的黑锅，这才是信用卡刑事庭的本质。</span></p>
<p><span style="color: #000000;">关于刑事，插入一句：</span><span style="color: #000000;">A.还款优先抵扣滞纳金，判定是否存在持续还款</span><span style="color: #000000;">B.还款优先抵扣本金后，判定刑事判决具体刑期</span><span style="color: #000000;"><span style="font-size: xx-small;">同一笔还款在AB两个阶段，优先偿还的优先级不同，A阶段在B阶段之前结算。</span></span></p>
<div class="blockcode"><br><div id="code_K1F"><br><br>1.  <span style="color: #000000;">以5%滞纳金+利息为例，如果每月还款不超过本金的5%视为没有还款。</span><br>2.  <span style="color: #000000;">如果每月偿还5%，那么20个月后停止偿还，也仅仅是民事问题。</span><br>3.  <span style="color: #000000;">举例：欠款10万，</span><br>4.  <span style="color: #000000;">第2~5个月还款5000.01，第6~15个月偿还3K，则有且仅有第6~15个月视为没有还款。</span><br>5.  <span style="color: #000000;">量刑金额：49,999.96 (即100K-5000.01<em>4-3K</em>10)，利息及滞纳金部分不作为量刑标准。                                                    </span><br>6.  <span style="color: #000000;">数额较大：数额在5000元以上不满5万元的；</span><br>7.  <span style="color: #000000;">数额巨大：数额在5万元以上不满50万元的。</span><br></div><br></div>

<p><span style="color: #000000;">上述数据可以看出逾期还款的基准点是：两年结清本金，利息、罚金不免。</span></p>
<p>由此引出了逾期协商的本质：<strong>双方退而求其次</strong>。<br><span style="color: #000000;">所谓谈判的过错不过是时间（容忍期）与空间（资金关系）的利益交换。</span><br><span style="color: #000000;">银行拒绝与持卡人协商的原因仅仅是由于持卡人没有任何谈判的诚意。</span></p>
<p><span style="color: #000000;">谈判（或者说协商）的本质无非是：时间换空间，或者空间换时间；</span><br><span style="color: #000000;">逾期者的协商如果基于时空双降，这注定是失败的，除非你爸是李刚。</span></p>
<p><span style="color: #000000;">空间换时间（典型案例）：持卡人通过另有约定同意<span style="font-size: xx-small;">(刑期意义上)</span>还款优先冲抵滞纳金；</span><br><span style="color: #000000;">银行接受较长的约定还款期限并降低最低还款标准，但不降低滞纳金收取标准。</span><br><span style="color: #000000;">时间换空间（典型案例）：持卡人于15个工作日内从其他债权方<span style="font-size: xx-small;">(特别是直系亲属)</span>借到本金；</span><br><span style="color: #000000;">银行确认本金偿清后，免除全部利息与滞纳金，并永久拒绝持卡人的信贷业务。</span></p>
<p><span style="color: #000000;">想要延长还款期，并减免利息的，洗洗睡吧：银行相对于默认规则没有降低任何风险。</span><br><span style="color: #000000;">至于自首，只要你的供述事实构不成犯罪，一定会被经侦赶出来，立不了案，哪来的自首？</span></p>
<p><span style="color: #000000;">注意：判刑后银行仍有对债务的民事权力，可以申请法院强制执行，也就是说：坐牢也得还。</span><br>但是，在某些极端情况下，银行一定会免除债务的，比如因负债压力过大而自杀(不含劝离/解救成功，含抢救成功):<br>因自杀导致的病危通知书，仅一张，或因其他原因而起，因而银行不承担责任，所以没卵用。<br>两张因自杀导致的(三甲医院出具的)病危通知书，免利息、滞纳金。<br>三张以上因自杀导致的(三甲医院出具的)病危通知书，连本金都免。<br>无论最后是否抢救成功，但上述病危通知书必须是持卡人本人、直系亲属或配偶。<br><span style="color: #000000;">不想像上述那样极端？成为特殊人群也可以享受减免且免于刑事，比如<span style="font-size: xx-small;">(政府部门确认的)</span>地震受灾户。</span></p>
<h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p><span style="color: #000000;">没有一家银行能承受挤兑，同样没有任何股票能承受抛售，但仍有很多人安然的持有着存款或股票；从这个意义上来说，银行与这些投资者其实并没有本质区别，盲目的信任其他投资者会继续持有，而成功者总是踩着失败者的尸体在攀登；如同股票一样，庄家与散户不会同时获益，所谓双赢无非是找第三方作为失败者，金融的本质是<strong>零和博弈</strong>：你、中介与银行总有一方是失败者，而这三者中绝对强势的银行注定不败。</span></p>
<p><span style="color: #000000;">说到第三方，普及一个反常识的常识：</span></p>
<div style="text-align: justify;" align="right"><strong><span style="color: #000000;">除非你套的行为一定（must）会被银行发现，否则这个行为总是（always）会导致降额或封卡</span></strong></div>

<p>之所以原谅你说谎，是因为自始就看透了你的谎言；<br>如果被你成功欺骗了，会害怕你欺骗的能力，所以不会原谅你。<br>局外人认为：只有银行发现不了的路子，才能活的长久；这样的路子不会被银行发现是在套。<br>事实的真相是：银行把所有经此消费均认定为套的路子，才能活的长久；因为他是永远的说谎者。<br>被记录在案的“永远说谎者”在某种意义上就是诚实者，当然银行不会承认有一份永久说谎者名单。<br>无论跳码还是套码，银行永远不是吃亏者，只有交足了保护费的说谎者（商户）才有开绿灯的资格。<br>这条食物链里银行拿的是大头，才能保持长期稳定的平衡，虽然银行装受害者，让第三方支付机构背黑锅。</p>
<p>如果你套的行为成功骗过银行电脑系统，那么银行会害怕你的反监控能力，于是就不和你玩了。<br>换句话说，如果你骗过了银行电脑系统，那么一旦被发现，100%被降额封卡，零宽容，零容忍</p>
<p>能长期稳定的路子没有能骗过银行电脑系统的评估和风控的，<br>或者说是已经和银行报备过自己被用来套的路子才能长期存活。<br>当然，丰富账单也是必要的，主要是给银监看的，只要别太过分，银监也装傻；不过，丰富账单对系统评分没卵用</p>
<p>关于代还的认定，这里一般采用池缓冲的概念（最低标准一天两夜，即一晚上加一白天再加一晚上）：<br>任意一笔金额入账时刻止，之前的48/72小时内的总消费入账和总还款入账是银行判定代还的标准：<br>该笔入账及之前48小时内，总消费入账超过额度的70%且总还款入账超过额度的70%则视为代还；<br>该笔入账及之前72小时内，总消费入账超过额度的90%且总还款入账超过额度的90%则视为代还。<br>单笔消费金额/还款金额不作为代还判定要件，相邻两笔消费/还款间的时间间隔不作为代还认定标准</p>
<h1 id="五"><a href="#五" class="headerlink" title="五"></a>五</h1><p><span style="color: #000000;">那年，又到了事业编制的招考，一心想要脱离银行业的我毅然决然的决定备考。幸运地，我考上了，虽然面临着30万的违约金与保密赔偿款<span style="font-size: xx-small;">(已挣回并偿清)</span>，前景也不如在银行那样明朗。但是人没有梦想和咸鱼有什么区别，帮助银行助纣为虐并不是我的理想，从那一刻起，我决定利用银行间的博弈均衡彻底玩弄银行的授信体系，这也许当年的年少轻狂，虽然现在也并不怎么成熟。</span></p>
<p><span style="color: #000000;">不过，这并不是天朝国情决定的，而是资本的本质决定的。</span><br><span style="color: #000000;">即使是传说中刷卡能拒付的美国，拒付其实也没有那么容易成功。</span><br><span style="color: #000000;">在美国（以及大部分资本主义国家）</span><br><span style="color: #000000;">商户分为三类，可信商户、合作商户、普通商户。</span><br><span style="color: #000000;">用户分为三类，受邀用户、高值用户、普通用户。</span><br><span style="color: #000000;">当然，分类标准并不是商户的口碑，而仅仅是商户缴纳的年费，或者说保护费。</span></p>
<p><span style="color: #000000;">当用户等级高于或等于商户等级时，拒付轻松加愉快。</span><br><span style="color: #000000;"> 当用户等级低于          商户等级时，拒付永远失败。</span><br><span style="color: #000000;"> 例如只有受邀用户可以拒付可信商户，受邀用户指银行主动邀请才能办理的高端卡用户，比如运通黑、花旗主席卡</span></p>
<div align="center"><span style="color: #000000;">注意：美国拒付是商户承担资金损失（财货两空）；并不是银行负责赔付</span></div>

<p><span style="color: #000000;">附花旗信用卡协议：</span><br><span style="color: #000000;"> 您不得以未凭密交易、单据上无签名或无交易单据等为由否认交易或拒绝还款。</span></p>
<p><span style="color: #000000;">这里不能不说一下中国的盗刷立案制度，受害人报案制，也就是说：谁的过失谁负责，谁负责谁报案，</span></p>
<div align="center"><span style="color: #000000;">如果是银行的错必须由银行负责报案，如果持卡人泄露的信息则是持卡人进行报案。</span></div>

<p><span style="color: #000000;">如果被盗刷到派出所报案时，一口咬定不是亲友作案，自己也从没泄露过信息，那么肯定立不了案。</span><br><span style="color: #000000;"> 这并非派出所不作为，而是必须提供盗刷信息的泄露途径才能立案；否则，必须银行方面进行报案。</span><br><span style="color: #000000;"> 另一方面，</span><br><span style="color: #000000;"> 除非提供立案材料，否则银行要承担泄露支付信息的刑事风险，(相比于这个风险)钱根本不是问题。</span><br><span style="color: #000000;"> 所有表示银行承认存在可疑交易但拒绝赔付的所谓个人经历一定是软文，银行即使明知也根本不可能承认这一点：</span><br><span style="color: #000000;"> 负责受理盗刷投诉的客服人员只有耍官腔的权力，负责交流细节的只有法务部，律师知道有些真话不能说。</span><br><span style="color: #000000;"> 如果持卡人坚持自己没有泄露过支付信息，但无法提供银行泄露(故意或漏洞)持卡人支付信息的证据：</span><br><span style="color: #000000;"> 那么就会出现银行必须等待立案材料，而派出所表示必须银行方面报案的（伪）踢皮球，形成死锁。</span><br><span style="color: #000000;"> 国内银行赔付信用卡盗刷(名义上)是因为信用卡附赠的保险，但银行不会承认在盗刷事件中存在过错。</span></p>
<h1 id="六"><a href="#六" class="headerlink" title="六"></a>六</h1><p><span style="color: #000000;">说来讽刺，我第一家申请的是单位的工资行——中国银行，然而时至今日仍然没有能够攻略中行白金卡的方法，即使依赖于存款也无济于事，甚至不知道问题出在哪里，或许距离才能产生美。</span></p>
<p><span style="color: #000000;">我得到毕业证的两周后获得了人生中的第一张，不，准确地说是两张校友信用卡，15K的招行，以及半个月之后的建行，只有12K的金卡。</span></p>
<p><span style="color: #000000;">这是一个很讽刺的开局，只有不到3万的额度，却想要玩弄银行的授信体系，这与儿童的妄语其实并没有什么不同。当时，我一度放弃了轻狂的想法；但是讽刺的，成也萧何败也萧何，花旗竟然批复了一张高于当前总额度两倍的卡，即由此，我开始了信用卡的提额之路。</span></p>
<p><table class="t_table" cellspacing="0" bgcolor="#fcfcfc"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td><span style="color: #000000;">退款能否视为还款的通用规则：</span><br><span style="color: #000000;">   账单日之后的退款优先冲抵未出账单； </span><br><span style="color: #000000;">   冲抵未出后余款可用来冲抵已出账单。</span><br><span style="font-size: xx-small; color: #000000;"><br>余款（退款冲抵已出账单部分）：</span><br><span style="color: #000000;">   如果不小于上期账单，视为全额还款；<br>如果小于上期账单，不视为最低还款。</span><br><span style="font-size: xx-small; color: #000000;"><br>当余款小于上期账单时，以下二选一：</span><br><span style="color: #000000;">   ①另行存入达到最低还款额的现金金额</span><br><span style="color: #000000;">   ②补足余款和上期账单全额还款的差额</span></td></p>
<p><td><span style="color: #000000;"><span style="font-size: large;">当天消费入账时刻分节点：</span><span style="font-size: medium;"><br>招商银行：00:00<br>工商银行：06:00【以步步为赢到账为准】<br>中国银行：08:00【中行未持卡，未验证】<br>建设银行：17:00【银联单币：19:00】<br>花旗银行：21:00（浦发银行）【纽约8:00】<br>农业银行：22:00<br>邮储银行：24:00（上海银行）</span></span></td><br><br><br><br>也许是上天眷顾，恰逢建行的清华提额活动，凭借一张清华龙卡和事业单位的工牌从12K直接保送到了100K。而在建行提额的不久，花旗也随之提升了额度，到达了119K，而招商作为我的第一张卡并没有任何变化，此时已经过了2015年的春节，看着手里这三家银行的卡，我决定在将国有银行攻略之前，不再申请其他商业银行的卡，当然交通银行作为股份制重组的银行，并没有在我的日程表之中，取而代之的是出身邮局系统的邮政储蓄银行。</p>
<p>也许是首卡的情怀，或者是对额度的偏执，在申请中行期间，一直不忘关心招行的额度，在第8个多月的时候，招行终于分娩了，奇迹的从15K直接提到了43K，然而这依然是额度最低的一张卡。显然，如果一直保持着低位，必定拉低平均授信额度。最低单行额度反应了你对金融波动承受的幅度，越低的额度意味着你对越低的资金波动反应敏感，银行更关心你的最低单行(含正式销户不足一年)额度，其次才是最高单行(不含已销户)额度。说到信报，顺便提一句：个人明细版和银行打印版信报在信贷交易信息明细后紧接着是查询记录，但是：<br>银行数据版在这两个大类之间还有一个：信贷机构信息明细，这在个人版及银行打印版不体现。<br>包括进行过信用卡审批的所有银行/机构(包括未批卡机构)的列表以及相关数据，此大类下包含：<br>额度使用量峰值(概念类似单月股票最高点)和日均额度占用(概念类似借记卡日均存款)等按机构上报的数据；<br>以及未批卡机构的未批卡原因（一般是”其他原因”，但”进件不实”、”仿真流水”等会以代码形式高亮体现）；<br>以及已销户机构的销整户原因（一般是“个人原因”，但”信贷逾期”、”虚假交易”等会以代码形式高亮体现）。<br>显然，账单日前还款来降低负债(除了自我安慰之外)对银行并没有什么卵用。<br>不过，用来骗小贷公司还是绰绰有余的。</p>
<p>需要特别说明的一点是：即使消掉的账户也不会消失(包括额度)，但是：<br>银行只关心法人机构数，你的信报有多少个账户根本无所谓。</p>
<div class="blockcode"><br><div id="code_kJ4"><br><br>1.  比如建行北京分行发了一张双币卡，建行上海分行发了一张银联单币卡，招行发了一个双币卡。<br>2.  那么你的：<br>3.  账户数是5个。<br>4.  机构数是三个（建行北京分行、建行上海分行、招商银行）<br>5.  法人机构数是两个（建设银行、招商银行）<br></div><br></div>

<p><span style="color: #000000;">接触客户的柜员/客服是看不见具体的拒绝理由的，客服告知的拒批原因都是一本正经的胡说八道。</span><br><span style="color: #000000;">即使你是因为进件身份无法核实真实性，你的理财经理也会在查询之后告诉你是总授信额度过高。</span></p>
<p><span style="color: #000000;">明显的，招行拉低了最低单行的额度，这是有着明确目标的人所不能容忍的；即使现金分期毕业，仍然无法摆脱最低单行的命运；但作为第一张信用卡有一种情怀在里面，所以并没有销卡，而是决定直接申请白金卡；来到支行要了一张白金卡的申请表，也许长相过得去，前台客服并没有为难，轻松地填了银联白的申请表，甚至连信用卡都没有复印，说是查的到；过程很愉快，结局很扯淡，被拒绝了。</span></p>
<p><span style="color: #000000;">这时我才意识到小昭成为了额度的短板，既然柜台不行，那就邮寄；个人邮寄肯定不如柜台，于是另辟蹊径，走了公对公的挂号信邮寄，速度很缓慢，结局很愉快。银联白成功下卡，而且不是起步的6万，直接给了7万。更诡调的是，之后的某一天这张7万的卡被意外的刷空了，竟然还有额度外的现金分期，而这次分期之后的某个周六，恰逢招行大赦天下，又出现了一次分期，此时小昭在一个月之内，额度成为了最高的155K。</span></p>
<h1 id="七"><a href="#七" class="headerlink" title="七"></a>七</h1><p><span style="color: #000000;">关于羊毛或腿毛的性质，内在原理是发卡行对持卡人的定额补偿：</span><br><span style="font-size: medium; color: #000000;">薅羊毛的重点不在于撸没撸，而在于程度是否超过官方福利的阈值标准</span><br><span style="color: #000000;">以招商腿毛卡为例：</span><br>招商金卡正常封顶额度是5万，20元一积分。则50000/20=2500；<br>按每张腿毛卡5000取现计算，可得积分5000/20=250；<br>城市卡每张享有1.5倍积分，两张城市卡相对于3张腿毛卡；<br>因此相对于两张城市卡+7张卡，其中ATM最多取10K单笔，相对于两笔网络，即：<br>每月的标准操作是：两张城市卡+1次ATM取现+5次网络取现；<br><span style="color: #000000;">此时需要，2张城市卡+6张标准腿毛卡，恰为招行推荐的工作地+户籍地城市卡。</span><br><span style="color: #000000;">所以，不难看出：腿毛卡的每月定额补偿积分是以2500分为安全阈值的；</span><br><span style="color: #000000;">无论怎么撸，每月腿毛总收益不超过2500积分就是安全的官方福利；</span><br><span style="color: #000000;">而超过2500分/月就会带来各种各样的评分下降，月撸几十张城市卡的也就呵呵了。</span></p>
<p><span style="color: #000000;">招行达到最高额度之后，我彷徨了；是去申请工商还是先搞定中行？犹豫中，老农来单位推自己的尊然白金卡，只要持卡行在2~5行，单行额度不低于10万的在职职工都能保送尊然白，而且返还首年年费，恰好低空飞过标准线，蒙蒙的填了表，但意外的批了卡，这时我才知道这张没听说过的精粹白是什么卡种。</span></p>
<p><span style="color: #000000;">拿到精粹白的时候，信心嫉妒膨胀，传说中的邮储白成为了奋斗的目标，便无视了中行和工商。当时邮储还没有小白金，邮储白的逼格令我心驰神往，恰逢正式成为副主任科员，当然这在我们单位内算是比较常见的级别，也还属于小兵的范畴。</span></p>
<p><span style="color: #000000;">但是，年轻嘛，不试试怎么行？于是壮着胆子就去了，由于招商成功的经验，我自认为毫无问题，然而连申请表都没有拿到，就被赶了出来。这能忍？当然不能，于是尝试了各种网点，得到的结果都是一样的：白金信用卡没有申请表。</span></p>
<p><span style="color: #000000;">邮储碰壁后，就又开始了工商和中行的申请，恰逢大妈推广大来白金卡，于是工商的大来白成功填了表，当然只是试试看根本没报多大希望，毕竟工行连储蓄账户都没有，而中行那也屡战屡败。结果出乎意料，大来白金卡批了（初始额度不高，后来在和电话客服扯淡时，意外的发现能提额，这是后话）；而中国银行一如既往的坚定，申请失败。</span></p>
<p><span style="color: #000000;">这里说明一下刷卡与费率的问题：</span><br><span style="color: #000000;"><span style="font-size: medium;">如果某档费率的月消费金额不超过月总消费金额的5%，则该费率不计评分</span>。</span><br><span style="color: #000000;">以某月刷卡消费66K<span style="font-size: xx-small;">（注意：不是账单金额）</span>为例：</span><br><span style="color: #000000;">某费率下的总消费金额低于3.3K，则这些消费不会增加评分，更不会减分。</span><br><span style="color: #000000;">对于月消费6万多的持卡人，总额两三千的几笔消费，1.25与刷封顶的效果是完全一样的。</span><br><span style="color: #000000;">所以，不必对偶尔遇到的小额套码耿耿于怀，因为根本无所谓（即使是三农或者封顶）。</span><br><span style="color: #000000;">同样，对于月消费数万元的账户，用小额多笔高费率来美化账单其实也并没有什么卵用。</span></p>
<div class="blockcode"><br><div id="code_BAn"><br><br>1.  <span style="color: #000000;">注：66K和3.3K这两个数值很熟悉吧，提醒一下：</span><br>2.  <span style="color: #000000;">建行：45K<em>(1+50%)=67.5K（你懂得）</em></span><br>3.  <span style="color: #000000;">中行：50K(1+30%)=65K（搬砖办卡）</span><br>4.  <span style="color: #000000;">招行：60K+5K=65K（现金分期）</span><br>5.  <span style="color: #000000;">封顶：26/0.78%=3.333K</span><br></div><br></div><br><span style="color: #000000;">元旦左右，坐飞机回北京，想着15号线比机场线换乘走的路要少（13号线的步行距离你懂的），于是乘坐了空港3路，诡吊的是在天竺村附近车抛锚了，地图上看附近有家邮储支行就又去试了试，结果意外的凭工牌和精粹白填了一张表（虽然没要精粹白的复印件），更意外的是竟然批卡了，虽然是所有银行额度最低的一张卡，但总归里离集齐国有行更近了一步。</span><br><br><span style="color: #000000;">虽然，第一家申请的信用卡，到现在还没有攻略成功……</span><br><br># 八<br><br><span style="color: #000000;">最后，告诫诸位：</span><br><br><span style="color: #000000;">信用卡套出来锦上添花，会成为卡神；套出来用于苟延残喘，则更加卡奴。</span><br><br><span style="color: #000000;">当不用也过得去，就放心大胆的用，不用来生钱的钱不过是一堆废纸。</span><br><span style="color: #000000;">当不用就过不去，请千万别用，否则不过是饮鸩止渴。</span><br><br><span style="color: #000000;">卡神与卡奴的核心不在于奇技淫巧，而在于是否有额度外的存款使之活盘。</span><br><br><span style="color: #000000;">如果已经负资产，同样也有成为卡神的机会，但请确保手上的闲置存款不要低于总负债的20%。</span><br><span style="color: #000000;">看起来这样的闲置负债将加大利息成本，但请记住只有资金是活盘的总还有希望。</span><br><br><strong><span style="color: #000000;">当闲置存款低于负债的16.5%这条活盘警戒线超过7日，终会被债务拖垮，万劫不复。</span></strong><br><br><span style="color: #000000;">注：闲置存款不限于定活期：<br>余额宝、招行朝朝盈等能实时取现的都算闲置存款，但不包括各种封闭期禁止取款的理财产品。</span><br><br><span style="color: #000000;">建行看重代发收入<span style="font-size: xx-small;">(象征国家建设的贡献)           </span>中行看重行内存款<span style="font-size: xx-small;">(象征国库保障的需要)</span></span><br><br><span style="color: #000000;">工商看重理财贡献<span style="font-size: xx-small;">(象征以钱生钱的能力</span><span style="font-size: xx-small;">)           </span>农行看重单位性质<span style="font-size: xx-small;">(象征术业专攻的特性)</span></span><br><br><span style="font-size: large; color: #000000;">附录：销卡威胁处理流程</span><br><br><div class="blockcode"><br><br>1.  <span style="color: #000000;">销卡不销户？是，下一步；否，转第3步；</span><br>2.  <span style="color: #000000;">销卡成功，结束。</span><br>3.  <span style="color: #000000;">确认用户诉求并挽留？无需销户，下一步；销户，转第5步；</span><br>4.  <span style="color: #000000;">客户是否有其他诉求（如：提额、年费优惠）？是，下一步；否，转第2步；</span><br>5.  <span style="color: #000000;">不可逆确认？是，下一步；否，转第2步；</span><br>6.  <span style="color: #000000;">系统评测是否通过客户诉求？是，下一步；否，转第8步；</span><br>7.  <span style="color: #000000;">客户同意系统评测结果？是，调整后结束；否，下一步；</span><br>8.  <span style="color: #000000;">系统评测客户综合评分？高，下一步；一般或较低，转第10步；</span><br>9.  <span style="color: #000000;">客户是否反悔销户请求？是，结束；否，下一步；</span><br>10.  <span style="color: #000000;">销户成功，不可恢复，结束。</span><br></div>

<blockquote>
<p>原文刊自某信用卡论坛。某年某日拜读之后，收获巨大，特此转载。感谢作者。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 哲学上的负债,关于人性. &lt;/p&gt;
    
    </summary>
    
      <category term="金融理财" scheme="http://yoursite.com/categories/%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/"/>
    
    
      <category term="金融" scheme="http://yoursite.com/tags/%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记八：简单的RSS阅读器</title>
    <link href="http://yoursite.com/2016/05/04/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%85%AB%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84RSS%E9%98%85%E8%AF%BB%E5%99%A8/"/>
    <id>http://yoursite.com/2016/05/04/UWP开发笔记八：简单的RSS阅读器/</id>
    <published>2016-05-03T21:00:23.000Z</published>
    <updated>2016-10-28T13:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>一个简单的RSS阅读器. </p>

<a id="more"></a>
<p>一个简单的RSS阅读器，实现任意开启RSS网站内容订阅，不过，只能在阅读器中搜集到标题、日期。后期再补充。</p>
<p>这次起，把所有功能代码放在类中，MainPage不能再那么随便了。</p>
<p>新建RSSClass类：</p>
<pre><code>    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    // ItemsControl
    using Windows.UI.Xaml.Controls;
    // KeyRoutedEventArgs 
    using Windows.UI.Xaml.Input;
    // SyndicationClient 
    using Windows.Web.Syndication;

    namespace RSS阅读器
    {
      public   class RssClass
        {
            // 下载指定url的feed条目，逐一将其整合到集合控件ItemsControl中
            private async void Load(ItemsControl list,Uri url)
            {
                // 从URL异步检索源
                SyndicationClient client = new SyndicationClient();
                // 开始一个异步操作以下载从给定的URI的聚合feed。
                SyndicationFeed feed =await client.RetrieveFeedAsync(url);
                // 遍历feed中的所有item，将其添加到list中
                foreach (var item in feed.Items)
                {
                    list.Items.Add(item);
                }
            }

            // 
            public void Start(ref ItemsControl list,string url,KeyRoutedEventArgs args)
            {
                // 当按下回车键时
                if (args.Key== Windows.System.VirtualKey.Enter)
                {
                    try
                    {
                        Load(list, new Uri(url));
                    }
                    catch (Exception)
                    {

                        throw;
                    }
                    // 设置控件的焦点
                    list.Focus(Windows.UI.Xaml.FocusState.Keyboard);
                }
            }
        }
}
</code></pre><p>页面代码：</p>
<pre><code>&lt;Grid.RowDefinitions&gt;
           &lt;RowDefinition Height=&quot;Auto&quot;/&gt;
           &lt;RowDefinition Height=&quot;*&quot;/&gt;
       &lt;/Grid.RowDefinitions&gt;
       &lt;TextBox Name=&quot;URLTextBox&quot;
                Margin=&quot;10&quot;
                KeyDown=&quot;URLTextBox_KeyDown&quot;
                PlaceholderText=&quot;请输入RSS地址&quot;/&gt;
       &lt;ScrollViewer VerticalScrollBarVisibility=&quot;Auto&quot;
                     HorizontalScrollBarVisibility=&quot;Auto&quot;
                     Margin=&quot;20&quot;
                     Grid.Row=&quot;1&quot;&gt;

           &lt;ItemsControl Name=&quot;ListItemsControl&quot;&gt;
                   &lt;ItemsControl.ItemTemplate&gt;
                       &lt;!--数据模板--&gt;
                       &lt;DataTemplate&gt;
                       &lt;StackPanel&gt;
                           &lt;!--超链接--&gt;
                           &lt;HyperlinkButton NavigateUri=&quot;{Binding Path=Links[0].Uri}&quot;&gt;
                               &lt;!--超链接标题--&gt;
                               &lt;HyperlinkButton.Content&gt;
                                   &lt;TextBlock Text=&quot;{Binding Path=Title.Text}&quot;/&gt;
                               &lt;/HyperlinkButton.Content&gt;
                           &lt;/HyperlinkButton&gt;

                           &lt;!--文章日期--&gt;
                           &lt;TextBlock Text=&quot;{Binding Path=PublishedDate}&quot;/&gt;
                       &lt;/StackPanel&gt;
                       &lt;/DataTemplate&gt;
                   &lt;/ItemsControl.ItemTemplate&gt;
               &lt;/ItemsControl&gt;

       &lt;/ScrollViewer&gt;
</code></pre><p>cs逻辑代码：</p>
<pre><code>private RssClass rss = new RssClass();
       private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
       {
           rss.Start(ref ListItemsControl, URLTextBox.Text, e);
       }
</code></pre><p>明显清晰许多。</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>ItemsControl的数据绑定：</p>
<pre><code>&lt;ItemsControl Name=&quot;ListItemsControl&quot;&gt;
            &lt;ItemsControl.ItemTemplate&gt;
                             &lt;DataTemplate&gt;

                              &lt;/DataTemplate&gt;
             &lt;/ItemsControl.ItemTemplate&gt;
&lt;/ItemsControl&gt;
</code></pre><p>ScrollViewer的两个属性：</p>
<pre><code>VerticalScrollBarVisibility=”Auto”
HorizontalScrollBarVisibility=”Auto”
</code></pre><p>绑定RSS内容：</p>
<p>链接：<br>        <code>&lt;HyperlinkButton NavigateUri=”{Binding Path=Links[0].Uri}”&gt;</code></p>
<p>链接标题：<code>&lt;TextBlock Text=”{Binding Path=Title.Text}”/&gt;</code></p>
<p>文章日期：<br>        <code>&lt;TextBlock Text=”{Binding Path=PublishedDate}”/&gt;</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;一个简单的RSS阅读器. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记七：WebView与简单浏览器</title>
    <link href="http://yoursite.com/2016/05/02/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%EF%BC%9AWebView%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://yoursite.com/2016/05/02/UWP开发笔记七：WebView与简单浏览器/</id>
    <published>2016-05-01T21:00:18.000Z</published>
    <updated>2016-10-28T13:33:09.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>利用webview控件可以简单制作一个浏览器. </p>

<a id="more"></a>
<p>利用webview控件可以简单制作一个浏览器，实现基本的前进、后退、刷新、停止等功能。不过需要注意的是，如果网页是在新窗口打开，那就承受不了了，将自动用系统默认浏览器打开。所以，前进、后退功能的前提是：打开的网页是在同一个窗口。</p>
<p>命令栏代码：</p>
<pre><code>&lt;Page.BottomAppBar&gt;
        &lt;AppBar IsOpen=”True”&gt;
            &lt;StackPanel Orientation=”Horizontal”&gt;
                &lt;AppBarButton Name=”BackAppBarButton”
                              Click=”BackAppBarButton_Click”
                              Label=”返回”
                              Icon=”Back”/&gt;
                &lt;AppBarButton Name=”ForwardAppBarButton”
                              Label=”前进”
                              Icon=”Forward”
                              Click=”ForwardAppBarButton_Click”/&gt;
                &lt;AppBarButton Name=”RefreshAppBarButton”
                              Label=”刷新”
                              Icon=”Refresh”
                              Click=”RefreshAppBarButton_Click”/&gt;
                &lt;AppBarButton Name=”StopAppBarButton”
                              Click=”StopAppBarButton_Click”
                              Label=”停止”
                              Icon=”Stop”/&gt;
            &lt;/StackPanel&gt;
        &lt;/AppBar&gt;
    &lt;/Page.BottomAppBar&gt;
</code></pre><p>页面：</p>
<pre><code>&lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height=”Auto”/&gt;
            &lt;RowDefinition Height=”*”/&gt;
        &lt;/Grid.RowDefinitions&gt;
        &lt;TextBox Name=”URLTextBox”
                 InputScope=”Url”
                 KeyDown=”URLTextBox_KeyDown”
                 Margin=”20”/&gt;
        &lt;WebView Name=”Web”
                 Grid.Row=”1”
                 NavigationCompleted=”Web_NavigationCompleted”/&gt;

&lt;/Grid&gt;
</code></pre><p>后台逻辑：</p>
<pre><code>     // 返回处理
            private void BackAppBarButton_Click(object sender, RoutedEventArgs e)
            {
                if (Web.CanGoBack)
                {
                    Web.GoBack();
                }
            }

    // 前进处理
    private void ForwardAppBarButton_Click(object sender, RoutedEventArgs e)
    {
        if (Web.CanGoForward)
        {
            Web.GoForward();
        }
    }

    // 刷新
    private void RefreshAppBarButton_Click(object sender, RoutedEventArgs e)
    {
        Web.Refresh();
    }

    // 停止
    private void StopAppBarButton_Click(object sender, RoutedEventArgs e)
    {
        Web.Stop();
    }

    // 按（回车）键处理
    private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
    {
        // 如果按下的键是回车键
        if (e.Key== Windows.System.VirtualKey.Enter)
        {
            // 导航到文本框中的地址
            Web.Navigate(new Uri(URLTextBox.Text));
        }

        // 处理焦点
        Web.Focus(FocusState.Keyboard);
    }

    // 导航完成事件处理
    private void Web_NavigationCompleted(WebView sender, WebViewNavigationCompletedEventArgs args)
    {
        // 导航是否成功
        if (args.IsSuccess)
        {
            // 参数传递到地址栏
            URLTextBox.Text = args.Uri.ToString();
    }

}&lt;/pre&gt;
</code></pre><p>可以看到效果(原谅我无耻地用了自己的博客）：</p>
<p>初始页面：<img src="http://images.chenyalun.cn/2016/04/23/001.png" alt=""></p>
<p>打开新链接：</p>
<p><img src="http://images.chenyalun.cn/2016/04/23/002.png" alt=""></p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>对键盘的按键（回车）键处理：</p>
<pre><code>private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
{
// 如果按下的键是回车键
if (e.Key== Windows.System.VirtualKey.Enter)
{
// 导航到文本框中的地址
Web.Navigate(new Uri(URLTextBox.Text));
}
}
</code></pre><p>对焦点的处理：<br><code>Web.Focus(FocusState.Keyboard);</code></p>
<p>还有就是，文本框（地址栏）输入的文本必须是URL，即 <a href="http://chenyalun.com/" target="_blank" rel="external">http://chenyalun.com/</a> 如果是chenyalun.com那就会报错了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;利用webview控件可以简单制作一个浏览器. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记六：幸运彩色小球</title>
    <link href="http://yoursite.com/2016/04/30/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9A%E5%B9%B8%E8%BF%90%E5%BD%A9%E8%89%B2%E5%B0%8F%E7%90%83/"/>
    <id>http://yoursite.com/2016/04/30/UWP开发笔记六：幸运彩色小球/</id>
    <published>2016-04-29T21:00:46.000Z</published>
    <updated>2016-10-28T13:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>幸运彩色小球游戏. </p>

<a id="more"></a>
<p>这个和随机数与筛子游戏有异曲同工之妙，通过随机函数产生一定范围大小的数字，根据数字大小设定不同的颜色，点击命令栏的新建按钮，面板清空，重新产生一轮数字。</p>
<p>命令栏：</p>
<pre><code>&lt;Page.BottomAppBar&gt;
        &lt;AppBar&gt;
            &lt;StackPanel Orientation=”Horizontal”&gt;
                &lt;AppBarButton Name=”NewAppBarButton”
                              Label=”新建”
                              Icon=”NewFolder”
                              Click=”NewAppBarButton_Click”/&gt;
            &lt;/StackPanel&gt;
        &lt;/AppBar&gt;
    &lt;/Page.BottomAppBar&gt;
</code></pre><p>页面代码：</p>
<pre><code>&lt;StackPanel HorizontalAlignment=”Center”
            VerticalAlignment=”Center”
            Name=”DisplayStackPanel”
                    Orientation=”Horizontal”/&gt;
</code></pre><p>当然，为了方便起见，创建一个ShowBall类：需要引入的命名空间有：</p>
<pre><code>//Thickness
using Windows.UI.Xaml;
//控件
using Windows.UI.Xaml.Controls;
//SolidColorBrush
using Windows.UI.Xaml.Media;
//球
using Windows.UI.Xaml.Shapes;
</code></pre><p>完整代码：</p>
<pre><code>    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    //color
    using Windows.UI;

    //Thickness
    using Windows.UI.Xaml;
    //控件
    using Windows.UI.Xaml.Controls;
    //SolidColorBrush
    using Windows.UI.Xaml.Media;
    //球
    using Windows.UI.Xaml.Shapes;

    namespace Lucky_Lotto
    {
    public class ShowBall
    {
    // 定义随机数(种子为日期和时间的计时周期）
    private Random random = new Random((int)DateTime.Now.Ticks);

        // 定义获取数字集合方法
        private List&amp;lt;int&amp;gt; GetNumbers()
        {
            int Number;
            // 定义Numbers集合
            List&amp;lt;int&amp;gt; Numbers = new List&amp;lt;int&amp;gt;();
            // 当Numbers集合中整数个数小于6时，自动增加
            while (Numbers.Count &amp;lt; 6)
            {
                // 随机获取1到50之间的整数赋予Number（Number可以取1，不可取50）
                Number = random.Next(1, 50);
                // 将产生的随机数添加到集合之中
                // 处理当集合中的整数与产生的随机数相同的情况
                if (!Numbers.Contains(Number)||Number&amp;lt;1)
                {
                    Numbers.Add(Number);
                }
                // 对集合中的数字进行有序整理（美观起见）
                Numbers.Sort();
            }

            return Numbers;

        }
        // 对StackPanel进行处理：创建小球，增添颜色等
        // 将每个小球分别放在Canva中s，6个Canvas放在一个StackPanel中
        public void PlayBall(ref StackPanel stackpanel)
        {
            // 清空原先讯在的元素
            stackpanel.Children.Clear();

            // 对数字集合遍历
            foreach(int number in GetNumbers())
            {
                // 定义Canvas
                Canvas canvas = new Canvas();
                canvas.Width = 48;
                canvas.Height = 48;
                canvas.Margin = new Thickness(2);

                // 定义球
                Ellipse ellipse = new Ellipse();
                ellipse.Width = canvas.Width;
                ellipse.Height = canvas.Height;
                // 设置小球边框颜色是黑色
                ellipse.Stroke = new SolidColorBrush(Colors.Black);

                // 根据数字的大小设置小球的填充颜色
                if (number &amp;gt;= 1 &amp;amp;&amp;amp; number &amp;lt;= 9)
                {
                    ellipse.Fill = new SolidColorBrush(Colors.White);
                }
                else if (number &amp;gt; 9 &amp;amp;&amp;amp; number &amp;lt;= 19)
                {
                    ellipse.Fill = new SolidColorBrush(Color.FromArgb(255, 112, 200, 236));
                }
                else if (number &amp;gt; 19 &amp;amp;&amp;amp; number &amp;lt;= 29)
                {
                    ellipse.Fill = new SolidColorBrush(Colors.Magenta);
                }
                else if (number &amp;gt; 29 &amp;amp;&amp;amp; number &amp;lt;= 39)
                {
                    ellipse.Fill = new SolidColorBrush(Color.FromArgb(255, 112, 255, 0));
                }
                else if (number &amp;gt; 39 &amp;amp;&amp;amp; number &amp;lt;= 49)
                {
                    ellipse.Fill = new SolidColorBrush(Colors.Yellow);
                }

                // 定义球中的文本（数字）
                TextBlock textBlock = new TextBlock();
                textBlock.Text = number.ToString();
                textBlock.FontSize = 16;
                textBlock.Foreground = new SolidColorBrush(Colors.Black);
                textBlock.Margin = new Thickness(16, 12, 16, 12);

                // 将文本（数字）、小球添加到canvas中，将canvas添加到stackpanel中
                // 一定先添加球，再添加文本，否则文本不会显示
                canvas.Children.Add(ellipse);
                canvas.Children.Add(textBlock);
                stackpanel.Children.Add(canvas);
        }
    }
}

}
</code></pre><p>这样主页面的后台代码就可以轻松的调用了：</p>
<pre><code> // 新建类的实例
        public  ShowBall showball = new ShowBall();
        private void NewAppBarButton_Click(object sender, RoutedEventArgs e)
        {

  showball.PlayBall(ref DisplayStackPanel);
}&lt;/pre&gt;
</code></pre><p>演示：</p>
<p><img src="http://images.chenyalun.cn/2016/04/22/001.png" alt=""><img src="http://images.chenyalun.cn/2016/04/22/002.png" alt=""></p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><pre><code>// 对数字集合遍历
foreach(int number in GetNumbers())  {}

// 设置小球边框颜色是黑色
ellipse.Stroke = new SolidColorBrush(Colors.Black);

//设置margin

textBlock.Margin = new Thickness(16, 12, 16, 12);

// 一定先添加球，再添加文本，否则文本不会显示
canvas.Children.Add(ellipse);
canvas.Children.Add(textBlock);
stackpanel.Children.Add(canvas);

// 清空原先存在的元素
stackpanel.Children.Clear();

// 对集合中的数字进行有序整理（美观起见）
Numbers.Sort();

// 定义随机数(种子为日期和时间的计时周期）
private Random random = new Random((int)DateTime.Now.Ticks);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;幸运彩色小球游戏. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记五：应用数据本地存储</title>
    <link href="http://yoursite.com/2016/04/28/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%9A%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2016/04/28/UWP开发笔记五：应用数据本地存储/</id>
    <published>2016-04-27T21:00:59.000Z</published>
    <updated>2016-10-28T13:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>应用数据存储. </p>

<a id="more"></a>
<p>应用数据存储有两种形式，一种存储在本地，另一种是漫游到云端。输入信息，保存在本地，点击显示按钮，重新显现刚刚输入的信息。</p>
<p>命令栏代码：</p>
<p><pre class="lang:default decode:true ">&lt;Page.BottomAppBar&gt;<br>        &lt;AppBar&gt;<br>            &lt;StackPanel Orientation=”Horizontal”&gt;<br>                &lt;AppBarButton Name=”NewAppBarButton”<br>                              Icon=”Page”<br>                              Label=”新建”<br>                              Click=”NewAppBarButton_Click”/&gt;<br>                &lt;AppBarButton Name=”LoadAppBarButton”<br>                              Icon=”Folder”<br>                              Label=”显示”<br>                              Click=”LoadAppBarButton_Click”/&gt;<br>                &lt;AppBarButton Name=”SaveAppBarButton”<br>                              Icon=”Save”<br>                              Label=”保存”<br>                              Click=”SaveAppBarButton_Click”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.BottomAppBar&gt;</pre><br>页面代码：</p>
<p><pre class="lang:default decode:true "> &lt;StackPanel&gt;<br>            &lt;TextBox Name=”Email”<br>                     PlaceholderText=”邮箱”<br>                     Margin=”20”<br>                     InputScope=”EmailSmtpAddress”/&gt;<br>            &lt;TextBox Name=”Web”<br>                     PlaceholderText=”网址”<br>                     Margin=”20”<br>                     InputScope=”Url”/&gt;<br>            &lt;TextBox Name=”Tel”<br>                     PlaceholderText=”手机号码”<br>                     Margin=”20”<br>                     InputScope=”TelephoneNumber”/&gt;<br>        &lt;/StackPanel&gt;</pre><br>后台逻辑：</p>
<p><pre class="lang:default decode:true ">  //  新建存储<br>        private void NewAppBarButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            Email.Text = string.Empty;<br>            Web.Text = string.Empty;<br>            Tel.Text = string.Empty;<br>        }</pre></p>
<pre><code>// 保存信息
private void SaveAppBarButton_Click(object sender, RoutedEventArgs e)
{
    Save(&quot;Email&quot;, Email.Text);
    Save(&quot;Web&quot;, Web.Text);
    Save(&quot;Tel&quot;, Tel.Text);
}

// 加载存储信息
private void LoadAppBarButton_Click(object sender, RoutedEventArgs e)
{
    Email.Text = Load(&quot;Email&quot;);
    Web.Text = Load(&quot;Web&quot;);
    Tel.Text = Load(&quot;Tel&quot;);
}

// 应用本地设置信息存储:保存 键 值
public void Save(string key,string value)
{
    ApplicationData.Current.LocalSettings.Values[key] = value;
}

// 加载应用本地设置存储的信息
public string Load(string key)
{
    if (ApplicationData.Current.LocalSettings.Values[key]!=null)
    {
        return ApplicationData.Current.LocalSettings.Values[key].ToString();
    }

    return string.Empty;
}&lt;/pre&gt;
</code></pre><p>输入信息并保存：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/005.png" alt=""></p>
<p>点击新建清空数据，点击显示：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/006.png" alt=""></p>
<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><ul>
<li>空字符串：string.Empty</li>
<li>保存的方式为键值对：key和value</li>
<li>本地设置类： ApplicationData.Current.LocalSettings.Values[key] = value;其中key一般是字符串，value是保存的值</li>
<li>需要引入命名空间：应用数据存储  using Windows.Storage;</li>
<li>删除存储 ApplicationData.Current.LocalSettings.Values.Remove(“key”); 其中key是键<br>&nbsp;</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;应用数据存储. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记四：随机数与筛子游戏</title>
    <link href="http://yoursite.com/2016/04/26/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E7%AD%9B%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <id>http://yoursite.com/2016/04/26/UWP开发笔记四：随机数与筛子游戏/</id>
    <published>2016-04-25T21:00:25.000Z</published>
    <updated>2016-10-28T13:41:18.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>随机数与筛子游戏<br>. </p>

<a id="more"></a>
<p>点击方块，方块随机出现类似筛子的点数，连续点击，连续出现随机的数。当然，是有两个方块的。点击底部命令栏的刷新按钮，两块“筛子”均恢复空白状态。</p>
<p>命令栏：</p>
<p><pre class="lang:default decode:true ">&lt;Page.BottomAppBar&gt;<br>        &lt;AppBar&gt;<br>            &lt;StackPanel Orientation=”Horizontal”&gt;<br>                    &lt;AppBarButton Name=”NewAppBarButton”<br>                                  Icon=”Page”<br>                                  Click=”NewAppBarButton_Click”<br>                                  Label=”刷新”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.BottomAppBar&gt;</pre><br>页面代码：</p>
<p><pre class="lang:default decode:true "> &lt;Grid.ColumnDefinitions&gt;<br>            &lt;ColumnDefinition Width=”<em>“/&gt;<br>            &lt;ColumnDefinition Width=”Auto”/&gt;<br>            &lt;ColumnDefinition Width=”</em>“/&gt;<br>            &lt;ColumnDefinition Width=”Auto”/&gt;<br>            &lt;ColumnDefinition Width=”*”/&gt;<br>        &lt;/Grid.ColumnDefinitions&gt;</pre></p>
<pre><code>    &amp;lt;Grid Name=&quot;FirstGrid&quot;
          Tapped=&quot;FirstGrid_Tapped&quot;
          Width=&quot;100&quot;
          Height=&quot;100&quot;
          Background=&quot;HotPink&quot;
          Grid.Column=&quot;1&quot;&amp;gt;
        &amp;lt;Grid.RowDefinitions&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;/Grid.RowDefinitions&amp;gt;
        &amp;lt;Grid.ColumnDefinitions&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;/Grid.ColumnDefinitions&amp;gt;
    &amp;lt;/Grid&amp;gt;

&amp;lt;Grid Name=&quot;SecondGrid&quot;
          Tapped=&quot;SecondGrid_Tapped&quot;
          Width=&quot;100&quot;
          Height=&quot;100&quot;
          Background=&quot;HotPink&quot;
          Grid.Column=&quot;3&quot;&amp;gt;
    &amp;lt;Grid.RowDefinitions&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
    &amp;lt;/Grid.RowDefinitions&amp;gt;
    &amp;lt;Grid.ColumnDefinitions&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
    &amp;lt;/Grid.ColumnDefinitions&amp;gt;

&amp;lt;/Grid&amp;gt;&lt;/pre&gt;
</code></pre><p>后台代码MainPage.xaml.cs：</p>
<p>引入命名空间：</p>
<p><pre class="lang:default decode:true ">//颜色<br>using Windows.UI;<br>//图形<br>using Windows.UI.Xaml.Shapes;</pre><br>逻辑代码：</p>
<p><pre class="lang:default decode:true"> private void NewAppBarButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            //刷新页面<br>            FirstGrid.Children.Clear();<br>            SecondGrid.Children.Clear();<br>        }</pre></p>
<pre><code>    private void FirstGrid_Tapped(object sender, TappedRoutedEventArgs e)
    {
        // 移除面板上所有元素
        FirstGrid.Children.Clear();
        switch (Number())
        {
            case 0:
            case 1:
                Add(FirstGrid, 1, 1);
                break;
            case 2:
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 0);
                break;
            case 3:
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 1, 1);
                Add(FirstGrid, 2, 0);
                break;
            case 4:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 0);
                Add(FirstGrid, 2, 2);
                break;
            case 5:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 2);
                Add(FirstGrid, 1, 1);
                Add(FirstGrid, 2, 0);
                break;
            case 6:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 1, 0);
                Add(FirstGrid, 1, 2);
                Add(FirstGrid, 2, 0);
                Add(FirstGrid, 2, 2);
                break;
        }
    }

// 设置随机数
    public int Number()
    {
        // 返回0到7之间的随机整数
        return new Random().Next(0, 7);
    }

    // 设置添加圆点
    public void Add(Grid grid, int row, int col)
    {

        Ellipse ell = new Ellipse();
        // 设置填充颜色
        ell.Fill = new SolidColorBrush(Colors.White);
        // 设置宽高度
        ell.Width = 20;
        ell.Height = 20;
        // 设置圆点的在表格上的位置
        ell.SetValue(Grid.RowProperty, row);
        ell.SetValue(Grid.ColumnProperty, col);
        // 获取面板元素（把ell元素添加到面板中）
        grid.Children.Add(ell);
    }

    private void SecondGrid_Tapped(object sender, TappedRoutedEventArgs e)
    {
        // 移除面板上所有元素
        SecondGrid.Children.Clear();
        switch (Number())
        {
            case 0:
            case 1:
                Add(SecondGrid, 1, 1);
                break;
            case 2:
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 0);
                break;
            case 3:
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 1, 1);
                Add(SecondGrid, 2, 0);
                break;
            case 4:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 0);
                Add(SecondGrid, 2, 2);
                break;
            case 5:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 2);
                Add(SecondGrid, 1, 1);
                Add(SecondGrid, 2, 0);
                break;
            case 6:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 1, 0);
                Add(SecondGrid, 1, 2);
                Add(SecondGrid,2, 0);
                Add(SecondGrid, 2, 2);
                break;
        }
    }&lt;/pre&gt;
</code></pre><p>点击出现筛子点数：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/001.png" alt=""></p>
<p>点击刷新按钮，清空所有元素：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/002.png" alt=""></p>
<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><ul>
<li><h3 id="随机数："><a href="#随机数：" class="headerlink" title="随机数："></a>随机数：</h3></li>
</ul>
<p>Random()与时间相关的种子；</p>
<p>Random(seed)指定种子；</p>
<p>Random().NextDouble返回大于或等于0.0且小于1.0的随机浮点数；</p>
<p>Random().Next()返回非负随机整数；</p>
<p>Random().Next(下限，上限)返回指定范围非负随机整数（可取下限，不可取上限）；</p>
<h3 id="设置图形依赖属性："><a href="#设置图形依赖属性：" class="headerlink" title="设置图形依赖属性："></a>设置图形依赖属性：</h3><p>Ellipse ell = new Ellipse();</p>
<p>// 设置填充颜色<br>ell.Fill = new SolidColorBrush(Colors.White);</p>
<p>// 设置圆点的在表格上的位置<br>ell.SetValue(Grid.RowProperty, row);<br>ell.SetValue(Grid.ColumnProperty, col);<br>// 获取面板元素（把ell元素添加到面板中）<br>grid.Children.Add(ell);</p>
<p>// 移除面板上所有元素<br>SecondGrid.Children.Clear();</p>
<p>总结：代码比较琐碎，而且不是很令人满意，xaml创建图形很方便，可是处理逻辑的时候没有思路，只好把图形创建的代码写在后台。本想写个方法同时处理两个方块，然而并没有成功〒_〒</p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;随机数与筛子游戏&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记三：动画编程之图形的翻转</title>
    <link href="http://yoursite.com/2016/04/24/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E5%8A%A8%E7%94%BB%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9B%BE%E5%BD%A2%E7%9A%84%E7%BF%BB%E8%BD%AC/"/>
    <id>http://yoursite.com/2016/04/24/UWP开发笔记三：动画编程之图形的翻转/</id>
    <published>2016-04-23T21:00:40.000Z</published>
    <updated>2016-10-28T13:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>动画编程小尝试<br>. </p>

<a id="more"></a>
<p>动画编程可以实现很酷的很炫的效果，能让开发出的App散发无穷无尽的魅力，在颜值至上的时代，好看是检验UI的唯一标准。图形的翻转主要有三种形式：RotationX，RotationY，RotationZ，就是获取或设置围绕旋转的 X 轴或Y轴或Z轴旋转对象的角度。</p>
<p>计划在文本框中键入图片的地址源，按回车载入图片，点击命令栏中按钮，图片做出相应变换。</p>
<p>XAML代码：</p>
<pre class="lang:default decode:true ">&lt;!--命令栏--&gt;
    &lt;Page.BottomAppBar&gt;
        &lt;AppBar IsSticky="True"&gt;
            &lt;StackPanel Orientation="Horizontal" HorizontalAlignment="Right"&gt;
            &lt;AppBarButton Name="XRotateAppBarButton"
                          Icon="RepeatAll"
                          Label="Pitch"
                          Click="XRotateAppBarButton_Click"/&gt;
            &lt;AppBarButton Name="YRotateAppButton"
                          Icon="Rotate"
                          Label="Roll"
                          Click="YRotateAppButton_Click"/&gt;
            &lt;AppBarButton Name="ZRotateAppBarButton"
                          Icon="Refresh"
                          Label="Yaw"
                          Click="ZRotateAppBarButton_Click"/&gt;
            &lt;/StackPanel&gt;

        &lt;/AppBar&gt;
    &lt;/Page.BottomAppBar&gt;

    &lt;!--动画--&gt;
    &lt;Page.Resources&gt;
        &lt;!--X方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardX"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationX)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;

        &lt;!--Y方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardY"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationY)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;

        &lt;!--Z方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardZ"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationZ)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;
    &lt;/Page.Resources&gt;

    &lt;Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height="Auto"/&gt;
            &lt;RowDefinition Height="Auto"/&gt;
            &lt;RowDefinition Height="*"/&gt;
        &lt;/Grid.RowDefinitions&gt;
        &lt;TextBlock Text="请输入图片的地址"
                   HorizontalAlignment="Center"
                   Height="30"/&gt;
        &lt;TextBox  Grid.Row="1"
                  Name="URLTextBox"
                   FontSize="20"
                   HorizontalAlignment="Stretch"
                   Height="40"
                   Margin="20"
                   InputScope="Url"
                   KeyDown="URLTextBox_KeyDown"/&gt;
        &lt;Image Grid.Row="2"
               Name="ResultImage"
               Margin="60"
               Stretch="Uniform"&gt;
            &lt;!--注意一定要声明-Projection属性--&gt;
            &lt;Image.Projection&gt;
                &lt;PlaneProjection /&gt;
            &lt;/Image.Projection&gt;
        &lt;/Image&gt;
    &lt;/Grid&gt;</pre>
原图：

![](http://images.chenyalun.cn/2016/04/20/101.png)

X轴翻转:

![](http://images.chenyalun.cn/2016/04/20/102.gif)

&nbsp;

Y轴翻转：![](http://images.chenyalun.cn/2016/04/20/103.gif)

以及Z轴翻转：![](http://images.chenyalun.cn/2016/04/20/104.gif)

CS 代码（主要是获取文本框中的URL，以及处理按钮事件）：
<pre class="lang:default decode:true "> // TextBox输入完毕按下回车后，得到图片来源
        private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
        {
            // 判断与事件关联的输入按钮是否为虚拟按键的Enter键
            if (e.Key==Windows.System.VirtualKey.Enter)
            {
                ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(new Uri(URLTextBox.Text));
            }
        }

        // 设置按下按钮后的翻转效果
        private   void XRotateAppBarButton_Click(object sender, RoutedEventArgs e)
        {
             StoryBoardX.Begin();
        }

        private void YRotateAppButton_Click(object sender, RoutedEventArgs e)
        {
            StoryBoardY.Begin();
        }

        private void ZRotateAppBarButton_Click(object sender, RoutedEventArgs e)
        {
            StoryBoardZ.Begin();
        }</pre>

<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><h3 id="1-处理文本框的回车事件中，"><a href="#1-处理文本框的回车事件中，" class="headerlink" title="1,处理文本框的回车事件中，"></a>1,处理文本框的回车事件中，</h3><p>文本框输入类型：InputScope=”Url”   键盘按键属性KeyDown=”URLTextBox_KeyDown”</p>
<p>获取文本框内容并转换为URL：</p>
<p>// 判断与事件关联的按键是否为虚拟按键的Enter键<br>if (e.Key==Windows.System.VirtualKey.Enter)<br>{<br>ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(new Uri(URLTextBox.Text));</p>
<p>等同于：</p>
<pre class="lang:default decode:true ">Uri url = new Uri(URLTextBox.Text);
ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(url);</pre>
}

当然，如果引入命名空间了，那就更好了  using Windows.UI.Xaml.Media.Imaging;
<pre class="lang:default decode:true ">Uri url = new Uri(URLTextBox.Text);
ResultImage.Source = new BitmapImage(url);</pre>

<h3 id="2，关于动画"><a href="#2，关于动画" class="headerlink" title="2，关于动画"></a>2，关于动画</h3><p>首先目标图片要声明Projection属性，即添加：</p>
<pre class="lang:default decode:true ">&lt;Image.Projection&gt;
   &lt;PlaneProjection /&gt;
&lt;/Image.Projection&gt;</pre>
其次在 &lt;Page.Resources&gt;中添加故事板：
<pre class="lang:default decode:true ">&lt;Storyboard x:Name="StoryBoardX"&gt;
&lt;DoubleAnimation Storyboard.TargetName="ResultImage"
Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationX)"
From="0.0"
To="360.0"
AutoReverse="True"
RepeatBehavior="Forever"&gt;
&lt;/DoubleAnimation&gt;
&lt;/Storyboard&gt;
</pre>

<ul>
<li>命名：方便后台代码调用</li>
<li>类：DoubleAnimation针对Double属性，还有ColorAnimation针对Color属性，以及PointAnimation针对Point，这里图形翻转目标属性是PlaneProjection   值是double类型</li>
<li>Storyboard.TargetName：执行动画的对象名称</li>
<li>Storyboard.TargetProperty：执行动画的对象属性，此处是PlaneProjection.RotationX，写成Storyboard.TargetProperty=”PlaneProjection.RotationX”也没有关系</li>
<li>From：起始值</li>
<li>To：终点值</li>
<li>By：变化值</li>
<li>AutoReverse：自动重置（返回原状）</li>
<li>RepeatBehavior：播放次数</li>
<li>Duration：持续时间（值的格式为时分秒，即0.0.3  3秒）<br>以上是通过XAML写出界面，当然，完全可以在后台代码中，完成StoryBoard的设置：<br><pre class="lang:default decode:true ">            DoubleAnimation animation = new DoubleAnimation();<pre><code>animation.From = 0.0;
animation.To = 360.0;
animation.BeginTime = TimeSpan.FromSeconds(1);
animation.RepeatBehavior = RepeatBehavior.Forever;
Storyboard.SetTarget(animation, target);
Storyboard.SetTargetProperty(animation, &quot;(UIElement.Projection).(PlaneProjection.Rotation&quot; + axis + &quot;)&quot;);
rotation.Children.Clear();
rotation.Children.Add(animation);
rotation.Begin();
rotating = true;&lt;/pre&gt;
</code></pre>不过看个人爱好了，我还是喜欢XAML。</pre></li>
</ul>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;动画编程小尝试&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记二：AppBar和CommandBar</title>
    <link href="http://yoursite.com/2016/04/22/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AAppBar%E5%92%8CCommandBar/"/>
    <id>http://yoursite.com/2016/04/22/UWP开发笔记二：AppBar和CommandBar/</id>
    <published>2016-04-21T21:00:36.000Z</published>
    <updated>2016-10-28T13:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>AppBar和CommandBar<br>. </p>

<a id="more"></a>
<p>AppBar和CommandBar也算是比较常用的控件了，不过个人不太喜欢这些，主要是觉得很非主流，我还是喜欢把功能都做到汉堡菜单里。</p>
<p>1，CommandBar被包裹住了，一般放在页面顶部或底部。</p>
<p><pre class="lang:default decode:true ">&lt;Page<br>    x:Class=”ApplicationBar.MainPage”<br>    xmlns=”<a href="http://schemas.microsoft.com/winfx/2006/xaml/presentation" target="_blank" rel="external">http://schemas.microsoft.com/winfx/2006/xaml/presentation</a>“<br>    xmlns:x=”<a href="http://schemas.microsoft.com/winfx/2006/xaml" target="_blank" rel="external">http://schemas.microsoft.com/winfx/2006/xaml</a>“<br>    xmlns:local=”using:ApplicationBar”<br>    xmlns:d=”<a href="http://schemas.microsoft.com/expression/blend/2008" target="_blank" rel="external">http://schemas.microsoft.com/expression/blend/2008</a>“<br>    xmlns:mc=”<a href="http://schemas.openxmlformats.org/markup-compatibility/2006" target="_blank" rel="external">http://schemas.openxmlformats.org/markup-compatibility/2006</a>“<br>    mc:Ignorable=”d”&gt;</pre></p>
<p>  &lt;Page.BottomAppBar&gt;<br>        &lt;CommandBar&gt;</p>
<pre><code>    &amp;lt;/CommandBar&amp;gt;
&amp;lt;/Page.BottomAppBar&amp;gt;
&amp;lt;Grid Background=&quot;{ThemeResource ApplicationPageBackgroundThemeBrush}&quot;&amp;gt;
&amp;lt;/Grid&amp;gt;
</code></pre><p>&lt;/Page&gt;<br>所以就是这种效果，在CommandBar中有两种菜单可选</p>
<p>图标文字：添加AppBarButton即可</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/001.png" alt=""></p>
<p><pre class="lang:default decode:true ">&lt;AppBarButton Name=”FirstAppBarButton”<br>    Icon=”Account”<br>     Label=”主页”<br>    Click=”FirstAppBarButton_Click”/&gt;</pre><br>文字列表：需要夹在&lt;CommandBar.SecondaryCommands&gt;&lt;/CommandBar.SecondaryCommands&gt;中间</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/002.png" alt=""></p>
<p><pre class="lang:default decode:true ">&lt;CommandBar.SecondaryCommands&gt;<br>                &lt;AppBarButton Name=”TextAppBarButton1”<br>                              Label=”文字1”<br>                              Click=”TextAppBarButton1_Click”/&gt;<br>&lt;/CommandBar.SecondaryCommands&gt;</pre><br>2,AppBar 的话，可能更强大一点，它可以嵌套着命令栏CommandBar，不过也是需要放在页面顶部或者底部</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/005.png" alt=""></p>
<p><pre class="lang:default decode:true">&lt;Page.TopAppBar&gt;<br>        &lt;AppBar  &gt;</pre></p>
<pre><code>    &amp;lt;/AppBar&amp;gt;
&amp;lt;/Page.TopAppBar&amp;gt;&lt;/pre&gt;
</code></pre><p>对于每个命令栏按钮，依然可以添加Click事件进行处理。</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/003.png" alt=""></p>
<p><img src="http://images.chenyalun.cn/2016/04/20/004.png" alt=""></p>
<hr>
<hr>
<h3 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h3><p>1,</p>
<p><pre class="lang:default decode:true ">&lt;Page.TopAppBar&gt;<br>        &lt;AppBar  IsSticky=”True” &gt;<br>            &lt;StackPanel Orientation=”Horizontal” &gt;<br>                &lt;CommandBar&gt;<br>                    &lt;!–第二命令栏–&gt;<br>                    &lt;CommandBar.SecondaryCommands&gt;<br>                        &lt;AppBarButton Name=”Hide” Icon=”Cancel” Label=”文本” Visibility=”Collapsed” Click=”Show_Click”/&gt;<br>                    &lt;/CommandBar.SecondaryCommands&gt;<br>                     &lt;!–设置命令栏内容–&gt;<br>                    &lt;CommandBar.Content&gt;<br>                        &lt;TextBlock Text=”Now playing…” Margin=”12,14”/&gt;<br>                    &lt;/CommandBar.Content&gt;<br>                &lt;/CommandBar&gt;<br>                     &lt;!–分割线–&gt;<br>                &lt;AppBarSeparator/&gt;<br>                &lt;AppBarButton Name=”Show”<br>                              Icon=”Accept”<br>                              Label=”Show Other”<br>                              Click=”Show_Click”<br>                              IsCompact=”True”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.TopAppBar&gt;</pre><br>如上所示，AppBar中包裹命令栏。若菜单栏中只包含AppBarButton（普通按钮）、AppBarToggleButton（切换按钮）、AppBarSeparator（分割线） 这几个控件，且没有特殊布局格式要求，CommandBar 控件可以解决大多数问题。</p>
<p>第二命令栏需要使用：CommandBar.SecondaryCommands</p>
<p>命令栏内容：CommandBar.Content</p>
<p>命令按钮分割线： &lt;AppBarSeparator/&gt;</p>
<p>标签：label</p>
<p>图标: icon</p>
<p>顶部命令栏：&lt;Page.TopAppBar&gt;&lt;/Page.TopAppBar&gt;</p>
<p>底部命令栏： &lt;Page.BottomAppBar&gt; &lt;/Page.BottomAppBar&gt;</p>
<p>单词：toggle 切换   Separator分隔符</p>
<p>在AppBar属性中：IsSticky=”True”表示打开命令栏后，除非用户显式地点击鼠标右键或按Win+z, 或用手指从屏幕顶端或底端划过才会隐藏，否则AppBar会一直显示。一般不设置。</p>
<p>IsOpen=”True” 一直完全显示图标+文字，一般不设置。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;AppBar和CommandBar&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记一：Hello UWP与对话框</title>
    <link href="http://yoursite.com/2016/04/20/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9AHello_UWP%E4%B8%8E%E5%AF%B9%E8%AF%9D%E6%A1%86/"/>
    <id>http://yoursite.com/2016/04/20/UWP开发笔记一：Hello_UWP与对话框/</id>
    <published>2016-04-19T21:00:51.000Z</published>
    <updated>2016-10-28T13:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>Hello World UWP<br>. </p>

<a id="more"></a>
<p>这段时间在悄悄地学习UWP开发，不过担心会忘记，所以感觉还是记下笔记比较好。一来自己没事可以翻着看看，可解闷了，二来欢迎志同道合的童鞋一起交流。</p>
<p>1，假定PC装好VS2015，文件–新建–项目–windows通用应用</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/001.png" alt=""></p>
<p>设置版本：</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/002.png" alt=""></p>
<p>2，右侧解决方案中，打开MainPage.xaml，写入xaml代码：</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/003.png" alt=""></p>
<p><pre class="lang:default decode:true ">  &lt;Button Name=”HelloUWPButton”<br>                Content=”显示”<br>                HorizontalAlignment=”Center”<br>                VerticalAlignment=”Center”<br>        Click=”HelloUWPButton_Click”/&gt;</pre><br>或者拖入Button控件，属性中设置Click事件：HelloUWPButton_Click，内容设置为：显示。</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/004.png" alt=""></p>
<p>3，处理click事件：</p>
<p><pre class="lang:default decode:true ">private async void HelloUWPButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            await new Windows.UI.Popups.MessageDialog(“Hello UWP”).ShowAsync();</pre></p>
<pre><code>}&lt;/pre&gt;
</code></pre><p>4，调试运行即可。</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/005.png" alt=""></p>
<hr>
<hr>
<h3 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;<strong>笔记</strong></h3><p>1，其实点击事件的代码和下面两行等价：</p>
<p><pre class="lang:default decode:true ">var message = new MessageDialog(“Hello UWP”);<br>await  message.ShowAsync();</pre><br>&nbsp;</p>
<p>2，消息对话框引入的命名空间：<strong>using Windows.UI.Popups;</strong></p>
<p>&nbsp;</p>
<p>3，消息对话框的使用</p>
<p>创建对话框并设置内容：</p>
<p><pre class="lang:default decode:true ">var messageDialog = new MessageDialog(“消息对话框的内容”, “可省略的对话框标题”);</pre><br>设置对话框中的命令,最多有3个：</p>
<p><pre class="lang:default decode:true ">UICommand cmd1 = new UICommand();<br>UICommand cmd2 = new UICommand();<br>UICommand cmd3 = new UICommand();</pre><br>设置命令的标签文本：</p>
<p><pre class="lang:default decode:true ">cmd1.Label = “标签1”;<br>cmd2.Label = “标签2”;<br>cmd3.Label = “标签3”;</pre><br>设置命令的唯一标识符：</p>
<p><pre class="lang:default decode:true ">cmd1.Id = 1;<br>cmd2.Id = 2;<br>cmd3.Id = 3;</pre><br>设置消息对话框命令的默认ID（直接按下回车键就可以执行的命令）<br>三个命令默认从左到右DefaultCommandIndex依次是0，1，2，大于2或者不设置则DefaultCommandIndex的值为0</p>
<p><pre class="lang:default decode:true "> messageDialog.DefaultCommandIndex = 1;</pre><br>设置调用（点击）命令时引发的事件：OnCommend</p>
<p><pre class="lang:default decode:true ">cmd1.Invoked = new UICommandInvokedHandler(OnCommend);<br>cmd2.Invoked = new UICommandInvokedHandler(OnCommend);<br>cmd3.Invoked = new UICommandInvokedHandler(OnCommend);</pre><br>将3个命令添加到对话框中</p>
<p><pre class="lang:default decode:true ">messageDialog.Commands.Add(cmd1);<br>messageDialog.Commands.Add(cmd2);<br>messageDialog.Commands.Add(cmd3);</pre><br>显示消息对话框(异步)</p>
<p><pre class="lang:default decode:true ">await messageDialog.ShowAsync();</pre><br>截至目前，上面的代码可以简化为：</p>
<p><pre class="lang:default decode:true">var messageDialog = new MessageDialog(“消息对话框的内容”);<br>messageDialog.DefaultCommandIndex = 1;<br>messageDialog.Commands.Add(new UICommand(“标签1”, OnCommend, 1));<br>messageDialog.Commands.Add(new UICommand(“标签2”, OnCommend, 2));<br>messageDialog.Commands.Add(new UICommand(“标签3”, OnCommend, 3));<br>await messageDialog.ShowAsync();</pre><br>处理调用命令的事件：</p>
<p>一般通过命令的ID进行不同的处理，将object类型的command.Id转化为int32类型</p>
<p><pre class="lang:default decode:true "> private void OnCommend(IUICommand command)<br>        {<br>            var ID = Convert.ToInt32(command.Id);</pre></p>
<pre><code>    // 处理不同的命令
    if (ID == 1)
    {
        ResultTextBlock.Text = &quot;你点击了命令1：标签1&quot;;
    }
    else if (ID == 2)
    {
        ResultTextBlock.Text = &quot;你点击了命令2：标签2&quot;;
    }
    else
    {
        ResultTextBlock.Text = &quot;你点击了命令3：标签3&quot;;
    }

}&lt;/pre&gt;
</code></pre><p><img src="http://images.chenyalun.cn/2016/04/19/006.png" alt=""></p>
<p>4，单词积累：</p>
<p>popups：弹出窗口；弹出式视窗</p>
<p>invoked：恳求；实行；引起</p>
<p>5,github: <a href="http://www.chenyalun.cn/go/?url=https://github.com/chenyalun/UWP-Notes.git" target="_blank" rel="external">https://github.com/chenyalun/UWP-Notes.git</a></p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;Hello World UWP&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>泛谈单链表的插入与删除</title>
    <link href="http://yoursite.com/2015/11/04/%E6%B3%9B%E8%B0%88%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2015/11/04/泛谈单链表的插入与删除/</id>
    <published>2015-11-03T21:00:32.000Z</published>
    <updated>2016-10-28T13:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>简单探讨单链表的插入与删除<br>. </p>

<a id="more"></a>
<p>其实单链表也是比较有意思的，可惜我弄了好久才些微明白些。在顺序表中，一个数组就将近定义一个结构，但在单链表中，却又要和指针扯上关系了。</p>
<p>定义：</p>
<pre><code>typedef struct LNode{
    int data;
    struct LNode next;
}LNode;
</code></pre><p>江湖传言LNode *p等价于LinkList p，不知道有木有人认同呢？</p>
<pre><code>    #include&lt;stdio.h&gt;

    #include&lt;malloc.h&gt;
    //定义并初始化单链表
    typedef struct LNode{
    int data;
    struct LNode *next;
    }LNode;

    //单链表的创建与初始化，设定共n个节点（不含头节点）
    void CreateLinkList(LNode a,int n) {
    LNode p,q;
    p=a;
    while(n–){
    q=(LNode )malloc(sizeof(LNode *));
    scanf(“%d”,&amp;q-&gt;data);
    q-&gt;next=NULL;
    p-&gt;next=q;
    p=q;
    }
    }

    //查找是否存在一个值为x的节点，若存在，删之，并返回OK，否则返回NOT FOUND
    char SearchAndDelete(LNode c,int x){
    LNode p,q;
    p=c;
    //开始查找
    while(p-&gt;next!=NULL)
    {
    if(p-&gt;next-&gt;data==x)
    break;
    p=p-&gt;next;
    }
    //若找到则开始删除
    if(p-&gt;next==NULL)
    return “NOT FOUND”;
    else
    {
    q=p-&gt;next;
    p-&gt;next=p-&gt;next-&gt;next;
    free(q);
    return “OK”;
    }
    }

    //在链表c中第n个节点位置插入元素e
    void Insert(LNode c,int n,int e){
    LNode p=( LNode )malloc(sizeof(LNode )),
    q=( LNode )malloc(sizeof(LNode ));//插入的节点
    p=c;
    q-&gt;data=e;
    //找到要插入节点的位置
    for(int i=1;i&lt;n;i++){
    p=p-&gt;next;
    }
    //插入节点
    q-&gt;next=p-&gt;next;
    p-&gt;next=q;
    }
    //打印单链表
    void Print(LNode a){
    LNode p=( LNode )malloc(sizeof(LNode *));
    p=a-&gt;next;
    while(p!=NULL){
    printf(“%d\n”,p-&gt;data);
    p=p-&gt;next;
    }
    }

    int main(){
    LNode a=( LNode )malloc(sizeof(LNode *));
    CreateLinkList(a,5);
    Insert(a,3,10086);//假定在第3个位置插入数值为10086的节点
    Print(a);
    printf(“—————-\n”);
    SearchAndDelete(a,13);//查找并执行删除数值为13的节点
    Print(a);
    return 0;
}
</code></pre><p>说明如下：</p>
<p>1，假定输入的是11 12 13 14 15五个数值。在第三个位置（13的位置）插入一个数据域为10086的节点。此时原来的数值已经变成了11 12 10086 13 14 15</p>
<p>2，完事后，我为了方便不再另写代码，在11 12 10086 13 14 15的基础上假定查找并删除数据域为13的节点。</p>
<p><img src="http://source.chenyalun.cn/images/201511/5110101.jpg" alt=""></p>
<p>当然还有值得体会的是，把节点的内存分配放在主函数里.</p>
<p>像这样：</p>
<pre><code>LNode a=( LNode )malloc(sizeof(LNode *));
</code></pre><p>当然，清晰一点就是</p>
<pre><code>LNode a;
a=( LNode )malloc(sizeof(LNode *));
</code></pre><p>两者效果一样。</p>
<pre><code>void Print(LNode *a){

}
和

void Print(LNode &amp;a){
    a=( LNode )malloc(sizeof(LNode *));

}
</code></pre><p>这才是重点，和小伙伴研究一下，决定采取有违伦理惨无人道的第一种方式。最后在主函数中再调用malloc觉得还是蛮灵活轻便的。</p>
<p>当然，上面的代码不是为了解题，只是提供一个思路，具体可视情况修改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;简单探讨单链表的插入与删除&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="编程技巧" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>泛谈顺序表的插入与删除</title>
    <link href="http://yoursite.com/2015/11/02/%E6%B3%9B%E8%B0%88%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2015/11/02/泛谈顺序表的插入与删除/</id>
    <published>2015-11-01T21:00:11.000Z</published>
    <updated>2016-10-28T13:54:12.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>简单探讨顺序表的插入与删除<br>. </p>

<a id="more"></a>
<p>所谓的顺序表，在严版的书中，定义的异常专业巧妙。存储空间基址、当前长度、分配的存储容量，这三部分融合而成线性表之顺序表。</p>
<pre><code>typedef struct{
    Elemtype *elem;
    int length;
    int listsize;
}SqList;
</code></pre><p>翻翻资料。发现还有一种更巧妙而且容易理解的方式：</p>
<pre><code>typedef struct{
    int data[Max];
    int length;
}SqList;
</code></pre><p>这样一来，整个顺序表就与数组特别特别相似啦。</p>
<p>那么，声明一个很长很长但是彼此知道的Max长度数组，作为默认“表长”（其实不是表长），再给它一个长度length，如此，顺序表横空出世了。</p>
<p>既然如此，那关于什么插入、删除操作就不在话下了。</p>
<p>1 已知顺序表的所有元素值（自行输入），在元素e的位置插入元素m</p>
<p>题目很清楚，插入元素m后，后面的元素自然往后移动啦。</p>
<pre><code>    #include&lt;stdio.h&gt;
    //#include&lt;malloc.h&gt;
    //#include&lt;stdlib.h&gt;   //一般这两个是需要的

    #define Max 200
    //定义并初始化顺序表
    typedef struct{
    int data[Max];
    int length=10;
    }SqList;
    //顺序表l中查找元素e的位置
    int LocatElem(SqList l,int e){
    int i=0;
    for(;i&lt;l.length;++i)
    if(l.data[i]==e)
    return i+1;
    }

    //在元素e的位置插入元素m
    void Insert(SqList &amp;l,int e,int m) {
    int i=l.length,p=LocatElem(l,e);
    for(;i&gt;=p;–i){
    l.data[i]=l.data[i-1];
    }
    l.data[i]=m;
    l.length++;
    }

    int main(){
    int i=0,e=18,m=200;
    SqList a;
    for(;i&lt;a.length;++i)
    scanf(“%d”,&amp;a.data[i]);
    Insert(a,e,m);
    for(int i=0;i&lt;a.length;++i)
    printf(“%d\n”,a.data[i]);
    return 0;
}
</code></pre><p>这里假设我们输入从11，12一直到20的整数值，首先查找元素e=18的值的位置，插入m的值200。</p>
<p>原来：11 12 13 14 15 16 17 18 19 20</p>
<p>run后：11 12 13 14 15 16 17 200 18 19 20</p>
<p><img src="http://source.chenyalun.cn/images/201510/5103102.jpg" alt=""></p>
<p>2 已知顺序表所有元素的值（自行输入），删除顺序表中值为e的元素</p>
<pre><code>    #include&lt;stdio.h&gt;
    //#include&lt;malloc.h&gt;
    //#include&lt;stdlib.h&gt;

    #define Max 200
    //定义并初始化顺序表
    typedef struct{
    int data[Max];
    int length=10;
    }SqList;
    //顺序表l中查找元素e的位置
    int LocatElem(SqList l,int e){
    int i=0;
    for(;i&lt;l.length;++i)
    if(l.data[i]==e)
    return i+1;
    }

    //删除顺序表中值为e的元素
    void Delete(SqList &amp;l,int e){
    int i=LocatElem(l,e);
    for(;i&lt;=l.length;++i)
    l.data[i-1]=l.data[i];
    l.length–;
    }
    int main(){
    int i=0, e=15;//e的值自己说了算
    SqList a;
    for(;i&lt;a.length;++i)
    scanf(“%d”,&amp;a.data[i]);
    Delete(a,e);
    for(int i=0;i&lt;a.length;++i)
    printf(“%d\n”,a.data[i]);
    return 0;
}
</code></pre><p>改动不大，添加个函数而已。这里删除的是15，具体题目具体分析。</p>
<p>原来：11 12 13 14 15 16 17 18 19 20</p>
<p>run后：11 12 13 14 16 17 18 19 20<br><img src="http://source.chenyalun.cn/images/201510/5103101.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;简单探讨顺序表的插入与删除&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="编程技巧" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
