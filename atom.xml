<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ya</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.chenyalun.com/"/>
  <updated>2019-03-22T03:05:15.532Z</updated>
  <id>http://blog.chenyalun.com/</id>
  
  <author>
    <name>Ya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础百搭款「PageMenu」</title>
    <link href="http://blog.chenyalun.com/2019/03/21/%E5%9F%BA%E7%A1%80%E7%99%BE%E6%90%AD%E6%AC%BE%E3%80%8CPageMenu%E3%80%8D/"/>
    <id>http://blog.chenyalun.com/2019/03/21/基础百搭款「PageMenu」/</id>
    <published>2019-03-21T11:42:23.000Z</published>
    <updated>2019-03-22T03:05:15.532Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 一个使用Swift写的PageMenu。 </p><br><a id="more"></a><p></p><p>一个使用Swift写的PageMenu。没有那么多接口，自己可以根据实际需要扩展。写这个的目的一是为了练手，毕竟工作中使用Swift极少，再一个，PageMenu使用场景挺多的，我遇到过好几次，这次做一个总结。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>MenuStyle: 用于标题的样式配置<br>PageTitleView: 私有的单个标题控件<br>PageTitle: 标题区视图<br>PageContent: 内容区视图<br>PageMenu: 继承自UIViewController的视图控制器，用于连接PageTitle和PageContent<br>UIColor+RGB: 一些对UIColor的拓展，主要是支持RGB的方式设置颜色</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="MenuStyle"><a href="#MenuStyle" class="headerlink" title="MenuStyle"></a>MenuStyle</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuStyle</span>: <span class="type">UIView &#123;</span></span></span><br><span class="line">    <span class="comment">// 标题之间的间距</span></span><br><span class="line">    <span class="keyword">var</span> margin: CGFloat = <span class="number">10</span></span><br><span class="line">    <span class="comment">// 默认颜色</span></span><br><span class="line">    <span class="keyword">var</span> defaultColor = UIColor(r: <span class="number">0</span>, g: <span class="number">0</span>, b: <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 默认字体</span></span><br><span class="line">    <span class="keyword">var</span> defaultFont = UIFont.systemFont(ofSize: <span class="number">17</span>)</span><br><span class="line">    <span class="comment">// 选中态颜色</span></span><br><span class="line">    <span class="keyword">var</span> selectedColor = UIColor(r: <span class="number">239</span>, g: <span class="number">154</span>, b: <span class="number">64</span>)</span><br><span class="line">    <span class="comment">// 选中态字体</span></span><br><span class="line">    <span class="keyword">var</span> selectedFont = UIFont.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指示条高度, 为0表示隐藏</span></span><br><span class="line">    <span class="keyword">var</span> lineHeight: CGFloat = <span class="number">2</span></span><br><span class="line">    <span class="comment">// 指示条宽度, 为0表示自适应</span></span><br><span class="line">    <span class="keyword">var</span> lineWidth: CGFloat = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 指示条颜色, 默认与selectedColor保持一致</span></span><br><span class="line">    <span class="keyword">var</span> lineColor: UIColor?</span><br><span class="line">    <span class="comment">// 是否开启指示条颜色渐变</span></span><br><span class="line">    <span class="keyword">var</span> lineColorGradual = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 指示条圆角</span></span><br><span class="line">    <span class="keyword">var</span> lineCornerRadius: CGFloat = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标题区的frame</span></span><br><span class="line">    <span class="keyword">var</span> pageTitleFrame = CGRect(x: <span class="number">0</span>, y: <span class="number">20</span>, width: UIScreen.main.bounds.width, height: <span class="number">25</span>)</span><br><span class="line">    <span class="comment">// 标题区与内容区的间距</span></span><br><span class="line">    <span class="keyword">var</span> titleContentMargin: CGFloat = <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PageTitle"><a href="#PageTitle" class="headerlink" title="PageTitle"></a>PageTitle</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PageTitleDelegate</span> : <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pageTitleDidSelected</span><span class="params">(pageTitle: PageTitle, pageTitleView: PageTitleView)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标题视图组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageTitleView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    <span class="keyword">var</span> index: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 标题</span></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span>?</span><br><span class="line">    <span class="comment">// 渐变颜色</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span>? &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            label.textColor = color</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 样式</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> style: <span class="type">MenuStyle</span></span><br><span class="line">    <span class="comment">// 选中状态</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> isSelected: <span class="type">Bool</span> = <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123; reloadState() &#125;<span class="comment">// 刷新数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自身宽度</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> width: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title?.size(withAttributes: [<span class="type">NSAttributedString</span>.<span class="type">Key</span>.font: font]).width ?? <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 字体大小</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> font: <span class="type">UIFont</span> &#123; <span class="keyword">return</span> isSelected ? style.selectedFont : style.defaultFont &#125;</span><br><span class="line">    <span class="comment">// 字体颜色</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> fontColor: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> isSelected ? style.selectedColor : style.defaultColor &#125;</span><br><span class="line">    <span class="comment">// 点击回调</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> tapCallBack: ((<span class="number">_</span> view: <span class="type">PageTitleView</span>) -&gt; <span class="type">Void</span>)?</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>()</span><br><span class="line">        <span class="keyword">let</span> gesture = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(action(<span class="number">_</span>:)))</span><br><span class="line">        label.addGestureRecognizer(gesture)</span><br><span class="line">        label.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>?, isSelected: <span class="type">Bool</span>, style: <span class="type">MenuStyle</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.isSelected = isSelected</span><br><span class="line">        <span class="keyword">self</span>.style = style</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>.zero)</span><br><span class="line">        reloadState()</span><br><span class="line">        <span class="keyword">self</span>.addSubview(label)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态链接</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(<span class="number">_</span> tap: UITapGestureRecognizer)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> tapCallBack != <span class="literal">nil</span> &#123;</span><br><span class="line">            tapCallBack!(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷新数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">reloadState</span><span class="params">()</span></span> &#123;</span><br><span class="line">        label.text = title</span><br><span class="line">        label.textColor = fontColor</span><br><span class="line">        label.font = font</span><br><span class="line">        label.sizeToFit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标题视图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageTitle</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">PageTitleDelegate</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> titleList: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> scrollView: <span class="type">UIScrollView</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> scrollView = <span class="type">UIScrollView</span>(frame: bounds)</span><br><span class="line">        scrollView.showsHorizontalScrollIndicator = <span class="literal">false</span></span><br><span class="line">        addSubview(scrollView)</span><br><span class="line">        <span class="keyword">return</span> scrollView</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 指示器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> lineView: <span class="type">UIView</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> lineView = <span class="type">UIView</span>()</span><br><span class="line">        lineView.backgroundColor = menuStyle.lineColor ?? menuStyle.selectedColor</span><br><span class="line">        lineView.layer.cornerRadius = menuStyle.lineCornerRadius</span><br><span class="line">        lineView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">        scrollView.addSubview(lineView)</span><br><span class="line">        <span class="keyword">return</span> lineView</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 样式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> menuStyle: <span class="type">MenuStyle</span></span><br><span class="line">    <span class="comment">// 当前选中标题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentSelectedView: <span class="type">PageTitleView</span>?</span><br><span class="line">    <span class="comment">// 标题列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> titleViewList = [<span class="type">PageTitleView</span>]()</span><br><span class="line">    <span class="keyword">init</span>(frame: <span class="type">CGRect</span>, menuStyle: <span class="type">MenuStyle</span>, titleList: [<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.menuStyle = menuStyle</span><br><span class="line">        <span class="keyword">self</span>.titleList = titleList</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">        setupSubViews()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupSubViews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> totalWidth: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 设置子控件</span></span><br><span class="line">        <span class="keyword">for</span> (idx, title) <span class="keyword">in</span> titleList.enumerated() &#123;</span><br><span class="line">            <span class="keyword">let</span> view = <span class="type">PageTitleView</span>(title: title <span class="keyword">as</span> <span class="type">String</span>, isSelected: <span class="literal">false</span>, style: menuStyle)</span><br><span class="line">            view.index = idx</span><br><span class="line">            titleViewList.append(view)</span><br><span class="line">            <span class="keyword">let</span> x = <span class="type">CGFloat</span>(idx + <span class="number">1</span>) * menuStyle.margin + totalWidth</span><br><span class="line">            view.frame = <span class="type">CGRect</span>(x: x, y: <span class="number">0</span>, width: view.width, height: frame.height - menuStyle.lineHeight)</span><br><span class="line">            totalWidth += view.width</span><br><span class="line">            scrollView.addSubview(view)</span><br><span class="line">            view.tapCallBack = &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] view <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                <span class="keyword">self</span>.changeToSelectedIndex(idx: view.index)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scrollView.contentSize = <span class="type">CGSize</span>(width: totalWidth + <span class="type">CGFloat</span>(titleList.<span class="built_in">count</span> + <span class="number">1</span>) * menuStyle.margin, height: <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 默认选中的索引 0</span></span><br><span class="line">        changeToSelectedIndex()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: 切换过程中需要调用的函数</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PageTitle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">changeToSelectedIndex</span><span class="params">(idx: Int = <span class="number">0</span>, progress: CGFloat = <span class="number">1</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 索引值越界</span></span><br><span class="line">        <span class="keyword">if</span> idx &gt; titleViewList.<span class="built_in">count</span> - <span class="number">1</span> || idx &lt; <span class="number">0</span> || titleViewList.<span class="built_in">count</span> &lt;= <span class="number">0</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> fromView, toView: <span class="type">PageTitleView</span></span><br><span class="line">        <span class="keyword">if</span> currentSelectedView == <span class="literal">nil</span> &#123;</span><br><span class="line">            fromView = titleViewList.first!</span><br><span class="line">            toView = fromView</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fromView = currentSelectedView!</span><br><span class="line">            toView = titleViewList[idx]</span><br><span class="line">            <span class="comment">// 同一个标题</span></span><br><span class="line">            <span class="keyword">if</span> fromView == toView &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> menuStyle.lineHeight != <span class="number">0</span> &#123;</span><br><span class="line">            refreshBottomLineFrame(fromView.frame, toView.frame, progress)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> menuStyle.lineColorGradual &#123;</span><br><span class="line">            refreshTitleViewColor(fromView, toView, progress)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> progress == <span class="number">1</span> &#123;</span><br><span class="line">            refreshTitleViewState(fromView, toView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置指示条frame</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshBottomLineFrame</span><span class="params">(<span class="number">_</span> from: CGRect, <span class="number">_</span> to: CGRect, <span class="number">_</span> progress: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> from = from</span><br><span class="line">        <span class="keyword">var</span> to = to</span><br><span class="line">        <span class="keyword">let</span> lineHeight = menuStyle.lineHeight</span><br><span class="line">        <span class="keyword">let</span> lineWidth = menuStyle.lineWidth</span><br><span class="line">        <span class="keyword">let</span> y = frame.height - lineHeight</span><br><span class="line">        <span class="keyword">let</span> isFixedLineWidth = lineWidth != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> fromWidth = isFixedLineWidth ? lineWidth : from.width</span><br><span class="line">        <span class="keyword">let</span> toWidth = isFixedLineWidth ? lineWidth : to.width</span><br><span class="line">        <span class="keyword">let</span> fromMinX = isFixedLineWidth ? from.midX - lineWidth * <span class="number">0.5</span> : from.minX</span><br><span class="line">        <span class="keyword">let</span> fromMaxX = isFixedLineWidth ? fromMinX + lineWidth : from.maxX</span><br><span class="line">        <span class="keyword">let</span> toMinX = isFixedLineWidth ? to.midX - lineWidth * <span class="number">0.5</span> : to.minX</span><br><span class="line">        <span class="keyword">let</span> toMaxX = isFixedLineWidth ? toMinX + lineWidth : to.maxX</span><br><span class="line">        from = <span class="type">CGRect</span>(x: fromMinX, y: y, width: fromWidth, height: lineHeight)</span><br><span class="line">        to = <span class="type">CGRect</span>(x: toMinX, y: y, width: toWidth, height: lineHeight)</span><br><span class="line">        <span class="keyword">let</span> isToLeft = toMinX &lt; fromMinX <span class="comment">// 向左</span></span><br><span class="line">        <span class="keyword">if</span> progress &lt; <span class="number">0.5</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isToLeft &#123; <span class="comment">// 向左移动</span></span><br><span class="line">                <span class="keyword">let</span> offsetWidth = (fromMinX - toMinX) * <span class="number">2</span> * progress</span><br><span class="line">                lineView.frame = <span class="type">CGRect</span>(x: fromMinX - offsetWidth, y: y, width:  fromMaxX - fromMinX + offsetWidth, height: lineHeight)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> offsetWidth = (toMaxX - fromMaxX) * <span class="number">2</span> * progress</span><br><span class="line">                lineView.frame = <span class="type">CGRect</span>(x: fromMinX, y: y, width:from.width + offsetWidth, height: lineHeight)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isToLeft &#123; <span class="comment">// 向左移动</span></span><br><span class="line">                <span class="keyword">let</span> offsetWidth = (fromMaxX - to.maxX) * (<span class="number">1</span> - (progress - <span class="number">0.5</span>) * <span class="number">2</span>)</span><br><span class="line">                lineView.frame = <span class="type">CGRect</span>(x: toMinX, y: y, width:to.width + offsetWidth, height: lineHeight)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> offsetWidth = (toMinX - fromMinX) * (<span class="number">1</span> - (progress - <span class="number">0.5</span>) * <span class="number">2</span>)</span><br><span class="line">                lineView.frame = <span class="type">CGRect</span>(x: toMinX - offsetWidth, y: y, width:toMaxX - toMinX + offsetWidth, height: lineHeight)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷新标题状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshTitleViewState</span><span class="params">(<span class="number">_</span> fromView: PageTitleView, <span class="number">_</span> toView: PageTitleView)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 更新currentSelectedView</span></span><br><span class="line">        currentSelectedView?.isSelected = <span class="literal">false</span></span><br><span class="line">        toView.isSelected = <span class="literal">true</span></span><br><span class="line">        currentSelectedView = toView</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置标题居中</span></span><br><span class="line">        <span class="keyword">let</span> width = scrollView.bounds.width</span><br><span class="line">        <span class="keyword">let</span> contentWidth = scrollView.contentSize.width</span><br><span class="line">        <span class="keyword">var</span> offsetX = toView.center.x - width * <span class="number">0.5</span></span><br><span class="line">        offsetX = <span class="built_in">max</span>(offsetX, <span class="number">0</span>)</span><br><span class="line">        offsetX = <span class="built_in">min</span>(contentWidth - width, offsetX)</span><br><span class="line">        <span class="keyword">if</span> contentWidth &lt;= width &#123; <span class="comment">// 保持居中</span></span><br><span class="line">            <span class="keyword">let</span> viewWidth = <span class="type">CGFloat</span>(titleViewList.last?.frame.maxX ?? <span class="number">0</span>) - <span class="type">CGFloat</span>(titleViewList.first?.frame.minX ?? <span class="number">0</span>)</span><br><span class="line">            offsetX = -(width - viewWidth) * <span class="number">0.5</span> + menuStyle.margin</span><br><span class="line">        &#125;</span><br><span class="line">        scrollView.setContentOffset(<span class="type">CGPoint</span>(x: offsetX, y: <span class="number">0</span>), animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> delegate != <span class="literal">nil</span> &#123;</span><br><span class="line">            delegate?.pageTitleDidSelected(pageTitle: <span class="keyword">self</span>, pageTitleView: toView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标题颜色渐变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshTitleViewColor</span><span class="params">(<span class="number">_</span> fromView: PageTitleView, <span class="number">_</span> toView: PageTitleView, <span class="number">_</span> progress: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> toRGB = <span class="type">UIColor</span>.rgbValue(menuStyle.selectedColor)</span><br><span class="line">        <span class="keyword">let</span> fromRGB = <span class="type">UIColor</span>.rgbValue(menuStyle.defaultColor)</span><br><span class="line">        <span class="keyword">let</span> deltaRGB = (toRGB.<span class="number">0</span> - fromRGB.<span class="number">0</span>, toRGB.<span class="number">1</span> - fromRGB.<span class="number">1</span>, toRGB.<span class="number">2</span> - fromRGB.<span class="number">2</span>)</span><br><span class="line">        fromView.color = <span class="type">UIColor</span>(r: toRGB.<span class="number">0</span> - deltaRGB.<span class="number">0</span> * progress, g: toRGB.<span class="number">1</span> - deltaRGB.<span class="number">1</span> * progress, b: toRGB.<span class="number">2</span> - deltaRGB.<span class="number">2</span> * progress)</span><br><span class="line">        toView.color = <span class="type">UIColor</span>(r: fromRGB.<span class="number">0</span> + deltaRGB.<span class="number">0</span> * progress, g: fromRGB.<span class="number">1</span> + deltaRGB.<span class="number">1</span> * progress, b: fromRGB.<span class="number">2</span> + deltaRGB.<span class="number">2</span> * progress)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: PageContentDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PageTitle</span> : <span class="title">PageContentDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pageContentDidChange</span><span class="params">(pageContent: PageContent, targetIndex: Int, progress: CGFloat)</span></span> &#123;</span><br><span class="line">        changeToSelectedIndex(idx: targetIndex, progress: progress)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PageContent"><a href="#PageContent" class="headerlink" title="PageContent"></a>PageContent</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PageContentDelegate</span> : <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pageContentDidChange</span><span class="params">(pageContent: PageContent, targetIndex: Int, progress: CGFloat)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageContent</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">PageContentDelegate</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> controllerList: [<span class="type">UIViewController</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> identifier = <span class="string">"PageMenu_CollectionView_Identifier"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> shouldCallDelegate = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> layout = <span class="type">UICollectionViewFlowLayout</span>()</span><br><span class="line">        layout.itemSize = bounds.size</span><br><span class="line">        layout.scrollDirection = .horizontal</span><br><span class="line">        layout.minimumLineSpacing = <span class="number">0</span></span><br><span class="line">        layout.minimumInteritemSpacing = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> collectionView = <span class="type">UICollectionView</span>(frame: bounds, collectionViewLayout: layout)</span><br><span class="line">        collectionView.dataSource = <span class="keyword">self</span> <span class="keyword">as</span> <span class="type">UICollectionViewDataSource</span></span><br><span class="line">        collectionView.delegate = <span class="keyword">self</span> <span class="keyword">as</span> <span class="type">UICollectionViewDelegate</span></span><br><span class="line">        collectionView.showsHorizontalScrollIndicator = <span class="literal">false</span></span><br><span class="line">        collectionView.scrollsToTop = <span class="literal">false</span></span><br><span class="line">        collectionView.isPagingEnabled = <span class="literal">true</span></span><br><span class="line">        collectionView.bounces = <span class="literal">false</span></span><br><span class="line">        collectionView.backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line">        <span class="comment">// 注册cell</span></span><br><span class="line">        collectionView.register(<span class="type">UICollectionViewCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: identifier)</span><br><span class="line">        addSubview(collectionView)</span><br><span class="line">        <span class="keyword">return</span> collectionView</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">init</span>(frame: <span class="type">CGRect</span>, controllerList: [<span class="type">UIViewController</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.controllerList = controllerList</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">        <span class="keyword">self</span>.collectionView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: UICollectionViewDataSource</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PageContent</span> : <span class="title">UICollectionViewDataSource</span>, <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> controllerList.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: identifier, <span class="keyword">for</span>: indexPath)</span><br><span class="line">        <span class="keyword">let</span> view = controllerList[indexPath.row].view!</span><br><span class="line">        view.frame = cell.bounds</span><br><span class="line">        cell.contentView.addSubview(view)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: UIScrollViewDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PageContent</span> : <span class="title">UIScrollViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndDecelerating</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="type">Int</span>(scrollView.contentOffset.x / scrollView.bounds.width)</span><br><span class="line">        currentIndex = index</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillBeginDragging</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">        shouldCallDelegate = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScroll</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !shouldCallDelegate &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> width = scrollView.bounds.width</span><br><span class="line">        <span class="keyword">let</span> offsetX = scrollView.contentOffset.x - <span class="type">CGFloat</span>(currentIndex) * width</span><br><span class="line">        <span class="keyword">let</span> offsetIndex = offsetX &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> progress = <span class="built_in">abs</span>(offsetX) / width</span><br><span class="line">        <span class="keyword">if</span> delegate != <span class="literal">nil</span> &#123;</span><br><span class="line">            delegate?.pageContentDidChange(pageContent: <span class="keyword">self</span>, targetIndex: currentIndex + offsetIndex, progress: progress)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: PageTitleDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PageContent</span> : <span class="title">PageTitleDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">pageTitleDidSelected</span><span class="params">(pageTitle: PageTitle, pageTitleView: PageTitleView)</span></span> &#123;</span><br><span class="line">        shouldCallDelegate = <span class="literal">false</span></span><br><span class="line">        collectionView.scrollToItem(at: <span class="type">IndexPath</span>(item: pageTitleView.index, section: <span class="number">0</span>), at: .<span class="keyword">left</span>, animated: <span class="literal">false</span>)</span><br><span class="line">        currentIndex = pageTitleView.index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PageMenu"><a href="#PageMenu" class="headerlink" title="PageMenu"></a>PageMenu</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageMenu</span> : <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pageTitle: <span class="type">PageTitle</span></span><br><span class="line">    <span class="keyword">var</span> pageContent: <span class="type">PageContent</span></span><br><span class="line">    <span class="keyword">var</span> menuStyle: <span class="type">MenuStyle</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> controllerList: [<span class="type">UIViewController</span>]</span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> menuStyle: <span class="type">MenuStyle</span>, <span class="number">_</span> controllerList: [<span class="type">UIViewController</span>]) &#123;</span><br><span class="line">        <span class="keyword">var</span> titleList = [<span class="type">String</span>]()</span><br><span class="line">        <span class="keyword">for</span> controller <span class="keyword">in</span> controllerList &#123;</span><br><span class="line">            titleList.append(controller.title ?? <span class="string">"null"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.pageTitle = <span class="type">PageTitle</span>(frame: menuStyle.pageTitleFrame, menuStyle: menuStyle, titleList: titleList)</span><br><span class="line">        <span class="keyword">self</span>.pageContent = <span class="type">PageContent</span>(frame: <span class="type">CGRect</span>(x: pageTitle.frame.minX, y: pageTitle.frame.maxY + menuStyle.titleContentMargin, width: pageTitle.frame.width, height: <span class="type">UIScreen</span>.main.bounds.height - pageTitle.frame.height), controllerList: controllerList)</span><br><span class="line">        <span class="keyword">self</span>.menuStyle = menuStyle</span><br><span class="line">        <span class="keyword">self</span>.controllerList = controllerList</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">        configureComponent()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">configureComponent</span><span class="params">()</span></span> &#123;</span><br><span class="line">        view.addSubview(pageTitle)</span><br><span class="line">        view.addSubview(pageContent)</span><br><span class="line">        <span class="keyword">for</span> controller <span class="keyword">in</span> controllerList &#123;</span><br><span class="line">            addChild(controller)</span><br><span class="line">        &#125;</span><br><span class="line">        pageTitle.delegate = pageContent</span><br><span class="line">        pageContent.delegate = pageTitle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UIColor-RGB"><a href="#UIColor-RGB" class="headerlink" title="UIColor+RGB"></a>UIColor+RGB</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(r : <span class="type">CGFloat</span>, g : <span class="type">CGFloat</span>, b : <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(red: r / <span class="number">255.0</span>, green: g / <span class="number">255.0</span>, blue: b / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">rgbValue</span>(<span class="title">_</span> <span class="title">color</span> : <span class="title">UIColor</span>) -&gt; (<span class="title">CGFloat</span>, <span class="title">CGFloat</span>, <span class="title">CGFloat</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> components = color.cgColor.components <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"颜色按照RGB设置"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (components[<span class="number">0</span>] * <span class="number">255</span>, components[<span class="number">1</span>] * <span class="number">255</span>, components[<span class="number">2</span>] * <span class="number">255</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>简单配置一下MenuStyle，创建自己的视图控制器，就能直接使用了。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    <span class="selector-tag">var</span> controllerList = [UIViewController]()</span><br><span class="line">    let style: MenuStyle = MenuStyle()</span><br><span class="line">    <span class="comment">// 创建style并配置样式</span></span><br><span class="line">    style<span class="selector-class">.margin</span> = <span class="number">30</span></span><br><span class="line">    style<span class="selector-class">.defaultColor</span> = UIColor(r: <span class="number">135</span>, g: <span class="number">135</span>, <span class="selector-tag">b</span>: <span class="number">135</span>)</span><br><span class="line">    style<span class="selector-class">.selectedColor</span> = UIColor(r: <span class="number">0</span>, g: <span class="number">0</span>, <span class="selector-tag">b</span>: <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 创建控制器</span></span><br><span class="line">    let red = UIViewController()</span><br><span class="line">    red<span class="selector-class">.view</span><span class="selector-class">.backgroundColor</span> = UIColor.red</span><br><span class="line">    red<span class="selector-class">.title</span> = <span class="string">"关注"</span></span><br><span class="line">    let blue = UIViewController()</span><br><span class="line">    blue<span class="selector-class">.view</span><span class="selector-class">.backgroundColor</span> = UIColor.blue</span><br><span class="line">    blue<span class="selector-class">.title</span> = <span class="string">"热门"</span></span><br><span class="line">    controllerList = [red, blue]</span><br><span class="line">    <span class="comment">// 创建PageMenu</span></span><br><span class="line">    let pageMenu = PageMenu(style, controllerList)</span><br><span class="line">    pageMenu<span class="selector-class">.pageTitle</span><span class="selector-class">.backgroundColor</span> = UIColor(r: <span class="number">45</span>, g: <span class="number">184</span>, <span class="selector-tag">b</span>: <span class="number">105</span>)</span><br><span class="line">    addChild(pageMenu)</span><br><span class="line">    view.addSubview(pageMenu.view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>微博样式：<br><img src="https://image.chenyalun.com/2019/03/22/weibo.gif" alt=""></p><p>it之家样式：<br><img src="https://image.chenyalun.com/2019/03/22/ithome.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>处理起来比较麻烦一点的就是，标题区指示条的frame渐变，要考虑左滑和右滑的情况，还要考虑进度progress的问题。不过还好，仔细想想都能解决的。</p><p>再一个，PageTitle和PageContent之间互相通信的方案，我选择的是代理。PageTitle是PageContent的代理，同时，PageContent又是PageTitle的代理。由PageMenu负责连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 一个使用Swift写的PageMenu。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="DIY" scheme="http://blog.chenyalun.com/categories/DIY/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>实现通知中心</title>
    <link href="http://blog.chenyalun.com/2019/01/28/%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%9F%A5%E4%B8%AD%E5%BF%83/"/>
    <id>http://blog.chenyalun.com/2019/01/28/实现通知中心/</id>
    <published>2019-01-28T13:12:23.000Z</published>
    <updated>2019-03-22T03:05:33.075Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 自己去实现NotificationCenter。 </p><br><a id="more"></a><p></p><p>有几个弱引用容器在日常工作中没有用过，但是又特别想亲手实践一番。偶尔看到一篇文章，说是自己实现了系统中通知中心的功能，出于好奇，于是自己也尝试一番。</p><p>主要原理就是创建一个字典observerMap，notificationName作为key，NSMapTable作为value。在这个NSMapTable中，观察者observer作为key，用于存放观察者的NSHashSet作为value。挺绕的。</p><h1 id="接口文件"><a href="#接口文件" class="headerlink" title="接口文件"></a>接口文件</h1><p>接口与系统保持一致。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> *YANotificationName <span class="built_in">NS_EXTENSIBLE_STRING_ENUM</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YANotificationCenter</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) YANotificationCenter *defaultCenter;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name:(<span class="keyword">nullable</span> YANotificationName)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer;</span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer name:(<span class="keyword">nullable</span> YANotificationName)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure><h1 id="Checklist"><a href="#Checklist" class="headerlink" title="Checklist"></a>Checklist</h1><ul><li style="list-style: none"><input type="checkbox" checked> 不增加observer和object的引用计数</li><li style="list-style: none"><input type="checkbox" checked> 支持携带参数信息userInfo</li><li style="list-style: none"><input type="checkbox" checked> 可以不指定object</li><li style="list-style: none"><input type="checkbox" checked> 添加观察者时指定object，post通知时只有相同的object才会有效</li><li style="list-style: none"><input type="checkbox" checked> observer为nil，发送通知时没有作用</li><li style="list-style: none"><input type="checkbox" checked> 指定线程发送通知，则在指定线程调用</li><li style="list-style: none"><input type="checkbox" checked> 没有及时移除通知，observer销毁之后继续发送通知不会产生异常<br>(从iOS 9开始，即使不移除观察者对象，程序也不会出现异常。)</li><li style="list-style: none"><input type="checkbox" checked> 支持多个observer监听同一个通知</li><li style="list-style: none"><input type="checkbox" checked> 如果notificationName为nil，object有值，则接收所有指定为object的通知</li><li style="list-style: none"><input type="checkbox" checked> 如果notificationName为nil，且object也为nil，则接收系统内所有通知<br>(也即YANotificationCenter发出的所有通知)</li><li style="list-style: none"><input type="checkbox" checked> 移除所有通知后，相关方法不再调用</li><li style="list-style: none"><input type="checkbox" checked> 移除指定通知后，相关方法不再调用</li><li style="list-style: none"><input type="checkbox"> 多次添加observer，发送通知时多次调用</li></ul><p>“多次添加observer，发送通知时多次调用”这个没有实现。目前是多次添加observer，发送通知时只会调用一次。其实要实现也有办法，只是个人感觉这样是不是更好一点？</p><h1 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h1><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 不对observer和object强引用</span><br><span class="line"><span class="number">2.</span> 可以携带参数userInfo</span><br><span class="line"><span class="number">3.</span> 添加观察者时object为nil，post通知时object有值，依然有效(表示不限于指定的object)</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_1"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_1"</span> <span class="string">object:</span>self <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">4.</span> 添加观察者时指定object，post通知时相同的object，有效，不同的object，无效</span><br><span class="line"><span class="comment">// 有效</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_2"</span> <span class="string">object:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_2"</span> <span class="string">object:</span>self <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_3"</span> <span class="string">object:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_3"</span> <span class="string">object:</span>a <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 可以添加n次observer，发送通知时对应调用n次(不支持)</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_4"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_4"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_4"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">6.</span> 未添加observer，发送通知时没有作用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_5"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 指定线程发送通知，则在指定线程调用</span><br><span class="line"><span class="comment">// print方法是在发送通知的线程中调用的</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_6"</span> <span class="string">object:</span>nil];</span><br><span class="line">dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">NSLog(@<span class="string">"当前线程:%@"</span>,[NSThread currentThread]);</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_6"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> 没有在observer的dealloc方法中移除通知，observer销毁之后继续发送通知，无影响(从iOS <span class="number">9</span>开始，即使不移除观察者对象，程序也不会出现异常。)</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_7"</span> <span class="string">object:</span>nil];</span><br><span class="line"><span class="comment">// a对象销毁之后继续发送通知</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_7"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 多个observer监听同一个通知，所有observer的相关方法均得到调用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>b <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>c <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">10.</span> 如果notificationName为nil，object有值，则接收所有指定为object的通知</span><br><span class="line"><span class="comment">// 接收self发送的所有通知</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>nil <span class="string">object:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_9"</span> <span class="string">object:</span>self <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">11.</span> 如果notificationName为nil，且object也为nil，则接收系统内所有通知(也即YANotificationCenter发出的所有通知)</span><br><span class="line"><span class="comment">// 接收系统内所有通知，也即任意一个通知都会触发</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>nil <span class="string">object:</span>nil];</span><br><span class="line"><span class="number">12.</span> 移除所有通知后，相关方法不再调用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>@<span class="string">"Noti_10"</span> <span class="string">object:</span>nil];</span><br><span class="line"><span class="comment">// 移除所有通知后，再次发送通知没有效果</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">removeObserver:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_10"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> 移除指定通知后，相关方法不再调用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>@<span class="string">"Noti_11"</span> <span class="string">object:</span>nil];</span><br><span class="line"><span class="comment">// 移除指定通知后，再次发送通知没有效果</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">removeObserver:</span>self <span class="string">name:</span>@<span class="string">"Noti_11"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_11"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br></pre></td></tr></table></figure><h1 id="实现文件"><a href="#实现文件" class="headerlink" title="实现文件"></a>实现文件</h1><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YANotificationCenter.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, YANotificationSenderType) &#123;</span><br><span class="line">    YANotificationSenderTypeObject   = <span class="number">0</span>, <span class="comment">// 指定对象</span></span><br><span class="line">    YANotificationSenderTypeObserver = <span class="number">1</span>, <span class="comment">// 观察者</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YANotificationCenter</span>()</span></span><br><span class="line"><span class="comment">// Recorder observer.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *observerMap;</span><br><span class="line"><span class="comment">// Recorder all the selector.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *selectorMap;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YANotificationCenter</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _observerMap = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        _selectorMap = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (YANotificationCenter *)defaultCenter &#123;</span><br><span class="line">    <span class="keyword">static</span> YANotificationCenter *center = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        center = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name:(YANotificationName)aName object:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line">    <span class="keyword">if</span> (!observer) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!aName) aName = (<span class="keyword">id</span>)kCFNull;</span><br><span class="line">    <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:aName];</span><br><span class="line">    <span class="keyword">if</span> (!map) map = [<span class="built_in">NSMapTable</span> weakToStrongObjectsMapTable];</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        <span class="built_in">NSHashTable</span> *set = [map objectForKey:observer];</span><br><span class="line">        <span class="keyword">if</span> (!set || ![set isKindOfClass:[<span class="built_in">NSHashTable</span> <span class="keyword">class</span>]]) set = [<span class="built_in">NSHashTable</span> weakObjectsHashTable];</span><br><span class="line">        [set addObject:anObject];</span><br><span class="line">        [map setObject:set forKey:observer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [map setObject:(<span class="keyword">id</span>)kCFNull forKey:observer];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.observerMap setObject:map forKey:aName];</span><br><span class="line">    <span class="built_in">NSString</span> *key = generateKey(observer, anObject, aName);</span><br><span class="line">    [<span class="keyword">self</span>.selectorMap setObject:<span class="built_in">NSStringFromSelector</span>(aSelector) forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line">    [<span class="keyword">self</span> postNotificationName:aName object:anObject userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(YANotificationName)aName object:(<span class="keyword">id</span>)anObject userInfo:(<span class="built_in">NSDictionary</span> *)aUserInfo &#123;</span><br><span class="line">    <span class="comment">// When the notification name is nil.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:(<span class="keyword">id</span>)kCFNull];</span><br><span class="line">        <span class="keyword">id</span> key = <span class="literal">nil</span>;</span><br><span class="line">        <span class="built_in">NSEnumerator</span> *enumerator = map.keyEnumerator;</span><br><span class="line">        <span class="keyword">while</span> (key = [enumerator nextObject]) &#123;</span><br><span class="line">            <span class="built_in">NSHashTable</span> *set = [map objectForKey:key];</span><br><span class="line">            <span class="built_in">NSArray</span> *selectorList = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (set == (<span class="keyword">id</span>)kCFNull) &#123;</span><br><span class="line">                selectorList = <span class="keyword">self</span>.selectorMap.allValues;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([set containsObject:anObject]) &#123;</span><br><span class="line">                selectorList = selectorListForSender(<span class="keyword">self</span>, anObject, YANotificationSenderTypeObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!selectorList) <span class="keyword">break</span>;</span><br><span class="line">            [selectorList enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *selector, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">                SEL sel = <span class="built_in">NSSelectorFromString</span>(selector);</span><br><span class="line">                ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))[key methodForSelector:sel])(<span class="keyword">self</span>, sel, aUserInfo);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normal process.</span></span><br><span class="line">    <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:aName];</span><br><span class="line">    <span class="keyword">id</span> key = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSEnumerator</span> *enumerator = map.keyEnumerator;</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        <span class="keyword">while</span> (key = [enumerator nextObject]) &#123;</span><br><span class="line">            <span class="built_in">NSHashTable</span> *set = [map objectForKey:key];</span><br><span class="line">            <span class="keyword">if</span> (set == (<span class="keyword">id</span>)kCFNull || [set containsObject:anObject]) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *selector = [<span class="keyword">self</span>.selectorMap objectForKey:generateKey(key, anObject, aName)];</span><br><span class="line">                <span class="keyword">if</span> (!selector) <span class="keyword">return</span>;</span><br><span class="line">                SEL sel = <span class="built_in">NSSelectorFromString</span>(selector);</span><br><span class="line">                ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))[key methodForSelector:sel])(<span class="keyword">self</span>, sel, aUserInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (key = [enumerator nextObject]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *selector = [<span class="keyword">self</span>.selectorMap objectForKey:generateKey(key, anObject, aName)];</span><br><span class="line">            <span class="keyword">if</span> (!selector) <span class="keyword">return</span>;</span><br><span class="line">            SEL sel = <span class="built_in">NSSelectorFromString</span>(selector);</span><br><span class="line">            ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))[key methodForSelector:sel])(<span class="keyword">self</span>, sel, aUserInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.observerMap.allValues enumerateObjectsUsingBlock:^(<span class="built_in">NSMapTable</span> *map, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        [map removeObjectForKey:observer];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.selectorMap removeObjectsForKeys:selectorListForSender(<span class="keyword">self</span>, observer, YANotificationSenderTypeObserver)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer name:(YANotificationName)aName object:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line">    <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:aName];</span><br><span class="line">    <span class="comment">// Remove selector.</span></span><br><span class="line">    [<span class="keyword">self</span>.selectorMap removeObjectForKey:generateKey(observer, anObject, aName)];</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        <span class="built_in">NSHashTable</span> *set = [map objectForKey:observer];</span><br><span class="line">        [set removeObject:anObject];</span><br><span class="line">        <span class="keyword">if</span> (set.count == <span class="number">0</span>) [map removeObjectForKey:observer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [map removeObjectForKey:observer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map.count == <span class="number">0</span>) [<span class="keyword">self</span>.observerMap removeObjectForKey:aName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">NSString</span> *generateKey(<span class="keyword">id</span> observer, <span class="keyword">id</span> anObject, YANotificationName name) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p_%@_%p"</span> ,anObject, name, observer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@_%p"</span>, name, observer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">NSArray</span> *selectorListForSender(YANotificationCenter *<span class="keyword">self</span>, <span class="keyword">id</span> object, YANotificationSenderType type) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *p = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, object];</span><br><span class="line">    <span class="built_in">NSPredicate</span> *predicate = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == YANotificationSenderTypeObject) &#123;</span><br><span class="line">        predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF BEGINSWITH %@"</span>, p];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF ENDSWITH %@"</span>, p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSArray</span> *keys = [<span class="keyword">self</span>.selectorMap.allKeys filteredArrayUsingPredicate:predicate];</span><br><span class="line">    <span class="built_in">NSArray</span> *result = [<span class="keyword">self</span>.selectorMap objectsForKeys:keys notFoundMarker:(<span class="keyword">id</span>)kCFNull];</span><br><span class="line">    <span class="keyword">return</span> result.count == <span class="number">0</span> ? <span class="literal">nil</span> : result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>参考资料：<br><a href="http://southpeak.github.io/2015/03/20/cocoa-foundation-nsnotificationcenter/" target="_blank" rel="noopener">http://southpeak.github.io/2015/03/20/cocoa-foundation-nsnotificationcenter/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 自己去实现NotificationCenter。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="DIY" scheme="http://blog.chenyalun.com/categories/DIY/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Weak Associated Object</title>
    <link href="http://blog.chenyalun.com/2019/01/20/Weak%20Associated%20Object/"/>
    <id>http://blog.chenyalun.com/2019/01/20/Weak Associated Object/</id>
    <published>2019-01-20T13:22:23.000Z</published>
    <updated>2019-03-22T02:59:09.227Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 给分类添加weak属性的几种方法。 </p><br><a id="more"></a><p></p><p>众所周知，通过Runtime的关联属性来给分类添加“属性”，这里的属性缺少了严格意义上的成员变量，而且是自己手动实现了getter方法和setter方法。几种关联策略中并没有与weak效果相媲美的选项，<code>OBJC_ASSOCIATION_ASSIGN</code>策略与weak效果的主要区别在于weak自动能将指向已销毁对象的指针指为nil。</p><h1 id="危险的ASSIGN"><a href="#危险的ASSIGN" class="headerlink" title="危险的ASSIGN"></a>危险的ASSIGN</h1><p>单纯使用ASSIGN容易诱发换内存访问，原因无需多言。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">Default</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">id</span> strongObj;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span>(<span class="title">Default</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setStrongObj:(<span class="keyword">id</span>)strongObj &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(strongObj), strongObj, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)strongObj &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(strongObj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例如下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="built_in">NSObject</span> *main = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    main.strongObj = obj;</span><br><span class="line">    obj = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, main.strongObj); <span class="comment">// Crash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="极简方案"><a href="#极简方案" class="headerlink" title="极简方案"></a>极简方案</h1><p>这是一种极好的给分类添加<code>weak</code>属性的实现方式。看到这种实现方式后极为兴奋，实在太简洁、巧妙了。<code>__weak</code>本身就会把指针指向nil，那直接利用就是了。使用<code>OBJC_ASSOCIATION_COPY</code>关联策略将block copy到堆上，利用block把持有的<code>weak</code>对象返回，如果对象不存在了，返回的便是空值。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">Weak</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">id</span> object;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span>(<span class="title">Weak</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> weakObject = object;</span><br><span class="line">    <span class="keyword">id</span> (^block)(<span class="keyword">void</span>) = ^&#123; <span class="keyword">return</span> weakObject; &#125;;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(object), block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">id</span> (^block)(<span class="keyword">void</span>) = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(object));</span><br><span class="line">    <span class="keyword">return</span> (block ? block() : <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>这种方式是通过包装一个对象实现的。要求设置的关联对象是<code>YAWeakObject</code>类型。当这个对象销毁的时候调用<code>deallocBlock</code>，而在这个block中把关联的对象重新设置为<code>nil</code>(不可使用<code>objc_removeAssociatedObjects</code>直接移除关联对象)，这样访问这个关联对象的时候得到的就是nil值了。</p><p>这种方式会污染<code>weak</code>属性，要求被设置为<code>weak</code>属性的对象必须是某种类型，不是太好。当然根据这种思路，还可以进一步封装，最终的落脚点无非是提供新的方法接口替代原生的运行时方法(见参考文章)。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">WeakClass</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) YAWeakObject *weakObject;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span>(<span class="title">WeakClass</span>)</span></span><br><span class="line">- (YAWeakObject *)weakObject &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObject));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWeakObject:(YAWeakObject *)weakObject &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObject), weakObject, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    <span class="keyword">typeof</span>(<span class="keyword">self</span>) slf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="keyword">typeof</span>(slf) <span class="keyword">self</span> = slf;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObject), <span class="literal">nil</span>, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    &#125;;</span><br><span class="line">    [weakObject setDeallocBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><h1 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h1><p>实际上使用支持弱引用的容器如<code>NSHashTable</code>、<code>NSMapTable</code>、<code>NSPointerArray</code>都是可以实现的。原理很简单，使用容器持有关联的对象，当该对象不存在时，容器自身便有自动移除已销毁对象的特性，这样就实现了<code>weak</code>属性。</p><blockquote><p>NSMapTable 可以持有键和值的弱引用，当键或者值当中的一个被释放时，整个这一项就会被移除掉。<br>NSHashTable 可以持有成员的弱引用。<br>NSPointerArray 可以持有成员的弱引用，当成员不存在时自动把所在index置为NULL。</p></blockquote><p>这种做法需要创建一个容器，相对比较麻烦。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">WeakContainer</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">id</span> weakObj;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span>(<span class="title">WeakContainer</span>)</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSPointerArray</span> *gPointerArray = <span class="literal">nil</span>;</span><br><span class="line">- (<span class="keyword">id</span>)weakObj &#123;</span><br><span class="line">    <span class="keyword">if</span> (!gPointerArray) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// Removes NULL values from the receiver.(sometimes doesn't work as documented)</span></span><br><span class="line">    [gPointerArray compact];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> gPointerArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObj));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gPointerArray = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWeakObj:(<span class="keyword">id</span>)weakObj &#123;</span><br><span class="line">    <span class="keyword">if</span> (weakObj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!gPointerArray) gPointerArray = [<span class="built_in">NSPointerArray</span> weakObjectsPointerArray];</span><br><span class="line">        [gPointerArray addPointer:(__bridge <span class="keyword">void</span> *)weakObj];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObj), weakObj, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="多说一句"><a href="#多说一句" class="headerlink" title="多说一句"></a>多说一句</h1><p>有一个东西在作者的文章里看到，比较有意思。</p><h2 id="Weak-Singleton"><a href="#Weak-Singleton" class="headerlink" title="Weak Singleton"></a>Weak Singleton</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedWeakInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> __<span class="keyword">weak</span> <span class="keyword">id</span> weakObj = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> strongObj = weakObj;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strongObj) &#123;</span><br><span class="line">            strongObj = [[<span class="keyword">self</span> <span class="keyword">class</span>] new];</span><br><span class="line">            weakObj = strongObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strongObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景:不需要保存公共的信息、用户状态等，符合”用完就走”。如果类似LoginManager管理登录状态，继承自 AFHttpSessionManager的NetworkManager单例，App单例ClientManager等则不适用这种方式。</p><p>参考资料：</p><blockquote><p><a href="https://www.jianshu.com/p/ed65d71554d8" target="_blank" rel="noopener">https://www.jianshu.com/p/ed65d71554d8</a><br><a href="https://blog.csdn.net/yan_1564335/article/details/53996538" target="_blank" rel="noopener">https://blog.csdn.net/yan_1564335/article/details/53996538</a><br><a href="http://mrpeak.cn/blog/ios-weak/" target="_blank" rel="noopener">http://mrpeak.cn/blog/ios-weak/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 给分类添加weak属性的几种方法。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>「KVOController」的封装</title>
    <link href="http://blog.chenyalun.com/2019/01/12/%E3%80%8CKVOController%E3%80%8D%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://blog.chenyalun.com/2019/01/12/「KVOController」的封装/</id>
    <published>2019-01-12T13:45:10.000Z</published>
    <updated>2019-01-07T02:22:47.793Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 学习KVO的封装。 </p><br><a id="more"></a><p></p><p>KVOController源码只有700行左右，读一遍下来还是比较通畅的。这里做一个记录。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用起来极其简便。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置所观察的对象及其keyPath</span></span><br><span class="line">[<span class="keyword">self</span>.KVOController observe:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, change[<span class="built_in">NSKeyValueChangeNewKey</span>]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这里的<code>self.KVOController</code>可以自己创建，也可以使用默认，因为<code>KVOController</code>是懒加载的。</p><p>一般情况下是像上面这样使用的，还有一种情况，不需要强持有被观察者的时候：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.KVOControllerNonRetaining observe:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, change[<span class="built_in">NSKeyValueChangeNewKey</span>]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>只需使用<code>self.KVOControllerNonRetaining</code>即可不增加被观察者<code>self.myButton</code>的引用计数。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> NSObject (FBKVOController)</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) FBKVOController *KVOController;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) FBKVOController *KVOControllerNonRetaining;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>要实现以上使用的方式，是给 <code>NSObject</code> 分类添加两个属性:<code>KVOController</code>和<code>KVOControllerNonRetaining</code>。这个比较简单，使用<code>Runtime</code> 的关联属性即可。值得一提的是作者在 <code>getter</code> 方法里使用了懒加载，只有当使用到<code>KVOController</code>或者<code>KVOControllerNonRetaining</code>的时候，才会创建。当然，也可以选择自行创建。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (FBKVOController *)KVOController &#123;</span><br><span class="line">  <span class="keyword">id</span> controller = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">NSObjectKVOControllerKey</span>);</span><br><span class="line">  <span class="comment">// 懒加载KVOController, 用到时才会创建</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == controller) &#123;</span><br><span class="line">    controller = [FBKVOController controllerWithObserver:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">self</span>.KVOController = controller;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (FBKVOController *)KVOControllerNonRetaining &#123;</span><br><span class="line">  <span class="keyword">id</span> controller = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">NSObjectKVOControllerNonRetainingKey</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == controller) &#123;</span><br><span class="line">    controller = [[FBKVOController alloc] initWithObserver:<span class="keyword">self</span> retainObserved:<span class="literal">NO</span>];</span><br><span class="line">    <span class="keyword">self</span>.KVOControllerNonRetaining = controller;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个 <code>getter</code> 方法分别对应强引用被观察者和弱引用被观察者。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>由此可以看到，核心功能的实现依赖于<code>FBKVOController</code>。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)controllerWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造器</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer retainObserved:(<span class="built_in">BOOL</span>)retainObserved <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new <span class="built_in">NS_UNAVAILABLE</span>;</span><br></pre></td></tr></table></figure><p>构造方法里主要暴露了两种初始化方式，其中通过<code>initWithObserver</code>这个方法可以设置参数<code>retainObserved</code>以表明是否需要强引用被观察者。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> observer;</span><br></pre></td></tr></table></figure><p>只有一个只读属性，给出被观察者对象。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options block:(FBKVONotificationBlock)block;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options action:(SEL)action;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure><p>作者给出了回调的三个选项：block回调，选择子回调以及 KVO 默认方法回调。可以在添加被观察者的时候自行选择。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPaths options:(<span class="built_in">NSKeyValueObservingOptions</span>)options block:(FBKVONotificationBlock)block;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPaths options:(<span class="built_in">NSKeyValueObservingOptions</span>)options action:(SEL)action;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPaths options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure><p>考虑到不一定只观察一个对象的一个成员变量，因此作者提供了<code>keyPaths</code>选项，可以同时观察一个对象的多个keyPath：传入一个字符串数组即可。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="keyword">void</span>)unobserveAll;</span><br></pre></td></tr></table></figure><p>移除监听提供三种接口：移除某个对象某个keyPath 的监听，移除对某个对象的监听，取消观察者对所有对象的所有监听。</p><h1 id="FBKVOController实现"><a href="#FBKVOController实现" class="headerlink" title="FBKVOController实现"></a>FBKVOController实现</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FBKVOController</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSMapTable</span>&lt;<span class="keyword">id</span>, <span class="built_in">NSMutableSet</span>&lt;_FBKVOInfo *&gt; *&gt; *_objectInfosMap;</span><br><span class="line">  pthread_mutex_t _lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FBKVOController</code>主要维护了一个<code>NSMapTable</code>。<code>key</code> 是所观察的对象，<code>value</code> 是<code>NSMutableSet</code>类型的集合(内部元素是<code>_FBKVOInfo</code>类型)。维护一个<code>NSMapTable</code>的原因是：便于观察一个对象的多个<code>keyPath</code>，这个对象作为 <code>key</code>，这许多个<code>keyPath</code>封装成一个个<code>_FBKVOInfo</code>存入<code>NSMutableSet</code>中。另外一个成员变量<code>_lock</code>主要是保证线程安全。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer retainObserved:(<span class="built_in">BOOL</span>)retainObserved &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) &#123;</span><br><span class="line">    _observer = observer;</span><br><span class="line">    <span class="comment">// 根据是否retainObserved，选择NSMapTable的"强-强"或者"弱-强"</span></span><br><span class="line">    <span class="built_in">NSPointerFunctionsOptions</span> keyOptions = retainObserved ? <span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> : <span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span>;</span><br><span class="line">    _objectInfosMap = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:keyOptions valueOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPersonality</span> capacity:<span class="number">0</span>];</span><br><span class="line">    pthread_mutex_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FBKVOController</code>所有暴露的构造方法接口都指向了上面的那个实现。这个方法只做了三件事: 1，初始化线程锁<code>_lock</code>，2，根据<code>retainObserved</code>参数创建不同类型的<code>NSMapTable</code>，是选择”强-强”还是选择”弱-强”。3，属性<code>observer</code>赋值。</p><p>由此可见，<code>FBKVOController</code>本身对被观察者<code>observer</code>是弱引用的(有一个 <code>weak</code> 属性的<code>observer</code>成员变量)，通过维护一个<code>NSMapTable</code>来最终确定对被观察者的强弱引用关系。</p><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">observe:</span>(nullable id)object <span class="string">keyPath:</span>(NSString *)keyPath <span class="string">options:</span>(NSKeyValueObservingOptions)options <span class="string">block:</span>(FBKVONotificationBlock)block &#123;</span><br><span class="line">  <span class="keyword">if</span> (nil == object || <span class="number">0</span> == keyPath.length || NULL == block) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建数据结构_FBKVOInfo</span></span><br><span class="line">  _FBKVOInfo *info = [[_FBKVOInfo alloc] <span class="string">initWithController:</span>self <span class="string">keyPath:</span>keyPath <span class="string">options:</span>options <span class="string">block:</span>block];</span><br><span class="line">  <span class="comment">// 添加对object的观察, 并传入info</span></span><br><span class="line">  [self <span class="string">_observe:</span>object <span class="string">info:</span>info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以添加一个被观察者并且回调是 block 为例。在这个方法里首先是对参数的合理性判断，要求<code>object</code>、<code>keyPath</code>以及<code>block</code>均是合理值。<br> 接着把<code>keyPath</code>、<code>options</code>、<code>block</code>包装成一个数据结构<code>_FBKVOInfo</code>。<br> 最后调用自己的<code>_observe:info:</code>方法，传入<code>object</code>和<code>info</code>。</p><h3 id="FBKVOInfo数据结构"><a href="#FBKVOInfo数据结构" class="headerlink" title="_FBKVOInfo数据结构"></a>_FBKVOInfo数据结构</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">_FBKVOInfo </span>: NSObject</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> _FBKVOInfo &#123;</span><br><span class="line"><span class="variable">@public</span></span><br><span class="line">  __weak FBKVOController *_controller;</span><br><span class="line">  <span class="selector-tag">NSString</span> *<span class="selector-tag">_keyPath</span>;</span><br><span class="line">  <span class="selector-tag">NSKeyValueObservingOptions</span> <span class="selector-tag">_options</span>;</span><br><span class="line">  <span class="selector-tag">SEL</span> <span class="selector-tag">_action</span>;</span><br><span class="line">  <span class="selector-tag">void</span> *<span class="selector-tag">_context</span>;</span><br><span class="line">  <span class="selector-tag">FBKVONotificationBlock</span> <span class="selector-tag">_block</span>;</span><br><span class="line">  <span class="selector-tag">_FBKVOInfoState</span> <span class="selector-tag">_state</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_FBKVOInfo</code>是一个数据结构，包含了监听的<code>keyPath</code>、<code>block</code>、选择子、<code>context</code>等等元素。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithController:(FBKVOController *)controller</span><br><span class="line">                           keyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                           options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</span><br><span class="line">                             block:(<span class="keyword">nullable</span> FBKVONotificationBlock)block</span><br><span class="line">                            action:(<span class="keyword">nullable</span> SEL)action</span><br><span class="line">                           context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) &#123;</span><br><span class="line">    _controller = controller;</span><br><span class="line">    _block = [block <span class="keyword">copy</span>];</span><br><span class="line">    _keyPath = [keyPath <span class="keyword">copy</span>];</span><br><span class="line">    _options = options;</span><br><span class="line">    _action = action;</span><br><span class="line">    _context = context;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法的实现就是这样，不过有两个关键点:<code>block</code>和<code>keyPath</code>调用一下 <code>copy</code> 方法。<br><code>keyPath</code>调用一下 <code>copy</code>的原因是，这里的<code>_keyPath</code>是使用<code>__strong</code>修饰的，如果外面传进来的是不可变字符串，自然没有啥问题，可是一旦传进来一个可变字符串，如果直接赋值<code>_keyPath = keyPath;</code>，当这个可变字符串改变就会造成<code>_keyPath</code>也改变，比较容易产生不可控事件，所以调用 <code>copy</code>方法，也即是深复制浅复制的问题。</p><p>没有深复制的示例如下：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"key"</span>];</span><br><span class="line">   <span class="comment">// 假定是_keyPath = keyPath;而不是_keyPath = [keyPath copy];</span></span><br><span class="line">   _FBKVOInfo *info = [[_FBKVOInfo alloc] initWithController:<span class="keyword">self</span> keyPath:str options:<span class="built_in">NSKeyValueObservingOptionNew</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">       </span><br><span class="line">   &#125; action:<span class="keyword">@selector</span>(push) context:<span class="literal">nil</span>];</span><br><span class="line">   [str appendString:<span class="string">@"new"</span>];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, info-&gt;_keyPath); <span class="comment">//info-&gt;_keyPath不符合预期的改变了</span></span><br></pre></td></tr></table></figure><p>同样，<code>block</code> 的<code>copy</code>是把<code>block</code>从栈拷贝到堆中，防止被释放。因为<code>block</code>作为参数传入函数不会被 <code>copy</code>，依然在栈上，方法执行完立即释放的。</p><blockquote><p>在ARC下：大部分情况下系统会把Block自动copy到堆上。</p><p>Block作为变量：<br>方法中声明一个 block 的时候是在栈上；<br>引用了外部局部变量或成员变量, 并且有赋值操作（有名字），会被 copy 到堆上；<br>赋值给附有__strong修饰符的id类型的类或者Blcok类型成员变量时；<br>赋值给一个 weak 变量不会被 copy；</p><p>Block作为属性：<br>用 copy 修饰会被 copy；</p><p>Block作为函数参数：<br>作为参数传入函数不会被 copy，依然在栈上，方法执行完即释放；<br>作为函数的返回值会被 copy 到堆；</p></blockquote><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">  <span class="keyword">return</span> [_keyPath hash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)<span class="keyword">object</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nil == <span class="keyword">object</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self == <span class="keyword">object</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (![<span class="keyword">object</span> isKindOfClass:[self <span class="class"><span class="keyword">class</span>]]) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [_keyPath isEqualToString:((_FBKVOInfo *)<span class="keyword">object</span>)-&gt;_keyPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_FBKVOInfo</code>还做了一点其他的事：<br>1.重写了<code>- (NSUInteger)hash;</code>方法，使用<code>_keyPath</code>的 <code>hash</code> 值来作为<code>_FBKVOInfo</code>的 <code>hash</code> 值。分配的这个<code>hash</code>值(即用于查找集合中成员的位置标识)，就是通过<code>hash</code>方法计算得来的，且<code>hash</code>方法返回的<code>hash</code>值最好唯一。<br>2.重写了<code>- (BOOL)isEqual:(id)object;</code>方法，满足<code>Equal</code>的条件有两个: 首先是类对象一致，再者是<code>_keyPath</code>匹配。换句话说，<code>_keyPath</code>决定了<code>_FBKVOInfo</code>是否是同一个。为了优化判等的效率，基于<code>hash</code>的<code>NSSet</code>和<code>NSDictionary</code>在判断成员是否相等时， 会这样做Step1: 成员的<code>hash</code>值是否和目标<code>hash</code>值相等，如果相同进入Step 2，如果不等，直接判断不相等<br>Step 2: <code>hash</code>值相同(即Step 1)的情况下，再进行对象判等， 作为判等的结果。</p><blockquote><p>hash值是对象判等的必要非充分条件</p></blockquote><p><code>NSPointerFunctionsObjectPointerPersonality</code>对于 <code>isEqual:</code> 和 <code>hash</code> 使用直接的指针比较。使用移位指针(shifted pointer)来做hash检测及确定两个对象是否相等；同时使用description方法来做描述字符串。</p><blockquote><p>Personalities determine hashing and equality. NSPointerFunctionsObjectPersonality provides the standard Foundation behavior of using hash and isEqual:. You can also use NSPointerFunctionsObjectPointerPersonality, which treats the contents as objects, but uses direct pointer value comparison; this is useful if you need a collection to work with object identity rather than value.<br>NSPointerFunctionsObjectPointerPersonality 使用 <code>==</code>判断相等<br>NSPointerFunctionsObjectPersonality 使用<code>hash</code>和<code>isEqual:</code>判断相等 </p></blockquote><h3 id="observe-info-方法"><a href="#observe-info-方法" class="headerlink" title="_observe:info:方法"></a>_observe:info:方法</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)<span class="variable">_observe</span>:(id)object info:(<span class="variable">_FBKVOInfo</span> *)info &#123;</span><br><span class="line">  <span class="comment">// lock</span></span><br><span class="line">  pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">  NSMutableSet *infos = [<span class="variable">_objectInfosMap</span> objectForKey:object];</span><br><span class="line">  <span class="comment">// 检查infos是否存在于_objectInfosMap中</span></span><br><span class="line">  <span class="variable">_FBKVOInfo</span> *existingInfo = [infos member:info];</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != existingInfo) &#123;</span><br><span class="line">    <span class="comment">// 已经存在了，return</span></span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不存在，创建infos并保存于_objectInfosMap中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == infos) &#123;</span><br><span class="line">    infos = [NSMutableSet <span class="built_in">set</span>];</span><br><span class="line">    [<span class="variable">_objectInfosMap</span> setObject:infos forKey:object];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把info添加到infos中</span></span><br><span class="line">  [infos addObject:info];</span><br><span class="line">  pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">  <span class="comment">// _FBKVOSharedController添加观察</span></span><br><span class="line">  [[<span class="variable">_FBKVOSharedController</span> sharedController] observe:object info:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先加锁。把被观察的对象<code>object</code>作为<code>key</code>从自己的<code>_objectInfosMap</code>获取其对应的<code>NSMutableSet</code>类型的集合，如果这个集合包含了已经封装好的<code>info</code>对象，说明已经对这个<code>info</code>添加过监听了，解锁直接 return 就是了。<br>如果这个<code>infos</code>集合不存在，创建。把<code>info</code>元素添加到这个<code>infos</code>集合中。解锁。调用<code>[[_FBKVOSharedController sharedController] observe:object info:info];</code>方法。</p><p>可见这个方法主要是使用<code>_objectInfosMap</code>保存了封装好的<code>info</code>对象，具体监听调用逻辑依赖于<code>_FBKVOSharedController</code>。</p><h1 id="FBKVOSharedController实现"><a href="#FBKVOSharedController实现" class="headerlink" title="_FBKVOSharedController实现"></a>_FBKVOSharedController实现</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_FBKVOSharedController</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedController;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">id</span>)object info:(<span class="keyword">nullable</span> _FBKVOInfo *)info;</span><br><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">id</span>)object info:(<span class="keyword">nullable</span> _FBKVOInfo *)info;</span><br><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">id</span>)object infos:(<span class="keyword">nullable</span> <span class="built_in">NSSet</span> *)infos;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_FBKVOSharedController</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSHashTable</span>&lt;_FBKVOInfo *&gt; *_infos;</span><br><span class="line">  pthread_mutex_t _mutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_FBKVOSharedController</code>是一个单例。作用是观察 <code>_FBKVOInfo</code> 中的 <code>keyPath</code>，并给予回调(回调的类型可以是 <code>block</code>、<code>selector</code>、系统回调方法)。</p><p> 暴露出两个方法:</p><ol><li>添加监听，参数为<code>_infos</code></li><li><p>移除监听，参数为<code>_FBKVOInfo</code>或者<code>NSSet</code>类型的<code>infos</code>(容器内的元素仍然是<code>_FBKVOInfo</code>)</p><p>内部维护了一个哈希表(NSHashTable)<code>_infos</code>，用于保存这些<code>_FBKVOInfo</code>。除此之外还有一个锁:<code>_mutex</code>，用于实现线程安全。</p><p>哈希表的创建:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSHashTable</span> *infos = [<span class="built_in">NSHashTable</span> alloc];</span><br><span class="line">_infos = [infos initWithOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> capacity:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSPointerFunctionsWeakMemory</span>: 持弱指针引用着_FBKVOInfo对象。</span><br><span class="line"><span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> 使用==判定相等。</span><br></pre></td></tr></table></figure></li></ol><p>可见<code>_FBKVOSharedController</code>只是单纯地掌管<code>_FBKVOInfo</code>集合，它只需要解析<code>_FBKVOInfo</code>并给observer回调即可，其他的一切都不关心。</p><h2 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">observe:</span>(id)object <span class="string">info:</span>(nullable _FBKVOInfo *)info &#123;</span><br><span class="line">  <span class="keyword">if</span> (nil == info) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// _infos添加对象</span></span><br><span class="line">  pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">  [_infos <span class="string">addObject:</span>info];</span><br><span class="line">  pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">  <span class="comment">// 添加观察，传入的context是info</span></span><br><span class="line">  [object <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>info-&gt;_keyPath <span class="string">options:</span>info-&gt;_options <span class="string">context:</span>(<span class="keyword">void</span> *)info];</span><br><span class="line">  <span class="keyword">if</span> (info-&gt;_state == _FBKVOInfoStateInitial) &#123;</span><br><span class="line">    info-&gt;_state = _FBKVOInfoStateObserving; <span class="comment">// 初始状态转监听状态</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;_state == _FBKVOInfoStateNotObserving) &#123; <span class="comment">// 未监听状态便移除</span></span><br><span class="line">    <span class="comment">// this could happen when `NSKeyValueObservingOptionInitial` is one of the NSKeyValueObservingOptions,</span></span><br><span class="line">    <span class="comment">// and the observer is unregistered within the callback block.</span></span><br><span class="line">    <span class="comment">// at this time the object has been registered as an observer (in Foundation KVO),</span></span><br><span class="line">    <span class="comment">// so we can safely unobserve it.</span></span><br><span class="line">    <span class="comment">// NSKeyValueObservingOptionInitial：添加观察者时就触发回调，并且在后面赋值时也会触发回调，但是都只返回NSKeyValueChangeKindKey。观察者在callback block中取消观察，所以在这里removeObserver</span></span><br><span class="line">    [object <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>info-&gt;_keyPath <span class="string">context:</span>(<span class="keyword">void</span> *)info];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器中添加 info 元素，添加监听。</p><h2 id="移除监听"><a href="#移除监听" class="headerlink" title="移除监听"></a>移除监听</h2><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)unobserve:(id)object info:(nullable <span class="variable">_FBKVOInfo</span> *)info &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == info) return;</span><br><span class="line">  <span class="comment">// 哈希表中移除info</span></span><br><span class="line">  pthread_mutex_lock(&amp;<span class="variable">_mutex</span>);</span><br><span class="line">  [<span class="variable">_infos</span> removeObject:info];</span><br><span class="line">  pthread_mutex_unlock(&amp;<span class="variable">_mutex</span>);</span><br><span class="line">  <span class="comment">// 移除监听</span></span><br><span class="line">  <span class="keyword">if</span> (info-&gt;<span class="variable">_state</span> == <span class="variable">_FBKVOInfoStateObserving</span>) &#123;</span><br><span class="line">    [object removeObserver:self forKeyPath:info-&gt;<span class="variable">_keyPath</span> context:(void *)info];</span><br><span class="line">  &#125;</span><br><span class="line">  info-&gt;<span class="variable">_state</span> = <span class="variable">_FBKVOInfoStateNotObserving</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器中移除 info 元素，移除监听。</p><h2 id="系统KVO调用"><a href="#系统KVO调用" class="headerlink" title="系统KVO调用"></a>系统KVO调用</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change</span><br><span class="line">                       context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context &#123;</span><br><span class="line">  _FBKVOInfo *info;</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    <span class="comment">// 看看info是否存在于_infos中，如果存在，返回info</span></span><br><span class="line">    info = [_infos member:(__bridge <span class="keyword">id</span>)context];</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != info) &#123;</span><br><span class="line">    <span class="comment">// 局部变量强引用controller</span></span><br><span class="line">    FBKVOController *controller = info-&gt;_controller;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != controller) &#123;</span><br><span class="line">      <span class="comment">// 局部变量强引用observer</span></span><br><span class="line">      <span class="keyword">id</span> observer = controller.observer;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">nil</span> != observer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;_block) &#123;  <span class="comment">// 回调 block</span></span><br><span class="line">          <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *changeWithKeyPath = change;</span><br><span class="line">          <span class="keyword">if</span> (keyPath) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *mChange = [<span class="built_in">NSMutableDictionary</span> dictionaryWithObject:keyPath forKey:FBKVONotificationKeyPathKey];</span><br><span class="line">            [mChange addEntriesFromDictionary:change];</span><br><span class="line">            changeWithKeyPath = [mChange <span class="keyword">copy</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          info-&gt;_block(observer, object, changeWithKeyPath);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;_action) &#123; <span class="comment">// 回调 selector</span></span><br><span class="line">          [observer performSelector:info-&gt;_action withObject:change withObject:object];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 调用KVO 系统方法</span></span><br><span class="line">          [observer observeValueForKeyPath:keyPath ofObject:object change:change context:info-&gt;_context];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终在系统方法中给予不同类型的回调。</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(uint8_t, <span class="variable">_FBKVOInfoState</span>) &#123;</span><br><span class="line">  <span class="variable">_FBKVOInfoStateInitial</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="variable">_FBKVOInfoStateObserving</span>,</span><br><span class="line">  <span class="variable">_FBKVOInfoStateNotObserving</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作者使用了三个枚举值来记录监听状态。会不会是多此一举呢？不会。作用主要体现在添加监听的方法里有个移除监听操作：</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 添加观察，传入的context是info</span></span><br><span class="line">[<span class="function"><span class="title">object</span> addObserver:self forKeyPath:info-&gt;</span>_<span class="function"><span class="title">keyPath</span> options:info-&gt;</span>_options context:(void *)info];</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="title">if</span> (info-&gt;</span>_state == _FBKVOInfoStateInitial) &#123;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>_state = _FBKVOInfoStateObserving; <span class="comment">// 初始状态转监听状态</span></span><br><span class="line">  &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (info-&gt;</span>_state == _FBKVOInfoStateNotObserving) &#123; <span class="comment">// 未监听状态便移除</span></span><br><span class="line">    [<span class="function"><span class="title">object</span> removeObserver:self forKeyPath:info-&gt;</span>_keyPath context:(void *)info];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>“未监听状态便移除“是怎么出现的？示例如下：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.KVOController observe:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span> options:<span class="built_in">NSKeyValueObservingOptionInitial</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">     [<span class="keyword">self</span>.KVOController unobserve:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>包含了<code>NSKeyValueObservingOptionInitial</code>选项且在回调中移除了监听就会出现这种情况。因为如果有<code>NSKeyValueObservingOptionInitial</code>选项，在添加监听的时候就会有回调。调用栈如下：<br><img src="https://image.chenyalun.com/2019/01/07/001.png" alt=""></p><p>执行到<code>[object addObserver:self forKeyPath:info-&gt;_keyPath options:info-&gt;_options context:(void *)info];</code>这行代码的时候，首先添加监听，接着调用回调，而回调中又移除了观察，这时info的状态被设置为<code>_FBKVOInfoStateNotObserving</code>。接着进入了下面的 if-else 判断中，才有了移除监听的操作。可见逻辑非常严谨。</p><p>NSKeyValueObservingOption参考：</p><blockquote><p>NSKeyValueObservingOptionNew：接收方法中使用change参数传入变化后的新值，键为：&gt;NSKeyValueChangeNewKey；<br>NSKeyValueObservingOptionOld：接收方法中使用change参数传入变化前的旧值，键为：&gt;NSKeyValueChangeOldKey；<br>NSKeyValueObservingOptionInitial：注册之后立刻调用接收方法，如果配置了&gt;NSKeyValueObservingOptionNew，change参数内容会包含新值，键为：&gt;NSKeyValueChangeNewKey；<br>NSKeyValueObservingOptionPrior：如果加入这个参数，接收方法会在变化前后分别调用一次，共两&gt;次，变化前的通知change参数包含notificationIsPrior = 1。其他内容根据&gt;NSKeyValueObservingOptionNew和NSKeyValueObservingOptionOld的配置确定。</p></blockquote><h1 id="一个函数"><a href="#一个函数" class="headerlink" title="一个函数"></a>一个函数</h1><p>其实不是一个函数，不过是为了实现一个功能，核心还是一个函数。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.枚举字符串化</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *describe_option(<span class="built_in">NSKeyValueObservingOptions</span> option) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionNew</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionNew"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionOld</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionOld"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionInitial</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionInitial"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionPrior</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionPrior"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"unexpected option %tu"</span>, option);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.拼接option</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> append_option_description(<span class="built_in">NSMutableString</span> *s, <span class="built_in">NSUInteger</span> option) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == s.length) &#123;</span><br><span class="line">        [s appendString:describe_option(option)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [s appendString:<span class="string">@"|"</span>];</span><br><span class="line">        [s appendString:describe_option(option)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.NSKeyValueObservingOptions类型值遍历</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSUInteger</span> enumerate_flags(<span class="built_in">NSUInteger</span> *ptrFlags) &#123;</span><br><span class="line">    <span class="built_in">NSCAssert</span>(ptrFlags, <span class="string">@"expected ptrFlags"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ptrFlags) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> flags = *ptrFlags;</span><br><span class="line">    <span class="keyword">if</span> (!flags)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> flag = <span class="number">1</span> &lt;&lt; __builtin_ctzl(flags);</span><br><span class="line">    flags &amp;= ~flag;</span><br><span class="line">    *ptrFlags = flags;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.把options所有值都拼出来</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *describe_options(<span class="built_in">NSKeyValueObservingOptions</span> options) &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *s = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    <span class="built_in">NSUInteger</span> option;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != (option = enumerate_flags(&amp;options))) &#123;</span><br><span class="line">        append_option_description(s, option);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不使用 switch-case 把位移枚举的值遍历出来了。</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Similar to __builtin_ctz, except the argument type is unsigned long.</span></span><br><span class="line"><span class="comment">// __builtin_ctz(x)：x末尾0的个数</span></span><br><span class="line"><span class="comment">// 左移__builtin_ctz(x)位得到原先的枚举值</span></span><br><span class="line">NSUInteger flag = <span class="number">1</span> &lt;&lt; __builtin_ctzl(<span class="keyword">flags</span>);</span><br><span class="line"><span class="comment">// flags 去除已经取到的值</span></span><br><span class="line"><span class="keyword">flags</span> &amp;= ~flag;</span><br><span class="line"><span class="comment">// 把更新后的flags赋予指向ptrFlags的指针</span></span><br><span class="line">*ptrFlags = <span class="keyword">flags</span>;</span><br></pre></td></tr></table></figure><p>不失为一个好办法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>使用 KVOController 进行键值观测可以说完美地解决了在使用原生 KVO 时遇到的各种问题。</p><p>1.不需要手动移除观察者；<br>2.实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；<br>3.使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；<br>4.每一个 keyPath 会对应一个属性，不需要在 block 中使用 if 判断 keyPath；</p></blockquote><p>以上引自draveness。解释如下：<br>1.NSMapTable 可以持有键和值的弱引用，当键或者值当中的一个被释放时，整个这一项就会被移除掉。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里使用被观察者observer作为强引用或者弱引用的key，使用_FBKVOInfo作为强引用的value</span></span><br><span class="line"><span class="built_in">NSPointerFunctionsOptions</span> keyOptions = retainObserved ? <span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> : <span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span>;</span><br><span class="line">_objectInfosMap = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:keyOptions valueOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPersonality</span> capacity:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>2.因为是在@selector(observeValueForKeyPath:ofObject:change:context:)中处理的回调。<br>3.使用FBKVONotificationBlock。<br>4._FBKVOInfo封装。</p><p>纵观全部代码，作者首先给分类添加了两个属性，用于接口调用。这些属性都指向了FBKVOController，FBKVOController主要维护了一个NSMapTable。key 是所观察的对象，value 是NSMutableSet类型的集合，其内部元素是_FBKVOInfo类型对象。一个_FBKVOInfo对象对应一个信息封装。之所以使用NSMapTable集合是便于对同一个对象的多个keyPath进行观察，同时处理被观察者的强弱引用。另外_FBKVOInfo对象是对FBKVOController、keyPath、context、回调block等信息的封装。最后，各个FBKVOController把所有对观察的处理交给单例_FBKVOSharedController，这个单例调用系统KVO方法回调、处理包含所有_FBKVOInfo对象的NSHashTable集合。</p><blockquote><p>参考资料<br><a href="https://github.com/draveness/analyze/blob/master/contents/KVOController/KVOController.md" target="_blank" rel="noopener">https://github.com/draveness/analyze/blob/master/contents/KVOController/KVOController.md</a><br><a href="https://blog.csdn.net/DonnyDN/article/details/77750751" target="_blank" rel="noopener">https://blog.csdn.net/DonnyDN/article/details/77750751</a><br><a href="https://www.jianshu.com/p/915356e280fc" target="_blank" rel="noopener">https://www.jianshu.com/p/915356e280fc</a><br><a href="https://blog.kyleduo.com/2014/10/20/ios_learning-kvo/" target="_blank" rel="noopener">https://blog.kyleduo.com/2014/10/20/ios_learning-kvo/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 学习KVO的封装。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>读「YYCache」</title>
    <link href="http://blog.chenyalun.com/2019/01/02/%E8%AF%BB%E3%80%8CYYCache%E3%80%8D/"/>
    <id>http://blog.chenyalun.com/2019/01/02/读「YYCache」/</id>
    <published>2019-01-02T07:22:17.000Z</published>
    <updated>2019-01-02T08:45:11.457Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 关于YYCache的简单总结。 </p><br><a id="more"></a><p></p><p>阅读YYCache源码有3遍了，自我感觉“需要理解”的部分掌握的差不多了，做个记录。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>API 类似字典，比较容易理解。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYMemoryCache *memoryCache;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYDiskCache *diskCache;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)cacheWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)cacheWithPath:(<span class="built_in">NSString</span> *)path;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</span><br></pre></td></tr></table></figure><h4 id="是否存在"><a href="#是否存在" class="headerlink" title="是否存在"></a>是否存在</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block;</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object))block;</span><br></pre></td></tr></table></figure><h4 id="设值"><a href="#设值" class="headerlink" title="设值"></a>设值</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br></pre></td></tr></table></figure><h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key))block;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</span><br></pre></td></tr></table></figure><h1 id="YYCache-实现"><a href="#YYCache-实现" class="headerlink" title="YYCache 实现"></a>YYCache 实现</h1><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYCache</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>) init &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Use \"initWithName\" or \"initWithPath\" to create YYCache instance."</span>);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:<span class="string">@""</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *cacheFolder = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) firstObject];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [cacheFolder stringByAppendingPathComponent:name];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    YYDiskCache *diskCache = [[YYDiskCache alloc] initWithPath:path];</span><br><span class="line">    <span class="keyword">if</span> (!diskCache) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *name = [path lastPathComponent];</span><br><span class="line">    YYMemoryCache *memoryCache = [YYMemoryCache new];</span><br><span class="line">    memoryCache.name = name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    _name = name;</span><br><span class="line">    _diskCache = diskCache;</span><br><span class="line">    _memoryCache = memoryCache;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)cacheWithName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithName:name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)cacheWithPath:(<span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithPath:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [_memoryCache containsObjectForKey:key] || [_diskCache containsObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (!block) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([_memoryCache containsObjectForKey:key]) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">            block(key, <span class="literal">YES</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">        [_diskCache containsObjectForKey:key withBlock:block];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object = [_memoryCache objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">        object = [_diskCache objectForKey:key];</span><br><span class="line">        <span class="keyword">if</span> (object) &#123;</span><br><span class="line">            [_memoryCache setObject:object forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (!block) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object = [_memoryCache objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (object) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">            block(key, object);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [_diskCache objectForKey:key withBlock:^(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object) &#123;</span><br><span class="line">            <span class="keyword">if</span> (object &amp;&amp; ![_memoryCache objectForKey:key]) &#123;</span><br><span class="line">                [_memoryCache setObject:object forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            block(key, object);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    [_memoryCache setObject:object forKey:key];</span><br><span class="line">    [_diskCache setObject:object forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    [_memoryCache setObject:object forKey:key];</span><br><span class="line">    [_diskCache setObject:object forKey:key withBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    [_memoryCache removeObjectForKey:key];</span><br><span class="line">    [_diskCache removeObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span> *key))block &#123;</span><br><span class="line">    [_memoryCache removeObjectForKey:key];</span><br><span class="line">    [_diskCache removeObjectForKey:key withBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</span><br><span class="line">    [_memoryCache removeAllObjects];</span><br><span class="line">    [_diskCache removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    [_memoryCache removeAllObjects];</span><br><span class="line">    [_diskCache removeAllObjectsWithBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</span><br><span class="line">                                 endBlock:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end &#123;</span><br><span class="line">    [_memoryCache removeAllObjects];</span><br><span class="line">    [_diskCache removeAllObjectsWithProgressBlock:progress endBlock:end];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="keyword">if</span> (_name) <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p&gt; (%@)"</span>, <span class="keyword">self</span>.class, <span class="keyword">self</span>, _name];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p&gt;"</span>, <span class="keyword">self</span>.class, <span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>整体来看还是比较容易理解的，YYCache 整合了内存缓存和磁盘缓存，主要做了这些事：</p><ol><li>初始化YYCache实例，要求缓存路径要合理。</li><li>查询缓存对象先从内存缓存中查找，如果没有，再从磁盘缓存中查找。当磁盘缓存中有而内存缓存中没有的时候，把取得的缓存对象保存在内存缓存中。</li><li>缓存对象的存取和移除，内存缓存和磁盘缓存两者保持同步。</li></ol><h2 id="YYMemoryCache-实现"><a href="#YYMemoryCache-实现" class="headerlink" title="YYMemoryCache 实现"></a>YYMemoryCache 实现</h2><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nullable, copy) NSString *name;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>(readonly) NSUInteger totalCount;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>(readonly) NSUInteger totalCost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#pragma mark - Limit</span></span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>NSUInteger countLimit;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>NSUInteger costLimit;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>NSTimeInterval ageLimit;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>NSTimeInterval autoTrimInterval;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>BOOL shouldRemoveAllObjectsOnMemoryWarning;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>BOOL shouldRemoveAllObjectsWhenEnteringBackground;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nullable, copy) void(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nullable, copy) void(^didEnterBackgroundBlock)(YYMemoryCache *cache);</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>BOOL releaseOnMainThread;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>BOOL releaseAsynchronously;</span><br></pre></td></tr></table></figure><p>类似于NSCache，提供包括缓存数量、缓存花费、缓存时间的管理。除此之外，当接收到内存警告时<code>(shouldRemoveAllObjectsOnMemoryWarning)</code>或者 App 进入到后台时<code>(shouldRemoveAllObjectsWhenEnteringBackground)</code>可以选择释放缓存对象。而对缓存对象释放也可以进行控制，比如可以选择在主线程释放<code>(releaseOnMainThread)</code>或者异步释放<code>(releaseAsynchronously)</code>。</p><h4 id="存取接口"><a href="#存取接口" class="headerlink" title="存取接口"></a>存取接口</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</span><br></pre></td></tr></table></figure><p> 除了基本的存取方法之外，YYMemoryCache 还暴露了三个移除缓存对象的方法。<br> trimToCount：根据限制的数量(countLimit)进行移除缓存对象操作，直到满足数量限制要求。<br> trimToCost：根据限制的花费(costLimit)进行移除缓存对象操作，直到满足花费限制要求。<br> trimToAge：根据缓存对象的过期时间(ageLimit)进行移除缓存对象操作，直到满足要求。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>在具体实现中，作者考虑了以下要求:</p><ol><li>缓存对象的存取。要保证效率就要求存取时间复杂度最好是O(1)。</li><li>缓存对象的移除。要保证能按照 <code>cost、age、count</code> 等条件对所有不符合要求的对象进行移除。</li><li>线程安全。需要加锁。<br>第一条：要求时间复杂度是 O(1)，那就可以采用哈希表、字典等。作者使用了字典，且是效率更高的<code>CFMutableDictionaryRef</code>。<br>第二条：记录 <code>cost、age、count</code>等属性，肯定需要对缓存对象进行包装。再者需要考虑LRU(Least Recently Used)，就需要保证顺序。而要使得字典中的对象(value)有顺序，必须有一个指向其他对象的指针(属性）。可以使用双向链表包装缓存对象。<br>第三条：存取的线程安全，使用GCD线程锁。</li></ol><h5 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h5><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">@interface <span class="variable">_YYLinkedMapNode</span> : NSObject &#123;</span><br><span class="line">    @package</span><br><span class="line">    <span class="variable">__unsafe_unretained</span> <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_prev</span>; <span class="comment">// retained by dic</span></span><br><span class="line">    <span class="variable">__unsafe_unretained</span> <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_next</span>; <span class="comment">// retained by dic</span></span><br><span class="line">    id <span class="variable">_key</span>;</span><br><span class="line">    id <span class="variable">_value</span>;</span><br><span class="line">    NSUInteger <span class="variable">_cost</span>;</span><br><span class="line">    NSTimeInterval <span class="variable">_time</span>;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>链表的结点中保存着key 和 value，这是对缓存对象的包装。_cost和_time记录着缓存对象的花费和过期时间。而使用<strong>unsafe_unretained修饰的_prev和_next则分别指向前一个对象和后一个对象。由于这些结点已经被字典持有了，所以直接使用</strong>unsafe_unretained修饰，不必再增加它的引用计数，提高效率。</p><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"> @interface <span class="variable">_YYLinkedMap</span> : NSObject &#123;</span><br><span class="line">    @package</span><br><span class="line">    CFMutableDictionaryRef <span class="variable">_dic</span>; <span class="comment">// do not set object directly</span></span><br><span class="line">    NSUInteger <span class="variable">_totalCost</span>;</span><br><span class="line">    NSUInteger <span class="variable">_totalCount</span>;</span><br><span class="line">    <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_head</span>; <span class="comment">// MRU, do not change it directly</span></span><br><span class="line">    <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_tail</span>; <span class="comment">// LRU, do not change it directly</span></span><br><span class="line">    BOOL <span class="variable">_releaseOnMainThread</span>;</span><br><span class="line">    BOOL <span class="variable">_releaseAsynchronously</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)insertNodeAtHead:(<span class="variable">_YYLinkedMapNode</span> *)node;</span><br><span class="line">- (void)bringNodeToHead:(<span class="variable">_YYLinkedMapNode</span> *)node;</span><br><span class="line">- (void)removeNode:(<span class="variable">_YYLinkedMapNode</span> *)node;</span><br><span class="line">- (<span class="variable">_YYLinkedMapNode</span> *)removeTailNode;</span><br><span class="line">- (void)removeAll;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>一个 <code>YYMemoryCache</code> 对象有一个链表。这个链表使用<code>_dic</code>保存着所有包装好的缓存对象(<code>_YYLinkedMapNode</code>)，记录着总的花费(<code>_totalCost</code>)和总的数量(<code>_totalCount</code>)。当然，还使用<code>_head</code>指着链表的头指针，使用<code>_tail</code>指着链表的尾指针。<code>_releaseOnMainThread</code>和<code>_releaseAsynchronously</code>用于设置对缓存对象释放操作的选项:主线程释放或者异步释放。</p><p><code>_YYLinkedMap</code>暴露出的五个方法很清晰地表明它的作用：每次当缓存取到某个对象时，把它置在头结点的位置。这样随着时间的推移，很轻松地使得那些不经常使用的对象处在链表的后端，经常使用的对象处在链表的前端，这样就实现了 <code>LRU</code>。</p><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">- (void)insertNodeAtHead:(_YYLinkedMapNode *)<span class="keyword">node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    CFDictionarySetValue</span>(_dic, (__bridge const void *)(<span class="keyword">node</span><span class="title">-&gt;_key</span>), (__bridge const void *)(<span class="keyword">node</span><span class="title">));</span></span><br><span class="line"><span class="title">    _totalCost</span> += <span class="keyword">node</span><span class="title">-&gt;_cost</span>;</span><br><span class="line">    _totalCount++;</span><br><span class="line">    if (_head) &#123;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;_next</span> = _head;</span><br><span class="line">        _head-&gt;_prev = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">        _head</span> = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125; else</span> &#123;</span><br><span class="line">        _head = _tail = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">- (void</span>)bringNodeToHead:(_YYLinkedMapNode *)<span class="keyword">node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    if</span> (_head == <span class="keyword">node</span><span class="title">) return</span>;</span><br><span class="line">    </span><br><span class="line">    if (_tail == <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">        _tail</span> = <span class="keyword">node</span><span class="title">-&gt;_prev</span>;</span><br><span class="line">        _tail-&gt;_next = nil;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;_next-</span>&gt;_prev = <span class="keyword">node</span><span class="title">-&gt;_prev</span>;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;_prev-</span>&gt;_next = <span class="keyword">node</span><span class="title">-&gt;_next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">node</span><span class="title">-&gt;_next</span> = _head;</span><br><span class="line">    <span class="keyword">node</span><span class="title">-&gt;_prev</span> = nil;</span><br><span class="line">    _head-&gt;_prev = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    _head</span> = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">- (void</span>)removeNode:(_YYLinkedMapNode *)<span class="keyword">node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    CFDictionaryRemoveValue</span>(_dic, (__bridge const void *)(<span class="keyword">node</span><span class="title">-&gt;_key</span>));</span><br><span class="line">    _totalCost -= <span class="keyword">node</span><span class="title">-&gt;_cost</span>;</span><br><span class="line">    _totalCount--;</span><br><span class="line">    if (<span class="keyword">node</span><span class="title">-&gt;_next</span>) <span class="keyword">node</span><span class="title">-&gt;_next-</span>&gt;_prev = <span class="keyword">node</span><span class="title">-&gt;_prev</span>;</span><br><span class="line">    if (<span class="keyword">node</span><span class="title">-&gt;_prev</span>) <span class="keyword">node</span><span class="title">-&gt;_prev-</span>&gt;_next = <span class="keyword">node</span><span class="title">-&gt;_next</span>;</span><br><span class="line">    if (_head == <span class="keyword">node</span><span class="title">) _head</span> = <span class="keyword">node</span><span class="title">-&gt;_next</span>;</span><br><span class="line">    if (_tail == <span class="keyword">node</span><span class="title">) _tail</span> = <span class="keyword">node</span><span class="title">-&gt;_prev</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (_YYLinkedMapNode *)removeTailNode &#123;</span><br><span class="line">    if (!_tail) return nil;</span><br><span class="line">    _YYLinkedMapNode *tail = _tail;</span><br><span class="line">    CFDictionaryRemoveValue(_dic, (__bridge const void *)(_tail-&gt;_key));</span><br><span class="line">    _totalCost -= _tail-&gt;_cost;</span><br><span class="line">    _totalCount--;</span><br><span class="line">    if (_head == _tail) &#123;</span><br><span class="line">        _head = _tail = nil;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _tail = _tail-&gt;_prev;</span><br><span class="line">        _tail-&gt;_next = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对结点的插入、移除、调整位置，是数据结构的基础操作。令人怀念！</p><p><code>_releaseOnMainThread</code>和<code>_releaseAsynchronously</code>这两个选项的实现也很简单。作者自己维护了一个队列:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> dispatch_queue_t <span class="title">YYMemoryCacheGetReleaseQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除的时候有所判断：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">CFMutableDictionaryRef</span> holder = _dic;</span><br><span class="line">      _dic = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> (_releaseAsynchronously) &#123;</span><br><span class="line">          <span class="built_in">dispatch_queue_t</span> queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">          <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">              <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">CFRelease</span>(holder);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>要求异步要求主线程：那就在主线程异步释放holder。关于这里使用一个holder的原因，下文有解释。</p><h4 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">@implementation YYMemoryCache &#123;</span><br><span class="line">    pthread_mutex_t _lock<span class="comment">;</span></span><br><span class="line">    _YYLinkedMap *_lru<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t </span>_queue<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出<code>YYMemoryCache</code>使用<code>pthread_mutex_t</code>保证线程安全。</p><p>最关键的还是对无效缓存对象的释放，以 <code>count</code> 为例，当缓存的对象数量超过了 <code>count</code> 限制，就需要对链表后端不常使用的缓存对象进行移除操作，直到满足 <code>count</code> 限制。</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)<span class="variable">_trimToCount</span>:(NSUInteger)countLimit &#123;</span><br><span class="line">    BOOL finish = NO;</span><br><span class="line">    pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    <span class="keyword">if</span> (countLimit == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="variable">_lru</span> removeAll];</span><br><span class="line">        finish = YES;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_totalCount</span> &lt;= countLimit) &#123;</span><br><span class="line">        finish = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    <span class="keyword">if</span> (finish) return;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *holder = [NSMutableArray new];</span><br><span class="line">    <span class="keyword">while</span> (!finish) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;<span class="variable">_lock</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_totalCount</span> &gt; countLimit) &#123;</span><br><span class="line">                <span class="variable">_YYLinkedMapNode</span> *node = [<span class="variable">_lru</span> removeTailNode];</span><br><span class="line">                <span class="keyword">if</span> (node) [holder addObject:node];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finish = YES;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder.<span class="built_in">count</span>) &#123;</span><br><span class="line">        dispatch_queue_t queue = <span class="variable">_lru</span>-&gt;<span class="variable">_releaseOnMainThread</span> ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            [holder <span class="built_in">count</span>]; <span class="comment">// release in queue</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法做了什么？</p><ol><li>使用<code>pthread_mutex_lock(&amp;_lock);pthread_mutex_unlock(&amp;_lock);</code>对操作加锁解锁来保证线程安全。</li><li>对参数 countLimit 判断：<br>如果countLimit为0，也就是说缓存数量限制为0，那移除所有缓存对象就是了。如果当前所缓存的对象数量小于countLimit，那说明满足数量限制要求，就不需要移除操作了。</li><li>作者创建一个可变字典holder，当不满足countLimit限制要求的时候，对链表尾结点进行移除操作，并把这个尾结点添加到holder中持有。当然，这里有加锁操作。这个 while 循环结束，所有多余的缓存对象就在holder中了。<br>4.对holder中所有元素进行 release 操作。<br>其他的如:</li></ol><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>_trimToAge:<span class="params">(NSTimeInterval)</span>ageLimit; </span><br><span class="line">- <span class="params">(void)</span>_trimToCost:<span class="params">(NSUInteger)</span>costLimit</span><br></pre></td></tr></table></figure><p>操作同理。</p><h4 id="内存警告"><a href="#内存警告" class="headerlink" title="内存警告"></a>内存警告</h4><p>内存警告语 App 进入后台时释放缓存对象的操作，作者接受了系统通知，直接处理即可。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span> <span class="selector-tag">selector</span>:@<span class="keyword">selector</span>(<span class="keyword">_appDidReceiveMemoryWarningNotification</span>) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span> <span class="selector-tag">selector</span>:@<span class="keyword">selector</span>(<span class="keyword">_appDidEnterBackgroundNotification</span>) name:UIApplicationDidEnterBackgroundNotification object:nil];</span><br></pre></td></tr></table></figure><h4 id="存取实现"><a href="#存取实现" class="headerlink" title="存取实现"></a>存取实现</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="built_in">BOOL</span> contains = <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">return</span> contains;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    [<span class="keyword">self</span> setObject:object forKey:key withCost:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对缓存对象的读取自然是根据 key 读取到字典中对应的 value，这个 value 是个结点(<code>_YYLinkedMapNode</code>)，再取出这个结点的value 属性，便是最原始的缓存对象了:<code>node-&gt;_value</code>。</p><h2 id="YYMemoryCache关键点"><a href="#YYMemoryCache关键点" class="headerlink" title="YYMemoryCache关键点"></a>YYMemoryCache关键点</h2><p>1.字典</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">声明: <span class="built_in">CFMutableDictionaryRef</span> _dic;</span><br><span class="line">创建: _dic = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">设值: <span class="built_in">CFDictionarySetValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key), (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node));</span><br><span class="line">取值: <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">移除: <span class="built_in">CFDictionaryRemoveValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key));</span><br><span class="line">获取数量: <span class="built_in">CFDictionaryGetCount</span>(_dic);</span><br><span class="line">是否存在: <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">释放: <span class="built_in">CFRelease</span>(_dic);</span><br></pre></td></tr></table></figure><p>2.容器中对象销毁控制</p><blockquote><p>“对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去…”</p></blockquote><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)demo &#123;</span><br><span class="line"><span class="comment">// 对象销毁和移除容器中元素两件事隔离开</span></span><br><span class="line">&#123; <span class="comment">// 数组中的所有元素在子线程释放</span></span><br><span class="line">   <span class="built_in">NSArray</span> *holder = tmp;</span><br><span class="line">   tmp = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">   <span class="keyword">if</span> (holder.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">           [holder count];</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#123; <span class="comment">// 数组中的某个元素在子线程释放</span></span><br><span class="line">   <span class="keyword">id</span> obj = tmp[<span class="number">2</span>];</span><br><span class="line">   <span class="built_in">NSMutableArray</span> *holder = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">   [holder addObject:obj];</span><br><span class="line">   [tmp removeObject:obj];</span><br><span class="line">   <span class="keyword">if</span> (holder.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">           [holder count];</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.线程安全的实现</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;  // 取值线程安全</span><br><span class="line">pthread_mutex_lock(<span class="name">&amp;_lock</span>)<span class="comment">;</span></span><br><span class="line">BOOL releaseAsynchronously = _lru-&gt;_releaseAsynchronously;</span><br><span class="line">pthread_mutex_unlock(<span class="name">&amp;_lock</span>)<span class="comment">;</span></span><br><span class="line">return releaseAsynchronously;</span><br><span class="line">&#125;</span><br><span class="line">&#123; // 设值线程安全</span><br><span class="line">pthread_mutex_lock(<span class="name">&amp;_lock</span>)<span class="comment">;</span></span><br><span class="line">_lru-&gt;_releaseAsynchronously = releaseAsynchronously;</span><br><span class="line">pthread_mutex_unlock(<span class="name">&amp;_lock</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<code>pthread_mutex_lock</code>使用</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">声明锁: pthread_mutex_t <span class="variable">_lock</span>;</span><br><span class="line">创建锁: pthread_mutex_init(&amp;<span class="variable">_lock</span>, NULL);</span><br><span class="line">加锁: pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">解锁: pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">尝试加锁:</span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_trylock(&amp;<span class="variable">_lock</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></span><br><span class="line">&#125;</span><br><span class="line">销毁锁: pthread_mutex_destroy(&amp;<span class="variable">_lock</span>);</span><br></pre></td></tr></table></figure><p>5.if-else 单句</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_name) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure><h2 id="YYDiskCache-实现"><a href="#YYDiskCache-实现" class="headerlink" title="YYDiskCache 实现"></a>YYDiskCache 实现</h2><p>YYDiskCache主要调用了YYKVStorage的接口，并提供对外 API。</p><h4 id="五个函数"><a href="#五个函数" class="headerlink" title="五个函数"></a>五个函数</h4><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">/// <span class="type">Free</span> disk space <span class="keyword">in</span> bytes.</span><br><span class="line"><span class="keyword">static</span> int64_t _YYDiskSpaceFree() &#123;</span><br><span class="line">    <span class="type">NSError</span> *error = <span class="keyword">nil</span>;</span><br><span class="line">    <span class="type">NSDictionary</span> *attrs = [[<span class="type">NSFileManager</span> defaultManager] attributesOfFileSystemForPath:<span class="type">NSHomeDirectory</span>() error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    int64_t space =  [[attrs objectForKey:<span class="type">NSFileSystemFreeSize</span>] longLongValue];</span><br><span class="line">    <span class="keyword">if</span> (space &lt; <span class="number">0</span>) space = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> space;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// <span class="type">String</span>'s md5 hash.</span><br><span class="line"><span class="keyword">static</span> <span class="type">NSString</span> *_YYNSStringMD5(<span class="type">NSString</span> *<span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">string</span>) <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">    <span class="type">NSData</span> *data = [<span class="built_in">string</span> dataUsingEncoding:<span class="type">NSUTF8StringEncoding</span>];</span><br><span class="line">    unsigned <span class="built_in">char</span> <span class="literal">result</span>[<span class="type">CC_MD5_DIGEST_LENGTH</span>];</span><br><span class="line">    <span class="type">CC_MD5</span>(data.bytes, (<span class="type">CC_LONG</span>)data.length, <span class="literal">result</span>);</span><br><span class="line">    <span class="keyword">return</span> [<span class="type">NSString</span> stringWithFormat:</span><br><span class="line">                @<span class="string">"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"</span>,</span><br><span class="line">                <span class="literal">result</span>[<span class="number">0</span>],  <span class="literal">result</span>[<span class="number">1</span>],  <span class="literal">result</span>[<span class="number">2</span>],  <span class="literal">result</span>[<span class="number">3</span>],</span><br><span class="line">                <span class="literal">result</span>[<span class="number">4</span>],  <span class="literal">result</span>[<span class="number">5</span>],  <span class="literal">result</span>[<span class="number">6</span>],  <span class="literal">result</span>[<span class="number">7</span>],</span><br><span class="line">                <span class="literal">result</span>[<span class="number">8</span>],  <span class="literal">result</span>[<span class="number">9</span>],  <span class="literal">result</span>[<span class="number">10</span>], <span class="literal">result</span>[<span class="number">11</span>],</span><br><span class="line">                <span class="literal">result</span>[<span class="number">12</span>], <span class="literal">result</span>[<span class="number">13</span>], <span class="literal">result</span>[<span class="number">14</span>], <span class="literal">result</span>[<span class="number">15</span>]</span><br><span class="line">            ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">void</span> _YYDiskCacheInitGlobal() &#123;</span><br><span class="line">    <span class="keyword">static</span> dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _globalInstancesLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _globalInstances = [[<span class="type">NSMapTable</span> alloc] initWithKeyOptions:<span class="type">NSPointerFunctionsStrongMemory</span> valueOptions:<span class="type">NSPointerFunctionsWeakMemory</span> capacity:<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">YYDiskCache</span> *_YYDiskCacheGetGlobal(<span class="type">NSString</span> *path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    dispatch_semaphore_wait(_globalInstancesLock, <span class="type">DISPATCH_TIME_FOREVER</span>);</span><br><span class="line">    id cache = [_globalInstances objectForKey:path];</span><br><span class="line">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">void</span> _YYDiskCacheSetGlobal(<span class="type">YYDiskCache</span> *cache) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.path.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    dispatch_semaphore_wait(_globalInstancesLock, <span class="type">DISPATCH_TIME_FOREVER</span>);</span><br><span class="line">    [_globalInstances setObject:cache forKey:cache.path];</span><br><span class="line">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_YYDiskSpaceFree()</code>提供剩余磁盘空间的查询。<br><code>_YYNSStringMD5(NSString *string)</code>提供字符串转 md5。</p><p><code>_YYDiskCacheInitGlobal()</code>用于初始化一个强-弱的<code>NSMapTable</code>，保存<code>YYDiskCache</code>对象。<br><code>_YYDiskCacheGetGlobal(NSString *path)</code>用于根据路径 path 获取对应的<code>YYDiskCache</code>对象。<br><code>_YYDiskCacheSetGlobal(YYDiskCache *cache)</code>用于根据路径 path 在<code>NSMapTable</code>保存一个<code>YYDiskCache</code>对象。</p><h4 id="主要实现"><a href="#主要实现" class="headerlink" title="主要实现"></a>主要实现</h4><p>YYDiskCache的功能比如移除过期的对象、移除超过数量限制的对象等，主要通过YYKVStorage实现。<br>作者把保存类型分为三种：</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSUInteger</span>, <span class="type">YYKVStorageType</span>) &#123;</span><br><span class="line">    /// file system.</span><br><span class="line">    <span class="type">YYKVStorageTypeFile</span> = 0,</span><br><span class="line">    ///  in sqlite.</span><br><span class="line">    <span class="type">YYKVStorageTypeSQLite</span> = 1,</span><br><span class="line">    ///  based on your choice.</span><br><span class="line">    <span class="type">YYKVStorageTypeMixed</span> = 2,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作者指明了原因：Typically, write data to sqlite is faster than extern file, but<br> reading performance is dependent on data size. In my test (on iPhone 6 64G),<br> read data from extern file is faster than from sqlite when the data is larger<br> than 20KB.</p><ul><li>If you want to store large number of small datas (such as contacts cache),<br>use YYKVStorageTypeSQLite to get better performance.</li><li>If you want to store large files (such as image cache),<br>use YYKVStorageTypeFile to get better performance.</li><li><p>You can use YYKVStorageTypeMixed and choice your storage type for each item.</p><p>20kb 以下的持久化，放到文件中。 20kb 以上的持久化，放到数据库sqlite中。也可以选择混合存储。</p></li></ul><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p>1.弱引用+强引用</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) _<span class="keyword">self</span> = <span class="keyword">self</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(_queue, ^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(_<span class="keyword">self</span>) <span class="keyword">self</span> = _<span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> contains = [<span class="keyword">self</span> containsObjectForKey:key];<span class="comment">// self 应该是局部变量</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2, 快速生成时间戳(10位数)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> timestamp = time(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>3.init构造<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>抛出异常</li></ol><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@throw</span> [NSException <span class="attribute">exceptionWithName</span>:@<span class="string">"name"</span> <span class="attribute">reason</span>:@<span class="string">"YYDiskCache must be initialized with a path. Use 'initWithPath:' or 'initWithPath:inlineThreshold:' instead."</span> <span class="attribute">userInfo</span>:nil];</span><br></pre></td></tr></table></figure><p>5.尝试捕获异常<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="meta">@try</span> &#123;</span><br><span class="line">    <span class="keyword">object</span> = [NSKeyedUnarchiver unarchiveObjectWithData:item.<span class="keyword">value</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@catch</span> (NSException *exception) &#123;</span><br><span class="line">    <span class="comment">// nothing to do...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="YYKVStorage"><a href="#YYKVStorage" class="headerlink" title="YYKVStorage"></a>YYKVStorage</h2><p>YYKVStorage没有阅读。乍一看是许多琐碎的 SQL 操作和文件操作，没有纳入阅读计划。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 关于YYCache的简单总结。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>读「YYModel」</title>
    <link href="http://blog.chenyalun.com/2018/12/20/%E8%AF%BB%E3%80%8CYYModel%E3%80%8D/"/>
    <id>http://blog.chenyalun.com/2018/12/20/读「YYModel」/</id>
    <published>2018-12-20T11:32:33.000Z</published>
    <updated>2019-01-02T09:19:55.919Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 关于YYModel的简单总结。 </p><br><a id="more"></a><p></p><p>尝试阅读YYModel源码，发现有一些细节并不能十分透彻地理解清楚，只能略微窥探到其中主要原理。这里就当做第一遍阅读笔记😂😂😂。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">YYModel</span>)</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)yy_modelWithJSON:(<span class="keyword">id</span>)json;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)yy_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary;</span><br><span class="line">- (<span class="built_in">BOOL</span>)yy_modelSetWithJSON:(<span class="keyword">id</span>)json;</span><br><span class="line">- (<span class="built_in">BOOL</span>)yy_modelSetWithDictionary:(<span class="built_in">NSDictionary</span> *)dic;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)yy_modelToJSONObject;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)yy_modelToJSONData;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)yy_modelToJSONString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)yy_modelCopy;</span><br><span class="line">- (<span class="keyword">void</span>)yy_modelEncodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder;</span><br><span class="line">- (<span class="keyword">id</span>)yy_modelInitWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)yy_modelHash;</span><br><span class="line">- (<span class="built_in">BOOL</span>)yy_modelIsEqual:(<span class="keyword">id</span>)model;</span><br><span class="line">- (<span class="built_in">NSString</span> *)yy_modelDescription;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> (<span class="title">YYModel</span>)</span></span><br><span class="line"><span class="comment">// json到模型数组</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSArray</span> *)yy_modelArrayWithClass:(Class)cls json:(<span class="keyword">id</span>)json;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDictionary</span> (<span class="title">YYModel</span>)</span></span><br><span class="line"><span class="comment">// json到字典</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)yy_modelDictionaryWithClass:(Class)cls json:(<span class="keyword">id</span>)json;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YYModel</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">// 自定义模型属性与json's key的映射</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)modelCustomPropertyMapper;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)modelCustomPropertyMapper &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123; <span class="string">@"name"</span> : <span class="string">@"n"</span>,</span><br><span class="line">              <span class="string">@"count"</span> : <span class="string">@"ext.c"</span>,</span><br><span class="line">              <span class="string">@"desc1"</span> : <span class="string">@"ext.d"</span>,</span><br><span class="line">              <span class="string">@"desc4"</span> : <span class="string">@".ext"</span>,</span><br><span class="line">              <span class="string">@"modelID"</span> : @[<span class="string">@"ID"</span>, <span class="string">@"Id"</span>, <span class="string">@"id"</span>, <span class="string">@"ext.id"</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 黑名单, 若实现该方法, 黑名单之内的key均不作处理</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)modelPropertyBlacklist;</span><br><span class="line">+ (<span class="built_in">NSArray</span> *)modelPropertyBlacklist &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>, <span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白名单, 若实现该方法, 白名单之外的key均不作处理</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)modelPropertyWhitelist;</span><br><span class="line">+ (<span class="built_in">NSArray</span> *)modelPropertyWhitelist &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.要在JSON转Model的过程中根据情况创建不同类型的实例</span></span><br><span class="line">+ (<span class="keyword">nullable</span> Class)modelCustomClassForDictionary:(<span class="built_in">NSDictionary</span> *)dictionary;</span><br><span class="line">+ (Class)modelCustomClassForDictionary:(<span class="built_in">NSDictionary</span>*)dictionary &#123;</span><br><span class="line">    <span class="keyword">if</span> (dictionary[<span class="string">@"localName"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [YYLocalUser <span class="keyword">class</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dictionary[<span class="string">@"remoteName"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [YYRemoteUser <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [YYBaseUser <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.该方法发生在字典转模型之前, 最后对字典做一次处理</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)modelCustomWillTransformFromDictionary:(<span class="built_in">NSDictionary</span> *)dic;</span><br><span class="line"><span class="comment">//- (NSDictionary *)modelCustomWillTransformFromDictionary:(NSDictionary *)dic&#123;</span></span><br><span class="line">    <span class="keyword">if</span> ([dic[<span class="string">@"sex"</span>] isEqualToString:<span class="string">@"Man"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.JSON转为Model后, 进行数据校验</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)modelCustomTransformFromDictionary:(<span class="built_in">NSDictionary</span> *)dic;</span><br><span class="line">- (<span class="built_in">BOOL</span>)modelCustomTransformFromDictionary:(<span class="built_in">NSDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *timestamp = dic[<span class="string">@"timestamp"</span>];</span><br><span class="line">    <span class="keyword">if</span> (![timestamp isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    _createdAt = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:timestamp.floatValue];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型容器属性中的所需要存放的数据类型</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)modelContainerPropertyGenericClass;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)modelContainerPropertyGenericClass &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"shadows"</span> : [Shadow <span class="keyword">class</span>],</span><br><span class="line">             <span class="string">@"borders"</span> : Border.class,</span><br><span class="line">             <span class="string">@"attachments"</span> : <span class="string">@"Attachment"</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Model转为JSON后, 进行数据校验</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)modelCustomTransformToDictionary:(<span class="built_in">NSMutableDictionary</span> *)dic;</span><br><span class="line">- (<span class="built_in">BOOL</span>)modelCustomTransformToDictionary:(<span class="built_in">NSMutableDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_createdAt) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    dic[<span class="string">@"timestamp"</span>] = @(_createdAt.timeIntervalSince1970);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 函数1: 根据class信息获取其对应的类型</span></span><br><span class="line"><span class="keyword">static</span> force_inline YYEncodingNSType YYClassGetNSType(Class cls) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> YYEncodingTypeNSUnknown;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSMutableString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSMutableString;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSString;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSDecimalNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSDecimalNumber;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSNumber;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSValue</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSValue;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSMutableData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSMutableData;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSData;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSDate;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSURL;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSMutableArray;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSArray;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSMutableDictionary;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSDictionary;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSMutableSet</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSMutableSet;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSSet;</span><br><span class="line">    <span class="keyword">return</span> YYEncodingTypeNSUnknown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数2: 判断YYEncodingType是不是一个数字(整形\长整型\浮点型等)</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">BOOL</span> YYEncodingTypeIsCNumber(YYEncodingType type) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeBool:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeInt8:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeUInt8:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeInt16:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeUInt16:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeInt32:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeUInt32:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeInt64:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeUInt64:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeFloat:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeDouble:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeLongDouble: <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数3: 根据一个id类型的对象创建一个NSNumber类型的对象</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">NSNumber</span> *YYNSNumberCreateFromID(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSCharacterSet</span> *dot;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDictionary</span> *dic;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        dot = [<span class="built_in">NSCharacterSet</span> characterSetWithRange:<span class="built_in">NSMakeRange</span>(<span class="string">'.'</span>, <span class="number">1</span>)];</span><br><span class="line">        dic = @&#123;<span class="string">@"TRUE"</span> :   @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"True"</span> :   @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"true"</span> :   @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"FALSE"</span> :  @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"False"</span> :  @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"false"</span> :  @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"YES"</span> :    @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"Yes"</span> :    @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"yes"</span> :    @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"NO"</span> :     @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"No"</span> :     @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"no"</span> :     @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"NIL"</span> :    (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"Nil"</span> :    (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"nil"</span> :    (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"NULL"</span> :   (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"Null"</span> :   (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"null"</span> :   (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"(NULL)"</span> : (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"(Null)"</span> : (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"(null)"</span> : (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"&lt;NULL&gt;"</span> : (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"&lt;Null&gt;"</span> : (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"&lt;null&gt;"</span> : (<span class="keyword">id</span>)kCFNull&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// kCFNull单例</span></span><br><span class="line">    <span class="keyword">if</span> (!value || value == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// NSNumber直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">// NSString, 取出dic中对应的值</span></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> *num = dic[value];</span><br><span class="line">        <span class="keyword">if</span> (num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个字符串中含有 ".", 例如 @"12.344"</span></span><br><span class="line">        <span class="keyword">if</span> ([(<span class="built_in">NSString</span> *)value rangeOfCharacterFromSet:dot].location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *cstring = ((<span class="built_in">NSString</span> *)value).UTF8String;</span><br><span class="line">            <span class="keyword">if</span> (!cstring) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">double</span> num = atof(cstring);</span><br><span class="line">            <span class="comment">// isfinite()测试某个浮点数是不是有限的数</span></span><br><span class="line">            <span class="comment">// isinf()测试某个浮点数是否是无限大</span></span><br><span class="line">            <span class="comment">// isnan()测试某个浮点数是否是 非数字</span></span><br><span class="line">            <span class="keyword">if</span> (isnan(num) || isinf(num)) <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">// num是否是无限大或者是否是非数字</span></span><br><span class="line">            <span class="keyword">return</span> @(num); <span class="comment">// return @(12.344);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 字符串中没有".", 例如 @"1323"</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *cstring = ((<span class="built_in">NSString</span> *)value).UTF8String;<span class="comment">// 转化为C字符串"1323"</span></span><br><span class="line">            <span class="keyword">if</span> (!cstring) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">// atoi函数：将字符串转化为int类型变量. atol函数：将字符串转化为long类型变量.</span></span><br><span class="line">            <span class="comment">// atoll函数：将字符串转化为long long类型变量.atof函数：将字符串转化为double类型变量</span></span><br><span class="line">            <span class="keyword">return</span> @(atoll(cstring)); <span class="comment">// 转换为long long类型变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数4: 将字符串转化为日期NSDate</span></span><br><span class="line"><span class="comment">// 根据string的length判断需要调用哪一个block, 为了避免效率较低的if-else, 采用block数组的形式, string的length正好对应blocks数组的索引, 即查表法, 效率得到提升.</span></span><br><span class="line"><span class="comment">// YYNSDateParseBlock parser = blocks[string.length];</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">NSDate</span> *YYNSDateFromString(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">NSDate</span>* (^YYNSDateParseBlock)(<span class="built_in">NSString</span> *string);</span><br><span class="line">    <span class="meta">#define kParserNum 34</span></span><br><span class="line">    <span class="comment">// 定义一个block数组, 数组是C数组</span></span><br><span class="line">    <span class="keyword">static</span> YYNSDateParseBlock blocks[kParserNum + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             2014-01-20  // Google , 10个字符, 对应blocks[10]</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter.dateFormat = <span class="string">@"yyyy-MM-dd"</span>;</span><br><span class="line">            blocks[<span class="number">10</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             2014-01-20 12:24:48 // 19个字符, 对应blocks[19]</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48   // Google, 19个字符, 对应blocks[19]</span></span><br><span class="line"><span class="comment">             2014-01-20 12:24:48.000 // 23个字符, 对应blocks[23]</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48.000 // 23个字符, 对应blocks[23]</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter1 = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter1.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter1.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter1.dateFormat = <span class="string">@"yyyy-MM-dd'T'HH:mm:ss"</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter2 = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter2.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter2.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter2.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter3 = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter3.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter3.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter3.dateFormat = <span class="string">@"yyyy-MM-dd'T'HH:mm:ss.SSS"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter4 = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter4.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter4.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter4.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm:ss.SSS"</span>;</span><br><span class="line">            </span><br><span class="line">            blocks[<span class="number">19</span>] = ^(<span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([string characterAtIndex:<span class="number">10</span>] == <span class="string">'T'</span>) &#123;<span class="comment">// 2014-01-20T12:24:48</span></span><br><span class="line">                    <span class="keyword">return</span> [formatter1 dateFromString:string];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// 2014-01-20 12:24:48</span></span><br><span class="line">                    <span class="keyword">return</span> [formatter2 dateFromString:string];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            blocks[<span class="number">23</span>] = ^(<span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([string characterAtIndex:<span class="number">10</span>] == <span class="string">'T'</span>) &#123;<span class="comment">// 2014-01-20T12:24:48.000</span></span><br><span class="line">                    <span class="keyword">return</span> [formatter3 dateFromString:string];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// 2014-01-20 12:24:48.000</span></span><br><span class="line">                    <span class="keyword">return</span> [formatter4 dateFromString:string];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48Z        // Github, Apple</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48+0800    // Facebook</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48+12:00   // Google</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48.000Z</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48.000+0800</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48.000+12:00</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter = [<span class="built_in">NSDateFormatter</span> new];</span><br><span class="line">            formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter.dateFormat = <span class="string">@"yyyy-MM-dd'T'HH:mm:ssZ"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter2 = [<span class="built_in">NSDateFormatter</span> new];</span><br><span class="line">            formatter2.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter2.dateFormat = <span class="string">@"yyyy-MM-dd'T'HH:mm:ss.SSSZ"</span>;</span><br><span class="line"></span><br><span class="line">            blocks[<span class="number">20</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]; &#125;;</span><br><span class="line">            blocks[<span class="number">24</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]?: [formatter2 dateFromString:string]; &#125;;</span><br><span class="line">            blocks[<span class="number">25</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]; &#125;;</span><br><span class="line">            blocks[<span class="number">28</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter2 dateFromString:string]; &#125;;</span><br><span class="line">            blocks[<span class="number">29</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter2 dateFromString:string]; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             Fri Sep 04 00:12:21 +0800 2015 // Weibo, Twitter</span></span><br><span class="line"><span class="comment">             Fri Sep 04 00:12:21.000 +0800 2015</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter = [<span class="built_in">NSDateFormatter</span> new];</span><br><span class="line">            formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter.dateFormat = <span class="string">@"EEE MMM dd HH:mm:ss Z yyyy"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter2 = [<span class="built_in">NSDateFormatter</span> new];</span><br><span class="line">            formatter2.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter2.dateFormat = <span class="string">@"EEE MMM dd HH:mm:ss.SSS Z yyyy"</span>;</span><br><span class="line"></span><br><span class="line">            blocks[<span class="number">30</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]; &#125;;</span><br><span class="line">            blocks[<span class="number">34</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter2 dateFromString:string]; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!string) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; kParserNum) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    YYNSDateParseBlock parser = blocks[string.length];</span><br><span class="line">    <span class="keyword">if</span> (!parser) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> parser(string);</span><br><span class="line">    <span class="meta">#undef kParserNum</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数5: 获取NSBlock类</span></span><br><span class="line"><span class="keyword">static</span> force_inline Class YYNSBlockClass() &#123;</span><br><span class="line">    <span class="keyword">static</span> Class cls;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;&#125;;</span><br><span class="line">        cls = ((<span class="built_in">NSObject</span> *)block).class;</span><br><span class="line">        <span class="keyword">while</span> (class_getSuperclass(cls) != [<span class="built_in">NSObject</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">            cls = class_getSuperclass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cls; <span class="comment">// current is "NSBlock"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数6: 获取ISO NSDateFormatter</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> example:</span></span><br><span class="line"><span class="comment"> 2010-07-09T16:13:30+12:00</span></span><br><span class="line"><span class="comment"> 2011-01-11T11:11:11+0000</span></span><br><span class="line"><span class="comment"> 2011-01-26T19:06:43Z</span></span><br><span class="line"><span class="comment"> length: 20/24/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">NSDateFormatter</span> *YYISODateFormatter() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *formatter = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">        formatter.dateFormat = <span class="string">@"yyyy-MM-dd'T'HH:mm:ssZ"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> formatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    "version": "1.1",</span></span><br><span class="line"><span class="comment">    "object": &#123;</span></span><br><span class="line"><span class="comment">        "data": &#123;</span></span><br><span class="line"><span class="comment">            "phone": "12332123"</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 函数7: 根据keypath从字典中获取对应的值(这个值是id类型)</span></span><br><span class="line"><span class="comment">// keyPaths: @[@"object", @"data", @"phone"] 对应的值是 @"12332123"</span></span><br><span class="line"><span class="comment">// keyPaths: @[@"object", @"data"] 对应的值是 @&#123;@"phone": @"12332123"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="keyword">id</span> YYValueForKeyPath(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSDictionary</span> *dic, __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSArray</span> *keyPaths) &#123;</span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = keyPaths.count; i &lt; max; i++) &#123;</span><br><span class="line">        value = dic[keyPaths[i]];</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; max) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                dic = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数8: 根据可变的keypath从字典中获取对应的值(这个值是id类型)</span></span><br><span class="line"><span class="comment">// multiKeys: @[ @[@"object", @"data"], @"phone"] 对应的值是 @&#123;@"phone": @"12332123"&#125;</span></span><br><span class="line"><span class="comment">// multiKeys: @[@"object", @"data"] 对应的值是 @&#123;@"data": @&#123;@"phone": @"12332123"&#125;&#125;</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="keyword">id</span> YYValueForMultiKeys(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSDictionary</span> *dic, __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSArray</span> *multiKeys) &#123;</span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> multiKeys) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([key isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            value = dic[key];</span><br><span class="line">            <span class="keyword">if</span> (value) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value = YYValueForKeyPath(dic, (<span class="built_in">NSArray</span> *)key);</span><br><span class="line">            <span class="keyword">if</span> (value) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数9: 从模型中的属性(_YYModelPropertyMeta类型)中获取NSNumber</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">NSNumber</span> *ModelCreateNumberFromProperty(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model,</span><br><span class="line">                                                            __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *meta) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (meta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeBool: &#123;</span><br><span class="line">            <span class="keyword">return</span> @(((<span class="keyword">bool</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, meta-&gt;_<span class="keyword">getter</span>));&#125;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数10: 对模型中的属性(_YYModelPropertyMeta类型)设值. 和函数9类似</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="keyword">void</span> ModelSetNumberToProperty(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model,</span><br><span class="line">                                                  __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSNumber</span> *num,</span><br><span class="line">                                                  __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *meta) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (meta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeBool: &#123;</span><br><span class="line">            ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">bool</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, num.boolValue);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数11: 对模型中的属性(_YYModelPropertyMeta类型)设值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetValueForProperty(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model,</span><br><span class="line">                                     __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> value,</span><br><span class="line">                                     __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *meta) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *modelMeta;  <span class="comment">///&lt; _YYModelMeta</span></span><br><span class="line">    <span class="keyword">void</span> *model;      <span class="comment">///&lt; id (self)</span></span><br><span class="line">    <span class="keyword">void</span> *dictionary; <span class="comment">///&lt; NSDictionary (json)</span></span><br><span class="line">&#125; ModelSetContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数12: 对模型(_context.modelMeta and _context.model)设置 key-value键值对</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetWithDictionaryFunction(<span class="keyword">const</span> <span class="keyword">void</span> *_key, <span class="keyword">const</span> <span class="keyword">void</span> *_value, <span class="keyword">void</span> *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta);</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge <span class="keyword">id</span>)(_key)];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model = (__bridge <span class="keyword">id</span>)(context-&gt;model);</span><br><span class="line">    <span class="keyword">while</span> (propertyMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_<span class="keyword">setter</span>) &#123;</span><br><span class="line">            ModelSetValueForProperty(model, (__bridge __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>)_value, propertyMeta);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有多个属性映射到同一个 key 则指向下一个模型属性元</span></span><br><span class="line">        propertyMeta = propertyMeta-&gt;_next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Apply function for model property meta, to set dictionary to model.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param _propertyMeta should not be nil, _YYModelPropertyMeta.</span></span><br><span class="line"><span class="comment"> @param _context      _context.model and _context.dictionary should not be nil.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 函数13:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetWithPropertyMetaArrayFunction(<span class="keyword">const</span> <span class="keyword">void</span> *_propertyMeta, <span class="keyword">void</span> *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSDictionary</span> *dictionary = (__bridge <span class="built_in">NSDictionary</span> *)(context-&gt;dictionary);</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = (__bridge _YYModelPropertyMeta *)(_propertyMeta);</span><br><span class="line">    <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">setter</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyArray) &#123;</span><br><span class="line">        value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;_mappedToKeyArray);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123;</span><br><span class="line">        value = YYValueForKeyPath(dictionary, propertyMeta-&gt;_mappedToKeyPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = [dictionary objectForKey:propertyMeta-&gt;_mappedToKey];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model = (__bridge <span class="keyword">id</span>)(context-&gt;model);</span><br><span class="line">        ModelSetValueForProperty(model, value, propertyMeta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns a valid JSON object (NSArray/NSDictionary/NSString/NSNumber/NSNull),</span></span><br><span class="line"><span class="comment"> or nil if an error occurs.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param model Model, can be nil.</span></span><br><span class="line"><span class="comment"> @return JSON object, nil if an error occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 函数14: 模型转 json</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> ModelToJSONObjectRecursive(<span class="built_in">NSObject</span> *model) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!model || model == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:model]) <span class="keyword">return</span> model;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *newDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        [((<span class="built_in">NSDictionary</span> *)model) enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *stringKey = [key isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] ? key : key.description;</span><br><span class="line">            <span class="keyword">if</span> (!stringKey) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">            <span class="keyword">if</span> (!jsonObj) jsonObj = (<span class="keyword">id</span>)kCFNull;</span><br><span class="line">            newDic[stringKey] = jsonObj;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> newDic;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = ((<span class="built_in">NSSet</span> *)model).allObjects;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:array]) <span class="keyword">return</span> array;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> array) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] || [obj isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                [newArray addObject:obj];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">                <span class="keyword">if</span> (jsonObj &amp;&amp; jsonObj != (<span class="keyword">id</span>)kCFNull) [newArray addObject:jsonObj];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArray;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:model]) <span class="keyword">return</span> model;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)model) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] || [obj isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                [newArray addObject:obj];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">                <span class="keyword">if</span> (jsonObj &amp;&amp; jsonObj != (<span class="keyword">id</span>)kCFNull) [newArray addObject:jsonObj];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArray;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSURL</span> *)model).absoluteString;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSAttributedString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSAttributedString</span> *)model).string;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> [YYISODateFormatter() stringFromDate:(<span class="keyword">id</span>)model];</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model <span class="keyword">class</span>]];</span><br><span class="line">    <span class="keyword">if</span> (!modelMeta || modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *result = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">64</span>];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSMutableDictionary</span> *dic = result; <span class="comment">// avoid retain and release in block</span></span><br><span class="line">    [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">getter</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_isCNumber) &#123;</span><br><span class="line">            value = ModelCreateNumberFromProperty(model, propertyMeta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_nsType) &#123;</span><br><span class="line">            <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">            value = ModelToJSONObjectRecursive(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                    <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = ModelToJSONObjectRecursive(v);</span><br><span class="line">                    <span class="keyword">if</span> (value == (<span class="keyword">id</span>)kCFNull) value = <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                    Class v = ((Class (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromClass</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeSEL: &#123;</span><br><span class="line">                    SEL v = ((SEL (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromSelector</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *superDic = dic;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *subDic = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *key = propertyMeta-&gt;_mappedToKeyPath[i];</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == max) &#123; <span class="comment">// end</span></span><br><span class="line">                    <span class="keyword">if</span> (!superDic[key]) superDic[key] = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                subDic = superDic[key];</span><br><span class="line">                <span class="keyword">if</span> (subDic) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ([subDic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                        subDic = subDic.mutableCopy;</span><br><span class="line">                        superDic[key] = subDic;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    subDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">                    superDic[key] = subDic;</span><br><span class="line">                &#125;</span><br><span class="line">                superDic = subDic;</span><br><span class="line">                subDic = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</span><br><span class="line">                dic[propertyMeta-&gt;_mappedToKey] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformToDictionary) &#123;</span><br><span class="line">        <span class="comment">// 当 Model 转为 JSON 完成后，该方法会被调用。</span></span><br><span class="line">        <span class="comment">// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。</span></span><br><span class="line">        <span class="comment">// 你也可以在这里做一些自动转换不能完成的工作。</span></span><br><span class="line">        <span class="built_in">BOOL</span> suc = [((<span class="keyword">id</span>&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (!suc) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 函数15: Add indent to string (exclude first line)</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableString</span> *ModelDescriptionAddIndent(<span class="built_in">NSMutableString</span> *desc, <span class="built_in">NSUInteger</span> indent) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = desc.length; i &lt; max; i++) &#123;</span><br><span class="line">        <span class="keyword">unichar</span> c = [desc characterAtIndex:i];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; indent; j++) &#123;</span><br><span class="line">                [desc insertString:<span class="string">@"    "</span> atIndex:i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i += indent * <span class="number">4</span>;</span><br><span class="line">            max += indent * <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 函数16: 根据model生成一个描述字符串</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *ModelDescription(<span class="built_in">NSObject</span> *model) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kDescMaxLength = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (!model) <span class="keyword">return</span> <span class="string">@"&lt;nil&gt;"</span>;</span><br><span class="line">    <span class="keyword">if</span> (model == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="string">@"&lt;null&gt;"</span>;</span><br><span class="line">    <span class="keyword">if</span> (![model isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,model];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:model.class];</span><br><span class="line">    <span class="keyword">switch</span> (modelMeta-&gt;_nsType) &#123;</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSString: <span class="keyword">case</span> YYEncodingTypeNSMutableString: &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"\"%@\""</span>,model];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSValue:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSData: <span class="keyword">case</span> YYEncodingTypeNSMutableData: &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *tmp = model.description;</span><br><span class="line">            <span class="keyword">if</span> (tmp.length &gt; kDescMaxLength) &#123;</span><br><span class="line">                tmp = [tmp substringToIndex:kDescMaxLength];</span><br><span class="line">                tmp = [tmp stringByAppendingString:<span class="string">@"..."</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSNumber:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSDecimalNumber:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSDate:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSURL: &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,model];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSSet: <span class="keyword">case</span> YYEncodingTypeNSMutableSet: &#123;</span><br><span class="line">            model = ((<span class="built_in">NSSet</span> *)model).allObjects;</span><br><span class="line">        &#125; <span class="comment">// no break</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSArray: <span class="keyword">case</span> YYEncodingTypeNSMutableArray: &#123;</span><br><span class="line">            <span class="built_in">NSArray</span> *array = (<span class="keyword">id</span>)model;</span><br><span class="line">            <span class="built_in">NSMutableString</span> *desc = [<span class="built_in">NSMutableString</span> new];</span><br><span class="line">            <span class="keyword">if</span> (array.count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> [desc stringByAppendingString:<span class="string">@"[]"</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [desc appendFormat:<span class="string">@"[\n"</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = array.count; i &lt; max; i++) &#123;</span><br><span class="line">                    <span class="built_in">NSObject</span> *obj = array[i];</span><br><span class="line">                    [desc appendString:<span class="string">@"    "</span>];</span><br><span class="line">                    [desc appendString:ModelDescriptionAddIndent(ModelDescription(obj).mutableCopy, <span class="number">1</span>)];</span><br><span class="line">                    [desc appendString:(i + <span class="number">1</span> == max) ? <span class="string">@"\n"</span> : <span class="string">@";\n"</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                [desc appendString:<span class="string">@"]"</span>];</span><br><span class="line">                <span class="keyword">return</span> desc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSDictionary: <span class="keyword">case</span> YYEncodingTypeNSMutableDictionary: &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *dic = (<span class="keyword">id</span>)model;</span><br><span class="line">            <span class="built_in">NSMutableString</span> *desc = [<span class="built_in">NSMutableString</span> new];</span><br><span class="line">            <span class="keyword">if</span> (dic.count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> [desc stringByAppendingString:<span class="string">@"&#123;&#125;"</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">NSArray</span> *keys = dic.allKeys;</span><br><span class="line">                </span><br><span class="line">                [desc appendFormat:<span class="string">@"&#123;\n"</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = keys.count; i &lt; max; i++) &#123;</span><br><span class="line">                    <span class="built_in">NSString</span> *key = keys[i];</span><br><span class="line">                    <span class="built_in">NSObject</span> *value = dic[key];</span><br><span class="line">                    [desc appendString:<span class="string">@"    "</span>];</span><br><span class="line">                    [desc appendFormat:<span class="string">@"%@ = %@"</span>,key, ModelDescriptionAddIndent(ModelDescription(value).mutableCopy, <span class="number">1</span>)];</span><br><span class="line">                    [desc appendString:(i + <span class="number">1</span> == max) ? <span class="string">@"\n"</span> : <span class="string">@";\n"</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                [desc appendString:<span class="string">@"&#125;"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> desc;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="built_in">NSMutableString</span> *desc = [<span class="built_in">NSMutableString</span> new];</span><br><span class="line">            [desc appendFormat:<span class="string">@"&lt;%@: %p&gt;"</span>, model.class, model];</span><br><span class="line">            <span class="keyword">if</span> (modelMeta-&gt;_allPropertyMetas.count == <span class="number">0</span>) <span class="keyword">return</span> desc;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// sort property names</span></span><br><span class="line">            <span class="built_in">NSArray</span> *properties = [modelMeta-&gt;_allPropertyMetas</span><br><span class="line">                                   sortedArrayUsingComparator:^<span class="built_in">NSComparisonResult</span>(_YYModelPropertyMeta *p1, _YYModelPropertyMeta *p2) &#123;</span><br><span class="line">                                       <span class="keyword">return</span> [p1-&gt;_name compare:p2-&gt;_name];</span><br><span class="line">                                   &#125;];</span><br><span class="line">            </span><br><span class="line">            [desc appendFormat:<span class="string">@" &#123;\n"</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = properties.count; i &lt; max; i++) &#123;</span><br><span class="line">                _YYModelPropertyMeta *property = properties[i];</span><br><span class="line">                <span class="built_in">NSString</span> *propertyDesc;</span><br><span class="line">                <span class="keyword">if</span> (property-&gt;_isCNumber) &#123;</span><br><span class="line">                    <span class="built_in">NSNumber</span> *num = ModelCreateNumberFromProperty(model, property);</span><br><span class="line">                    propertyDesc = num.stringValue;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (property-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                            <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, property-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                            propertyDesc = ModelDescription(v);</span><br><span class="line">                            <span class="keyword">if</span> (!propertyDesc) propertyDesc = <span class="string">@"&lt;nil&gt;"</span>;</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                            <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, property-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                            propertyDesc = ((<span class="built_in">NSObject</span> *)v).description;</span><br><span class="line">                            <span class="keyword">if</span> (!propertyDesc) propertyDesc = <span class="string">@"&lt;nil&gt;"</span>;</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeSEL: &#123;</span><br><span class="line">                            SEL sel = ((SEL (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, property-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                            <span class="keyword">if</span> (sel) propertyDesc = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">                            <span class="keyword">else</span> propertyDesc = <span class="string">@"&lt;NULL&gt;"</span>;</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeBlock: &#123;</span><br><span class="line">                            <span class="keyword">id</span> block = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, property-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                            propertyDesc = block ? ((<span class="built_in">NSObject</span> *)block).description : <span class="string">@"&lt;nil&gt;"</span>;</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeCArray: <span class="keyword">case</span> YYEncodingTypeCString: <span class="keyword">case</span> YYEncodingTypePointer: &#123;</span><br><span class="line">                            <span class="keyword">void</span> *pointer = ((<span class="keyword">void</span>* (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, property-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                            propertyDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>,pointer];</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeStruct: <span class="keyword">case</span> YYEncodingTypeUnion: &#123;</span><br><span class="line">                            <span class="built_in">NSValue</span> *value = [model valueForKey:property-&gt;_name];</span><br><span class="line">                            propertyDesc = value ? value.description : <span class="string">@"&#123;unknown&#125;"</span>;</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: propertyDesc = <span class="string">@"&lt;unknown&gt;"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                propertyDesc = ModelDescriptionAddIndent(propertyDesc.mutableCopy, <span class="number">1</span>);</span><br><span class="line">                [desc appendFormat:<span class="string">@"    %@ = %@"</span>,property-&gt;_name, propertyDesc];</span><br><span class="line">                [desc appendString:(i + <span class="number">1</span> == max) ? <span class="string">@"\n"</span> : <span class="string">@";\n"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            [desc appendFormat:<span class="string">@"&#125;"</span>];</span><br><span class="line">            <span class="keyword">return</span> desc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><p> 1.强制内联</p> <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">#define force_inline __inline__ __attribute__((<span class="name">always_inline</span>))</span><br></pre></td></tr></table></figure><p>2.使用代码块, 节省许多变量名</p> <figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init]<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用block数组</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSDate</span>* (^YYNSDateParseBlock)(<span class="built_in">NSString</span> *string);</span><br><span class="line"><span class="comment">// 定义一个block数组</span></span><br><span class="line"><span class="keyword">static</span> YYNSDateParseBlock blocks[<span class="number">35</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>4.获取NSBlock类</p><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;&#125;;</span><br><span class="line">cls = ((NSObject *)block).<span class="keyword">class</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">class</span><span class="number">_</span>getSuperclass(cls) != [NSObject <span class="keyword">class</span>]) &#123;</span><br><span class="line">    cls = <span class="keyword">class</span><span class="number">_</span>getSuperclass(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 5.函数参数使用<code>__unsafe_unretained</code><br> 在 ARC 条件下，默认声明的对象是 <code>__strong</code> 类型的，赋值时有可能会产生<code>retain/release</code>调用，如果一个变量在其生命周期内不会被释放，则使用<code>__unsafe_unretained `</code>会节省很大的开销。</p><p> 访问具有 <code>__weak</code>属性的变量时，实际上会调用 <code>objc_loadWeak()</code> 和 <code>objc_storeWeak()</code> 来完成，这也会带来很大的开销，所以要避免使用 <code>__weak</code>属性。</p><p> 创建和使用对象时，要尽量避免对象进入<code>autoreleasepool</code>，以避免额外的资源开销。</p><p> 6.for循环中定义变量, 使用unsigned</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, <span class="built_in">max</span> = keyPaths.count; i &lt; <span class="built_in">max</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 7.可变量创建静态不变量, 静态常量配合dispatch_once使用</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSSet</span> *types = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"><span class="built_in">NSMutableSet</span> *set = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">    types = set;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 8.线程安全的缓存字典</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> cacheWithKey(<span class="built_in">NSString</span> *key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> cache;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> dispatch_semaphore_t lock;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        cache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="keyword">id</span> obj = <span class="built_in">CFDictionaryGetValue</span>(cache, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    dispatch_semaphore_signal(lock);</span><br><span class="line">    <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">        obj = [<span class="built_in">NSObject</span> new]; <span class="comment">// Other operation.</span></span><br><span class="line">        <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(cache, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key), (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(obj));</span><br><span class="line">            dispatch_semaphore_signal(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.消息发送调用格式</p><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">((<span class="name">int32_t</span> (<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))(<span class="name">void</span> *) objc_msgSend)((<span class="name"><span class="builtin-name">id</span></span>)model, meta-&gt;_getter)</span><br></pre></td></tr></table></figure><p>10.<code>NSNull</code>的单例<code>kCFNull</code>, 推荐使用, 而不是创建<code>[NSNull null]</code></p> <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNull</span> *null1 = (<span class="keyword">id</span>)kCFNull;</span><br><span class="line"><span class="built_in">NSNull</span> *null2 = [<span class="built_in">NSNull</span> null];</span><br><span class="line"></span><br><span class="line">Class <span class="keyword">class</span> = Nil;</span><br><span class="line"><span class="built_in">NSDate</span> *date = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>11.<code>YYClassIvarInfo</code>中的 <code>name</code> 和 <code>typeEncoding</code> 属性都用 <code>strong</code> 修饰。<br>NSString 这类属性在确定其不会在初始化之后被修改的情况下，使用 strong 做一次单纯的强引用在性能上讲比 copy 要高一些。</p><p>12.<code>NSString</code>转C字符串</p><p> <code>const char *cstring = ((NSString *)value).UTF8String;</code></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p> YYModel 最核心的便是通过遍历模型的所有属性，根据字典值来调用属性的 setter 方法。没有使用效率低下的 KVC（效率低下的原因可能是需要对方法进行搜索吧，有空深究）。鉴于此，用了300行代码简单写了一个字典转模型的玩具，权当做是读完 YYModel 的实践吧。试了一下，效果还可以😂。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">@protocol</span> <span class="title">YAModelProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span>;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)customPropertyKey;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, Class&gt;*)classInArray;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">YAModel</span>)</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)ya_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dict;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)ya_modelWithJSON:(<span class="built_in">NSData</span> *)data;</span><br><span class="line">+ (<span class="built_in">NSArray</span> *)ya_modelArrayWithKeyValuesArray:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSDictionary</span> *&gt;*)dictArray;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编码类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, YAType) &#123;</span><br><span class="line">    YATypeMask              = <span class="number">0xFF</span>,</span><br><span class="line">    YATypeUnknown           = <span class="number">0</span>,</span><br><span class="line">    YATypeBOOL              = <span class="number">1</span>,</span><br><span class="line">    YATypeNSInteger         = <span class="number">2</span>,</span><br><span class="line">    YATypeNSUInteger        = <span class="number">3</span>,</span><br><span class="line">    YATypeCGFloat           = <span class="number">4</span>,</span><br><span class="line">    YATypeObject            = <span class="number">5</span>,</span><br><span class="line">    YATypeDate              = <span class="number">6</span>,</span><br><span class="line">    YATypeClass             = <span class="number">7</span>,</span><br><span class="line">    YATypeSEL               = <span class="number">8</span>,</span><br><span class="line">    YATypeArray             = <span class="number">9</span>,</span><br><span class="line">    YATypeMutableArray      = <span class="number">10</span>,</span><br><span class="line">    YATypeDictionary        = <span class="number">11</span>,</span><br><span class="line">    YATypeMutableDictionary = <span class="number">12</span>,</span><br><span class="line">    YATypeSet               = <span class="number">13</span>,</span><br><span class="line">    YATypeMutableSet        = <span class="number">14</span>,</span><br><span class="line">    YATypeString            = <span class="number">15</span>,</span><br><span class="line">    YATypeMutableString     = <span class="number">16</span>,</span><br><span class="line">    YATypeData              = <span class="number">17</span>,</span><br><span class="line">    YATypeNumber            = <span class="number">18</span>,</span><br><span class="line">    YATypeDecimalNumber     = <span class="number">19</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">YAModel</span>)</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDictionary</span> *classArrayDict = <span class="literal">nil</span>;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)ya_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dict &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dict || ![dict isKindOfClass:<span class="built_in">NSDictionary</span>.class]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *propertyList = PropertyList(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">id</span> obj = [<span class="keyword">self</span> new];</span><br><span class="line">    ObjSetWithKeyValueList(obj, propertyList, dict);</span><br><span class="line">    classArrayDict = <span class="literal">nil</span>; <span class="comment">// Clean memory.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)ya_modelWithJSON:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || ![data isKindOfClass:<span class="built_in">NSData</span>.class]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> json = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> ([json isKindOfClass:<span class="built_in">NSDictionary</span>.class]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> ya_modelWithDictionary:json];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)ya_modelArrayWithKeyValuesArray:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSDictionary</span> *&gt; *)dictArray &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dictArray || ![dictArray isKindOfClass:<span class="built_in">NSArray</span>.class]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *tmp = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:dictArray.count];</span><br><span class="line">    [dictArray enumerateObjectsUsingBlock:^(<span class="built_in">NSDictionary</span> * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSDictionary</span>.class]) &#123;</span><br><span class="line">            <span class="keyword">id</span> model = [[<span class="keyword">self</span> <span class="keyword">class</span>] ya_modelWithDictionary:obj];</span><br><span class="line">            [tmp addObject:model];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:tmp] ?: <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性列表 key:属性名 value: 属性类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDictionary</span> *PropertyList(Class cls) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    objc_property_t *properties = class_copyPropertyList(cls, &amp;count);</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *tempDict = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        objc_property_t property = properties[i];</span><br><span class="line">        <span class="built_in">NSString</span> *propertyName = [<span class="built_in">NSString</span> stringWithUTF8String:property_getName(property)];</span><br><span class="line">        <span class="built_in">NSString</span> *propertyAttr = [<span class="built_in">NSString</span> stringWithUTF8String:property_getAttributes(property)];</span><br><span class="line">        <span class="built_in">NSString</span> *type = [propertyAttr substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">1</span>, <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">if</span> ([type isEqualToString:<span class="string">@"@"</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSArray</span> *components = [propertyAttr componentsSeparatedByString:<span class="string">@"\""</span>];</span><br><span class="line">            <span class="keyword">if</span> (components.count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                Class propCls = <span class="built_in">NSClassFromString</span>(components[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (propCls == <span class="built_in">NSDate</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"1"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSArray</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"2"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSMutableArray</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"3"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSDictionary</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"4"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSMutableDictionary</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"5"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSSet</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"6"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSMutableSet</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"7"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSString</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"8"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSMutableString</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"9"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSData</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"10"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSNumber</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"11"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSDecimalNumber</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"12"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSObject</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"@"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    type = components[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSNumber</span> *myType = TypeForProperty(type);</span><br><span class="line">        [tempDict setObject:myType forKey:propertyName];</span><br><span class="line">        <span class="keyword">if</span> (myType.integerValue == <span class="number">0</span>) &#123;</span><br><span class="line">            [tempDict setObject:type forKey:propertyName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(properties);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:tempDict];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSNumber</span> *TypeForProperty(<span class="built_in">NSString</span> *type) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDictionary</span> *_SELDictionary = <span class="literal">nil</span>;;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _SELDictionary = @&#123;</span><br><span class="line">                           <span class="string">@"B"</span>: @(YATypeBOOL),</span><br><span class="line">                           <span class="string">@"q"</span>: @(YATypeNSInteger),</span><br><span class="line">                           <span class="string">@"Q"</span>: @(YATypeNSUInteger),</span><br><span class="line">                           <span class="string">@"d"</span>: @(YATypeCGFloat),</span><br><span class="line">                           <span class="string">@"#"</span>: @(YATypeClass),</span><br><span class="line">                           <span class="string">@":"</span>: @(YATypeSEL),</span><br><span class="line">                           <span class="string">@"@"</span>: @(YATypeObject),</span><br><span class="line">                           <span class="string">@"1"</span>: @(YATypeDate),</span><br><span class="line">                           <span class="string">@"2"</span>: @(YATypeArray),</span><br><span class="line">                           <span class="string">@"3"</span>: @(YATypeMutableArray),</span><br><span class="line">                           <span class="string">@"4"</span>: @(YATypeDictionary),</span><br><span class="line">                           <span class="string">@"5"</span>: @(YATypeMutableDictionary),</span><br><span class="line">                           <span class="string">@"6"</span>: @(YATypeSet),</span><br><span class="line">                           <span class="string">@"7"</span>: @(YATypeMutableSet),</span><br><span class="line">                           <span class="string">@"8"</span>: @(YATypeString),</span><br><span class="line">                           <span class="string">@"9"</span>: @(YATypeMutableString),</span><br><span class="line">                           <span class="string">@"10"</span>: @(YATypeData),</span><br><span class="line">                           <span class="string">@"11"</span>: @(YATypeNumber),</span><br><span class="line">                           <span class="string">@"12"</span>: @(YATypeDecimalNumber),</span><br><span class="line">                           &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _SELDictionary[type] ?: @(YATypeUnknown);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ObjSetWithArray(Class cls, <span class="built_in">NSDictionary</span> *propertyDict, <span class="built_in">NSArray</span> **keyValueArray) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *tmpArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [*keyValueArray enumerateObjectsUsingBlock:^(<span class="keyword">id</span> keyValue, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([keyValue isKindOfClass:<span class="built_in">NSDictionary</span>.class]) &#123;</span><br><span class="line">            <span class="keyword">id</span> obj = [cls new];</span><br><span class="line">            ObjSetWithKeyValueList(obj, PropertyList([obj <span class="keyword">class</span>]), keyValue);</span><br><span class="line">            [tmpArray addObject:obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    *keyValueArray = [<span class="built_in">NSArray</span> arrayWithArray:tmpArray];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ObjSetWithKeyValueList(<span class="keyword">id</span> obj, <span class="built_in">NSDictionary</span> *propertyDict, <span class="built_in">NSDictionary</span> *dict) &#123;</span><br><span class="line">    Class cls = [obj <span class="keyword">class</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *customPropertyKeyDict = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(customPropertyKey)]) &#123;</span><br><span class="line">        customPropertyKeyDict = [cls customPropertyKey];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(classInArray)] &amp;&amp; !classArrayDict) &#123;</span><br><span class="line">        classArrayDict = [cls classInArray];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [propertyDict.allKeys enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *name, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        SEL <span class="keyword">setter</span> = SetterSelectorFromString(name);</span><br><span class="line">        <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (customPropertyKeyDict[name]) &#123;</span><br><span class="line">            value = customPropertyKeyDict[name];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value = dict[name];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">id</span> propType = propertyDict[name];</span><br><span class="line">        YAType type = [propType integerValue];</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (type &amp; YATypeMask) &#123;</span><br><span class="line">                <span class="keyword">case</span> YATypeBOOL: &#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">bool</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, [value boolValue]);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeNSInteger: &#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, int64_t))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, (int64_t)[value longLongValue]);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeNSUInteger: &#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, uint64_t))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, (uint64_t)[value unsignedLongLongValue]);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeCGFloat: &#123;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">double</span> d = [value doubleValue];</span><br><span class="line">                    <span class="keyword">if</span> (isnan(d) || isinf(d)) d = <span class="number">0</span>;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">long</span> <span class="keyword">double</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, (<span class="keyword">long</span> <span class="keyword">double</span>)d);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeDecimalNumber: &#123;</span><br><span class="line">                    <span class="keyword">if</span> ([value isKindOfClass:<span class="built_in">NSNumber</span>.class]) &#123;</span><br><span class="line">                        <span class="built_in">NSDecimalNumber</span> *decNum = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithDecimal:[value decimalValue]];</span><br><span class="line">                        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">NSDecimalNumber</span> *))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, decNum);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeClass: &#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, Class))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, <span class="built_in">NSClassFromString</span>(value));</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeSEL:&#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, <span class="built_in">NSSelectorFromString</span>(value));</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeDate:&#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, DateFromString(value));</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeArray: &#123;</span><br><span class="line">                    Class cls = classArrayDict[name];</span><br><span class="line">                    <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">                        ObjSetWithArray(cls, PropertyList(cls), &amp;value);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeMutableArray: &#123;</span><br><span class="line">                    <span class="built_in">NSString</span> *clsStr = classArrayDict[name];</span><br><span class="line">                    <span class="keyword">if</span> (clsStr) &#123;</span><br><span class="line">                        Class cls = <span class="built_in">NSClassFromString</span>(clsStr);</span><br><span class="line">                        ObjSetWithArray(cls, PropertyList(cls), &amp;value);</span><br><span class="line">                    &#125;</span><br><span class="line">                    value = [<span class="built_in">NSMutableArray</span> arrayWithArray:value];</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeSet: &#123;</span><br><span class="line">                    value = [<span class="built_in">NSSet</span> setWithArray:value];</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeMutableSet: &#123;</span><br><span class="line">                    value = [<span class="built_in">NSMutableSet</span> setWithArray:value];</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeMutableString:</span><br><span class="line">                <span class="keyword">case</span> YATypeMutableDictionary: &#123;</span><br><span class="line">                    value = [value mutableCopy];</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeString:</span><br><span class="line">                <span class="keyword">case</span> YATypeDictionary:</span><br><span class="line">                <span class="keyword">case</span> YATypeNumber:</span><br><span class="line">                <span class="keyword">case</span> YATypeUnknown:</span><br><span class="line">                <span class="keyword">case</span> YATypeObject: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (type == YATypeUnknown &amp;&amp; [propType isKindOfClass:<span class="built_in">NSString</span>.class]) &#123; <span class="comment">// 嵌套模型</span></span><br><span class="line">                        Class cls = <span class="built_in">NSClassFromString</span>(propType);</span><br><span class="line">                        <span class="keyword">if</span> (cls &amp;&amp; [value isKindOfClass:<span class="built_in">NSDictionary</span>.class]) &#123;</span><br><span class="line">                            <span class="keyword">id</span> obj = [cls new];</span><br><span class="line">                            ObjSetWithKeyValueList(obj, PropertyList(cls), value);</span><br><span class="line">                            value = obj;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name  ==&gt; setName:</span></span><br><span class="line"><span class="keyword">static</span> SEL SetterSelectorFromString(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str || str.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *result = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@%@:"</span>, [str substringToIndex:<span class="number">1</span>].uppercaseString, [str substringFromIndex:<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSSelectorFromString</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// date string ==&gt; data // @"2016-7-16 09:33:22"</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDate</span> *DateFromString(<span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">NSDate</span>* (^DateParseBlock)(<span class="built_in">NSString</span> *string);</span><br><span class="line">    <span class="keyword">static</span> DateParseBlock blocks[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// @"2016-07-16 09:33:22" // 19个字符, 对应blocks[19]</span></span><br><span class="line">        <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">        formatter.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">        formatter.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">        blocks[<span class="number">19</span>] = ^(<span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">            <span class="keyword">return</span> [formatter dateFromString:string];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!string || string.length &gt; <span class="number">19</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    DateParseBlock parser = blocks[string.length];</span><br><span class="line">    <span class="keyword">if</span> (!parser) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> parser(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>具体源码放在了我的代码工具库里，YAKit：<a href="https://github.com/ChenYalun/YAKit/tree/master/Util/Model" target="_blank" rel="noopener">https://github.com/ChenYalun/YAKit/tree/master/Util/Model</a></p><blockquote><p>参考资料<br> <a href="https://juejin.im/post/5a097435f265da431769a49c" target="_blank" rel="noopener">https://juejin.im/post/5a097435f265da431769a49c</a><br> <a href="https://juejin.im/post/5a1296e36fb9a044fb075d5e" target="_blank" rel="noopener">https://juejin.im/post/5a1296e36fb9a044fb075d5e</a><br> <a href="https://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/</a><br> <a href="https://blog.csdn.net/game3108/article/details/52416868" target="_blank" rel="noopener">https://blog.csdn.net/game3108/article/details/52416868</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 关于YYModel的简单总结。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>详解performSelector</title>
    <link href="http://blog.chenyalun.com/2018/09/30/%E8%AF%A6%E8%A7%A3performSelector/"/>
    <id>http://blog.chenyalun.com/2018/09/30/详解performSelector/</id>
    <published>2018-09-30T09:22:13.000Z</published>
    <updated>2019-01-10T06:22:49.013Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> performSelector相关知识。 </p><a id="more"></a><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object1 withObject:<span class="params">(id)</span>object2;</span><br></pre></td></tr></table></figure><p>代码:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参</span></span><br><span class="line">- (<span class="keyword">id</span>)printString &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个参数</span></span><br><span class="line">- (<span class="keyword">id</span>)printString:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个参数</span></span><br><span class="line">- (<span class="keyword">id</span>)printString:(<span class="built_in">NSString</span> *)str1 str2:(<span class="keyword">id</span>)obj &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, str1, obj[<span class="string">@"key"</span>]);</span><br><span class="line">    <span class="keyword">return</span> str1;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">id</span> obj1 = [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(printString)];</span><br><span class="line"><span class="keyword">id</span> obj2 = [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(printString:) withObject:<span class="string">@"string"</span>];</span><br><span class="line"><span class="keyword">id</span> obj3 = [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(printString:str2:) withObject:<span class="string">@"string"</span> withObject:@&#123;<span class="string">@"key"</span>: @(<span class="number">3</span>)&#125;];</span><br></pre></td></tr></table></figure><p>实现方式: </p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) performSelector: (SEL)aSelector</span><br><span class="line">    withObject: (<span class="keyword">id</span>) object1</span><br><span class="line">    withObject: (<span class="keyword">id</span>) object2</span><br><span class="line">&#123;</span><br><span class="line">  IMP msg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (aSelector == <span class="number">0</span>)</span><br><span class="line">    [<span class="built_in">NSException</span> raise: <span class="built_in">NSInvalidArgumentException</span></span><br><span class="line">format: <span class="string">@"%@ null selector given"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">  msg = objc_msg_lookup(<span class="keyword">self</span>, aSelector);</span><br><span class="line">  <span class="keyword">if</span> (!msg)</span><br><span class="line">    &#123;</span><br><span class="line">      [<span class="built_in">NSException</span> raise: <span class="built_in">NSGenericException</span></span><br><span class="line">   format: <span class="string">@"invalid selector '%s' passed to %s"</span>,</span><br><span class="line">                   sel_getName(aSelector), sel_getName(_cmd)];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (*msg)(<span class="keyword">self</span>, aSelector, object1, object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Runtime中的API<code>objc_msg_lookup()</code>，根据方法名获取到函数指针IMP，进而进行间接调用。在这其中还包括了方法名和函数指针的容错处理。<br>主要就是这样:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 获取函数指针</span></span><br><span class="line"><span class="type">IMP</span> imp = [<span class="keyword">self</span> methodForSelector:@selector(printString:)];</span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line">void (*<span class="function"><span class="keyword">func</span>)<span class="params">(id, SEL, id)</span></span> = (void *)imp;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">self</span>, @selector<span class="params">(printString:)</span></span></span>, @<span class="string">"string"</span>);</span><br></pre></td></tr></table></figure><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><ol><li>调用<code>alloc, copy, init, mutableCopy, new</code>等方法出现内存泄露。</li><li>调用以<code>alloc, new, copy, mutableCopy</code>开头的方法出现内存泄露。You create an object using a method whose name begins with “alloc”, “new”, “copy”, or “mutableCopy” (for example, alloc, newObject, or mutableCopy).</li></ol><ul><li>有内存泄露</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"mutableString"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调用出现Error: PerformSelector names a selector which retains the object</span></span><br><span class="line">[str performSelector:<span class="keyword">@selector</span>(<span class="keyword">copy</span>)];</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(newObject)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式调用无法分析出错误: 出现内存泄露</span></span><br><span class="line"><span class="keyword">id</span> obj4 = [str performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"copy"</span>)];</span><br><span class="line">[str performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"mutableCopy"</span>)];</span><br><span class="line"><span class="keyword">id</span> newObject = [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"new"</span>)];</span><br></pre></td></tr></table></figure><ul><li>没有内存泄露</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有内存泄露</span></span><br><span class="line">- (<span class="keyword">id</span>)createNewObject &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"string"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">id</span> newObject = [<span class="keyword">self</span> performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"createNewObject"</span>)];</span><br></pre></td></tr></table></figure><ul><li>有内存泄露</li></ul><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有内存泄露</span></span><br><span class="line">- (id)<span class="keyword">new</span><span class="type">Object</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [NSObject <span class="keyword">new</span><span class="type"></span>];</span><br><span class="line">&#125;</span><br><span class="line">id <span class="keyword">new</span><span class="type">Object</span> = [self performSelector:<span class="type">NSSelectorFromString</span>(@<span class="string">"newObject"</span>)];</span><br></pre></td></tr></table></figure><p>There are really only 4 things that ARC would consider for the return value:4</p><ul><li>Ignore non-object types (void, int, etc)</li><li>Retain object value, then release when it is no longer used (standard assumption)</li><li>Release new object values when no longer used (methods in the init/ copy family or attributed with ns_returns_retained)</li><li>Do nothing &amp; assume returned object value will be valid in local scope (until inner most release pool is drained, attributed with ns_returns_autoreleased)</li></ul><p>The call to methodForSelector: assumes that the return value of the method it’s calling is an object, but does not retain/release it. So you could end up creating a leak if your object is supposed to be released as in #3 above (that is, the method you’re calling returns a new object).</p><p><img src="https://image.chenyalun.com/2018/09/30/002.png" alt=""></p><p>内存泄露的原因:</p><ol><li>调用<code>performSelector:</code>编译器会假设调用方法的返回值是一个对象，且不会对返回值进行retain/release。</li><li>如果调用的方法是<code>alloc, new, copy, mutableCopy</code>家族中的方法(包含以它们开头)，方法调用的结果是开辟了一块内存空间，但是系统仍然按照非retain/release处理，内存空间无法释放，故而产生内存泄露。</li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>下面的是为了消除警告而列出的方法。</p><h4 id="方式一-methodForSelector-没有解决内存泄露"><a href="#方式一-methodForSelector-没有解决内存泄露" class="headerlink" title="方式一: methodForSelector(没有解决内存泄露)"></a>方式一: methodForSelector(没有解决内存泄露)</h4><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!person) return;</span><br><span class="line"><span class="comment">// 获取函数指针</span></span><br><span class="line">IMP imp = [person methodForSelector:<span class="keyword">selector</span>];</span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line">void <span class="comment">(*func)(id, SEL) = (void *)</span>imp;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">func(person, <span class="keyword">selector</span>);</span><br></pre></td></tr></table></figure><h4 id="方式二-methodForSelector简化版-没有解决内存泄露"><a href="#方式二-methodForSelector简化版-没有解决内存泄露" class="headerlink" title="方式二: methodForSelector简化版(没有解决内存泄露)"></a>方式二: methodForSelector简化版(没有解决内存泄露)</h4><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">((<span class="name">void</span> (<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))[person methodForSelector:selector])(<span class="name">self</span>, selector)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="方式三-消除警告-没有解决内存泄露"><a href="#方式三-消除警告-没有解决内存泄露" class="headerlink" title="方式三: 消除警告(没有解决内存泄露)"></a>方式三: 消除警告(没有解决内存泄露)</h4><figure class="highlight leaf"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic push"</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic ignored \"</span>-<span class="variable">Warc</span>-<span class="variable">performSelector</span>-<span class="variable">leaks</span>\<span class="string">""</span>)</span></span></span><br><span class="line">[person performSelector:selector]; // 插入需要消除警告的代码</span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic pop"</span>)</span></span></span><br><span class="line">     </span><br><span class="line">// 使用<span class="function"><span class="keyword">#</span><span class="title">pragm</span><span class="params">(与以上无异)</span></span></span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored "-Warc-performSelector-leaks"</span><br><span class="line">YAPerson *person = [[YAPerson alloc] init];</span><br><span class="line">[person performSelector:selector];</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure><h4 id="方式四-使用objc-msgSend-没有解决内存泄露"><a href="#方式四-使用objc-msgSend-没有解决内存泄露" class="headerlink" title="方式四: 使用objc_msgSend(没有解决内存泄露)"></a>方式四: 使用objc_msgSend(没有解决内存泄露)</h4><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">((<span class="name">void</span> *(<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))objc_msgSend)((<span class="name"><span class="builtin-name">id</span></span>)self, NSSelectorFromString(@<span class="string">"newObject"</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="方式五-objc-msgSend手动释放内存-解决内存泄露"><a href="#方式五-objc-msgSend手动释放内存-解决内存泄露" class="headerlink" title="方式五: objc_msgSend手动释放内存(解决内存泄露)"></a>方式五: objc_msgSend手动释放内存(解决内存泄露)</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 就是方式二, 只不过添加了Release Bridge</span></span><br><span class="line"><span class="keyword">id</span> obj = <span class="built_in">CFBridgingRelease</span>(((<span class="keyword">void</span> *(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(<span class="keyword">self</span>, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)));</span><br></pre></td></tr></table></figure><h4 id="方式六-methodForSelector手动释放内存-解决内存泄露"><a href="#方式六-methodForSelector手动释放内存-解决内存泄露" class="headerlink" title="方式六: methodForSelector手动释放内存(解决内存泄露)"></a>方式六: methodForSelector手动释放内存(解决内存泄露)</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = <span class="built_in">CFBridgingRelease</span>(((<span class="keyword">void</span> *(*)(<span class="keyword">id</span>, SEL))[<span class="keyword">self</span> methodForSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)])(<span class="keyword">self</span>, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)));</span><br></pre></td></tr></table></figure><h4 id="方式七-NSInvocation-没有解决内存泄露"><a href="#方式七-NSInvocation-没有解决内存泄露" class="headerlink" title="方式七: NSInvocation(没有解决内存泄露)"></a>方式七: NSInvocation(没有解决内存泄露)</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>);</span><br><span class="line"><span class="built_in">NSMethodSignature</span> *methodSig = [[<span class="keyword">self</span> <span class="keyword">class</span>] instanceMethodSignatureForSelector:selector];</span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:methodSig];</span><br><span class="line">[invocation setSelector:selector];</span><br><span class="line">[invocation setTarget:<span class="keyword">self</span>];</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure><h4 id="方式八-sendAction-没有解决内存泄露"><a href="#方式八-sendAction-没有解决内存泄露" class="headerlink" title="方式八: sendAction(没有解决内存泄露)"></a>方式八: sendAction(没有解决内存泄露)</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIApplication</span>.sharedApplication sendAction:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>) to:<span class="keyword">self</span> from:<span class="literal">nil</span> forEvent:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>除此之外，还有许多许多，并没有全部列出来。尤其是一些看似<code>一顿操作猛如虎</code>却没有解决实质问题的方法。<br>总结以上方法，既能消除警告，又能避免内存泄露，还不会丢掉动态调用的便利，三全其美的便是方法五和方法六，尤其是方法五。当然，两者本质上是一样的，只不过一个看着顺眼些。核心还是<code>CFBridgingRelease</code>: 把遗漏的对象释放掉。<br>(注: 笔者目前没有在网上看到有人使用类似的方法，但是，亲自实验过后发现其确实可以解决内存泄露问题。若有不妥，请指正:<a href="mailto:iChenYalun@gmail.com" target="_blank" rel="noopener">iChenYalun@gmail.com</a>)</p><h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument;</span><br><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget;</span><br></pre></td></tr></table></figure><h3 id="performSelector-withObject-afterDelay"><a href="#performSelector-withObject-afterDelay" class="headerlink" title="performSelector:withObject:afterDelay:"></a>performSelector:withObject:afterDelay:</h3><p>源码实现:</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">- (void)performSelector: (<span class="keyword">SEL)aSelector</span></span><br><span class="line"><span class="keyword"></span>      withObject: (id)argument</span><br><span class="line"><span class="symbol">      afterDelay:</span> (NSTimeInterval)seconds &#123;</span><br><span class="line">  NSRunLoop*loop = [NSRunLoop currentRunLoop]<span class="comment">;</span></span><br><span class="line">  GSTimedPerformer*<span class="keyword">item;</span></span><br><span class="line"><span class="keyword"> </span> // <span class="keyword">item引用计数+1</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">item </span>= [[GSTimedPerformer alloc] initWithSelector: aSelector</span><br><span class="line"><span class="symbol">     target:</span> <span class="keyword">self</span></span><br><span class="line"><span class="keyword"></span>   argument: argument</span><br><span class="line"><span class="symbol">      delay:</span> seconds]<span class="comment">;</span></span><br><span class="line">// 持有<span class="keyword">item</span></span><br><span class="line"><span class="keyword"> </span> [[loop _timedPerformers] <span class="keyword">addObject: </span><span class="keyword">item];</span></span><br><span class="line"><span class="keyword"> </span> // <span class="keyword">item引用计数-1</span></span><br><span class="line"><span class="keyword"> </span> RELEASE(<span class="keyword">item);</span></span><br><span class="line"><span class="keyword"> </span> // 持有timer</span><br><span class="line">  [loop <span class="keyword">addTimer: </span><span class="keyword">item-&gt;timer </span>forMode: NSDefaultRunLoopMode]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要做了这些事:</p><ol><li>获取当前线程的Runloop对象。</li><li>根据方法名、方法参数、方法调用者及延迟时间等信息创建一个GSTimedPerformer对象，把该对象添加到Runloop的_timedPerformers数组中保存。</li><li>把GSTimedPerformer中的定时器timer添加到Runloop中。</li></ol><p>如官方文档所说:This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode.</p><p>看看GSTimedPerformer做了什么:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GSTimedPerformer</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">  SELselector;</span><br><span class="line">  <span class="keyword">id</span>target;</span><br><span class="line">  <span class="keyword">id</span>argument;</span><br><span class="line">  <span class="built_in">NSTimer</span>*timer;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)fire;</span><br><span class="line">- (<span class="keyword">id</span>)initWithSelector: (SEL)aSelector</span><br><span class="line"> target: (<span class="keyword">id</span>)target</span><br><span class="line">       argument: (<span class="keyword">id</span>)argument</span><br><span class="line">  delay: (<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line">- (<span class="keyword">void</span>)invalidate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GSTimedPerformer</span></span></span><br><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">  [<span class="keyword">self</span> finalize];</span><br><span class="line">  TEST_RELEASE(timer);</span><br><span class="line">  <span class="comment">// 释放target对象</span></span><br><span class="line">  RELEASE(target);</span><br><span class="line">  RELEASE(argument);</span><br><span class="line">  [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) finalize &#123;</span><br><span class="line">  [<span class="keyword">self</span> invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) fire &#123;</span><br><span class="line">   DESTROY(timer);</span><br><span class="line">   [target performSelector: selector withObject: argument];</span><br><span class="line">   [[[<span class="built_in">NSRunLoop</span> currentRunLoop] _timedPerformers]</span><br><span class="line">    removeObjectIdenticalTo: <span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithSelector:(SEL)aSelector</span><br><span class="line">                target:(<span class="keyword">id</span>)aTarget</span><br><span class="line">              argument:(<span class="keyword">id</span>)anArgument</span><br><span class="line">                 delay:(<span class="built_in">NSTimeInterval</span>)delay &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        selector = aSelector;</span><br><span class="line">        <span class="comment">// 持有target</span></span><br><span class="line">        target = RETAIN(aTarget);</span><br><span class="line">        argument = RETAIN(anArgument);</span><br><span class="line">        timer = [[<span class="built_in">NSTimer</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()]</span><br><span class="line">                 initWithFireDate: <span class="literal">nil</span></span><br><span class="line">                 interval: delay</span><br><span class="line">                 target: <span class="keyword">self</span></span><br><span class="line">                 selector: <span class="keyword">@selector</span>(fire)</span><br><span class="line">                 userInfo: <span class="literal">nil</span></span><br><span class="line">                 repeats: <span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">        DESTROY(timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>The GSTimedPerformer class is used to hold information about messages which are due to be sent to objects at a particular time.</p><p>由此可见，<code>GSTimedPerformer</code>作用就是保存关于消息的信息，具体方法的延迟和调用主要还是依靠其内部的定时器。<br>综上，Runloop的<code>_timedPerformers</code>数组持有了<code>GSTimedPerformer</code>，Runloop还持有<code>GSTimedPerformer</code>内部的定时器<code>timer</code>。<code>GSTimedPerformer</code>持有了<code>target(self)</code>。<code>GSTimedPerformer</code>销毁的时候释放掉<code>target(self)</code>。<code>GSTimedPerformer</code>什么时候销毁? Runloop运行在<code>NSDefaultRunLoopMode</code>模式下并顺利调用该方法。也即，<code>GSTimedPerformer</code>在定时器时间截止时调用<code>fire</code>方法，之后<code>GSTimedPerformer</code>不再持有timer，接着Runloop不再持有<code>GSTimedPerformer</code>，于是<code>GSTimedPerformer</code>销毁，它对target的强引用也不复存在。</p><p>如图:</p><p><img src="https://image.chenyalun.com/2018/09/30/001.png" alt=""></p><p>这也是网上许多文章所称的”Runloop强持有target对象(self)”。</p><p>当延迟方法因种种原因没有执行就可能出现内存泄露，网上有一篇文章是这样描述的:</p><blockquote><p>performSelector关于内存管理的执行原理是这样的执行 [self performSelector:@selector(method1:) withObject:self afterDelay:3]; 的时候，系统会将self的引用计数加1，执行完这个方法时，还会将self的引用计数减1，当方法还没有执行的时候，要返回父视图释放当前视图的时候，self的计数没有减少到0，而导致无法调用dealloc方法，出现了内存泄露。 </p></blockquote><p>最简单的例子: 从A控制器push到B控制器，B控制器此时执行一个方法:<code>[self performSelector:@selector(printInfo) withObject:nil afterDelay:100];</code>。此时从B控制器pop到A控制器，很明显B控制器并没有销毁，因为Runloop还强引用着它，可以理解为出现了内存泄露(尽管100s后<code>printInfo</code>方法得到执行，B控制器会销毁)。</p><p>比较好的做法是取消掉之前的延迟调用:<code>cancelPreviousPerformRequestsWithTarget: selector:object:</code>，那么<code>cancelPreviousPerformRequestsWithTarget: selector:object:</code>做了什么呢?</p><h3 id="cancelPreviousPerformRequestsWithTarget-selector-object"><a href="#cancelPreviousPerformRequestsWithTarget-selector-object" class="headerlink" title="cancelPreviousPerformRequestsWithTarget: selector:object:"></a>cancelPreviousPerformRequestsWithTarget: selector:object:</h3><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">NSObject</span> cancelPreviousPerformRequestsWithTarget:self]<span class="comment">;</span></span><br><span class="line">[<span class="name">NSObject</span> cancelPreviousPerformRequestsWithTarget:self selector:NSSelectorFromString(<span class="name">@</span><span class="string">"printString:"</span>) object:@<span class="string">"str"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这两个方法可以取消perform延迟调用，它们内部做了什么？</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)target</span><br><span class="line"><span class="symbol">                                        selector:</span>(SEL)aSelector</span><br><span class="line"><span class="symbol">                                          object:</span>(id)arg &#123;</span><br><span class="line">  </span><br><span class="line">    NSMutableArray *perf = [[NSRunLoop currentRunLoop] _timedPerformers]<span class="comment">;</span></span><br><span class="line">    unsigned<span class="built_in">count</span> = [perf <span class="built_in">count</span>]<span class="comment">;</span></span><br><span class="line">    if (<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      GSTimedPerformer*array[<span class="built_in">count</span>]<span class="comment">;</span></span><br><span class="line">      IF_NO_GC(RETAIN(target))<span class="comment">;</span></span><br><span class="line">      IF_NO_GC(RETAIN(arg))<span class="comment">;</span></span><br><span class="line">      [perf getObjects: array]<span class="comment">;</span></span><br><span class="line">        while (<span class="built_in">count</span>-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            GSTimedPerformer*p = array[<span class="built_in">count</span>]<span class="comment">;</span></span><br><span class="line">            if (p-&gt;target == target &amp;&amp; sel_isEqual(p-&gt;selector, aSelector)</span><br><span class="line">                &amp;&amp; (p-&gt;argument == arg <span class="title">||</span> [p-&gt;argument isEqual: arg])) &#123;</span><br><span class="line">                [p invalidate]<span class="comment">;</span></span><br><span class="line">                [perf removeObjectAtIndex: <span class="built_in">count</span>]<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(arg)<span class="comment">;</span></span><br><span class="line">        RELEASE(target)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取Runloop内部持有的_timedPerformers数组(数组中的是GSTimedPerformer对象)。</li><li>创建一个C语言数组，并把_timedPerformers数组中的内容copy到这个C语言数组array。</li><li>遍历该C语言数组array: 如果给定参数中的target、argument、selector均一一对应，那么销毁GSTimedPerformer对象中的定时器，并根据当前的索引移除_timedPerformers数组的GSTimedPerformer对象。</li></ol><p>换句话说，如果target、argument、selector中有一个参数没有对应，那么便不会执行销毁定时器操作和移除操作。那么，判定target、argument、selector均一一对应的标准是:Matching of the argument may be either by pointer equality or by use of the [NSObject-isEqual:] method.就是指针和isEqual方法。</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(p-&gt;</span>target == target </span><br><span class="line">&amp;&amp; <span class="function"><span class="title">sel_isEqual</span>(p-&gt;</span>selector, aSelector)</span><br><span class="line">&amp;&amp; (<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">argument</span> == arg || [p-&gt;</span>argument isEqual: arg])) </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>其实这里的<code>sel_isEqual</code>就等价于<code>==</code>，这样的话如果我们自己需要预先判断参数是否一一对应不妨就按照它这么写。</p><p>同理，<code>+ (void)cancelPreviousPerformRequestsWithTarget:(id)target</code>方法执行原理与上面的方法类似，只是不用比较参数，把所有定时器都销毁，并把所有GSTimedPerformer对象都从_timedPerformers数组中移除。</p><p>如上文所述:</p><blockquote><p>GSTimedPerformer在定时器时间截止时调用<code>fire</code>方法，之后GSTimedPerformer不再持有timer，接着Runloop不再持有GSTimedPerformer，于是GSTimedPerformer销毁，它对target的强引用也不复存在。</p></blockquote><p>当手动销毁定时器并把GSTimedPerformer从Runloop从移除时，GSTimedPerformer销毁，GSTimedPerformer对target的强引用不存在，这样，内存泄露问题解决了。这也是为什么使用<code>cancelPreviousPerformRequestsWithTarget</code>取消还没有执行的perform就可以解决<code>target</code>无法释放掉的原因。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="performSelector-onThread-withObject-waitUntilDone-modes"><a href="#performSelector-onThread-withObject-waitUntilDone-modes" class="headerlink" title="performSelector:onThread:withObject:waitUntilDone:modes:"></a>performSelector:onThread:withObject:waitUntilDone:modes:</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br></pre></td></tr></table></figure><p>要求perform在指定的线程执行。具体的实现如下所示:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector</span><br><span class="line">               onThread:(<span class="built_in">NSThread</span>*)aThread</span><br><span class="line">             withObject:(<span class="keyword">id</span>)anObject</span><br><span class="line">          waitUntilDone:(<span class="built_in">BOOL</span>)aFlag</span><br><span class="line">                  modes:(<span class="built_in">NSArray</span>*)anArray &#123;</span><br><span class="line">  </span><br><span class="line">    GSRunLoopThreadInfo  *info;</span><br><span class="line">    <span class="built_in">NSThread</span> *t;</span><br><span class="line">    <span class="keyword">if</span> ([anArray count] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    t = GSCurrentThread();</span><br><span class="line">    <span class="keyword">if</span> (aThread == <span class="literal">nil</span>) aThread = t;</span><br><span class="line">    info = GSRunLoopInfoForThread(aThread);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t == aThread) &#123;</span><br><span class="line">        <span class="comment">// Perform in current thread.</span></span><br><span class="line">        <span class="keyword">if</span> (aFlag == <span class="literal">YES</span> || info-&gt;loop == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">// Wait until done or no run loop.</span></span><br><span class="line">            [<span class="keyword">self</span> performSelector: aSelector withObject: anObject];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Don't wait ... schedule operation in run loop.</span></span><br><span class="line">            [info-&gt;loop performSelector: aSelector</span><br><span class="line">                                 target: <span class="keyword">self</span></span><br><span class="line">                               argument: anObject</span><br><span class="line">                                  order: <span class="number">0</span></span><br><span class="line">                                  modes: anArray];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GSPerformHolder   *h;</span><br><span class="line">        <span class="built_in">NSConditionLock</span>*l = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 线程Finished判断</span></span><br><span class="line">        <span class="keyword">if</span> ([aThread isFinished] == <span class="literal">YES</span>) &#123;</span><br><span class="line">            [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                      format: <span class="string">@"perform on finished thread"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 阻塞等待加锁</span></span><br><span class="line">        <span class="keyword">if</span> (aFlag == <span class="literal">YES</span>) &#123;</span><br><span class="line">            l = [[<span class="built_in">NSConditionLock</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h = [GSPerformHolder newForReceiver:<span class="keyword">self</span></span><br><span class="line">                   argument:anObject</span><br><span class="line">                   selector:aSelector</span><br><span class="line">                                      modes:anArray</span><br><span class="line">                       lock:l];</span><br><span class="line">        [info addPerformer: h];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 条件锁创建成功(也即参数aFlag为YES)</span></span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">nil</span>) &#123;</span><br><span class="line">            [l lockWhenCondition: <span class="number">1</span>]; <span class="comment">// 当条件为1时加锁</span></span><br><span class="line">            [l unlock];</span><br><span class="line">            RELEASE(l);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// holder已经失效则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> ([h isInvalidated] == <span class="literal">YES</span>) &#123;</span><br><span class="line">                RELEASE(h);</span><br><span class="line">                [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                          format: <span class="string">@"perform on finished thread"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// holder自身就产生exception了, 那么再次抛出异常</span></span><br><span class="line">            <span class="comment">// If we have an exception passed back from the remote thread, re-raise it.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nil</span> != h-&gt;exception) &#123;</span><br><span class="line">              <span class="built_in">NSException</span>       *e = AUTORELEASE(RETAIN(h-&gt;exception));</span><br><span class="line">              RELEASE(h);</span><br><span class="line">              [e raise];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      RELEASE(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要做了这些什么?</p><ol><li>首先对传进来的modes(Runloop模式数组)个数进行判断，如果为0，则直接return。</li><li>获取该方法执行上下文中的线程: <code>t</code>，并把它与作为参数传进来的线程<code>aThread</code>进行比较，看是否一致。当然，如果传进来的<code>aThread</code>为空，那么执行<code>aThread = t;</code>，简单粗暴地假定传进来的线程和上下文中的线程一致。</li><li>当两个线程一致时，如果参数<code>aFlag</code>为YES或者线程对应的Runloop为空，说明需要等待，也即这个方法应该等到selector被执行完毕后再return。这就好办了，直接调用<code>[self performSelector: aSelector withObject: anObject];</code>方法，同步执行即可。如果不需要等待呢? 把<code>selector</code>、<code>argument</code>、<code>modes</code>等信息交给线程对应的Runloop再进一步处理。</li><li>当两个线程不一致时，首先判断<code>aThread</code>有没有finished，线程死了自然selector无法执行，抛出异常。再者判断是否需要阻塞等待，如果需要的话就创建一个条件锁。接着把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个GSPerformHolder对象，并把它交给封装线程信息的GSRunLoopThreadInfo对象。之后是一些收尾工作:设置条件锁的condition及以下异常判断。</li></ol><p>需要着重说明的是参数<code>aFlag</code>: 是否立即返回。如果参数<code>aFlag</code>为YES，则这个方法应该等到selector被执行完毕后再return。那么就有一个问题，这个方法本身并不会触发<code>aThread</code>对应的Runloop运行，换句话说，如果<code>aThread</code>对应的Runloop一直不运行那么这个方法也一直不会return，咦，如果<code>aThread</code>和当前线程一致，Runloop要是一直没运行，那整个程序不就锁在这段代码了吗。</p><p>所以，针对这个特殊情况:参数<code>aFlag</code>为YES且<code>aThread</code>和当前线程一致，那<code>modes</code>将会被忽略，这个selector会立刻执行(因此上面的方法实现中直接调用<code>performSelector:withObject</code>而不是走到条件锁那段代码)。这就巧妙地避免了由于当前线程的Runloop没运行而线程被一个永远无法执行的<code>perform</code>阻塞的问题。</p><h4 id="两个线程一致时"><a href="#两个线程一致时" class="headerlink" title="两个线程一致时"></a>两个线程一致时</h4><p>问题一: 两个线程一致时，”把<code>selector</code>、<code>argument</code>、<code>modes</code>等信息交给线程对应的Runloop再进一步处理。”，具体怎么做的呢?</p><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(SEL)</span>aSelector</span><br><span class="line">            target:<span class="params">(id)</span>target</span><br><span class="line">          argument:<span class="params">(id)</span>argument</span><br><span class="line">           order:<span class="params">(NSUInteger)</span>order</span><br><span class="line">                   modes:<span class="params">(NSArray*)</span>modes;</span><br></pre></td></tr></table></figure><p>Sets up sending of aSelector to target with argument. The selector is sent before the next runloop iteration (unless cancelled before then) in any of the specified modes.The target and argument objects are retained.<br>The order value is used to determine the order in which messages are sent if multiple messages have been set up. Messages with a lower order value are sent first.If the modes array is empty, this method has no effect.<br>说的很明白了，就是在指定模式的Runloop下一次迭代之前把selector、argument等信息丢给target，以便调用。这里的<code>order</code>指定了这个调用的优先级。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector</span><br><span class="line">          target:(<span class="keyword">id</span>)target</span><br><span class="line">        argument:(<span class="keyword">id</span>)argument</span><br><span class="line">           order:(<span class="built_in">NSUInteger</span>)order</span><br><span class="line">                   modes:(<span class="built_in">NSArray</span>*)modes &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">unsigned</span>count = [modes count];</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span>*array[count];</span><br><span class="line">        GSRunLoopPerformer*item;</span><br><span class="line">        item = [[GSRunLoopPerformer alloc] initWithSelector:aSelector</span><br><span class="line">                                                     target: target</span><br><span class="line">                                                   argument: argument</span><br><span class="line">                                                      order: order];</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 把modes中的内容copy到array</span></span><br><span class="line">        <span class="keyword">if</span> ([modes isProxy]) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                array[i] = [modes objectAtIndex: i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [modes getObjects: array];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span>*mode = array[count];</span><br><span class="line">            <span class="keyword">unsigned</span>end;</span><br><span class="line">            <span class="keyword">unsigned</span>i;</span><br><span class="line">            GSRunLoopCtxt*context;</span><br><span class="line">            GSIArrayperformers;</span><br><span class="line"></span><br><span class="line">            context = <span class="built_in">NSMapGet</span>(_contextMap, mode);</span><br><span class="line">            <span class="keyword">if</span> (context == <span class="literal">nil</span>) &#123;</span><br><span class="line">                context = [[GSRunLoopCtxt alloc] initWithMode: mode extra: _extra];</span><br><span class="line">                <span class="built_in">NSMapInsert</span>(_contextMap, context-&gt;mode, context);</span><br><span class="line">                RELEASE(context);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            performers = context-&gt;performers;</span><br><span class="line">            end = GSIArrayCount(performers);</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; end; i++) &#123;</span><br><span class="line">                GSRunLoopPerformer*p;</span><br><span class="line">                p = GSIArrayItemAtIndex(performers, i).obj;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;order &gt; order) &#123;</span><br><span class="line">                    GSIArrayInsertItem(performers, (GSIArrayItem)((<span class="keyword">id</span>)item), i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                GSIArrayInsertItem(performers, (GSIArrayItem)((<span class="keyword">id</span>)item), i);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            i = GSIArrayCount(performers);</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span> &amp;&amp; i &gt; context-&gt;maxPerformers) &#123;</span><br><span class="line">                context-&gt;maxPerformers = i;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"WARNING ... there are %u performers scheduled"</span></span><br><span class="line">                <span class="string">@" in mode %@ of %@\n(Latest: [%@ %@])"</span>,</span><br><span class="line">                i, mode, <span class="keyword">self</span>, <span class="built_in">NSStringFromClass</span>([target <span class="keyword">class</span>]),</span><br><span class="line">                <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据方法实现来看，这个方法做了这些事:</p><ol><li>如果数组modes中没有内容就直接return。</li><li>把<code>target</code>、<code>argument</code>、<code>selector</code>、<code>order</code>等信息包装成一个对象GSRunLoopPerformer。</li><li>创建一个字符串数组array，把modes中的内容copy到array。</li><li>遍历array。根据array中的模式mode(NSString类型)找到_contextMap(NSMapTable类型)表中对应的context(GSRunLoopCtxt类型)，获得context中需要执行的performers(GSIArray类型)。</li><li>把第2步中包装好的GSRunLoopPerformer对象放到performers中。遍历performers，根据order确定优先级，调整performers中的索引。</li></ol><p>总而言之，就是把<code>target</code>、<code>argument</code>、<code>selector</code>、<code>order</code>等信息包装成一个GSRunLoopPerformer对象，并把该对象交给Runloop(中的_contextMap中的performers)，供其在合适的时机调用。具体啥时候调用呢?官方文档说是Runloop的下一次迭代的时候。</p><h4 id="两个线程不一致时"><a href="#两个线程不一致时" class="headerlink" title="两个线程不一致时"></a>两个线程不一致时</h4><p>问题二: 两个线程不一致时，”把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个GSPerformHolder对象，并把它交给封装线程信息的GSRunLoopThreadInfo对象”又是怎么做的呢?</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(GSPerformHolder</span> <span class="string">*)h</span> <span class="string">=</span> <span class="string">[GSPerformHolder</span> <span class="attr">newForReceiver:self</span></span><br><span class="line">                   <span class="attr">argument:anObject</span></span><br><span class="line">                   <span class="attr">selector:aSelector</span></span><br><span class="line"><span class="attr">                            modes:</span><span class="string">anArray</span></span><br><span class="line">                       <span class="attr">lock:l];</span></span><br><span class="line"><span class="string">[(GSRunLoopThreadInfo</span> <span class="string">*)info</span> <span class="attr">addPerformer:</span> <span class="string">h];</span></span><br></pre></td></tr></table></figure><p><code>newForReceiver:argument:selector:modes:lock:</code> 这个方法就是做一些信息封装，无需多言。主要是这个<code>addPerformer</code>，删除<code>#if defined(_WIN32)</code>的代码后具体实现如下:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addPerformer:(<span class="keyword">id</span>)performer &#123;</span><br><span class="line">    <span class="built_in">BOOL</span>  signalled = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">// NSLock加锁</span></span><br><span class="line">    [lock lock];</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> start = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 使用write函数向 outputFd 中写入 1 字节数据，数据为: "0"。</span></span><br><span class="line">    <span class="keyword">while</span> (outputFd &gt;= <span class="number">0</span> &amp;&amp; <span class="literal">NO</span> == (signalled = (write(outputFd, <span class="string">"0"</span>, <span class="number">1</span>) == <span class="number">1</span>) ? <span class="literal">YES</span> : <span class="literal">NO</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSTimeInterval</span>    now = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0.0</span> == start) &#123;</span><br><span class="line">            start = now;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now - start &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Unable to signal %@ within a second; blocked?"</span>, <span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock];</span><br><span class="line">        [lock lock];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据成功，把performer添加到GSRunLoopThreadInfo数组中</span></span><br><span class="line">    <span class="keyword">if</span> (signalled) [performers addObject: performer];</span><br><span class="line">    <span class="comment">// NSLock解锁</span></span><br><span class="line">    [lock unlock];</span><br><span class="line">    <span class="comment">// 写入数据失败，销毁performer</span></span><br><span class="line">    <span class="keyword">if</span> (!signalled) [performer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充write函数知识点:</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * <span class="built_in">write</span>函数</span><br><span class="line"> * ssize_t  <span class="built_in">write</span>(int __fd, const void * __buf, size_t __nbyte) __DARWIN_ALIAS_C(<span class="built_in">write</span>);</span><br><span class="line"> * <span class="built_in">write</span> 函数向 __fd 中写入 __nbyte 字节数据，数据来源为 __buf 。返回值一般总是等于 __nbyte</span><br><span class="line"> * 返回值如果不是等于__nbyte，就是出错了。常见的出错原因是磁盘空间满了或者超过了文件大小限制。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* The <span class="built_in">write</span> could concievably fail <span class="keyword">if</span> <span class="keyword">the</span> pipe <span class="keyword">is</span> full.</span><br><span class="line"> * In <span class="keyword">that</span> case we need <span class="keyword">to</span> release <span class="keyword">the</span> lock temporarily <span class="keyword">to</span> allow <span class="keyword">the</span> other</span><br><span class="line"> * thread <span class="keyword">to</span> consume data <span class="keyword">from</span> <span class="keyword">the</span> pipe.  It's possible <span class="keyword">that</span> <span class="keyword">the</span> thread</span><br><span class="line"> * <span class="keyword">and</span> <span class="keyword">its</span> runloop might stop during <span class="keyword">that</span> ... so we need <span class="keyword">to</span> check <span class="keyword">that</span></span><br><span class="line"> * outputFd <span class="keyword">is</span> still valid.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>不是十分理解write函数在这里的作用，根据一些异常信息<code>&quot;Failed to set non block flag for perform in thread&quot; &quot;Failed to create event to handle perform in thread&quot;</code>，可能是向文件中写入一些flag表示线程指定事件对象的信号状态吧。</p><p>如果信号状态设置成功，就把这个perform对象(GSPerformHolder类型)添加到GSRunLoopThreadInfo的performers数组中。</p><p>这个GSRunLoopThreadInfo对象把GSPerformHolder对象添加到自己数组中后，具体最原先的perform什么时候执行呢? 是在调用GSRunLoopThreadInfo对象的fire方法时逐个执行:</p><p>GSRunLoopThreadInfo对象的<code>fire</code>方法部分实现:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">for</span> <span class="string">(i</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span> <span class="string">i</span> <span class="string">&lt;</span> <span class="string">c;</span> <span class="string">i++)</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line">    <span class="string">GSPerformHolder</span><span class="meta">*h</span> <span class="string">=</span> <span class="string">[toDo</span> <span class="attr">objectAtIndex:</span> <span class="string">i];</span></span><br><span class="line"></span><br><span class="line">    <span class="string">[loop</span> <span class="attr">performSelector:</span> <span class="string">@selector(fire)</span></span><br><span class="line"><span class="attr">     target:</span> <span class="string">h</span></span><br><span class="line"><span class="attr">   argument:</span> <span class="string">nil</span></span><br><span class="line"><span class="attr">      order:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      modes:</span> <span class="string">[h</span> <span class="string">modes]];</span></span><br><span class="line">  <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>可见是逐个取出数组中的<code>GSPerformHolder</code>对象，一个接一个地调用<code>GSPerformHolder</code>的<code>fire</code>方法，这也是个<code>fire</code>方法，它内部做了什么?就是<code>[receiver performSelector: selector withObject: argument];</code>。</p><p>捋一捋: 两个线程不一致时，把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个<code>GSPerformHolder</code>对象，并把它添加到<code>GSRunLoopThreadInfo</code>对象的performers数组中。当调用<code>GSRunLoopThreadInfo</code>对象的<code>fair</code>方法时会遍历performers数组，然后逐个调用数组中每一个元素的<code>fair</code>方法，而这个<code>fair</code>方法内部就是调用<code>performSelector:withObject</code>方法。</p><p>最最关键的一个问题: 什么时候调用<code>GSRunLoopThreadInfo</code>对象的<code>fair</code>方法? 官方文档说: May only be called from the runloop when the event/descriptor is triggered.<br>我在Runloop的<code>+(BOOL)awakenedBefore:</code>和 <code>-(BOOL)pollUntil:within:</code>方法中找到了调用痕迹。</p><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">(void)</span> <span class="attr">performSelector:(SEL)aSelector</span></span><br><span class="line"><span class="attr">                onThread:</span><span class="string">(NSThread*)aThread</span></span><br><span class="line"><span class="attr">              withObject:</span><span class="string">(id)anObject</span></span><br><span class="line"><span class="attr">           waitUntilDone:</span><span class="string">(BOOL)aFlag</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">[self</span> <span class="attr">performSelector:aSelector</span></span><br><span class="line"><span class="attr">               onThread:</span><span class="string">aThread</span></span><br><span class="line"><span class="attr">             withObject:</span><span class="string">anObject</span></span><br><span class="line"><span class="attr">          waitUntilDone:</span><span class="string">aFlag</span></span><br><span class="line"><span class="attr">                  modes:</span><span class="string">commonModes()];</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>Runloop的五种mode分别是:<code>NSDefaultRunLoopMode，NSConnectionReplyMode，NSModalPanelRunLoopMode，NSEventTrackingRunLoopMode，NSRunLoopCommonModes</code>。<br>这个方法省略了modes参数，内部使用common mode，也即<code>NSDefaultRunLoopMode</code>和<code>NSConnectionReplyMode</code>(不是<code>NSEventTrackingRunLoopMode</code>)。所以如果有鼠标或者手势事件需要处理，省略modes参数可能不是个好做法。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">(void)</span> <span class="attr">performSelectorOnMainThread:(SEL)aSelector</span></span><br><span class="line">  <span class="attr">withObject:(id)anObject</span></span><br><span class="line">       <span class="attr">waitUntilDone:(BOOL)aFlag</span></span><br><span class="line">       <span class="attr">modes:(NSArray*)anArray</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">if</span> <span class="string">(defaultThread</span> <span class="string">==</span> <span class="string">nil)</span> <span class="string">[NSThread</span> <span class="string">mainThread];</span></span><br><span class="line">  <span class="string">[self</span> <span class="attr">performSelector:aSelector</span></span><br><span class="line"><span class="attr">               onThread:</span><span class="string">defaultThread</span></span><br><span class="line"><span class="attr">             withObject:</span><span class="string">anObject</span></span><br><span class="line"><span class="attr">          waitUntilDone:</span><span class="string">aFlag</span></span><br><span class="line"><span class="attr">                  modes:</span><span class="string">anArray];</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">(void)performSelectorOnMainThread:(SEL)aSelector</span></span><br><span class="line">  <span class="attr">withObject:(id)anObject</span></span><br><span class="line">       <span class="attr">waitUntilDone:(BOOL)aFlag</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">[self</span> <span class="attr">performSelectorOnMainThread:aSelector</span></span><br><span class="line"> <span class="attr">withObject:anObject</span></span><br><span class="line">      <span class="attr">waitUntilDone:aFlag</span></span><br><span class="line">      <span class="attr">modes:commonModes()];</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这两个方法指定了主线程。一: 如果参数aFlag是YES且方法调用的当前线程就是主线程，那么modes参数会被忽略。与上文所说的”参数<code>aFlag</code>为YES且<code>aThread</code>和当前线程一致，那<code>modes</code>将会被忽略，这个selector会立刻执行”一致。</p><p>后台执行:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">(void)</span> <span class="attr">performSelectorInBackground:(SEL)aSelector</span></span><br><span class="line"><span class="attr">                          withObject:</span><span class="string">(id)anObject</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">[NSThread</span> <span class="attr">detachNewThreadSelector:aSelector</span></span><br><span class="line"><span class="attr">                           toTarget:</span><span class="string">self</span></span><br><span class="line"><span class="attr">                         withObject:</span><span class="string">anObject];</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>就是随意创建一个线程执行selector方法。</p><h2 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h2><h3 id="printInfo方法会执行吗"><a href="#printInfo方法会执行吗" class="headerlink" title="printInfo方法会执行吗"></a>printInfo方法会执行吗</h3><h4 id="GCD调用"><a href="#GCD调用" class="headerlink" title="GCD调用"></a>GCD调用</h4><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">     [self performSelector:@selector(<span class="name">printInfo</span>) withObject<span class="symbol">:nil</span> afterDelay:<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>很明显是不会的。因为performSelector具体实现中并没有主动触发线程对应Runloop运行。子线程对应的Runloop没有run。怎么让它执行?启动Runloop:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [self performSelector:@selector(<span class="name">printInfo</span>) withObject<span class="symbol">:nil</span> afterDelay:<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    [[NSRunLoop currentRunLoop] run]<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="NSThread调用"><a href="#NSThread调用" class="headerlink" title="NSThread调用"></a>NSThread调用</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] <span class="string">initWithBlock:</span>^&#123;</span><br><span class="line">    [self <span class="string">performSelector:</span><span class="meta">@selector</span>(printInfo) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">1</span>];</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure><p>同理:</p><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">NSThread *thread = <span class="comment">[<span class="comment">[NSThread alloc]</span> initWithBlock:^&#123;</span></span><br><span class="line"><span class="comment">    <span class="comment">[self performSelector:@selector(printInfo) withObject:nil afterDelay:1]</span>;</span></span><br><span class="line"><span class="comment">    <span class="comment">[<span class="comment">[NSRunLoop currentRunLoop]</span> run]</span>;</span></span><br><span class="line"><span class="comment">&#125;]</span>;</span><br><span class="line"><span class="comment">[thread start]</span>;</span><br></pre></td></tr></table></figure><p>这就有一个问题了。在GCD中<code>[[NSRunLoop currentRunLoop] run];</code>放在<code>performSelector</code>前面或者后面貌似都是可以的，但是在NSThread中<code>[[NSRunLoop currentRunLoop] run];</code>只能放在<code>performSelector</code>的后面。</p><p>在NSThread方法中:</p><blockquote><p>因为run方法只是尝试想要开启当前线程中的runloop，但是如果该线程中并没有任何事件(source、timer、observer)的话，并不会成功的开启。</p></blockquote><p>为什么GCD中即使<code>[[NSRunLoop currentRunLoop] run];</code>放在前面<code>printInfo</code>方法还是调用了呢? 代码实际测试，延迟效果没有了，并且有时方法执行，有时方法没有执行。</p><p>综上，在子线程中使用performSelector的延迟方法是，需要加上<code>[[NSRunLoop currentRunLoop] run];</code>使得Runloop能够运行，并且该方法要放在<code>performSelector</code>的后面来保证正确成功地开启。</p><h4 id="NSThread无效"><a href="#NSThread无效" class="headerlink" title="NSThread无效"></a>NSThread无效</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">NSThread *thread = [[NSThread alloc] <span class="string">initWithBlock:</span>^&#123;&#125;];</span><br><span class="line">[thread start];</span><br><span class="line">[self <span class="string">performSelector:</span><span class="meta">@selector</span>(printMainInfo) <span class="string">onThread:</span>thread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br></pre></td></tr></table></figure><p>上面这段代码为什么没有执行printMainInfo方法?</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 执行一次而已</span></span><br><span class="line">    <span class="built_in">NSRunLoop</span> *currentRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [currentRunLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(printMainInfo) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure><p>子线程执行完操作之后就会立即释放，即使我们使用强引用引用子线程使子线程不被释放，也不能给子线程再次添加操作，或者再次开启。这里可以使用Runloop。子线程获取其对应的Runloop对象并使之运行。一般使用常驻子线程。</p><hr><blockquote><p>参考资料<br><a href="https://zhongwuzw.github.io/2017/01/19/Objective-C之performSelector编译器内存泄露警告/" target="_blank" rel="noopener">https://zhongwuzw.github.io/2017/01/19/Objective-C之performSelector编译器内存泄露警告/</a><br> <a href="https://blog.csdn.net/dean19900504/article/details/8067679" target="_blank" rel="noopener">https://blog.csdn.net/dean19900504/article/details/8067679</a><br><a href="https://www.jianshu.com/p/4f5566125148" target="_blank" rel="noopener">https://www.jianshu.com/p/4f5566125148</a><br> <a href="https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown" target="_blank" rel="noopener">https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown</a><br> <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html</a><br> <a href="https://blog.csdn.net/wei371522/article/details/81216853" target="_blank" rel="noopener">https://blog.csdn.net/wei371522/article/details/81216853</a><br> <a href="https://blog.csdn.net/king16304/article/details/52192259" target="_blank" rel="noopener">https://blog.csdn.net/king16304/article/details/52192259</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; performSelector相关知识。 &lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Runtime基础</title>
    <link href="http://blog.chenyalun.com/2018/07/10/Runtime%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.chenyalun.com/2018/07/10/Runtime基础/</id>
    <published>2018-07-10T15:02:17.000Z</published>
    <updated>2018-12-12T09:26:45.693Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018.8.26 更新Class定义</p></blockquote><p></p><p align="center"> 关于Runtime的简单总结。 </p><br><a id="more"></a><p></p><p>代码中省略<code>OBJC2_UNAVAILABLE</code>,也即不可直接访问结构体中的成员.</p><h2 id="一、Runtime"><a href="#一、Runtime" class="headerlink" title="一、Runtime"></a>一、Runtime</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Objective-C2<span class="number">.0</span>之前Class的定义</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">    <span class="comment">// 父类</span></span><br><span class="line">    Class super_class;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">long</span> version;</span><br><span class="line">    <span class="keyword">long</span> info;</span><br><span class="line">    <span class="keyword">long</span> instance_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>;</span></span><br><span class="line">    <span class="comment">// 方法缓存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied;</span><br><span class="line">    Method buckets[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">根据源码，最新定义大致如下:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;<span class="comment">// 方法缓存</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits; <span class="comment">// 用于获取具体的类信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> YAPerson *person = [[YAPerson alloc] init];</span><br><span class="line">    Class cls = [person class];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取实例对象对应的Class</span></span><br><span class="line">    Class class1 = object_getClass(person);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指定名称的类对象</span></span><br><span class="line">    Class class3 = objc_getClass(<span class="string">"YAPerson"</span>);</span><br><span class="line">    Class class2 = objc_getRequiredClass(<span class="string">"YAPerson"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指定名称的元类对象</span></span><br><span class="line">    Class class4 = objc_getMetaClass(<span class="string">"YAPerson"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到指定名称的类对象</span></span><br><span class="line">    Class class5 = objc_lookUpClass(<span class="string">"NSObject"</span>);</span><br><span class="line">    NSLog(@<span class="string">"%@%@%@%@%@"</span>,class1,class2,class3,class4,class5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置对象对应的Class,返回原先的class</span></span><br><span class="line">    Class oriClass = object_setClass(person, [NSObject class]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是类对象或元类对象</span></span><br><span class="line">    BOOL isClass = object_isClass(person);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否是元类对象</span></span><br><span class="line">    BOOL isMetaClass = class_isMetaClass(class4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取父类</span></span><br><span class="line">    Class superClass = class_getSuperclass(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取类的版本</span></span><br><span class="line">    <span class="keyword">int</span> version = class_getVersion(cls);</span><br><span class="line">    <span class="comment">// 设置类的版本</span></span><br><span class="line">    class_setVersion(cls, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例大小</span></span><br><span class="line">    <span class="keyword">typedef</span> __SIZE_TYPE__ <span class="keyword">size_t</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> size = class_getInstanceSize(cls);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    int objc_getClassList(Class *buffer, int bufferCount)</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    Class *objc_copyClassList(unsigned int *outCount)</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line">    <span class="comment">// 获取类的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = class_getName(cls);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态创建类</span></span><br><span class="line">    <span class="comment">//Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</span></span><br><span class="line">    <span class="comment">//void objc_registerClassPair(Class cls)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态废弃类</span></span><br><span class="line">    <span class="comment">//Class objc_duplicateClass(Class original, const char *name, size_t extraBytes)</span></span><br><span class="line">    <span class="comment">//void objc_disposeClassPair(Class cls)</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//id o = objc_storeWeak(&amp;weakObject, weakObject);</span></span><br><span class="line">    <span class="comment">//id result = objc_loadWeak(&amp;weakObject);</span></span><br></pre></td></tr></table></figure><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">给<span class="keyword">block创建一个关联的函数指针</span></span><br><span class="line"><span class="keyword">IMP </span>imp_implementationWithBlock(id <span class="keyword">block)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">获取函数指针关联的block</span></span><br><span class="line"><span class="keyword">id </span>imp_getBlock(IMP anImp)</span><br><span class="line"></span><br><span class="line">移除函数指针对应的<span class="keyword">block</span></span><br><span class="line"><span class="keyword">BOOL </span>imp_removeBlock(IMP anImp)</span><br></pre></td></tr></table></figure><p>实例演练</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^Block) ();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义block</span></span><br><span class="line">Block block = ^() &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"哈哈哈"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给block创建一个关联的函数指针</span></span><br><span class="line">IMP imp = imp_implementationWithBlock(block);</span><br><span class="line"><span class="comment">// 调用block</span></span><br><span class="line">(*imp)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数指针关联的block</span></span><br><span class="line"><span class="keyword">id</span> blockObject = imp_getBlock(imp);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,blockObject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除函数指针对应的block</span></span><br><span class="line"><span class="built_in">BOOL</span> isRemoveBlock = imp_removeBlock(imp);</span><br><span class="line"><span class="keyword">if</span> (isRemoveBlock) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"成功移除"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">获取<span class="keyword">SEL的名称(char </span>*类型)</span><br><span class="line"><span class="symbol">const</span> char *<span class="keyword">sel_getName(SEL </span><span class="keyword">sel)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">注册SEL</span></span><br><span class="line"><span class="keyword">SEL </span><span class="keyword">sel_registerName(const </span>char *<span class="keyword">str)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">比较SEL</span></span><br><span class="line"><span class="keyword">BOOL </span><span class="keyword">sel_isEqual(SEL </span>lhs, <span class="keyword">SEL </span>rhs)</span><br></pre></td></tr></table></figure><p>实例演练</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取SEL的名称(char *类型)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *selName = sel_getName(<span class="keyword">@selector</span>(viewWillAppear:));</span><br><span class="line">printf(<span class="string">"%s"</span>,selName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册SEL</span></span><br><span class="line">SEL newSel = sel_registerName(<span class="string">"haha"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较SEL</span></span><br><span class="line"><span class="built_in">BOOL</span> isEqual = sel_isEqual(<span class="keyword">@selector</span>(viewWillAppear:), newSel);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,isEqual);</span><br></pre></td></tr></table></figure><h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">定义一个objc_ivar结构体指针Ivar</span><br><span class="line"><span class="keyword">typedef</span> struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct objc_ivar &#123;</span><br><span class="line">    成员变量名称</span><br><span class="line">    <span class="keyword">char</span> *ivar_name;</span><br><span class="line">    成员变量类型                                         </span><br><span class="line">    <span class="keyword">char</span> *ivar_type;                                          </span><br><span class="line">    偏移量</span><br><span class="line">    <span class="keyword">int</span> ivar_offset;                                          </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space;                                                </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于偏移量的定义(就是整型)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__PTRDIFF_TYPE__)</span></span><br><span class="line">    <span class="keyword">typedef</span> __PTRDIFF_TYPE____darwin_ptrdiff_t;<span class="comment">/* ptr1 - ptr2 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__LP64__)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span>__darwin_ptrdiff_t;<span class="comment">/* ptr1 - ptr2 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span>__darwin_ptrdiff_t;<span class="comment">/* ptr1 - ptr2 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __GNUC__ */</span></span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _PTRDIFF_T</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PTRDIFF_T</span></span><br><span class="line">    <span class="keyword">typedef</span> __darwin_ptrdiff_t ptrdiff_t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _PTRDIFF_T */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">成员变量列表</span><br><span class="line">struct objc_ivar_list &#123;</span><br><span class="line">    成员变量数量</span><br><span class="line">    <span class="keyword">int</span> ivar_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    struct objc_ivar ivar_list[<span class="number">1</span>];</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">获取实例变量</span><br><span class="line">Ivar class_getInstanceVariable(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取类变量</span></span><br><span class="line"><span class="comment">//Ivar class_getClassVariable(Class cls, const char *name)</span></span><br><span class="line">    </span><br><span class="line">获取成员变量列表</span><br><span class="line">Ivar *class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line">   </span><br><span class="line">获取Ivar变量的名称</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getName(Ivar v)</span><br><span class="line">    </span><br><span class="line">获取Ivar变量的偏移量</span><br><span class="line">ptrdiff_t ivar_getOffset(Ivar v)</span><br><span class="line">    </span><br><span class="line">获取Ivar变量的编码</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getTypeEncoding(Ivar v)</span><br><span class="line">    </span><br><span class="line">设置成员变量的值</span><br><span class="line"><span class="keyword">void</span> object_setIvarWithStrongDefault(id obj, Ivar ivar, id value)</span><br><span class="line"></span><br><span class="line">设置成员变量的值</span><br><span class="line"><span class="keyword">void</span> object_setIvar(id obj, Ivar ivar, id value)</span><br><span class="line"></span><br><span class="line">获取Ivar对应的成员变量对象</span><br><span class="line">id object_getIvar(id obj, Ivar ivar)</span><br><span class="line"></span><br><span class="line">IvarLayout相关</span><br><span class="line"><span class="keyword">const</span> uint8_t *class_getIvarLayout(Class cls)</span><br><span class="line"><span class="keyword">const</span> uint8_t *class_getWeakIvarLayout(Class cls)</span><br><span class="line"><span class="keyword">void</span> class_setIvarLayout(Class cls, <span class="keyword">const</span> uint8_t *layout)</span><br><span class="line"><span class="keyword">void</span> class_setWeakIvarLayout(Class cls, <span class="keyword">const</span> uint8_t *layout)</span><br><span class="line">    </span><br><span class="line">添加成员变量</span><br><span class="line">BOOL class_addIvar(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t <span class="built_in">size</span>,</span><br><span class="line">                  uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br></pre></td></tr></table></figure><p>实例演示</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">    YAPerson *person = [[YAPerson alloc] init];</span><br><span class="line">    Class cls = [person <span class="keyword">class</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取实例变量</span></span><br><span class="line">    Ivar ivar_num = class_getInstanceVariable(cls, <span class="string">"num"</span>);</span><br><span class="line">    </span><br><span class="line">    Ivar ivar_name = class_getInstanceVariable(cls, <span class="string">"name"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取类变量</span></span><br><span class="line">    <span class="comment">//Ivar class_getClassVariable(Class cls, const char *name)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Ivar变量的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar_name);</span><br><span class="line">    printf(<span class="string">"%s\n"</span>,name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Ivar变量的偏移量</span></span><br><span class="line">    ptrdiff_t p = ivar_getOffset(ivar_num);</span><br><span class="line">    printf(<span class="string">"%td"</span>,p); <span class="comment">// 打印16</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Ivar变量的编码</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = ivar_getTypeEncoding(ivar_name);</span><br><span class="line">    printf(<span class="string">"%s\n"</span>,typeEncoding); <span class="comment">// 打印 @"NSString"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置成员变量的值</span></span><br><span class="line">    object_setIvarWithStrongDefault(person, ivar_name, <span class="string">@"haha"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person-&gt;name);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置成员变量对应的值</span></span><br><span class="line">    object_setIvar(person, ivar_name, <span class="string">@"hahaaaaaa"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person-&gt;name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Ivar对应的成员变量对象</span></span><br><span class="line">    <span class="keyword">id</span> object = object_getIvar(person, ivar_name);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,object);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态添加成员变量</span></span><br><span class="line">    <span class="comment">// 必须在 objc_allocateClassPair 之后 和 在objc_registerClassPair之前调用</span></span><br><span class="line">    <span class="comment">// 不能给一个已经存在的类添加成员变量</span></span><br><span class="line">    Class peopleClass = objc_allocateClassPair(cls, <span class="string">"YAPeople"</span>, <span class="number">0</span>);</span><br><span class="line">    class_addIvar(peopleClass, <span class="string">"_gayFriend"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">    class_addIvar(peopleClass, <span class="string">"_girlFriend"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">    class_addIvar(peopleClass, <span class="string">"_company"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">    objc_registerClassPair(peopleClass);</span><br><span class="line">    <span class="comment">// 打印成员变量列表</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="keyword">self</span> ya_getIvarList:peopleClass]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IvarLayout相关</span></span><br><span class="line">    <span class="comment">// ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t *ivarLayoutArray= class_getIvarLayout(cls);</span><br><span class="line">    <span class="keyword">const</span> uint8_t *weakIvarLayoutArray = class_getWeakIvarLayout(cls);</span><br><span class="line">    <span class="keyword">if</span> (ivarLayoutArray) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        uint8_t value_s = ivarLayoutArray[i];</span><br><span class="line">        <span class="keyword">while</span> (value_s != <span class="number">0x0</span>) &#123;</span><br><span class="line">            printf(<span class="string">"\\x%02x\n"</span>, value_s);</span><br><span class="line">            value_s = ivarLayoutArray[++i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//void class_setIvarLayout(Class cls, const uint8_t *layout)</span></span><br><span class="line">    <span class="comment">//void class_setWeakIvarLayout(Class cls, const uint8_t *layout)</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据class获取成员变量列表</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param class 类</span></span><br><span class="line"><span class="comment"> @return 成员变量字典(名称:类型)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)ya_getIvarList:(Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取成员变量列表</span></span><br><span class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">class</span>, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储成员变量</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取成员变量类型与成员变量名称</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 成员变量类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *c_ivarType = ivar_getTypeEncoding(ivarList[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 成员变量名称</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *c_ivarName = ivar_getName(ivarList[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用字典存储,格式为 成员变量名称:对应的成员变量类型</span></span><br><span class="line">        <span class="built_in">NSString</span> *ivarName = [<span class="built_in">NSString</span> stringWithUTF8String:c_ivarName];</span><br><span class="line">        dict[ivarName] = [<span class="built_in">NSString</span> stringWithUTF8String:c_ivarType];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要手动free</span></span><br><span class="line">    free(ivarList);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:dict];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>值得一提的是方法编码和类型编码:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ID       <span class="meta-string">'@'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CLASS    <span class="meta-string">'#'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_SEL      <span class="meta-string">':'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CHR      <span class="meta-string">'c'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UCHR     <span class="meta-string">'C'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_SHT      <span class="meta-string">'s'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_USHT     <span class="meta-string">'S'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_INT      <span class="meta-string">'i'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UINT     <span class="meta-string">'I'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_LNG      <span class="meta-string">'l'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ULNG     <span class="meta-string">'L'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_LNG_LNG  <span class="meta-string">'q'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ULNG_LNG <span class="meta-string">'Q'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_FLT      <span class="meta-string">'f'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_DBL      <span class="meta-string">'d'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_BFLD     <span class="meta-string">'b'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_BOOL     <span class="meta-string">'B'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_VOID     <span class="meta-string">'v'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UNDEF    <span class="meta-string">'?'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_PTR      <span class="meta-string">'^'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CHARPTR  <span class="meta-string">'*'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ATOM     <span class="meta-string">'%'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ARY_B    <span class="meta-string">'['</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ARY_E    <span class="meta-string">']'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UNION_B  <span class="meta-string">'('</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UNION_E  <span class="meta-string">')'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_STRUCT_B <span class="meta-string">'&#123;'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_STRUCT_E <span class="meta-string">'&#125;'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_VECTOR   <span class="meta-string">'!'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CONST    <span class="meta-string">'r'</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Code</th><th>Meaning</th></tr></thead><tbody><tr><td>r</td><td>const</td></tr><tr><td>n</td><td>in</td></tr><tr><td>N</td><td>inout</td></tr><tr><td>o</td><td>out</td></tr><tr><td>O</td><td>bycopy</td></tr><tr><td>R</td><td>byref</td></tr><tr><td>V</td><td>oneway</td></tr></tbody></table><p>以上信息在具体应用时,可以自定义一个枚举获取.</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct objc_method <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    // 方法的名称</span></span><br><span class="line"><span class="comment">    SEL method_name;                                          </span></span><br><span class="line"><span class="comment">    // 方法的参数类型</span></span><br><span class="line"><span class="comment">    char *method_types;                                       </span></span><br><span class="line"><span class="comment">    // 方法的实现(函数指针)</span></span><br><span class="line"><span class="comment">    IMP method_imp;                                           </span></span><br><span class="line"><span class="comment">&#125;</span>                                                            </span><br><span class="line"></span><br><span class="line">根据方法名称获取<span class="function"><span class="keyword">Method</span></span></span><br><span class="line"><span class="function"><span class="title">Method</span> <span class="title">class_getInstanceMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span></span></span><br><span class="line"><span class="function"><span class="title">Method</span> <span class="title">class_getClassMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取<span class="title">Method</span>的方法名称</span></span><br><span class="line"><span class="function"><span class="title">SEL</span> <span class="title">method_getName</span><span class="params">(<span class="keyword">Method</span> m)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取<span class="title">Method</span>的方法实现</span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">method_getImplementation</span><span class="params">(<span class="keyword">Method</span> m)</span> </span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">class_getMethodImplementation</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取<span class="title">Method</span>的返回值类型<span class="params">(需手动释放)</span></span></span><br><span class="line"><span class="function"><span class="title">char</span> *<span class="title">method_copyReturnType</span><span class="params">(<span class="keyword">Method</span> m)</span></span></span><br><span class="line"><span class="function">//<span class="title">void</span> <span class="title">method_getReturnType</span><span class="params">(<span class="keyword">Method</span> m, char *dst, size_t dst_len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取指定<span class="title">Method</span>的类型</span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">char</span> *<span class="title">method_getTypeEncoding</span><span class="params">(<span class="keyword">Method</span> m)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取<span class="title">Method</span>的参数数量</span></span><br><span class="line"><span class="function"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">method_getNumberOfArguments</span><span class="params">(<span class="keyword">Method</span> m)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取<span class="title">Method</span>中第<span class="title">i</span>个参数的类型<span class="params">(Char *类型)</span><span class="params">(需手动释放)</span></span></span><br><span class="line"><span class="function"><span class="title">char</span> *<span class="title">method_copyArgumentType</span><span class="params">(<span class="keyword">Method</span> m, unsigned int <span class="keyword">index</span>)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取方法列表</span></span><br><span class="line"><span class="function"><span class="title">Method</span> *<span class="title">class_copyMethodList</span><span class="params">(<span class="keyword">Class</span> cls, unsigned int *outCount)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">设置<span class="title">IMP</span></span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">method_setImplementation</span><span class="params">(<span class="keyword">Method</span> m, IMP imp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">交换方法实现</span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(<span class="keyword">Method</span> m1, <span class="keyword">Method</span> m2)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">添加方法</span></span><br><span class="line"><span class="function"><span class="title">BOOL</span> <span class="title">class_addMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name, IMP imp, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> char *types)</span> </span></span><br><span class="line"><span class="function">替换方法                                 </span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">class_replaceMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name, IMP imp, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> char *types)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">标明需要手动释放的动态内存<span class="params">(如返回值类型/参数类型)</span></span></span><br><span class="line"><span class="function">// 及时释放</span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(argumentType)</span> <span class="title">free</span><span class="params">(argumentType)</span>;</span></span><br></pre></td></tr></table></figure><p>实例演示</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    YAPerson *person = [[YAPerson alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Method</span></span><br><span class="line">    Method method = class_getInstanceMethod([person <span class="keyword">class</span>] , <span class="built_in">NSSelectorFromString</span>(<span class="string">@"nameWithArg:arg:arg:arg:arg:"</span>));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Method的方法名称</span></span><br><span class="line">    SEL sel = method_getName(method);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Method的方法实现</span></span><br><span class="line">    IMP imp1 = method_getImplementation(method);</span><br><span class="line">    IMP imp2 = class_getMethodImplementation([person <span class="keyword">class</span>],sel);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Method的返回值类型(需手动释放)</span></span><br><span class="line">    <span class="keyword">char</span> *returnType = method_copyReturnType(method);</span><br><span class="line">    <span class="keyword">if</span> (returnType) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSString</span> stringWithUTF8String:returnType]);</span><br><span class="line">        free(returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指定Method的类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(method);</span><br><span class="line">    <span class="keyword">if</span> (typeEncoding) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSString</span> stringWithUTF8String:typeEncoding]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Method的参数数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> arguementCount = method_getNumberOfArguments(method);</span><br><span class="line">    <span class="keyword">if</span> (arguementCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguementCount; i++) &#123;</span><br><span class="line">            <span class="comment">//获取Method中第i个参数的类型(Char *类型)(需手动释放)</span></span><br><span class="line">            <span class="keyword">char</span> *arguementType = method_copyArgumentType(method, i);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSString</span> stringWithUTF8String:arguementType]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 手动释放</span></span><br><span class="line">            <span class="keyword">if</span> (arguementType) &#123;</span><br><span class="line">                free(arguementType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的方法实现IMP,并返回原先的IMP</span></span><br><span class="line">    IMP imp3 = method_setImplementation(method, imp2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Method Swizzling</span></span><br><span class="line"><span class="comment"> 一般放在load方法中,并且使用dispatch_once,需要调用 class_addMethod 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class cls = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        SEL oldSelector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"XXXX"</span>);</span><br><span class="line">        SEL newSelector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"XXXXXXXX"</span>);</span><br><span class="line">        </span><br><span class="line">        Method oldMethod = class_getInstanceMethod(cls, oldSelector);</span><br><span class="line">        Method newMethod = class_getInstanceMethod(cls, newSelector);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试给旧的方法oldSelector添加新的方法newSelectot的实现,如果已经存在方法实现,则添加失败</span></span><br><span class="line">        <span class="built_in">BOOL</span> isSuccess = class_addMethod(cls, oldSelector, method_getImplementation(newMethod), method_getTypeEncoding(newMethod));</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123; <span class="comment">// 添加成功,那么用旧的方法实现替换新的方法实现</span></span><br><span class="line">            class_replaceMethod(cls, newSelector, method_getImplementation(oldMethod), method_getTypeEncoding(oldMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 旧的方法已经有了实现,直接交换即可</span></span><br><span class="line">            method_exchangeImplementations(newMethod, oldMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全地替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Swizzling应该总是在+load中执行</span></span><br><span class="line"><span class="comment">在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证–事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Swizzling应该总是在dispatch_once中执行</span></span><br><span class="line"><span class="comment">与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据class获取方法列表</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param class 类</span></span><br><span class="line"><span class="comment"> @return 方法名称数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)ya_getMethodList:(Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">// 方法列表数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取方法列表</span></span><br><span class="line">    Method *methodList = class_copyMethodList(<span class="keyword">class</span>, &amp;methodCount);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储方法名称</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">if</span> (methodList) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i ++) &#123;</span><br><span class="line">            <span class="comment">// 获取方法</span></span><br><span class="line">            Method method = methodList[i];</span><br><span class="line">            <span class="comment">// 获取方法名称</span></span><br><span class="line">            SEL sel = method_getName(method);</span><br><span class="line">            </span><br><span class="line">            [array addObject:<span class="built_in">NSStringFromSelector</span>(sel)];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手动释放</span></span><br><span class="line">        free(methodList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:array];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 交换实例方法实现</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param class 类</span></span><br><span class="line"><span class="comment"> @param aSEL 方法一的名称</span></span><br><span class="line"><span class="comment"> @param bSEL 方法二的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)ya_exchangeInstanceMethod:(Class)<span class="keyword">class</span> firstMethod:(SEL)aSEL secondMethod:(SEL)bSEL &#123;</span><br><span class="line">    Method aMethad = class_getInstanceMethod(<span class="keyword">class</span>, aSEL);</span><br><span class="line">    Method bMethod = class_getInstanceMethod(<span class="keyword">class</span>, bSEL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换方法实现</span></span><br><span class="line">    method_exchangeImplementations(aMethad, bMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 交换类方法实现</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param class 类</span></span><br><span class="line"><span class="comment"> @param aSEL 方法一的名称</span></span><br><span class="line"><span class="comment"> @param bSEL 方法二的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)ya_exchangeClassMethod:(Class)<span class="keyword">class</span> firstMethod:(SEL)aSEL secondMethod:(SEL)bSEL &#123;</span><br><span class="line">    Method aMethad = class_getClassMethod(<span class="keyword">class</span>, aSEL);</span><br><span class="line">    Method bMethod = class_getClassMethod(<span class="keyword">class</span>, bSEL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换方法实现</span></span><br><span class="line">    method_exchangeImplementations(aMethad, bMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 为类添加名为newSEL的(实例)方法</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param class 类</span></span><br><span class="line"><span class="comment"> @param aSEL 新的方法名称</span></span><br><span class="line"><span class="comment"> @param bSEL 已经存在的方法名称</span></span><br><span class="line"><span class="comment"> @return 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)ya_addMethod:(Class)<span class="keyword">class</span> newSEL:(SEL)aSEL existSEL:(SEL)bSEL &#123;</span><br><span class="line">    <span class="comment">// 获取已经存在的方法</span></span><br><span class="line">    Method method = class_getInstanceMethod(<span class="keyword">class</span>, bSEL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取已经存在的方法的实现</span></span><br><span class="line">    IMP imp = class_getMethodImplementation(<span class="keyword">class</span>, bSEL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取type</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type = method_getTypeEncoding(method);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给class添加名称为aSEL的方法实现</span></span><br><span class="line">    <span class="keyword">return</span> class_addMethod(<span class="keyword">class</span>, aSEL, imp, type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果父类中已经有该名称的方法,那么调用后将重写该方法</span></span><br><span class="line"><span class="comment">    如果本类中已经有了该名称的方法实现,那么将添加失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line">属性相关信息</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;         </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          </span><br><span class="line">&#125; objc_property_attribute_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">获取属性</span><br><span class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"></span><br><span class="line">获取属性列表</span><br><span class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line">获取属性信息列表</span><br><span class="line">objc_property_attribute_t *property_copyAttributeList(objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line">获取属性信息中某个Value</span><br><span class="line"><span class="keyword">char</span> *property_copyAttributeValue(objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName)</span><br><span class="line"></span><br><span class="line">添加属性</span><br><span class="line"><span class="built_in">BOOL</span> class_addProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span><br><span class="line"></span><br><span class="line">替换属性</span><br><span class="line"><span class="keyword">void</span> class_replaceProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span><br><span class="line"></span><br><span class="line">获取属性名称</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property) </span><br><span class="line"></span><br><span class="line">获取属性相关信息</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getAttributes(objc_property_t property)</span><br></pre></td></tr></table></figure><p>实例演示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">YAPerson *person = [[YAPerson alloc] init];</span><br><span class="line">    Class cls = [person class];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性</span></span><br><span class="line">    <span class="keyword">objc_property_t</span> property = class_getProperty(cls, <span class="string">"school"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,propertyName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性信息列表</span></span><br><span class="line">    <span class="comment">// objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性相关信息</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *propertyAttributes = property_getAttributes(property);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,propertyAttributes); <span class="comment">// 打印 T@"NSObject",W,N,V_school</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据获取属性信息中的name获取对应的Value</span></span><br><span class="line">    <span class="keyword">char</span> *propertyValue = property_copyAttributeValue(property, <span class="string">"T"</span>); <span class="comment">// 类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,propertyValue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     T 类型 例如:NSObject</span></span><br><span class="line"><span class="comment">     V 值(成员变量) 例如 _school</span></span><br><span class="line"><span class="comment">     C copy</span></span><br><span class="line"><span class="comment">     N nonatommic</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加属性</span></span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> type = &#123; <span class="string">"T"</span>, [[NSString stringWithFormat:@<span class="string">"@\"%@\""</span>,NSStringFromClass([NSString class])] UTF8String] &#125;; <span class="comment">//type</span></span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> ownership0 = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;; <span class="comment">// C = copy</span></span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> ownership = &#123; <span class="string">"N"</span>, <span class="string">""</span> &#125;; <span class="comment">//N = nonatomic</span></span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> backingivar  = &#123; <span class="string">"V"</span>, [[NSString stringWithFormat:@<span class="string">"_%s"</span>, <span class="string">"propertyName"</span>] UTF8String] &#125;;  <span class="comment">//variable name</span></span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> attrs[] = &#123; type, ownership0, ownership, backingivar &#125;;</span><br><span class="line">    <span class="keyword">if</span> (class_addProperty(cls, <span class="string">"propertyName"</span>, attrs, <span class="number">4</span>)) &#123;</span><br><span class="line">        NSLog(@<span class="string">"添加成功"</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 替换属性</span></span><br><span class="line">    <span class="comment">//void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据class获取类的属性列表</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param class 类</span></span><br><span class="line"><span class="comment"> @return 属性列表数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (NSArray *)ya_getPropertyList:(Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="comment">// 私有/公有/类扩展中的所有属性数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性列表</span></span><br><span class="line">    <span class="keyword">objc_property_t</span> *propertyList = class_copyPropertyList(class, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储属性名称</span></span><br><span class="line">    NSMutableArray *<span class="built_in">array</span> = [NSMutableArray <span class="built_in">array</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* c_propertyName = property_getName(propertyList[i]);</span><br><span class="line">        [<span class="built_in">array</span> addObject:[NSString stringWithUTF8String:c_propertyName]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手动释放</span></span><br><span class="line">    <span class="built_in">free</span>(propertyList);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [NSArray arrayWithArray:<span class="built_in">array</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p>本部分应用较少,未做详细实践.</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_protocol_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *next;</span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Protocol *list[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">是否遵循协议</span><br><span class="line"><span class="built_in">BOOL</span> class_conformsToProtocol(Class cls, Protocol *protocol)</span><br><span class="line"></span><br><span class="line">协议列表</span><br><span class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *class_copyProtocolList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *objc_copyProtocolList(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *protocol_copyProtocolList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line">动态添加协议</span><br><span class="line"><span class="built_in">BOOL</span> class_addProtocol(Class cls, Protocol *protocol) </span><br><span class="line"></span><br><span class="line">获取指定名称的协议</span><br><span class="line">Protocol *objc_getProtocol(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"></span><br><span class="line">协议A是否遵循协议B</span><br><span class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol(Protocol *proto, Protocol *other)</span><br><span class="line"></span><br><span class="line">两个协议是否相等</span><br><span class="line"><span class="built_in">BOOL</span> protocol_isEqual(Protocol *proto, Protocol *other)</span><br><span class="line"></span><br><span class="line">获取某个协议的名称</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *protocol_getName(Protocol *p)</span><br><span class="line"></span><br><span class="line">动态生成协议</span><br><span class="line">Protocol *objc_allocateProtocol(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="keyword">void</span> objc_registerProtocol(Protocol *proto) </span><br><span class="line"></span><br><span class="line">给协议添加方法</span><br><span class="line"><span class="keyword">void</span> protocol_addMethodDescription(Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod) </span><br><span class="line"></span><br><span class="line">给协议添加协议</span><br><span class="line"><span class="keyword">void</span> protocol_addProtocol(Protocol *proto, Protocol *addition) </span><br><span class="line"></span><br><span class="line">给协议添加属性</span><br><span class="line"><span class="keyword">void</span> protocol_addProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据class获取遵循的协议列表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param class 类</span></span><br><span class="line"><span class="comment"> @return 协议名称列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)ya_getProtocolList:(Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">// 协议列表数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取协议列表</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Protocol **protocolList = class_copyProtocolList(<span class="keyword">class</span>, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储协议</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">        <span class="comment">// 获取协议</span></span><br><span class="line">        Protocol *protocol = protocolList[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取协议名称</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *c_protocolName = protocol_getName(protocol);</span><br><span class="line">        </span><br><span class="line">        [array addObject:[<span class="built_in">NSString</span> stringWithUTF8String:c_protocolName]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手动释放</span></span><br><span class="line">    free(protocolList);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、技能"><a href="#二、技能" class="headerlink" title="二、技能"></a>二、技能</h2><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sel_isEqual(sel, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"ss"</span>))) &#123;</span><br><span class="line">        <span class="comment">// 要求参数要匹配</span></span><br><span class="line">        [YARuntime ya_addMethod:[<span class="keyword">self</span> <span class="keyword">class</span>] newSEL:sel existSEL:<span class="keyword">@selector</span>(printPersonalInfo)];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (id)<span class="string">forwardingTargetForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel_isEqual(aSelector, NSSelectorFromString(@<span class="string">"ss"</span>))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转发给已经存在的对象</span></span><br><span class="line">        <span class="keyword">return</span> [[YAPerson alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">forwardingTargetForSelector:</span>aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>aSelector];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有找到signature(方法签名),只能手动提供</span></span><br><span class="line">    <span class="keyword">if</span> (signature == nil) &#123;</span><br><span class="line">        signature = [NSMethodSignature <span class="string">signatureWithObjCTypes:</span><span class="string">"@@:"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation &#123;</span><br><span class="line">    YAPerson *personClass = [[YAPerson alloc] init];</span><br><span class="line">    SEL sel = anInvocation.selector;</span><br><span class="line">    <span class="keyword">if</span> ([personClass <span class="string">respondsToSelector:</span>sel]) &#123;</span><br><span class="line">        <span class="comment">// 最后一次机会</span></span><br><span class="line">        [anInvocation <span class="string">invokeWithTarget:</span>personClass];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 回天乏力</span></span><br><span class="line">        [self <span class="string">doesNotRecognizeSelector:</span>sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><blockquote><p>不会做菜的程序员不是好男人。</p></blockquote><p>YADeveloper 继承自 YAMan,想让YADeveloper实例对象同时具备响应 YAMan方法和 YACook方法的能力。</p><p>YAMan:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YAMan </span>: NSObject</span><br><span class="line">- (void)printMan;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> YAMan</span><br><span class="line">- (void)printMan &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"我是一个男人"</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>YACook:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YACook </span>: NSObject </span><br><span class="line">- (void)printCook;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> YACook</span><br><span class="line">- (void)printCook &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"我是个会做菜的人"</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>YADeveloper:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@class</span> YACook;</span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">YADeveloper </span>: YAMan</span><br><span class="line"><span class="variable">@property</span> (nonatomic,strong) YACook *cook;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">printDev</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明YACook的方法,使编译通过</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">printCook</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">implementation</span> <span class="selector-tag">YADeveloper</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">printDev</span> &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"我是个会写程序的人"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">forwardingTargetForSelector</span><span class="selector-pseudo">:(SEL)aSelector</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (sel_isEqual(aSelector, NSSelectorFromString(@<span class="string">"printCook"</span>))) &#123;</span><br><span class="line">        <span class="comment">// 需要预先对self.cook初始化</span></span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">self</span><span class="selector-class">.cook</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 或者直接创建</span></span><br><span class="line">        <span class="comment">// return [[YACook alloc] init];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[super forwardingTargetForSelector:aSelector]</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><h3 id="关联引用"><a href="#关联引用" class="headerlink" title="关联引用"></a>关联引用</h3><p>注意点:</p><ol><li>objc_removeAssociatedObjects 函数一般不可手动调用，因为这个函数会移除一个对象的所有关联对象，将该对象恢复成“原始”状态。这样做就很有可能把别人添加的关联对象也一并移除，这并不是我们所希望的。所以一般的做法是通过给 objc_setAssociatedObject 函数传入 nil 来移除某个已有的关联对象。</li><li>关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的。<h4 id="给分类添加weak属性"><a href="#给分类添加weak属性" class="headerlink" title="给分类添加weak属性"></a>给分类添加weak属性</h4><blockquote><p>给任意对象A 添加 weak属性 B</p></blockquote></li></ol><p>问题关键点:在属性销毁的时候，将其置为空(或者说在关联对象销毁的时候，使objc_getAssociatedObject得到的是nil)。</p><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>通过继承关联对象B ，重写其dealloc方法即可适时把A中的关联对象返回值设置为nil，达到自动置空的目的，这也是最本能的方法。</p><p>给NSObject添加分类，也即任何继承自NSObject的对象都可以有weak属性。</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> NSObject (YAWeakProperty)</span><br><span class="line"><span class="variable">@property</span> (nonatomic, weak) YAProperty *property;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> NSObject (YAWeakProperty)</span><br><span class="line"></span><br><span class="line"><span class="comment">// const static char *key = "key";</span></span><br><span class="line"></span><br><span class="line">- (id)property &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">objc_getAssociatedObject</span>(self, <span class="variable">@selector</span>(property));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setProperty</span><span class="selector-pseudo">:(YAProperty</span> *)<span class="selector-tag">property</span> &#123;</span><br><span class="line">    <span class="selector-tag">objc_setAssociatedObject</span>(self, <span class="variable">@selector</span>(property), property, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    <span class="selector-attr">[property setAssociate:self selector:@selector(setProperty:)]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>关联引用的key一般使用getter方法的selector，此时get方法中的key也可使用_cmd，二者等效。</p><p>属性的实现:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAProperty</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setAssociate:(<span class="built_in">NSObject</span> *)associatedObject selector:(SEL)sel;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类扩展</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAProperty</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">   __<span class="keyword">weak</span> <span class="keyword">id</span> _associatedObject;</span><br><span class="line">   SEL _sel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAProperty</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAssociate:(<span class="built_in">NSObject</span> *)associatedObject selector:(SEL)sel &#123;</span><br><span class="line">    _associatedObject = associatedObject;</span><br><span class="line">    _sel = sel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL,<span class="keyword">id</span>)) objc_msgSend)(_associatedObject, _sel, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然而有个问题:添加的属性继承自NSObject时非常完美，但是实际项目中不可能给任意对象添加的属性都是NSObject，有可能是NSString/NSArray/NSDictionary/NSSet等等。那么就只能继承自NSString/NSArray/NSDictionary/NSSet等系统类，这样会出现一系列一系列一系列问题，苹果并不建议我们使用NSString/NSArray/NSDictionary/NSSet等的派生类(这些类已经足够好了，不需要画蛇添足)。</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><blockquote><p>用一个NSPointerArray（弱引用类型的数组）包一层就可以了。虽然关联属性的policy不支持weak，但是你可以把要关联的对象放入一个弱引用数组里面，然后把这个弱引用数组设置为关联对象，每次取值的时候，只需要从这个弱引用数组里面取就可以了。一样可以达到关联弱引用对象的效果。</p></blockquote><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><p>A 关联 C<br>B 关联 C<br>C 销毁 通知B<br>B 再告诉 A</p><h2 id="三、要点"><a href="#三、要点" class="headerlink" title="三、要点"></a>三、要点</h2><h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>() 函数用来释放动态分配的内存空间，其原型为：</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span> <span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>() 可以释放由 <span class="built_in">malloc</span>()、<span class="built_in">calloc</span>()、<span class="built_in">realloc</span>() 分配的内存空间，以便其他程序再次使用。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 及时释放字符串常量</span></span><br><span class="line"><span class="keyword">if</span> (argumentType) <span class="built_in">free</span>(argumentType);</span><br></pre></td></tr></table></figure><h3 id="NONNULL"><a href="#NONNULL" class="headerlink" title="NONNULL"></a>NONNULL</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span>和<span class="built_in">NS_ASSUME_NONNULL_END</span>。</span><br><span class="line">在这两个宏之间的代码，所有简单指针对象都被假定为 <span class="keyword">nonnull</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define NS_ASSUME_NONNULL_BEGIN _Pragma(<span class="meta-string">"clang assume_nonnull begin"</span>)</span></span><br><span class="line"><span class="meta">#define NS_ASSUME_NONNULL_END   _Pragma(<span class="meta-string">"clang assume_nonnull end"</span>)</span></span><br></pre></td></tr></table></figure><h3 id="covariant"><a href="#covariant" class="headerlink" title="__covariant"></a>__covariant</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">__covariant</span> - 协变性，子类型可以强转到父类型（里氏替换原则）</span><br><span class="line"><span class="variable">__contravariant</span> - 逆变性，父类型可以强转到子类型（WTF）</span><br></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">__kindof</span></span><br></pre></td></tr></table></figure><h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">__attribute__</span>((always_inline)) 的意思是强制内联</span><br></pre></td></tr></table></figure><blockquote><p>参考并感谢<br><a href="http://www.cnblogs.com/ludashi/p/6294112.html" target="_blank" rel="noopener">青玉伏案</a><br><a href="http://southpeak.github.io/2014/11/06/objective-c-runtime-4/" target="_blank" rel="noopener">南峰子</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2018.8.26 更新Class定义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 关于Runtime的简单总结。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>查找算法总结</title>
    <link href="http://blog.chenyalun.com/2017/04/21/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.chenyalun.com/2017/04/21/查找算法总结/</id>
    <published>2017-04-21T11:10:17.000Z</published>
    <updated>2017-04-30T09:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 关于查找算法。 </p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文”完全二叉树”的定义采用国内定义<br>B-树 即 B树,两者是相同概念,而非指二叉搜索树(百度百科)</p></blockquote><h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>1.国内早期教材中，满二叉树一般指 perfect binary tree，所以会有满二叉树是完全二叉树的一个特例的说法.</p><p>2.树的深度的定义，有的根结点从0开始计数，有的从1开始计数.</p><p>3.结点 与 节点 是对Node的翻译,可以看做等同.</p><h2 id="维基百科定义"><a href="#维基百科定义" class="headerlink" title="维基百科定义"></a>维基百科定义</h2><p>1.根二叉树(Rooted Binary Tree)：<br>有一个根结点，每个结点至多有两个孩子。</p><p>2.满二叉树(Full Binary Tree)：<br>要么是叶子结点(结点的度为0)，要么结点同时具有左右子树(结点的度为2)。</p><p>3.完全二叉树(Complete Binary Tree)：<br>每层结点都完全填满，在最后一层上如果不是满的，则只缺少右边的若干结点。</p><p>4.完美二叉树(Perfect Binary Tree)<br>所有的非叶子结点都有两个孩子，所有的叶子结点都在同一层。即每层结点都完全填满。</p><p>5.无限完全二叉树(Infinite Complete Binary Tree)：    每个结点都有两个孩子，结点的层数是无限的。</p><p>6.平衡二叉树(Balanced Binary Tree)：<br>也称为AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><strong>满二叉树(Full Binary Tree)</strong><br>如果一棵二叉树的结点要么是叶子要么有两个孩子结点,则为满二叉树</p><p>性质:<br>1.总结点个数呈现个数为:0 1 3 7 15…满足2^(n) -1,其中n为树的深度(最大层)</p><p>2.第k层(k不为0)结点个数:1 2 4 8…满足2^(k - 1)</p><p>3.满二叉树是完全二叉树</p><p><strong>完全二叉树(Complete Binary Tree)</strong><br>若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><p>性质:完全二叉树中度为1的结点数只有两种可能0或1,那么:<br>总结点数为n,有  <strong>n0=n/2</strong> 或 <strong>n0=(n+1)/2</strong></p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>顺序存储的排序数组<br><img src="http://static.chenyalun.com/2017/04/21/170421004.jpg" alt=""><br>插入和删除的时候时间复杂度达到O(n),顺序存储结构不适于动态的情况</p><p>链式存储<br><img src="http://static.chenyalun.com/2017/04/21/170421005.jpg" alt=""><br>链表的查找需要O(n)</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找表:由同一类型的数据元素构成的集合.<br>关键字:数据元素中某个数据项的值.<br>主关键字:可以唯一地标识一个记录.<br>次关键字:可以识别多个数据元素.<br>查找:根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素(或记录).<br>静态查找表:只作查找操作的查找表.<br>动态查找表:在查找过程中同时插入查找表中不存在的数据元素,或者从查找表中删除已经存在的某个数据元素.</p><h2 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h2><p>顺序查找(线性查找):从表中第一个记录开始,逐个进行记录的关键字和给定值的比较.</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 顺序查找的实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequentialSearch</span><span class="params">(key, numbers)</span></span><span class="symbol">:</span></span><br><span class="line">    length = len(numbers)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(length)<span class="symbol">:</span></span><br><span class="line">        <span class="comment"># 查找成功返回索引</span></span><br><span class="line">        <span class="keyword">if</span> key == numbers[i]<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="comment"># 查找失败返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>最好情况:在第一个位置找到,时间复杂度为O(1)<br>最坏情况:在最后一个位置找到,时间复杂度O(n)<br>查找不成功:时间复杂度O(n)<br>平均查找次数:(n+1)/2<br>平均时间复杂度:O(n)</p><h2 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h2><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><p> 折半查找(二分查找):在线性表中的记录有序的前提下进行查找.取中间元素作为比较对象,若给定值与中间元素相等,则查找成功,若给定值小于中间元素,则在中间元素的左半区继续查找,若给定值大于中间元素,则在中间元素的右半区继续查找,不断重复查找过程,直到查找成功,或查找失败.</p><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 二分查找的实现</span></span><br><span class="line">def binarySearch(<span class="keyword">key</span>, numbers):</span><br><span class="line">    <span class="meta"># 左边界</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    <span class="meta"># 右边界</span></span><br><span class="line">    high = len(numbers) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        <span class="meta"># 中间元素索引</span></span><br><span class="line">        <span class="keyword">mid</span> = (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="meta"># 查找成功</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] == <span class="keyword">key</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">mid</span></span><br><span class="line">        <span class="meta"># 在左区间</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] &gt; <span class="keyword">key</span>:</span><br><span class="line">            high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">        <span class="meta"># 在右区间</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] &lt; <span class="keyword">key</span>:</span><br><span class="line">            low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="meta"># 查找失败返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>最好情况:是中间元素,一次即可找到,时间复杂度O(1)<br>最坏情况:完全二叉树的深度加1,即floor(logn) + 1次,时间复杂度O(logn).(注意:logn这里指以2为底,floor表示向下取整)</p><h3 id="2-插值查找"><a href="#2-插值查找" class="headerlink" title="2.插值查找"></a>2.插值查找</h3><p>二分查找的优化版,核心是插值公式:<br>(key - numbers[low]) / (numbers[high] - numbers[low])</p><p>核心代码:</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插值</span></span><br><span class="line">mid = low + <span class="comment">(high - low)</span> * <span class="comment">(key - numbers[low])</span> / <span class="comment">(numbers[high] - numbers[low])</span></span><br></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 插值查找的实现</span></span><br><span class="line">def interpolationSearch(<span class="keyword">key</span>, numbers):</span><br><span class="line">    <span class="meta"># 左边界</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    <span class="meta"># 右边界</span></span><br><span class="line">    high = len(numbers) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        <span class="meta"># 核心代码</span></span><br><span class="line">        <span class="keyword">mid</span> = low + (high - low) * (<span class="keyword">key</span> - numbers[low]) / (numbers[high] - numbers[low])</span><br><span class="line">        <span class="meta"># 查找成功</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] == <span class="keyword">key</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">mid</span></span><br><span class="line">        <span class="meta"># 在左区间</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] &gt; <span class="keyword">key</span>:</span><br><span class="line">            high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">        <span class="meta"># 在右区间</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] &lt; <span class="keyword">key</span>:</span><br><span class="line">            low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="meta"># 查找失败返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>从时间复杂度上,依然是O(logn),但是对于表长较大,关键字分布比较均匀的查找表,性能相对二分查找更好.<br>但是,分布极不均匀的数据,不是很合适,比如[1,2,4,3000,3003…9988899,8988998]</p><p>插值查找在实际使用时，一般要满足两个假设条件：</p><p>(1)每一次对数据的访问与通常的指令相比，费用都是相当昂贵的。例如，待查找的表一定是在磁盘而非内存中，因而每一次比较都要进行磁盘访问。</p><p>(2)数据不仅是已被排好序的，而且呈现均匀分布特征。</p><h3 id="3-斐波那契查找"><a href="#3-斐波那契查找" class="headerlink" title="3.斐波那契查找"></a>3.斐波那契查找</h3><p>利用黄金分割原理实现,折半查找算法来进行修改和改进.<br>对于斐波那契数列,前后两个数字的比值随着数列的增加,越来越接近黄金比值:0.618</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">0<span class="selector-class">.0</span></span><br><span class="line">1<span class="selector-class">.0</span></span><br><span class="line">0<span class="selector-class">.5</span></span><br><span class="line">0<span class="selector-class">.666666666667</span></span><br><span class="line">0<span class="selector-class">.6</span></span><br><span class="line">0<span class="selector-class">.625</span></span><br><span class="line">0<span class="selector-class">.615384615385</span></span><br><span class="line">0<span class="selector-class">.619047619048</span></span><br><span class="line">0<span class="selector-class">.617647058824</span></span><br><span class="line">0<span class="selector-class">.618181818182</span></span><br><span class="line">0<span class="selector-class">.61797752809</span></span><br><span class="line">0<span class="selector-class">.618055555556</span></span><br><span class="line">0<span class="selector-class">.618025751073</span></span><br><span class="line">0<span class="selector-class">.618037135279</span></span><br><span class="line">0<span class="selector-class">.618032786885</span></span><br><span class="line">0<span class="selector-class">.618034447822</span></span><br><span class="line">0<span class="selector-class">.6180338134</span></span><br><span class="line">0<span class="selector-class">.618034055728</span></span><br><span class="line">0<span class="selector-class">.618033963167</span></span><br><span class="line">0<span class="selector-class">.618033998522</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>对于斐波那契数列:<br>0 1 1 2 3 5 8 13 21 34 55 89 …</p><p><strong>原理:</strong><br>比如这里的89，假定它是整个有序表的元素个数，而89是由前面的两个数34和55相加之后的和，也即把元素个数为89的有序表分成由前55个数据元素组成的前半段和由后34个数据元素组成的后半段，那么前半段元素个数和整个有序表长度的比值就接近黄金比值0.618，假如要查找的元素在前半段，那么继续按照斐波那契数列来看，55 = 34 + 21，所以继续把前半段分成前34个数据元素的前半段和后21个元素的后半段，继续查找，如此反复，直到查找成功或失败.</p><p>当有序表的元素个数不是斐波那契数列中的某个数字时，需要把有序表的元素个数长度补齐，让它成为斐波那契数列中的一个数值,也即<strong>把需要补齐的的元素都赋值为有序表的最大值</strong>。</p><p><strong>核心:</strong><br>(1)当key == numbers[mid],查找成功<br>(2)当key &lt; numbers[mid],新范围是第low个到第mid-1个,范围个数是F(k-1) - 1个,即有序列表左边的长度<br>(3)当key &gt; numbers[mid]时,新范围是第mid+1到第high个,范围个数是F(k-2) - 1个,即有序列表右边的长度</p><p>k 表示列表的长度<br>k-1表示索引<br>F(k-1)表示列表最后一个元素</p><p>元素总个数 = 左区间个数 + 右区间个数 + 中间的一个元素,即:</p><pre><code>F(k)-1 = F(k-1)-1  +   F(k-2)-1    +     1</code></pre><p>斐波那契查找算法如下：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 斐波那契查找</span></span><br><span class="line">def Fbonacci(index):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="literal">return</span> </span><br><span class="line">    <span class="keyword">a</span>, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(index):</span><br><span class="line">        <span class="keyword">a</span>, b = b, <span class="keyword">a</span> + b</span><br><span class="line">    <span class="literal">return</span> <span class="keyword">a</span></span><br><span class="line">    </span><br><span class="line">def FbonacciSearch(key, numbers):</span><br><span class="line">    <span class="comment"># 确定该序列在斐波那契数列中的位置</span></span><br><span class="line">    n, <span class="built_in">length</span> = <span class="number">0</span>, <span class="built_in">len</span>(numbers)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span> &gt; Fbonacci(n) - <span class="number">1</span>:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 填满元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n,Fbonacci(n)):</span><br><span class="line">        numbers.append(numbers[<span class="number">-1</span>])</span><br><span class="line">    </span><br><span class="line">    low, high = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        <span class="comment"># 获取黄金分割下标</span></span><br><span class="line">        <span class="keyword">mid</span> = low + Fbonacci(n - <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左区间</span></span><br><span class="line">        <span class="comment">#若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1</span></span><br><span class="line">        <span class="keyword">if</span> key &lt; numbers[<span class="keyword">mid</span>]:</span><br><span class="line">            high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 右区间</span></span><br><span class="line">        <span class="comment">#若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1</span></span><br><span class="line">        <span class="keyword">if</span> key &gt; numbers[<span class="keyword">mid</span>]:</span><br><span class="line">            low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">            n -= <span class="number">2</span></span><br><span class="line">        <span class="comment"># 相等</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 成功找到</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">mid</span> &lt;= n:</span><br><span class="line">                <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">            <span class="comment"># 补全的数,返回n</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="literal">return</span> n</span><br><span class="line">    <span class="literal">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="4-比较"><a href="#4-比较" class="headerlink" title="4.比较"></a>4.比较</h3><p>二分查找是加法与除法运算<br>插值查找是复杂的四则运算<br>斐波那契查找是加减法运算</p><h2 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h2><p>索引:把一个关键字与它对应的记录相关联的过程.<br>线性索引:把索引项集合组织为线性结构,也即索引表</p><h3 id="1-稠密索引"><a href="#1-稠密索引" class="headerlink" title="1.稠密索引"></a>1.稠密索引</h3><p>稠密索引:将数据集的每个记录对应一个索引项,且索引项一定按照关键码有序排列.</p><h3 id="2-分块索引"><a href="#2-分块索引" class="headerlink" title="2.分块索引"></a>2.分块索引</h3><p>对数据集进行分块,使分块有序,然后对每一块建立一个索引项,从而减少索引项的个数.</p><p>块需要满足的条件:<br>(1)块内无序:每一块的记录不要求有序.<br>(2)块间有序:比如,要求第二块所有记录的关键字均要大于第一块所有记录的关键字.第三块大于第二块…</p><p>分块索引的索引项结构:</p><ul><li>最大关键码:存储每一块中点最大关键字</li><li>存储块中记录的个数,便于循环</li><li>用于指向块首数据元素的指针,便于遍历</li></ul><p>查找分两步:<br>(1)在分块索引表中查找关键字所在的块.<br>(2)根据块首指针找到相应的块,并在块中顺序查找关键码.</p><p>设n个记录被平均分成m块,每个块t条记录,则n=mt<br>查找索引表的平均查找长度:(1+m)/2<br>查找记录的平均查找长度:(t+1)/2</p><p>则块中查找记录的平均查找长度:</p><pre><code>  (1+m)/2 + (t+1)/2 = (m+t)/2+1 = (n/t+t)/2+1</code></pre><p>最佳情况:m与t相等,也即n = t^2 = m^2 ,则原式为:</p><pre><code>= (t*t/t+t)/2+1= t+1= n^0.5 + 1 (^ 表示次方)</code></pre><p>由此分块索引比顺序查找O(n)提高不少.</p><h3 id="3-倒排索引"><a href="#3-倒排索引" class="headerlink" title="3.倒排索引"></a>3.倒排索引</h3><p>索引项的结构:次关键码与记录号表<br>根据属性(次关键码,字段)的值查找记录.<br>该索引表中的每一项包括一个属性值和具有该属性值的各记录的地址.<br>由于不是由记录确定属性值而是由属性值确定记录,因而称为倒排索引.</p><p>优点:生成索引表后不用读取记录就可知道结果,查找非常快<br>缺点:记录号不定长</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>如果查找的数据集是有序线性表,并且是顺序存储的,可以使用二分查找/插值查找/斐波那契查找,但是在插入删除操作上耗费大量时间,由此引出既可以使得插入删除效率不错又可以高效率查找的算法====&gt;使用二叉树数据结构:在创建集合时就考虑使用二叉树结果,而且是排好序的二叉树.构造二叉搜索树的目的不是为了排序,而是为了提高插入/删除的效率.</p><p>二叉查找树,也称(二叉搜索树,有序二叉树,排序二叉树,二叉排序树）,是指<strong>一棵空树</strong>或者具有下列性质的<strong>二叉树</strong>：</p><ul><li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ul><p>性质:<br>1.左小于根小于右<br>2.值不重复<br>3.”中序遍历“可以让结点有序<br>4.二叉搜索树有两种结点删除方式:取被删除结点的右子树中的最小元素替代或者取被删除结点的左子树中的最大元素替代</p><p>优势:<br>查找、插入的时间复杂度较低。为O(log n)<br>二叉查找树的最坏效率是O(n),此时退化为线性结构</p><p><img src="http://static.chenyalun.com/2017/04/21/170421006.jpg" alt=""></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeNode</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,val = <span class="number">0</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.val = val</span><br><span class="line"><span class="keyword">self</span>.left = None</span><br><span class="line"><span class="keyword">self</span>.right = None</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找结点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(<span class="keyword">self</span>, data)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.val == <span class="symbol">data:</span></span><br><span class="line"><span class="keyword">return</span> True</span><br><span class="line">elif data &lt; <span class="keyword">self</span>.val <span class="keyword">and</span> <span class="keyword">self</span>.<span class="symbol">left:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.left.find(data)</span><br><span class="line">elif data &gt; <span class="keyword">self</span>.val <span class="keyword">and</span> <span class="keyword">self</span>.<span class="symbol">right:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.right.find(data)</span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找最小结点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMinData</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">left:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.left.findMinData()</span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找最大结点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxData</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">right:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.right.findMaxData()</span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.val</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入结点</span></span><br><span class="line"><span class="comment"># 当data与二叉搜索树中某结点val相等时不作处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertNode</span><span class="params">(<span class="keyword">self</span>, data)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="comment"># 在右子树上</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.val &lt; <span class="symbol">data:</span></span><br><span class="line"><span class="keyword">if</span>  <span class="keyword">self</span>.<span class="symbol">right:</span></span><br><span class="line"><span class="keyword">self</span>.right.insertNode(data)</span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="keyword">self</span>.right = BinarySearchTreeNode(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在左子树上</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.val &gt; <span class="symbol">data:</span></span><br><span class="line"><span class="keyword">if</span>  <span class="keyword">self</span>.<span class="symbol">left:</span></span><br><span class="line"><span class="keyword">self</span>.left.insertNode(data)</span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="keyword">self</span>.left = BinarySearchTreeNode(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印二叉搜索树</span></span><br><span class="line"><span class="comment"># 左根右遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printTree</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">left:</span></span><br><span class="line"><span class="keyword">self</span>.left.printTree()</span><br><span class="line">print <span class="keyword">self</span>.val,</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">right:</span></span><br><span class="line"><span class="keyword">self</span>.right.printTree()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结点的删除</span></span><br><span class="line"><span class="comment"># 当删除一个叶子结点时,直接删除即可</span></span><br><span class="line"><span class="comment"># 当删除的结点只有一个孩子时,用该孩子替换</span></span><br><span class="line"><span class="comment"># 当删除的结点有两个孩子时,寻找该结点右子树中的最小数据代替子节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">daleteNode</span><span class="params">(<span class="keyword">self</span>, data)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="comment"># 前提是该结点在二叉搜索树中能找到</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.find(data)<span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line"><span class="keyword">if</span> data &lt; <span class="keyword">self</span>.<span class="symbol">val:</span></span><br><span class="line"><span class="keyword">self</span>.left = <span class="keyword">self</span>.left.daleteNode(data)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">elif data &gt; <span class="keyword">self</span>.<span class="symbol">val:</span></span><br><span class="line"><span class="keyword">self</span>.right = <span class="keyword">self</span>.right.daleteNode(data)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">elif <span class="keyword">self</span>.left <span class="keyword">and</span> <span class="keyword">self</span>.<span class="symbol">right:</span></span><br><span class="line"><span class="comment"># 找到右子树最小的结点,获取值</span></span><br><span class="line">val = <span class="keyword">self</span>.right.findMinData()</span><br><span class="line"><span class="comment"># 把最小结点的值给自己</span></span><br><span class="line"><span class="keyword">self</span>.val = val</span><br><span class="line"><span class="comment"># 删除右子树中的最小结点,使self.right指向右子树的根节点</span></span><br><span class="line"><span class="comment"># self.right.daleteNode(val)最终返回右子树的根节点</span></span><br><span class="line"><span class="keyword">self</span>.right = <span class="keyword">self</span>.right.daleteNode(val)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="comment"># 左结点存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">left:</span></span><br><span class="line"><span class="comment"># 直接指向左结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.left</span><br><span class="line"><span class="comment"># 右结点存在,或不存在结点</span></span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="comment"># 直接指向右结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = BinarySearchTreeNode(<span class="number">10</span>)</span><br><span class="line">a.insertNode(<span class="number">8</span>)</span><br><span class="line">a.insertNode(<span class="number">12</span>)</span><br><span class="line">a.insertNode(<span class="number">6</span>)</span><br><span class="line">a.insertNode(<span class="number">9</span>)</span><br><span class="line">a.insertNode(<span class="number">11</span>)</span><br><span class="line">a.insertNode(<span class="number">14</span>)</span><br><span class="line">a.insertNode(<span class="number">7</span>)</span><br><span class="line">a.insertNode(<span class="number">13</span>)</span><br><span class="line">a.insertNode(<span class="number">5</span>)</span><br><span class="line">a.insertNode(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">a.printTree()</span><br><span class="line">print <span class="string">"\n"</span></span><br><span class="line">print a.find(<span class="number">11</span>)</span><br><span class="line">print a.find(<span class="number">100000</span>)</span><br><span class="line">print a.findMaxData()</span><br><span class="line">print a.findMinData()</span><br><span class="line"></span><br><span class="line">a.daleteNode(<span class="number">1000000</span>)</span><br><span class="line">a.daleteNode(<span class="number">10</span>)</span><br><span class="line">a.daleteNode(<span class="number">14</span>)</span><br><span class="line">a.daleteNode(<span class="number">2</span>)</span><br><span class="line">a.printTree()</span><br></pre></td></tr></table></figure><p>二叉搜索树以链接的方式存储,保持了链接存储结构在执行插入或删除时的优越性.</p><p><img src="http://static.chenyalun.com/2017/04/21/170421002.png" alt=""></p><p>对于二叉搜索树的查找,比较次数等于给定值的结点在二叉搜索树的层数.最少为1次(为根节点),最多不超过树的深度(最差是极端的右斜树或左斜树).</p><p><img src="http://static.chenyalun.com/2017/04/21/170421001.png" alt=""></p><p>二叉排序树倘若是平衡的,其深度与完全二叉树相同,均为<code>floor(logn) + 1</code>,查找的时间复杂度为O(logn),近似与折半查找,若不是平衡的,甚至演化为极端的右斜树或左斜树,查找的时间复杂度为O(n),等同于顺序查找.</p><p>因此,平衡至关重要.</p><h2 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h2><p>平衡二叉搜索树是改进的二叉搜索树,也是二叉搜索树。</p><p>一般的二叉搜索树的查询复杂度是跟深度有关，因此当结点的深度普遍较大时，查询的均摊复杂度会上升，为了更高效的查询，平衡树应运而生了。</p><p>可以使查找树的高度为 O (log(n)) </p><p>定义:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>AVL树中的每个结点都有一个平衡因子（balance factor，BF），它表示这个结点的左、右子树的深度差，也就是左子树的深度减去右子树的深度的结果值。AVL树上所有结点的BF值只能是-1、0、1。反之，只要二叉树上一个结点的BF的绝对值大于1，则该二叉树就不是平衡二叉树。在进行插入和删除的时候找出失去平衡的节点，进行必要的旋转操作保证树的平衡。</p><p>查找、插入和删除在平均和最坏情况下都是O（log n）</p><h3 id="最少结点"><a href="#最少结点" class="headerlink" title="最少结点"></a>最少结点</h3><p>设n(h)是高度为h的AVL树，则结点数最少时有:<br>n(h) = n(h-1) + n(h-2) + 1</p><table><thead><tr><th>h(VAL树的高度)</th><th>最少结点数</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>2</td><td>4</td></tr><tr><td>3</td><td>7</td></tr><tr><td>4</td><td>12</td></tr><tr><td>5</td><td>20</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>显而易见，满足的关系为:<br>高度为h的AVL树，其最少结点数量为<code>F(h+2) - 1</code>，其中F(x)为斐波那契数列逗号且规定从1开始，即F(0) = 1，F(1) = 2</p><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><p>RR(右单旋):麻烦结点在发现结点的右子树的右子树上</p><p>RL():麻烦结点在发现结点的右子树的左子树上</p><p>LL(左单旋):麻烦结点在发现结点的左子树的左子树上</p><p>LR():麻烦结点在发现结点的左子树的右子树上</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆:用数组表示的完全二叉树<br>有序性:任一结点的关键字是其子树所有结点的最大值(或者最小值)，从根结点到任意结点路径上结点序列的有序性。<br>最大堆,也称为大顶堆:最大值<br>最小堆,也称为小顶堆:最小值</p><p>最大堆的建立:<br>方法一:自底向上调整堆，首先将n个节点按输入顺序存入，使其满足完全二叉树的结构特性，然后调整各节点的位置。</p><p>方法二:通过插入操作，将n个元素一个个地相继插入到一个初始为空的堆中，其时间代价最大为O(nlogn)。</p><p>堆顶元素的删除<br>元素的插入</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>带权路径长度:设二叉树有n个叶子节点，每个叶子节点带有权值W，从根节点到每个叶子节点的长度为L，则每个叶子节点的带权路径长度之和为WPL=∑WL。<br>哈夫曼树即是最优二叉树:WPL最小的二叉树。</p><p>性质:</p><ol><li>没有度为1的结点(按照构造哈夫曼树的规则，显而易见)。</li><li>n个叶子节点的哈夫曼树共有 <code>2 * n - 1</code>个结点。</li><li>哈夫曼树的任意非叶子结点的左右子树交换后仍是哈夫曼树。</li><li>对同一组权值的，可能存在不同结构的几棵哈夫曼树，但是它们的WPL是相同的。</li></ol><p>性质2推导:根据哈夫曼树没有度为1的结点，则 n1 = 0，又根据 n0 = n2 + 1，sum = n0 + n1 + n2，则有:</p><pre><code>sum = n0 + n1 + n2    = n0 + n2    = n0 + n0 - 1    = 2 * n0 - 1    = 2 * n - 1 // n即n0</code></pre><p>图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片<br><img src="" alt=""></p><p>图a的WPL为 5 <em> 2 + 7 </em> 2 + 2 <em> 2 + 13 </em> 2 = 54<br>图b的WPL为 13 <em> 1 + 7 </em> 2 + 2 <em> 3 + 5 </em> 3 = 48<br>PL的计算方式为:该节点的权值 * 从根节点到该节点的树枝数量</p><p>哈夫曼树的构造:每次把权值最小的两个二叉树合并，参照最大堆的调整。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p><p>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）每个红色节点必须有两个黑色的子节点。<br>（5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。  </p><p>一棵n个结点是红黑树始终保持了logn的高度,所以红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</p><p>红黑树之所以是平衡的二叉查找树，是因为每个节点都有表示其颜色的域值：红或黑，在插入和删除操作的时候依据节点的颜色向平衡的方向调整。</p><p><img src="http://static.chenyalun.com/2017/04/21/170421007.png" alt=""></p><p>“叶结点” 或”NULL结点”，它不包含数据而只充当树在此结束的指示，这些结点以及它们的父结点，在绘图中都会经常被省略。</p><p>当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。 为了继续保持红黑树的性质，我们可以通过对结点进行重新着色，以及对树进行相关的旋转操作</p><p>左旋:左右左<br>右旋:右左右</p><h2 id="多路查找树-B树"><a href="#多路查找树-B树" class="headerlink" title="多路查找树(B树)"></a>多路查找树(B树)</h2><p>B树即为B-树、B_树,又叫平衡多路查找树.<br>多路查找树:其每一个结点的孩子数可以多于两个,每一个结点处可以存储多个元素.</p><p>一个节点只能存储一个元素,在元素非常多的时候,就使得要么树的度非常大,要么树的高度非常大,甚至两者都必须足够大才可以,这使得内存存取外村次数非常多,造成了时间效率上的瓶颈,于是引入多路查找树.</p><p>树的高度越高，查找文件所需要的磁盘IO读写次数越多，所以为了减少磁盘的IO读写，要想办法进一步降低树的高度。 因此，具有多个孩子的B树便应运而生，因为B树每一个结点可以有几个到几千个孩子，使得在结点数目一定的情况下，树的高度会大大降低，从而有效减少磁盘IO读写消耗。</p><p>B+树、B树等的根结点和部分顶层数据存在内存中，大部分下层数据存在磁盘上。</p><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>2-3树是这样一棵多路查找树:其中的每一个结点都具有两个孩子或三个孩子.</p><ol><li><p>一个2结点包含一个元素和两个孩子(或没有孩子),与二叉排序树类似,左子树包含的元素小于该元素,右子树包含的元素大于该元素,与二叉排序树不同的是,这个2结点要么没有孩子,要么就有两个,不能只有一个孩子.</p></li><li><p>一个3结点包含一小一大两个元素和三个孩子(或没有孩子),一个3结点要么没有孩子,要么具有3个孩子.如果具有3个孩子的话,左子树包含的元素小于较小元素的元素,右子树包含的元素大于较大元素的元素,中间子树包含介于两元素之间的元素.</p></li><li><p>并且2-3树中所有叶子都在同一层次上.</p></li></ol><p>2-3树的插入</p><p>2-3树的删除</p><h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p>2-3树的概念扩展,包括了4结点的使用.一个4结点包含小中大三个元素和四个孩子(或者没有孩子).</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树是一种平衡的多路查找树,2-3树和2-3-4树都是B树的特例.<br>结点最大的孩子数目称为B树的阶.<br>2-3树是3阶B树,2-3-4树是4阶B树.</p><p>A B-tree of order m is a tree which satisfies the following properties:</p><pre><code>Every node has at most m children.Every non-leaf node (except root) has at least ⌈m/2⌉ children.The root has at least two children if it is not a leaf node.A non-leaf node with k children contains k−1 keys.All leaves appear in the same level</code></pre><p>一棵m阶的B树满足以下条件<br>1.每个结点至多有m棵子树<br>2.除根结点外,其他分支结点至少有ceil(m/2)棵子树(ceil()函数向上取整<br>3.根结点至少有两棵子树,除非树只包含一个结点<br>4.有k个孩子的非叶结点有k-1个关键码,关键码按递增次序排列<br>5.所有叶子结点在同一层</p><h4 id="B树如何做到减少访问外存次数"><a href="#B树如何做到减少访问外存次数" class="headerlink" title="B树如何做到减少访问外存次数"></a>B树如何做到减少访问外存次数</h4><p>硬盘将信息分割成相等大小的页面,每次硬盘读写都是一个或者多个完整的页面,对一个硬盘来说,一页的长度可能是211到214字节.</p><p>在一个典型的B树应用中,要处理的硬盘数据量很大,因此无法一次全部装入内存,因此需要对B树进行调整,使得B树的阶树与硬盘存储的页面大小相匹配.在有限内存的情况下,每一次磁盘的访问我们都可以获得最大量的数据,由于B树每节点可以具有比二叉树多得多的元素,所以减少了必须访问结点和数据块的数量,提高了性能.<br>B树的数据结构就是为内外存的数据交互准备的.</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+ 树是一种树数据结构，通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。</p><p>B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。</p><p>一棵m阶的B+树与B树的区别在于:</p><ol><li>有n棵子树的结点包含有n个关键字</li><li>所有的叶子节点包含全部的关键字信息,以及指向含这些关键字记录的指针,叶子节点本身依关键字的大小自小而大顺序链接</li><li>所有分支结点可以看成是索引,结点中仅含有其子树的最大(最小)关键字.</li></ol><p>好处:<br>如果要随机查找,就从根节点出发,与B树的查找方式相同,只不过即使在分支结点找到了待查找的关键字,它也只是用来索引的,不能提供实际记录的访问,还是需要到达包含此关键字的终端结点.</p><p>如果需要从最小关键字进行自小而大的顺序查找,可以从最左端的叶子结点出发,不经过分支结点,而是沿着指向下一叶子的指针就可遍历所有的关键字.</p><p>B+树适合有范围的查找(比如年龄18–22),从根节点出发找到18,再在叶子结点中按顺序找到符合要求的记录.</p><p>B+树的插入/删除与B树类似,只不过插入删除的元素都是在叶子结点上进行.</p><h2 id="散列表查找"><a href="#散列表查找" class="headerlink" title="散列表查找"></a>散列表查找</h2><p>存储位置 = f(关键字)</p><p>记录的存储位置和它的关键字之间建立的一个确定的对应关系.每个关键字key对应一个存储位置f(key),查找时根据这个确定的对应关系找到给定key的映射f(key).</p><p>f称为散列函数,又称哈希函数,采用散列技术将记录存储在一块连续的存储空间中,这块连续的存储空间称为散列表或哈希表,关键字对应的记录存储位置称为散列地址.</p><p>冲突:key1不等于key2,但是f(key1)=f(key2),key1和key2称为散列函数的同义词.</p><h3 id="常用的散列函数"><a href="#常用的散列函数" class="headerlink" title="常用的散列函数"></a>常用的散列函数</h3><h4 id="1-直接定址法"><a href="#1-直接定址法" class="headerlink" title="1.直接定址法"></a>1.直接定址法</h4><pre><code>f(key) = a * key + b  (a,b为常数)</code></pre><ul><li>优点:简单均匀,不会产生冲突,但需要事先知道关键字的分布情况,适合查找表较小且连续的情况.</li></ul><h4 id="2-数字分析法"><a href="#2-数字分析法" class="headerlink" title="2.数字分析法"></a>2.数字分析法</h4><p>手机号码等,对数字进行抽取,反转,左环位移,右环位移等方式合理地将关键字分配到散列表的各位置.</p><ul><li>适合处理关键字位数比较大的情况,如果事先知道关键字的分布且关键字的若干位分布均匀,可以使用.</li></ul><h4 id="3-平方取中法"><a href="#3-平方取中法" class="headerlink" title="3.平方取中法"></a>3.平方取中法</h4><p>关键字1234—-&gt;平方后:1522756—–&gt;抽取中间的3位——&gt;227,用作散列地址.</p><ul><li>适合不知道关键字的分布,而位数又不是很大的情况</li></ul><h4 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="4.折叠法"></a>4.折叠法</h4><p>从左到右分割成位数相等的几部分,叠加求和,按照散列表长,取后几位作为散列地址.</p><p>9876543210—–&gt;987  654  321 0—–&gt;求和987+654+321+0=1962,求后三位:962</p><ul><li>适合不需要事先知道关键字的分布.适合关键字位数较多的情况.</li></ul><h4 id="5-除留余数法"><a href="#5-除留余数法" class="headerlink" title="5.除留余数法"></a>5.除留余数法</h4><p>最常用,散列表长为m的公式:</p><pre><code>f(key) = key mod p (p&lt;=m)</code></pre><ul><li>若散列表表长m,通常p为小于或者等于表长的最小质数或不包含小于20质因子的合数.</li></ul><h4 id="6-随机数法"><a href="#6-随机数法" class="headerlink" title="6.随机数法"></a>6.随机数法</h4><pre><code>f(key) = random(key)</code></pre><ul><li>当关键字的长度不等时,采用这个方法.</li></ul><h3 id="常用的处理冲突方法"><a href="#常用的处理冲突方法" class="headerlink" title="常用的处理冲突方法"></a>常用的处理冲突方法</h3><h4 id="1-开放定址法"><a href="#1-开放定址法" class="headerlink" title="1.开放定址法"></a>1.开放定址法</h4><p>线性探测法</p><pre><code>f(key) = (f(key) + d) mod m  (d = 1,2,3...)</code></pre><p>二次探测法</p><pre><code>f(key) = (f(key) + d) mod m  (d = 1^2,-1^2,2^2,-2^2,3^2,-3^2...q^2,-q^2,其中q&lt;=m/2)</code></pre><p>随机探测法</p><pre><code>f(key) = (f(key) + d) mod m  (d 是一个随机数列)</code></pre><h4 id="2-再散列函数法"><a href="#2-再散列函数法" class="headerlink" title="2.再散列函数法"></a>2.再散列函数法</h4><pre><code>f(key) = RH(key)</code></pre><p>每次发生散列冲突时,就换一个散列函数计算.</p><h4 id="3-链地址法"><a href="#3-链地址法" class="headerlink" title="3.链地址法"></a>3.链地址法</h4><p>提供绝不会找不到地址的保障,但是带来查找时需要遍历单链表的性能损耗.</p><h4 id="4-公共溢出区法"><a href="#4-公共溢出区法" class="headerlink" title="4.公共溢出区法"></a>4.公共溢出区法</h4><p>增添溢出表.<br>对给定值通过散列函数计算出散列地址后,先与基本表的相应位置进行比对,如果相等,成功,否则,到溢出表中进行<strong>顺序查找</strong>.    </p><blockquote><p>参考并致谢<br><a href="https://www.zhihu.com/question/19809666/answer/88158084" target="_blank" rel="noopener">知乎 灰杉树</a><br><a href="http://haiyangxu.github.io/posts/2014/2014-05-05-binary_search_tree.html" target="_blank" rel="noopener">HAIYANG XU</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="noopener">v_JULY_v</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 关于查找算法。 &lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://blog.chenyalun.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>读《Objective-C高级编程》</title>
    <link href="http://blog.chenyalun.com/2017/04/13/%E8%AF%BB%E3%80%8AObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"/>
    <id>http://blog.chenyalun.com/2017/04/13/读《Objective-C高级编程》/</id>
    <published>2017-04-13T13:05:17.000Z</published>
    <updated>2017-04-13T13:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 关于ARC/Block/GCD。 </p><a id="more"></a><h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>寒假里就大致看了一遍，但是吸收的不完全，尤其是block部分。这两三天又赶紧从图书馆借来翻一翻，还是收获满满。不过C++不够扎实，很多源码还是看不明白(摊手)。这里把一些重点问题整理出来，以问答的形式进行总结，所有代码都尝试验证一下，没毛病。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="一-为什么苹果主要采用散列表管理引用计数"><a href="#一-为什么苹果主要采用散列表管理引用计数" class="headerlink" title="一.为什么苹果主要采用散列表管理引用计数"></a>一.为什么苹果主要采用散列表管理引用计数</h2><p><strong>GNUstep将引用计数保存在对象占用内存块头部的变量中。</strong><br>优点：</p><ol><li>只需少量代码。</li><li>能统一管理引用计数用内存块与对象用内存块。</li></ol><p><strong>苹果采用散列表（引用计数表，DenseMap 类实现）管理引用计数。</strong><br>优点：</p><ol><li>对象用内存块的分配无需考虑内存块头部。</li><li>引用计数表记录中存有内存块地址，可追溯各对象的内存块。有助于检测对象的持有者是否存在，可检测内存泄漏。</li></ol><p>注:如果设备是 64 位环境并且使用 Objective-C 2.0，那么“一些”对象会使用其 isa 指针的一部分空间来存储它的引用计数。</p><p><strong>苹果为什么不采用垃圾回收（GC）？</strong></p><p>苹果曾在OS X 10.5 尝试使用，不过在 10.7 的时候把 GC 换成了 ARC。GC 有个问题让苹果不能忍：垃圾回收的时候，整个程序需要暂停，英文把这个过程叫做：Stop the World。所有的对象都需要一起回收时，造成用户体验不好。</p><p><strong>ARC相对于GC所具有的优点：</strong></p><ol><li><p>ARC工作在编译期，在运行时没有额外开销。</p></li><li><p>ARC的内存回收是平稳进行的，对象不被使用时会立即被回收。而GC的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。</p></li></ol><p><strong>简单介绍GC的原理</strong><br>基于事实：大部分的对象的生命期都很短。</p><p>GC 将内存中的对象主要分成两个区域：Young 区和 Old 区。<br>对象先在 Young 区被创建，然后如果经过一段时间还存活着，则被移动到Old 区。（其实还有一个Perm区，但是内存回收算法通常不涉及这个区域）</p><p>Young区的对象因为大部分生命期都很短，每次回收之后只有少部分能够存活，所以采用的算法叫Copying算法，简单说来就是直接把活着的对象复制到另一个地方。Young 区内部又分成了三块区域：Eden区 ,From区 ,To区。每次执行 Copying 算法时，即将存活的对象从 Eden 区和 From 区复制到To区，然后交换 From 区和To区的名字（即From 区变成 To 区，To区变成From区）。</p><p>Old区的回收算法叫 Mark-Sweep 算法。简单来说，就是只是把不用的对象先标记（Mark）出来，然后回收（Sweep），活着的对象就不动它了。因为大部分对象都活着，所以回收下来的对象并不多。但是这个算法会有一个问题：它会产生内存碎片，所以它一般还会带有整理内存碎片的逻辑，在算法中叫做 Compact。</p><h2 id="二-如何提高Objective-C方法的速度"><a href="#二-如何提高Objective-C方法的速度" class="headerlink" title="二.如何提高Objective-C方法的速度"></a>二.如何提高Objective-C方法的速度</h2><p>采用IMP Caching。一般而言速度是其他方法的两倍。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> autorelease_class = [<span class="built_in">NSAutoreleasePool</span> <span class="keyword">class</span>];</span><br><span class="line">SEL autorelease_sel = <span class="keyword">@selector</span>(addObject:);</span><br><span class="line">IMP autorelease_imp = [autorelease_class methodForSelector:autorelease_sel];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) autorelease</span><br><span class="line">&#123;</span><br><span class="line">    (* autorelease_imp)(autorelease_class,autorelease_sel,<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)autorelease</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">NSAutoreleasePool</span> addObject:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IMP的使用:实例方法+有参数+有返回值</strong></p><p>IMP默认是无参数，无返回值类型，且自带_cmd和selector。如果要使用带参数或者带返回值的IMP有两种方法。<br>方式一：关闭Xcode中的编译选项。<br><img src="http://static.chenyalun.com/2017/04/13/20170413001.png" alt=""></p><p>方式二：重新定义一个“IMP”，但不能同名，否则会报错，显示</p><p><code>Typedef redefinition with different types (&#39;id (*)(__strong id, SEL, ...)&#39; vs &#39;void (*)(void)&#39;)</code></p><p>这里统一采取第二种方式，即重新定义函数指针_IMP。</p><p><code>typedef id (*_IMP)(id, SEL,...);</code></p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// .h文件</span></span><br><span class="line"><span class="selector-tag">-</span> (NSString *)<span class="selector-tag">print</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">name</span>;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// .m文件</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)print:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,name);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"因为我刚好遇见你"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">YAUser *user = [[YAUser alloc] init];</span><br><span class="line">user.<span class="built_in">name</span> = @<span class="string">"张无忌"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取SEL</span></span><br><span class="line">SEL sel = @selector(print:);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数指针</span></span><br><span class="line"><span class="variable">_IMP</span> instanceIMP1 = (<span class="variable">_IMP</span>)[YAUser instanceMethodForSelector:sel];</span><br><span class="line"><span class="variable">_IMP</span> instanceIMP2 = (<span class="variable">_IMP</span>)[user methodForSelector:sel];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法并返回字符串</span></span><br><span class="line">NSString *name1 = (*instanceIMP1)(user, sel, user.<span class="built_in">name</span>);</span><br><span class="line">NSString *name2 = (*instanceIMP2)(user, sel, user.<span class="built_in">name</span>);</span><br><span class="line">NSLog(@<span class="string">"%@--%@"</span>,name1, name2);</span><br></pre></td></tr></table></figure><p><strong>IMP的使用:类方法+有参数+有返回值</strong></p><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">+ (NSString *)printClassName:(<span class="class"><span class="keyword">Class</span>)<span class="title">className</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)printClassName:(Class)className &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,className);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"原谅我这一生不羁放纵爱自由"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSStringFromClass</span>(className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">YAUser *user = [[YAUser alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取SEL</span></span><br><span class="line">SEL sel = <span class="meta">@selector(printClassName:)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数指针</span></span><br><span class="line">_IMP classIMP = (_IMP)[[YAUser <span class="class"><span class="keyword">class</span>] <span class="title">methodForSelector</span>:<span class="type">sel];</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法并返回字符串</span></span><br><span class="line">NSString *name = (*classIMP)(user, sel, [user <span class="class"><span class="keyword">class</span>]);</span></span><br><span class="line">NSLog(@<span class="string">"%@"</span>,name);</span><br></pre></td></tr></table></figure><p><strong>实例方法/类方法+无参数+无返回值</strong></p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">- (<span class="name">void</span>)print<span class="comment">;</span></span><br><span class="line">+ (<span class="name">void</span>)printName<span class="comment">;</span></span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>print&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog<span class="params">(@<span class="string">"留下足迹才美丽"</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ <span class="params">(void)</span>printName &#123;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"风吹花落美如玉"</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取SEL</span></span><br><span class="line">SEL sel1 = <span class="meta">@selector(print)</span>;</span><br><span class="line">SEL sel2 = <span class="meta">@selector(printName)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数指针</span></span><br><span class="line">IMP instanceIMP = [[YAUser <span class="class"><span class="keyword">class</span>] <span class="title">instanceMethodForSelector</span>:<span class="type">sel1];</span></span></span><br><span class="line">IMP classIMP = [YAUser methodForSelector:sel2];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">(*instanceIMP)();</span><br><span class="line">(*classIMP)();</span><br></pre></td></tr></table></figure><h2 id="三-非显式使用-autoreleasing的场景有哪些"><a href="#三-非显式使用-autoreleasing的场景有哪些" class="headerlink" title="三.非显式使用__autoreleasing的场景有哪些"></a>三.非显式使用__autoreleasing的场景有哪些</h2><p><strong>场景一:@autoreleasepool。</strong></p><p>编译器会检查@autoreleasepool块中的方法,如果<strong>不是</strong>以alloc/new/copy/mutableCopy开头，则自动把方法返回值的对象注册到autoreleasepool中。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="built_in">NSObject</span>  *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="comment">// ==&gt;NSObject __strong *object = [[NSObject alloc] init];</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> array];</span><br><span class="line">    <span class="comment">// ==&gt;NSArray __autoreleasing  *array = [NSArray array];</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>场景二:方法的返回值。</strong></p><p>没有显式指定所有权修饰符，所以默认为__strong。由于return使得变量array超出作用域，强引用对应持有的对象会释放。但是该对象作为方法的返回值，编译器自动将其注册到自动释放池中，延缓释放(否则如果立即释放，那返回值就没有意义了)。</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">- (id)<span class="keyword">array</span> &#123;</span><br><span class="line">    NSArray *<span class="keyword">array</span> = [NSArray <span class="keyword">array</span>];</span><br><span class="line">    // ==&gt;NSArray __strong *<span class="keyword">array</span> = [NSArray <span class="keyword">array</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>场景三:<code>__weak</code>修饰的变量。</strong><br><code>__weak</code>修饰的变量会被自动注册到自动释放池中。由于<code>__weak</code>不持有对象的强引用，在访问该对象的时候，该对象有可能已经释放，但是要保证能访问到该对象，所以把它注册到自动释放池中，确保@autoreleasepool块结束之前该对象存在。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> object;</span><br></pre></td></tr></table></figure><p><strong>场景四:指向对象的指针的指针。</strong><br>指向对象的指针默认<strong>strong修饰。<br>指向对象的指针的指针默认</strong>autoreleasing修饰。</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">NSObject *o<span class="comment">;</span></span><br><span class="line">// ==&gt;NSObject __strong *o<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">NSObject **o<span class="comment">;</span></span><br><span class="line">// ==&gt;NSObject* __autoreleasing *o<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>为什么要使用指向对象的指针的指针?</strong><br>通常是回传值。<br>在C函数中，无法返回多个值，借助指针可以回传值。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求两个数的和 积</span></span><br><span class="line"><span class="built_in">NSInteger</span> sum(<span class="built_in">NSInteger</span> a, <span class="built_in">NSInteger</span> b, <span class="built_in">NSInteger</span> *product) &#123;</span><br><span class="line">    <span class="comment">// 计算乘积</span></span><br><span class="line">    *product = a * b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回求和</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">    <span class="built_in">NSInteger</span> a = <span class="number">3</span>, b = <span class="number">32</span>, summation, product;</span><br><span class="line">    summation = sum(a,b,&amp;product);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld--%ld"</span>,summation,product);</span><br></pre></td></tr></table></figure><p>在Objective-C中常用于NSError对象。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"这里是URL"</span>];</span><br><span class="line">[<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br></pre></td></tr></table></figure><p><code>stringWithContentsOfURL:encoding:error:</code>方法返回字符串，但是在获取字符串的时候可能发生错误，于是传入指向NSError对象的指针的指针，用于回传值(error是指向对象的指针，*error是该对象，&amp;error是指向对象的指针的指针)。</p><p>赋给对象指针时，变量所有权修饰符必须保持一致，否则会出错。修饰error的是<strong>strong，而这里要求传入的指针的类型是</strong>autoreleasing:<code>(NSError * _Nullable __autoreleasing * _Nullable)</code>，修饰符不一致，不符合规则，但是编译器做了转换。</p><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">// 转换所有权修饰符</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSError __autoreleasing *tmp = error;</span><br><span class="line">BOOL result = [obj performOperationWithError:&amp;tmp];</span><br><span class="line"><span class="keyword">error </span>= tmp;</span><br></pre></td></tr></table></figure><p><strong>可是为什么要使用__autoreleasing呢?</strong></p><p>实际上不注册到自动释放池也能传(返回)值，就像C函数中的回传乘积值一样。但是这样做不符合内存管理原则，只有作为alloc/new/copy/mutableCopy 开头的方法，能够自己生成并持有。也即其他方法的返回值取得对象(就像场景二中的返回值取得对象一样)需要注册到自动释放池，这便是原则。</p><p>如这种不符合内存管理原则的代码:</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="type">CFGetRetainCount</span>(<span class="class"><span class="keyword">object</span>) <span class="title">!=</span> 1) </span>&#123;</span><br><span class="line">   <span class="type">CFRelease</span>(<span class="class"><span class="keyword">object</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (_objc_rootRetainCount(<span class="class"><span class="keyword">object</span>) <span class="title">!=</span> 1) </span>&#123;</span><br><span class="line">   _objc_rootRelease(<span class="class"><span class="keyword">object</span>)</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="四-内存泄漏的场景有哪些"><a href="#四-内存泄漏的场景有哪些" class="headerlink" title="四.内存泄漏的场景有哪些"></a>四.内存泄漏的场景有哪些</h2><h4 id="1-Core-Fundation的类型转换"><a href="#1-Core-Fundation的类型转换" class="headerlink" title="1. Core Fundation的类型转换"></a>1. Core Fundation的类型转换</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CFMutableArrayRef <span class="built_in">array</span> = CFArrayCreateMutable(kCFAllocatorDefault, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用计数为1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</span><br><span class="line"></span><br><span class="line">id obj = (__bridge id)<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用计数为2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要使用_objc_rootRetainCount(),很不准很不准很不准</span></span><br><span class="line"><span class="comment">//NSLog(@"%d",_objc_rootRetainCount(fontRef));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不使用CFRelease()就会造成内存泄漏</span></span><br><span class="line">CFRelease(<span class="built_in">array</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</span><br></pre></td></tr></table></figure><p>主要原因是获取到CF对象后没有对其引用计数做出合适的处理。</p><h4 id="2-使用calloc函数创建动态数组"><a href="#2-使用calloc函数创建动态数组" class="headerlink" title="2. 使用calloc函数创建动态数组"></a>2. 使用calloc函数创建动态数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  声明动态数组</span></span><br><span class="line"><span class="comment">// 默认为__autoreleasing修饰,需显式指明为__strong</span></span><br><span class="line">id __strong *<span class="built_in">array</span> = nil;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用calloc分配内存</span></span><br><span class="line"><span class="built_in">array</span> = (id __strong *)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(id));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = @<span class="string">"Aaren"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单释放内存,造成内存泄漏</span></span><br><span class="line"><span class="comment">// 实际上对象array[0]还存在</span></span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure><p>正确做法:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  声明动态数组</span></span><br><span class="line"><span class="comment">// 默认为__autoreleasing修饰,需显式指明为__strong</span></span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> *array = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明容量</span></span><br><span class="line"><span class="built_in">NSInteger</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用calloc分配内存</span></span><br><span class="line">array = (<span class="keyword">id</span> __<span class="keyword">strong</span> *)calloc(num, <span class="keyword">sizeof</span>(<span class="keyword">id</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">@"Aaren"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>;i &lt; num; i ++)&#123;</span><br><span class="line">    array[i] = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line">free(array);</span><br></pre></td></tr></table></figure><p>注意:<br>1.不要使用malloc函数分配内存，malloc函数分配内存区域没有被初始化为0，可能产生随机访问导致错误，所以还需要使用memset()函数将内存填充为0。</p><p>2.对于NSMutableSet/NSMutableArray/NSMutableDictionary等容器，不需要人为手动管理。</p><h4 id="3-MRC下的匿名对象"><a href="#3-MRC下的匿名对象" class="headerlink" title="3. MRC下的匿名对象"></a>3. MRC下的匿名对象</h4><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[[<span class="name">NSObject</span> alloc] init]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>匿名对象在MRC下会造成内存泄漏(C++中的匿名对象创建完毕后立即调用析构函数做销毁处理)。</p><p>但是在ARC环境下，不会造成内存泄漏。</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">id temp = objc_msgSend(<span class="name">NSObject</span>, @selector(<span class="name">alloc</span>))<span class="comment">;</span></span><br><span class="line">objc_msgSend(<span class="name">temp</span>,@selector(<span class="name">init</span>))<span class="comment">;</span></span><br><span class="line">objc_release(<span class="name">temp</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>创建完毕立即销毁，这也解释了为什么使用__weak修饰将要创建的对象会有警告。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> * __<span class="keyword">weak</span> object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> object = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure><p>警告:Assigning retained object to weak variable; object will be released after assignment</p><h4 id="4-block的循环引用"><a href="#4-block的循环引用" class="headerlink" title="4. block的循环引用"></a>4. block的循环引用</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAUser</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    block _block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)func &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环引用</span></span><br><span class="line">    _block = ^() &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>,<span class="keyword">self</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-weak如何实现"><a href="#五-weak如何实现" class="headerlink" title="五.__weak如何实现"></a>五.__weak如何实现</h2><p>weak 表的作用是在对象执行 dealloc 的时候将所有指向该对象的 weak 指针的值设为 nil，避免悬空指针。苹果使用一个全局的 weak 表来保存所有的 weak 引用。并将对象作为键，weak_entry_t 作为值。weak_entry_t 中保存了所有指向该对象的 weak 指针。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries;</span><br><span class="line">    <span class="keyword">size_t</span>    num_entries;</span><br><span class="line">    <span class="keyword">uintptr_t</span> mask;</span><br><span class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="六-Core-Fundation-与-Foundation如何转换"><a href="#六-Core-Fundation-与-Foundation如何转换" class="headerlink" title="六.Core Fundation 与 Foundation如何转换"></a>六.Core Fundation 与 Foundation如何转换</h2><p>1.<strong>__bridge</strong><br>只做类型转换，不修改相关对象的引用计数，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFMutableArrayRef <span class="built_in">array</span> = CFArrayCreateMutable(kCFAllocatorDefault, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用计数为1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj强引用该对象(默认为__strong)</span></span><br><span class="line">id obj = (__bridge id)<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用计数为2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不使用CFRelease()就会造成内存泄漏</span></span><br><span class="line">CFRelease(<span class="built_in">array</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</span><br></pre></td></tr></table></figure><p><img src="http://static.chenyalun.com/2017/04/13/20170413002.png" alt=""></p><p>2.<strong>__bridge_transfer</strong><br>常用在CF对象转化成OC对象时，将CF对象的所有权交给OC对象，此时ARC就能自动管理该内存,作用同CFBridgingRelease()</p><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CFMutableArrayRef<span class="built_in"> array </span>= CFArrayCreateMutable(kCFAllocatorDefault, 0, NU<span class="class">LL);</span></span><br><span class="line"></span><br><span class="line">// 引用计数为1</span><br><span class="line">printf(<span class="string">"%ld\n"</span>,CFGetRetainCount(array));</span><br><span class="line"></span><br><span class="line">// obj持有对象 array放弃持有对象,相当于做了CFRelease()    </span><br><span class="line">id obj = (__bridge_transfer  id)array;</span><br></pre></td></tr></table></figure><p>3.<strong>bridge_retained</strong><br>与bridge_transfer 相反，常用在将OC对象转化成CF对象，且OC对象的所有权也交给CF对象来管理，即OC对象转化成CF对象时，涉及到对象类型和对象所有权的转化，作用同CFBridgingRetain()</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *obj = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFMutableArrayRef</span> array2 = (__bridge_retained <span class="built_in">CFMutableArrayRef</span>)obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用计数为2,obj持有对象,array2也持有对象</span></span><br><span class="line">printf(<span class="string">"%ld\n"</span>,<span class="built_in">CFGetRetainCount</span>(array2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用完毕,手动release,否则内存泄漏</span></span><br><span class="line"><span class="built_in">CFRelease</span>((array2));</span><br></pre></td></tr></table></figure><h2 id="七-简单介绍block"><a href="#七-简单介绍block" class="headerlink" title="七.简单介绍block"></a>七.简单介绍block</h2><p>block是能持有作用域变量的匿名函数，本质上是Objective-C对象。<br>语法格式:<code>^ 返回值类型 参数列表 表达式</code>,其中返回值类型可省略，无参数时参数列表可省略。<br>声明block与声明函数指针类似，执行block与调用函数类似。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值类型 (*f) 参数类型</span></span><br><span class="line"><span class="keyword">int</span> (*f)(<span class="keyword">int</span>) = &amp;<span class="function"><span class="keyword">func</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 声明<span class="title">block</span></span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(^blk)</span><span class="params">(<span class="keyword">int</span>)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 赋值</span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(^blk2)</span><span class="params">(<span class="keyword">int</span>)</span> = ^<span class="params">(<span class="keyword">int</span> a)</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 起别名</span></span><br><span class="line">typedef <span class="keyword">int</span> (^block) (<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h3 id="block的三种类型"><a href="#block的三种类型" class="headerlink" title="block的三种类型"></a>block的三种类型</h3><ol><li>如果block没有访问外部的局部变量，或者访问的局部变量被static修饰，block存储在静态区，是NSConcreteGlobalBlock。</li><li>其他情况下，语法生成的block存放在栈中，是NSConcreteStackBlock。</li><li>当把栈中的block复制到堆上时，是NSConcreteMallocBlock。</li></ol><h3 id="block复制到堆上的情况"><a href="#block复制到堆上的情况" class="headerlink" title="block复制到堆上的情况"></a>block复制到堆上的情况</h3><p>大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上，只有当 block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；</p><p>编译器或者方法内部已经实现copy代码的情况:</p><ol><li>block作为函数返回值</li><li>赋值给 __strong id 类型的对象或 block 的成员变量</li><li>Cocoa框架方法名含有usingBlock</li><li>GCD中的API</li></ol><p>其他情况需要手动复制:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 程序异常:栈上的block被废弃 </span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">void</span>(^block) (<span class="keyword">void</span>);</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">id</span>)getBlockArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSArray</span> alloc] initWithObjects:</span><br><span class="line">            ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk0:%d"</span>, val);&#125;,</span><br><span class="line">            ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk1:%d"</span>, val);&#125;, <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    block b = [<span class="keyword">self</span> getBlockArray][<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    b();</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手动将block 复制到堆上:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^block) (<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)getBlockArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSArray</span> alloc] initWithObjects:</span><br><span class="line">            [^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk0:%d"</span>, val);&#125; <span class="keyword">copy</span>],</span><br><span class="line">            [^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk1:%d"</span>, val);&#125; <span class="keyword">copy</span>], <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    block b = [<span class="keyword">self</span> getBlockArray][<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    b();</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block捕获变量"><a href="#block捕获变量" class="headerlink" title="block捕获变量"></a>block捕获变量</h3><p><strong>1.对于实例变量、静态全局变量、静态局部变量，全局变量，无论其为基本类型还是对象类型，在block中可读可写。</strong></p><p>定义在函数内部的变量称为局部变量（Local Variable）。<br>在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域默认是整个程序，也就是所有的源文件。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> globalAge = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *globalName = <span class="string">@"Aaren"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">NSInteger</span> age = <span class="number">12</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态局部变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSInteger</span> staticAge = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *staticName = <span class="string">@"Bob"</span>;</span><br><span class="line"></span><br><span class="line">    YAUser *user = [[YAUser alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^func)() = ^() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改实例变量</span></span><br><span class="line">        user.age = <span class="number">18</span>;</span><br><span class="line">        user.name = <span class="string">@"Jack"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,user.age);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,user.name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改静态局部变量</span></span><br><span class="line">        staticAge = <span class="number">22</span>;</span><br><span class="line">        staticName = <span class="string">@"Lucy"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,staticAge);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,staticName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改静态全局变量</span></span><br><span class="line">        globalAge = <span class="number">14</span>;</span><br><span class="line">        globalName = <span class="string">@"Allen"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,globalAge);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,globalName);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    func();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,user.age);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,user.name);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,staticAge);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,staticName);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,globalAge);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,globalName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>2.对于局部变量，无论其是基本类型还是对象类型，在block中为只读，当使用<strong>block修饰时，变量可读可写。</strong>block修饰的对象类型变量，在ARC环境下，block对其强引用。在非ARC环境下，block不会对其retain。</strong></p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">     __block <span class="built_in">NSInteger</span> age = <span class="number">17</span>;</span><br><span class="line">     __block <span class="built_in">NSString</span> *name = <span class="string">@"Bob"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (^func)() = ^() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改局部变量</span></span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">        name = <span class="string">@"Jack"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,age);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,name);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    func();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改局部变量</span></span><br><span class="line">    age = <span class="number">22</span>;</span><br><span class="line">    name = <span class="string">@"Aaren"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,age);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block的循环引用"><a href="#block的循环引用" class="headerlink" title="block的循环引用"></a>block的循环引用</h3><p>Capturing ‘self’ strongly in this block is likely to lead to a retain cycle.</p><p>.h文件</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YAUser </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) NSObject *object;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">func</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>.m文件</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^block) ();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAUser</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    block _block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAUser</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)func &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环引用</span></span><br><span class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    _block = ^() &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.object);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    _block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>由于block语法赋值给了成员变量，所以在栈上生成的block被复制到堆上。而block强引用了self的成员变量object，实际上是持有了self，self持有block的同时block持有self，于是self和block循环引用。</p><p><img src="http://static.chenyalun.com/2017/04/13/20170413003.png" alt=""><br>解决方案一:采用__weak修饰。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)func &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// __weak解决循环引用</span></span><br><span class="line">    <span class="keyword">self</span>.name = <span class="string">@"Aaren"</span>;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">NSString</span> *weakName = <span class="keyword">self</span>.name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---此时weakName和self.name是同一个变量</span></span><br><span class="line"></span><br><span class="line">    _block = ^() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,weakName);</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    _block();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---此时weakName和self.name是同一个变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.name = <span class="string">@"Jack"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ---此时weakName和self.name不是同一个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果依然是@"Aaren"</span></span><br><span class="line">    _block();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)func &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// __weak解决循环引用</span></span><br><span class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明了一个self类型的weak指针，名字叫做weakSelf.</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    _block = ^() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,weakSelf.object);</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    _block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改一方的强引用为弱引用打破了循环引用。但是有瑕疵:block内部可能捕获到空值。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)func &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// __weak解决循环引用</span></span><br><span class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _block = ^() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 现在立即使用weakSelf.object</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,weakSelf.object);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要异步执行,但是却无法保证weakSelf.object一定存在</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,weakSelf.object);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用block</span></span><br><span class="line">    _block();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自以为block调用完毕,不再需要self.object的值了,大胆地将self.object改为其他值</span></span><br><span class="line">    <span class="keyword">self</span>.object = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况就造成block内部正在使用持有变量的时候，变量的值却意外地改变了，甚至为nil，极易引发问题。<br>最佳方案:弱引用加强引用:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)func &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// __weak解决循环引用</span></span><br><span class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    _block = ^() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// __strong可以不加,默认为__strong,但最好加上,更醒目</span></span><br><span class="line">        __<span class="keyword">strong</span> <span class="built_in">NSObject</span> *strongObject = weakSelf.object;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最好加上判断,保证strongObject不为空</span></span><br><span class="line">        <span class="keyword">if</span> (strongObject) &#123;</span><br><span class="line">            <span class="comment">// 现在立即使用weakSelf.object</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strongObject);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 需要异步执行,可以保证weakSelf.object的值不改变</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strongObject);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用block</span></span><br><span class="line">    _block();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放心地将self.object改为其他值</span></span><br><span class="line">    <span class="keyword">self</span>.object = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做可以保证在block执行期间持有的变量不改变。但如果在block执行之前该变量已经为nil，那回天乏力。</p><p><strong>评价:</strong><br>这种方式不会造成循环引用:block弱引用的方式持有self.object，即不会影响self.object的释放。在block中是通过<strong>局部变量</strong>强引用self.object，作用域结束，局部变量销毁，不再强引用，从此你我是路人。</p><p><strong>注意事项:</strong><br>1.除了使用typeof()之外，还可以直接声明与self相同类型的变量，但依然需要使用__weak修饰。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> YAUser *weakSelf = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure><p>2.循环引用的本质是block强引用了self。但是如果以 以上代码为例:block持有了self的成员变量，完全可以通过以下方式解决。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)func &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环引用</span></span><br><span class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSObject</span> *weakObject = <span class="keyword">self</span>.object;</span><br><span class="line">    </span><br><span class="line">    _block = ^() &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,weakObject);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    _block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.如果可以放宽要求，那么不把block设置为成员变量、把block中调用的代码抽取出来等都可以解决循环引用。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)func &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环引用</span></span><br><span class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    _block = ^() &#123;</span><br><span class="line">        [weakSelf log];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    _block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把方法抽取出来</span></span><br><span class="line">- (<span class="keyword">void</span>)log &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用场景:</strong><br>不需要对block中持有的变量进行写入操作，也即仅仅读取变量。<br>当block异步使用持有的变量时，注意弱引用+强引用配合使用。<br>建议统一采用 <code>typeof(self) + 弱引用 + 强引用的形式</code>。</p><p>解决方案二:采用__block修饰。</p><p>产生循环引用的代码:</p><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>func &#123;</span><br><span class="line"></span><br><span class="line">    // 循环引用</span><br><span class="line">    _block = ^<span class="params">()</span> &#123;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"%p"</span>,self)</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>execBlock &#123;</span><br><span class="line">    _block<span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决循环引用:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)func &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决循环引用</span></span><br><span class="line">    __block <span class="keyword">id</span> tmp = <span class="keyword">self</span>;</span><br><span class="line">    _block = ^() &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>,tmp);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关键所在</span></span><br><span class="line">        tmp = <span class="literal">nil</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)execBlock &#123;</span><br><span class="line">    _block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>评价:</strong><br><strong>block本身不能解决循环引用，关键在于 在block中将</strong>block修饰的变量置为空。<br>当需要对持有的变量进行写入操作时可以使用。</p><p><strong>注意事项:</strong><br><strong>block必须执行</strong>，否则仍然不会解决循环引用。如下面代码:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)func &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决循环引用</span></span><br><span class="line">    __block <span class="keyword">id</span> tmp = <span class="keyword">self</span>;</span><br><span class="line">    _block = ^() &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>,tmp);</span><br><span class="line">        tmp = <span class="literal">nil</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)execBlock &#123;</span><br><span class="line">    <span class="comment">// block没有执行,扔不能解决循环引用</span></span><br><span class="line">    <span class="comment">// _block();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么block没有执行就无法解决循环引用呢?</strong><br>在block中出现tmp的那刻起，block就已经持有了self，即产生了循环引用，如:</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">_block</span> = ^() &#123;tmp;&#125;;</span><br></pre></td></tr></table></figure><p>而只有通过执行block才能把nil赋给tmp，才能打破循环引用。因此，执行block的目的是把nil赋予tmp，而把nil赋予tmp便能解决循环引用的原因是打破了self对block的强引用(self已经不存在了)。</p><h2 id="八-简要介绍GCD常用API"><a href="#八-简要介绍GCD常用API" class="headerlink" title="八.简要介绍GCD常用API"></a>八.简要介绍GCD常用API</h2><h3 id="1-dispatch-async与dispatch-sync"><a href="#1-dispatch-async与dispatch-sync" class="headerlink" title="1.dispatch_async与dispatch_sync"></a>1.dispatch_async与dispatch_sync</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步执行</span></span><br><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步执行dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;);</span></span><br></pre></td></tr></table></figure><h3 id="2-dispatch-queue-t"><a href="#2-dispatch-queue-t" class="headerlink" title="2.dispatch_queue_t"></a>2.dispatch_queue_t</h3><p>使用系统提供的queue</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主队列:串行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局队列:并行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> globalQueue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> globalQueue2 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> globalQueue3 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> globalQueue4 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>自己创建queue</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般指定这两种类型</span></span><br><span class="line"><span class="comment">// DISPATCH_QUEUE_SERIAL</span></span><br><span class="line"><span class="comment">// DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.chenyalun.gcd.createQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(createQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"  "</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If your deployment target is iOS 6.0 or Mac OS X 10.8 or later</span></span><br><span class="line"><span class="comment">//dispatch_release(createQueue);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定创建的队列与globalQueue享有同一优先级</span></span><br><span class="line"><span class="comment">// 不可指定系统的队列</span></span><br><span class="line">dispatch_set_target_queue(createQueue, globalQueue);</span><br></pre></td></tr></table></figure><p>注意:</p><ol><li>现在适配的版本一般大于iOS6,因此不必也不能对自己创建的queue进行dispatch_release，不会造成内存泄漏。</li><li>自己创建的队列严格按照格式来，尤其是作为第一个参数的queue的名称:”com.chenyalun.gcd.createQueue”</li><li>第二个参数设置为NULL，则为串行队列。specify DISPATCH_QUEUE_SERIAL (or NULL) to create a serial queue or specify DISPATCH_QUEUE_CONCURRENT to create a concurrent queue. In earlier versions, you must specify NULL for this parameter.</li></ol><h3 id="3-dispatch-resume-dispatch-suspend"><a href="#3-dispatch-resume-dispatch-suspend" class="headerlink" title="3.dispatch_resume/dispatch_suspend"></a>3.dispatch_resume/dispatch_suspend</h3><p>队列的挂起与恢复</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 全局队列:并行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"你在何方 眼看天亮"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂起</span></span><br><span class="line">dispatch_suspend(globalQueue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"都怪这夜色 撩人的疯狂"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复执行</span></span><br><span class="line">dispatch_resume(globalQueue);</span><br></pre></td></tr></table></figure><h3 id="4-dispatch-apply"><a href="#4-dispatch-apply" class="headerlink" title="4.dispatch_apply"></a>4.dispatch_apply</h3><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 指定迭代的次数</span><br><span class="line">NSArray <span class="symbol">*</span>array = <span class="meta">@[</span><span class="meta">@1,</span> <span class="meta">@2,</span> <span class="meta">@3,</span> <span class="meta">@4,</span> <span class="meta">@5,</span> <span class="meta">@6,</span> <span class="meta">@7];</span></span><br><span class="line">dispatch_apply(array.count, globalQueue, ^(size_t index) &#123;</span><br><span class="line">    NSLog(<span class="meta">@"%</span><span class="meta">@",</span> [array objectAtIndex:index]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-dispatch-group"><a href="#5-dispatch-group" class="headerlink" title="5.dispatch_group"></a>5.dispatch_group</h3><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"这夜的风儿吹"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"我要 美丽的衣裳"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"为你 对镜贴花黄"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 保证以上三个任务执行完毕再执行下面的任务</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"这夜色太紧张"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"这夜的风儿吹"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"我要 美丽的衣裳"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"为你 对镜贴花黄"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证以上三个任务执行完毕再执行下面的任务</span></span><br><span class="line"><span class="comment">// DISPATCH_TIME_NOW 不等待</span></span><br><span class="line"><span class="comment">// DISPATCH_TIME_FOREVER 永久等待</span></span><br><span class="line">NSInteger result = dispatch_group_wait(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// group中的任务全部执行完毕</span></span><br><span class="line">    NSLog(@<span class="string">"这夜色太紧张"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 任务没有执行完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-dispatch-barrier"><a href="#6-dispatch-barrier" class="headerlink" title="6.dispatch_barrier"></a>6.dispatch_barrier</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一个任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二个任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 栅栏函数</span></span><br><span class="line">dispatch_barrier_async(globalQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"英雄之所以被称为英雄，可能只是第一枪打中了而已。"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第四个任务。"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第五个任务"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-dispatch-once"><a href="#7-dispatch-once" class="headerlink" title="7.dispatch_once"></a>7.dispatch_once</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typedef long dispatch_once_t;</span></span><br><span class="line"><span class="comment">// static long onceToken;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"仅仅执行一次"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8-dispatch-after"><a href="#8-dispatch-after" class="headerlink" title="8.dispatch_after"></a>8.dispatch_after</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, </span>(int64_t)(<span class="number">3</span>.<span class="number">0</span> * NSEC_PER_SEC)), <span class="keyword">dispatch_get_main_queue(), </span>^&#123;</span><br><span class="line">        NSLog(@<span class="string">"你在何方 眼看天亮"</span>)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>指定3秒之后把要执行的任务追加到主队列中。最早3.0秒后执行，最迟3+1/60秒后执行，若主线程有延迟，时间会更长。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// DISPATCH_TIME_NOW</span></span><br><span class="line"><span class="comment">// DISPATCH_TIME_FOREVER</span></span><br><span class="line"><span class="comment">// 时间的单位为毫微秒</span></span><br><span class="line"><span class="keyword">dispatch_time_t</span> time = dispatch_time(DISPATCH_TIME_FOREVER, <span class="number">3000000</span>);</span><br></pre></td></tr></table></figure><h3 id="7-dispatch-semaphore"><a href="#7-dispatch-semaphore" class="headerlink" title="7.dispatch_semaphore"></a>7.dispatch_semaphore</h3><p>更细粒度的排他控制<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局队列:并行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置信号量为1,也即保证同时访问的数量为1</span></span><br><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">NSMutableArray *<span class="built_in">array</span> = [NSMutableArray <span class="built_in">array</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代添加对象</span></span><br><span class="line">dispatch_apply(<span class="number">100</span>, globalQueue, ^(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="comment">// 将要添加元素前一直等待信号量为1</span></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放心地给数组添加元素</span></span><br><span class="line">    [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:(<span class="keyword">int</span>)index]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加完成后释放信号量</span></span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 关于ARC/Block/GCD。 &lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>读《SQL必知必会》</title>
    <link href="http://blog.chenyalun.com/2017/04/09/%E8%AF%BB%E3%80%8ASQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"/>
    <id>http://blog.chenyalun.com/2017/04/09/读《SQL必知必会》/</id>
    <published>2017-04-09T09:28:14.000Z</published>
    <updated>2017-04-09T09:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 关于SQLite数据库。 </p><a id="more"></a><p>采用 SQLite 数据库<br>所有命令都敲了一遍，没毛病。</p><h1 id="一、提要"><a href="#一、提要" class="headerlink" title="一、提要"></a>一、提要</h1><h2 id="1-语言"><a href="#1-语言" class="headerlink" title="1.语言"></a>1.语言</h2><ol><li><p>数据定义语言<br>CREATE 创建表/视图/其他对象<br>ALTER 修改对象<br>DROP 删除表/视图/其他对象</p></li><li><p>数据操纵语言<br>SELECT 检索数据<br>INSERT 创建记录<br>UPDATE 修改记录<br>DELETE 删除记录</p></li><li><p>数据控制语言<br>GRANT 赋予用户特权<br>REVOKE 收回用户特权</p></li></ol><h2 id="2-概念"><a href="#2-概念" class="headerlink" title="2.概念"></a>2.概念</h2><p>表:某种特定类型数据的结构化清单<br>字段:限定数据中的列(名)<br>记录:水平排列的数据的实体<br>列:表中的一个字段<br>模式:数据库和表的布局及特性<br>NULL值:表中以空白形式出现的值，表示没有设值<br>主键值:不重复，不为空，不能修改，不能重用</p><h2 id="3-类型"><a href="#3-类型" class="headerlink" title="3.类型"></a>3.类型</h2><p>SQLite无类型，在表声明中明确了字段类型，仍然可以在该字段中存储其它类型的数据。</p><p>NULL: 表示该值为NULL值。<br>INTEGER: 无符号整型值。<br>REAL: 浮点值。<br>TEXT: 文本字符串，存储使用的编码方式为UTF-8、UTF-16BE、UTF-16LE。<br>BLOB: 存储Blob数据，该类型数据和输入数据完全相同。<br>布尔数据类型：SQLite并没有提供专门的布尔存储类型，取而代之的是存储整型1表示true，0表示false。<br>日期和时间数据类型：以TEXT、REAL和INTEGER类型分别不同的格式表示该类型，如：</p><pre><code>TEXT: &quot;YYYY-MM-DD HH:MM:SS.SSS&quot;REAL: 以Julian日期格式存储INTEGER: 以Unix时间形式保存数据值，即从1970-01-01 00:00:00到当前时间所流经的秒数。</code></pre><h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h2><ol><li>正行注释 <code># 注释内容</code></li><li>多行注释 <code>/* 注释内容  */</code></li><li>行尾注释 <code>--注释内容</code></li></ol><h2 id="5-提示"><a href="#5-提示" class="headerlink" title="5.提示"></a>5.提示</h2><ol><li>多条语句必须以分号分隔。</li><li>SQL语句不区分大小写。</li><li>空格会被忽略，可以写成多行。</li></ol><h2 id="6-约束"><a href="#6-约束" class="headerlink" title="6.约束"></a>6.约束</h2><ol><li><p>NOT NULL:非空约束，不能有NULL值。</p><pre><code>ID INTEGER NOT NULL</code></pre></li><li><p>DEFAULT:默认值，数据未指定的默认值，如默认时间:<code>date(&#39;now&#39;)</code>。</p><pre><code>SALARY REAL DEFAULT 5000.0</code></pre> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除默认约束</span></span><br><span class="line"><span class="comment">-- 在SQLite中不可用</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> SALARY <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span></span><br></pre></td></tr></table></figure></li><li><p>UNIQUE:唯一,列中所有数据各不相同。</p><pre><code>AGE INTEGER UNIQUE</code></pre></li><li><p>主键:唯一标识数据表中的记录，不为空。</p><pre><code>PRIMARY KEY(ID,name)</code></pre> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加主键(前提列已经声明为非空)</span></span><br><span class="line"><span class="comment">-- 在SQLite中不可用</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">ID</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除主键</span></span><br><span class="line"><span class="comment">-- 在SQLite中不可用</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span></span><br></pre></td></tr></table></figure></li><li><p>外键:唯一标识其他表中的一条记录。</p><pre><code>FOREIGN KEY(name) REFERENCES q(name)</code></pre> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加外键</span></span><br><span class="line"><span class="comment">-- 在SQLite中不可用</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t</span><br><span class="line"><span class="keyword">ADD</span> FOREIGN <span class="keyword">KEY</span> (C_ID) <span class="keyword">REFERENCES</span> <span class="keyword">USER</span> (<span class="keyword">ID</span>)</span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="comment">-- 在SQLite中不可用</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">DROP</span> FOREIGN <span class="keyword">KEY</span></span><br></pre></td></tr></table></figure></li><li><p>CHECK:保证列中所有值满足某一条件。</p><pre><code>AGE INT NOT NULL CHECK(AGE&lt;=18)</code></pre><pre><code>增加CHECK-- 在SQLite中不可用ALTER TABLE tMODIFY AGE INT NOT NULL CHECK(AGE&gt;=18)或者ALTER TABLE tADD CONSTRAINT checkConstraint CHECK(AGE&gt;=18)-- 删除CHECK-- 在SQLite中不可用ALTER TABLE tDROP CONSTRAINT checkConstraint</code></pre></li></ol><h2 id="7-范式"><a href="#7-范式" class="headerlink" title="7.范式"></a>7.范式</h2><p>第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列,如”地址”可以细分为:”省,市”。</p><p>第二范式（2NF）：首先是 1NF，其次一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。</p><p>第三范式（3NF）：首先是 2NF，其次非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8.函数"></a>8.函数</h2><blockquote><p>传送门：<br><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/02/15/2322027.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/02/15/2322027.html</a></p></blockquote><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理:"></a>字符串处理:</h3><p>UPPER() 大写转换<br>LENGTH() 字符串长度<br>LOWER() 小写转换<br>LTRIM() 去掉字符串左边的空格<br>RTRIM() 去掉字符串右边的空格</p><h3 id="日期时间处理"><a href="#日期时间处理" class="headerlink" title="日期时间处理"></a>日期时间处理</h3><p>date(‘now’) 返回当前日期。</p><p><code>date(&#39;now&#39;,&#39;start of month&#39;,&#39;1 month&#39;,&#39;-1 day&#39;)</code>返回当前月的最后一天。</p><h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><p>ABS() 绝对值<br>COS() 角度的余弦<br>EXP() 数的指数值<br>PI() 返回圆周率<br>SIN() 角度的正弦值<br>SQRT() 平方根<br>TAN() 角度的正切</p><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>AVG() 平均值,忽略NULL值</p><p>COUNT() 某列的行数,若指定列名则会忽略NULL值,而<code>COUNT(*)</code>对表中行的数目进行计数,无论是否为NULL都计数,DISTINCT不能用于<code>COUNT(*)</code>,如COUNT(DISTINCT *)为错误写法</p><p>MAX() 某列的最大值,忽略NULL值<br>MIN() 某列的最小值,忽略NULL值<br>SUM() 某列值的和,忽略NULL值</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>查看版本</p><pre><code>select sqlite_version();</code></pre><h2 id="9-视图"><a href="#9-视图" class="headerlink" title="9.视图"></a>9.视图</h2><p>视图只不过是通过相关的名称存储在数据库中的一个 SQLite 语句。视图实际上是一个以预定义的 SQLite 查询形式存在的表的组合。</p><p>SQLite仅支持只读视图，所以视图可以创建，可以读，但其内容不能更改。</p><p>视图的作用:<br>视图是一种虚表，允许用户实现以下几点：</p><ul><li><p>用户或用户组查找结构数据的方式更自然或直观。</p></li><li><p>限制数据访问，用户只能看到有限的数据，而不是完整的表。</p></li><li><p>汇总各种表中的数据，用于生成报告。</p></li></ul><h2 id="10-事务"><a href="#10-事务" class="headerlink" title="10.事务"></a>10.事务</h2><p>事务是一个对数据库执行工作单元,是以逻辑顺序完成的工作单位或序列。</p><p>事务是指一个或多个更改数据库的扩展。例如，如果正在创建一个记录或者更新一个记录或者从表中删除一个记录，那么正在该表上执行事务。重要的是要控制事务以确保数据的完整性和处理数据库错误。</p><p>可以把许多的 SQLite 查询联合成一组，把所有这些放在一起作为事务的一部分进行执行。</p><p>事务具有以下四个标准属性，通常根据首字母缩写为 ACID：</p><ul><li><p>Atomicity（原子性）原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p></li><li><p>Consistency（一致性）一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 </p></li><li><p>Isolation（隔离性）多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p></li><li><p>Durability（持久性）持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p></li></ul><p>撤销<br>ROLLBACK 命令是用于撤消尚未保存到数据库的事务的事务命令。<br>ROLLBACK 命令只能用于撤销自上次发出 COMMIT 或 ROLLBACK 命令以来的事务。</p><pre><code>BEGIN TRANSACTION;DELETE FROM t WHERE ID = 6;ROLLBACK;</code></pre><p>提交</p><pre><code>BEGIN TRANSACTION;DELETE FROM t WHERE ID = 5;-- 要做的事END TRANSACTION;-- 或者使用以下语法BEGIN;DELETE FROM t WHERE ID = 6;COMMIt;</code></pre><p><strong>注意:保存点在 SQLite (≥ 3.6.8)支持</strong><br>保留点,保留点越多越好</p><pre><code>SAVEPOINT delRow;  ROLLBACK TO delRow;  </code></pre><h2 id="11-索引"><a href="#11-索引" class="headerlink" title="11.索引"></a>11.索引</h2><p>索引是一种特殊的查找表，数据库搜索引擎用来加快数据检索，简单地说，索引是一个指向表中数据的指针。</p><pre><code>创建索引CREATE INDEX in_name_age ON t(name, age);删除索引DROP INDEX in_name;</code></pre><h2 id="12-顺序"><a href="#12-顺序" class="headerlink" title="12.顺序"></a>12.顺序</h2><table><thead><tr><th>子句</th><th>说明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>返回列</td><td>是</td></tr><tr><td>FROM</td><td>检索的表</td><td>从表中选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组</td><td>按组计算聚集时使用</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序</td><td>否</td></tr></tbody></table><p>妙记:</p><pre><code>SELECT kindID, COUNT(*)FROM tableWHERE PRICE &gt; 10GROUP BY kindIDHAVING COUNT(*) &gt;=2ORDER BY kindID;</code></pre><h1 id="二、命令"><a href="#二、命令" class="headerlink" title="二、命令"></a>二、命令</h1><h2 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1.SELECT"></a>1.SELECT</h2><p>检索单个列</p><pre><code>-- SELECT 列名 FROM 表名SELECT age FROM t;</code></pre><p>检索多个列</p><pre><code>SELECT name, age, groupID FROM t;</code></pre><p>检索所有列</p><pre><code>SELECT * FROM t;-- 检索不必要的列会降低检索和应用程序的性能</code></pre><p>检索并返回不同的值</p><pre><code>SELECT DISTINCT name, age FROM t;-- DISTINCT作用于所有的列,如SELECT DISTINCT groupID, age FROM t;-- 作用于groupID, age两列-- 当groupID, age双双重复,只会返回一个结果</code></pre><p>限制结果</p><pre><code>-- 不超过5行SELECT  name, age FROM t LIMIT 5;-- 从第10行开始检索,不超过7行SELECT  name, age FROM t LIMIT 5 OFFSET 3;</code></pre><p>1.LIMIT限制返回的行数，OFFSET指定从哪开始。<br>2.行数指的是索引行，即从第0行开始。</p><h2 id="2-ORDEY-BY"><a href="#2-ORDEY-BY" class="headerlink" title="2.ORDEY BY"></a>2.ORDEY BY</h2><p>ORDEY BY子句要保证放到最后</p><p>单个列排序</p><pre><code>-- 以age值的字母顺序/大小排列SELECT  name FROM t ORDER BY age;</code></pre><p>多个列排序</p><pre><code>-- 首先按照age,在age中按照nameSELECT  name, age FROM t ORDER BY age, name;</code></pre><p>按列位置排序</p><pre><code>-- 首先按照age,在age中按照name-- 3对应age, 1对应IDSELECT ID, name, age FROM t ORDER BY 3, 1;</code></pre><p>按降序排序</p><pre><code>-- DESC 只作用在它前面的列SELECT ID, name, age FROM t ORDER BY 3 DESC;SELECT ID, name, age FROM t ORDER BY 1 DESC,3 DESC;</code></pre><h2 id="3-WHERE"><a href="#3-WHERE" class="headerlink" title="3.WHERE"></a>3.WHERE</h2><p>常用操作符:<br>一般:=  !  =  &lt;  &gt;   &gt;=  &lt;=<br>介于之间:BETWEEN AND<br>为空值:IS NULL</p><p>一般使用</p><pre><code>SELECT age, name FROM table WHERE age &lt; 10;-- 单引号用来限定字符串-- 将值与字符串类型的列比较需要限定引号-- 将值与数值列进行比较不用引号SELECT ID, name, age FROM t WHERE age = 18;SELECT ID, name, age FROM t WHERE name = &apos;张无忌&apos;;</code></pre><p>范围筛选</p><pre><code>SELECT ID, name, age FROM t WHERE age BETWEEN 18 AND 22;</code></pre><p>空值检查</p><pre><code>SELECT ID, name, age FROM t WHERE sex IS NULL;</code></pre><h2 id="4-AND-OR"><a href="#4-AND-OR" class="headerlink" title="4.AND OR"></a>4.AND OR</h2><p>AND 优先级大于OR<br>组合使用注意加括号</p><pre><code>SELECT ID, name, age FROM t WHERE age = 18 AND name = &apos;唐僧&apos;;SELECT ID, name, age FROM t WHERE age = 18 OR groupID = 1;</code></pre><p>组合使用</p><pre><code>SELECT ID, name, age FROM t WHERE (age = 18 OR ID &lt; 12) AND groupID = 1;</code></pre><h2 id="5-IN"><a href="#5-IN" class="headerlink" title="5.IN"></a>5.IN</h2><p>关键字匹配</p><pre><code>-- 18,19岁SELECT ID, name, age FROM t WHERE age IN (18, 19);</code></pre><h2 id="6-NOT"><a href="#6-NOT" class="headerlink" title="6.NOT"></a>6.NOT</h2><p>否定其后的限定条件</p><pre><code>SELECT ID, name, age FROM t WHERE age NOT IN (18, 19);SELECT ID, name, age FROM t WHERE NOT age &lt; 22;</code></pre><h2 id="7-LIKE"><a href="#7-LIKE" class="headerlink" title="7.LIKE"></a>7.LIKE</h2><p>% 通配符<br>表示任何字符出现任意次数,不会匹配NULL</p><pre><code>SELECT ID, name, age FROM t WHERE name LIKE &apos;张%&apos;;SELECT ID, name, age FROM t WHERE name LIKE &apos;%六&apos;;</code></pre><p>_ 通配符<br>匹配单个字符,注意LIKE后的值使用字符串</p><pre><code>SELECT ID, name, age FROM t WHERE age LIKE &apos;2_&apos;;</code></pre><p><strong>注意:SQLite 不支持[] 通配符</strong><br><del>[] 通配符<br>指定一系列的字符,只要满足这些字符其中之一,且位置出现在“[]”通配符的位置的字符串就满足查询条件</del></p><pre><code>SELECT ID, name, age FROM t WHERE name LIKE &apos;[牛]%&apos;;-- 否定SELECT ID, name, age FROM t WHERE name LIKE &apos;[^牛]%&apos;;</code></pre><p>注意:少使用通配符,尽量不要把通配符置于开始处</p><h2 id="8-拼接"><a href="#8-拼接" class="headerlink" title="8.拼接"></a>8.拼接</h2><p>使用 || 拼接多个列</p><pre><code>SELECT age || &apos;(&apos; || name || &apos;)&apos; FROM t;-- 结果: 23(牛魔王)</code></pre><p>使用RTRIM去除填充列宽的文本值</p><pre><code>SELECT age || &apos;(&apos; || RTRIM(name) || &apos;)&apos; FROM t;RTRIM() 去掉字符串右边的空格LTRIM() 去掉字符串左边的空格TRIM() 去掉字符串左右两边的空格</code></pre><p>使用别名AS<br>  要求得到的是一列</p><pre><code>SELECT age || &apos;(&apos; || RTRIM(name) || &apos;)&apos;  AS Results FROM t;</code></pre><p>执行计算</p><pre><code>SELECT age + 3, name  FROM t;</code></pre><h2 id="9-GROUP-BY"><a href="#9-GROUP-BY" class="headerlink" title="9.GROUP BY"></a>9.GROUP BY</h2><p>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</p><pre><code>SELECT groupID, COUNT(*)  FROM t GROUP BY groupID;/* 含有COUNT(*)的分组的结果不该包含每列独有的字段,如name,ID等, 而应该是共性的字段,如分组ID等,因为目的是得知某组的COUNT */SELECT name FROM t GROUP BY name;</code></pre><h2 id="10-HAVING"><a href="#10-HAVING" class="headerlink" title="10.HAVING"></a>10.HAVING</h2><p>1.WHERE过滤行，而HAVING过滤分组,HAVING支持所有WHERE操作符<br>2.WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤</p><pre><code>SELECT groupID, COUNT(*)  FROM t GROUP BY groupID HAVING COUNT(*) &gt; 5;-- 筛选每组数量大于5</code></pre><h2 id="11-ORDER-BY"><a href="#11-ORDER-BY" class="headerlink" title="11.ORDER BY"></a>11.ORDER BY</h2><p>排序<br>HAVING常与GROUP BY连用</p><pre><code>SELECT groupID, COUNT(*)  FROM t WHERE age &gt; 18  GROUP BY groupID HAVING COUNT(*) &gt; 2ORDER BY groupID DESC;</code></pre><h2 id="12-子查询"><a href="#12-子查询" class="headerlink" title="12.子查询"></a>12.子查询</h2><p>在SELECT语句中，子查询总是从内向外处理。<br>作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误。</p><pre><code>SELECT name, age FROM t WHERE age IN (SELECT age FROM t WHERE age &gt; 10 AND sex IS NULL);</code></pre><h2 id="13-连接"><a href="#13-连接" class="headerlink" title="13.连接"></a>13.连接</h2><p>内连接是据根据每个表共有的列的值匹配两个表中的行</p><pre><code>SELECT t.name, age FROM t INNER JOIN q ON t.ID = q.ID;SELECT t.name, t.age FROM t, q WHERE t.name = q.name; -- 注意表的名称要匹配</code></pre><p>自连接,查询中需要的两个表实际上是相同的表</p><pre><code>SELECT a.name, a.age FROM t AS a, t AS b WHERE a.name = b.name AND b.ID = 10;</code></pre><p>外连接<br>1.外连接可以是左向外连接、右向外连接或完整外部连接<br>2.在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表(RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表)。<br>3.左向外连接的结果集包括LEFT  OUTER子句中指定的左表的所有行，而不仅仅是连接列所匹配的行。<br>4.右向外连接是左向外连接的反向连接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。   </p><p>SQLite支持左外连接LEFT OUTER JOIN，但不支持RIGHT OUTER JOIN 和 FULL OUTER JOIN语法。</p><pre><code>SELECT t.*, q.*  FROM t LEFt JOIN q ON t.ID = q.ID;   </code></pre><p>交叉连接。交叉连接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉连接也称作笛卡尔积。 </p><p>总结:<br>左外连接显示左表所有行+匹配行<br>右外连接显示右表所有行+匹配行<br>完整外部连接显示左表和右表中的所有行<br>内连接显示根据比较运算符匹配两个表中的行<br>自连接需要的两个表实际上是相同的表<br>交叉连接显示左表所有行+左表每一行与右表所有行的组合<br>连接不匹配时显示空值</p><h2 id="14-UNION"><a href="#14-UNION" class="headerlink" title="14.UNION"></a>14.UNION</h2><p>将结果组合成一个结果集<br>1.UNION中的每个查询必须包含相同的列、表达式或聚集函数<br>2.UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔<br>3.列数据类型必须兼容</p><pre><code>SELECT name, age FROM t WHERE name LIKE &apos;张%&apos; UNION SELECT name, age FROM t WHERE age &gt; 22;-- 相当于 &quot;并&quot;在一起</code></pre><h2 id="15-INSERT"><a href="#15-INSERT" class="headerlink" title="15.INSERT"></a>15.INSERT</h2><p>插入记录</p><pre><code>INSERT INTO t VALUES(13,      &apos;白骨精&apos;,      &apos;1543&apos;,      1,      NULL,      19,      1.68);INSERT INTOt(ID, name, phone, groupID, sex, age, height) VALUES(14, &apos;白龙马&apos;, &apos;1323&apos;, 0, NULL, 20, 1.69);</code></pre><p>VALUES必须以其指定的次序匹配指定的列名,更推荐这种方式<br>省略列:允许NULL或者有默认值</p><h2 id="16-CREATE-AS"><a href="#16-CREATE-AS" class="headerlink" title="16.CREATE AS"></a>16.CREATE AS</h2><p>复制表</p><pre><code>CREATE TABLE c AS SELECT * FROM t;</code></pre><h2 id="17-UPDATE"><a href="#17-UPDATE" class="headerlink" title="17.UPDATE"></a>17.UPDATE</h2><p>更新行</p><pre><code>UPDATE t SET height = 1.66 WHERE name = &apos;白龙马&apos;;-- 删除某列的值UPDATE t SET height = NULL  WHERE name = &apos;韦小宝&apos;;    </code></pre><p>更新多列,注意逗号</p><pre><code>UPDATE t SET height = 1.55, phone = &apos;1888&apos;, groupID = 0  WHERE name = &apos;唐僧&apos;;</code></pre><h2 id="18-DELETE"><a href="#18-DELETE" class="headerlink" title="18.DELETE"></a>18.DELETE</h2><p>删除行</p><pre><code>DELETE FROM t WHERE name = &apos;白龙马&apos;;</code></pre><h2 id="19-CREATE"><a href="#19-CREATE" class="headerlink" title="19.CREATE"></a>19.CREATE</h2><p>创建表</p><pre><code>CREATE TABLE d(ID INTEGER NOT NULL UNIQUE,name TEXT NOT NULL,sex INTEGER DEFAULT 0,height REAL CHECK(height &gt; 0),PRIMARY KEY(&apos;ID&apos;)FOREIGN KEY(name) REFERENCES q(name));</code></pre><p>主键单独标明。</p><h2 id="20-ALTER"><a href="#20-ALTER" class="headerlink" title="20.ALTER"></a>20.ALTER</h2><p>给表增加一列</p><pre><code>ALTER TABLE bADD place TEXT;    </code></pre><p>重命名表</p><pre><code>ALTER TABLE bRENAME TO bbb;</code></pre><p>在 SQLite 中，除了重命名表和在已有的表中添加列，ALTER TABLE 命令不支持其他操作,包括删除列,定义主键和外键等.</p><p>SQLite不支持删除列</p><pre><code>ALTER TABLE t DROP COLUMN vend_phone;</code></pre><h2 id="21-DROP"><a href="#21-DROP" class="headerlink" title="21.DROP"></a>21.DROP</h2><p>删除表</p><pre><code>DROP TABLE t;</code></pre><h2 id="22-视图"><a href="#22-视图" class="headerlink" title="22.视图"></a>22.视图</h2><p>创建视图</p><pre><code>CREATE VIEW view_b AS SELECT name, age FROM t;</code></pre><p>查看视图</p><pre><code>SELECT * FROM view_b;</code></pre><p>删除视图</p><pre><code>DROP VIEW view_b;</code></pre><blockquote><p>参考感谢：<br><a href="http://zhiwei.li/text/2010/08/23/sqlite%E5%A4%96%E9%94%AE/" target="_blank" rel="noopener">http://zhiwei.li/text/2010/08/23/sqlite%E5%A4%96%E9%94%AE/</a><br><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/02/22/2325258.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/02/22/2325258.html</a><br><a href="http://www.runoob.com/sqlite/sqlite-syntax.html" target="_blank" rel="noopener">http://www.runoob.com/sqlite/sqlite-syntax.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 关于SQLite数据库。 &lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="数据库" scheme="http://blog.chenyalun.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>读《Effective Objective-C 2.0》</title>
    <link href="http://blog.chenyalun.com/2017/04/05/%E8%AF%BB%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B/"/>
    <id>http://blog.chenyalun.com/2017/04/05/读《Effective Objective-C 2.0》/</id>
    <published>2017-04-05T04:02:17.000Z</published>
    <updated>2017-04-05T05:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 许多小技巧。 </p><a id="more"></a><h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>一晚上加一早上时间读了一遍,很多技巧都屡有耳闻,不过还是收获许多.</p><h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><ol><li>.h文件中使用@class声明类,.m文件中使用import导入其他头文件,而不是只在.h文件中import头文件</li><li>常量使用static const,其他情况(如[NSNotificationCenter defaultCenter])使用宏</li><li>不需要位或运算的枚举使用NS_ENUM,需要使用位或运算的枚举使用NS_OPTIONS,避免C语言中的enum</li><li>switch状态机下避免default分支(确保switch正确处理已知情况,往后增加新的的枚举值会有警告)</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="1-属性声明为-dynamic后该怎么做"><a href="#1-属性声明为-dynamic后该怎么做" class="headerlink" title="1.属性声明为@dynamic后该怎么做"></a>1.属性声明为@dynamic后该怎么做</h2><p>.h文件暴露属性</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br></pre></td></tr></table></figure><p>.m文件动态添加方法</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAHeader</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAHeader</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加set方法,要传入参数</span></span><br><span class="line"><span class="keyword">void</span> dynamicSetMethodIMP(YAHeader *<span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *prame) &#123;</span><br><span class="line">    <span class="keyword">self</span>-&gt;_name = prame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加get方法,要返回NSString *类型</span></span><br><span class="line"><span class="built_in">NSString</span> *dynamicGetMethodIMP(YAHeader *<span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(setName:)) &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)dynamicSetMethodIMP, <span class="string">"v@:@"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(name)) &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)dynamicGetMethodIMP, <span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>注意:<br>1.按照本书所说,使用@dynamic将仅仅生成get/set方法的声明,不会生成get/set方法的实现,也不会合成成员变量</p><p>2.由于没有合成成员变量,所以手动添加</p><p>3.使用@property但是却没有合成成员变量的情景有:<br>(1):同时使用@property和@dynamic<br>(2):set和get方法均手动实现<br>(3):分类中@property<br>值得一提的是,当使用<code>@synthesize num;</code>时,将不会生成成员变量<code>_num</code>,而是生成成员变量<code>num</code></p><h2 id="2-关联对象中为什么使用static修饰的指针"><a href="#2-关联对象中为什么使用static修饰的指针" class="headerlink" title="2.关联对象中为什么使用static修饰的指针"></a>2.关联对象中为什么使用static修饰的指针</h2><p>static的作用之一便是使变量在内存中只有一份拷贝,由于需要objc_setAssociatedObject和objc_getAssociatedObject中的两个键(void *key)需要匹配同一个值(关联的对象),所以需要两者是完全相同的指针,故而使用静态全局变量做键</p><h2 id="3-简述Objective-C在发送消息时的动态性"><a href="#3-简述Objective-C在发送消息时的动态性" class="headerlink" title="3.简述Objective-C在发送消息时的动态性"></a>3.简述Objective-C在发送消息时的动态性</h2><p>静态绑定:将在运行期间调用的函数在编译期间已经确定<br>动态绑定:发送的消息部分转化为objc_msgSend函数,传入将要调用函数的对象、将要调用的函数以及将要调用的函数的参数,具体调用哪个函数,通过快速映射表、方法列表亦或是消息转发确定<br>objc_msgSend_stret:消息返回结构体调用<br>objc_msgSend_fpret:消息返回浮点数调用<br>objc_msgSendSuper:给超类发送消息调用</p><h2 id="4-如何解决unrecognized-selector-send-to-instance"><a href="#4-如何解决unrecognized-selector-send-to-instance" class="headerlink" title="4.如何解决unrecognized selector send to instance"></a>4.如何解决unrecognized selector send to instance</h2><p>消息转发的三个流程<br>1.对象收到无法识别的消息,根据使类方法还是对象方法调用<br><code>+ (BOOL)resolveInstanceMethod:(SEL)selector</code><br><code>+ (BOOL)resolveClassMethod:(SEL)selector</code><br>前提:相关方法的实现代码已经写好<br>使用:根据类方法还是对象方法,在resolveMethod中为无法响应的selector动态添加方法实现(提供函数指针IMP)<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">class_addMethod(<span class="name">self</span>, selector, (<span class="name">IMP</span>)methodImplemention,<span class="string">"v@:@"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>若没有做出处理,返回NO</p><p>2.倘若没有相关方法实现,进入<br><code>- (id)forwardingTargetForSelector:(SEL)selector</code><br>将消息转发给其他对象,若找不到,返回nil</p><p>3.完整的消息转发,调用对象方法<br><code>- (void)forwardInvocation:(NSInvocation *)invocation</code><br>首先发送-methodSignatureForSelector:获取函数的参数和返回值类型,若返回nil,直接挂掉,否则Runtime创建一个NSIn<br>vocation对象,发送forwardInvocation消息给目标对象</p><h2 id="5-如何实现多重继承"><a href="#5-如何实现多重继承" class="headerlink" title="5.如何实现多重继承"></a>5.如何实现多重继承</h2><p>C类 继承自 A类,想让C类对象同时具备A类方法和 B类方法的能力<br>使C类对象中拥有B类对象(组合),在C类对象中实现对象方法forwardingTargetForSelect:方法,将发送来的B类方法转发给所拥有的B类对象处理</p><h2 id="6-怎么实现方法实现的交换"><a href="#6-怎么实现方法实现的交换" class="headerlink" title="6.怎么实现方法实现的交换"></a>6.怎么实现方法实现的交换</h2><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取通过SEL获取一个方法</span></span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getInstanceMethod</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个方法的实现</span></span><br><span class="line">method<span class="number">_</span>getImplementation</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个OC实现的编码类型</span></span><br><span class="line">method<span class="number">_</span>getTypeEncoding</span><br><span class="line"></span><br><span class="line"><span class="comment">// 給方法添加实现</span></span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>addMethod</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用一个方法的实现替换另一个方法的实现</span></span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>replaceMethod</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个方法的实现</span></span><br><span class="line">method<span class="number">_</span>exchangeImplementations</span><br></pre></td></tr></table></figure><p>获取Method<br><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">Method</span> <span class="title">lowercaseString</span> =</span> class_getInstanceMethod([NSString <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">lowercaseString</span>));</span></span><br><span class="line">    <span class="function"><span class="keyword">Method</span> <span class="title">uppercaseString</span> =</span> class_getInstanceMethod([NSString <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">uppercaseString</span>));</span></span><br><span class="line">    method_exchangeImplementations(lowercaseString, uppercaseString);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>表面上看是死循环:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)lowercaseString &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.lowercaseString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)uppercaseString &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.uppercaseString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-简述为代码加锁的方式"><a href="#7-简述为代码加锁的方式" class="headerlink" title="7.简述为代码加锁的方式"></a>7.简述为代码加锁的方式</h2><p>同步块:</p><pre><code>@synchronized(self) {//...}</code></pre><p>滥用@synchronized(self)很危险,所有的块都会彼此抢夺同一个锁.</p><p>锁对象:<br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">_lock</span> = [[<span class="symbol">NSLock</span> alloc] init];</span><br><span class="line"></span><br><span class="line">[<span class="symbol">_lock</span> lock];</span><br><span class="line">// ...</span><br><span class="line">[<span class="symbol">_lock</span> unlock];</span><br></pre></td></tr></table></figure></p><h2 id="8-原子性一定安全吗-如何确保属性的线程安全"><a href="#8-原子性一定安全吗-如何确保属性的线程安全" class="headerlink" title="8.原子性一定安全吗,如何确保属性的线程安全"></a>8.原子性一定安全吗,如何确保属性的线程安全</h2><p>不一定.<br>原子性能保证存取方法的线程安全,也即读写操作是原子性的,在读或者写发生的时候,其他读或者写操作必须等待.<br>然而同一个线程上多次调用get方法,每一次获取到的值未必相同,多次访问期间,其他线程可能会写入新的值.比如当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全.</p><p>线程安全:不会出现数据不一致或者数据污染。</p><p>使用串行同步队列,将读取以及写入操作都安排在同一个队列中,即可保证数据同步.</p><p>方式一:同步派发(在set方法简单的时候使用)</p><p>.h文件<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br></pre></td></tr></table></figure></p><p>.m文件<br>1.创建串行队列<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAHeader</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> _serialQueue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> label = <span class="string">"label"</span>;</span><br><span class="line"> _serialQueue = dispatch_queue_create(label, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p><p>2.合成属性(由于需要重写get/set方法,编译器已取消自动合成)<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAHeader</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> name = _name;</span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> label = <span class="string">"label"</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_serialQueue, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">   </span><br><span class="line">    __block <span class="built_in">NSString</span> *localName;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_serialQueue, ^&#123;</span><br><span class="line">        localName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> localName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>方式二:异步派发(在set方法复杂的时候使用)<br>改动set方法</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)<span class="built_in">setName</span>:(NSString *)<span class="built_in">name</span> &#123;</span><br><span class="line">    dispatch_async(<span class="variable">_serialQueue</span>, ^&#123;</span><br><span class="line">         <span class="variable">_name</span> = <span class="built_in">name</span>;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// ...(还有许多操作)</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异步派发的时候需要拷贝block,需要消耗一定时间,所以在set方法更复杂的场景下使用</p><h2 id="9-performSelector的局限性有哪些"><a href="#9-performSelector的局限性有哪些" class="headerlink" title="9.performSelector的局限性有哪些"></a>9.performSelector的局限性有哪些</h2><p>1.由于无法确定将要执行的selector具体是什么,ARC无法将其纳入合适的内存管理方法中,可能有内存泄漏<br>2.selector的返回值类型和参数个数、类型受到限制<br>建议使用GCD中的dispatch_async/dispatch_after等代替相应的performSelector</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (void)fetchSelector:(NSInteger)condition &#123;</span><br><span class="line">    <span class="keyword">SEL </span><span class="keyword">selector;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (condition == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">selector </span>= <span class="comment">@selector(dismiss);</span></span><br><span class="line">    &#125; <span class="meta">else</span> <span class="meta">if</span> (condition == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">selector </span>= <span class="comment">@selector(miss:);</span></span><br><span class="line">    &#125; <span class="meta">else</span> &#123;</span><br><span class="line">         <span class="keyword">selector </span>= <span class="comment">@selector(love);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self </span>performSelector:<span class="keyword">selector];</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>警告:/Users/chenyalun/Desktop/iOS/program/Demo170404/Demo170404/YAHeader.m:70:11: PerformSelector may cause a leak because its selector is unknown</p><h2 id="10-bridge、bridge-retained与-bridge-transfer的区别"><a href="#10-bridge、bridge-retained与-bridge-transfer的区别" class="headerlink" title="10.bridge、bridge_retained与__bridge_transfer的区别"></a>10.<strong>bridge、</strong>bridge_retained与__bridge_transfer的区别</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">10</span>, @<span class="number">11</span>, @<span class="number">12</span>];</span><br><span class="line"><span class="built_in">CFArrayRef</span> cfarray = (__bridge <span class="built_in">CFArrayRef</span>)array;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFArrayRef</span> cfarray2 = (__bridge_retained <span class="built_in">CFArrayRef</span>)array;</span><br><span class="line"><span class="built_in">CFRelease</span>(cfarray2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *array2 = (__bridge_transfer <span class="built_in">NSArray</span> *)cfarray;</span><br></pre></td></tr></table></figure><p>__bridge表示ARC仍然具备该对象的所有权</p><p>__bridge_retained表示ARC交出该对象的所有权(需手动release)</p><p>__bridge_transfer:表示反向转换,同时ARC获取对象所有权</p><h2 id="11-NSCache相较NSDictionary的优点"><a href="#11-NSCache相较NSDictionary的优点" class="headerlink" title="11.NSCache相较NSDictionary的优点"></a>11.NSCache相较NSDictionary的优点</h2><p>1.在系统发出低内存通知时,NSCache自动删减缓存,并且先行删减最久未使用的对象<br>2.增加键的引用计数而不是拷贝它<br>3.NSCache线程安全,可以多线程访问而不出错<br>4.NSPurgeableData是NSMutableData的子类,将它与NSCache搭配使用,当NSPurgeableData对象所占内存为系统所丢弃时,该对象自动从NSCache缓存中清除</p><p>访问NSPurgeableData对象</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">NSCache *cache = [[NSCache alloc] init];</span><br><span class="line"></span><br><span class="line">NSPurgeableData *purgeableData = [NSPurgeableData <span class="string">dataWithBytes:</span>@<span class="string">"ILOVEYOU"</span> <span class="string">length:</span><span class="number">10</span>];</span><br><span class="line">[cache <span class="string">setObject:</span>purgeableData <span class="string">forKey:</span>@<span class="number">00</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问NSPurgeableData</span></span><br><span class="line"><span class="keyword">if</span> (purgeableData) &#123;</span><br><span class="line">    <span class="comment">// 开始访问,现在还不应该丢弃自己所占用的内存</span></span><br><span class="line">    [purgeableData beginContentAccess];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [self <span class="string">useData:</span>purgeableData];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束访问,现在可以丢弃自己所占用的内存啦</span></span><br><span class="line">    [purgeableData endContentAccess];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料:</p><blockquote><p>乞力马扎罗的雪的博客:<a href="http://blog.csdn.net/chenyufeng1991/article/details/49687215" target="_blank" rel="noopener"> blog.csdn.net/chenyufeng1991/article/details/49687215</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 许多小技巧。 &lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C提要</title>
    <link href="http://blog.chenyalun.com/2017/04/02/C%E6%8F%90%E8%A6%81/"/>
    <id>http://blog.chenyalun.com/2017/04/02/C提要/</id>
    <published>2017-04-02T03:22:17.000Z</published>
    <updated>2017-05-11T10:19:06.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 不堪回首。 </p><a id="more"></a><p>Java、前端、Android、iOS的笔试题涌现大量C++的内容，我和小伙伴们苦不堪言，于是特意抽大半天时间试着回忆一下。</p><h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><h2 id="1-命名空间如何使用"><a href="#1-命名空间如何使用" class="headerlink" title="1.命名空间如何使用"></a>1.命名空间如何使用</h2><p>防止出现变量或函数的命名冲突.</p><p>在 main() 函数中声明命名空间 std，它的作用范围就位于 main() 函数内部，如果在其他函数中又用到了 std，就需要重新声明</p><p>如果希望在所有函数中都使用命名空间 std，可以将它声明在全局范围中<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">namespace</span> YA &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">// 变量、类、函数、typedef、#define 等都可以出现在命名空间中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式一:域解析操作符</span></span><br><span class="line"><span class="comment">// :是域解析操作符,指明要使用的命名空间</span></span><br><span class="line">YA :: a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式二:针对变量</span></span><br><span class="line"><span class="comment">// 如果以后出现了未指明命名空间的a，就使用YA :: a</span></span><br><span class="line"><span class="keyword">using</span> YA :: a;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式三:针对命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> YA; <span class="comment">// 声明整个命名空间</span></span><br></pre></td></tr></table></figure></p><h2 id="2-C-现行标准库"><a href="#2-C-现行标准库" class="headerlink" title="2.C++现行标准库"></a>2.C++现行标准库</h2><p>对于不带.h的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；<br>对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>C语言的头文件在 C++ 中依然被支持，C++ 新增的库更加强大和灵活,例如 iostream、fstream、string 等</p><p>推荐:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></p><h2 id="3-cin与cout"><a href="#3-cin与cout" class="headerlink" title="3.cin与cout"></a>3.cin与cout</h2><p>cout 和 cin 分别是 ostream 和 istream 类的对象,而不是关键字<br>使用:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a是"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b是"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>其中endl表示end of line,表示换行,可用\n代替</p><h2 id="4-C-中const的作用"><a href="#4-C-中const的作用" class="headerlink" title="4.C++中const的作用"></a>4.C++中const的作用</h2><p>1.定义常量<br><code>const int a = 10; // a不可修改</code></p><p>2.类型检查<br><code>void f(const int i){}// 对传进来的参数进行类型检查,不匹配则提示</code></p><p>3.保护参数<br><code>void f(const int i){}// i不可修改</code></p><p>4.节省空间<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换三次,分配三次内存空间</span></span><br><span class="line">#define pi <span class="number">3.14</span></span><br><span class="line"><span class="keyword">double</span> a = pi;</span><br><span class="line"><span class="keyword">double</span> b = pi;</span><br><span class="line"><span class="keyword">double</span> c = pi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> <span class="literal">PI</span> = <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 只分配一次内存空间</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="literal">PI</span>;</span><br><span class="line"><span class="comment">// 不再分配内存空间</span></span><br><span class="line"><span class="keyword">double</span> e = <span class="literal">PI</span>;</span><br></pre></td></tr></table></figure></p><p>混淆点:<br>指针本身是常量不可变,不可以指向其他</p><pre><code>char* const pContent;</code></pre><p>指针所指向的内容是常量不可变</p><pre><code>const char *pContent;</code></pre><p>两者都不可变</p><pre><code>const char* const pContent;</code></pre><h2 id="5-动态分配内存"><a href="#5-动态分配内存" class="headerlink" title="5.动态分配内存"></a>5.动态分配内存</h2><p>在C中<br>分配</p><pre><code>int *p = (int *)malloc(sizeof(int) * 10);</code></pre><p>释放</p><pre><code>free(p);</code></pre><p>在C++中 new[]分配 delete[]释放</p><pre><code>int *p = new int;delete p;int *p = new int[10];  //分配10个int型的内存空间delete[] p;</code></pre><p>new 是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收<br>用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。</p><h2 id="6-函数调用的流程"><a href="#6-函数调用的流程" class="headerlink" title="6.函数调用的流程"></a>6.函数调用的流程</h2><p>函数调用是有时间和空间开销的(递归效率低下)。<br>程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。</p><h2 id="7-内联函数"><a href="#7-内联函数" class="headerlink" title="7.内联函数"></a>7.内联函数</h2><p>作用:为了消除函数调用的时空开销，在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数.</p><p>在<strong>函数定义处</strong>添加inline关键字,声明处添加无效.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"内联函数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意:</p><ol><li>当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以一般是将非常短小的函数声明为内联函数。</li><li>对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的。编译器有自己的判断能力，它会根据具体情况决定是否这样做。如何函数体非常大，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。</li></ol><p>缺点:编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大。</p><p>总结:小而短的函数声明为内联函数.</p><p>内联函数替代宏<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(a,b) (a+b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="8-函数的默认参数-重载"><a href="#8-函数的默认参数-重载" class="headerlink" title="8.函数的默认参数/重载"></a>8.函数的默认参数/重载</h2><p>默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">sum(<span class="number">12</span>,<span class="number">23</span>);</span><br><span class="line">sum(<span class="number">12</span>)</span><br></pre></td></tr></table></figure></p><p>重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。<br>重载的结果是让一个函数名拥有了多种用途，使得命名更加方便,调用更加灵活。<br>要求:函数名相同,参数列表不同,仅仅返回类型不同不足以成为函数的重载。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换 int 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换 float 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">float</span> *a, <span class="keyword">float</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重载的本质:<br>在编译时会根据参数列表对函数进行重命名,函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。</p><h2 id="9-对象的创建"><a href="#9-对象的创建" class="headerlink" title="9.对象的创建"></a>9.对象的创建</h2><p>类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。</p><p>成员变量大都以m_开头。</p><p>存储在栈上的对象</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Student stu<span class="comment">;</span></span><br><span class="line">Student *p = &amp;stu<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>存储在堆上的对象<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Student *stu = <span class="keyword">new</span> <span class="type">Student</span>;</span><br></pre></td></tr></table></figure></p><p>使用 new 在堆上创建出来的对象是匿名的，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</p><h2 id="10-成员函数"><a href="#10-成员函数" class="headerlink" title="10.成员函数"></a>10.成员函数</h2><p>在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以建议在类体内部对成员函数作声明，而在类体外部进行定义.</p><p>不使用内联函数:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> age;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;  <span class="comment">//内联函数声明</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//函数定义</span></span><br><span class="line"><span class="keyword">void</span> Student::say()&#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="11-构造函数"><a href="#11-构造函数" class="headerlink" title="11.构造函数"></a>11.构造函数</h2><p>构造函数必须是 public 属性的，否则创建对象时无法调用。<br>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。</p><p>一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成</p><p>调用没有参数的构造函数也可以省略括号。<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Student stu()<span class="comment">;</span></span><br><span class="line">Student stu<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Student *stu = new Student()<span class="comment">;</span></span><br><span class="line">Student *stu = new Student<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>参数初始化表可以用于全部成员变量，也可以只用于部分成员变量。<br>参数初始化顺序与初始化表列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。<br>初始化 const 成员变量的唯一方法就是使用参数初始化表。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//采用参数初始化表</span></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-析构函数"><a href="#12-析构函数" class="headerlink" title="12.析构函数"></a>12.析构函数</h2><p>析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号。<br>析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。</p><h2 id="13-this的本质"><a href="#13-this的本质" class="headerlink" title="13.this的本质"></a>13.this的本质</h2><p>this 是 C++ 中的一个关键字，也是一个 <strong>const 指针</strong>，它指向当前对象，通过它可以访问当前对象的所有成员。</p><p>his 虽然用在类的内部，但是只有在对象被创建以后才会给 this 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给 this 赋值。</p><p>this的本质:<br>this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。<br>this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。</p><h2 id="14-静态成员变量"><a href="#14-静态成员变量" class="headerlink" title="14.静态成员变量"></a>14.静态成员变量</h2><p>static 成员变量属于类，不属于某个具体的对象，即使创建多个对象,也只分配一份内存.</p><p>static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用</p><p>static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 m_total 声明为静态成员变量</span></span><br><span class="line"><span class="comment">//通过类类访问 static 成员变量</span></span><br><span class="line">Student::m_total = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//通过对象来访问 static 成员变量</span></span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</span><br><span class="line">stu.m_total = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//通过对象指针来访问 static 成员变量</span></span><br><span class="line">Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李华"</span>, <span class="number">16</span>, <span class="number">96</span>);</span><br><span class="line">pstu -&gt; m_total = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p><p>静态成员变量必须初始化，而且只能在类体外进行</p><p>static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p><h2 id="15-静态成员函数"><a href="#15-静态成员函数" class="headerlink" title="15.静态成员函数"></a>15.静态成员函数</h2><p>普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。</p><p>普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。</p><p>普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。</p><p>静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</p><h2 id="16-常成员函数"><a href="#16-常成员函数" class="headerlink" title="16.常成员函数"></a>16.常成员函数</h2><p>const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的</p><p>常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明常成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义常成员函数</span></span><br><span class="line"><span class="keyword">int</span> Student::getage() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="17-友元函数与友元类"><a href="#17-友元函数与友元类" class="headerlink" title="17.友元函数与友元类"></a>17.友元函数与友元类</h2><p>借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。<br>在当前类以外定义的、不属于当前类的函数可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。</p><p>友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。</p><p>一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// 构造函数</span></span><br><span class="line">    Address(<span class="keyword">char</span> *province, <span class="keyword">char</span> *city, <span class="keyword">char</span> *district);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将Student类中的成员函数show()声明为友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Student::show(Address *addr);</span><br></pre></td></tr></table></figure></p><p>友元类中的所有成员函数都是另外一个类的友元函数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Address(<span class="keyword">char</span> *province, <span class="keyword">char</span> *city, <span class="keyword">char</span> *district);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//将Student类声明为Address类的友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>;</span></span><br></pre></td></tr></table></figure></p><p>友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。<br>友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。</p><h2 id="18-struct与class比较"><a href="#18-struct与class比较" class="headerlink" title="18.struct与class比较"></a>18.struct与class比较</h2><p>使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的</p><p>class 继承默认是 private 继承，而 struct 继承默认是 public 继承</p><p>class 可以使用模板，而 struct 不能</p><h2 id="19-string的使用"><a href="#19-string的使用" class="headerlink" title="19.string的使用"></a>19.string的使用</h2><p>前提:<code>#include &lt;string&gt;</code></p><p>1.输入输出</p><pre><code>string s;cin&gt;&gt;s;cou&lt;&lt;s&lt;&lt;endl;</code></pre><p>2.通过下标访问</p><pre><code>string s = &quot;qwert&quot;;s[3] = &apos;d&apos;;couy&lt;&lt;s[2];    </code></pre><p>3.拼接</p><pre><code>string s = &quot;i&quot;;char *s1 = &quot;love&quot;;char s2[] = &quot;you&quot;;char s3 = &apos;!&apos;;string rs = s + s1 + s2 + s3;</code></pre><p>4.插入</p><pre><code>string s = &quot;sdf&quot;;s.insert(1,&quot;sds&quot;); // 索引/内容</code></pre><p>5.删除</p><pre><code>s1 = s2 = s3 = &quot;1234567890&quot;;s2.erase(5);s3.erase(5, 3); // 长度为3</code></pre><p>6.提取</p><pre><code>s1.substr(6, 6); // 长度为6</code></pre><p>7.查找</p><pre><code>s.find(&quot;,&quot;,1); // 从索引1开始查找逗号,返回索引</code></pre><h2 id="20-指针传递与引用传递的比较"><a href="#20-指针传递与引用传递的比较" class="headerlink" title="20.指针传递与引用传递的比较"></a>20.指针传递与引用传递的比较</h2><p>引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。</p><p>引用的定义方式类似于指针，只是用&amp;取代了*</p><pre><code>type &amp;name = data;// 指针传递// 比如交换数据swap(int *a, int *b) {int temp = *a;*a = *b;*b = temp;    }// 使用swap(&amp;a, &amp;b);//引用传递swap2(int &amp;a, int &amp;b) {int temp = a;a = b;b = temp;}// 使用swap2(a,b);</code></pre><p>引用也可以作为函数的返回值,不过不能返回局部变量的引用,因为局部变量过了作用域就销毁了</p><h2 id="21-继承"><a href="#21-继承" class="headerlink" title="21.继承"></a>21.继承</h2><p>继承方式包括 public（公有的）、private（私有的）和 protected（受保护的），此项是可选的，如果不写，那么默认为 private。</p><pre><code>class 派生类名:［继承方式］ 基类名{    派生类新增加的成员};</code></pre><p>不同的继承方式会影响基类成员在派生类中的访问权限。</p><p>1) public继承方式</p><pre><code>基类中所有 public 成员在派生类中为 public 属性；基类中所有 protected 成员在派生类中为 protected 属性；基类中所有 private 成员在派生类中不能使用。</code></pre><p>2) protected继承方式</p><pre><code>基类中的所有 public 成员在派生类中为 protected 属性；基类中的所有 protected 成员在派生类中为 protected 属性；基类中的所有 private 成员在派生类中不能使用。</code></pre><p>3) private继承方式</p><pre><code>基类中的所有 public 成员在派生类中均为 private 属性；基类中的所有 protected 成员在派生类中均为 private 属性；基类中的所有 private 成员在派生类中不能使用。</code></pre><p>基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。</p><p>基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。</p><p>类的构造函数不能被继承<br>析构函数也不能被继承<br>派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</p><h2 id="22-多重继承"><a href="#22-多重继承" class="headerlink" title="22.多重继承"></a>22.多重继承</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C&#123;</span><br><span class="line">    <span class="comment">//类D新增加的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和<strong>声明派生类时基类出现的顺序</strong>相同。</p><h2 id="23-虚继承"><a href="#23-虚继承" class="headerlink" title="23.虚继承"></a>23.虚继承</h2><p><img src="http://static.chenyalun.com/2017/04/03/20170403002.jpg" alt=""><br>假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A –&gt;B–&gt;D 这条路径，还是来自 A–&gt;C–&gt;D 这条路径。因为类 B 和类 C 中都有成员变量 a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了错误。</p><p>消除歧义:使用域解析操作符</p><p>为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。<br>在继承方式前面加上 virtual 关键字就是虚继承<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//间接基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接基类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; m_a = a; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setb</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123; m_b = b; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setc</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123; m_c = c; &#125;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setd</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123; m_d = d; &#125;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><p>虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。</p><p>在最终派生类 D 的构造函数中，除了调用 B 和 C 的构造函数，还调用了 A 的构造函数，这说明 D 不但要负责初始化直接基类 B 和 C，还要负责初始化间接基类 A。直接派生类 B 和 C 对 A 的构造函数的调用是无效的.而在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误。</p><p>在类被构造的时候，先执行<strong>虚拟继承的父类的构造函数</strong>，然后从<strong>左到右执行普通继承的父类的构造函数</strong>，然后按照<strong>定义的顺序执行数据成员的初始化</strong>，最后是<strong>自身的构造函数的调用</strong>。析构函数与之完全相反，互成镜像。<br>见:<a href="http://gaocegege.com/Blog/cpp/cppclass" target="_blank" rel="noopener">http://gaocegege.com/Blog/cpp/cppclass</a></p><h2 id="24-C-向上转型"><a href="#24-C-向上转型" class="headerlink" title="24.C++向上转型"></a>24.C++向上转型</h2><p>编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。<br>基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。</p><h2 id="25-虚函数、纯虚函数与多态"><a href="#25-虚函数、纯虚函数与多态" class="headerlink" title="25.虚函数、纯虚函数与多态"></a>25.虚函数、纯虚函数与多态</h2><p>目的:让基类指针能够访问派生类的成员函数,只需要在该成员函数声明前面增加 virtual 关键字(基类\派生类都要操作)</p><p>有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）</p><p>虚函数的唯一用处就是构成多态,如果没有多态，我们只能访问成员变量。</p><p>只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）</p><p>构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。</p><p>析构函数可以声明为虚函数，而且有时候必须要声明为虚函数</p><p>将虚函数声明为纯虚函数，纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数。 语法格式为：</p><pre><code>virtual 返回值类型 函数名 (函数参数) = 0;</code></pre><p><strong>包含纯虚函数的类称为抽象类（Abstract Class）</strong><br>一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。</p><h2 id="26-运算符重载"><a href="#26-运算符重载" class="headerlink" title="26.运算符重载"></a>26.运算符重载</h2><p>运算符重载的格式为：</p><pre><code>返回值类型 operator 运算符名称 (形参表列){//TODO:}// 如complex operator+(const complex &amp;A) const;</code></pre><h2 id="27-模板"><a href="#27-模板" class="headerlink" title="27.模板"></a>27.模板</h2><p>函数模板<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , ...&gt; 返回值类型  函数名(形参列表)&#123;</span><br><span class="line"><span class="comment">//在函数体中可以使用类型参数</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">typename</span>关键字可使用<span class="class"><span class="keyword">class</span>代替</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"> // 如</span></span><br><span class="line"><span class="class"><span class="title">template</span>&lt;class T&gt; <span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>)&#123;</span></span><br><span class="line">   T temp = a;</span><br><span class="line">   a = b;</span><br><span class="line">   b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键在于函数定义前面加上 template<typename t,="" typename="" m=""></typename></p><p>类模板<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , …&gt; <span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;typename T1, typename T2&gt;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板使用时需要指明类型,函数模板不需要</span></span><br><span class="line">Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; *p1 = <span class="keyword">new</span> Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt;(<span class="number">10.6</span>, <span class="number">109.3</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>参考博客<br>C语言中文网:<a href="http://c.biancheng.net/cpp/biancheng/cpp/rumen/" target="_blank" rel="noopener">http://c.biancheng.net/cpp/biancheng/cpp/rumen/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 不堪回首。 &lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://blog.chenyalun.com/categories/C/"/>
    
    
      <category term="C" scheme="http://blog.chenyalun.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>排序算法实现</title>
    <link href="http://blog.chenyalun.com/2017/03/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.chenyalun.com/2017/03/05/排序算法实现/</id>
    <published>2017-03-05T03:52:27.000Z</published>
    <updated>2017-04-26T01:06:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017.4.24 修改部分代码<br>2017.4.21 完善<br>2017.3.25 修改</p></blockquote><p align="center"> 排序算法。 </p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为笔试使用的编译器语言为Python2.7，所以以下代码使用Python2实现并规定从小到大为目标顺序。</p><p>八大排序：<br>直接插入排序，希尔排序，简单选择排序，堆排序，冒泡排序，快速排序，归并排序，基数排序。</p><h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>假定n1 = n2,排序前n1位于n2前面,如果排序后n1扔领先于n2,则称排序算法稳定.</p><h2 id="内排序与外排序"><a href="#内排序与外排序" class="headerlink" title="内排序与外排序"></a>内排序与外排序</h2><p>内排序:排序的整个过程中,待排序的所有记录全部被放置在内存中.<br>外排序:由于排序的记录太多,排序的过程中,需要内外存之间多次交换才能进行.</p><h1 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h1><p>原理:通过相邻元素的比较和交换，把较大的数交换到后面，类似水泡向上面(数组的后面，所以总是靠后的数字有序)升，故称为冒泡排序。如果两数相等，不交换，所以稳定。</p><p>普通方式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(tempList)</span>:</span></span><br><span class="line">n = len(tempList)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">1</span>, n - x):<span class="comment"># 索引n-x之后的数已经排序好了</span></span><br><span class="line"><span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]:</span><br><span class="line">tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y]</span><br><span class="line"><span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> bubbleSort([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</span><br></pre></td></tr></table></figure><p>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，无需继续迭代。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#交换排序-冒泡排序优化1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort1</span><span class="params">(tempList)</span>:</span></span><br><span class="line">n = len(tempList)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</span><br><span class="line"><span class="comment">#标志位,倘若没有交换,说明已经排序好了</span></span><br><span class="line">flag = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">1</span>, n - x):<span class="comment"># 索引n-x之后的数已经排序好了</span></span><br><span class="line"><span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]:</span><br><span class="line">tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y]</span><br><span class="line">flag = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> flag: <span class="comment"># 发现并没有发生交换</span></span><br><span class="line"><span class="keyword">return</span> tempList</span><br><span class="line"><span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> bubbleSort1([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</span><br></pre></td></tr></table></figure><p>优化2：记录最后发生交换的位置，位置之后的数据已经井然有序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#交换排序-冒泡排序优化2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort2</span><span class="params">(tempList)</span>:</span></span><br><span class="line">n = len(tempList)</span><br><span class="line"><span class="comment"># 循环范围</span></span><br><span class="line">m = n</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</span><br><span class="line"><span class="comment">#标志位,倘若没有交换,说明已经排序好了</span></span><br><span class="line">flag = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">1</span>, m):<span class="comment"># 索引m之后的数已经排序好了</span></span><br><span class="line"><span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]:</span><br><span class="line">tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y]</span><br><span class="line">m = y</span><br><span class="line">flag = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> flag: <span class="comment"># 发现并没有发生交换</span></span><br><span class="line"><span class="keyword">return</span> tempList</span><br><span class="line"><span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> bubbleSort2([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</span><br></pre></td></tr></table></figure><p><strong>分析</strong><br>最好情况:数据井然有序,根据优化后的代码,只需要迭代一次,即n-1次的比较,则时间复杂度为O(n)<br>最坏情况:数据逆序,需要比较的次数为1+2+3+4+…+(n-1)=n(n-1)/2次,时间复杂度为O(n^2)</p><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">假定有4个数,分别为4<span class="number"> 3 </span>2 1,排序过程为:</span><br><span class="line">原数据:<span class="number"> 4 </span>3<span class="number"> 2 </span>1</span><br><span class="line">第1次:<span class="number"> 3 </span>4<span class="number"> 2 </span>1</span><br><span class="line">第2次:<span class="number"> 3 </span>2<span class="number"> 4 </span>1</span><br><span class="line">第3次:<span class="number"> 3 </span>2<span class="number"> 1 </span>4</span><br><span class="line">第4次:<span class="number"> 2 </span>3<span class="number"> 1 </span>4</span><br><span class="line">第5次:<span class="number"> 2 </span>1<span class="number"> 3 </span>4</span><br><span class="line">第6次:<span class="number"> 1 </span>2<span class="number"> 3 </span>4</span><br><span class="line"></span><br><span class="line">归纳推理:n(n-1)/2次</span><br></pre></td></tr></table></figure><h1 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h1><p>在未排序序列中找到最小元素，存放到排序序列的起始位置(与第一个元素交换位置)，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾(与第二个元素交换位置)。以此类推，直到所有元素均排序完毕。</p><p>通过n-i次关键字间的比较,从n-i+1个记录中选出最小的记录,并和第i个记录交换之.</p><p>选择排序的交换操作介于 0 和 ( n − 1 )次之间。<br>选择排序的比较操作为 n ( n − 1 ) / 2次之间。<br>选择排序的赋值操作介于 0 和 3 ( n − 1 )次之间。</p><p>当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">def selectionSort(tempList):</span><br><span class="line">n = len(tempList)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</span><br><span class="line"><span class="meta"># 假定索引x对应的是最小值</span></span><br><span class="line"><span class="keyword">index</span> = x</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> xrange(x + <span class="number">1</span>,n):</span><br><span class="line"><span class="meta"># 如果找到比索引index对应的值还要小的值,交换两者位置</span></span><br><span class="line"><span class="keyword">if</span> tempList[<span class="keyword">index</span>] &gt; tempList[y]:</span><br><span class="line">tempList[<span class="keyword">index</span>], tempList[y] = tempList[y], tempList[<span class="keyword">index</span>]</span><br><span class="line"><span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print selectionSort([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</span><br></pre></td></tr></table></figure><p><strong>分析</strong><br>特点:交换移动数据次数相当少<br>最好情况与最坏情况:比较次数一样多,为n(n-1)/2次,时间复杂度:O(n^2)</p><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">假定有4个数据,分别为<span class="number"> 4 </span>3<span class="number"> 2 </span>1</span><br><span class="line">原数据:<span class="number"> 4 </span>3<span class="number"> 2 </span>1</span><br><span class="line">第1次比较:<span class="number"> 4 </span>与 3</span><br><span class="line">第2次比较:<span class="number"> 4 </span>与 2</span><br><span class="line">第3次比较:<span class="number"> 4 </span>与<span class="number"> 1 </span>(此时数据为1<span class="number"> 3 </span>2 4)</span><br><span class="line">第4次比较:<span class="number"> 3 </span>与 2</span><br><span class="line">第5次比较:<span class="number"> 3 </span>与<span class="number"> 4 </span>(此时数据为<span class="number"> 1 </span>2<span class="number"> 3 </span>4)</span><br><span class="line">第6次比较:<span class="number"> 3 </span>与 4</span><br><span class="line"></span><br><span class="line">最终结果:<span class="number"> 1 </span>2<span class="number"> 3 </span>4</span><br><span class="line">比较次数:6次</span><br></pre></td></tr></table></figure><p>选择排序是不稳定的排序算法,比如<code>5 8 5 2 9</code>,显然第1个5最终落到第2个5的后面.</p><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">原数据:    5'<span class="number"> 8 </span>5<span class="number"> 2 </span>9</span><br><span class="line">第1次交换:<span class="number"> 2 </span>8<span class="number"> 5 </span>5' 9</span><br><span class="line">第2次交换:<span class="number"> 2 </span>5<span class="number"> 8 </span>5' 9</span><br><span class="line">第3次交换:<span class="number"> 2 </span>5 5'<span class="number"> 8 </span>9</span><br><span class="line">第4次交换:<span class="number"> 2 </span>5 5'<span class="number"> 8 </span>9</span><br><span class="line"></span><br><span class="line">最终 5'在<span class="number"> 5 </span>的前面.</span><br></pre></td></tr></table></figure><h1 id="三、直接插入排序"><a href="#三、直接插入排序" class="headerlink" title="三、直接插入排序"></a>三、直接插入排序</h1><p>原理:在一个已经有序的数据序列中插入一个数，在插入后此数据序列仍然有序。默认前1个数有序，第二个数与前一个数组成的有序数列比较并插入，第三个数与前两个数组成的有序数列比较并插入……所以总是靠前的数字有序。</p><p>遇到相等的数，插入到该数的后面，而不是前面，所以是稳定排序算法。</p><p><img src="http://static.chenyalun.com/2017/03/15/2017031501.gif" alt=""></p><p>最好情况：序列已经是升序排列了，需要进行的比较操作需(n-1)次,时间复杂度为O(n)。<br>最坏情况：序列是降序排列，那么此时需要进行的比较共有 n ( n − 1 ) / 2 次。<br>插入排序的赋值操作是比较操作的次数加上(n-1)次。<br>平均来说插入排序算法复杂度为 O ( n^2 )。<br>插入排序不适合对于数据量比较大的排序应用。<strong>用于少量元素的排序</strong>（通常为8个或以下）。</p><p>直接插入</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(tempList)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="comment"># 获取列表的长度</span></span><br><span class="line">n = len(tempList)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>,n): <span class="comment"># 从第1个元素而非第0个元素开始遍历</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> xrange(x, <span class="number">0</span>, -<span class="number">1</span>): <span class="comment"># 在已经排好序的列表中逐个扫描</span></span><br><span class="line"><span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]: <span class="comment"># 如果当前元素比前面的小</span></span><br><span class="line">tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y] <span class="comment"># 两者位置互换</span></span><br><span class="line"><span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"><span class="comment"># print insertionSort([])</span></span><br><span class="line"><span class="comment"># print insertionSort([8])</span></span><br><span class="line"><span class="comment"># print insertionSort([5,2,7,0,1,5,9])</span></span><br></pre></td></tr></table></figure><h1 id="四、二分插入排序"><a href="#四、二分插入排序" class="headerlink" title="四、二分插入排序"></a>四、二分插入排序</h1><p>二分查找插入与希尔排序是直接插入排序的优化。</p><p>二分查找插入</p><p>使用Python模块实现</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bisect模块实现了一个算法, 用于向一个有序列表中插入一个元素,不改变列表的序列</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用这个模块的函数前先确保操作的列表是已排序的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">import bisect </span></span><br><span class="line">def insertionSortBisect(tempList):  </span><br><span class="line">    for i in xrange(1, len(tempList)):  </span><br><span class="line">        bisect.insort(tempList, tempList.pop(i), 0, i) # 排序列表,移除并插入元素,区间开始,区间结束</span><br><span class="line">    return tempList</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">print</span> insertionSortBisect([])</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">print</span> insertionSortBisect([8])</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">print</span> insertionSortBisect([5,2,7,0,1,5,9])</span></span><br></pre></td></tr></table></figure><p>手动实现</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二分查找的前提必须待查找的序列有序</span></span><br><span class="line"><span class="comment"># 在有序列表中,返回值m应该所在的索引</span></span><br><span class="line">def indexOfInsertionSort(tempList, m):</span><br><span class="line"><span class="comment"># 获取列表的长度</span></span><br><span class="line">n = <span class="built_in">len</span>(tempList)</span><br><span class="line">left, <span class="literal">right</span> = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt;= <span class="literal">right</span>:</span><br><span class="line"><span class="keyword">middle</span> = (left + <span class="literal">right</span>) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> tempList[<span class="keyword">middle</span>] &lt; m:<span class="comment"># 右半部分</span></span><br><span class="line">left = <span class="keyword">middle</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>: <span class="comment">#左半部分,含相同元素</span></span><br><span class="line"><span class="literal">right</span> = <span class="keyword">middle</span> <span class="number">-1</span></span><br><span class="line"><span class="literal">return</span> <span class="literal">right</span> +<span class="number">1</span></span><br><span class="line"></span><br><span class="line">def insertionSortbin(tempList):</span><br><span class="line"><span class="comment"># 获取列表的长度</span></span><br><span class="line">n = <span class="built_in">len</span>(tempList)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>,n): <span class="comment"># 从头至尾遍历列表中的元素</span></span><br><span class="line">m = tempList[x]</span><br><span class="line">tempList.pop(x)</span><br><span class="line">index = indexOfInsertionSort(tempList[<span class="number">0</span>:x],m)</span><br><span class="line">tempList.insert(index , m) <span class="comment">#第一个参数是索引,第二个参数是数值</span></span><br><span class="line"><span class="literal">return</span> tempList</span><br><span class="line"></span><br><span class="line"><span class="comment">#print insertionSortbin([12,12,16,8,5,10,7])</span></span><br></pre></td></tr></table></figure><h1 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a>五、希尔排序</h1><p>先将待排记录序列分割为若干个子序列，分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序。</p><p>采用跳跃分割的策略:把相距某个”增量”的记录组成一个序列，保证在子序列内分别进行直接插入排序后得到的结果是基本有序的。</p><p>原始序列</p><blockquote><p>2 5 1 9 8 2 10 4</p></blockquote><p>4步长，分组，每列排序</p><blockquote><p>2 5 1 9<br>8 2 10 4</p></blockquote><p>排序后</p><blockquote><p>2 2 1 4<br>8 5 10 9</p></blockquote><p>也即</p><blockquote><p>2 2 1 4 8 5 10 9</p></blockquote><p>2步长，再分组</p><blockquote><p>2 2<br>1 4<br>8 5<br>10 9</p></blockquote><p>排序</p><blockquote><p>1 2<br>2 4<br>8 5<br>10 9</p></blockquote><p>也即：</p><blockquote><p>1 2 2 4 8 5 10 9</p></blockquote><p>最后以1步长进行排序（还是直接插入排序）。</p><p>一般插入</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def insertionSortShell(tempList):</span><br><span class="line">n = len(tempList)</span><br><span class="line"># 确定分组,假定n = 6</span><br><span class="line"><span class="built_in">group </span>= n / 2 # 此时group = 3,分成3组,3组元素索引分别为3与3-3,4与4-3,5与5-3</span><br><span class="line"><span class="keyword">while</span><span class="built_in"> group </span>&gt; 0:</span><br><span class="line">#x从3到5</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(group,n):</span><br><span class="line"># 每组元素:x,x-group,x-group-group <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>插入排序</span><br><span class="line">temp = tempList[x]</span><br><span class="line">y = x</span><br><span class="line"># 这里使用简单的插入排序</span><br><span class="line"><span class="keyword">while</span> y &gt;=<span class="built_in"> group </span><span class="keyword">and</span> tempList[y - group] &gt; temp:</span><br><span class="line">tempList[y] = tempList[y - group]</span><br><span class="line">y -= group</span><br><span class="line">tempList[y] = temp</span><br><span class="line"></span><br><span class="line"><span class="built_in">group </span>/= 2</span><br><span class="line">return tempList</span><br></pre></td></tr></table></figure><p>互换法</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def insertionSortShellExchange(tempList):</span><br><span class="line">n = len(tempList)</span><br><span class="line"># 确定分组,假定n = 6</span><br><span class="line"><span class="built_in">group </span>= n / 2 # 此时group = 3,分成3组,3组元素索引分别为3与3-3,4与4-3,5与5-3</span><br><span class="line"><span class="keyword">while</span><span class="built_in"> group </span>&gt; 0:</span><br><span class="line">#x从3到5</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(group,n):</span><br><span class="line"># 每组元素:x,x-group,x-group-group <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>插入排序</span><br><span class="line">y = x</span><br><span class="line">m = tempList[x]</span><br><span class="line"><span class="keyword">while</span> y &gt;=<span class="built_in"> group </span><span class="keyword">and</span> tempList[y - group] &gt; m:</span><br><span class="line"># 这里直接交换位置</span><br><span class="line">tempList[y], tempList[y - group] = tempList[y - group], tempList[y]</span><br><span class="line">y -= group</span><br><span class="line"></span><br><span class="line"><span class="built_in">group </span>/= 2</span><br><span class="line">return tempList</span><br><span class="line"></span><br><span class="line"><span class="comment">#print insertionSortShell([1,8,10,2,4,0])</span></span><br><span class="line"><span class="comment">#print insertionSortShellExchange([1,8,10,2,4,0])</span></span><br></pre></td></tr></table></figure><p>由于记录是跳跃式的，希尔排序是不稳定的排序算法。</p><h1 id="六、堆排序"><a href="#六、堆排序" class="headerlink" title="六、堆排序"></a>六、堆排序</h1><p>堆排序是对简单选择排序的改进。</p><p>堆是具有以下性质的完全二叉树:<br>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。<br>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p>性质:按层遍历的方式给结点编号，则有:</p><pre><code>k(i) &gt;= k(2i)k(i) &gt;= k(2i+1)或k(i) &lt;= k(2i)k(i) &lt;= k(2i+1)</code></pre><p>堆排序就是利用堆进行排序的算法，基本思想是:将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根结点。把它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个值重新构造成一个堆，这样就会得到n个元素中的次小值，如此反复执行，便能得到一个有序序列了。</p><p>需要解决的两个问题:<br><strong>1. 如何由一个无序序列构建成一个堆</strong><br><strong>2. 如何在获取堆顶元素后，调整剩余元素成为一个新的堆</strong></p><p>所谓的将待排序的序列构建成一个大顶堆，其实就是从下往上、从右往左，将每个非叶结点当作根节点，将其和其子树调整成大顶堆。</p><p>在正式排序时，第i次取堆顶记录重建需要O(logi)的时间，并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为O(nlogn)。</p><p>堆排序对原始状态的排序不敏感，无论是最好最坏还是平均情况时间复杂度总是为O(nlogn)。</p><p>注意:由于初始构建堆所需的比较次数较多，因此，它并<strong>不适合待排序序列个数较少的情况</strong>。</p><p>实现</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start是当前需要调整最小堆的位置,end是调整边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapAdjust</span><span class="params">(tempList, start, end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        child = root * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> tempList[child] &lt; tempList[child + <span class="number">1</span>]:</span><br><span class="line">            child += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> tempList[root] &lt; tempList[child]:</span><br><span class="line">            tempList[root], tempList[child] = tempList[child], tempList[root]</span><br><span class="line">            root = child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(tempList)</span>:</span></span><br><span class="line">    n = len(tempList)</span><br><span class="line">    <span class="comment"># 构造小顶堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n / <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        heapAdjust(tempList, i, n - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 将堆顶记录和当前未排序子序列的最后一个记录交换</span></span><br><span class="line">        tempList[<span class="number">0</span>], tempList[i] = tempList[i], tempList[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 重新调整为小顶堆</span></span><br><span class="line">        heapAdjust(tempList, <span class="number">0</span>, i - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> heapSort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure><h1 id="七、归并排序"><a href="#七、归并排序" class="headerlink" title="七、归并排序"></a>七、归并排序</h1><p>归并排序就是利用归并的思想实现的排序算法。原理是:假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两合并，得到n/2的向上取整个长度为2或者为1的有序子序列，然后两两合并，如此重复，直到得到一个长度为n的有序序列。该方法也称为2路归并排序。</p><p>比较操作的次数介于 ( nlogn ) / 2 和 nlogn − n + 1。<br>赋值操作的次数是 ( 2 nlogn )。</p><p><img src="http://static.chenyalun.com/2017/03/15/2017031503.gif" alt=""></p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment">#归并排序</span></span><br><span class="line">def mergeSort(tempList):</span><br><span class="line"><span class="built_in">length</span> = <span class="built_in">len</span>(tempList)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span> &lt;= <span class="number">1</span>:</span><br><span class="line"><span class="literal">return</span> tempList</span><br><span class="line"><span class="comment"># 二分列表</span></span><br><span class="line"><span class="keyword">middle</span> = <span class="built_in">length</span> / <span class="number">2</span></span><br><span class="line">leftList = mergeSort(tempList[:<span class="keyword">middle</span>])</span><br><span class="line">rightList = mergeSort(tempList[<span class="keyword">middle</span>:])</span><br><span class="line"></span><br><span class="line"><span class="literal">return</span> <span class="built_in">merge</span>(leftList,rightList)</span><br><span class="line"></span><br><span class="line">def <span class="built_in">merge</span>(leftList,rightList):</span><br><span class="line">leftIndex,rightIndex = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="built_in">result</span> = []</span><br><span class="line"><span class="keyword">while</span> leftIndex &lt; <span class="built_in">len</span>(leftList) <span class="keyword">and</span> rightIndex &lt; <span class="built_in">len</span>(rightList):</span><br><span class="line"><span class="keyword">if</span> leftList[leftIndex] &lt; rightList[rightIndex]:</span><br><span class="line"><span class="built_in">result</span>.append(leftList[leftIndex])</span><br><span class="line">leftIndex += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">result</span>.append(rightList[rightIndex])</span><br><span class="line">rightIndex += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">result</span> += leftList[leftIndex:]</span><br><span class="line"><span class="built_in">result</span> += rightList[rightIndex:]</span><br><span class="line"><span class="literal">return</span> <span class="built_in">result</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print mergeSort([<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>一趟归并需要耗费O(n)时间，由完全二叉树的深度可知，整个归并排序需要进行logn次，故，总的时间复杂度为O(logn)，并且最好/最坏/平均时间性能均是如此。</p><p>归并排序需要两两比较，不存在跳跃，因此稳定。</p><h1 id="八、快速排序"><a href="#八、快速排序" class="headerlink" title="八、快速排序"></a>八、快速排序</h1><p>20世纪十大算法之一。</p><p>关键词:基准 分组 递归</p><p>在平均状况下，排序n个项目要Ο(n log n)次比较。<br>在最坏状况下则需要Ο(n2)次比较。</p><p><img src="http://static.chenyalun.com/2017/03/15/2017031502.gif" alt=""></p><p>快速排序使用分治法策略来把一个序列分为两个子序列。</p><p>步骤为：</p><ol><li>从数列中挑出一个元素，作为基准数，</li><li>分区：把比基准大的放在右边，比基准小的放在左边，等于基准的放在基准列表中。</li><li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(tempList)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(tempList) &lt;= <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> tempList</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基准列表</span></span><br><span class="line">pivotList = []</span><br><span class="line"><span class="comment"># 比基准小的列表</span></span><br><span class="line">lessList = []</span><br><span class="line"><span class="comment"># 比基准大的列表</span></span><br><span class="line">moreList = []</span><br><span class="line"><span class="comment">#将第一个值作为基准</span></span><br><span class="line">pivot = tempList[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 遍历tempList</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> tempList:</span><br><span class="line"><span class="comment"># 比基准大,放入moreList</span></span><br><span class="line"><span class="keyword">if</span> x &gt; pivot:</span><br><span class="line">moreList.append(x)</span><br><span class="line"><span class="comment"># 比基准小,放入lessList</span></span><br><span class="line"><span class="keyword">elif</span> x &lt; pivot:</span><br><span class="line">lessList.append(x)</span><br><span class="line"><span class="comment"># 与基准相等,放入基准列表中</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">pivotList.append(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对lessList和moreList递归操作</span></span><br><span class="line">lessList = quickSort(lessList)</span><br><span class="line">moreList = quickSort(moreList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回排序好的列表</span></span><br><span class="line"><span class="keyword">return</span> lessList + pivotList + moreList</span><br></pre></td></tr></table></figure><p>甚至可以这么写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort1</span><span class="params">(tempList)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(tempList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> tempList</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = tempList[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> quickSort1([x <span class="keyword">for</span> x <span class="keyword">in</span> tempList[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; pivot])\</span><br><span class="line">         + [pivot] + \</span><br><span class="line">         quickSort1([x <span class="keyword">for</span> x <span class="keyword">in</span> tempList[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= pivot])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> quickSort1([<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure><p>快速排序的时间复杂度取决于快速排序递归的深度，在最优情况下时间复杂度为O(logn)。最坏情况下，待排序为正序或者逆序，时间复杂度为O(n^2)</p><p>由于关键字的比较和交换是跳跃进行的，因此快速排序不稳定。</p><p>快速排序的优化:</p><ol><li><strong>优化选取枢轴</strong><br>三数取中法:取三个关键字先进行排序，将中间数作为枢轴，一般取左端、右端和中间三个数，也可以随机选取，至少枢轴不是最大或者最小的数。</li></ol><h1 id="九、计数排序"><a href="#九、计数排序" class="headerlink" title="九、计数排序"></a>九、计数排序</h1><p>计数排序是用来排序0到100之间的数字的最好的算法。</p><p>步骤:</p><blockquote><p>找出待排序的数组中最大和最小的元素<br>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项<br>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计数排序</span></span><br><span class="line">def countsort(tempList):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tempList) &lt;= <span class="number">1</span>:</span><br><span class="line"><span class="literal">return</span> tempList</span><br><span class="line"></span><br><span class="line">maxValue = <span class="built_in">max</span>(tempList)</span><br><span class="line">minValue = <span class="built_in">min</span>(tempList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建计数列表countList</span></span><br><span class="line">countList = [<span class="number">0</span>] * (maxValue - minValue + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 获取元素出现次数</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> tempList:</span><br><span class="line">countList[e - minValue] += <span class="number">1</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 填值</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">a</span> <span class="keyword">in</span> xrange(maxValue - minValue + <span class="number">1</span>):</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> xrange(countList[<span class="keyword">a</span>]):</span><br><span class="line">tempList[index] = <span class="keyword">a</span> + minValue</span><br><span class="line">index += <span class="number">1</span></span><br><span class="line"><span class="literal">return</span> tempList</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">print countsort([<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>那么,以1,6,3,2,3为例<br>最值<br>maxValue = 6<br>minValue = 1</p><p>计数列表<br>countList = [0, 0, 0, 0, 0, 0]</p><p>元素出现的次数<br>countList = [1, 1, 2, 0, 0, 1]</p><table><thead><tr><th>a</th><th>countList[a] 即遍历次数</th><th>tempList[index]</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>tempList[0] = 1</td></tr><tr><td>1</td><td>1</td><td>tempList[1] = 2</td></tr><tr><td>2</td><td>2</td><td>tempList[2] = 3以及tempList[3] = 3</td></tr><tr><td>3</td><td>0</td><td></td></tr><tr><td>4</td><td>0</td><td></td></tr><tr><td>5</td><td>1</td><td>tempList[4] = 6</td></tr></tbody></table><p>排序成功:1, 2, 3, 3, 6</p><h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>算法分析：</p><p><img src="http://static.chenyalun.com/2017/03/15/2017031504.jpg" alt=""></p><p>代码保存在<a href="https://github.com/ChenYalun/YACode/tree/master/Blog" target="_blank" rel="noopener">GitHub</a>上。</p><p>参考资料：</p><blockquote><p>《大话数据结构》<br><a href="https://zh.wikipedia.org/zh-hans/" target="_blank" rel="noopener">维基百科</a><br><a href="https://segmentfault.com/a/1190000006546190#articleHeader17" target="_blank" rel="noopener">segmentfault</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="noopener">WuChong</a><br><a href="http://bubkoo.com/2014/01/13/sort-algorithm/selection-sort/" target="_blank" rel="noopener">bubkoo</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017.4.24 修改部分代码&lt;br&gt;2017.4.21 完善&lt;br&gt;2017.3.25 修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt; 排序算法。 &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.chenyalun.com/categories/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/categories/Python/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://blog.chenyalun.com/tags/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://blog.chenyalun.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS自定义转场总结</title>
    <link href="http://blog.chenyalun.com/2017/02/26/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.chenyalun.com/2017/02/26/iOS自定义转场总结/</id>
    <published>2017-02-26T07:22:34.000Z</published>
    <updated>2017-03-15T08:37:53.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 自定义转场总结。 </p><a id="more"></a><h1 id="一、勾弦"><a href="#一、勾弦" class="headerlink" title="一、勾弦"></a>一、勾弦</h1><p>转场的本质是下一场景的视图替换当前场景的视图以及相应的控制器的替换，表现为当前视图消失和下一视图出现。容器类 VC 的转场里 fromView 和 toView 是 containerView 的子层次的视图，而 Modal 转场里 presentingView 与ontainerView 是同层次的视图，只有 presentedView 是 containerView 的子层次视图。Custom 模式下 Modal 转场结束时 fromView 并未从视图结构中移除；FullScreen 模式的 Modal 转场结束后 fromView 主动被从视图结构中移除了。Custom 模式下，在 dismissal 中，不要像其他转场中那样将 toView加入 containerView 中，否则 dismiss 结束后本来可见的 presentingView 将会随着 containerView 一起被移除。</p><p>在 Modal 转场中，presentingView 并非 containerView 的子视图，这时通过viewForKey:方法来获取presentingView 得到的是 nil，必须通过viewControllerForKey:得到presentingVC 后来获取。当 UIViewController 的modalPresentationStyle属性为.Custom 或.FullScreen时，就有机会定制转场效果，此时modalTransitionStyle指定的转场动画将会被忽略。</p><p>容器 VC 的转场的代理由容器 VC 自身的代理提供不同，Modal 转场的代理由 presentedVC(目标控制器) 提供。Modal 转场在 Custom 模式下必须区分 presentation 和 dismissal 转场，而在 FullScreen 模式下可以不用这么做，因为 UIKit 会在 dismissal 转场结束后自动将 presentingView 放置到原来的位置。转场代理（Transitioning Delegate）根据不同的转场类型提供其所需要的动画控制类和交互控制类。</p><p>动画控制类(器)（Animation Controller）遵从UIViewControllerAnimatedTransitioning协议，并且负责执行实际的动画。交互控制类(器)（Interaction Controller）遵从UIViewControllerInteractiveTransition协议来控制可交互的转场动画。转场上下文（Transitioning Context）定义了转场时需要的元数据（比如转场所参与了的视图控制器和视图的属性），其遵从UIViewControllerContextTransitioning协议，并且这是由系统负责生成和提供。</p><p>转场协调器（Transition Coordinators）可以在运行转场动画时，并行的运行其他动画。转场协调器遵从UIViewControllerTransitionCoordinator协议。转场动画交互方式分两种，第一种是属于非交互式：必须要实现动画控制类，第二种交互式：必须要实现动画控制类和交互控制类（例如可以通过手势的滑动距离来控制转场动画的一个进度，一般应用中都可以通过手势的滑动来推出一个视图控制器)。</p><h1 id="二、简单转场"><a href="#二、简单转场" class="headerlink" title="二、简单转场"></a>二、简单转场</h1><p>基本类型</p><blockquote><p>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。<br>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。<br>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。<br>UIViewAnimationOptionRepeat：重复运行动画。<br>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。<br>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。<br>UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。<br>UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场 动画）。</p></blockquote><blockquote><p>UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，<br>而不是将旧视图从父视图移除（仅仅适用于转场动画）<br>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</p></blockquote><p>动画速度控制（可从其中选择一个设置）</p><blockquote><p>UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。<br>UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。<br>UIViewAnimationOptionCurveEaseOut：动画逐渐加速。<br>UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。</p></blockquote><p>转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）</p><blockquote><p>UIViewAnimationOptionTransitionNone：没有转场动画效果。<br>UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。<br>UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。<br>UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。<br>UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。<br>UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。<br>UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。<br>UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。</p></blockquote><p>简单使用<br>  作用于fromView的父视图，切换两个view，将formView从其父视图上移除，将toView重新粘在其父视图上，展现一个动画效果。</p>  <figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">UIView</span> transitionFromView:self.view toView:redView duration:5.0 options:</span><br><span class="line">UIViewAnimationOptionCurveLinear completion:^(<span class="name">BOOL</span> finished) &#123;</span><br><span class="line">        kLog(<span class="name">@</span><span class="string">"转场动画完成"</span>)<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>  重绘View视图，任何其子视图的改变或者其自身的改变都会触发转场动画的效果。</p>  <figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">[UIView transitionWithView:self.view duration:2.0 options:</span><br><span class="line">UIViewAnimationOptionCurveLinear animations:<span class="comment">^&#123;</span></span><br><span class="line"><span class="comment">        self.view.alpha = 0.1;</span></span><br><span class="line"><span class="comment">&#125;</span> completion:^(<span class="name">BOOL</span> finished) &#123;</span><br><span class="line">        kLog(@<span class="string">"动画完成"</span>)<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h1 id="三、模态转场"><a href="#三、模态转场" class="headerlink" title="三、模态转场"></a>三、模态转场</h1><p>源控制器A–&gt;目标控制器B</p><h2 id="1-提要"><a href="#1-提要" class="headerlink" title="(1) 提要"></a>(1) 提要</h2><p>可以只使用一个动画控制器Animator，但是要对Present/Dismiss分别实现。模态的类型默认为FullScreen，即在Present时，会移除fromView，而类型设置为Custom时，就会使fromView与toView共存。present时，要把toView加入到container的视图层级，dismiss时，要把fromView从container的视图层级中移除。非交互式转场，需要在动画执行完毕声明complete<code>[transitionContext completeTransition:YES];</code>交互式转场，需要判断转场完成或者取消。</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isCancelled = transitionContext.transitionWasCancelled;</span><br><span class="line"><span class="comment">// 考虑到转场中途可能取消的情况，转场结束后，恢复视图状态。</span></span><br><span class="line">fromView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">toView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br></pre></td></tr></table></figure><p>在模态中，设置将要跳转到的视图控制器(presentedViewController)的transitioningDelegate。充当代理的对象可以是源视图控制器(presentingViewController)，也可以是自己创建的对象，它需要为转场动画提供一个animator对象。animator对象的animateTransition是整个动画的核心逻辑。</p><h2 id="2-无交互"><a href="#2-无交互" class="headerlink" title="(2) 无交互"></a>(2) 无交互</h2><p>设置<strong>目标控制器B</strong>的代理(可以是A，也可以是B)以及模态动画类型(常用UIModalPresentationCustom或UIModalPresentationFullScreen)。</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">YAShareViewController *shareViewController = [[YAShareViewController alloc] init];</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 设置转场代理</span></span><br><span class="line">shareViewController.transitioningDelegate = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">// 设置转场动画类型</span></span><br><span class="line">shareViewController.modalPresentationStyle = <span class="built_in">UIModalPresentationCustom</span>;</span><br><span class="line">[<span class="keyword">self</span> presentViewController:shareViewController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标控制器的代理遵守UIViewControllerTransitioningDelegate协议并相关实现方法</span></span><br><span class="line"><span class="meta">#pragma mark - Transitioning Delegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无交互出现动画</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source &#123;</span><br><span class="line"> YATransitionAnimator *animator = [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPresent];</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> animator;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 无交互消失动画</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed &#123;</span><br><span class="line"> YATransitionAnimator *animator = [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorDismiss];</span><br><span class="line">     <span class="keyword">return</span> animator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理方法中的动画管理者Animator独立存在，可以新建一继承自NSObject且遵守<code>UIViewControllerAnimatedTransitioning</code>协议的对象担任(仅仅遵守协议实现方法即可，不需设置代理)。</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark – Life Cycle</span></span><br><span class="line">   </span><br><span class="line">+ (<span class="keyword">instancetype</span>)transitionAnimatorWithType:(TransitionAnimatorType)transitionAnimatorType &#123;</span><br><span class="line">  YATransitionAnimator *animator = [[YATransitionAnimator alloc] init];</span><br><span class="line">  animator.transitionAnimatorType = transitionAnimatorType;</span><br><span class="line">  <span class="keyword">return</span> animator;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="meta">#pragma mark - AnimatedTransitioning delegate</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//返回动画时间</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//执行动画的地方</span></span><br><span class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 1.获取动画必要元素</span></span><br><span class="line">  <span class="built_in">UIView</span> *containerView = [transitionContext containerView];</span><br><span class="line">  <span class="built_in">UIView</span> *fromView = [transitionContext viewForKey:<span class="built_in">UITransitionContextFromViewKey</span>];</span><br><span class="line">  <span class="built_in">UIView</span> *toView = [transitionContext viewForKey:<span class="built_in">UITransitionContextToViewKey</span>];</span><br><span class="line">  </span><br><span class="line">  toView.origin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>， kScreenHeight);      </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.动画</span></span><br><span class="line">  <span class="comment">// 出场</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>.transitionAnimatorType == TransitionAnimatorPresent) &#123;</span><br><span class="line">      <span class="comment">// 2.添加toView，不一定是addSubview方式</span></span><br><span class="line">      [containerView addSubview:toView];</span><br><span class="line">      [<span class="built_in">UIView</span> animateWithDuration:<span class="number">2.5</span> animations:^&#123;</span><br><span class="line">          toView.origin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>， <span class="number">0</span>);</span><br><span class="line">      &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">          <span class="comment">// 完成</span></span><br><span class="line">          [transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">      &#125;];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 消失</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>.transitionAnimatorType == TransitionAnimatorDismiss) &#123;</span><br><span class="line">      [<span class="built_in">UIView</span> animateWithDuration:<span class="number">2.5</span> animations:^&#123;</span><br><span class="line">          fromView.origin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>， kScreenHeight);</span><br><span class="line">      &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">          <span class="comment">// 2.添加toView，不一定是addSubview方式</span></span><br><span class="line">          [fromView removeFromSuperview];</span><br><span class="line">          <span class="comment">// 完成</span></span><br><span class="line">          [transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-交互"><a href="#3-交互" class="headerlink" title="(3) 交互"></a>(3) 交互</h2><p>(坑多，所以一般不用下列方式，取而代之使用UIPresentationController。)</p><p>在目标控制器的代理方法中，实现交互式代理方法:</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.交互出现动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForPresentation:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[YAInteractiveTransition alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.交互消失动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[YAInteractiveTransition alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一继承自UIPercentDrivenInteractiveTransition的交互组件类(最好这么做，也可以自定义类遵守UIViewControllerInteractiveTransitioning协议，但极不推荐)，实现必须的startInteractiveTransition方法。</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startInteractiveTransition:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-UIPresentationController"><a href="#4-UIPresentationController" class="headerlink" title="(4) UIPresentationController"></a>(4) UIPresentationController</h2><p>iOS8后的新API，极其方便。<br>把管理权限交给UIPresentationController.设置模态动画类型后，只需要在目标控制器的代理方法中实现:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (nullable UIPresentationController *)<span class="selector-tag">presentationControllerForPresentedViewController</span><span class="selector-pseudo">:(UIViewController</span> *)<span class="selector-tag">presented</span> <span class="selector-tag">presentingViewController</span><span class="selector-pseudo">:(nullable</span> <span class="selector-tag">UIViewController</span> *)<span class="selector-tag">presenting</span> <span class="selector-tag">sourceViewController</span><span class="selector-pseudo">:(UIViewController</span> *)<span class="selector-tag">source</span> &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-attr">[[YAPresentationController alloc]</span> <span class="selector-tag">initWithPresentedViewController</span><span class="selector-pseudo">:presented</span> <span class="selector-tag">presentingViewController</span><span class="selector-pseudo">:presenting</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么所有的工作就在YAPresentationController控制器中了。<br>实现相应的方法:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在呈现过渡即将开始的时候被调用的</span></span><br><span class="line">- (<span class="keyword">void</span>)presentationTransitionWillBegin&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 源控制器的View</span></span><br><span class="line">  [<span class="keyword">self</span>.containerView addSubview:<span class="keyword">self</span>.presentingViewController.view];</span><br><span class="line">  <span class="comment">// 背景View</span></span><br><span class="line">  [<span class="keyword">self</span>.containerView addSubview:<span class="keyword">self</span>.backgroundView];</span><br><span class="line">  <span class="comment">// 目标控制器View</span></span><br><span class="line">  [<span class="keyword">self</span>.containerView addSubview:<span class="keyword">self</span>.presentedView];</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//在呈现过渡结束时被调用的</span></span><br><span class="line">- (<span class="keyword">void</span>)presentationTransitionDidEnd:(<span class="built_in">BOOL</span>)completed&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//在退出过渡即将开始的时候被调用的</span></span><br><span class="line">- (<span class="keyword">void</span>)dismissalTransitionWillBegin&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//在退出的过渡结束时被调用的</span></span><br><span class="line">- (<span class="keyword">void</span>)dismissalTransitionDidEnd:(<span class="built_in">BOOL</span>)completed&#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment">// 调整呈现的View的frame</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)frameOfPresentedViewInContainerView&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、NavigationController转场"><a href="#四、NavigationController转场" class="headerlink" title="四、NavigationController转场"></a>四、NavigationController转场</h1><p>设置源控制器的导航控制器的代理，遵守UINavigationControllerDelegate协议，根据交互式或者非交互式实现相应方法.在方法中根据Push或者Pop返回相应的自定义动画控制器(或者交互控制器)。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交互式</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)navigationController:(<span class="built_in">UINavigationController</span> *)navigationController</span><br><span class="line">                                 interactionControllerForAnimationController:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;) animationController &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 非交互式</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)navigationController:(<span class="built_in">UINavigationController</span> *)navigationController</span><br><span class="line">                                          animationControllerForOperation:(<span class="built_in">UINavigationControllerOperation</span>)operation</span><br><span class="line">                                                       fromViewController:(<span class="built_in">UIViewController</span> *)fromVC</span><br><span class="line">                                                         toViewController:(<span class="built_in">UIViewController</span> *)toVC &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Push情况下</span></span><br><span class="line">  <span class="keyword">if</span> (operation == <span class="built_in">UINavigationControllerOperationPush</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPush];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="built_in">UINavigationControllerOperationPop</span>) &#123; <span class="comment">// Pop情况下</span></span><br><span class="line">      <span class="keyword">return</span> [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPop];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、TabBarController转场"><a href="#五、TabBarController转场" class="headerlink" title="五、TabBarController转场"></a>五、TabBarController转场</h1><p>与导航控制器类似，设置源控制器的tabBarController的代理，遵循UITabBarControllerDelegate，实现相应的方法，只不过它既没有模态的Present和Dismiss，也没有导航控制器的Push和Pop，只有一种方式，更加简单，同样，在方法中返回自定义的动画控制器(或者交互控制器)。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)tabBarController: <span class="built_in">UITabBarController</span> *)tabBarControllerinteractionControllerForAnimationController:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationController &#123;&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)tabBarController:(<span class="built_in">UITabBarController</span> *)tabBarController animationControllerForTransitionFromViewController:(<span class="built_in">UIViewController</span> *)fromVC  toViewController:(<span class="built_in">UIViewController</span> *)toVC &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 自定义转场总结。 &lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://blog.chenyalun.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Git/LLDB/Linux等常用命令</title>
    <link href="http://blog.chenyalun.com/2017/02/20/Git:LLDB:Linux%E7%AD%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.chenyalun.com/2017/02/20/Git:LLDB:Linux等常用命令/</id>
    <published>2017-02-20T01:22:34.000Z</published>
    <updated>2017-04-10T03:10:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017.4.3 补充Clang指令<br>2017.4.2 补充</p></blockquote><p align="center"> Git/SVN/Linux/Vim/LLDB等常用、快忘记的命令总结。 </p><a id="more"></a><h1 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h1><pre><code>pod install --verbose --no-repo-update </code></pre><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>源代码管理工具能追踪一个项目从诞生一直到定案的过程，记录一个项目的所有内容变化，方便地查阅特定版本的修订情况。</p><p>Git与SVN的对比:<br>1.Git是分布式，有本地分支，SVN是集中式，无本地分支。<br>2.git合并操作保留原有的提交过程（即保留了合并来源的作者、提交次数、分离提交的内容）。<br>svn合并操作把来源多个提交合并成了一个合并提交。<br>3.git：可以修正提交(在自己的分支)。<br>svn：一旦提交就到服务器上，实际使用中就是不能修改。<br>4.SVN没有tag和真正意义的分支(它的分支是一个完整的目录。且这个目录拥有完整的实际文件)，Git支持。<br>5.Git有暂存区，提交速度快。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>1.清除本地以及远程的.DS_Store文件(修复后添加.gitignore)</p><pre><code>find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch</code></pre><p>2.克隆仓库到本地</p><pre><code>git clone https://github.com/ChenYalun/a.git</code></pre><p>3.添加忽略文件</p><pre><code>git add .gitignore</code></pre><p>4.提交修改</p><pre><code>git commit -m &quot;注释&quot;</code></pre><p>5.推送到远程仓库</p><pre><code>git push YAKit(仓库名称) origin(分支名称)</code></pre><h2 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h2><p>在git中，版本号是一个由SHA1生成的哈希值。<br> 查看git所有命令的帮助</p><pre><code>$ git help 子命令# 要退出帮助信息，按&quot;q&quot;# 翻看下页，按&quot;空格&quot;# 翻看上页，按&quot;CTRL+B&quot;# 要搜索相关文字，按&quot;/&quot;然后输入&quot;相关文字&quot;</code></pre><p>配置以及全局配置</p><pre><code>git config  user.name &quot;chenyalun&quot;git config  user.email iChenYalun@gmail.com git config --global user.name &quot;chenyalun&quot;git config --global user.email iChenYalun@gmail.com  查看当前所有配置git config -l 编辑(全局)配置文件git config -e [--global]</code></pre><p>在当前目录下初始化仓库</p><pre><code>git init</code></pre><p>新建一个目录，将其初始化为Git代码库</p><pre><code>git init [目录]</code></pre><p>添加所有的文件/指定的文件到暂存区</p><pre><code>git add .git add a.h，a.m</code></pre><p>添加目录到暂存区</p><pre><code>git add [dir]</code></pre><p>删除工作区文件</p><pre><code>git rm a.h a.m</code></pre><p>停止追踪指定文件,但是文件会保存在工作区</p><pre><code>git rm --cached a.h</code></pre><p>改名,并且将这个改名放入暂存区</p><pre><code>git mv old.h new.h</code></pre><p>提交文件，添加注释，要使用 -m 参数指定修改的备注信息</p><pre><code>git commit -m &quot;初始化仓库&quot;使用git时，每一次修改都需要添加(add)再提交(commit)，这一点是与svn不一样</code></pre><p>查询代码库当前状态(已加载，未加载等)</p><pre><code>git status</code></pre><p>查看所有版本库日志</p><pre><code>git log</code></pre><p>查看指定文件(a.m)的版本库日志</p><pre><code>git log a.m</code></pre><p>追加提交</p><pre><code>git commit -m &apos;initial commit&apos;git add forgotten_filegit commit --amend</code></pre><p>撤销某次提交</p><pre><code>git revert commitId</code></pre><p>提交时显示所有diff信息</p><pre><code>git commit -v</code></pre><p>使用一次新的commit，替代上一次提交<br>如果代码没有任何新变化，则用来改写上一次commit的提交信息</p><pre><code>git commit --amend -m [message]</code></pre><p>重做上一次commit，并包括指定文件的新变化</p><pre><code>git commit --amend a.h a.m</code></pre><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>恢复暂存区的指定文件到工作区</p><pre><code>git checkout a.h</code></pre><p>恢复某个commit的指定文件到暂存区和工作区</p><pre><code>git checkout [commit] [file]</code></pre><p>恢复暂存区的所有文件到工作区</p><pre><code>git checkout .</code></pre><p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p><pre><code>git reset a.h</code></pre><p>重置暂存区与工作区，与上一次commit保持一致</p><pre><code>git reset --hard</code></pre><p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p><pre><code>git reset [commit]</code></pre><p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p><pre><code>git reset --hard [commit]</code></pre><p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p><pre><code>git reset --keep [commit]</code></pre><p>新建一个commit，用来撤销指定commit<br>后者的所有变化都将被前者抵消，并且应用到当前分支</p><pre><code>git revert [commit]</code></pre><p>暂时将未提交的变化移除，稍后再移入</p><pre><code>git stashgit stash pop</code></pre><p>查看git的总提交次数</p><pre><code>git rev-list head | sort | wc -l</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>列出所有本地分支</p><pre><code>git branch</code></pre><p>列出所有远程分支</p><pre><code>git branch -r</code></pre><p>列出所有本地分支和远程分支</p><pre><code>git branch -a</code></pre><p>新建一个分支，但依然停留在当前分支</p><pre><code>git branch [branch-name]</code></pre><p>新建一个分支，并切换到该分支</p><pre><code>git checkout -b [branch]</code></pre><p>新建一个分支，指向指定commit</p><pre><code>git branch [branch] [commit]</code></pre><p>新建一个分支，与指定的远程分支建立追踪关系</p><pre><code>git branch --track [branch] [remote-branch]</code></pre><p>切换到指定分支，并更新工作区</p><pre><code>git checkout [branch-name]</code></pre><p>切换到上一个分支</p><pre><code>git checkout -</code></pre><p>建立追踪关系，在现有分支与指定的远程分支之间</p><pre><code>git branch --set-upstream [branch] [remote-branch]如:git branch --set-upstream dev remotes/origin/dev,名字保持一致</code></pre><p>合并指定分支到当前分支</p><pre><code>git merge [branch]// 通常使用下面这条:git merge --no-ff [branch]</code></pre><p>选择一个commit，合并进当前分支</p><pre><code>git cherry-pick [commit]</code></pre><p>删除分支</p><pre><code>git branch -d [branch-name]</code></pre><p>删除远程分支</p><pre><code>git push origin --delete [branch-name]git branch -dr [remote/branch]</code></pre><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>添加新的远程仓库</p><pre><code>git remote add &lt;name&gt; &lt;url&gt;</code></pre><p>拉取远程仓库的内容</p><pre><code>git fetch &lt;name&gt; [branchName] //不会合并，只拉取git pull &lt;name&gt;  [branchName] //拉取并且合并</code></pre><p>移除某个远程仓库</p><pre><code>git remote rm &lt;name&gt;</code></pre><p>重命名远程仓库</p><pre><code>git remote rename oldShortName newShortName</code></pre><p>查看远程仓库的url</p><pre><code>git remote -v</code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>列出所有tag</p><pre><code>git tag</code></pre><p>新建一个tag在当前commit</p><pre><code>git tag [tag]</code></pre><p>新建一个tag在指定commit</p><pre><code>git tag [tag] [commit]</code></pre><p>删除本地tag</p><pre><code>git tag -d [tag]</code></pre><p>删除远程tag</p><pre><code>git push origin :refs/tags/[tagName]</code></pre><p>查看tag信息</p><pre><code>git show [tag]</code></pre><p>提交指定tag</p><pre><code>git push [remote] [tag]</code></pre><p>提交所有tag</p><pre><code>git push [remote] --tags</code></pre><p>新建一个分支，指向某个tag</p><pre><code>git checkout -b [branch] [tag]</code></pre><h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><p>下载远程仓库的所有变动</p><pre><code>git fetch [remote]</code></pre><p>显示所有远程仓库</p><pre><code>git remote -v</code></pre><p>显示某个远程仓库的信息</p><pre><code>git remote show [remote]</code></pre><p>增加一个新的远程仓库，并命名</p><pre><code>git remote add [shortname] [url]</code></pre><p>取回远程仓库的变化，并与本地分支合并</p><pre><code>git pull [remote] [branch]</code></pre><p>上传本地指定分支到远程仓库</p><pre><code>git push [remote] [branch]</code></pre><p>强行推送当前分支到远程仓库，即使有冲突</p><pre><code>git push [remote] --force</code></pre><p>推送所有分支到远程仓库</p><pre><code>git push [remote] --all</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>设置git别名</p><pre><code>git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.unstage &apos;reset HEAD --&apos;</code></pre><p>文件权限不纳入版本管理</p><pre><code>git config core.filemode false</code></pre><h1 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h1><h2 id="初步-1"><a href="#初步-1" class="headerlink" title="初步"></a>初步</h2><p>checkout<br>将服务器上最新的代码仓库下载到本地，”只需要做一次”</p><p>update<br>从服务器上将其他人所做的修改下载到本地</p><p>commit<br>将工作提交到服务器</p><p>将文件添加到本地版本库中</p><pre><code>svn add main.c</code></pre><p>将文件提交到服务器的版本库中</p><pre><code>svn ci -m &quot;添加了main.c文件&quot; </code></pre><p>删除文件</p><pre><code>svn rm Person.h</code></pre><p>提交删除</p><pre><code>svn ci -m &quot;删除了文件&quot;注意：不要使用文件管理器直接删除文件</code></pre><p>撤销文件的修改</p><pre><code>svn revert Person.m</code></pre><p>恢复到之前的某个版本</p><pre><code>svn update -r 5svn up</code></pre><p>svn help (查看svn所有命令的帮助)</p><h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><pre><code>svn co http://192.168.1.188/svn/weibo --username=manager --password=managercheckout(co)之后，命令行会记录用户名和密码，后续操作不用再另行指定</code></pre><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><pre><code>命令行格式：svn &lt;subcommand&gt; [options] [args]说明svn 子命令 [选项] [参数]</code></pre><p>提示：</p><pre><code>[中括号]中包含的内容是可选的(子命令缩写)</code></pre><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><pre><code>查看svn日志svn log查看某一个文件的日志svn log filename查看某一个文件某个版本的日志svn log filename@1查看工作目录状态svn st</code></pre><h2 id="SVN-st"><a href="#SVN-st" class="headerlink" title="SVN st"></a>SVN st</h2><p>状态说明：描述文件被添加、删除或其他修改</p><pre><code>&apos; &apos; 没有修改&apos;A&apos; 被添加到本地代码仓库&apos;C&apos; 冲突&apos;D&apos; 被删除&apos;I&apos; 被忽略&apos;M&apos; 被修改&apos;R&apos; 被替换&apos;X&apos; 外部定义创建的版本目录&apos;?&apos; 文件没有被添加到本地版本库内，不在SVN的管理之下&apos;!&apos; 文件丢失或者不完整(不识别该文件)&apos;~&apos; 受控文件被其他文件阻隔&apos;U&apos; 更新最新的代码到本地(本地有文件的情况下)&apos;G&apos; 产生冲突后，更新操作去解决冲突，相当于进行合并</code></pre><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>Trunk<br>目前项目正在开发的版本</p><p>Tags<br>存放已经上线的重大版本</p><p>Branches<br>当发生重大bug或者有新需求时</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ol><li>读权限（r）写权限（w) 可执行权限（x）。</li><li><p>第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。</p></li><li><p>文件类型+所有者+用户组+其他用户。</p></li><li>空格:下一屏 回车:一行 q:退出 /word:搜索word (以及tab的自动补全)</li></ol><h2 id="初步-2"><a href="#初步-2" class="headerlink" title="初步"></a>初步</h2><p>最基本(不阐述)</p><pre><code>cd clear pwd mkdir rmdir who whoami exit ping</code></pre><p>查看</p><pre><code>ls -a(所有) -l(列表) -h(显示大小)</code></pre><p>重定向(结果重定向到一个文件，不存在创建，存在覆盖)</p><pre><code>ls &gt; a.txt </code></pre><p>分屏</p><pre><code>more</code></pre><p>管道(一个命令的结果作为另一个命令的输入)</p><pre><code>ls -a | more</code></pre><p>删除</p><pre><code>rm Dir/ -r 递归地删除，删除文件夹必带rm a.txt -f 强制删除，忽略不存在的文件，无需提示rm b -i 交互式</code></pre><p>链接<br>软链接:软链接不占用磁盘空间，源文件删除则软链接失效。(快捷方式)<br>硬链接:硬链接只能链接普通文件，不能链接目录。两个文件占用相同大小的硬盘空间，不常用。</p><pre><code>ln 源文件 链接文件 (硬链接)ln -s 源文件 链接文件 </code></pre><p>查看或合并</p><pre><code>cat q.txtcat 1.txt 2.txt &gt; 3.txt (重定向)</code></pre><p>文本搜索可正则</p><pre><code>grep -v(选项) &apos;app&apos;(匹配字符串) a.txt(文件名)-v 显示不包含匹配文本的所有行-n 显示匹配行及行号-i 忽略大小写</code></pre><p>查找</p><pre><code>find ./ -name a.txtfind ./ -name &apos;*.txt&apos;find ./ -size +10M(大于10M)</code></pre><p>拷贝</p><pre><code>cp-a     该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。-f     强制-i     交互-r     递归-v     进度</code></pre><p>移动(重命名)</p><pre><code>mv-f -v -i</code></pre><p>归档与压缩</p><pre><code>tar [参数] 打包文件名 文件gzip  [选项]  被压缩文件</code></pre><p>切换用户</p><pre><code>su 不切换目录su - 切换目录su root 到rootsu -root 到root，同时到/root目录</code></pre><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>日历</p><pre><code>cal</code></pre><p>时间</p><pre><code>date</code></pre><p>网卡</p><pre><code>ifconfig</code></pre><p>进程</p><pre><code>ps-a     所有-u     详细状态-x     显示没有控制终端的进程-w     显示加宽-r     正在运行</code></pre><p>动态进程</p><pre><code>topM     内存使用量 排序P     CPU占有率 排序T     运行时间 排序U     可以根据后面输入的用户名来筛选进程K     可以根据后面输入的PID来杀死进程。kill pidq     退出h     获得帮助</code></pre><p>关机重启</p><pre><code>reboot     重启shutdown –r now     重新启动shutdown -h now     立刻关机shutdown -h 20:25     在今天的20:25会关机shutdown -h +10     过十分钟后自动关机init 0     关机init 6     重启</code></pre><p>磁盘空间</p><pre><code>df-a     所有-m     以1024字节为单位显示-t     显示各指定文件系统的磁盘空间使用情况-T     显示文件系统</code></pre><p>目录所占磁盘空间</p><pre><code>du-a     递归-s     显示指定文件或目录占用的数据块-b     以字节为单位显示磁盘占用情况-l     计算所有文件大小，对硬链接文件计算多次</code></pre><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><h2 id="初步-3"><a href="#初步-3" class="headerlink" title="初步"></a>初步</h2><pre><code>i: 插入光标前一个字符 I: 插入行首 a: 插入光标后一个字符 A: 插入行未 o: 向下新开一行，插入行首 O: 向上新开一行，插入行首</code></pre><p>ESC:从插入模式或末行模式进入命令模式</p><p>移动光标:</p><pre><code>h: 左移 j: 下移 k: 上移 l: 右移M: 光标移动到中间行 L: 光标移动到屏幕最后一行行首 G: 移动到指定行，行号 -Gw: 向后一次移动一个字 b: 向前一次移动一个字{: 按段移动，上移 }: 按段移动，下移Ctr-d: 向下翻半屏 Ctr-u: 向上翻半屏Ctr-f: 向下翻一屏 Ctr-b: 向上翻一屏gg: 光标移动文件开头 G: 光标移动到文件末尾</code></pre><p>删除命令:</p><pre><code>x: 删除光标后一个字符，相当于 Del X: 删除光标前一个字符，相当于 Backspacedd: 删除光标所在行，n dd 删除指定的行数 D: 删除光标后本行所有内容，包含光标所在字符 d0: 删除光标前本行所有内容，不包含光标所在字符dw: 删除光标开始位置的字，包含光标所在字符</code></pre><p>撤销命令:</p><pre><code>u: 一步一步撤销 Ctr-r: 反撤销</code></pre><p>重复命令:</p><pre><code>.: 重复上一次操作的命令</code></pre><p>文本行移动:</p><pre><code>&gt;&gt;:文本行右移动&lt;&lt;:文本行左移动</code></pre><p>复制粘贴:</p><pre><code>yy: 复制当前行，n yy 复制 n 行 p: 在光标所在位置向下新开辟一行，粘贴</code></pre><p>可视模式:</p><pre><code>v: 按字符移动，选中文本 V: 按行移动，选中文本可视模式可以配合 d， y， &gt;&gt;， &lt;&lt; 实现对文本块的删除，复制，左右移动</code></pre><p>替换操作:</p><pre><code>r: 替换当前字符 R: 替换当前行光标后的字符</code></pre><p>查找命令:</p><pre><code>/: str查找n: 下一个N：上一个</code></pre><p>替换命令：</p><p>把abc全部替换成123</p><pre><code>末行模式下，将光标所在行的abc替换成123:%s/abc/123/g末行模式下，将第一行至第10行之间的abc替换成123:1， 10s/abc/123/g</code></pre><p>vim里执行 shell 下命令:</p><pre><code>末行模式里输入!，后面跟命令</code></pre><h1 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h1><h2 id="初步-4"><a href="#初步-4" class="headerlink" title="初步"></a>初步</h2><pre><code>help</code></pre><p>输出</p><pre><code>p (int)self.view.subviews.count 基本类型 po self.view 对象</code></pre><p>修改</p><pre><code>expr a = 3expr int $c = 10 声明一个新变量</code></pre><p>调用</p><pre><code>call self.view.backgroundColor = [UIColor redColor]方法无返回值时使用call</code></pre><p>堆栈</p><pre><code>bt 加all可打印所有thread的堆栈</code></pre><p>寻址</p><pre><code>image lookup --address 0x0000000103aca1e1寻找栈地址对应的代码位置</code></pre><h1 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h1><h2 id="初步-5"><a href="#初步-5" class="headerlink" title="初步"></a>初步</h2><p> 编译单个c源文件，并产生一个目标文件  </p><pre><code>cc -c one.c</code></pre><p> 编译多个c源文件，并为每个文件产生一个目标文件  </p><pre><code>cc -c one.c two.c three.c</code></pre><p> 链接单个目标文件产生一个名为a.out的可执行文件  </p><pre><code>cc one.o</code></pre><p> 链接多个目标文件  </p><pre><code>cc one.o two.o three.o</code></pre><p> 编译并链接一个c源文件  </p><pre><code>cc one.c</code></pre><p> 编译并链接多个c源文件  </p><pre><code>cc one.c two.c three.c</code></pre><p> 编译一个c源文件，并把它和现存的目标文件链接在一起  </p><pre><code>cc one.o two.o three.c</code></pre><p> 可执行文件重命名加上“-o name”这个选项  </p><pre><code>cc -o abc one.c</code></pre><p> 执行可执行文件  </p><pre><code>./a.out</code></pre><p>编译C++文件</p><pre><code>clang++ -Wall -g -std=c++11 -stdlib=libc++ fileName.cpp -o targetFileName</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017.4.3 补充Clang指令&lt;br&gt;2017.4.2 补充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt; Git/SVN/Linux/Vim/LLDB等常用、快忘记的命令总结。 &lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://blog.chenyalun.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Git" scheme="http://blog.chenyalun.com/tags/Git/"/>
    
      <category term="SVN" scheme="http://blog.chenyalun.com/tags/SVN/"/>
    
      <category term="Linux" scheme="http://blog.chenyalun.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>iOS应用优化总结</title>
    <link href="http://blog.chenyalun.com/2017/02/14/iOS%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.chenyalun.com/2017/02/14/iOS应用优化总结/</id>
    <published>2017-02-14T11:26:34.000Z</published>
    <updated>2017-03-15T09:17:29.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 一些优化的Tips。 </p><a id="more"></a><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><ul><li><p>UITableView采用注册的方式使用reuseIdentifier<br><code>static NSString *CellIdentifier = @&quot;Cell&quot;;</code>复用 Cell 与各个 Section 的 Header 和 Footer。<br>复用 Cell 时， storyboard 中的 cell 设置 reuseIdentifier 完毕即可，无需注册，xib 与 class 自定义的cell 需要设置 reuseIdentifier 而且要注册。</p></li><li><p>使用UITableView+FDTemplateLayoutCell<br>优点:预缓存机制/自动的缓存失效机制/根据 autolayout 约束自动计算高度。<br>注意:cacheByKey比cacheByIndexPath 更为高效。</p> <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> [tableView <span class="string">fd_heightForCellWithIdentifier:</span>reuseIdentifier <span class="string">cacheByIndexPath:</span>indexPath <span class="string">configuration:</span>^(YACommentTableViewCell *cell) &#123;</span><br><span class="line">       cell.comment = self.comments[indexPath.section][indexPath.row];</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不缓存高度</span></span><br><span class="line"><span class="keyword">return</span> [tableView <span class="string">fd_heightForCellWithIdentifier:</span>reuseIdentifier <span class="string">configuration:</span>^(YACommentTableViewCell *cell)&#123;</span><br><span class="line">    cell.comment = self.comments[indexPath.section][indexPath.row];</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br><span class="line">     </span><br><span class="line"><span class="comment">// 更高效，但是当高度变化时，需要手动清除缓存</span></span><br><span class="line">YACommentModel *model = self.comments[indexPath.section][indexPath.row];</span><br><span class="line"><span class="keyword">return</span> [tableView <span class="string">fd_heightForCellWithIdentifier:</span>reuseIdentifier <span class="string">cacheByKey:</span>model.ID <span class="string">configuration:</span>^(id cell) &#123;</span><br><span class="line">     cell.comment = self.comments[indexPath.section][indexPath.row];</span><br><span class="line">&#125;];</span><br><span class="line">     </span><br><span class="line"><span class="comment">// 移除 key 对应的高度缓存</span></span><br><span class="line">[tableView.fd_keyedHeightCache <span class="string">invalidateHeightForKey:</span>key];</span><br><span class="line"><span class="comment">// 移除所有高度缓存</span></span><br><span class="line">[tableView.fd_keyedHeightCache invalidateAllHeightCache];</span><br></pre></td></tr></table></figure></li></ul><ul><li>设置 opaque 为YES，尽量把 view 设置为透明。</li></ul><ul><li><p>尽量不使用<code>cellForRowAtIndexPath:</code>，用一次然后缓存结果。</p></li><li><p>尝试缓存。</p></li><li><p>保证XIB文件的小巧灵活。</p></li><li><p>预处理懒加载。</p></li><li><p>处理内存警告。</p></li><li><p>单一固定的情况下，使用<code>rowHeight</code>， <code>sectionFooterHeight</code>和 <code>sectionHeaderHeight</code>来设定固定的高，而不是请求delegate。</p></li><li><p>使用</p><figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">shadowPath，<span class="keyword">view</span>.layer.shadowPath = [[UIBezierPath bezierPathWithRect:<span class="keyword">view</span>.bounds] CGPath]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 而不是:</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">view</span>.layer.shadowOffset = CGSizeMake(-<span class="number">1</span>， <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">view</span>.layer.shadowRadius = <span class="number">1.0</span>f<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">view</span>.layer.shadowOpacity = <span class="number">0.1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul><li><p>合理开线程，主线程占1M，子线程占512K。UI 操作和 DataSource 的操作一定在主线程。DB 操作、日志记录、网络回调都在各自的固定线程。</p></li><li><p>选择合适的容器，减少subviews的数量。<br>NSArrayi:有序的。能搞按照索引快速查找元素。按照值查找很慢，插入和删除很慢。<br>NSDictionary:无序的。键值对存储。按照key可以快速查找。<br>NSSet: 无序的。按照值可以快速查找，插入和删除很快。</p></li><li><p>正确使用 <code>imageNamed:</code> 与 <code>imageWithContentsOfFile:</code>，<code>imageNamed:</code>的优点是当加载时会缓存图片，所以当图片会频繁的使用时，用<code>imageNamed:</code>。<code>imageWithContentsOfFile：</code>仅加载图片，图像数据不会缓存，对于较大的图片以及使用情况较少时，就可以用该方法，降低内存消耗。</p></li><li><p>慎用 NSDateFormatter和NSCalendar，缓存 NSDateFormatter 的结果。<br>Creating a date formatter is not a cheap operation. If you are likely to use a formatter frequently， it is typically more efficient to cache a single instance than to create and dispose of multiple instances. One approach is to use a static variable.</p></li></ul><ul><li><p>在iOS 7、macOS 10.9及以上系统版本，NSDateFormatter都是线程安全的。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>， <span class="keyword">strong</span>) <span class="built_in">NSDateFormatter</span> *formatter;</span><br><span class="line">   </span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)formatter &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *formatter;</span><br><span class="line"> <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"> <span class="built_in">dispatch_once</span>(&amp;onceToken， ^&#123;</span><br><span class="line">     _formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">     _formatter.dateFormat = <span class="string">@"EEE MMM dd HH:mm:ss Z yyyy"</span>; <span class="comment">// twitter date format</span></span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">return</span> formatter</span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>寻找 (NSDate *)dateFromString:(NSString )string 的替换品。下面是ISO8601 转成 NSDate 的 NSDateFormatter 的最著名替代品，也可以使用开源作品:NSDate+SSToolkitAdditions。</p> <figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">  //<span class="comment">#include &lt;time.h&gt;</span></span><br><span class="line">time_t t;</span><br><span class="line">struct tm tm;</span><br><span class="line">strptime([iso8601String cStringUsingEncoding:NSUTF8StringEncoding]， <span class="string">"%Y-%m-%dT%H:%M:%S%z"</span>， &amp;tm);</span><br><span class="line">tm.tm_isdst = -<span class="number">1</span>;</span><br><span class="line">t = mktime(&amp;tm);</span><br><span class="line">[NSDate dateWithTimeIntervalSince197<span class="number">0</span>:t + [[NSTimeZone localTimeZone] secondsFromGM</span><br><span class="line">T]];</span><br></pre></td></tr></table></figure></li><li><p>不要随意使用 <code>NSLog()</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="comment">// Only log when attached to the debugger</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> DLog(...) NSLog(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> DLog(...) <span class="comment">/* */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// Always log， even in production</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALog(...) NSLog(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure></li><li><p>当试图获取磁盘中一个文件的属性信息时，使用 <code>[NSFileManager attributesOfItemAtPath:error:]</code>会浪费大量时间读取可能根本不需要的附加属性。这时可以使用 stat 代替 NSFileManager，直接获取文件属性：</p> <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">  <span class="keyword">struct</span> stat statbuf;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cpath = [filePath fileSystemRepresentation];</span><br><span class="line">  <span class="keyword">if</span> (cpath &amp;&amp; stat(cpath， &amp;statbuf) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">NSNumber</span> *fileSize = [<span class="built_in">NSNumber</span> numberWithUnsignedLongLong:statbuf.st_size];</span><br><span class="line">      <span class="built_in">NSDate</span> *modificationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:statbuf.st_mtime];</span><br><span class="line">      <span class="built_in">NSDate</span> *creationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:statbuf.st_ctime];</span><br><span class="line">      <span class="comment">// etc</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>MLeakFinder 能在开发阶段，把内存泄露问题暴露无遗，减少了很多潜在的性能问题.    原理:在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 view，view 的 subviews 等等是否还存在。</p></li><li><p>接入bugly。</p></li><li><p>创造圆形图片避免使用以下方式(会造成离屏渲染):</p> <figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">view</span>.layer.cornerRadius = <span class="built_in">view</span>.<span class="built_in">width</span> * <span class="number">0.5</span>;</span><br><span class="line">   <span class="built_in">view</span>.layer.masksToBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>圆形图片</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">UIBezierPath *clipPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(<span class="number">0</span>， <span class="number">0</span>， <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">width</span>， <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">height</span>)] ;</span><br><span class="line">     </span><br><span class="line">[clipPath addClip] ;</span><br><span class="line">    </span><br><span class="line">[<span class="built_in">image</span> drawAtPoint:CGPointZero] ;</span><br><span class="line">     </span><br><span class="line"><span class="built_in">image</span> = UIGraphicsGetImageFromCurrentImageContext() ;</span><br><span class="line"> </span><br><span class="line">UIGraphicsEndImageContext() ;</span><br><span class="line">     </span><br><span class="line"><span class="built_in">return</span> <span class="built_in">image</span> ;</span><br></pre></td></tr></table></figure></li><li><p>设置Label的圆角。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不要这么做：label.backgroundColor = aColor </span></span><br><span class="line"><span class="comment">// 以及不要在 IB 里为 label 设置背景色</span></span><br><span class="line"><span class="selector-tag">label</span><span class="selector-class">.layer</span><span class="selector-class">.backgroundColor</span> = aColor</span><br><span class="line"><span class="selector-tag">label</span><span class="selector-class">.layer</span><span class="selector-class">.cornerRadius</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>指定图片的宽高为整数，否则造成离屏渲染。</p></li><li><p>cell当中不要动态的添加子控件，选中适时地显示与隐藏。</p></li><li><p>当控件非常多时，把不需要与用户进行交互的控件.通过异步绘制成一张图片，把图片添加到cell当中。</p></li><li>将 UIView 的属性 clearsContextBeforeDrawing 设置为 NO 在多数情况下可以提高绘制性能，尤其是在用绘制代码实现了一个定制 view 的时候。</li><li><p>设置阴影。</p><figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="keyword">view</span>.layer.shadowPath = [[UIBezierPath bezierPathWithRect:<span class="keyword">view</span>.bounds] CGPath]<span class="comment">;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 而不是</span></span><br><span class="line"><span class="keyword">view</span>.layer.shadowOffset = CGSizeMake(-<span class="number">1.0</span>f， <span class="number">1.0</span>f)<span class="comment">;</span></span><br><span class="line"><span class="keyword">view</span>.layer.shadowRadius = <span class="number">5.0</span>f<span class="comment">;</span></span><br><span class="line"><span class="keyword">view</span>.layer.shadowOpacity = <span class="number">0.6</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>通常图层的以下属性将会触发离屏渲染：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">阴影（UIView<span class="selector-class">.layer</span><span class="selector-class">.shadowOffset</span>/shadowRadius/…）</span><br><span class="line">圆角（当 UIView<span class="selector-class">.layer</span><span class="selector-class">.cornerRadius</span> 和 UIView<span class="selector-class">.layer</span><span class="selector-class">.maskToBounds</span> 一起使用时）</span><br><span class="line">图层蒙板</span><br></pre></td></tr></table></figure></li><li><p>使用 Autorelease Pool，当需要在代码中创建许多临时对象时，可以显式的使用 Autorelease Pool。</p></li><li><p>使用IMP。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 一些优化的Tips。 &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.chenyalun.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.chenyalun.com/tags/iOS/"/>
    
      <category term="优化" scheme="http://blog.chenyalun.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS常用设计模式</title>
    <link href="http://blog.chenyalun.com/2017/02/11/iOS%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.chenyalun.com/2017/02/11/iOS常用设计模式/</id>
    <published>2017-02-11T07:36:34.000Z</published>
    <updated>2017-03-15T09:09:45.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 关于设计模式。 </p><a id="more"></a><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><ul><li><p>原型模式是通过克隆已有的对象来创建新的对象，已有的对象即为原型。(Objective-C中的深复制)</p></li><li><p>优点:将创建对象的代码隐藏，屏蔽初始化的具体细节，避免重复耗时的过程。</p></li><li><p>当需要创建一个新的实例，但不想依赖初始化器，使用此模式。</p></li><li><p>注意:深复制与浅复制的问题。浅复制:复制对象的引用，深复制:复制对象本身。不可变对象的copy操作是浅复制，其他情况是深复制，但是集合类对象即便是深复制，也是复制集合类对象自身，里面的元素并未复制，或者说是单层深复制，而要对集合类对象进行完全彻底的复制，归档可以解决。</p></li><li><p>应用:实现NSCopying协议并保证类的基类是NSObject。</p></li><li><p>实现方法: 根类遵循NSCopying协议，重写copyWithZone方法，创建一个复制方法Operation，方便自身以及增加属性的子类再次复制。</p></li><li><p>YAObject担当根类，遵循NSCopying协议，重写copyWithZone方法，提供复制接口copyWithObject，方便自身以及子类复制.YAPerson增加两个属性，且类型是集合类。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAObject</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"><span class="comment">/** 年龄 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="comment">/** 姓名 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/** 复制操作 */</span></span><br><span class="line">- (<span class="keyword">void</span>)copyWithObject:(<span class="built_in">NSObject</span> *)object;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAPerson</span> : <span class="title">YAObject</span></span></span><br><span class="line"><span class="comment">/** 书籍 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">strong</span>) <span class="built_in">NSArray</span> *books;</span><br><span class="line"><span class="comment">/** 朋友 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *friends;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>copyWithZone操作中，[self class]使子类也能调用此方法，子类中，重写copyWithObject操作，当有集合类元素的时候，不能单纯的[array copy]，这样仅是复制了集合元素自身，却没有复制集合中的元素，是单层深复制，要copyItems。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="meta">@implementation</span> <span class="type">YAObject</span></span><br><span class="line"><span class="comment">// 实现的时候用copyWithZone，调用的时候用copy，最顶层的根类重写该方法，子类调用但不得重写</span></span><br><span class="line">- (id)copyWithZone:(<span class="type">NSZone</span> *)zone &#123;</span><br><span class="line">    <span class="type">YAObject</span> *<span class="class"><span class="keyword">object</span> </span>= [[[self <span class="class"><span class="keyword">class</span>] <span class="title">allocWithZone</span></span>:zone] init];</span><br><span class="line">    <span class="comment">// 把自己copy后赋予object</span></span><br><span class="line">    [self copyWithObject:<span class="class"><span class="keyword">object</span>]</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">object</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自身以及子类实现该方法以赋值给object</span></span><br><span class="line">- (void)copyWithObject:(<span class="type">YAObject</span> *)<span class="class"><span class="keyword">object</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">object</span>.<span class="title">name</span> </span>= self.name;</span><br><span class="line">    <span class="class"><span class="keyword">object</span>.<span class="title">age</span> </span>= self.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">YAPerson</span></span><br><span class="line"><span class="comment">// 又增加了属性</span></span><br><span class="line"><span class="comment">// 自身以及子类实现该方法以赋值给object</span></span><br><span class="line">- (void)copyWithObject:(<span class="type">YAPerson</span> *)<span class="class"><span class="keyword">object</span> </span>&#123;</span><br><span class="line">    [<span class="keyword">super</span> copyWithObject:<span class="class"><span class="keyword">object</span>]</span>;</span><br><span class="line">    <span class="class"><span class="keyword">object</span>.<span class="title">books</span> </span>= [[<span class="type">NSArray</span> alloc] initWithArray:self.books copyItems:<span class="type">YES</span>];</span><br><span class="line">    <span class="class"><span class="keyword">object</span>.<span class="title">friends</span> </span>= [[<span class="type">NSMutableArray</span> alloc] initWithArray:self.friends copyItems:<span class="type">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">YAObject *object = [[YAObject alloc] init]<span class="comment">;</span></span><br><span class="line">object.name = @<span class="string">"Aaron"</span><span class="comment">;</span></span><br><span class="line">object.age = <span class="number">22</span><span class="comment">;</span></span><br><span class="line">kLog(@<span class="string">"%@--%ld"</span>，object.name， object.age)<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">YAObject *objectB = [object copy]<span class="comment">;</span></span><br><span class="line">kLog(@<span class="string">"%@--%ld"</span>，objectB.name， objectB.age)<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">YAPerson *person = [[YAPerson alloc] init]<span class="comment">;</span></span><br><span class="line">person.name = @<span class="string">"A"</span><span class="comment">;</span></span><br><span class="line">person.age = <span class="number">25</span><span class="comment">;</span></span><br><span class="line">person.<span class="keyword">books </span>= @[@<span class="string">"V"</span>，@<span class="string">"T"</span>，@<span class="string">"N"</span>]<span class="comment">;</span></span><br><span class="line">person.friends = [NSMutableArray arrayWithObjects:@<span class="string">"QQ"</span>，@<span class="string">"WeChat"</span>， nil]<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">YAPerson *personB = [person copy]<span class="comment">;</span></span><br><span class="line">kLog(@<span class="string">"%@-%ld-%@-%@"</span>，personB.name， personB.age， personB.<span class="keyword">books， </span>personB.friends)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><ul><li><p>单例模式保证某个类型的对象在应用中只存在一个实例。</p></li><li><p>封装共享资源，管理代表现实世界资源的对象。</p></li><li><p>当进一步创建对象却不能增加现实中的可用资源，或者希望对象只存在一个实例时使用。</p></li><li><p>要求该实例无法真正意义上被复制克隆。</p></li><li><p>实现:考虑多线程，重写alloc init方法。</p></li><li><p>考虑调用copy等方法，不遵循NSCopying协议，重写Copy等方法。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YASingleton</span> : <span class="title">NSObject</span></span></span><br><span class="line">  <span class="comment">// 接口</span></span><br><span class="line">  + (<span class="keyword">instancetype</span>)sharedSingleton;</span><br><span class="line">  <span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">@implementation</span> <span class="title">YASingleton</span></span></span><br><span class="line">     <span class="comment">// 重写alloc  init</span></span><br><span class="line">     <span class="keyword">static</span> YASingleton *singleton = <span class="literal">nil</span>;</span><br><span class="line">     + (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">         <span class="keyword">if</span> (singleton == <span class="literal">nil</span>) &#123;</span><br><span class="line">             <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">             <span class="built_in">dispatch_once</span>(&amp;onceToken， ^&#123;</span><br><span class="line">                 singleton = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> singleton;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">         <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">         <span class="built_in">dispatch_once</span>(&amp;onceToken， ^&#123;</span><br><span class="line">             singleton = [<span class="keyword">super</span> init];</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">return</span> singleton;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 考虑复制的情况</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      不建议</span></span><br><span class="line"><span class="comment">     - (id)mutableCopyWithZone:(struct _NSZone *)zone &#123;</span></span><br><span class="line"><span class="comment">         return singleton;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     - (id)copyWithZone:(struct _NSZone *)zone &#123;</span></span><br><span class="line"><span class="comment">         return singleton;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     - (<span class="keyword">id</span>)<span class="keyword">copy</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> singleton;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     - (<span class="keyword">id</span>)mutableCopy &#123;</span><br><span class="line">         <span class="keyword">return</span> singleton;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 接口</span></span><br><span class="line">     + (<span class="keyword">instancetype</span>)sharedSingleton &#123;</span><br><span class="line">         <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>除了使用GCD，也可以使用互斥锁。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 互斥锁的形式</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        singleton = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打印地址，验证：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">YASingleton *sing = [YASingleton <span class="keyword">sharedSingleton];</span></span><br><span class="line"><span class="keyword">YASingleton </span>*singB = [sing copy]<span class="comment">;</span></span><br><span class="line">YASingleton *singC = [sing mutableCopy]<span class="comment">;</span></span><br><span class="line">YASingleton *singD = [[YASingleton alloc] init]<span class="comment">;</span></span><br><span class="line">kLog(@<span class="string">"%p-%p-%p-%p"</span>，sing， singB， singC， singD)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>似乎封装成宏更好一点：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例</span></span><br><span class="line"><span class="meta">#define YASingH(Name) + (instancetype)shared##Name;</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#define YASingM(Name) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instace = <span class="literal">nil</span>; \</span><br><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">if</span> (_instace == <span class="literal">nil</span>) &#123; \</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken， ^&#123; \</span><br><span class="line">_instace = [<span class="keyword">super</span> allocWithZone:zone]; \</span><br><span class="line">&#125;); \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">return</span> _instace; \</span><br><span class="line">&#125; \</span><br><span class="line">\</span><br><span class="line">- (<span class="keyword">id</span>)init \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken， ^&#123; \</span><br><span class="line">_instace = [<span class="keyword">super</span> init]; \</span><br><span class="line">&#125;); \</span><br><span class="line"><span class="keyword">return</span> _instace; \</span><br><span class="line">&#125; \</span><br><span class="line">\</span><br><span class="line">+ (<span class="keyword">instancetype</span>)shared<span class="meta">##Name \</span></span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init]; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">instancetype</span>)<span class="keyword">copy</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">return</span> _instace; \</span><br><span class="line">&#125; \</span><br><span class="line">\</span><br><span class="line">- (<span class="keyword">instancetype</span>)mutableCopy \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">return</span> _instace; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h1><ul><li><p>适配器使得两个不兼容的API组件协同工作，用于连接两种不同种类的对象。</p></li><li><p>解决无法修改或者不修改源代码的组件的兼容性问题。</p></li><li><p>类适配器:适配器继承主功能组件，遵循适配接口协议。</p></li><li><p>对象适配器:适配器持有主功能组件(作为成员变量)，遵循适配接口协议。</p></li><li><p>类适配器的实现</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAMac</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// Mac自带显示接口</span></span><br><span class="line">- (<span class="keyword">void</span>)show;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 一般显示器DVI接口</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YADVI</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)dvi;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 适配器:继承自Mac，有显示的功能，遵循YADVI协议，可以显示到一般显示器上</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAMacDVIAdapter</span> : <span class="title">YAMac</span> &lt;<span class="title">YADVI</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAMac</span></span></span><br><span class="line">- (<span class="keyword">void</span>)show &#123;</span><br><span class="line">  kLog(<span class="string">@"Mac自带显示接口"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 适配器实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAMacDVIAdapter</span></span></span><br><span class="line">   </span><br><span class="line">- (<span class="keyword">void</span>)dvi &#123;</span><br><span class="line">  [<span class="keyword">super</span> show]; <span class="comment">// 可以显示内容</span></span><br><span class="line">  kLog(<span class="string">@"可以连接到一般的显示器"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 具体使用，调用接口即可</span></span><br><span class="line">YAMacDVIAdapter *adapter = [[YAMacDVIAdapter alloc] init];</span><br><span class="line">[adapter dvi];</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当不再继承主功能组件，而是把它作为属性持有的时候，便是对象适配器。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAMac</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// Mac自带显示接口</span></span><br><span class="line">- (<span class="keyword">void</span>)show;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 一般显示器DVI接口</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YADVI</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)dvi;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 适配器:遵循YADVI协议，可以显示到一般显示器上，拥有Mac属性，有显示的功能</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAMacDVIAdapter</span> : <span class="title">NSObject</span> &lt;<span class="title">YADVI</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">strong</span>) YAMac *mac;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAMac</span></span></span><br><span class="line">- (<span class="keyword">void</span>)show &#123;</span><br><span class="line">  kLog(<span class="string">@"Mac自带显示接口"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 适配器实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAMacDVIAdapter</span></span></span><br><span class="line">   </span><br><span class="line">- (<span class="keyword">void</span>)dvi &#123;</span><br><span class="line">  <span class="keyword">self</span>.mac = [[YAMac alloc] init];</span><br><span class="line">  [<span class="keyword">self</span>.mac show];</span><br><span class="line">  kLog(<span class="string">@"可以连接到一般的显示器"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 然而.使用方式没有改变</span></span><br><span class="line">YAMacDVIAdapter *adapter = [[YAMacDVIAdapter alloc] init];</span><br><span class="line">[adapter dvi];</span><br></pre></td></tr></table></figure></li></ul><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><ul><li><p>MVC 能使整个应用结构化，使应用的各个部分更易开发测试维护。</p></li><li><p>M是指数据模型，V是指用户界面，C则是控制器。</p></li><li><p>模型对象封装了应用程序的数据，并定义操控和处理该数据的逻辑和运算.视图对象是应用程序中用户可以看见的对象.控制器对象解释在视图对象中进行的用户操作，并将新的或更改过的数据传达给模型对象。</p></li><li><p>Model 和 View 永远不能相互通信，只能通过Controller传递。</p></li><li><p>Controller 与 Model 的通信: Notification 和 KVO。</p></li><li><p>Controller 与 View 的通信:outlet， action， 数据源，代理等。</p></li></ul><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><ul><li><p>MVC升级版</p></li><li><p>ViewController 从 ViewModel 层中读取数据然后显示在View上。</p></li><li><p>ViewController与ViewModel的通信:Block回调和ReactiveCocoa。</p></li><li><p>….// 待补充</p></li></ul><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><ul><li><p>一个代理对象可以代表其他资源。</p></li><li><p>当A对象要监听B对象的一些行为时，A成为B的代理.当B对象要通知A对象一些事情时(消息传递)，A成为B的代理。</p></li><li><p>遵守协议，设置代理，实现方法。</p></li><li><p>实现:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YACodeDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">void</span>)code;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAMan</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 代理属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>， <span class="keyword">weak</span>) <span class="keyword">id</span> delegate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YACoder</span> : <span class="title">NSObject</span> &lt;<span class="title">YACodeDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAMan</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setup &#123;</span><br><span class="line">  <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(code)]) &#123;</span><br><span class="line">      <span class="comment">// 告诉代理要做的事</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YACoder</span></span></span><br><span class="line">- (<span class="keyword">void</span>)code &#123;</span><br><span class="line">  <span class="comment">// 实现必须实现的方法</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 具体使用时，设置代理</span></span><br><span class="line">YAMan *man = [[YAMan alloc] init];</span><br><span class="line">YACoder *coder = [[YACoder alloc] init];</span><br><span class="line">man.delegate = coder;</span><br></pre></td></tr></table></figure></li></ul><h1 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h1><ul><li><p>观察者模式定义了一种一对多的依赖关系，让一个或者多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 </p></li><li><p>一个对象需要在不依赖另一个对象的情况下，接收到另一个对象的通知。</p></li><li><p>实现:通知中心.假定A是观察者，B是被观察者。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在A中</span></span><br><span class="line"><span class="comment">// 添加自己为观察者，通知产生执行show方法</span></span><br><span class="line">[[NSNotificationCenter defaultCenter] <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(show) <span class="string">name:</span>@<span class="string">"show"</span> <span class="string">object:</span>nil];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在自己即将销毁的那刻移除通知</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">[[NSNotificationCenter defaultCenter] <span class="string">removeObserver:</span>self];</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在B中，负责适时发送通知</span></span><br><span class="line"><span class="comment">// 发出通知</span></span><br><span class="line">[[NSNotificationCenter defaultCenter] <span class="string">postNotificationName:</span>@<span class="string">"show"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>nil];</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>键值观察(某个属性值改变时通知被观察者)</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为view的alpha属性添加自己为观察者</span></span><br><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">[view addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"alpha"</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当自身销毁时为view移除观察</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.view removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"alpha"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当alpha属性改变，就会进入</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>，<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 关于设计模式。 &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.chenyalun.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.chenyalun.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>树与二叉树</title>
    <link href="http://blog.chenyalun.com/2017/01/24/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blog.chenyalun.com/2017/01/24/树与二叉树/</id>
    <published>2017-01-24T08:26:34.000Z</published>
    <updated>2017-04-21T04:43:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017.04.21 更正错误</p></blockquote><p align="center"> 二叉树。 </p><a id="more"></a><h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><p>树形结构是由节点和节点间的联系构成，最重要的特征是:每个节点都只有一个前驱，一个节点可以有多个后继。从一个树形结构里的任意两个节点出发，通过后继关系可达的节点集合:相互之间或者互不相交，或者有子集关系。</p><p>树(tree)是具有递归性质的结构，所以树的定义也是递归的。一棵树是 n (n≥0) 个节点的有限集 T(可为空)，T 非空时满足:有且仅有一个特殊的称为根的节点 r， 根节点外的其余节点划分为m(m ≥ 0)个互不相交的非空有限集。节点个数为 0 的树称为空树。一棵树可以只有根但没有子树(m = 0)，这是一棵单节点的树。</p><p>二叉树是一种树形结构，特点是与每个节点关联的子节点至多有两个(可为 0, 1, 2)。每个节点的子节点关联有位置关系，二叉树的两棵子树分别称作它的(其根的)左子树和右子树。<br>二叉树不是树的特殊情形:<br>1.<strong>其子树分左子树和右子树</strong>，即使只有 一棵子树也要明确说明是左还是右。<br>2.树中结点的最大度数没有限制，而二叉树结点的最大度数为2。<br>3.树的结点个数至少为 1，而二叉树的结点个数可以为 0</p><p>完全二叉树:除最下两层外，其余节点度数都是 2(显然都不是叶节点)，如果最底层的节点不满，则所有空位都在右边，左边没有空位。</p><p>满二叉树:树中每个分支节点(非叶节点)都有两棵非空子树。<br>扩充二叉树(由已有非空二叉树生成的一种二叉树): 是原二叉树的最小节点扩充，使原树中所有节点的度数都变成 2。扩充二叉树新增节点(称为其外部节点)的个数比原树节点(称为其内 部节点)的个数多 1。</p><p>深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。</p><ul><li>边:从父节点到子节点的连线(注意，边有方向)</li><li>兄弟节点:父节点相同的节点互为兄弟节点</li><li>树叶、分支节点:没有子节点的节点称为树叶，树中的其余节点称为分支节点</li><li>度数:一个节点的子节点个数称为该节点的度数，显然树叶的度数为 0</li><li>一棵树的度数就是它里面度数最大的节点的度数</li><li>从一个祖先节点到其子孙节点的一系列边称为树中一条路径</li><li>路径中<strong>边的条数</strong>称为路径长度，认为每个节点到自身有长 0 的路径</li><li>树根到节点的路径长度是该节点的层数</li><li>~~树的高度或深度是树中节点的最大层数(最长路径的长度)加 1(或者说是节点有多少排) ~~  </li><li>树的高度定义为层数最大的叶结点的层数加1</li><li>树的深度定义为层数最大的叶结点的层数(或者说是节点有多少排,深度=层数)</li></ul><p>部分教材定义不同.</p><p>重要!</p><ul><li>一棵深度为k，且有 2^k -1 个节点称之为满二叉树</li><li>一棵深度为k的完全二叉树，最少有 2^(k-1) 个节点，最多有2^k - 1个节点</li><li>对任何一棵二叉树T，如果其终端节点数为 n0 ，度为2的节点数为 n2 ，则 n0 = n2 + 1  </li></ul><h1 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h1><ol><li>非空二叉树第 i 层上至多有 2i 个节点(i ≥ 0)</li><li>高度为 k 的二叉树至多有 2k-1 个节点(k ≥ 0)</li><li>对任何非空二叉树 T，若其叶节点个数为 n0，度数为 2 的节点 个数为 n2，则n0 = n2 + 1</li><li>n个节点的完全二叉树的高度k=⎡log2(n+1)⎤</li><li>满二叉树里的叶节点比分支节点多一个</li></ol><h1 id="二叉树的list实现"><a href="#二叉树的list实现" class="headerlink" title="二叉树的list实现"></a>二叉树的list实现</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BTree</span><span class="params">(data,left,right)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span> [data,left,right]</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断为空</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(btree)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span> btree == []</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回根(父)节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">root</span><span class="params">(btree)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span> btree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回左节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(btree)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span> btree[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回右节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span><span class="params">(btree)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span> btree[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置根节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setRoot</span><span class="params">(btree,data)</span></span><span class="symbol">:</span></span><br><span class="line">btree[<span class="number">0</span>] = data</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置左节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setLeft</span><span class="params">(btree,data)</span></span><span class="symbol">:</span></span><br><span class="line">btree[<span class="number">1</span>] = data</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置右节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setRight</span><span class="params">(btree,data)</span></span><span class="symbol">:</span></span><br><span class="line">btree[<span class="number">2</span>] = data</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">btree = BTree(<span class="number">1</span>,BTree(<span class="number">2</span>,[],[]),BTree(<span class="number">4</span>,[],[]))</span><br></pre></td></tr></table></figure><h1 id="二叉树的类实现"><a href="#二叉树的类实现" class="headerlink" title="二叉树的类实现"></a>二叉树的类实现</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,data = <span class="number">0</span>,left = <span class="number">0</span>,right = <span class="number">0</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.data = data <span class="comment">#数据域</span></span><br><span class="line"><span class="keyword">self</span>.left = left <span class="comment">#左节点</span></span><br><span class="line"><span class="keyword">self</span>.right = right <span class="comment">#右节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinTree</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,root = <span class="number">0</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.root = root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.root == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#先序遍历:根左右</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(<span class="keyword">self</span>,treeRoot)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">if</span> treeRoot == <span class="number">0</span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">print(treeRoot.data)</span><br><span class="line"><span class="keyword">self</span>.preorder(treeRoot.left)</span><br><span class="line"><span class="keyword">self</span>.preorder(treeRoot.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">#中序遍历:左根右</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(<span class="keyword">self</span>,treeRoot)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">if</span> treeRoot == <span class="number">0</span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">self</span>.inorder(treeRoot.left)</span><br><span class="line">print(treeRoot.data)</span><br><span class="line"><span class="keyword">self</span>.inorder(treeRoot.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">#后序遍历:左右根</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(<span class="keyword">self</span>,treeRoot)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">if</span> treeRoot == <span class="number">0</span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">self</span>.postorder(treeRoot.left)</span><br><span class="line"><span class="keyword">self</span>.postorder(treeRoot.right)</span><br><span class="line">print(treeRoot.data)</span><br><span class="line"></span><br><span class="line">tree1 = TreeNode(<span class="number">10</span>)</span><br><span class="line">tree2 = TreeNode(<span class="number">11</span>)</span><br><span class="line">tree3 = TreeNode(<span class="number">13</span>,tree1,tree2)</span><br><span class="line">tree4 = TreeNode(<span class="number">14</span>,tree3)</span><br><span class="line">tree5 = TreeNode(<span class="number">15</span>,tree4)</span><br><span class="line">root = TreeNode(<span class="number">17</span>,tree5)</span><br><span class="line"></span><br><span class="line">btree2 = BinTree(root)</span><br><span class="line"></span><br><span class="line">btree2.preorder(btree2.root)</span><br><span class="line">btree2.inorder(btree2.root)</span><br><span class="line">btree2.postorder(btree2.root)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017.04.21 更正错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt; 二叉树。 &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.chenyalun.com/categories/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/categories/Python/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://blog.chenyalun.com/tags/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://blog.chenyalun.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列的实现</title>
    <link href="http://blog.chenyalun.com/2017/01/22/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.chenyalun.com/2017/01/22/栈与队列的实现/</id>
    <published>2017-01-22T06:06:58.000Z</published>
    <updated>2017-03-15T09:26:30.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 栈与队列。 </p><a id="more"></a><p>栈(stack)，又称堆栈，是一种容器，可存入数据元素、 访问元素、删除元素。</p><p>栈保证任何时刻可以访问、删除的元素都是在此之前最后存入的那个 元素。</p><h1 id="list实现栈"><a href="#list实现栈" class="headerlink" title="list实现栈"></a>list实现栈</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackUnderFlow</span>(<span class="title">ValueError</span>):</span></span><br><span class="line">    pass</span><br><span class="line">    </span><br><span class="line"><span class="comment">#list开头设置为栈底 list结尾设置为栈顶</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>():</span></span><br><span class="line">    <span class="comment">#初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.elems = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">#判断为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.elems == []</span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.isEmpty()<span class="symbol">:</span></span><br><span class="line">            raise StackUnderFlow</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.elems[len(<span class="keyword">self</span>.elems) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将元素压入栈中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(<span class="keyword">self</span>,data)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.elems.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#弹出栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.isEmpty()<span class="symbol">:</span></span><br><span class="line">            raise StackUnderFlow</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.elems.pop()</span><br></pre></td></tr></table></figure><h1 id="链表实现栈"><a href="#链表实现栈" class="headerlink" title="链表实现栈"></a>链表实现栈</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#链表头部设为栈顶,链表尾部设为栈底</span></span><br><span class="line"><span class="comment">#定义结点:数据域+指针域</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,data,nextNode=None)</span></span><span class="symbol">:</span><span class="comment">#缺省函数,指向的下一个结点默认为None</span></span><br><span class="line">        <span class="keyword">self</span>.data = data <span class="comment">#当前结点的数据域</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = nextNode <span class="comment">#指向下一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span>():</span></span><br><span class="line">    <span class="comment">#初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.topNode = None</span><br><span class="line"></span><br><span class="line">    <span class="comment">#判断为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.topNode == None</span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.isEmpty()<span class="symbol">:</span></span><br><span class="line">            raise StackUnderFlow</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.topNode.data</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将元素压入栈中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(<span class="keyword">self</span>,data)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.topNode = Node(data,<span class="keyword">self</span>.topNode)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#弹出栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.isEmpty()<span class="symbol">:</span></span><br><span class="line">    raise StackUnderFlow</span><br><span class="line">    pnode = <span class="keyword">self</span>.topNode</span><br><span class="line">    <span class="keyword">self</span>.topNode = pnode.<span class="keyword">next</span></span><br><span class="line">    <span class="keyword">return</span> pnode.data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#演练</span></span><br><span class="line">stack1 = Stack()</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回栈顶元素</span></span><br><span class="line"><span class="comment">#print(stack1.top())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将元素压入栈中</span></span><br><span class="line">stack1.push(<span class="number">12</span>)</span><br><span class="line">stack1.push(<span class="number">11</span>)</span><br><span class="line">print(stack1.top())</span><br><span class="line"></span><br><span class="line"><span class="comment">#弹出栈顶元素</span></span><br><span class="line">stack1.pop()</span><br><span class="line">print(stack1.top())</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断为空</span></span><br><span class="line">print(stack1.isEmpty())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack2 = LinkStack()</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回栈顶元素</span></span><br><span class="line"><span class="comment">#print(stack2.top())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将元素压入栈中</span></span><br><span class="line">stack2.push(<span class="number">12</span>)</span><br><span class="line">stack2.push(<span class="number">11</span>)</span><br><span class="line">print(stack2.top())</span><br><span class="line"></span><br><span class="line"><span class="comment">#弹出栈顶元素</span></span><br><span class="line">stack2.pop()</span><br><span class="line">print(stack2.top())</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断为空</span></span><br><span class="line">print(stack2.isEmpty())</span><br></pre></td></tr></table></figure><p>细节:当LinkStack类中含有self.top()方法时,不要再设置self.top重名属性<br>否则报错:object is not callable</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列(queue)，或称为队，也是一种容器<br>可存入数据元素、访问元素、删除元素</p><ul><li>出队操作的一端称为队头</li><li>入队操作的一端称为队尾</li><li>链接表队列的实现，使用链接表即可</li><li>顺序表队列的实现,入队在表尾,出队在表头</li></ul><p>考虑首元素出队后元素不前移，记住新队头位置。<br>这一设计也有问题: 反复入队出队，如果元素存储区固定，一定会在某次入队时出现队<br>尾溢出表尾(表满)的情况<br>出现这种溢出时，顺序表前部通常会有一些空闲位置 这是“假性溢出”，并不是真的用完了整个元素区<br>如果元素存储区自动增长(如 list)，首端将留下越来越大的空区。 而且这片空区永远也不会用到(完全浪费了)</p><ul><li><p>使用环形队列(把数组看作环形)可以解决这个问题</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">q.rear 是最后元素之后空位的下标</span><br><span class="line">q.head 是首元素的下标</span><br><span class="line">[q.head, q.rear) 是队列中所有元 素(看作按照环形排列)</span><br><span class="line">入队时，先存入，后移位</span><br><span class="line">当队列空: q.<span class="attr">head</span> == q.rear </span><br><span class="line">当队列满:(q.rear + <span class="number">1</span>) % q.<span class="attr">len</span> == q.head</span><br><span class="line"></span><br><span class="line">入队出队时的下标更新语句</span><br><span class="line">q.<span class="attr">head</span> = (q.head+<span class="number">1</span>) % q.len </span><br><span class="line">q.<span class="attr">rear</span> = (q.rear + <span class="number">1</span>) % q.len</span><br></pre></td></tr></table></figure></li></ul><h1 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h1><ul><li>elems引用着队列的元素存储区，是一个list 对象</li><li>len是这个存储区的有效容量(我们并不知道该 list 对象的实际大小)</li><li>head  是队列首元素(当时在队列里的存入最早的那个元素)的下标</li><li>elemNum始终记录着队列中元素的个数</li><li>队列里的元素在 elems 里连续存放，但需要在下标 len 存入元素时，操作改在下标 0 的位置存入</li><li><p>在 elemNum == len 的情况下，入队列操作将自动扩张存储区</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueUnderFlow</span>(<span class="title">ValueError</span>):</span></span><br><span class="line">  pass</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>():</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,length = <span class="number">10</span>)</span></span><span class="symbol">:</span></span><br><span class="line">      <span class="keyword">self</span>.length = length <span class="comment">#存储区容量</span></span><br><span class="line">      <span class="keyword">self</span>.elems = [<span class="number">0</span>] * <span class="keyword">self</span>.length <span class="comment">#存储数据元素</span></span><br><span class="line">      <span class="keyword">self</span>.head = <span class="number">0</span> <span class="comment">#队列首元素</span></span><br><span class="line">      <span class="keyword">self</span>.elemNum = <span class="number">0</span> <span class="comment">#队列中元素个数</span></span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>.elemNum == <span class="number">0</span></span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">firstElem</span><span class="params">(<span class="keyword">self</span>)</span></span>: <span class="comment">#获取队头元素</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">self</span>.isEmpty()<span class="symbol">:</span></span><br><span class="line">          raise QueueUnderFlow</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>.elems[<span class="keyword">self</span>.head]</span><br><span class="line">   </span><br><span class="line">  <span class="comment">#出队</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">self</span>.isEmpty()<span class="symbol">:</span></span><br><span class="line">          raise QueueUnderFlow</span><br><span class="line">      e = <span class="keyword">self</span>.elems[<span class="keyword">self</span>.head]</span><br><span class="line">      <span class="keyword">self</span>.head = (<span class="keyword">self</span>.head + <span class="number">1</span>) % <span class="keyword">self</span>.length</span><br><span class="line">      <span class="keyword">self</span>.elemNum -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> e</span><br><span class="line">   </span><br><span class="line">  <span class="comment">#入队</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">self</span>,data)</span></span><span class="symbol">:</span></span><br><span class="line">      <span class="comment">#检验队列是否已满</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">self</span>.elemNum == <span class="keyword">self</span>.<span class="symbol">length:</span></span><br><span class="line">          <span class="keyword">self</span>.extend() <span class="comment">#扩张存储区</span></span><br><span class="line">      <span class="keyword">self</span>.elems[(<span class="keyword">self</span>.head + <span class="keyword">self</span>.elemNum) % <span class="keyword">self</span>.length] = data</span><br><span class="line">      <span class="keyword">self</span>.elemNum += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extend</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">      oldLen = <span class="keyword">self</span>.length</span><br><span class="line">      <span class="keyword">self</span>.length *= <span class="number">2</span></span><br><span class="line">      newElems = [<span class="number">0</span>] * (<span class="keyword">self</span>.length)</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(oldLen)<span class="symbol">:</span></span><br><span class="line">          newElems[i] = <span class="keyword">self</span>.elems[(<span class="keyword">self</span>.head + i) % oldLen]</span><br><span class="line">      <span class="keyword">self</span>.elems = newElems</span><br><span class="line">      <span class="keyword">self</span>.head = <span class="number">0</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment"># 演练</span></span><br><span class="line">queue = Queue()</span><br><span class="line">   </span><br><span class="line">queue.enqueue(<span class="number">11</span>)</span><br><span class="line">queue.enqueue(<span class="number">12</span>)</span><br><span class="line">queue.enqueue(<span class="number">13</span>)</span><br><span class="line">   </span><br><span class="line">print(queue.firstElem())</span><br><span class="line">   </span><br><span class="line">queue.dequeue()</span><br><span class="line">print(queue.firstElem())</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 栈与队列。 &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.chenyalun.com/categories/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/categories/Python/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://blog.chenyalun.com/tags/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="http://blog.chenyalun.com/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://blog.chenyalun.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
