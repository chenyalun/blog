<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ya</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.chenyalun.com/"/>
  <updated>2019-12-06T08:53:05.141Z</updated>
  <id>http://blog.chenyalun.com/</id>
  
  <author>
    <name>Ya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>App作品：Splash</title>
    <link href="http://blog.chenyalun.com/2019/12/06/App%E4%BD%9C%E5%93%81%EF%BC%9ASplash/"/>
    <id>http://blog.chenyalun.com/2019/12/06/App作品：Splash/</id>
    <published>2019-12-06T06:55:25.000Z</published>
    <updated>2019-12-06T08:53:05.141Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 实践一些想法。 </p><br><a id="more"></a><p></p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>拜读了Casa前辈的<a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html" target="_blank" rel="noopener">《iOS应用架构谈》</a>系列文章，收获颇丰，萌生了想实践的想法。2017年到现在，虽然写过不少项目，但是始终没有App作品在App Store上架过，也一直有这个小心愿。手机里面有个叫Splasher的App，是壁纸类型的App，虽然壁纸质量不错，但是App体验不太好，加载慢，界面冷酷无情。后来打听到它的API来自无版权可以商用的UnSplash。天时地利人和都有了，我的第一个期望上架App Store的作品：Splash，诞生了。</p><p>虽然只是壁纸类的没有多少功能的不需要多少道行就能写出来的App，但是还是想简单聊一聊。</p><h1 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h1><h2 id="1，代码结构"><a href="#1，代码结构" class="headerlink" title="1，代码结构"></a>1，代码结构</h2><p>与俺目前的习惯一致：方法结构按照life cycle、Delegate方法实现、event response、getters and setters顺序。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - Life cycle</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - Event response</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - Getter and setter</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - Private methods</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - Public methods</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - UITableViewDelegate</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - UITableViewDataSource</span><br></pre></td></tr></table></figure></p><blockquote><p>在viewDidload里面只做addSubview的事情，在viewDidLoad里面开一个layoutPageSubviews的方法，在这个里面创建Constraints并添加，在viewDidAppear里面做Notification的监听之类的事情。所有的属性都使用getter和setter，并且全部都放在最后。</p></blockquote><p>我觉得作者说的还是有道理的，虽然某些getter一定会用到，再做一层懒加载貌似显得冗余，但是从结构上看更清晰。</p><h2 id="2，公有特性"><a href="#2，公有特性" class="headerlink" title="2，公有特性"></a>2，公有特性</h2><p>面向切片编程</p><ul><li>什么是切片？<br>程序要完成一件事情，一定会有一些步骤，1，2，3，4这样。这里分解出来的每一个步骤我们可以认为是一个切片。</li><li>什么是面向切片编程？<br>你针对每一个切片的间隙，塞一些代码进去，在程序正常进行1，2，3，4步的间隙可以跑到你塞进去的代码，那么你写这些代码就是面向切片编程。</li><li>为什么会出现面向切片编程？<br>你要想做到在每一个步骤中间做你自己的事情，不用AOP也一样可以达到目的，直接往步骤之间塞代码就好了。但是事实情况往往很复杂，直接把代码塞进去，主要问题就在于：塞进去的代码很有可能是跟原业务无关的代码，在同一份代码文件里面掺杂多种业务，这会带来业务间耦合。为了降低这种耦合度，我们引入了AOP。</li><li>如何实现AOP？<br>Method Swizzling或者protocol的方式来实现拦截器（beforePerform、afterPerform）</li></ul><p>使用AOP而非继承来实现公有特性。比如每个ViewController都有一个通用的navigationHeaderBar:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAObjectIntercepter</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    [YAObjectIntercepter sharedInstance];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> YAObjectIntercepter *sharedInstance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [YAObjectIntercepter new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 方法拦截</span></span><br><span class="line">        [<span class="built_in">UIViewController</span> aspect_hookSelector:<span class="keyword">@selector</span>(viewDidLoad) withOptions:AspectPositionBefore usingBlock:^(<span class="keyword">id</span> &lt;AspectInfo&gt; aspectInfo)&#123;</span><br><span class="line">            [<span class="keyword">self</span> viewDidLoadWithViewController:[aspectInfo instance]];</span><br><span class="line">        &#125; error:<span class="literal">NULL</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - fake methods</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoadWithViewController:(<span class="built_in">UIViewController</span> *)viewController &#123;</span><br><span class="line">    <span class="keyword">if</span> ([viewController isKindOfClass:<span class="built_in">UIViewController</span>.class] &amp;&amp; [<span class="built_in">NSStringFromClass</span>(viewController.class) hasPrefix:<span class="string">@"YA"</span>]) &#123;</span><br><span class="line">        viewController.view.backgroundColor = <span class="built_in">UIColor</span>.whiteColor;</span><br><span class="line">        viewController.navigationHeaderBar.backgroundColor = <span class="built_in">UIColor</span>.whiteColor;</span><br><span class="line">        [viewController.view addSubview:viewController.navigationHeaderBar];</span><br><span class="line">        viewController.navigationHeaderBar.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, kIPHONEX_TOP, kScreenWidth, kNavigationBarHeight);</span><br><span class="line">        [viewController.navigationHeaderBar.leftButton setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"feed_back"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        [viewController.navigationHeaderBar.leftButton setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"feed_back"</span>] forState:<span class="built_in">UIControlStateHighlighted</span>];</span><br><span class="line">        [viewController.navigationHeaderBar.leftButton addTarget:viewController action:<span class="keyword">@selector</span>(popViewControllerWithAnimation) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="3，网络层设计"><a href="#3，网络层设计" class="headerlink" title="3，网络层设计"></a>3，网络层设计</h2><blockquote><p>1，网络层数据通信以Delegate为主，Notification为辅（网络信号从2G变成3G变成4G变成Wi-Fi）。<br>2，提供reformer机制来处理网络层反馈的数据，交付NSDictionary给业务层，使用Const字符串作为Key来保持可读性。<br>3，网络层上部分使用离散型设计，下部分使用集约型设计。设计合理的继承机制，让派生出来的APIManager受到限制，避免混乱。<br>关于集约型的API调用和离散型的API调用，我倾向于这样：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约化的手段组装请求，放飞请求，然而业务方调用API的时候，则是以离散的API调用方式来调用。如果你的App只提供了集约化的方式，而没有离散方式的通道，那么我建议你再封装一层，便于业务方使用离散的API调用方式来放飞请求。</p></blockquote><p>大型App可以使用封装AFN的YTKNetwork，而小型App由于API少，参数不复杂，很多就直接使用一个类，暴露Get和Post接口就可以了。</p><p><strong>下层：统一接口，以离散型封装AFNetworking</strong><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> *YAServerInterfaceName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首页Feed接口</span></span><br><span class="line"><span class="keyword">extern</span> YAServerInterfaceName <span class="keyword">const</span> kYAServerInterfaceFeed;</span><br><span class="line"><span class="comment">// 搜索接口</span></span><br><span class="line"><span class="keyword">extern</span> YAServerInterfaceName <span class="keyword">const</span> kYAServerInterfaceSearch;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YANetworkManager</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)manager;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)requestWithInterfaceName:(YAServerInterfaceName)interfaceName</span><br><span class="line">                                        parameters:(<span class="built_in">NSDictionary</span> *)parameters</span><br><span class="line">                                          progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *))downloadProgress</span><br><span class="line">                                           success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="keyword">id</span>))success</span><br><span class="line">                                           failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>把接口以及公共参数进行封装，避免散落一地。使用时只需要传入InterfaceName即可。每个业务都可以有自己的manager，成功或者失败回调以block的形式回传，供各个业务自己发挥。</p><p><strong>上层：统一APIManager，以集约型的delegate进行回调</strong><br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// API manager的基类</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">YABaseAPIManager </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) BOOL noMoreData;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">fetchNetworkDataWithParameters</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">parameters</span>;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">cancelPreviousRequest</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure></p><p>BaseAPIManager负责派生各个业务的APIManager，提供数据请求及取消数据请求接口。BaseAPIManager还约定了子类需要实现的方法：成功回调、失败回调、以及接口名称。具体请求的参数怎么配置、成功回调怎么处理、失败回调怎么处理都由子类决定。</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@protocol</span> YABaseAPIManagerChildProtocol &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@required</span></span><br><span class="line">- (YAServerInterfaceName)interfaceName;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">APIManager</span><span class="selector-pseudo">:(YABaseAPIManager</span> *)<span class="selector-tag">manager</span> <span class="selector-tag">finishedWithFailedError</span><span class="selector-pseudo">:(NSError</span> *)<span class="selector-tag">error</span>;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">APIManager</span><span class="selector-pseudo">:(YABaseAPIManager</span> *)<span class="selector-tag">manager</span> <span class="selector-tag">finishedWithSuccessResult</span><span class="selector-pseudo">:(id)result</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><h2 id="4，从MVC、MVVM到去Model化"><a href="#4，从MVC、MVVM到去Model化" class="headerlink" title="4，从MVC、MVVM到去Model化"></a>4，从MVC、MVVM到去Model化</h2><p><strong>MVC</strong><br>M应该做的事：<br>给ViewController提供数据；<br>给ViewController存储数据提供接口；<br>提供经过抽象的业务基本组件，供Controller调度；</p><p>C应该做的事：<br>管理View Container的生命周期；<br>负责生成所有的View实例，并放入View Container；<br>监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务；</p><p>V应该做的事：<br>响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等；<br>界面元素表达</p><p><strong>MVVM</strong><br>在MVC的基础上，把C拆出一个ViewModel专门负责数据处理的事情，就是MVVM。然后，为了让View和ViewModel之间能够有比较松散的绑定关系，于是我们使用ReactiveCocoa，因为苹果本身并没有提供一个比较适合这种情况的绑定方法。iOS领域里KVO，Notification，block，delegate和target-action都可以用来做数据通信，从而来实现绑定，但都不如ReactiveCocoa提供的RACSignal来的优雅，如果不用ReactiveCocoa，绑定关系可能就做不到那么松散那么好，但并不影响它还是MVVM。</p><p><strong>去Model化</strong><br>保留原始数据，定义reform协议，遵守该协议的对象来处理manager的原始数据，处理后的数据依然是字典或者数组。</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@protocol</span> YAFeedReformerProtocol &lt;NSObject&gt;</span><br><span class="line">- (NSArray *)<span class="attribute">reformData</span>:(id)data <span class="attribute">manager</span>:(YAFeedAPIManager *)manager;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>每类数据对应一个Reformer：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyFeedID;             <span class="comment">///&lt; id</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyFeedThumbUrl;       <span class="comment">///&lt; 拇指图url</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyFeedSmallUrl;       <span class="comment">///&lt; 小图url</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyFeedRegularUrl;     <span class="comment">///&lt; 常规图url</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAFeedReformer</span> : <span class="title">NSObject</span> &lt;<span class="title">YAFeedReformerProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>根据字典的key可以直接使用:<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setPhotoInfo:(<span class="built_in">NSDictionary</span> *)photoInfo &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (YASettingManager.columnCount &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        url = [<span class="built_in">NSURL</span> URLWithString:photoInfo[kPropertyListDataKeyFeedRegularUrl]];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5，网络优化"><a href="#5，网络优化" class="headerlink" title="5，网络优化"></a>5，网络优化</h2><p><strong>针对链接建立环节的优化</strong></p><ul><li>使用缓存手段减少请求的发起次数（API名字和参数拼成一个字符串然后取MD5作为key，存储对应返回的数据）</li><li>使用策略来减少请求的发起次数（下拉刷新、条件筛选取消原先存在的请求，用户日志满足一定数量再上传）</li></ul><p><strong>针对DNS域名解析做的优化</strong><br>原因：API请求在DNS解析阶段的耗时会很多（网络信号源会经常变换、自己的App所做的DNS缓存会被别的DNS缓存给挤出去被清理掉、墙 这三个原因造成链路的DNS缓存很快失效相当于没有，于是直接走IP请求，绕过DNS服务的耗时）<br>方案：本地有一份IP列表，这些IP是所有提供API的服务器的IP，每次应用启动的时候，针对这个列表里的所有IP取ping延时时间，然后取延时时间最小的那个IP作为今后发起请求的IP地址。一般都是在应用启动的时候获得本地列表中所有IP的ping值，然后通过NSURLProtocol的手段将URL中的HOST修改为我们找到的最快的IP。另外，这个本地IP列表也会需要通过一个API来维护，一般是每天第一次启动的时候读一次API，然后更新到本地。</p><p><strong>针对链接传输数据量的优化</strong><br>压缩。</p><p><strong>针对链接复用的优化</strong><br>HTTP/2.0。</p><p><strong>判断API的调用请求是来自于经过授权的APP？</strong><br>设计签名<br>服务端需要给你一个密钥，每次调用API时，你使用这个密钥再加上API名字和API请求参数算一个hash出来，然后请求的时候带上这个hash。服务端收到请求之后，按照同样的密钥同样的算法也算一个hash出来，然后跟请求带来的hash做一个比较，如果一致，那么就表示这个API的调用者确实是你的APP。为了不让别人也获取到这个密钥，你最好不要把这个密钥存储在本地，直接写死在代码里面就好了。另外适当增加一下求Hash的算法的复杂度，那就是各种Hash算法（比如MD5）加点盐，再回炉跑一次Hash啥的。这样就能解决第一个目的了：确保你的API是来自于你自己的App。</p><p>网络优化在Splash上的实践主要是<strong>ip直连</strong>。Casa前辈给出了NSEtcHosts，但是它处理NSURLConnection，过时了，我学习借鉴写了个NSURLSession版本的。当然，思路都是一样的，自定义NSURLProtocol。增加了一点点功能：</p><ul><li>支持HTTPS</li><li>直连ip失败后自动切回host</li><li>支持AFN</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YAHostsConfiguration</span></span></span><br><span class="line"><span class="comment">// 配置host与IP的映射</span></span><br><span class="line">- (<span class="keyword">void</span>)resolveHostName:(<span class="built_in">NSString</span> *)hostName</span><br><span class="line">           mapIPAddress:(<span class="built_in">NSString</span> *)IPAddress;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YADomainURLProtocol</span> : <span class="title">NSURLProtocol</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)configureHostsWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;YAHostsConfiguration&gt; configuration))block;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAHostsConfiguration</span> : <span class="title">NSObject</span> &lt;<span class="title">YAHostsConfiguration</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *mutableIPAddressesByHostName;</span><br><span class="line">- (<span class="built_in">NSString</span> *)IPAddressForHostName:(<span class="built_in">NSString</span> *)hostName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAHostsConfiguration</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _mutableIPAddressesByHostName = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)IPAddressForHostName:(<span class="built_in">NSString</span> *)hostName &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.mutableIPAddressesByHostName[hostName.lowercaseString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)resolveHostName:(<span class="built_in">NSString</span> *)hostName mapIPAddress:(<span class="built_in">NSString</span> *)IPAddress &#123;</span><br><span class="line">    <span class="keyword">self</span>.mutableIPAddressesByHostName[hostName.lowercaseString] = IPAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kURLProtocolHostModifiedKey = <span class="string">@"kURLProtocolHostModifiedKey"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YADomainURLProtocol</span> () &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YADomainURLProtocol</span></span></span><br><span class="line">+ (YAHostsConfiguration *)sharedConfiguration &#123;</span><br><span class="line">    <span class="keyword">static</span> YAHostsConfiguration * sharedConfiguration = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedConfiguration = [YAHostsConfiguration new];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sharedConfiguration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)configureHostsWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;YAHostsConfiguration&gt; configuration))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (block) block([<span class="keyword">self</span> sharedConfiguration]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isHttp = [request.URL.scheme caseInsensitiveCompare:<span class="string">@"http"</span>] == <span class="built_in">NSOrderedSame</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> isHttps = [request.URL.scheme caseInsensitiveCompare:<span class="string">@"https"</span>] == <span class="built_in">NSOrderedSame</span>;</span><br><span class="line">    <span class="keyword">if</span> (isHttp || isHttps) &#123;</span><br><span class="line">        <span class="comment">// 没有处理过且有映射</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> propertyForKey:kURLProtocolHostModifiedKey inRequest:request] &amp;&amp; [[<span class="keyword">self</span> sharedConfiguration] IPAddressForHostName:request.URL.host]) &#123;</span><br><span class="line">            YALog(<span class="string">@"命中ip直连"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="comment">// 容错</span></span><br><span class="line">    <span class="keyword">if</span> (request.URL.host.length == <span class="number">0</span>) <span class="keyword">return</span> request;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line">    <span class="built_in">NSURLComponents</span> *URLComponents = [<span class="built_in">NSURLComponents</span> componentsWithString:mutableRequest.URL.absoluteString];</span><br><span class="line">    URLComponents.scheme = <span class="string">@"https"</span>;</span><br><span class="line">    URLComponents.host = [[<span class="keyword">self</span> sharedConfiguration] IPAddressForHostName:URLComponents.host];</span><br><span class="line">    mutableRequest.URL = [URLComponents URL];</span><br><span class="line">    [<span class="keyword">self</span> setProperty:@(<span class="literal">YES</span>) forKey:kURLProtocolHostModifiedKey inRequest:mutableRequest];</span><br><span class="line">    <span class="comment">// 设置原先的host</span></span><br><span class="line">    [mutableRequest setValue:request.URL.host forHTTPHeaderField:<span class="string">@"host"</span>];</span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> new]];</span><br><span class="line">    [[<span class="keyword">self</span>.session dataTaskWithRequest:<span class="keyword">self</span>.request] resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading &#123;</span><br><span class="line">    [<span class="keyword">self</span>.session finishTasksAndInvalidate];</span><br><span class="line">    <span class="keyword">self</span>.session = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSURLSessionDataDelegate</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 加载完成: error回调</span></span><br><span class="line">        [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didFailWithError:error];</span><br><span class="line">        <span class="comment">// 出错: 取消ip直连</span></span><br><span class="line">        <span class="built_in">NSString</span> *host = [<span class="keyword">self</span>.request valueForHTTPHeaderField:<span class="string">@"host"</span>];</span><br><span class="line">        [YADomainURLProtocol sharedConfiguration].mutableIPAddressesByHostName[host.lowercaseString] = <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 加载完成: success回调</span></span><br><span class="line">        [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;</span><br><span class="line">    <span class="comment">// 接收response回调</span></span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</span><br><span class="line">    completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="comment">// 接收数据回调</span></span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 证书</span></span><br><span class="line"><span class="comment">// https: 证书</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span>, <span class="built_in">NSURLCredential</span> *))completionHandler &#123;</span><br><span class="line">    <span class="keyword">if</span> (!challenge) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *host = [<span class="keyword">self</span>.request.allHTTPHeaderFields objectForKey:<span class="string">@"host"</span>];</span><br><span class="line">    <span class="keyword">if</span> (!host) host = <span class="keyword">self</span>.request.URL.host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>] &amp;&amp; [<span class="keyword">self</span> createServerTrust:challenge.protectionSpace.serverTrust forDomain:host]) &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">        credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler(disposition, credential);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建证书校验策略</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)createServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定校验策略到服务端的证书上</span></span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error;</span><br><span class="line">    SecTrustEvaluate(serverTrust, &amp;result);</span><br><span class="line">    <span class="keyword">return</span> (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>只需要这么使用：<br><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">NSURLProtocol</span> registerClass:YADomainURLProtocol.class]<span class="comment">;</span></span><br><span class="line">[<span class="name">YADomainURLProtocol</span> configureHostsWithBlock:^(<span class="name">id&lt;YAHostsConfiguration&gt;</span> configuration) &#123;</span><br><span class="line">    [<span class="name">configuration</span> resolveHostName:@<span class="string">"www.baidu.com"</span> mapIPAddress:@<span class="string">"220.181.38.150"</span>]<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>对于AFN，配置configuration即可<br><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">NSURLSessionConfiguration *configuration = <span class="comment">[NSURLSessionConfiguration defaultSessionConfiguration]</span>;</span><br><span class="line">configuration.protocolClasses = @<span class="comment">[YADomainURLProtocol.class]</span>;</span><br><span class="line">AFHTTPSessionManager *sessionManager = <span class="comment">[<span class="comment">[AFHTTPSessionManager alloc]</span> initWithSessionConfiguration:configuration]</span>;</span><br></pre></td></tr></table></figure></p><h2 id="6，持久化"><a href="#6，持久化" class="headerlink" title="6，持久化"></a>6，持久化</h2><p><strong>持久化方案有哪些？</strong></p><ul><li>NSUserDefault： 小规模数据，弱业务相关数据，都可以放到NSUserDefault里面，内容比较多的数据，强业务相关的数据就不太适合NSUserDefault了。</li><li>Keychain ： Keychain是苹果提供的带有可逆加密的存储机制，普遍用在各种存密码的需求上。另外，由于App卸载只要系统不重装，Keychain中的数据依旧能够得到保留，以及可被iCloud同步的特性，大家都会在这里存储用户唯一标识串。所以有需要加密、需要存iCloud的敏感小数据，一般都会放在Keychain。</li><li>文件存储：文件存储包括了Plist、archive、Stream等方式，一般结构化的数据或者需要方便查询的数据，都会以Plist的方式去持久化。Archive方式适合存储平时不太经常使用但很大量的数据，或者读取之后希望直接对象化的数据，因为Archive会将对象及其对象关系序列化，以至于读取数据的时候需要Decode很花时间，Decode的过程可以是解压，也可以是对象化，这个可以根据具体<nscoding>中的实现来决定。Stream就是一般的文件存储了，一般用来存存图片啊啥的，适用于比较经常使用，然而数据量又不算非常大的那种。</nscoding></li><li>数据库存储：苹果自带了一个Core Data，其他还有FMDB。数据库方案主要是为了便于增删改查，当数据有状态和类别的时候最好还是采用数据库方案比较好。因为你不可能通过文件系统遍历文件去甄别你需要获取的属于某个状态或类别的数据，这么做成本就太大了。当然，特别大量的数据也不适合直接存储数据库，比如图片或者文章这样的数据，一般来说，都是数据库存一个文件名，然后这个文件名指向的是某个图片或者文章的文件。如果真的要做全文索引这种需求，建议最好还是挂个API丢到服务端去做。</li></ul><p>上面是前辈总结的面试题答案😂</p><p>接下来是持久化的实践：<br>与以往不同的是，之前采用MVC或者MVVM模式，存在数据库的是Model，而现在去Model化了，存原始数据呢，还是存Reform之后的数据。我选择存储原始数据，原因有二：<br>1，Reformer有多个，但是原始数据只有一份，只存储一份原始数据避免冗余。<br>2，如果存储原始数据，那从数据库取出的数据和从网络获取的数据，格式将会是一样的，只需要一种处理方式。</p><p>怎么存储？每条photo信息中的photo_id作为主键，再加上时间戳用于筛选，photo_content自然就是存储的原始信息了：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">"t_photoList"</span> (</span><br><span class="line"><span class="string">"photo_id"</span> <span class="built_in">text</span>,</span><br><span class="line"><span class="string">"photo_content"</span> <span class="built_in">text</span>,</span><br><span class="line"><span class="string">"photo_date"</span> <span class="built_in">INTEGER</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">"photo_id"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>这样职责更清晰了：APIManager负责从网络或者数据库取数据以及持久化数据，Reformer只负责格式化APIManager的数据。对于控制器来说，它做的也很简单了：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)feedAPIDidSuccessWithManager:(YAFeedAPIManager *)manager</span><br><span class="line">                           isNewData:(<span class="built_in">BOOL</span>)isNewData &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> &lt;<span class="built_in">NSDictionary</span> *&gt; *array = [manager fetchDataWithReformer:<span class="keyword">self</span>.feedReformer];</span><br><span class="line">    <span class="keyword">if</span> (isNewData) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.photoArray removeAllObjects];</span><br><span class="line">        [<span class="keyword">self</span>.refreshHeader endRefreshing];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.photoArray addObjectsFromArray:array];</span><br><span class="line">    <span class="keyword">if</span> (manager.noMoreData) &#123;</span><br><span class="line">        <span class="comment">// 没有更多数据</span></span><br><span class="line">        [<span class="keyword">self</span>.refreshFooter endRefreshingWithNoMoreData];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.refreshFooter endRefreshing];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.feedCollectionView reloadData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="7，动态部署方案"><a href="#7，动态部署方案" class="headerlink" title="7，动态部署方案"></a>7，动态部署方案</h2><p>（1）Web App<br>其实所谓的web app，就是通过手机上的浏览器进行访问的H5页面。这个H5页面是针对移动场景特别优化的，比如UI交互等。</p><ul><li>优点<br>无需走苹果流程，所有苹果流程带来的成本都能避免，包括审核周期、证书成本等。<br>版本更新跟网页一样，随时生效。<br>不需要Native App工程师的参与，而且市面上已经有很多针对这种场景的框架。</li><li>缺点<br>重度依赖网络环境、流畅度不如Native、很难做好本地持久化（只能提供账户体系，对应账户的持久化数据全部存在服务端）、即时响应方案、远程通知实现方案、移动端传感器的使用方案复杂，维护难度大。<br>安全问题，H5页面等于是所有东西都暴露给了用户，如果对安全要求比较高的，很多额外的安全机制都需要在服务端实现。</li><li>总结<br>web app一般是创业初期会重点考虑的方案，因为迭代非常快，而且创业初期的主要目标是需要验证模式的正确性，并不在于提供非常好的用户体验，只需要完成闭环即可。</li></ul><p>（2）Hybrid App<br>通过市面上各种Hybrid框架，来做H5和Native的混合应用，或者通过JS Bridge来做到H5和Native之间的数据互通。</p><ul><li>优点<br>除了要承担苹果流程导致的成本以外，具备所有web app的优势、能够访问本地数据、设备传感器等</li><li>缺点<br>跟web app一样存在过度依赖网络环境的问题、用户体验也很难做到很好、安全性问题依旧存在、大规模的数据交互很难实现，例如图片在本地处理后，将图片传递给H5</li><li>总结<br>Hybrid方案更加适合跟本地资源交互不是很多，然后主要以内容展示为主的App。在天猫App中，大量地采用了JS Bridge的方式来让H5跟Native做交互，因为天猫App是一个以内容展示为主的App，且营销活动多，周期短，比较适合Hybrid。</li></ul><p>（3）React-Native</p><ul><li>优点<br>响应速度很快，只比Native慢一点，比webview快很多。<br>能够做到一定程度上的动态部署</li><li>缺点<br>组装页面的元素需要Native提供支持，一定程度上限制了动态部署的灵活性。</li><li>总结<br>由于View的展示和View的事件响应分属于不同的端，展示部分的描述在JS端，响应事件的监听和描述都在Native端，通过Native转发给JS端。所以，从做动态部署的角度上讲，React-Native只能动态部署新View，不能动态部署新View对应的事件。<br>View的原型需要从Native中取，以后某个页面需要添加某个复杂的view的时候，需要从现有的组件中拼装。<br>它解决的是如何不使用Objc/Swift来写iOS App的View的问题，对于如何通过不发版来给已发版的App更新功能这样的问题，帮助有限。</li></ul><p>（4）Lua Patch<br>waxPatch的主要原理是通过lua来针对objc的方法进行替换，由于lua本身是解释型语言，可以通过动态下载得到，因此具备了一定的动态部署能力。然而iOS系统原生并不提供lua的解释库，所以需要在打包时把lua的解释库编译进app。</p><ul><li>优点<br>能够通过下载脚本替换方法的方式，修改本地App的行为。<br>执行效率较高</li><li>缺点<br>对于替换功能来说，lua是很不错的选择。但如果要添加新内容，实际操作会很复杂，很容易改错，小问题变成大问题</li><li>总结<br>lua的解决方案在一定程度上解决了动态部署的问题。实际操作时，一般不使用它来做新功能的动态部署，主要还是用于修复bug时代码的动态部署。</li></ul><p>（5）Javascript Patch<br>这个工作原理其实跟上面说的lua那套方案的工作原理一样，只不过是用javascript实现。</p><ul><li>优点<br>打包时不用将解释器也编译进去，iOS自带JavaScript的解释器。</li><li>缺点<br>同Lua方案的缺点</li><li>总结<br>在对app打补丁的方案中，目前我更倾向于使用JSPatch的方案，在能够完成Lua做到的所有事情的同时，还不用编一个JS解释器进去，而且会javascript的人比会lua的人多，技术储备比较好做。</li></ul><p>（6）JSON Descripted View<br>使用JSON来描述一个View应该有哪些元素，以及元素的位置，以及相关的属性，比如背景色，圆角等等。然后本地有一个解释器来把JSON描述的View生成出来。<br>这跟React-Native有点儿像，一个是JS转Native，一个是JSON转Native。但是同样有的问题就是事件处理的问题，在事件处理上，React-Native做得相对更好。因为JSON不能够描述事件逻辑，所以JSON生成的View所需要的事件处理都必须要本地事先挂好。</p><ul><li>优点<br>能够自由生成View并动态部署</li><li>缺点<br>天猫实际使用下来，发现还是存在一定的性能问题，不够快<br>事件需要本地事先写好，无法动态部署事件</li><li>总结<br>其实JSON描述的View比React-Native的View有个好处就在于对于这个View而言，不需要本地也有一套对应的View，它可以依据JSON的描述来自己生成。然而对于事件的处理是它的硬伤，所以JSON描述View的方案，一般比较适用于换肤，或者固定事件不同样式的View，比如贴纸。</li></ul><p>作者总结地实在是太全面太好了（崇拜脸😁）。<br>目前来看，使用比较广泛的是JS Patch。手百参考了一下它的原理，自己又写了一个，用于热修复，之前老板让调研过，最近用了几次。</p><p>在Splash中目前还没有实践热更新方案。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>1.0.0版本已经发布了，但是最近开发人员注册好像出了点问题，付款老是失败，然后就没上线。</p><p>github放这了：<a href="https://github.com/chenYalun/Splash" target="_blank" rel="noopener">https://github.com/chenYalun/Splash</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 实践一些想法。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="开源项目" scheme="http://blog.chenyalun.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>多线程与Runloop拾遗</title>
    <link href="http://blog.chenyalun.com/2019/09/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8ERunloop%E6%8B%BE%E9%81%97/"/>
    <id>http://blog.chenyalun.com/2019/09/30/多线程与Runloop拾遗/</id>
    <published>2019-09-30T10:36:38.000Z</published>
    <updated>2019-12-09T08:15:11.430Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 回顾了多线程、Runloop相关的重点知识。 </p><a id="more"></a><p>比较零碎。</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>首先简单回顾几个常见的术语：<br>同步：只能在当前线程中执行任务，不具备开启新线程的能力。在队列里面的任务完成之前会一直等待。<br>异步：可以在新的线程中执行任务，具备开启新线程的能力。它不会做任何等待，可以继续执行任务。<br>串行：一个任务执行完毕后，再执行下一个任务。<br>并发：多个任务并发（同时）执行，并发队列的并发功能只有在异步函数下才有效。</p><p>自己创建的串行队列（非主队列），使用异步方式，会开启新线程执行任务。<br>并发队列下的异步方式，会开启新线程，并发执行任务。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="dispatch-sync类型"><a href="#dispatch-sync类型" class="headerlink" title="dispatch_sync类型"></a>dispatch_sync类型</h3><p>主队列下的同步执行，会产生死锁。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在主线程执行task方法</span></span><br><span class="line">- (<span class="keyword">void</span>)task &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"a任务"</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 追加到主队列中按照顺序执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"b任务"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"c任务"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是同步执行，所以c任务需要等待b任务执行完毕之后才可以执行；又因为是主队列且a任务和c任务都要在主线程执行，所以b任务需要等待（a任务和）c任务执行完毕之后才可以执行；这样a任务与c任务互相等待产生了死锁。</p><p>再比如<a href="http://southpeak.github.io/2016/09/20/ios-techset-8/" target="_blank" rel="noopener">知识小集</a>中的一个例子：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(<span class="string">"com.app.test"</span>, NULL)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">queue</span>, ^&#123; </span><br><span class="line">    dispatch_sync(<span class="name">queue</span>, ^&#123;</span><br><span class="line">        // 向串行队列queue中追加任务B</span><br><span class="line">        NSLog(@<span class="string">"B任务"</span>)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"A任务"</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>向串行队列queue中追加任务B，B任务需要等待A任务执行完毕才能执行，由于是串行队列下的同步执行，A任务需要等待B任务执行完毕才能执行，二者互相等待产生死锁。</p><p>可以总结，<strong>使用sync函数向当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</strong>。</p><h3 id="dispatch-once类型"><a href="#dispatch-once类型" class="headerlink" title="dispatch_once类型"></a>dispatch_once类型</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">void test() &#123;</span><br><span class="line">    static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class="line">        test()<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">"This is a test"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_once的<a href="http://southpeak.github.io/2016/08/31/ios-techset-7/" target="_blank" rel="noopener">递归调用</a>也会产生死锁。</p><blockquote><p>onceToken在第一次执行block之前，其值将由NULL变为指向第一个调用者的指针(&amp;dow)。如果在block完成之前，有其它的调用者进来，则会把这些调用者放到一个waiter链表中(走else分支)，直到block执行完成。waiter链中的每个调用者都会等待一个信号量(dow.dow_sema)。在block执行完成后，除了将onceToken置为DISPATCH_ONCE_DONE外，还会去遍历waiter链中的所有waiter，抛出相应的信号量，以告知waiter们调用结束。<br>递归调用test()时，第二次调用作为一个waiter，在等待block完成，而block的完成依赖于test()的执行完成，这就成了一个死锁。</p></blockquote><p>下一篇文章看一下GCD源码吧。。</p><h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h3><p>tutuge介绍了一个<a href="http://tutuge.me/2015/04/03/something-about-gcd/" target="_blank" rel="noopener">例子</a>：</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(<span class="string">"com.app.test"</span>, DISPATCH_QUEUE_SERIAL)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_apply(<span class="number">3</span>, queue, ^(<span class="name">size_t</span> i) &#123;</span><br><span class="line">    NSLog(@<span class="string">"apply loop outside %zu"</span>, j)<span class="comment">;</span></span><br><span class="line">    // 死锁</span><br><span class="line">    dispatch_apply(<span class="number">3</span>, queue, ^(<span class="name">size_t</span> j) &#123;</span><br><span class="line">        NSLog(@<span class="string">"apply loop inside %zu"</span>, j)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>dispatch_apply是将block追加到指定的Queue中执行指定次数，并等待全部block执行完毕，也即它用的是dispatch_sync。这自然解释了为啥会死锁了。官方文档上苹果推荐的使用方式是配合dispatch_get_global_queue全局队列。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>iOS中的线程同步方案有很多：</p><ul><li>OSSpinLock（自旋锁，忙等）</li><li>os_unfair_lock（休眠，iOS10+）</li><li>pthread_mutex（互斥锁，可递归，可条件，休眠）</li><li>dispatch_semaphore（信号量）</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)（串行同步）</li><li>NSLock（封装mutex）</li><li>NSRecursiveLock（封装mutex递归锁）</li><li>NSCondition（封装mutex条件锁）</li><li>NSConditionLock（封装NSCondition，可设置条件值）</li><li>@synchronized（封装mutex递归锁，语法简单）</li></ul><p>ibireme在<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">《不再安全的OSSpinLock》</a>中介绍了自旋锁（比如OSSpinLock）优先级翻转的问题：<br>假定有优先级较高的线程a，优先级较低的线程b，一开始由线程b执行任务，则加锁，线程a处于忙等状态。但是由于线程a的优先级较高，获得的时间片也较多，那么线程b的时间片比较少，可能一直无法往下执行，无法释放锁。于是造成线程a一直处于忙等状态，而优先级较低的线程b却在一直执行任务，便出现了优先级反转。<br>当使用互斥锁时就不会有这种问题：线程a不会忙等，而是休眠，也即不会占用CPU资源，这样线程b的任务很快执行完毕并释放锁，线程a的任务就得到执行了。</p><p>什么情况使用自旋锁比较划算？</p><ul><li>预计线程等待锁的时间很短</li><li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li><li>CPU资源不紧张</li><li>多核处理器</li></ul><p>什么情况使用互斥锁比较划算？</p><ul><li>预计线程等待锁的时间较长</li><li>单核处理器</li><li>临界区有IO操作</li><li>临界区代码复杂或者循环量大</li><li>临界区竞争非常激烈</li></ul><p>在开发中常用的是信号量，性能较高（次于OSSpinLock和os_unfair_lock）且方便。</p><h2 id="存取方法加锁"><a href="#存取方法加锁" class="headerlink" title="存取方法加锁"></a>存取方法加锁</h2><p>nonatomic与atomic是很常见的话题。atomic保证了getter和setter的原子性，方法内部是线程安全的。但是不能保证使用属性过程中的线程安全。而大多数情况下，需要保证“使用属性过程中的线程安全”。所以，这就造成我们经常选择nonatomic：<br>1， 项目中有太多的属性设置取值操作，每次都加锁，消耗性能；<br>2， 并不是每个属性取值设值操作都需要加锁的，完全可以在真正需要的地方自己加锁；</p><p>对于属性来说，最理想的自然是读操作，允许多条线程并发执行，写操作，同一时刻只能一条线程执行。实现方案有两种，读写锁pthread_rwlock或者GCD中的dispatch_barrier_async。个人喜欢第二种。<br><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">@synthesize <span class="built_in">name</span> = <span class="variable">_name</span>;</span><br><span class="line">- (void)<span class="built_in">setName</span>:(NSString *)<span class="built_in">name</span> &#123;</span><br><span class="line">    dispatch_barrier_sync(self.propertyQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">name</span> != <span class="variable">_name</span>) &#123;</span><br><span class="line">            <span class="variable">_name</span> = <span class="built_in">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)<span class="built_in">name</span> &#123;</span><br><span class="line">    <span class="variable">__block</span> NSString *<span class="built_in">name</span> = <span class="literal">nil</span>;</span><br><span class="line">    dispatch_sync(self.propertyQueue, ^&#123;</span><br><span class="line">        <span class="built_in">name</span> = <span class="variable">_name</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    return <span class="built_in">name</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>Runloop与线程</strong><br>每条线程都有唯一的一个与之对应的RunLoop对象，RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value。线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建，<br>会在线程结束时销毁。主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop。</p><p><strong>Runloop的Mode</strong><br>CFRunLoopModeRef代表RunLoop的运行模式。一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer。RunLoop启动时只能选择其中一个Mode，作为currentMode<br>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入（这样做可以保证专心处理一个Mode下的事件）。不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响。如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出。</p><p>kCFRunLoopDefaultMode是App的默认Mode，通常主线程是在这个Mode下运行。UITrackingRunLoopMode是界面跟踪 Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响。</p><p><strong>Mode下的Source0/Source1/Timer/Observer</strong><br>Source0</p><ul><li>触摸事件处理</li><li>performSelector:onThread:</li></ul><p>Source1</p><ul><li>基于Port的线程间通信（比如<a href="https://blog.chenyalun.com/2019/01/28/NSNotificationCenter探索/#三、子线程通知">不同线程间的Notification</a>）</li><li>系统事件捕捉</li></ul><p>Timers</p><ul><li>NSTimer</li><li>performSelector:withObject:afterDelay:（内部也是定时器）</li></ul><p>Observers</p><ul><li>用于监听RunLoop的状态</li><li>UI刷新（BeforeWaiting）</li><li>Autorelease pool（BeforeWaiting）</li></ul><p><strong>Runloop的内部逻辑</strong><br>01、通知Observers：进入Loop<br>02、通知Observers：即将处理Timers<br>03、通知Observers：即将处理Sources<br>04、处理Blocks<br>05、处理Source0（可能会再次处理Blocks）<br>06、如果存在Source1，就跳转到第8步<br>07、通知Observers：开始休眠（等待消息唤醒）<br>08、通知Observers：结束休眠（被某个消息唤醒）<br>    （01）&gt; 处理Timer<br>    （02）&gt; 处理GCD Async To Main Queue<br>    （03）&gt; 处理Source1<br>09、处理Blocks<br>10、根据前面的执行结果，决定如何操作<br>    （01）&gt; 回到第02步<br>    （02）&gt; 退出Loop<br>11、通知Observers：退出Loop</p><p><strong>Runloop状态监听</strong><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 创建Observer</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">   <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">       <span class="keyword">case</span> kCFRunLoopEntry: &#123;</span><br><span class="line">           <span class="built_in">CFRunLoopMode</span> mode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"kCFRunLoopEntry - %@"</span>, mode);</span><br><span class="line">           <span class="built_in">CFRelease</span>(mode);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">           </span><br><span class="line">       <span class="keyword">case</span> kCFRunLoopExit: &#123;</span><br><span class="line">           <span class="built_in">CFRunLoopMode</span> mode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"kCFRunLoopExit - %@"</span>, mode);</span><br><span class="line">           <span class="built_in">CFRelease</span>(mode);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">           </span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Observer到RunLoop中</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure></p><p><strong>休眠的实现原理</strong><br>依靠mach_msg()函数，做到用户态处理消息，内核态等待消息，没有消息就让线程休眠。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1，控制线程周期"><a href="#1，控制线程周期" class="headerlink" title="1，控制线程周期"></a>1，控制线程周期</h3><p>借助Runloop实现线程保活：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAPermenantThread</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *innerThread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAPermenantThread</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _innerThread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">CFRunLoopSourceContext</span> context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">CFRunLoopSourceRef</span> source = <span class="built_in">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="number">0</span>, &amp;context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(source);</span><br><span class="line">            <span class="comment">// 第3个参数：returnAfterSourceHandled，设置为true，代表执行完source后就会退出当前loop</span></span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        [_innerThread start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))task &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !task) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(executeInnerTask:) onThread:<span class="keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stopThread) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - private methods</span></span><br><span class="line">- (<span class="keyword">void</span>)stopThread &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeInnerTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))task &#123;</span><br><span class="line">    <span class="keyword">if</span> (task) task();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><h3 id="2，解决NSTimer在UIScrollView滑动时停止工作"><a href="#2，解决NSTimer在UIScrollView滑动时停止工作" class="headerlink" title="2，解决NSTimer在UIScrollView滑动时停止工作"></a>2，解决NSTimer在UIScrollView滑动时停止工作</h3><p>修改Runloop的Mode即可。</p><h3 id="3，监控应用卡顿"><a href="#3，监控应用卡顿" class="headerlink" title="3，监控应用卡顿"></a>3，监控应用卡顿</h3><p>常见原因：<br>死锁：主线程拿到锁 A，需要获得锁 B，而同时某个子线程拿了锁 B，需要锁 A，这样相互等待就死锁了。<br>抢锁：主线程需要访问 DB，而此时某个子线程往 DB 插入大量数据。通常抢锁的体验是偶尔卡一阵子，过会就恢复了。<br>主线程大量 IO：主线程为了方便直接写入大量数据，会导致界面卡顿。<br>主线程大量计算：算法不合理，导致主线程某个函数占用大量 CPU。<br>大量的 UI 绘制：复杂的 UI、图文混排等，带来大量的 UI 绘制。</p><blockquote><p>主线程绝大部分计算或者绘制任务都是以Runloop为单位发生。单次Runloop如果时长超过16ms，就会导致UI体验的卡顿。    ——by mrpeak前辈</p></blockquote><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>创建一个子线程，监控主线程的活动情况，如果发现有卡顿，就将堆栈dump下来。如何监控？主要利用Runloop状态监听，kCFRunLoopExit的时间，减去kCFRunLoopEntry的时间，获得一次Runloop所耗费的时间。<br>实际上，主线程的RunLoop是在应用启动时自动开启的，主线程中的block、交互事件、以及其他任务都是在kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting之间执行，所以可以在即将开始执行Sources时，记录一下起始时间，并标记任务状态为YES，将要进入睡眠状态时，标记置为NO。</p><p>第一种方式是添加一个定时器，设定为2秒一次回调，也即每隔2秒计算一下时间差看是否会有卡顿发生。有同学已经给出了<a href="http://hl1987.com/2018/04/27/RunLoop总结：RunLoop的应用场景（四）App卡顿监测/" target="_blank" rel="noopener">方法</a>。</p><p>每次定时器回调时，若任务状态仍然为YES（说明Runloop在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间），则判断时间有没有超过阈值：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> RunLoopTimerCallBack(<span class="built_in">CFRunLoopTimerRef</span> timer, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">     YAFluencyMonitorManager *manager = (__bridge YAFluencyMonitorManager *)info;</span><br><span class="line">     <span class="keyword">if</span> (!manager.excuting) <span class="keyword">return</span>;</span><br><span class="line">     <span class="built_in">NSTimeInterval</span> excuteTime = [<span class="built_in">NSDate</span>.date timeIntervalSinceDate:manager.startDate];</span><br><span class="line">     <span class="keyword">if</span> (excuteTime &gt;= manager.fault) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"线程卡顿了%f秒"</span>, excuteTime);</span><br><span class="line">         [manager handleStackInfo];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，我从数据库中读出1000条数据，再把这1000条数据写到数据库中，这些操作都在主线程进行，利用第三方框架CrashReporter可以看到函数调用栈：</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">Thread <span class="number">0</span>:</span><br><span class="line"><span class="number">0</span>   libsystem_kernel.dylib              <span class="number">0x00000001874cb42c</span> fsync + <span class="number">8</span></span><br><span class="line"><span class="number">1</span>   libsqlite3.dylib                    <span class="number">0x00000001893549ec</span> sqlite3_randomness + <span class="number">2520</span></span><br><span class="line"><span class="number">2</span>   libsqlite3.dylib                    <span class="number">0x000000018934a780</span> sqlite3_free_table + <span class="number">62008</span></span><br><span class="line"><span class="number">3</span>   libsqlite3.dylib                    <span class="number">0x0000000189335d0c</span> sqlite3_value_text + <span class="number">23504</span></span><br><span class="line"><span class="number">4</span>   libsqlite3.dylib                    <span class="number">0x0000000189301f44</span> sqlite3_finalize + <span class="number">3608</span></span><br><span class="line"><span class="number">5</span>   libsqlite3.dylib                    <span class="number">0x000000018932e774</span> sqlite3_step + <span class="number">60828</span></span><br><span class="line"><span class="number">6</span>   libsqlite3.dylib                    <span class="number">0x000000018931fb5c</span> sqlite3_step + <span class="number">388</span></span><br><span class="line"><span class="number">7</span>   FMDB                                <span class="number">0x00000001051b39d0</span> -[FMDatabase executeUpdate:error:withArgumentsInArray:orDictionary:orVAList:] + <span class="number">3152</span></span><br><span class="line"><span class="number">8</span>   FMDB                                <span class="number">0x00000001051b4038</span> -[FMDatabase executeUpdate:] + <span class="number">96</span></span><br><span class="line"><span class="number">9</span>   FMDB                                <span class="number">0x00000001051b4ab8</span> -[FMDatabase commit] + <span class="number">48</span></span><br><span class="line"><span class="number">10</span>  FMDB                                <span class="number">0x00000001051bb270</span> __46-[FMDatabaseQueue beginTransaction:withBlock:]_block_invoke + <span class="number">592</span></span><br><span class="line"><span class="number">11</span>  libdispatch.dylib                   <span class="number">0x00000001053d2bd8</span> _dispatch_client_callout + <span class="number">16</span></span><br><span class="line"><span class="number">12</span>  libdispatch.dylib                   <span class="number">0x00000001053e1858</span> _dispatch_lane_barrier_sync_invoke_and_complete + <span class="number">124</span></span><br><span class="line"><span class="number">13</span>  FMDB                                <span class="number">0x00000001051bafd8</span> -[FMDatabaseQueue beginTransaction:withBlock:] + <span class="number">176</span></span><br><span class="line"><span class="number">14</span>  FMDB                                <span class="number">0x00000001051bb2dc</span> -[FMDatabaseQueue inTransaction:] + <span class="number">80</span></span><br><span class="line"><span class="number">15</span>  Splash                              <span class="number">0x0000000104cb0be4</span> +[YAFeedPhotoDBManager savePhotoListToDataBase:] + <span class="number">388</span></span><br><span class="line"><span class="number">16</span>  Splash                              <span class="number">0x0000000104c9f380</span> __65-[YAFeedAPIManager parseAPIManager:successResult:isFromDataBase:]_block_invoke + <span class="number">80</span></span><br><span class="line"><span class="number">17</span>  Splash                              <span class="number">0x0000000104cb09d8</span> __73+[YAFeedPhotoDBManager loadPhotoListWithStartTime:limitCount:completion:]_block_invoke + <span class="number">60</span></span><br><span class="line"><span class="number">18</span>  libdispatch.dylib                   <span class="number">0x00000001053d17fc</span> _dispatch_call_block_and_release + <span class="number">24</span></span><br><span class="line"><span class="number">19</span>  libdispatch.dylib                   <span class="number">0x00000001053d2bd8</span> _dispatch_client_callout + <span class="number">16</span></span><br><span class="line"><span class="number">20</span>  libdispatch.dylib                   <span class="number">0x00000001053e0c34</span> _dispatch_main_queue_callback_4CF + <span class="number">1316</span></span><br><span class="line"><span class="number">21</span>  CoreFoundation                      <span class="number">0x000000018764f3a8</span> &lt;redacted&gt; + <span class="number">12</span></span><br><span class="line"><span class="number">22</span>  CoreFoundation                      <span class="number">0x000000018764a39c</span> &lt;redacted&gt; + <span class="number">2004</span></span><br><span class="line"><span class="number">23</span>  CoreFoundation                      <span class="number">0x00000001876498a0</span> CFRunLoopRunSpecific + <span class="number">464</span></span><br><span class="line"><span class="number">24</span>  GraphicsServices                    <span class="number">0x00000001915a1328</span> GSEventRunModal + <span class="number">104</span></span><br><span class="line"><span class="number">25</span>  UIKitCore                           <span class="number">0x000000018b73a740</span> UIApplicationMain + <span class="number">1936</span></span><br><span class="line"><span class="number">26</span>  Splash                              <span class="number">0x0000000104cac944</span> main + <span class="number">120</span></span><br><span class="line"><span class="number">27</span>  libdyld.dylib                       <span class="number">0x00000001874d4360</span> &lt;redacted&gt; + <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以看到，问题就在<code>+[YAFeedPhotoDBManager savePhotoListToDataBase:]</code>这行代码了。</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>第二种方式主要是对检测粒度的改进。比如，卡顿阈值T=500ms、卡顿次数N=1，可以判定为单次耗时较长的一次有效卡顿；而卡顿阈值T=50ms、卡顿次数N=5，可以判定为频次较快的一次有效卡顿。这样就需要对每次Runloop时间段做处理。<a href="https://juejin.im/post/5cacb2baf265da03904bf93b" target="_blank" rel="noopener">minjing_linlv同学</a>有给出Demo，作者没有使用定时器来定时监测卡顿状况，而是“实时计算两个状态区域之间的耗时是否到达某个阀值”。</p><p>把代码down下来试了一试，发现作者是把卡顿耗时和卡顿次数两个条件综合起来判断的，耗时的实现是利用dispatch_semaphore_wait函数，设置了超时参数。</p><p>不过代码这块有几个地方值得商榷：<br>1，子线程卡顿监控最好开一个独立的常驻线程，而作者却用了一个全局队列。<br>2，“发生一次有效的卡顿回调函数”，设置这种接口而且暴露给外界不知道意义何在，发生卡顿难道不是这个单例自己处理并上报吗？<br>3，在setter方法中手动调用willChangeValueForKey和didChangeValueForKey，貌似是为了手动触发KVO，但是却又不重写automaticallyNotifiesObserversForName方法，那这么做图啥？</p><p>只看作者思路，这种方式较方案一显得细腻，还是挺棒的。</p><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>其实最棒的还是<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207890859&amp;idx=1&amp;sn=e98dd604cdb854e7a5808d2072c29162&amp;scene=4" target="_blank" rel="noopener">《微信iOS卡顿监控系统》</a>这篇文章介绍的。</p><p>总结一下key point：<br>1，CPU 占用超过了100%和主线程 Runloop 执行了超过2秒综合起来判断是一次卡顿发生了（需要双核iPhone）。<br>2，遇到相同的卡顿堆栈，按照斐波那契数列将检查时间递增，避免同一个卡顿写入多个文件，也避免检测线程围着同一个卡顿空转。<br>3，主要根据堆栈的最内层归类，这样能够将同一原因的卡顿归类起来。<br>4，抽样上报，减小后台压力。</p><h3 id="4，应用起死回生"><a href="#4，应用起死回生" class="headerlink" title="4，应用起死回生"></a>4，应用起死回生</h3><p>App出现异常后，手动创建一个循环，在这个循环里面跑Runloop的所有mode。主要就是下面这段代码：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出runLoop所有运行的mode</span></span><br><span class="line"><span class="built_in">NSArray</span> *allModes = <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CFRunLoopCopyAllModes</span>(<span class="built_in">CFRunLoopGetCurrent</span>()));</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *mode <span class="keyword">in</span> allModes) &#123;</span><br><span class="line">    <span class="comment">//在每个 mode 中轮流运行至少0.001 秒</span></span><br><span class="line">        <span class="built_in">CFRunLoopRunInMode</span>((<span class="built_in">CFStringRef</span>)mode, <span class="number">0.001</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，如果在自己手动创建的循环里面又一次出现crash，那神仙也没办法了。</p><p>整理一下，是这样：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YACrashHandlerManager</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> shouldIgnore;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YACrashHandlerManager</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)handleException:(<span class="built_in">NSException</span> *)exception &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *message = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"崩溃原因如下:\n%@\n%@"</span>,</span><br><span class="line">                         [exception reason],</span><br><span class="line">                         [[exception userInfo]</span><br><span class="line">                          objectForKey:kCaughtExceptionStackInfoKey]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,message);</span><br><span class="line">    <span class="comment">// 弹出弹窗, 设置shouldIgnore的值</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *allModes = <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CFRunLoopCopyAllModes</span>(<span class="built_in">CFRunLoopGetCurrent</span>()));</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">self</span>.shouldIgnore) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *mode <span class="keyword">in</span> allModes) &#123;</span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>((<span class="built_in">CFStringRef</span>)mode, <span class="number">0.001</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    configCatchExceptionHandler(<span class="literal">YES</span>);</span><br><span class="line">    <span class="keyword">if</span> ([[exception name] isEqual:kSignalExceptionName]) &#123;</span><br><span class="line">        kill(getpid(), [[[exception userInfo] objectForKey:kSignalKey] intValue]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [exception raise];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> *getBacktrace() &#123;</span><br><span class="line">    <span class="keyword">void</span> *callstack[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> frames = backtrace(callstack, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">char</span> **strs = backtrace_symbols(callstack, frames);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *backtrace = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:frames];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frames; i++) &#123;</span><br><span class="line">        [backtrace addObject:[<span class="built_in">NSString</span> stringWithUTF8String:strs[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    free(strs);</span><br><span class="line">    <span class="keyword">return</span> backtrace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> configCatchExceptionHandler(<span class="built_in">BOOL</span> isNil) &#123;</span><br><span class="line">    <span class="keyword">void</span> (*handler)(<span class="keyword">int</span>) = SIG_DFL;</span><br><span class="line">    <span class="built_in">NSUncaughtExceptionHandler</span> *exc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isNil) &#123;</span><br><span class="line">        handler = signalHandler;</span><br><span class="line">        exc = &amp;handleException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(exc);</span><br><span class="line">    signal(SIGABRT, handler);</span><br><span class="line">    signal(SIGILL, handler);</span><br><span class="line">    signal(SIGSEGV, handler);</span><br><span class="line">    signal(SIGFPE, handler);</span><br><span class="line">    signal(SIGBUS, handler);</span><br><span class="line">    signal(SIGPIPE, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> handleException(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="built_in">NSException</span> *customException = [<span class="built_in">NSException</span> exceptionWithName:[exception name] reason:[exception reason] userInfo:@&#123;kCaughtExceptionStackInfoKey: [exception callStackSymbols]&#125;];</span><br><span class="line">    [[YACrashHandlerManager sharedManager] performSelectorOnMainThread:<span class="keyword">@selector</span>(handleException:) withObject:customException waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> signalHandler(<span class="keyword">int</span> signal) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *stack = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, getBacktrace()];</span><br><span class="line">    <span class="built_in">NSException</span> *customException = [<span class="built_in">NSException</span> exceptionWithName:kSignalExceptionName</span><br><span class="line">                                                           reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedString</span>(<span class="string">@"Signal %d was raised."</span>, <span class="literal">nil</span>), signal]</span><br><span class="line">                                                         userInfo:@&#123;kSignalKey:[<span class="built_in">NSNumber</span> numberWithInt:signal], kCaughtExceptionStackInfoKey: stack&#125;];</span><br><span class="line">    [[YACrashHandlerManager sharedManager] performSelectorOnMainThread:<span class="keyword">@selector</span>(handleException:) withObject:customException waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="自实现"><a href="#自实现" class="headerlink" title="自实现"></a>自实现</h2><p>这篇文章有空写一点，结果发出来都12月份了。太忙了，hold不住。。。立个flag，2020年Q1自实现一个Runloop。</p><blockquote><p>网上搜了几篇很棒的文章：<br><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="noopener">iOS 并发编程之 Operation Queues</a><br><a href="http://dnduuhn.com/2018/12/02/iOS-多线程编程知识整理/" target="_blank" rel="noopener">iOS 多线程编程知识整理</a><br><a href="http://dnduuhn.com/2018/12/11/iOS-多线编程之线程安全/" target="_blank" rel="noopener">iOS 多线编程之线程安全</a><br><a href="http://zenonhuang.me/2018/03/08/technology/2018-03-01-LockForiOS/" target="_blank" rel="noopener">谈 iOS 的锁</a><br><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">@synchronized，这儿比你想知道的还要多</a><br><a href="http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/" target="_blank" rel="noopener">Threading Programming Guide(2)</a><br><a href="http://zenonhuang.me/2018/04/17/technology/2018-04-17-Runloop/" target="_blank" rel="noopener">RunLoop 源码阅读</a><br><a href="http://zhengtingi.cc/2017/02/20/RunLoop1/" target="_blank" rel="noopener">RunLoop深入学习笔记</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 回顾了多线程、Runloop相关的重点知识。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的Crash防护</title>
    <link href="http://blog.chenyalun.com/2019/09/11/iOS%E4%B8%AD%E7%9A%84Crash%E9%98%B2%E6%8A%A4/"/>
    <id>http://blog.chenyalun.com/2019/09/11/iOS中的Crash防护/</id>
    <published>2019-09-11T14:18:38.000Z</published>
    <updated>2019-10-27T08:13:47.446Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 避免App crash。 </p><a id="more"></a><p>App的质量评测主要有两个关注点，一个是Crash，另一个是卡顿。手百已经建立了卡顿监测平台，主要是通过监测主线程的Runloop的状态切换耗时实现。对于Crash只做了收集，及时报告给个业务方，但并没有“防护”平台（貌似由于种种原因目前还没有完成）。假如需要做一个简单的crash防护措施，该怎么着手呢？</p><p><a href="https://neyoufan.github.io/2017/01/13/ios/BayMax_HTSafetyGuard/" target="_blank" rel="noopener">《大白健康系统–iOS APP运行时Crash自动修复系统》</a>这篇文章总结地很不错了，网上很多组件都是根据这篇文章开发的（手百内部也有参考）。本文在前辈们的基础上，简单叙述下自己的想法。</p><h1 id="一、常见Crash类型"><a href="#一、常见Crash类型" class="headerlink" title="一、常见Crash类型"></a>一、常见Crash类型</h1><h2 id="1-unrecognized-selector-crash"><a href="#1-unrecognized-selector-crash" class="headerlink" title="1. unrecognized selector crash"></a>1. unrecognized selector crash</h2><p><code>unrecognized selector sent to instance</code>类型的crash是比较常见的，原因是没有找到方法的实现。H5与NA交互时，别人难免会调错；项目在合并分支、重构等大改动的时候也难免不小心把方法的实现删掉了（这种情况俺遇到好多次了==）。这类crash的防护是最有意义的，一来解决了体验问题，二来只是添加一个单纯的实现，一般不会影响其他功能和数据。</p><p>根据消息机制，resolveInstanceMethod需要在类中提前加上，略显冗余；forwardInvocation需要创建NSInvocation，开销较大且常被外界重写以转发消息。<a href="https://neyoufan.github.io/2017/01/13/ios/BayMax_HTSafetyGuard/" target="_blank" rel="noopener">最适合的还是forwardingTargetForSelector</a>。</p><p>需要考虑的有：</p><ol><li>防护实例方法和类方法。</li><li>防护的方法要可供选择，如白名单，或者前缀等（避免影响其他业务方）。</li><li>获取crash的函数调用栈以供追踪。</li><li>不能影响已重写了<code>forwardInvocation:</code>方法（含实例方法和类方法）的类。</li></ol><p>第一条，方法交换时传入类对象或者元类对象即可；<br>第二条，可以获取当前的classString进行定制化判断；<br>第三条，<code>[NSThread callStackSymbols]</code>可以获取调用栈；<br>第四条，可以参考KVO中判断<code>willChangeValueForKey:</code>是否已被重写的逻辑—<a href="https://blog.chenyalun.com/2019/05/31/Key-Value%20Observing源码初探/">比较IMP是否一致</a>。也即比较NSObject和当前类中的<code>forwardInvocation:</code>方法的IMP是否一致；当然，需要对<code>-forwardInvocation:</code>和<code>+forwardInvocation:</code>区分；</p><p>这样，首先添加一个继承自NSObject的target，重写resolveInstanceMethod和resolveClassMethod以添加空白的方法实现：<code>forwardingTargetDynamicMethod</code>。这里也是获取调用栈的好时机：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define kYACurrentCallStackSymbols [NSString stringWithFormat:@<span class="meta-string">"%@"</span>,[NSThread callStackSymbols]]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAForwardingTarget</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAForwardingTarget</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> forwardingTargetDynamicMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;&#125;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    class_addMethod(<span class="keyword">self</span>.class, sel, (IMP)forwardingTargetDynamicMethod, <span class="string">"v@:"</span>);</span><br><span class="line">    [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Unrecognized instance Method: %@\n调用栈是:%@"</span>, <span class="built_in">NSStringFromSelector</span>(sel), kYACurrentCallStackSymbols);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    class_addMethod(object_getClass(<span class="keyword">self</span>), sel, (IMP)forwardingTargetDynamicMethod, <span class="string">"v@:"</span>);</span><br><span class="line">    [class_getSuperclass(<span class="keyword">self</span>) resolveClassMethod:sel];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Unrecognized class Method: %@\n调用栈是:%@"</span>, <span class="built_in">NSStringFromSelector</span>(sel), kYACurrentCallStackSymbols);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>利用方法交换，在NSObject的分类中hook <code>forwardingTargetForSelector:</code>方法处理转发逻辑：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">YAResolveUnrecognizedSelector</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">YAResolveUnrecognizedSelector</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        ya_methodSwizzle(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(forwardingTargetForSelector:), <span class="keyword">@selector</span>(swizzleForwardingTargetForSelector:));</span><br><span class="line">        ya_methodSwizzle(object_getClass(<span class="keyword">self</span>), <span class="keyword">@selector</span>(forwardingTargetForSelector:), <span class="keyword">@selector</span>(swizzleForwardingTargetForSelector:));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define swizzleForwardingTargetForSelector(arg) \</span></span><br><span class="line">arg (<span class="keyword">id</span>)swizzleForwardingTargetForSelector:(SEL)aSelector &#123; \</span><br><span class="line">    <span class="keyword">id</span> result = [<span class="keyword">self</span> swizzleForwardingTargetForSelector:aSelector]; \</span><br><span class="line">    <span class="keyword">if</span> (result) <span class="keyword">return</span> result; \</span><br><span class="line">    <span class="built_in">NSString</span> *classString = <span class="built_in">NSStringFromClass</span>(object_getClass(<span class="keyword">self</span>)); \</span><br><span class="line">    <span class="built_in">BOOL</span> isClsMethod = [@<span class="meta">#arg isEqualToString:@<span class="meta-string">"+"</span>]; /* 区分类方法和实例方法 */\</span></span><br><span class="line">    Class currCls = isClsMethod ? object_getClass(<span class="keyword">self</span>) : <span class="keyword">self</span>.class;\</span><br><span class="line">    Class oriCls = isClsMethod ? object_getClass(<span class="built_in">NSObject</span>.class) : <span class="built_in">NSObject</span>.class;\</span><br><span class="line">    IMP currentImp = class_getMethodImplementation_stret(currCls, <span class="keyword">@selector</span>(forwardInvocation:));\</span><br><span class="line">    IMP originImp = class_getMethodImplementation_stret(oriCls, <span class="keyword">@selector</span>(forwardInvocation:));\</span><br><span class="line">    <span class="comment">/* 也可以添加白名单. */</span> \</span><br><span class="line">    <span class="keyword">if</span> ([classString hasPrefix:<span class="string">@"YA"</span>] &amp;&amp; currentImp == originImp) &#123; \</span><br><span class="line">        <span class="comment">/* 避免crash. */</span>\</span><br><span class="line">        <span class="keyword">return</span> isClsMethod ? YAForwardingTarget.class : [YAForwardingTarget new]; \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">/* 抛出异常. */</span> \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; \</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class method and instance method.</span></span><br><span class="line">swizzleForwardingTargetForSelector(+)</span><br><span class="line">swizzleForwardingTargetForSelector(-)</span><br><span class="line"><span class="meta">#undef swizzleForwardingTargetForSelector</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>在获取到classString时，可以根据下发的白名单判断是否需要防护，当然也可以直接判断前缀，只防护自己业务的方法。</p><h2 id="2-容器-crash"><a href="#2-容器-crash" class="headerlink" title="2. 容器 crash"></a>2. 容器 crash</h2><p>再一个比较常见的就是容器crash，比如向NSMutableArray中添加空元素抛出异常。这种crash看似很低级，但却防不胜防。当向一个数组中添加元素时，需要由开发者考虑这个元素有没有可能为空，如果有，做空值判断；如果没有，直接添加即可。但是这种“考虑”往往不是百分百可靠的。最保险的办法是对所有被添加的元素都做空值判断，可是项目中的容器何其多，每次都要if判断，是否有性能方面的影响呢？这就是另一种权衡了。</p><p>现在不考虑那么多，假定需要对NSMutableArray的addObject做防护，最简单的是添加一个safe方法：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@implementation</span> NSMutableArray (YAResolveNilObject)</span><br><span class="line">- (void)<span class="attribute">ya_addObject</span>:(id)anObject &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (anObject) &#123;</span><br><span class="line">        <span class="selector-attr">[self addObject:anObject]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p><p>之后使用时只需要使用<code>ya_addObject:</code>就行了。当然最优雅的还是进行hook，让外界继续使用原生方法：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@implementation</span> NSMutableArray (YAResolveNilObject)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    <span class="selector-tag">static</span> <span class="selector-tag">dispatch_once_t</span> <span class="selector-tag">onceToken</span>;</span><br><span class="line">    <span class="selector-tag">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="selector-tag">ya_methodSwizzle</span>(NSClassFromString(@<span class="string">"__NSArrayM"</span>), <span class="variable">@selector</span>(<span class="attribute">addObject</span>:), <span class="variable">@selector</span>(<span class="attribute">ya_addObject</span>:));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">ya_addObject</span><span class="selector-pseudo">:(id)anObject</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (anObject) &#123;</span><br><span class="line">        <span class="selector-attr">[self ya_addObject:anObject]</span>;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        <span class="selector-tag">NSLog</span>(@<span class="string">"防护了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是Array系列是类簇，直接hook NSMutableArray是无法成功的，需要hook对外隐藏的实际起作用的类：<code>__NSArrayM</code>。还有就是如果要考虑线程安全的话，自己再通过加锁来保证（这种case较少，建议单独写一个线程安全的addObject，一股脑全都加锁实在没有必要）。不然 <code>if (anObject)</code>判断时发现为<code>YES</code>，而到<code>addObject:</code>时，anObject又为空了，十分尴尬。</p><p>除了addObject时的判空，还有objectAtIndex时的range判断，也需要处理。</p><p>NSMutableArray是这样，那NSMutableSet、NSMutableDictionary、NSCache等类也好说了。</p><h2 id="3-KVO-crash"><a href="#3-KVO-crash" class="headerlink" title="3. KVO crash"></a>3. KVO crash</h2><p>KVO引起crash有两种场景：<br>1，observer已经销毁，但是未及时移除监听；<br>2，addObserver与removeObserver不匹配（重复添加或移除、没有添加却移除等）；</p><h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><p>从“预防”层面讲，可以使用KVO的第三方框架：<a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">KVOController</a>。<br>1，使用单例接管了系统的observeValueForKeyPath方法，通过它再来分发调用。如果observer已经销毁，则不再回调（block），解决了第一个问题；<br>2，只有addObserver接口，其内部依赖容器避免外界重复addObserver，没有暴露removeObserver接口，解决了第二个问题；</p><p>而且KVOController极其优雅，只调用一个方法就可以完成一个对象的键值观测。更多介绍可以查看draveness大神的文章：<a href="https://draveness.me/kvocontroller" target="_blank" rel="noopener">《如何优雅地使用 KVO》</a>，当然也可以简单参考下俺写的水文<a href="https://blog.chenyalun.com/2019/01/12/「KVOController」的封装/">《「KVOController」的封装》</a>。</p><h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><p>好了，预防层面有办法解决了，那防护层面呢？“observer已经销毁，但是未及时移除监听”，针对这个问题很自然地想到在observer的dealloc方法中做移除监听操作。这种做法的思路是：<br>1， hook addObserver方法，object为key，keyPath数组作为value，与observer建立关系，大致是这种结构：<br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">observer1:</span> &#123;</span><br><span class="line"><span class="symbol">    object1:</span> [<span class="string">"keyPath1"</span>, <span class="string">"keyPath2"</span>], </span><br><span class="line"><span class="symbol">    object2:</span> [<span class="string">"keyPath3"</span>, <span class="string">"keyPath4"</span>],</span><br><span class="line">    <span class="comment">///....</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="symbol">observer2:</span> &#123;</span><br><span class="line"><span class="symbol">    object3:</span> [<span class="string">"keyPath5"</span>, <span class="string">"keyPath6"</span>], </span><br><span class="line"><span class="symbol">    object4:</span> [<span class="string">"keyPath7"</span>, <span class="string">"keyPath8"</span>],</span><br><span class="line">    <span class="comment">///....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2， hook observer的dealloc方法，在这里面逐个移除object的keyPath监听：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// observer1</span></span><br><span class="line">[object1 <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>keyPath1];</span><br><span class="line">[object1 <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>keyPath2];</span><br><span class="line">[object2 <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>keyPath3];</span><br><span class="line">[object2 <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>keyPath4];</span><br><span class="line"></span><br><span class="line"><span class="comment">// observer2</span></span><br><span class="line"><span class="comment">/// ...</span></span><br></pre></td></tr></table></figure></p><p>具体代码实现层面，NSMapTable可以支持直接使用对象（object）作为key；keyPath的重复过滤可以使用NSMutableSet；可以使用一个标志位判断是否重复添加或者移除；</p><p>hook后的addObserver方法：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">ya_addObserver:</span>(NSObject *)observer <span class="string">forKeyPath:</span>(NSString *)keyPath <span class="string">options:</span>(NSKeyValueObservingOptions)options <span class="string">context:</span>(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    BOOL shouldAddObserver = YES;</span><br><span class="line">    NSString *observerKey = [NSString <span class="string">stringWithFormat:</span>@<span class="string">"%p"</span>, observer];</span><br><span class="line">    <span class="keyword">if</span> (!mainMap) &#123;</span><br><span class="line">        mainMap = [NSMutableDictionary dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMapTable *subMap = [mainMap <span class="string">objectForKey:</span>observerKey];</span><br><span class="line">    <span class="keyword">if</span> (!subMap) &#123;</span><br><span class="line">        subMap = [NSMapTable strongToStrongObjectsMapTable];</span><br><span class="line">        NSMutableSet *set = [NSMutableSet <span class="string">setWithObject:</span>keyPath];</span><br><span class="line">        [subMap <span class="string">setObject:</span>set <span class="string">forKey:</span>self];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NSMutableSet *set = [subMap <span class="string">objectForKey:</span>self];</span><br><span class="line">        <span class="keyword">if</span> ([set <span class="string">containsObject:</span>keyPath]) &#123;</span><br><span class="line">            <span class="comment">// 重复addObserver</span></span><br><span class="line">            shouldAddObserver = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        [set <span class="string">addObject:</span>keyPath];</span><br><span class="line">    &#125;</span><br><span class="line">    [mainMap <span class="string">setObject:</span>subMap <span class="string">forKey:</span>observerKey];</span><br><span class="line">    <span class="keyword">if</span> (shouldAddObserver) &#123;</span><br><span class="line">        [self <span class="string">ya_addObserver:</span>observer <span class="string">forKeyPath:</span>keyPath <span class="string">options:</span>options <span class="string">context:</span>context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同理，removeObserver原理大致相同，就不再复述了。</p><p>hook后的dealloc方法：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ya_dealloc &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selfKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, <span class="keyword">self</span>];</span><br><span class="line">    <span class="built_in">NSMapTable</span> *subMap = [mainMap objectForKey:selfKey];</span><br><span class="line">    <span class="keyword">if</span> (subMap) &#123;</span><br><span class="line">        [[[subMap keyEnumerator] allObjects] enumerateObjectsUsingBlock:^(<span class="keyword">id</span> object, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">          <span class="built_in">NSSet</span> *set = [subMap objectForKey:object];</span><br><span class="line">          [set enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">              [object removeObserver:<span class="keyword">self</span> forKeyPath:key];</span><br><span class="line">          &#125;];</span><br><span class="line">          <span class="comment">// 移除keyPath</span></span><br><span class="line">          [subMap removeObjectForKey:object];</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">// 移除subMap</span></span><br><span class="line">        [mainMap removeObjectForKey:selfKey];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> ya_dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这种方式有个问题：hook dealloc方法风险极大，因为这个方法关乎App中所有对象的释放，代码一旦有瑕疵，后果不堪设想。子线程调用、hook方式正确与否都会产生<a href="https://www.valiantcat.cn/index.php/2017/11/03/53.html" target="_blank" rel="noopener">潜在的风险</a>，应该尽量避免这种风险极大的操作。那还有其他方式能在对象销毁之前做点事吗？有的。关联对象。<br>一个对象在dealloc之前会移除自己的所有关联对象，我们可以自定义一个对象，将其作为NSObject的关联对象，同时在这个自定义对象的dealloc方法中做上面的操作。为了避免循环引用，自定义的对象不能强引用NSObject，但是使用weak的话，在实践中会发现被关联的NSObject已经销毁了，根本获取不到，所以这里使用<code>unsafe_unretained</code>。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 被关联的对象</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAKVOInfoObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 注意使用unsafe_unretained修饰</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>) <span class="keyword">id</span> object;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAKVOInfoObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">id</span> observer = <span class="keyword">self</span>.object;</span><br><span class="line">        <span class="built_in">NSString</span> *observerKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, observer];</span><br><span class="line">        <span class="built_in">NSMapTable</span> *subMap = [mainMap objectForKey:observerKey];</span><br><span class="line">        <span class="keyword">if</span> (subMap) &#123;</span><br><span class="line">          [[[subMap keyEnumerator] allObjects] enumerateObjectsUsingBlock:^(<span class="keyword">id</span> object, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            <span class="built_in">NSSet</span> *set = [subMap objectForKey:object];</span><br><span class="line">            [set enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">                [object removeObserver:observer forKeyPath:key];</span><br><span class="line">            &#125;];</span><br><span class="line">            <span class="comment">// 移除keyPath</span></span><br><span class="line">            [subMap removeObjectForKey:object];</span><br><span class="line">          &#125;];</span><br><span class="line">          <span class="comment">// 移除subMap</span></span><br><span class="line">          [mainMap removeObjectForKey:observerKey];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 分类，用于设置关联对象</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">YAKVOInfoObject</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)ya_setKVOInfoObject:(YAKVOInfoObject *)object &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">"ya_kVOInfoObject"</span>, object, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>这样一来似乎更体面一点了，设置关联对象的时机自然是在成功addObserver的时候，而且每个对象只需要设置一次即可。</p><p>需要注意的是，由于需要严格依赖observer的dealloc方法，如果系统的自动释放池出现了延时释放，会导致observer被销毁之后过一段时间关联对象才会释放，这时候使用<code>unsafe_unretained</code>访问的就是非法地址。所以需要在关联对象的dealloc方法中添加上自己的自动释放池。这一点我确实没有想到，请参考<a href="https://www.valiantcat.cn/index.php/2017/11/03/53.html" target="_blank" rel="noopener">这篇文章</a>。</p><p>到这里，removeObserver的时机已经搞定了，至于对这些keyPath和object的保存，可以参考上面的代码使用全局的容器，当然也可以把它们放在关联对象YAKVOInfoObject中存储。还有一种方式，是使用代理，不过我想了一下，要是使用代理，首先要设置observer的delegate为object，然后还要在observer销毁的时候移除delegate（也就是object）的keyPath监听，但是keyPath需要保存，observer销毁的时机同样需要hook，似乎observer与object只是多了一层直接联系，并且把结构搞得更加复杂了。。。</p><p>至于未及时移除NSNotificationCenter的监听产生的crash在iOS9之后已经不存在了，而且我在<a href="https://blog.chenyalun.com/2019/01/28/NSNotificationCenter探索/">《NSNotificationCenter探索》</a>这篇文章中还利用弱引用容器简单实现了个demo，即便不移除也不会产生异常，作为练习之用。目前App的最低版本已经是iOS9了，不过还是建议addObserver后能有对应的removeObserver，有头有尾，严谨一些。当然，要是铁了心非要对它加上防护，原理与KVO这个类似，或者说更简单了，毕竟不需要保存keyPath、object之类的。</p><h2 id="4-NSTimer-crash"><a href="#4-NSTimer-crash" class="headerlink" title="4. NSTimer crash"></a>4. NSTimer crash</h2><p>NSTimer会强引用着target，target往往也需要强引用着NSTimer，容易产生循环引用，引发内存泄漏进而可能产生crash问题（ps：CADisplayLink同理，推荐使用不依赖Runloop更准时的dispatch_source_t）。</p><p>可以举个循环引用的例子：控制器强引用着YASinger对象，YASinger对象强引用着NSTimer。当控制器调用<code>self.singer = nil;</code>的时候，会发现sing方法依然在不停调用。可见，NSTimer内部又强引用着YASinger对象，二者是循环引用，控制器把YASinger对象的引用计数减1并不能使得它及时销毁。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YASinger</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YASinger</span></span></span><br><span class="line">- (<span class="keyword">void</span>)sing &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"YASinger  show"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startTask &#123;</span><br><span class="line">    YASinger *singer = [YASinger new];</span><br><span class="line">    singer.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:singer selector:<span class="keyword">@selector</span>(sing) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="keyword">self</span>.singer = singer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一般解决NSTimer的循环引用问题有三种方法。</strong></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><strong>使用block作为中间件，可以参考BlocksKit2.2.5的实现：</strong><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">BlocksKit</span>)</span></span><br><span class="line">+ (<span class="keyword">id</span>)bk_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)inTimeInterval block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block repeats:(<span class="built_in">BOOL</span>)inRepeats</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> scheduledTimerWithTimeInterval:inTimeInterval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(bk_executeBlockFromTimer:) userInfo:[block <span class="keyword">copy</span>] repeats:inRepeats];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)bk_timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)inTimeInterval block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block repeats:(<span class="built_in">BOOL</span>)inRepeats</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> timerWithTimeInterval:inTimeInterval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(bk_executeBlockFromTimer:) userInfo:[block <span class="keyword">copy</span>] repeats:inRepeats];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)bk_executeBlockFromTimer:(<span class="built_in">NSTimer</span> *)aTimer &#123;</span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="built_in">NSTimer</span> *) = [aTimer userInfo];</span><br><span class="line"><span class="keyword">if</span> (block) block(aTimer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>NSTimer实例对象直接强引用着NSTimer的类对象（单例），通过持有block再间接持有外界的target。这样NSTimer与target的引用问题就转化为NSTimer的block与target的引用问题。而这类问题是我们非常熟悉的，可以通过weakSelf-strongSelf解决：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">- (void)startTask &#123;</span><br><span class="line">    YASinger *singer = [YASinger new]<span class="comment">;</span></span><br><span class="line">    self.singer = singer<span class="comment">;</span></span><br><span class="line">    __weak YASinger *weakSinger = singer<span class="comment">;</span></span><br><span class="line">    singer.timer = [NSTimer <span class="keyword">bk_scheduledTimerWithTimeInterval:1 </span><span class="keyword">block:^(NSTimer </span>*timer) &#123;</span><br><span class="line">        __strong YASinger *singer = weakSinger<span class="comment">;</span></span><br><span class="line">        [singer sing]<span class="comment">;</span></span><br><span class="line">    &#125; repeats:YES]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>使用继承自NSObject的对象作为中间件，弱引用着target：</strong><br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YAWeakTarget </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, weak)   id target;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) SEL selector;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) NSTimer *timer;;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> YAWeakTarget</span><br><span class="line">- (void)<span class="attribute">timerTask</span>:(NSTimer *)timer &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (self.target) &#123;</span><br><span class="line">        <span class="selector-attr">[self.target performSelector:self.selector withObject:timer.userInfo]</span>;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        <span class="selector-attr">[self.timer invalidate]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p><p>由YAWeakTarget保存着target、selector和timer，并负责间接调用target的selector方法。使用的时候，统一调用YAWeakTarget的<code>timerTask:</code>方法：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startTask &#123;</span><br><span class="line">    YASinger *singer = [YASinger <span class="keyword">new</span>];</span><br><span class="line">    self.singer = singer;</span><br><span class="line">    YAWeakTarget *weakTarget = [YAWeakTarget <span class="keyword">new</span>];</span><br><span class="line">    weakTarget.target = singer;</span><br><span class="line">    weakTarget.selector = <span class="meta">@selector</span>(sing);</span><br><span class="line">    weakTarget.timer = [NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">1</span> <span class="string">target:</span>weakTarget <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">timerTask:</span>) <span class="string">userInfo:</span>@&#123;&#125; <span class="string">repeats:</span>YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一图胜千言：<br><img src="https://image.chenyalun.com/2019/09/11/001.png" style="zoom:40%"></p><p>打破循环引用的根本原因是NSTimer的invalidate方法得到执行。NSTimer在其invalidate方法调用后，Runloop会自动移除对它的引用，它也会移除对target和userInfo的强引用。</p><p>weakTarget一旦发现YASinger为nil，就会调用定时器的invalidate方法。因此，weakTarget强引用着timer也是没关系的（也就是图中的蓝线）。</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p><strong>使用继承自NSProxy的对象作消息转发：</strong><br><code>forwardInvocation:</code>和<code>methodSignatureForSelector:</code>两个基本方法必须实现。在这基础上，加上自己需要的。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    _target = target;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target respondsToSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.target respondsToSelector:invocation.selector]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>使用的时候，这么做就行了：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startTask &#123;</span><br><span class="line">    YASinger *singer = [YASinger <span class="keyword">new</span>];</span><br><span class="line">    self.singer = singer;</span><br><span class="line">    singer.timer = [NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">1</span> <span class="string">target:</span>[[YAProxy alloc] <span class="string">initWithTarget:</span>singer] <span class="string">selector:</span><span class="meta">@selector</span>(sing) <span class="string">userInfo:</span>@&#123;&#125; <span class="string">repeats:</span>YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这三种方法就个人而言，我更喜欢方法三。方法一需要时刻牢记weak-strong，影响代码美观；方法二不优雅，还要引入中间件。方法三中的Proxy专门做消息转发，而且复用性强，并不单单针对NSTimer的循环引用问题。</p><p>如此，根本方法有了，剩下的就是做相关方法的hook工作了，不再赘述。</p><h2 id="5-Bad-Access-crash"><a href="#5-Bad-Access-crash" class="headerlink" title="5. Bad Access crash"></a>5. Bad Access crash</h2><p>这种crash产生的原因是向已经销毁的对象发送消息。类型很常见，但是却又比较难排查。防护层面也是有办法的，原理是hook 需要监测的对象的dealloc方法，不让它释放内存（避免调用dealloc方法），并修改它的isa指针从而把之后的消息转发给固定的对象。</p><p>假定需要监测“YA”打头的所有对象：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">YAResolveZombie</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        ya_methodSwizzle(<span class="built_in">NSObject</span>.class, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"dealloc"</span>), <span class="keyword">@selector</span>(ya_dealloc));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ya_dealloc &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *clsName = <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class);</span><br><span class="line">    <span class="keyword">if</span> ([clsName hasPrefix:<span class="string">@"YA"</span>]) &#123;</span><br><span class="line">        <span class="comment">// 修改isa指针</span></span><br><span class="line">        object_setClass(<span class="keyword">self</span>, YAZombieInfoObject.class);</span><br><span class="line">        <span class="comment">// 记录类信息</span></span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">"ya_className"</span>, clsName, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他对象正常调用dealloc</span></span><br><span class="line">        [<span class="keyword">self</span> ya_dealloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>而这个YAZombieInfoObject对象是现成的（我看有文章使用动态生成class，确实没有必要），类似unrecognized selector crash的防护，记录类名、方法名、调用栈等信息即可。由于类对象是单例，所以只需要防护实例对象（实例方法）就行了。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAZombieInfoObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAZombieInfoObject</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> forwardingTargetDynamicMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *clsName = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="string">"ya_className"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Class name is %@, zombie instance Method is %@, \n调用栈是:%@"</span>,clsName,  <span class="built_in">NSStringFromSelector</span>(_cmd), kYACurrentCallStackSymbols);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    class_addMethod(<span class="keyword">self</span>.class, sel, (IMP)forwardingTargetDynamicMethod, <span class="string">"v@:"</span>);</span><br><span class="line">    [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这种方法有几个点需要考虑：<br>1，被监测对象的范围怎么衡量，是所有自定义的类吗？<br>2，被监测对象延迟释放会占用内存，内存限制多少合适？<br>3，被监测对象最终还是调要dealloc的，什么时机比较合适？<br>4，这种方法hook了dealloc方法，会不会有潜在的危险？</p><p>预防为主，下面简单列举几个这种类型的例子吧。</p><h3 id="block为nil"><a href="#block为nil" class="headerlink" title="block为nil"></a>block为nil</h3><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">void (^block)() = <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">block()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>一般是新人才犯这种错误。block在执行之前一定要判空，不然会造成程序读取内存地址时出错。</p><p>使用条件运算符可以使风格更加<a href="http://southpeak.github.io/2016/09/20/ios-techset-8/" target="_blank" rel="noopener">优雅</a>：<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">!<span class="built_in">block</span> ?: <span class="built_in">block</span>();</span><br></pre></td></tr></table></figure></p><h3 id="指针传递未判空"><a href="#指针传递未判空" class="headerlink" title="指针传递未判空"></a>指针传递未判空</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> saveText(<span class="built_in">NSString</span> *text, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="comment">// 保存文本却失败了</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递error</span></span><br><span class="line">    *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"error"</span> code:<span class="number">-1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">saveText(<span class="string">@"test"</span>, <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure><p>同样地，指针不做判空也是会出问题。</p><h3 id="assgin修饰对象"><a href="#assgin修饰对象" class="headerlink" title="assgin修饰对象"></a>assgin修饰对象</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSString</span> *cuid;</span><br></pre></td></tr></table></figure><p>这种错误一般是在复制、粘贴的时候没仔细review造成的，一旦出问题也很严重，而且排查起来极其蛋疼。。。</p><h3 id="self提前释放"><a href="#self提前释放" class="headerlink" title="self提前释放"></a>self提前释放</h3><p>为了保证性能，<code>self</code>的修饰是<code>__unsafe_unretained</code>而不是<code>strong</code>（<strong>一般情况下</strong>调用方都不会在方法执行时把这个对象释放所以不增加引用计数）。这就有可能造成方法还没有执行完毕，而自己（self）被释放掉，从而产生坏内存访问。</p><p>比如<a href="https://blog.sunnyxx.com/2015/01/17/self-in-arc/" target="_blank" rel="noopener">孙源大神文章中的例子</a></p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@class</span> YARequest;</span><br><span class="line"><span class="variable">@protocol</span> YARequestDelegate &lt;NSObject&gt;</span><br><span class="line">- (void)requestFinished;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">YARequest </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, weak) id &lt;YARequestDelegate&gt; delegate;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> YARequest</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    <span class="selector-attr">[self.delegate requestFinished]</span>;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"%@"</span>, self); <span class="comment">// EXC_BAD_ACCESS</span></span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>控制器中的方法：<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> YARequest *gRequest;</span><br><span class="line"><span class="comment">// 开始执行</span></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    gRequest = [YARequest <span class="keyword">new</span>];</span><br><span class="line">    gRequest.<span class="keyword">delegate</span> = self;</span><br><span class="line">    [<span class="meta">gRequest start</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line">- (<span class="keyword">void</span>)requestFinished &#123;</span><br><span class="line">    gRequest = nil;</span><br><span class="line">    NSLog(<span class="string">@"请求执行完毕"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很容易就发现EXC_BAD_ACCESS了。原因是在YARequest的代理方法中，控制器把YARequest置为nil了。这就造成继续在start方法中访问<code>self</code>产生了问题。</p><p>注意：这里的gRequest对象，直接使用了全局变量而不是属性。如果使用属性的getter取值，对象作为返回值会自动被auto release，引用计数会被干扰，就没办法复现了。</p><p>这个case出现的可能性比较低，但是也值得注意的。</p><h3 id="快速遍历下的-autoreleasing"><a href="#快速遍历下的-autoreleasing" class="headerlink" title="快速遍历下的__autoreleasing"></a>快速遍历下的<code>__autoreleasing</code></h3><p>指向引用类型指针的指针作为参数传递时，是使用<code>__autoreleasing</code>修饰的。比如NSFileManager中的删除文件方法：<code>removeItemAtURL:(NSURL *)url error:(NSError *__autoreleasing  *)error;</code><br>当这种指针遇见<code>enumerateObjectsUsingBlock</code>时，金风玉露一相逢，就该出问题了。比如这个<a href="http://tutuge.me/2016/04/30/autoreleasing-meet-autoreleasepool/" target="_blank" rel="noopener">例子</a>，看着没毛病，其实是有问题的：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决方法: void enumerateArray(__strong NSError **error) &#123;</span></span><br><span class="line"><span class="keyword">void</span> enumerateArray(<span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>, @<span class="number">5</span>];</span><br><span class="line">    [array enumerateObjectsUsingBlock:^(<span class="built_in">NSNumber</span> *obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">0</span> &amp;&amp; error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"error"</span> code:<span class="number">-1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    enumerateArray(&amp;error);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，编译器也会警告的：Block captures an autoreleasing out-parameter, which may result in use-after-free bugs。</p><p><code>__autoreleasing</code>修饰时，会把外界的这个对象放到自动释放池中，可是enumerateObjectsUsingBlock恰恰是会自己创建自动释放池的，这样一来，<code>*error</code>被创建之后在下次迭代之前就已经销毁了。于是外界访问已经释放的<code>*error</code>自然会出错了。解决这个问题也很简单，改为<code>__strong</code>修饰即可。</p><p>两个小点：<br>1、enumerateObjectsUsingBlock内部会自己创建自动释放池，<code>for循环</code>、<code>for in循环</code>是没有这个能力的。因为这是属于C语言的语法，自然不存在自动释放池的概念。不过要是自己手动添加<code>@autoreleasepool{}</code>，那就又另说了。<br>2、关于为啥指向引用类型的指针的指针默认是使用<code>__autoreleasing</code>修饰的，这个我觉得和引用类型的返回值需要被添加到自动释放池中是同样的道理：本来自己作用域内retain的对象就应该自己把它release，但是偏偏这个对象要延长它的生命周期以供外界使用，所以就需要被添加到autoreleasepool中延迟release了。</p><h3 id="IMP调用"><a href="#IMP调用" class="headerlink" title="IMP调用"></a>IMP调用</h3><p>坏内存：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SEL</span> sel = @selector(showText:);</span><br><span class="line"><span class="type">IMP</span> imp = [<span class="keyword">self</span>.target methodForSelector:sel]; <span class="comment">// self.target为nil</span></span><br><span class="line">id (*<span class="function"><span class="keyword">func</span>)<span class="params">(id, SEL, id)</span></span> = (void *)imp;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">self</span>, sel, @<span class="string">"text"</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>正常：<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">SEL sel = <span class="symbol">@selector</span>(showText:)<span class="comment">;</span></span><br><span class="line">IMP imp = [self.target methodForSelector:sel]<span class="comment">;</span></span><br><span class="line">id (*<span class="function"><span class="keyword">func</span>)<span class="params">(id, SEL, id)</span> = <span class="params">(void *)</span><span class="title">imp</span>;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="function"><span class="keyword">func</span>) <span class="title">func</span><span class="params">(self, sel, @<span class="string">"text"</span>)</span>;</span></span><br></pre></td></tr></table></figure></p><p>当直接使用函数指针调用方法时，倘若获取的imp为nil而直接调用也会产生异常。比如当<code>self.target</code>返回nil时，就会造成imp也为nil。这时候做一个判空再好不过了。</p><h2 id="6-其他类型的crash"><a href="#6-其他类型的crash" class="headerlink" title="6. 其他类型的crash"></a>6. 其他类型的crash</h2><p>还有几个我见过的crash，一并分享一下，以后慢慢补充：</p><p><strong>遍历数组的同时移除数组元素</strong><br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">NSMutableArray *array = [NSMutableArray arrayWithArray:<span class="symbol">@[</span><span class="symbol">@1</span>, <span class="symbol">@2</span>, <span class="symbol">@3</span>, <span class="symbol">@4</span>, <span class="symbol">@5]]</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">for</span> (NSNumber *num <span class="keyword">in</span> array) &#123;</span><br><span class="line">   <span class="keyword">if</span> ([num isEqualToNumber:<span class="symbol">@1]</span>) &#123;</span><br><span class="line">       [array removeObject:num]<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用逆序遍历可以解决：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">for</span> (NSNumber *num in array.reverseObjectEnumerator) &#123;</span><br><span class="line">   <span class="selector-tag">if</span> ([num <span class="attribute">isEqualToNumber</span>:<span class="variable">@1</span>]) &#123;</span><br><span class="line">       <span class="selector-attr">[array removeObject:num]</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为啥使用逆序遍历就能解决问题呢？因为正序遍历时，移除元素会造成没有遍历的元素的索引发生异常，而逆序遍历时，索引改变的是遍历过的元素，而没有遍历到的元素索引却没有改变，自然索引也不会越界了。</p><p>还有一点，这个reverseObjectEnumerator目前还是好使的，往后好不好使不好说的：</p><blockquote><p>In Objective-C, it is not safe to modify a mutable collection while enumerating through it. Some enumerators may currently allow enumeration of a collection that is modified, but this behavior is not guaranteed to be supported in the future.</p></blockquote><p><strong>非法数值</strong><br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">CGFloat <span class="built_in">width</span> = <span class="number">100.0</span>;</span><br><span class="line">CGFloat <span class="built_in">height</span> = <span class="number">0.0</span>;</span><br><span class="line">CGFloat <span class="built_in">scale</span> = <span class="built_in">width</span> / <span class="built_in">height</span>;</span><br><span class="line">UIView *<span class="built_in">view</span> = [[UIView alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">width</span>, <span class="built_in">height</span> * <span class="built_in">scale</span>)];</span><br></pre></td></tr></table></figure></p><p>一个非法的数值在传来传去传到UIView的frame上的时候，就该出问题了：<code>&#39;CALayer bounds contains NaN: [0 0; 100 nan].</code>。判断数值的合法性可以使用isnan()函数和isinf()函数。遇到除法的时候，一定要做个判断。</p><h1 id="二、小结"><a href="#二、小结" class="headerlink" title="二、小结"></a>二、小结</h1><p>这篇文章写得很是随意，简单描述了自己的想法却没有给出完整的解决方案。Crash防护在一定程度上是有意义的，能增强用户体验，但是还有几个问题需要考虑的：</p><ol><li>Crash防护原理大多是hook系统方法，那是否会对App产生性能或者速度方面的影响，尤其是亿万级别的App？比如是做速度优化的核心方法？</li><li>发生Crash一定是App出现异常情况了，系统把它杀死也是一种保护机制。倘若执意让App继续运行，会不会造成数据异常、界面异常？</li></ol><p>Crash防护只能算作一个兜底策略，目前来说，很多问题可以通过热修复解决，更有针对性。当然，最核心最重要的是小伙伴们都有良好的编程习惯，仔细review。</p>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 避免App crash。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.chenyalun.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C设计指北</title>
    <link href="http://blog.chenyalun.com/2019/08/22/Objective-C%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8C%97/"/>
    <id>http://blog.chenyalun.com/2019/08/22/Objective-C设计指北/</id>
    <published>2019-08-22T11:32:37.000Z</published>
    <updated>2019-10-28T09:09:11.329Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 尝试回答“给你 C 语言，如何实现一个 Objective-C”。 </p><a id="more"></a><p>孙源大神在他的文章中留下了这样一道问题：<a href="https://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-0/" target="_blank" rel="noopener">假如非要让我考一道 Runtime 的题，可能是“给你 C 语言，如何实现一个 Objective-C？</a>”，答到哪儿算哪儿。</p><p>这篇文章尝试做一点解答，也整体复习一下Objective-C。</p><h1 id="一、类与对象"><a href="#一、类与对象" class="headerlink" title="一、类与对象"></a>一、类与对象</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/// Represents an<span class="built_in"> instance </span>of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAI<span class="class">LABILITY;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Objective-C实例对象的本质是结构体，混沌初开的时候，其内部有且只有一个成员：Class类型的isa。isa是一个指向objc_class结构体的指针，在arm64上占用8个字节，在armv7上占用4个字节（本文都按照64位平台来说的）。一个NSObject对象只有这一个成员变量，理论上也只需要8个字节，但是通过memory read可以知道系统给它分配了16个字节。查看源码发现allocWithZone最终调用到instanceSize()函数时，为了内存对齐，限制了一个对象的最小占用内存为16个字节。同时，这也是为了呼应“操作系统的内存对齐”：给一个对象分配的字节数量为16的倍数。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">    <span class="comment">// 内存对齐之后的大小</span></span><br><span class="line">   size_t <span class="built_in">size</span> = alignedInstanceSize() + extraBytes;</span><br><span class="line">   <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">   <span class="built_in">if</span> (<span class="built_in">size</span> &lt; <span class="number">16</span>) <span class="built_in">size</span> = <span class="number">16</span>;</span><br><span class="line">   <span class="built_in">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在arm64架构之前，isa是一个普通的指针，直接指向类对象或者元类对象的内存地址。从arm64架构开始，isa被优化为一个共用体，使用位域把诸多信息存储在8个字节的方寸之间。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;  <span class="comment">// 1表示优化过的isa指针</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;  <span class="comment">// 是否有设置过关联对象</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 是否有C++的析构函数</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// 类对象或者元类对象地址</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;  <span class="comment">// 是否未完成初始化</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;  <span class="comment">// 是否有弱引用指向过</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;  <span class="comment">// 是否正在dealloc</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 引用计数是否过大使得无法存储在isa中，</span></span><br><span class="line">                                          <span class="comment">// 如果是则引用计数存储在SideTable中</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>; <span class="comment">// 里面存储的值是引用计数减去1</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候使用掩码进行按位与运算就可以计算出它的类对象或者元类对象的地址。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">NSObject *obj = [NSObject <span class="keyword">new</span>];</span><br><span class="line"><span class="comment">// (lldb) p/x (long)obj-&gt;isa</span></span><br><span class="line"><span class="comment">// (long) $3 = 0x001dffff9da71141</span></span><br><span class="line">    </span><br><span class="line">Class cls = [NSObject class];</span><br><span class="line"><span class="comment">// (lldb) p/x (long)obj.class</span></span><br><span class="line"><span class="comment">// (long) $5 = 0x00007fff9da71140</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (lldb) p/x (0x001dffff9da71141 &amp; 0x00007ffffffffff8ULL)</span></span><br><span class="line"><span class="comment">// (unsigned long long) $7 = 0x00007fff9da71140</span></span><br></pre></td></tr></table></figure></p><p>每个实例对象生而不同，自己的成员变量理所应当地存储在每一个实例对象中，而方法具有唯一性，同一个类实例化的所有的对象应当共享一份对象方法。自然，对象方法应该存储在“类”中，这个“类”，就是类对象。除了对象方法之外还有类方法，就像全局函数，类方法存储在元类对象中。</p><h2 id="成员变量与属性"><a href="#成员变量与属性" class="headerlink" title="成员变量与属性"></a>成员变量与属性</h2><p>声明一个YAPerson类，并填充一些成员变量、属性、实例方法和类方法。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAPerson</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    uint age;</span><br><span class="line">    <span class="built_in">NSString</span> *nickname;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">BOOL</span> isRich;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> isMale;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>)singWithSongName:(<span class="built_in">NSString</span> *)songName &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"I'm singing a song named %@"</span>, songName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)canWork &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>创建一个YAPerson实例，它包含了继承自NSObject的成员变量isa和自有的成员变量。它的结构是这样的：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">struct YAPerson_IMPL &#123;</span><br><span class="line">    struct NSObject_IMPL NSObject_IVARS<span class="comment">; // Class isa;</span></span><br><span class="line">    uint age<span class="comment">;</span></span><br><span class="line">    NSString *nickname<span class="comment">;</span></span><br><span class="line">    <span class="keyword">BOOL </span>isRich<span class="comment">;</span></span><br><span class="line">    <span class="keyword">BOOL </span>_isMale<span class="comment">;</span></span><br><span class="line">    NSString *_name<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>迫于结构体内存对齐、系统内存对齐以及一个对象最小16个字节的限制，YAPerson实例占用48个字节。</p><p>当创建一个实例对象时，由于消息机制，类方法“new”的调用实际上是被转换为objc_msgSend()函数调用，消息接收者是类对象。而调用实例方法也是通过objc_msgSend()函数，只不过第一个参数是具体的实例对象。这里的字符串<code>@&quot;Love&quot;</code>会被编译器优化为常量字符串，直接取地址使用了。</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">jack </span>singWithSongName:@<span class="string">"Love"</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">objc_msgSend(<span class="keyword">jack, </span>sel_registerName(<span class="string">"singWithSongName:"</span>), (NSString *)&amp;__NSConstantStringImpl__var_xxxxxx)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>当对实例对象的属性进行赋值时，点语法会被编译器转化为setter方法，最后还是调用objc_msgSend()函数：<br><code>objc_msgSend(jack, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_xxxxxxxxx);</code></p><p>当对实例对象的成员变量赋值时就比较有趣了，<code>jack-&gt;age = 23;</code>，大致是这种效果：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">#define __OFFSETOFIVAR__(<span class="name">TYPE</span>, MEMBER) ((<span class="name">long</span> long) &amp;((<span class="name">TYPE</span> *)0)-&gt;MEMBER)</span><br><span class="line">unsigned long int OBJC_IVAR_$_YAPerson$age = __OFFSETOFIVAR__(struct YAPerson, age);</span><br><span class="line">uint *ageOffset = (<span class="name">uint</span> *)((char *)jack + OBJC_IVAR_$_YAPerson$age)<span class="comment">;</span></span><br><span class="line">(<span class="name">*ageOffset</span>) = <span class="number">23</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>首先通过<code>__OFFSETOFIVAR__</code>宏，获取成员变量age在<code>YAPerson_IMPL</code>结构体中的偏移量：8个字节（isa占用8个字节），并把它存储为<strong>全局的常量</strong>，接着根据实例对象jack的地址加上成员变量age的偏移量获取age的地址，最后对age进行赋值。这些在编译的时候，就已经确定了，也即根本不需要通过<code>jack-&gt;age = 23;</code>这样的指针调用。一个成员变量的结构是这样的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;  <span class="comment">// pointer to ivar offset location</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw; <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">int</span> size; <span class="comment">// 占用字节</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> WORD_SHIFT 3UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> WORD_SHIFT 2UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (alignment_raw == ~(<span class="keyword">uint32_t</span>)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ageIvar = &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$age, <span class="string">"age"</span>, <span class="string">"I"</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>由于偏移量是全局的常量，所以使用<code>int32_t *</code>类型的offset存储这个偏移量的地址，而不是使用<code>int32_t</code>存储这个偏移量的值。name和type描述了成员变量的名称与类型，alignment的值取决于<a href="https://developer.apple.com/documentation/objectivec/1418756-class_addivar?language=objc" target="_blank" rel="noopener">成员变量类型和机器架构</a>，它的最小值为2的n次方。size是该类型变量占用字节。</p><p>编译时确定偏移量的原因<a href="http://zhengtingi.cc/2017/03/08/runtime1-ivar/" target="_blank" rel="noopener">是这样</a>：</p><blockquote><p>In the modern runtime, if you change the layout of instance variables in a class, you do not have to recompile classes that inherit from it.<br>在程序启动后，runtime加载类的时候，通过计算基类的大小，runtime动态调整了类成员变量布局。于是我们的程序无需编译，就能在新版本系统上运行。<br>变量地址 = 对象地址 + ivar.offset<br>ivar.offset = 基类地址(动态) + ivar在本类中的偏移量(编译时固定)</p></blockquote><p>动态创建一个类，添加成员变量的时候我们会用到这些信息：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">class_addIvar</span>(myClass, <span class="string">"someIvar"</span>, sizeof(int), log2(_Alignof(int)), <span class="variable">@encode</span>(int))</span><br></pre></td></tr></table></figure></p><p>这个函数只能用在动态创建类的时候。类一旦定义完毕就无法再（在分类中）添加成员变量，因为“类中成员变量的偏移量是由基类大小和本类中成员变量共同决定的，如果一个类添加了成员变量，size发生了变化，会导致子类无法工作”。</p><p>一个类的所有成员变量信息汇聚在一起就成为了成员变量列表<code>struct ivar_list_t</code>，它在内存中只需要一份：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count; <span class="comment">// 数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> <span class="title">ivar_list</span>[6];</span> <span class="comment">// 成员变量数组</span></span><br><span class="line">&#125; _OBJC_$_INSTANCE_VARIABLES_YAPerson = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">ivar_t</span>),</span><br><span class="line">    <span class="number">6</span>,</span><br><span class="line">    &#123;&#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$age, <span class="string">"age"</span>, <span class="string">"I"</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$nickname, <span class="string">"nickname"</span>, <span class="string">"@\"NSString\""</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$isRich, <span class="string">"isRich"</span>, <span class="string">"B"</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$_isMale, <span class="string">"_isMale"</span>, <span class="string">"B"</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$_name, <span class="string">"_name"</span>, <span class="string">"@\"NSString\""</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$_block, <span class="string">"_block"</span>, <span class="string">"@?"</span>, <span class="number">3</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>_OBJC_$_INSTANCE_VARIABLES_YAPerson</code>是YAPerson类的全局的成员变量列表。</p><p>对于我们来说，Objective-C中的属性指的就是成员变量与存取器方法。一般地，声明一个属性的时候，编译器会生成一个下划线打头的成员变量，比如<code>@property (nonatomic, copy) NSString *name;</code>会生成成员变量：<code>NSString *_name;</code>。</p><p>在语言层面，属性指的是属性的名称与对属性的修饰（类型、原子性、内存策略等）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>name是属性的名称，attributes包含的信息就比较多了，可以通过property_getAttributes()获取，比如YAPerson的name属性，得到的是<code>&quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;</code>，“C”表示copy，“N”表示nonatomic，具体含义<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html" target="_blank" rel="noopener">官方文档</a>说的很详细。</p><p>当然，属性列表是所有属性的集合：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> <span class="title">prop_list</span>[3];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_YAPerson = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">property_t</span>),</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    &#123;&#123;<span class="string">"name"</span>,<span class="string">"T@\"NSString\",C,N,V_name"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"isMale"</span>,<span class="string">"TB,R,N,V_isMale"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"block"</span>,<span class="string">"T@?,C,N,V_block"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>_OBJC_$_PROP_LIST_YAPerson</code>是YAPerson类的全局的属性列表。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>设计一个方法需要解决三个问题：方法名、方法实现以及方法的参数类型和返回值类型。</p><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>表征方法名的selector是SEL类型：<code>typedef struct objc_selector *SEL;</code>，也即“Defines an opaque type that represents a method selector”。关于它的解释目前主要有两种看法：<br>一、有人根据Runtime源码中的定义和官方文档认为它是指向objc_selector结构体的指针，但是objc_selector结构体的具体实现并没有开源。<br>二、有人说它就是C语言中的字符串常量<code>const char *</code>类型，理由是Runtime源码中sel_getName()的函数实现表明了<code>SEL</code>类型可以直接转换为<code>const char *</code>类型，而且“对于字符串的比较仅仅需要比较他们的地址就可以”，在各种查找中速度更快。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">sel_getName</span><span class="params">(SEL sel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) <span class="keyword">return</span> <span class="string">"&lt;null selector&gt;"</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">const</span> <span class="keyword">char</span> *)(<span class="keyword">const</span> <span class="keyword">void</span>*)sel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我觉得这两种看法可以结合一下，SEL是指向objc_selector结构体的指针，objc_selector的实现应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[];</span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    objc_selector(<span class="keyword">char</span> name[]) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1.从结果上看，可以满足直接转换为<code>const char *</code>类型：str的值就是“new”。从本质上看，指向结构体的指针就是指向结构体第一个成员（name数组）的指针。<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建结构体</span></span><br><span class="line">objc_selector selector = &#123;<span class="string">"new"</span>&#125;;</span><br><span class="line"><span class="comment">// p为指向结构体的指针</span></span><br><span class="line">objc_selector *p = &amp;selector;</span><br><span class="line"><span class="comment">// 将 p 强制转化为 const char * 类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> *<span class="built_in">str</span> = (<span class="keyword">const</span> <span class="built_in">char</span> *)p;</span><br><span class="line"><span class="comment">// 实际上str与结构体中的name是等价的</span></span><br><span class="line"><span class="built_in">bool</span> res = (<span class="built_in">str</span> == p-&gt;name);</span><br></pre></td></tr></table></figure></p><p>2.与SEL的内存表现是一致的。需要根据方法名的长度，创建相应长度的name数组。比如“new”方法，占用4个字节：<code>6e 65 77 00</code>。</p><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">objc_selector selector = &#123;"new"&#125;;</span><br><span class="line">objc_selector *p = &amp;selector;</span><br><span class="line">SEL sel = @selector(new);</span><br><span class="line">   </span><br><span class="line">(lldb) x p</span><br><span class="line">0x16f825c78: 6e<span class="number"> 65 </span>77<span class="number"> 00 </span>01<span class="number"> 00 </span>00<span class="number"> 00 </span>a0<span class="number"> 85 </span>c0<span class="number"> 00 </span>01<span class="number"> 00 </span>00<span class="number"> 00 </span> new.............</span><br><span class="line">(lldb) x sel</span><br><span class="line">0x1fc67fc8f: 6e<span class="number"> 65 </span>77<span class="number"> 00 </span>69<span class="number"> 73 </span>61<span class="number"> 00 </span>63 6f 6e<span class="number"> 66 </span>6f<span class="number"> 72 </span>6d<span class="number"> 73 </span> new.isa.conforms</span><br></pre></td></tr></table></figure><p>看源码不难得知，相同名称对应的selector在内存中只有一个，存储在NXMapTable中。也就是说通过<code>@selector()</code>语法糖、<code>sel_registerName()</code>函数、<code>NSSelectorFromString()</code>函数，都是从NXMapTable中取出selector。如果这个名称对应的selector已经注册在Runtime（存储在NXMapTable）中，直接返回，如果没有注册，才会进行创建。不同指针变量指向同一个结构体，这也解释了为啥可以使用<code>==</code>运算符比较。</p><p>最后一个问题，为什么表征方法名的selector要设计成结构体而不是直接使用<code>const char *</code>？</p><blockquote><p>When using selectors, you must use the value returned from sel_registerName or the Objective-C compiler directive @selector(). You cannot simply cast a C string to SEL.</p></blockquote><p>苹果希望我们使用诸如sel_registerName()这些转化函数，就是想让方法名与selector建立映射，同时把selector纳入管理。而不是像这样：</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SEL </span><span class="keyword">sel </span>= (<span class="keyword">SEL)"show";</span></span><br><span class="line"><span class="keyword">[view </span>performSelector:<span class="keyword">sel];</span></span><br></pre></td></tr></table></figure><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>对于一般的函数来说，函数名也是指向函数实现的指针。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于func函数，<code>func()</code>是通过函数名调用，<code>(*func)()</code>是通过指向函数的指针调用。在Objective-C中，IMP就是指向函数的指针。</p><p>标准的IMP定义是这样的：<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef id (*<span class="type">IMP</span>)(id, <span class="type">SEL</span>, ...);</span><br></pre></td></tr></table></figure></p><p>在实际使用时，需要根据具体的参数、返回值重新定义：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> *(*_IMP)(<span class="keyword">id</span> ,SEL, ...);</span><br><span class="line">SEL sel = <span class="keyword">@selector</span>(description);</span><br><span class="line"><span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">_IMP imp = (_IMP)class_getMethodImplementation(obj.class, sel);</span><br><span class="line"><span class="keyword">if</span> (imp) &#123;</span><br><span class="line">    <span class="comment">// 函数名调用</span></span><br><span class="line">    <span class="built_in">NSString</span> *desc1 = imp(obj, sel);</span><br><span class="line">    <span class="comment">// 函数指针调用</span></span><br><span class="line">    <span class="built_in">NSString</span> *desc2 = (*imp)(obj, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>为了简便地描述类型、修饰符，字符串形式的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">类型编码</a>产生了。<code>const char *type = @encode(int)</code>在编译时便返回了字符串常量“i”，用来表明这是int类型。但是有一些像<code>const</code>、<code>inout</code>等方法参数的修饰符无法通过@encode()获取。对于方法来说，<code>const char *method_getTypeEncoding(Method m)</code>函数可以直接返回方法完整的Type Encode。这里的Method是集成了方法名SEL、函数指针、类型编码的结构体指针。</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">typedef struct method_t *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line">struct method_t <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    SEL name;</span></span><br><span class="line"><span class="comment">    const char *types;</span></span><br><span class="line"><span class="comment">    IMP imp;</span></span><br><span class="line"><span class="comment">&#125;</span>;</span><br></pre></td></tr></table></figure><p>实例方法存放在类对象之中，这样，类对象的方法列表就产生了：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="keyword">struct</span> method_t method_list[<span class="number">6</span>];</span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_YAPerson = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(method_t),</span><br><span class="line">    <span class="number">6</span>,</span><br><span class="line">    &#123;&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"singWithSongName:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_YAPerson_singWithSongName_&#125;,</span><br><span class="line">    &#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"name"</span>, <span class="string">"@16@0:8"</span>, (<span class="keyword">void</span> *)_I_YAPerson_name&#125;,</span><br><span class="line">    &#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"setName:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_YAPerson_setName_&#125;,</span><br><span class="line">    &#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"isMale"</span>, <span class="string">"B16@0:8"</span>, (<span class="keyword">void</span> *)_I_YAPerson_isMale&#125;,</span><br><span class="line">    &#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"block"</span>, <span class="string">"@?16@0:8"</span>, (<span class="keyword">void</span> *)_I_YAPerson_block&#125;,</span><br><span class="line">    &#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"setBlock:"</span>, <span class="string">"v24@0:8@?16"</span>, (<span class="keyword">void</span> *)_I_YAPerson_setBlock_&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>类方法保存在元类对象之中，对于YAPerson，只有一个类方法<code>canWork</code>，其方法列表是这样：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span>  &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CLASS_METHODS_YAPerson = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">method_t</span>),</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    &#123;&#123;(struct objc_selector *)<span class="string">"canWork"</span>, <span class="string">"B16@0:8"</span>, (<span class="keyword">void</span> *)_C_YAPerson_canWork&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>成员变量列表、属性列表、实例方法列表、类方法列表都已经有了，那么一个类的结构也就出来了。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>class、meta-class、root meta-class的本质都是objc_class结构体，且都是以单例的形式表现在内存中。objc_class继承自objc_object，它的cache存储着缓存的方法列表，bits中的一些位存储着指向class_rw_t的指针。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="comment">//  baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line">    <span class="comment">// methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容</span></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// bits &amp; FAST_DATA_MASK可以获取class_rw_t</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>YAPerson类对象的结构是这样的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="comment">//  baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList; <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols; <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars; <span class="comment">// 成员变量列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout; </span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties; <span class="comment">// 属性列表</span></span><br><span class="line">&#125; _OBJC_CLASS_RO_$_YAPerson = &#123;</span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    <span class="comment">// 计算 YAPerson 中的第一个成员变量在结构体中的偏移量</span></span><br><span class="line">    __OFFSETOFIVAR__(struct YAPerson, age),</span><br><span class="line">    <span class="keyword">sizeof</span>(struct YAPerson_IMPL),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="string">"YAPerson"</span>,</span><br><span class="line">    (<span class="keyword">method_list_t</span> *)&amp;_OBJC_$_INSTANCE_METHODS_YAPerson,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">ivar_list_t</span> *)&amp;_OBJC_$_INSTANCE_VARIABLES_YAPerson,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">property_list_t</span> *)&amp;_OBJC_$_PROP_LIST_YAPerson,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>元类对象与类对象的结构是相同的，就YAPerson而言，主要存储了类方法列表，内容是这样：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span></span> _OBJC_METACLASS_RO_$_YAPerson = &#123;</span><br><span class="line">    <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">class_t</span></span>), <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">class_t</span></span>),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="string">"YAPerson"</span>,</span><br><span class="line">    (<span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span></span> *)&amp;_OBJC_$_CLASS_METHODS_YAPerson,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二、协议"><a href="#二、协议" class="headerlink" title="二、协议"></a>二、协议</h1><p>协议规定了协议遵守者需要实现的方法。如果在协议中声明一个属性，实际上相当于在协议中添加了该属性对应的存取器方法声明。对于协议遵守者，一般来说，需要合成该属性对应的成员变量：<code>@synthesize 属性名;</code>。<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@class</span> YAStudent;</span><br><span class="line"><span class="variable">@protocol</span> YAStudentProtocol &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@required</span></span><br><span class="line"><span class="comment">// 实例属性</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) BOOL isExcellent;</span><br><span class="line"><span class="comment">// 类属性</span></span><br><span class="line"><span class="variable">@property</span> (class, nonatomic, copy) NSString *protocolName;</span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">isSame</span><span class="selector-pseudo">:(YAStudent</span> *)<span class="selector-tag">person</span>;</span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line">+ (NSString *)<span class="selector-tag">description</span>;</span><br><span class="line">@<span class="selector-tag">optional</span></span><br><span class="line"><span class="comment">// 可选的实例属性</span></span><br><span class="line">@<span class="selector-tag">property</span> (readonly, copy) <span class="selector-tag">NSString</span> *<span class="selector-tag">debugDescription</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure></p><p>上面声明的协议的对应的结构是这样的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_t</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span> <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *instanceMethods; <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *classMethods; <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalInstanceMethods; <span class="comment">// 可选的实例方法列表</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalClassMethods; <span class="comment">// 可选的类方法列表</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *instanceProperties; <span class="comment">// 实例属性列表</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **_extendedMethodTypes;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName;</span><br><span class="line">    <span class="keyword">property_list_t</span> *_classProperties; <span class="comment">// 类属性列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为C++后</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">protocol_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * isa;  <span class="comment">// NULL</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_name; <span class="comment">// 协议名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> * <span class="title">protocol_list</span>;</span> <span class="comment">// super protocols</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span> <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span> <span class="comment">//类方法列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">optionalInstanceMethods</span>;</span> <span class="comment">// 可选的实例方法列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">optionalClassMethods</span>;</span> <span class="comment">// 可选的类方法列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> * <span class="title">properties</span>;</span> <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> size;  <span class="comment">// sizeof(struct _protocol_t)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;  <span class="comment">// = 0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> ** extendedMethodTypes; <span class="comment">// 方法type</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="string">"YAStudentProtocol"</span>,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_protocol_list_t</span> *)&amp;_OBJC_PROTOCOL_REFS_YAStudentProtocol,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">method_list_t</span> *)&amp;_OBJC_PROTOCOL_INSTANCE_METHODS_YAStudentProtocol,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">method_list_t</span> *)&amp;_OBJC_PROTOCOL_CLASS_METHODS_YAStudentProtocol,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">method_list_t</span> *)&amp;_OBJC_PROTOCOL_OPT_INSTANCE_METHODS_YAStudentProtocol,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_PROTOCOL_PROPERTIES_YAStudentProtocol,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">_protocol_t</span>),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">char</span> **)&amp;_OBJC_PROTOCOL_METHOD_TYPES_YAStudentProtocol</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，协议主要存储了方法。协议的方法列表和类对象中的方法列表结构是一样的，但是有一点，协议方法列表中的方法Method没有具体实现IMP。也容易理解，毕竟协议只能提供方法名、方法参数和返回值。那么有没有可能为协议添加方法实现呢？有。因为，协议继承自objc_object，所以协议也是一个实例对象。当获取它的superclass时，发现就是NSObject。<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">Protocol *<span class="keyword">pro</span> = objc_getProtocol(<span class="string">"YAStudentProtocol"</span>);</span><br><span class="line"></span><br><span class="line">(lldb) po [<span class="keyword">pro</span> <span class="keyword">class</span>]</span><br><span class="line">Protocol</span><br><span class="line">(lldb) po [<span class="keyword">pro</span> superclass]</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure></p><p>那么，把它当做一个普通对象即可：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Method me = class_getInstanceMethod(YAStudent.class, <span class="keyword">@selector</span>(show));</span><br><span class="line">IMP imp = method_getImplementation(me);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *type = method_getTypeEncoding(me);</span><br><span class="line"><span class="built_in">BOOL</span> success = class_addMethod(<span class="built_in">NSClassFromString</span>(<span class="string">@"Protocol"</span>), <span class="keyword">@selector</span>(show), imp, type);</span><br><span class="line"><span class="keyword">if</span> (success) &#123;</span><br><span class="line">   <span class="comment">// "创建"一个叫"YAStudentProtocol"的协议对象, 它的class是Protocol, 它的superclass是NSObject</span></span><br><span class="line">   Protocol *pro = objc_getProtocol(<span class="string">"YAStudentProtocol"</span>);</span><br><span class="line">   <span class="comment">// 调用协议对象的show方法</span></span><br><span class="line">   <span class="built_in">NSString</span> *result = [(<span class="keyword">id</span>)pro performSelector:<span class="keyword">@selector</span>(show)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然这么做意义并不是很大，但是脑洞再大一点，有没有可能只要遵守一个协议，那么就拥有了协议中的方法声明和方法实现呢？有。ProtocolKit解决了这个问题。</p><h1 id="三、类扩展与分类"><a href="#三、类扩展与分类" class="headerlink" title="三、类扩展与分类"></a>三、类扩展与分类</h1><p>类扩展和分类都可以给已有的类添加功能，不同的是类扩展是编译时合并到类中，分类是在运行时合并到类中。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 主类的名称</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls; <span class="comment">// 类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span> <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span> <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span> <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span> <span class="comment">// 实例属性列表</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span> <span class="comment">// 类属性列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每创建一个分类时，都会产生一个_category_t结构体：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_YAStudent_</span>$_<span class="title">HighSchoolStudent</span>;</span></span><br></pre></td></tr></table></figure></p><p>根据源码，分类中的属性、方法、协议等信息，合并到主类中的过程是这样的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Attach method lists and properties and protocols from categories to a class.</span></span><br><span class="line"><span class="comment">// Assumes the categories in cats are all loaded and sorted by load order, </span></span><br><span class="line"><span class="comment">// oldest categories first.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attachCategories</span><span class="params">(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证不为空</span></span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// "log methods replaced by category implementations"</span></span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是元类对象</span></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储空间分配 fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>; <span class="comment">// 方法数量</span></span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>; <span class="comment">// 属性数量</span></span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>; <span class="comment">// 协议数量</span></span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count; <span class="comment">// 分类数量</span></span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="comment">// 取出分类列表中的最后一个分类</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法列表</span></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取属性列表</span></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取协议列表</span></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    <span class="built_in">free</span>(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches &amp;&amp; mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="built_in">free</span>(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    <span class="built_in">free</span>(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，分类信息是按照分类列表的逆序逐个进行合并，分类列表的顺序是由加载顺序确定的。方法、属性、协议数组等，都是二维数组，一维对应着分类，二维对应着每条信息。</p><p>附加过程是这样的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">       <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">       <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">       <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">       <span class="comment">// 重新分配newCount的内存</span></span><br><span class="line">       setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">       <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">       <span class="comment">// 把addedLists放到老数据的前面, 形成新的array()-&gt;lists</span></span><br><span class="line">       memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">               oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">       <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">              addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">       <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">       List* oldList = <span class="built_in">list</span>;</span><br><span class="line">       <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">       setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">       <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">       <span class="comment">// 把oldList放到addedLists的后面</span></span><br><span class="line">       <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">       <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">              addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>各种情况都有考虑，但是目的只有一个：把addedLists插入到原有数据的前面。这也解释了为什么分类中的方法与主类中的方法同名时，实际上会调用分类的。表面上看是“覆盖”，实际上方法都是存在的，只不过一旦在方法列表中找到需要调用的方法，就不再往下找了。</p><h1 id="四、关联对象"><a href="#四、关联对象" class="headerlink" title="四、关联对象"></a>四、关联对象</h1><p>由于内存布局在类定义后就已经固定，所有没有办法在分类中添加成员变量，但是相似的场景还是有的，这就需要用到关联对象。</p><p>设置关联对象的逻辑是这样的：<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>set<span class="number">_</span>associative<span class="number">_</span>reference(id <span class="keyword">object</span>, <span class="keyword">void</span> *key, id <span class="keyword">value</span>, uintptr<span class="number">_</span>t policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old<span class="number">_</span>association(<span class="number">0</span>, nil);</span><br><span class="line">    <span class="comment">// 如果修饰策略是OBJC_ASSOCIATION_SETTER_RETAIN, 则new_value = [value retain]</span></span><br><span class="line">    <span class="comment">// 如果修饰策略是OBJC_ASSOCIATION_SETTER_COPY, 则new_value = [value copy]</span></span><br><span class="line">    id <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span> = <span class="keyword">value</span> ? acquireValue(<span class="keyword">value</span>, policy) : nil;</span><br><span class="line"></span><br><span class="line">    AssociationsManager manager;</span><br><span class="line">    <span class="comment">// 获取哈希表(AssociationsHashMap)的引用: associations</span></span><br><span class="line">    AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">    <span class="comment">// 获取object的"按位取反值"</span></span><br><span class="line">    unsigned long disguised<span class="number">_</span><span class="keyword">object</span> = DISGUISE(<span class="keyword">object</span>); <span class="comment">// ~(unsigned long)(object)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据object的"按位取反值"作为key, 查找对应的iterator, 如未查找到，返回end()</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised<span class="number">_</span><span class="keyword">object</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123; <span class="comment">// object已经设置过关联对象, 则需要更新key对应的对象</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123; <span class="comment">// 找到key对应的对象, 获取旧的对象, 设置新的对象</span></span><br><span class="line">                old<span class="number">_</span>association = j-&gt;second;</span><br><span class="line">                j-&gt;second = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有找到key对应的对象, 这是一个新的key</span></span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明在AssociationsHashMap中, object目前还没有对应的ObjectAssociationMap, 也即是第一次设置关联对象, 则创建ObjectAssociationMap</span></span><br><span class="line">            ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">            <span class="comment">// 存储refs</span></span><br><span class="line">            associations[disguised<span class="number">_</span><span class="keyword">object</span>] = refs;</span><br><span class="line">            <span class="comment">// 在ref中存储关联策略和new_value</span></span><br><span class="line">            (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            <span class="comment">// 标明当前类具有关联类, 它会将isa中的has_assoc标记为true</span></span><br><span class="line">            <span class="keyword">object</span>-&gt;setHasAssociatedObjects();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// value为空, 说明是要删除原先的关联引用(一般也是这么用的, 而不是使用remove)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找对应的iterator</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised<span class="number">_</span><span class="keyword">object</span>);</span><br><span class="line">        <span class="keyword">if</span> (i !=  associations.end()) &#123; <span class="comment">// 说明是有值的</span></span><br><span class="line">            <span class="comment">// 获取值(first是键, second是值): ObjectAssociationMap</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="comment">// 根据参数key, 获取在refs中对应的iterator</span></span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                <span class="comment">// 获取旧值</span></span><br><span class="line">                old<span class="number">_</span>association = j-&gt;second;</span><br><span class="line">                <span class="comment">// 把参数key对应的对象擦除</span></span><br><span class="line">                refs-&gt;erase(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果旧的关联对象不为空, 就把它release.  release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old<span class="number">_</span>association.hasValue()) ReleaseValue()(old<span class="number">_</span>association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取关联对象的逻辑是这样的：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">id _object_get_associative_reference(<span class="name">id</span> object, void *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    AssociationsManager manager;</span><br><span class="line">    // 获取AssociationsHashMap</span><br><span class="line">    AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">    disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">    AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">    if (i != associations.end()) &#123;</span><br><span class="line">        // 找到ObjectAssociationMap</span><br><span class="line">        ObjectAssociationMap *refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">        ObjectAssociationMap:<span class="symbol">:iterator</span> j = refs-&gt;find(<span class="name">key</span>)<span class="comment">;</span></span><br><span class="line">        if (<span class="name">j</span> != refs-&gt;end()) &#123;</span><br><span class="line">            // 再找到ObjcAssociation</span><br><span class="line">            ObjcAssociation <span class="symbol">&amp;entry</span> = j-&gt;second<span class="comment">;</span></span><br><span class="line">            // 取出关联对象和关联策略</span><br><span class="line">            value = entry.value()<span class="comment">;</span></span><br><span class="line">            policy = entry.policy()<span class="comment">;</span></span><br><span class="line">            // 策略是retain的话, 获取[value retain]</span><br><span class="line">            if (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((<span class="name">id</span>(<span class="name">*</span>)(<span class="name">id</span>, SEL))objc_msgSend)(<span class="name">value</span>, SEL_retain)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (<span class="name">value</span> <span class="symbol">&amp;&amp;</span> (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        // 策略是autorelease的话, 获取[value autorelease]</span><br><span class="line">        ((<span class="name">id</span>(<span class="name">*</span>)(<span class="name">id</span>, SEL))objc_msgSend)(<span class="name">value</span>, SEL_autorelease)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return value<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体来看是比较简单的，有同学画了<a href="https://www.neroxie.com/2019/07/23/从源码理解关联属性/" target="_blank" rel="noopener">一幅图</a>，很清晰地说明了存储层次：<br><img src="https://image.chenyalun.com/2019/01/28/001.png" style="zoom:80%"></p><p>关联对象的存储与类的存储没有关系。全局的AssociationsHashMap存储着所有对象与关联对象的映射关系，并由AssociationsManager管理。在AssociationsHashMap中，每个对象的“按位取反值”作为键，每个对象对应的ObjectAssociationMap作为值。在ObjectAssociationMap中，参数key作为键，关联的对象被包装成ObjcAssociation并作为值存储。</p><p>实际使用时，一般把getter方法的selector作为key，避免了新变量的产生；在移除关联对象时，常常使用objc_setAssociatedObject()函数，传入空的object，而不是使用objc_removeAssociatedObjects()函数直接把所有的关联对象都给移除。</p><p>一个对象在销毁之前，会自动移除它所有的关联对象。利用这个特性，可以实现不hook dealloc方法而在<a href="http://www.tanhao.me/pieces/160626.html/" target="_blank" rel="noopener">一个对象生命周期结束的时候触发一个操作</a>。简单地说，就是利用一个中间对象，让它保存需要执行的操作，在其dealloc时执行操作。而把这个中间对象（或者保存中间对象的数组，亦或者是block）作为分类的关联属性，也算是一种思路吧。</p><p>最后就是很有意思的weak关联属性，这个在<a href="https://blog.chenyalun.com/2019/01/20/Weak%20Associated%20Object/">《Weak Associated Object》</a>一文中专门做了思考与说明，巧妙地利用现成的weak关键字和block即可轻松实现。</p><h1 id="五、消息机制"><a href="#五、消息机制" class="headerlink" title="五、消息机制"></a>五、消息机制</h1><p>Objective-C中的实例方法调用和类方法调用都是基于消息机制的，通过发送消息而不是直接的函数调用使得这个语言非常具有动态性，这也是很有意思的。</p><p>假定YAStudent继承自YAPerson，YAPerson继承自NSObject。</p><p>以YAStudent为模板创建出一个student实例，它的实例方法大致是这么调用的：首先会先通过isa找到YAStudent的类对象，在类对象的方法列表找到目标方法，没有找到的话再通过superclass找到YAPerson的类对象，再在其方法列表中查找，没有找到的话再通过superclass找到NSObject的类对象，看是否能在其方法列表中找到并调用。</p><p>YAStudent的类方法大致是这么调用的：会先通过isa找到YAStudent的元类对象，在其方法列表中查找目标方法，如果没有找到再通过superclass找到YAPerson的元类对象，如果还没有找到就再通过superclass找到NSObject的元类对象，还是没有找到的话<strong>最后再通过isa找到NSObject类对象</strong>，看是否能在其方法列表中找到并调用。</p><p>实例对象的isa指向类对象，类对象的isa指向元类对象，元类对象的isa指向根元类，根元类的isa指向它自己。类对象的superclass指针指向父类的类对象，元类对象的superclass指针指向父类的元类对象，<strong>根元类的superclass指针指向根类（NSObject）</strong>。</p><p>由于根元类的superclass指针指向根类，这就解释了<code>[NSObject show];</code>这样明明是类方法调用却成功变成了调用NSObject的show实例方法。<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> NSObject (YAShow)</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> NSObject (YAShow)</span><br><span class="line">- (void)show &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"- (void)show"</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure></p><h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><p>编译器会将方法的调用转换为objc_msgSend、objc_msgSend_stret、objc_msgSendSuper和objc_msgSendSuper_stret。</p><blockquote><p>发送给对象的父类的消息会使用 objc_msgSendSuper;<br>有数据结构作为返回值的方法会使用 objc_msgSendSuper_stret 或 objc_msgSend_stret;<br>其它的消息都是使用 objc_msgSend 发送的。</p></blockquote><p>objc_msgSend的具体实现由汇编语言编写而成，原因有两个：</p><ol><li><p>一个C++函数不可能调用任意的函数指针，它可以重载、有可变参数，但是不可能有可变的返回值。</p></li><li><p>通过使用汇编，可以免去大量局部变量拷贝的操作，参数会直接被存放在寄存器中，当找到IMP时，参数已经保存在了寄存器中，可以直接使用，速度更快。</p></li></ol><p>第一条的解释是这样的，假定objc_msgSend是使用C++实现，那么从语法层面它需要做到能接收可变参数、返回值类型可以任意。比如返回值类型可以是<code>NSUInteger</code>也可以是<code>id</code>：</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">NSUInteger n = [<span class="keyword">array</span> count];</span><br><span class="line">id obj = [<span class="keyword">array</span> objectAtIndex:<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化后</span></span><br><span class="line">NSUInteger n = (NSUInteger <span class="comment">(*)(id, SEL))objc_msgSend(array,  @selector(count));</span></span><br><span class="line"><span class="comment">id obj = (id (*)</span>(id, SEL, NSUInteger))objc_msgSend(<span class="keyword">array</span>, @<span class="keyword">selector</span>(objectAtIndex:), <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>可变参数可以做到，任意返回值类型貌似可以利用重载，但是仅仅返回值类型不同无法构成重载：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译通不过</span></span><br><span class="line"><span class="built_in">NSUInteger</span> objc_msgSend(<span class="keyword">id</span>, SEL, ...) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span>, SEL, ...) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而且就算这两条都做到了，也没有办法支撑无穷无尽的任意函数指针—不可能把所有函数指针一一穷举。</p><blockquote><p>objc_msgSend的解决办法，主要依据的是：当objc_msgSend被调用时，所有的参数已经被设置好了。<br>换一种方式来说，就是：在objc_msgSend开始执行时，栈帧（stack frame）的状态、数据，和各个寄存器的组合形式、数据，跟调用具体的函数指针（IMP）时所需的状态、数据，是完全一致的！</p></blockquote><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">ENTRY _objc_msgSend</span><br><span class="line">UNWIND _objc_msgSend, NoFrame</span><br><span class="line">MESSENGER_START</span><br><span class="line"></span><br><span class="line">cmp<span class="keyword">x</span><span class="number">0</span>, <span class="symbol">#0</span>// 消息接收者为空，返回<span class="number">0</span></span><br><span class="line">b.leLNilOrTagged//  (MSB tagged pointer looks negative)</span><br><span class="line">ldr<span class="keyword">x</span><span class="number">13</span>, [<span class="keyword">x</span><span class="number">0</span>]// <span class="keyword">x</span><span class="number">13</span> = isa</span><br><span class="line"><span class="keyword">and</span><span class="keyword">x</span><span class="number">16</span>, <span class="keyword">x</span><span class="number">13</span>, #ISA_MASK// <span class="keyword">x</span><span class="number">16</span> = class</span><br><span class="line">LGetIsaDone:</span><br><span class="line">CacheLookup NORMAL// calls imp <span class="keyword">or</span> objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">LNilOrTagged:</span><br><span class="line">b.<span class="keyword">eq</span>LReturnZero// nil check</span><br><span class="line"></span><br><span class="line">// tagged</span><br><span class="line">mov<span class="keyword">x</span><span class="number">10</span>, <span class="symbol">#0</span>xf<span class="number">000000000000000</span></span><br><span class="line">cmp<span class="keyword">x</span><span class="number">0</span>, <span class="keyword">x</span><span class="number">10</span></span><br><span class="line">b.hsLExtTag</span><br><span class="line">adrp<span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_classes<span class="title">@PAGE</span></span><br><span class="line"><span class="keyword">add</span><span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_classes<span class="title">@PAGEOFF</span></span><br><span class="line">ubfx<span class="keyword">x</span><span class="number">11</span>, <span class="keyword">x</span><span class="number">0</span>, <span class="symbol">#60</span>, <span class="symbol">#4</span></span><br><span class="line">ldr<span class="keyword">x</span><span class="number">16</span>, [<span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">11</span>, LSL <span class="symbol">#3</span>]</span><br><span class="line">bLGetIsaDone</span><br><span class="line"></span><br><span class="line">LExtTag:</span><br><span class="line">// ext tagged</span><br><span class="line">adrp<span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_ext_classes<span class="title">@PAGE</span></span><br><span class="line"><span class="keyword">add</span><span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_ext_classes<span class="title">@PAGEOFF</span></span><br><span class="line">ubfx<span class="keyword">x</span><span class="number">11</span>, <span class="keyword">x</span><span class="number">0</span>, <span class="symbol">#52</span>, <span class="symbol">#8</span></span><br><span class="line">ldr<span class="keyword">x</span><span class="number">16</span>, [<span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">11</span>, LSL <span class="symbol">#3</span>]</span><br><span class="line">bLGetIsaDone</span><br><span class="line"></span><br><span class="line">LReturnZero:</span><br><span class="line">// <span class="keyword">x</span><span class="number">0</span> is already zero</span><br><span class="line">mov<span class="keyword">x</span><span class="number">1</span>, <span class="symbol">#0</span></span><br><span class="line">movid<span class="number">0</span>, <span class="symbol">#0</span></span><br><span class="line">movid<span class="number">1</span>, <span class="symbol">#0</span></span><br><span class="line">movid<span class="number">2</span>, <span class="symbol">#0</span></span><br><span class="line">movid<span class="number">3</span>, <span class="symbol">#0</span></span><br><span class="line">MESSENGER_END_NIL</span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>当一个方法没有相应的实现时，就会进入消息转发机制，在这套流程中，可以动态增加方法实现。</p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p><strong>在动态方法解析中可以直接添加上函数实现。</strong><br>比如调用YAPerson的instanceShow实例方法，当判断出这个selector是<code>instanceShow</code>的时候，在<code>resolveInstanceMethod</code>方法中为<code>instanceShow</code>实例方法添加上函数实现<code>instanceFunc</code>。而对于classShow类方法，在<code>resolveClassMethod</code>方法中为classShow方法添加上函数实现<code>classFunc</code>。</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">instanceFunc</span>(id self, SEL _cmd) &#123;</span><br><span class="line">   <span class="selector-tag">NSLog</span>(@<span class="string">"%@, %p"</span>, self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)<span class="selector-tag">resolveInstanceMethod</span><span class="selector-pseudo">:(SEL)sel</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (sel_isEqual(sel, <span class="variable">@selector</span>(instanceShow))) &#123;</span><br><span class="line">        <span class="comment">// 添加关于类对象的sel实现</span></span><br><span class="line">        <span class="selector-tag">class_addMethod</span>(self.class, sel, (IMP)instanceFunc, <span class="string">"@:"</span>);</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[super resolveInstanceMethod:sel]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">classFunc</span>(id self, SEL _cmd) &#123;</span><br><span class="line">   <span class="selector-tag">NSLog</span>(@<span class="string">"%@, %p"</span>, self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)<span class="selector-tag">resolveClassMethod</span><span class="selector-pseudo">:(SEL)sel</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (sel_isEqual(sel, <span class="variable">@selector</span>(classShow))) &#123;</span><br><span class="line">         <span class="comment">// 添加关于元类对象的sel实现</span></span><br><span class="line">         <span class="selector-tag">class_addMethod</span>(object_getClass(self), sel, (IMP)classFunc, <span class="string">"@:"</span>);</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[super resolveClassMethod:sel]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预先把函数实现都写好了，再通过class_addMethod()把实现添加到方法中，那何不如直接完整地把方法实现写了，比如上面的例子，直接把instanceShow实例方法和classShow类方法完整地写出来不就行了？何必多此一举。</p><p>实际上，这一阶段常是配合<code>@dynamic</code>来使用。<a href="http://www.peerassembly.com/blog/using-dynamic-properties-to-access-nsuserdefaults.html" target="_blank" rel="noopener">peerassembly</a>举了一个还不错的例子：<br>假定需要通过Preferences接管NSUserDefaults，由它提供各个key的存取接口，那一般需要这么做：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Preferences </span>: NSObject &#123;</span><br><span class="line">    <span class="selector-tag">NSUserDefaults</span> *<span class="selector-tag">_defaults</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (Preferences *)<span class="selector-tag">sharedInstance</span>;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">property</span> (nonatomic, assign) <span class="selector-tag">BOOL</span> <span class="selector-tag">autoStartBreak</span>;</span><br><span class="line"><span class="comment">// ... 还有好多属性</span></span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">implementation</span> <span class="selector-tag">Preferences</span></span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">autoStartBreak</span> &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[_defaults boolForKey:@"autoStartBreak"]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setAutoStartBreak</span><span class="selector-pseudo">:(BOOL)autoStartBreak</span> &#123;</span><br><span class="line">    <span class="selector-attr">[_defaults setBool:autoStartBreak forKey:@"autoStartBreak"]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 写好多好多</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p><p>需要对每一个属性都写上存取方法的实现，如果有20个属性，岂不是要写40个方法？</p><p>要是借助<code>resolveInstanceMethod()</code>，就可以这么办：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Preferences</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> autoStartBreak;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> iaFromSmartApp;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isDarkMode;</span><br><span class="line"><span class="comment">// ... 还有好多属性</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *_dynamicProperties;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Preferences</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> autoStartBreak, iaFromSmartApp, isDarkMode;</span><br><span class="line"><span class="built_in">BOOL</span> paprefBoolGetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    PAPropertyDescriptor *propertyDescriptor = _dynamicProperties[selectorString];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSUserDefaults</span>.standardUserDefaults boolForKey:propertyDescriptor.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> paprefBoolSetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">BOOL</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    PAPropertyDescriptor *propertyDescriptor = _dynamicProperties[selectorString];</span><br><span class="line">    [<span class="built_in">NSUserDefaults</span>.standardUserDefaults setBool:value forKey:propertyDescriptor.name];</span><br><span class="line">    [<span class="built_in">NSUserDefaults</span>.standardUserDefaults synchronize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    PAPropertyDescriptor *propertyDescriptor = [PAPropertyDescriptor new];</span><br><span class="line">    <span class="keyword">if</span> ([selectorString hasPrefix:<span class="string">@"set"</span>]) &#123; <span class="comment">// setAutoStartBreak --&gt;autoStartBreak</span></span><br><span class="line">        <span class="built_in">NSString</span> *first = [selectorString substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">3</span>, <span class="number">1</span>)];</span><br><span class="line">        <span class="built_in">NSString</span> *prop = [selectorString substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">4</span>, selectorString.length - <span class="number">5</span>)];</span><br><span class="line">        propertyDescriptor.name = [first.lowercaseString stringByAppendingString:prop];</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>.class, sel, (IMP)paprefBoolSetter, <span class="string">"v@:B"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        propertyDescriptor.name = selectorString;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>.class, sel, (IMP)paprefBoolGetter, <span class="string">"B@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_dynamicProperties[selectorString]) &#123;</span><br><span class="line">        _dynamicProperties[selectorString] = propertyDescriptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>通过建立映射，把所以存取器都统一纳入管理，更清晰高效。上面的只是一个示例，还要考虑许多问题，比如支持不同类型的属性、替换默认的方法实现等，这个作者已经写了一个完整的组件，可参考<a href="https://github.com/dhennessy/PAPreferences/blob/master/PAPreferences/PAPreferences.m" target="_blank" rel="noopener">PAPreferences</a>。</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p><strong>将消息转发给其他target。</strong><br>第一阶段中无法及时添加上相应的方法实现，就会进入第二阶段，我们可以在这里把消息转发给其他对象处理。如果是实例方法，需要实现<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>，如果是类方法，则需要实现<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>。</p><p>假定YAPerson的instanceShow实例方法没有具体的实现，而YASinger却是有的，那可以把消息转发给YASinger实例对象，交由它处理：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (id)<span class="string">forwardingTargetForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [YASinger <span class="keyword">new</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假定YADancer有classShow类方法的实现，那可以把消息转发给YADancer类对象：<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line"><span class="built_in">    return</span> YADancer.<span class="built_in">class</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上，把YAPerson的消息转发给其他对象（实例对象或者类对象）之后，其他对象就会开启新一轮的消息解析，它如果没有对应的方法实现，同样会开启这三个阶段。因此，其他对象不一定要完完整整地具备YAPerson所缺省的方法实现。</p><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p><strong>完整的消息转发。</strong><br>如若前两个阶段都没办法妥善地处理，就会进入消息解析的第三阶段。在这个阶段中，使用<code>forwardInvocation</code>配合<code>methodSignatureForSelector</code>对消息做最后一步的处理。</p><p>首先会解析methodSignatureForSelector，只有当它返回的方法签名不为空时，才会进入forwardInvocation流程中，因此我们对该方法重写并返回一个不为空的signature。<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>aSelector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([YAMethodHelper <span class="string">instancesRespondToSelector:</span>aSelector]) &#123;</span><br><span class="line">            signature = [YAMethodHelper <span class="string">instanceMethodSignatureForSelector:</span>aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着在forwardInvocation中获取创建的NSInvocation对象，调用selector即可：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">if</span> ([YAMethodHelper <span class="string">instancesRespondToSelector:</span>anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation <span class="string">invokeWithTarget:</span>_helper];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是很传统的处理步骤，实际上只要保证methodSignatureForSelector返回一个不为空的方法签名，可以在forwardInvocation中对NSInvocation对象做肆意更改。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">      <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">           signature = [<span class="built_in">NSObject</span> instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(<span class="keyword">class</span>)];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="comment">// 调用NSObject对象的description方法</span></span><br><span class="line">    anInvocation.selector = <span class="keyword">@selector</span>(description);</span><br><span class="line">    [anInvocation invokeWithTarget:[<span class="built_in">NSObject</span> new]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，前提是这么做有意义。</p><p>其实在这一阶段还可以实现<a href="http://kittenyang.com/forwardinvocation/" target="_blank" rel="noopener">伪多继承</a>：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *first = [(<span class="built_in">NSObject</span> *)<span class="keyword">self</span>.firstDelegate methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *second = [(<span class="built_in">NSObject</span> *)<span class="keyword">self</span>.secondDelegate methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (first)&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(second) &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    SEL aSelector = [anInvocation selector];</span><br><span class="line">    <span class="keyword">if</span>([<span class="keyword">self</span>.firstDelegate respondsToSelector:aSelector])&#123;</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.firstDelegate];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>([<span class="keyword">self</span>.secondDelegate respondsToSelector:aSelector])&#123;</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.secondDelegate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span>([<span class="keyword">self</span>.firstDelegate respondsToSelector:aSelector] || [<span class="keyword">self</span>.secondDelegate respondsToSelector:aSelector])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p></blockquote><h2 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h2><p>为了加快方法查找速度，方法缓存产生了。调用过的方法会被缓存起来，如果方法是属于父类的，也会把方法缓存在自己的cache中。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets; <span class="comment">// 散列表，指向bucket_t结构体数组的指针</span></span><br><span class="line">    mask_t _mask; <span class="comment">// 散列表长度减1</span></span><br><span class="line">    mask_t _occupied; <span class="comment">// 已经缓存的方法数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *buckets();</span><br><span class="line">    <span class="function">mask_t <span class="title">mask</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">mask_t <span class="title">occupied</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incrementOccupied</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBucketsAndMask</span>(<span class="params"><span class="keyword">struct</span> bucket_t *newBuckets, mask_t newMask</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeToEmpty</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">mask_t <span class="title">capacity</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConstantEmptyCache</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeFreed</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">bytesForCapacity</span>(<span class="params">uint32_t cap</span>)</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">struct</span> bucket_t * endMarker(<span class="keyword">struct</span> bucket_t *b, uint32_t cap);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span>(<span class="params">mask_t oldCapacity, mask_t newCapacity</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t * find(cache_key_t key, id receiver);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bad_cache</span>(<span class="params">id receiver, SEL sel, Class isa</span>) __<span class="title">attribute__</span>(<span class="params">(noreturn</span>))</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> cache_key_t <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> IMP <span class="title">imp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (IMP)_imp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(<span class="keyword">cache_key_t</span> newKey)</span> </span>&#123; _key = newKey; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setImp</span><span class="params">(IMP newImp)</span> </span>&#123; _imp = newImp; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">cache_key_t</span> newKey, IMP newImp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法查找过程：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Selector转换为cache_key_t（unsigned long类型）</span></span><br><span class="line"><span class="keyword">cache_key_t</span> getKey(SEL sel) &#123;</span><br><span class="line">    assert(sel);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">cache_key_t</span>)sel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bucket_t</span> *<span class="keyword">cache_t</span>::find(<span class="keyword">cache_key_t</span> k, id receiver) &#123;</span><br><span class="line">    assert(k != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *b = _buckets;</span><br><span class="line">    <span class="keyword">mask_t</span> m = _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> begin = (<span class="keyword">mask_t</span>)(k &amp; m);</span><br><span class="line">    <span class="keyword">mask_t</span> i = begin;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i].key() == <span class="number">0</span>  ||  b[i].key() == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i = ((i+<span class="number">1</span>) &amp; m)) != begin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hack</span></span><br><span class="line">    Class cls = (Class)((<span class="keyword">uintptr_t</span>)<span class="keyword">this</span> - offsetof(objc_class, cache));</span><br><span class="line">    <span class="keyword">cache_t</span>::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>散列表的索引通过<code>index = selector &amp; _mask</code>获得。</p><h1 id="六、block"><a href="#六、block" class="headerlink" title="六、block"></a>六、block</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>block的本质是<code>__main_block_impl_0</code>结构体，它拥有isa指针，是一个封装了函数调用以及函数调用环境的Objective-C对象。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数实现以及isa</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些描述信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">size_t</span> reserved; </span><br><span class="line">    <span class="comment">// block大小</span></span><br><span class="line">    <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>定义一个block时，会调用<code>__main_block_impl_0</code>的构造函数，主要是把需要执行的函数地址赋值给FuncPtr指针。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数调用的第一个参数是指向block自己的指针，之后的才是自定义的参数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, <span class="keyword">int</span> age, <span class="keyword">double</span> <span class="built_in">height</span>) &#123;</span><br><span class="line">    <span class="comment">// block做的事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用block也即执行FuncPtr函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个int型参数、一个double型参数</span></span><br><span class="line"><span class="keyword">void</span> (*myBlock)(<span class="keyword">int</span>, <span class="keyword">double</span>) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">myBlock-&gt;FuncPtr(myBlock, <span class="number">22</span>, <span class="number">175.3</span>);</span><br></pre></td></tr></table></figure><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>从代码段（text区）、数据段（data区）、堆区再到栈区，内存地址逐渐增高。block有三种类型，分别分布在数据段、栈区和堆区。</p><p>没有访问auto变量的block是Global类型，继承关系链为：<code>__NSGlobalBlock__</code>，<code>__NSGlobalBlock</code>，<code>NSBlock</code>，<code>NSObject</code>。比如：<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^(<span class="built_in">void</span>) &#123; &#125;;</span><br></pre></td></tr></table></figure></p><p>访问了auto变量的block是Stack类型，继承关系链为：<code>__NSStackBlock__</code>，<code>__NSStackBlock</code>，<code>NSBlock</code>，<code>NSObject</code>。比如：<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^(<span class="built_in">void</span>) &#123;</span><br><span class="line">   <span class="type">NSLog</span>(@<span class="string">"名字是:%d"</span>, age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当<code>__main_block_impl_0</code>的构造函数调用完毕，栈上的该结构体变量销毁，那取出该结构体的指针，再访问数据就不会是正确的数据了。这时候为了保证访问数据的正确性，需要把block放到堆空间，手动管理该结构体变量的生命周期。</p><p>Global类型的block调用copy方法后，它依然是Global类型。Stack类型的block调用copy方法后，就成为Malloc类型，继承关系链为：<code>__NSMallocBlock__</code>，<code>__NSMallocBlock</code>，<code>NSBlock</code>，<code>NSObject</code>。比如：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = [^(<span class="keyword">void</span>) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"名字是:%d"</span>, age);</span><br><span class="line">&#125; <span class="keyword">copy</span>];</span><br></pre></td></tr></table></figure></p><p>而Malloc类型的block调用copy方法后，引用计数增加1。</p><p>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况，block作为函数返回值时、将block赋值给<code>__strong</code>指针时、block作为Cocoa API中方法名含有usingBlock的方法参数时、block作为GCD API的方法参数时。</p><h2 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h2><p>一般来说，当block捕获外界的auto变量时，该变量会作为block对象的一个成员变量存储，是值传递；<br>当block捕获外界的static变量（非全局变量）时，block对象会增加一个存储该static变量的指针的成员变量，是指针传递；<br>对于全局变量（无论是否static修饰），block会直接访问，不进行捕获。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="built_in">NSString</span> *globalName = <span class="string">@"globalName"</span>;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *staticName = <span class="string">@"staticName"</span>;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">NSString</span> *autoName = <span class="string">@"autoName"</span>;</span><br><span class="line">    <span class="keyword">void</span> (^myBlock)(<span class="keyword">int</span>, <span class="keyword">double</span>) = ^(<span class="keyword">int</span> age, <span class="keyword">double</span> height) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"globalName: %@, staticName: %@, autoName: %@,"</span>, globalName, staticName, autoName);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"年龄是:%d, 身高是:%f"</span>, age, height);</span><br><span class="line">    &#125;;</span><br><span class="line">    myBlock(<span class="number">22</span>, <span class="number">175.3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 结构如下</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">    <span class="built_in">NSString</span> **staticName;</span><br><span class="line">    <span class="built_in">NSString</span> *autoName;</span><br><span class="line">    <span class="comment">// 初始化列表中对autoName和staticName赋值</span></span><br><span class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="built_in">NSString</span> **_staticName, <span class="built_in">NSString</span> *_autoName, <span class="keyword">int</span> flags=<span class="number">0</span>) : staticName(_staticName), autoName(_autoName) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>特殊地，self作为隐式参数，是<strong>局部变量</strong>，所以block访问时会进行捕获。而对于直接访问某个对象的成员变量，比如：<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^(<span class="built_in">void</span>) &#123; <span class="type">NSLog</span>(@<span class="string">"名字是:%@"</span>, _name); &#125;;</span><br></pre></td></tr></table></figure></p><p>实际上是首先访问self，接着访问self的成员变量<code>_name</code>，因此，也会对self进行捕获。</p><p>尤其需要说明的是，对于一般的auto变量来说，捕获基本数据类型的自动变量的方式是const copy。而当block内部访问了对象类型的auto变量时，如果block是在栈上，将不会对auto变量产生强引用。如果block被拷贝到堆上，会调用block内部的copy函数，copy函数内部会调用<code>_Block_object_assign</code>函数，<code>_Block_object_assign</code>函数会根据auto变量的修饰符<code>（__strong、__weak、__unsafe_unretained）</code>做出相应的操作，形成强引用（retain）或者弱引用。如果block从堆上移除，会调用block内部的dispose函数，dispose函数内部会调用<code>_Block_object_dispose</code>函数，<code>_Block_object_dispose</code>函数会自动释放引用的auto变量（release）。</p><h2 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h2><p>对于<code>__block</code>修饰的auto变量（含基本数据类型和对象类型），block捕获时会将该变量包装成新的对象：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">__block <span class="keyword">int</span> age = <span class="number">22</span>;</span><br><span class="line">__block <span class="built_in">NSObject</span> *strongObj = obj;</span><br><span class="line">__block __<span class="keyword">weak</span> <span class="built_in">NSObject</span> *weakObj = obj;</span><br><span class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">   age = <span class="number">23</span>;</span><br><span class="line">   strongObj = <span class="literal">nil</span>;</span><br><span class="line">   weakObj = <span class="literal">nil</span>;</span><br><span class="line">&#125;;</span><br><span class="line">myBlock();</span><br><span class="line"><span class="comment">// 再次访问</span></span><br><span class="line">strongObj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">age = <span class="number">24</span>;</span><br></pre></td></tr></table></figure></p><p>实际上是这样：</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把age包装成新的对象</span></span><br><span class="line">struct <span class="variable">__Block_byref_age_0</span> &#123;</span><br><span class="line">    void *<span class="variable">__isa</span>;</span><br><span class="line">    <span class="variable">__Block_byref_age_0</span> *<span class="variable">__forwarding</span>;</span><br><span class="line">    int <span class="variable">__flags</span>;</span><br><span class="line">    int <span class="variable">__size</span>;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把strong修饰的strongObj包装成新的对象</span></span><br><span class="line">struct <span class="variable">__Block_byref_strongObj_1</span> &#123;</span><br><span class="line">    void *<span class="variable">__isa</span>;</span><br><span class="line">    <span class="variable">__Block_byref_strongObj_1</span> *<span class="variable">__forwarding</span>;</span><br><span class="line">    int <span class="variable">__flags</span>;</span><br><span class="line">    int <span class="variable">__size</span>;</span><br><span class="line">    void (*<span class="variable">__Block_byref_id_object_copy</span>)(void*, void*);</span><br><span class="line">    void (*<span class="variable">__Block_byref_id_object_dispose</span>)(void*);</span><br><span class="line">    NSObject *<span class="variable">__strong</span> strongObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把weak修饰的weakObj包装成新的对象</span></span><br><span class="line">struct <span class="variable">__Block_byref_weakObj_2</span> &#123;</span><br><span class="line">    void *<span class="variable">__isa</span>;</span><br><span class="line">    <span class="variable">__Block_byref_weakObj_2</span> *<span class="variable">__forwarding</span>;</span><br><span class="line">    int <span class="variable">__flags</span>;</span><br><span class="line">    int <span class="variable">__size</span>;</span><br><span class="line">    void (*<span class="variable">__Block_byref_id_object_copy</span>)(void*, void*);</span><br><span class="line">    void (*<span class="variable">__Block_byref_id_object_dispose</span>)(void*);</span><br><span class="line">    NSObject *<span class="variable">__weak</span> weakObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block的结构</span></span><br><span class="line">struct <span class="variable">__main_block_impl_0</span> &#123;</span><br><span class="line">    struct <span class="variable">__block_impl</span> impl;</span><br><span class="line">    struct <span class="variable">__main_block_desc_0</span>* Desc;</span><br><span class="line">    <span class="variable">__Block_byref_age_0</span> *age; <span class="comment">// by ref</span></span><br><span class="line">    <span class="variable">__Block_byref_strongObj_1</span> *strongObj; <span class="comment">// by ref</span></span><br><span class="line">    <span class="variable">__Block_byref_weakObj_2</span> *weakObj; <span class="comment">// by ref</span></span><br><span class="line">    <span class="variable">__main_block_impl_0</span>(void *fp, </span><br><span class="line">        struct <span class="variable">__main_block_desc_0</span> *desc, </span><br><span class="line">        <span class="variable">__Block_byref_age_0</span> *<span class="variable">_age</span>, </span><br><span class="line">        <span class="variable">__Block_byref_strongObj_1</span> *<span class="variable">_strongObj</span>, </span><br><span class="line">        <span class="variable">__Block_byref_weakObj_2</span> *<span class="variable">_weakObj</span>, int flags=<span class="number">0</span>) </span><br><span class="line">        : age(<span class="variable">_age</span>-&gt;<span class="variable">__forwarding</span>), strongObj(<span class="variable">_strongObj</span>-&gt;<span class="variable">__forwarding</span>), weakObj(<span class="variable">_weakObj</span>-&gt;<span class="variable">__forwarding</span>) &#123; <span class="comment">// 初始化列表</span></span><br><span class="line">        impl.isa = &amp;<span class="variable">_NSConcreteStackBlock</span>;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而从这一刻开始，再访问该auto变量（age、strongObj、weakObj），实质上是访问包装成新的对象内部的同名变量（原先的变量已经不存在了）。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">__block <span class="keyword">int</span> age = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">   age = <span class="number">23</span>;</span><br><span class="line">&#125;;</span><br><span class="line">myBlock();</span><br><span class="line">age = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行类型转换</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 *block_imp = (__bridge <span class="keyword">struct</span> __main_block_impl_0 *)(myBlock);</span><br><span class="line"><span class="keyword">struct</span> __Block_byref_age_0 *age_imp = block_imp-&gt;age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">(lldb) p/x &amp;age</span><br><span class="line">(<span class="keyword">int</span> *) $<span class="number">3</span> = <span class="number">0x00000001006207d8</span></span><br><span class="line">(lldb) p/x &amp;(age_imp-&gt;age)</span><br><span class="line">(<span class="keyword">int</span> *) $<span class="number">2</span> = <span class="number">0x00000001006207d8</span></span><br></pre></td></tr></table></figure><p>利用类型转换，打印变量age的地址与结构体age_imp中的age成员的地址，发现是一致的，也印证了这一点：<code>__block</code>修饰的age就是“不可见”的新结构体内部的age。</p><p>这个“被包装的新的对象”的内存管理也需要考虑，当block在栈上时，并不会对这个“新的对象”产生强引用。当block被copy到堆时，会对“新的对象”产生强引用。对于基本数据类型的包装并不需要赘述，而对于对象类型的包装倒值得一提。“新的对象”内部的strongObj以及weakObj的修饰策略很清晰地表明了它对原来对象内存管理的立场：原来是strong，包装后依然是strong；原来是weak，包装后依然是weak。</p><p>对于<code>__block</code>修饰的变量进行装箱也很容易理解，倘若考虑把被修改的auto变量的指针传递给block，这样似乎也能达到修改变量的效果，但是不应该忘记，被修改的auto变量的生命周期是不确定的，假如这个变量很快就销毁，过了很久block才得到执行，这时再去通过指针是无法访问到这个变量的，这种访问方式也很危险。而包装成一个新的对象后，这个对象的生命周期就随着block了，block无论在栈上还是在堆上，都没有关系。</p><h2 id="属性修饰"><a href="#属性修饰" class="headerlink" title="属性修饰"></a>属性修饰</h2><p>一般来说，只有当栈上的block作为方法的参数时，需要我们手动调用block的copy方法，将栈上的block复制到堆上，以避免坏内存问题。在ARC时代，如果block作为属性，无论是copy修饰还是strong修饰都是可以的。对于getter方法，由于block是作为方法的返回值，则它会自动被copy到堆空间，不需要我们关心。对于setter方法，block是作为方法的参数，如果是copy修饰，栈上的block自然会被调用copy方法而被复制到堆空间。如果是strong修饰，那么当把栈上的block赋值给 <code>__strong id</code>类型的对象，也是会被调用copy方法复制到堆空间的。<br>即便如此，还是推荐使用copy修饰，这样能时刻提醒我们这个block将来会被安全地copy到堆空间上。但是，如果是使用<code>weak</code>、<code>assign</code>、<code>unsafe_unretained</code>这些另类的修饰符修饰block，那很轻而易举地就会出问题了。</p><h1 id="七、小结"><a href="#七、小结" class="headerlink" title="七、小结"></a>七、小结</h1><p>halfrost同学概括了与Runtime有关的应用大概是这些，也是比较全面了。</p><ol><li>实现多继承（消息转发）</li><li>Method Swizzling</li><li>Aspect Oriented Programming（比如打点）</li><li>Isa Swizzling（KVO的动态派生）</li><li>Associated Object关联对象</li><li>动态地增加方法</li><li>NSCoding的自动归档和自动解档</li><li>字典和模型互相转换（KVC也可，利用IMP也行）</li></ol><p>这篇文章主要总结了Objective-C“对象”相关的基础知识，最后还提了一下这门语言特有的block。不知道有没有把开头的那道问题回答好（捂脸），写了好久，会经常回顾并完善。</p><blockquote><p>参考感谢：<br><a href="http://southpeak.github.io/2014/11/03/objective-c-runtime-3/" target="_blank" rel="noopener">《方法与消息》</a><br><a href="https://lpd-ios.github.io/2017/12/19/ObjC-Message/" target="_blank" rel="noopener">《用代码理解 ObjC 中的发送消息和消息转发》</a><br><a href="https://halfrost.com/how_to_use_runtime/" target="_blank" rel="noopener">《如何正确使用 Runtime》</a><br><a href="https://zhongwuzw.github.io/2018/04/21/iOS知识小集之为什么objc-msgSend-是用汇编实现的/" target="_blank" rel="noopener">《为什么objc_msgSend()是用汇编实现的》</a><br><a href="https://amywushu.github.io/2016/11/09/逆向知识-通过汇编解读-objc_msgSend.html" target="_blank" rel="noopener">《通过汇编解读-objc_msgSend》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 尝试回答“给你 C 语言，如何实现一个 Objective-C”。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://blog.chenyalun.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>开源项目：YAPageView</title>
    <link href="http://blog.chenyalun.com/2019/08/07/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9AYAPageView/"/>
    <id>http://blog.chenyalun.com/2019/08/07/开源项目：YAPageView/</id>
    <published>2019-08-07T01:45:09.000Z</published>
    <updated>2019-12-16T02:48:23.812Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 轻量级、新样式轮播视图。 </p><br><a id="more"></a><p></p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在拜读<a href="http://adad184.com/" target="_blank" rel="noopener">里脊串的开发随笔</a>大神的博客时，发现个好玩的东西：<a href="http://adad184.com/2015/07/01/opensource-xxpagingscrollview/" target="_blank" rel="noopener">《开源项目:XXPagingScrollView》</a>。虽然是很常见的轮播视图，但是这种新样式的实现思路挺有意思。记得两年前在写某个项目时也遇到过这个，但是当然确实没有想出来咋实现这种非全屏有间隙的轮播控件。</p><p>读完大神的文章，很是兴奋，一般是不爱造重复的轮子，但是作者这个是<a href="https://github.com/adad184/XXPagingScrollView/blob/master/Classes/XXPagingScrollView.swift" target="_blank" rel="noopener">Swift版本</a>的，而且是基础组件，少了很多功能，所以心血来潮，在大神基础上再进一步。</p><p>相比较来说更加完善了：</p><ul><li>支持设置pagingWidth</li><li>支持设置pageInset</li><li>支持无限循环轮播</li><li>支持本地图片</li><li>支持网络图片</li><li>支持自动轮播、设置轮播时间间隔</li><li>支持点击回调</li></ul><p>整体代码约150行左右，更加精简。<br><img src="https://image.chenyalun.com/2019/08/07/003.gif"><br>项目地址:<a href="https://github.com/ChenYalun/YAPageView" target="_blank" rel="noopener">https://github.com/ChenYalun/YAPageView</a></p><h1 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h1><p>实际上轮播视图是烂大街的东西了，网上现成代码特别多。一般而言，假定需要n个页面，实现方式有：</p><ol><li>使用<code>UIScrollView</code>，添加 n 个<code>UIImageView</code>。</li><li>使用<code>UIScrollView</code>，添加两个<code>UIImageView</code>，动态循环调整。</li><li>使用<code>UICollectionView</code>。</li></ol><p>方法1比较基础，更适合非循环；方法3比较简单，但是<code>UICollectionView</code>过于heavily。<br>方法2，很精简轻量，就是处理起来有点绕。然而，绕一次，换来永久的舒适，很值得。</p><p>如何实现自定义<code>Page width</code>的视图，作者给出的方案是：</p><blockquote><p>方案1: 不使用<code>pagingEnabled</code>属性 而是手动的计算并设置滑动偏移<br>方案2: 使用<code>pagingEnabled</code>属性 扩大<code>UIScrollview</code>的显示范围即可</p></blockquote><p>很明显，方案2更好。思路是，扩大<code>UIScrollView</code>的可显示范围并让UIScrollView响应超出其本身范围的触摸事件。思路知道了，实现起来很简单，就是<code>clipsToBounds</code>属性和<code>pointInside</code>方法。</p><h4 id="间距处理"><a href="#间距处理" class="headerlink" title="间距处理"></a>间距处理</h4><p>核心有三条：</p><ol><li><code>UIScrollView</code>的宽度就是<code>pageWidth + pageInset</code>。</li><li>为了保持左右显示区域的对称性，<code>UIScrollView</code>的<code>x</code>是<code>(superView.width - pageWidth) * 0.5</code>。</li><li>子视图的frame是<code>CGRectMake(idx * (pageWidth + pageInset), 0, pageWidth, height)</code>，也即，子视图的宽度与<code>UIScrollView</code>的宽度保持一致。</li></ol><h4 id="无限循环处理"><a href="#无限循环处理" class="headerlink" title="无限循环处理"></a>无限循环处理</h4><ol><li>视图循环利用<br>使用三个<code>UIImageView</code>，记为左、中、右，重复利用。默认显示中间的imageView。</li><li>刷新逻辑<br>在<code>scrollViewDidScroll</code>回调中，当<code>UIScrollView</code>即将显示出下一个（可能是左、也可能是右）视图时，立即调用刷新方法。刷新的逻辑是：</li></ol><ul><li><p>重新计算left、currentIndex、right三个索引</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kLeft (_currentIndex == 0 ? kCount - 1 : _currentIndex - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kRight (_currentIndex == kCount - 1 ? 0 : _currentIndex + 1)</span></span><br></pre></td></tr></table></figure></li><li><p>对左、中、右三个<code>UIImageView</code>重新设置配图</p>  <figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">self.pageArray<span class="string">[0]</span>.image = self.imageArray<span class="string">[kLeft]</span>;</span><br><span class="line">self.pageArray<span class="string">[1]</span>.image = self.imageArray<span class="string">[_currentIndex]</span>;</span><br><span class="line">self.pageArray<span class="string">[2]</span>.image = self.imageArray<span class="string">[kRight]</span>;</span><br></pre></td></tr></table></figure></li><li><p>以非动画方式设置<code>UIScrollView</code>的偏移量</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> x = <span class="keyword">self</span>.scrollView.contentOffset.x;</span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="keyword">self</span>.pageWidth + <span class="keyword">self</span>.pageInset;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">   x = width;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   x += x &gt; width ? -width : width;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.scrollView setContentOffset:<span class="built_in">CGPointMake</span>(x, <span class="number">0</span>)];</span><br></pre></td></tr></table></figure><p>  这样便实现了无限循环。</p></li></ul><ol start="3"><li><p>刷新时机处理<br><code>scrollViewDidScroll</code>会回调很多次，本来以为使用一个标志位就可以控制只刷新一次，但是并没有实现😂 所以，退一步，用了两个标志位：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> leftLock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> rightLock;</span><br></pre></td></tr></table></figure><p>逻辑是这样的：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Turn left.</span></span><br><span class="line"><span class="keyword">if</span> (offsetX &gt; <span class="number">2</span> * (width - <span class="keyword">self</span>.pageInset)) <span class="keyword">self</span>.rightLock = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">self</span>.leftLock &amp;&amp; offsetX &lt; width - <span class="number">2</span> * <span class="keyword">self</span>.pageInset) &#123;</span><br><span class="line">    <span class="keyword">self</span>.leftLock = <span class="literal">YES</span>;</span><br><span class="line">    _currentIndex = kLeft;</span><br><span class="line">    [<span class="keyword">self</span> refresh];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Turn right.</span></span><br><span class="line"><span class="keyword">if</span> (offsetX &lt; <span class="number">2</span> * <span class="keyword">self</span>.pageInset) <span class="keyword">self</span>.leftLock = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">self</span>.rightLock &amp;&amp; offsetX &gt; width + <span class="number">2</span> * <span class="keyword">self</span>.pageInset) &#123;</span><br><span class="line">    <span class="keyword">self</span>.rightLock = <span class="literal">YES</span>;</span><br><span class="line">    _currentIndex = kRight;</span><br><span class="line">    [<span class="keyword">self</span> refresh];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 请牢记<code>UIScrollView</code>的宽度width是<code>width=pageWidth+pageInset</code>，这里以即将显示右边视图为例：<br> scrollView的初始偏移量是<code>width</code>，逐渐偏移，直到越过空白间距(pageInset)要显示下一个视图时，此时offsetX为<code>width + (pageWidth - pageInset)</code>，也即代码中的<code>2 * (width - pageInset)</code>，立即将offsetX还原为<code>2 * (width - pageInset) - (width)</code>也就是<code>pageWidth-pageInset</code>，对leftLock加锁，更新当前索引。</p></li></ol><h4 id="点击事件处理"><a href="#点击事件处理" class="headerlink" title="点击事件处理"></a>点击事件处理</h4><p>对<code>UIScrollView</code>添加点击手势，计算出当前点击位置在图片数组中的索引即可：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> pointX = [tap locationInView:tap.view].x;</span><br><span class="line"><span class="built_in">NSUInteger</span> idx = _currentIndex;</span><br><span class="line"><span class="keyword">if</span> (pointX &lt; <span class="keyword">self</span>.pageWidth + <span class="keyword">self</span>.pageInset) &#123;</span><br><span class="line">   idx = kLeft;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pointX &gt; <span class="number">2</span> * <span class="keyword">self</span>.pageWidth + <span class="keyword">self</span>.pageInset) &#123;</span><br><span class="line">   idx = kRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="自动轮播处理"><a href="#自动轮播处理" class="headerlink" title="自动轮播处理"></a>自动轮播处理</h4><p>当设置<code>timeInterval</code>属性时，说明需要自动轮播，懒加载创建定时器：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">_timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:_timeInterval repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> *timer) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.scrollView setContentOffset:<span class="built_in">CGPointMake</span>(<span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.scrollView.frame) * <span class="number">2</span>, <span class="number">0</span>) animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>并把定时器放到<code>currentRunLoop</code>中，设置<code>NSRunLoopCommonModes</code>。当然，需要在ScrollView的一些代理中处理用户手动滑动与定时器设置的滑动的冲突。</p><h4 id="定时器循环引用处理"><a href="#定时器循环引用处理" class="headerlink" title="定时器循环引用处理"></a>定时器循环引用处理</h4><p>解决方式是，当PageView从父视图上移除时，手动销毁定时器：<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">- (void)willMoveToSuperview:<span class="type"></span>(UIView *)<span class="keyword">new</span><span class="type">Superview</span> &#123;</span><br><span class="line">    [<span class="keyword">super</span> willMoveToSuperview:<span class="type">newSuperview</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Superview</span> == nil) &#123; <span class="comment">// 视图从父视图移除时, 销毁定时器</span></span><br><span class="line">        [_timer invalidate];</span><br><span class="line">        _timer = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="点击回调循环引用处理"><a href="#点击回调循环引用处理" class="headerlink" title="点击回调循环引用处理"></a>点击回调循环引用处理</h4><p>点击事件给出的接口我选择使用block，（使用弱引用的代理就不会有这个问题了，但是代理会增加调用的复杂性，设置代理、遵守协议、实现方法巴拉巴拉。。。）</p><p>然而，同许多视图的block回调一样，会有循环引用的问题，只能这样使用：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">pageView.tapHandler = ^(<span class="built_in">NSUInteger</span> idx, <span class="built_in">UIImage</span> *img, <span class="built_in">NSURL</span> *url) &#123;</span><br><span class="line">   __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) <span class="keyword">self</span> = weakSelf;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"self = %@, index = %lu, url = %@"</span>, <span class="keyword">self</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)idx, url);</span><br><span class="line">   <span class="comment">/// ....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>万一调用方忘了呢，那就内存泄漏了。</p><p>大神<a href="https://yulingtianxia.com/blog/2015/11/13/Summary-of-the-first-month-in-the-internship-of-Tencent/" target="_blank" rel="noopener">玉令天下</a>的方式是使用弱引用的变量持有外界的调用者，然后在适当时机将组件“自己”置为空。不过需要给调用者写个分类（属性）持有组件，还需要明确切断循环引用的时机，对于我的这个100来行的PageView，可能有点不太合适。</p><p>突然脑洞一开，想到一个方法，显式让使用方传进来调用者，重新定义外界的<code>self</code>，将其作为一个回调参数传递给使用方（PageView内部使用weak持有外界的<code>self</code>）。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^tapHandler)(<span class="built_in">NSUInteger</span> idx, <span class="built_in">UIImage</span> *img, <span class="built_in">NSURL</span> *url, <span class="keyword">id</span> <span class="keyword">self</span>);</span><br></pre></td></tr></table></figure><p>外界使用的时候像这样：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">pageView.tapHandler = ^(<span class="built_in">NSUInteger</span> idx, <span class="built_in">UIImage</span> *img, <span class="built_in">NSURL</span> *url, <span class="built_in">UIViewController</span> *<span class="keyword">self</span>) &#123;</span><br><span class="line">   [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>确实能解决循环引用，而且不是很费事。但是，实际使用的时候是这样的：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">pageView.tapHandler = ^(<span class="built_in">NSUInteger</span> idx, <span class="built_in">UIImage</span> *img, <span class="built_in">NSURL</span> *url, <span class="keyword">id</span> controller) &#123;</span><br><span class="line">   <span class="comment">// 需要手动把id类型改成实际的类型，如UIViewController、UIView等等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并不知道外界的<code>self</code>是啥类型，只能用<code>id</code>。我感觉也不是很巧妙。所以，还是使用苹果推荐的主流的weak-strong吧。</p><h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><h4 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h4><p>本地图片直接传入UIImage数组即可。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定构造器，设定pageWidth、pageInset等</span></span><br><span class="line">YAPageView *pageView = [[YAPageView alloc] <span class="string">initWithFrame:</span>CGRectMake(<span class="number">0</span>, <span class="number">200</span>, kScreenWidth, <span class="number">200</span>) <span class="string">controller:</span>self <span class="string">pageWidth:</span><span class="number">300</span> <span class="string">pageInset:</span><span class="number">20</span>];</span><br><span class="line">pageView.imageArray = @[</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"1"</span>],</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"2"</span>],</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"3"</span>],</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"4"</span>],</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"5"</span>],</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"6"</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h4 id="网络图片"><a href="#网络图片" class="headerlink" title="网络图片"></a>网络图片</h4><p>网络图片传入图片URL数组，并设置处理图片的block。这个block指的是给UIImageView设置图片URL的方式。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果使用SDWebImage，可以这么设置</span></span><br><span class="line">pageView.configImageHandler = ^(<span class="built_in">UIImageView</span> *imageView, <span class="built_in">NSURL</span> *url) &#123;</span><br><span class="line">   [imageView sd_setImageWithURL:url];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pageView.imageURLArray = @[</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/230/350/200"</span>],</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/231/350/200"</span>],</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/232/350/200"</span>],</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/233/350/200"</span>],</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/234/350/200"</span>],</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/235/350/200"</span>]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h4 id="设置自动轮播时间"><a href="#设置自动轮播时间" class="headerlink" title="设置自动轮播时间"></a>设置自动轮播时间</h4><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">pageView.timeInterval = <span class="number">3</span>.f<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="设置点击回调"><a href="#设置点击回调" class="headerlink" title="设置点击回调"></a>设置点击回调</h4><p>别忘了循环引用的问题。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">pageView.tapHandler = ^(<span class="built_in">NSUInteger</span> idx, <span class="built_in">UIImage</span> *img, <span class="built_in">NSURL</span> *url) &#123;</span><br><span class="line">   __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) <span class="keyword">self</span> = weakSelf;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"self = %@, index = %lu, url = %@"</span>, <span class="keyword">self</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)idx, url);</span><br><span class="line">   [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>整体而言，没有冗余逻辑，能优化的也优化了（比如索引计算对取模的优化、定时器懒加载、刷新时机次数等等），应该算是比较轻量了吧哈哈哈哈。</p><p>具体应用方面，比如腾讯视频App中的首页Tab、会员Tab都有这种custom width的轮播图。<br><img src="https://image.chenyalun.com/2019/08/07/002.gif" style="zoom:80%"></p><p>QQ音乐中的发现Tab也是这种轮播图，不过不能无限循环（不能无限循环岂不是更简单。。）。<br><img src="https://image.chenyalun.com/2019/08/07/001.gif" style="zoom:80%"></p><p>好了，把两年前的坑填上了。</p><hr><p><strong>后记</strong><br>有因必有果。<br>2019年11月，图搜进行大改版，pm有个新特性引导的需求。于是我在这个代码的基础上修修改改，很快就开发完毕了，大幅缩短了这块需求的开发时间😁。</p><p><img src="https://image.chenyalun.com/2019/08/07/010.png" style="zoom:30%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 轻量级、新样式轮播视图。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="开源项目" scheme="http://blog.chenyalun.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构的Swift实现</title>
    <link href="http://blog.chenyalun.com/2019/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84Swift%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.chenyalun.com/2019/07/31/数据结构的Swift实现/</id>
    <published>2019-07-31T03:39:23.000Z</published>
    <updated>2019-08-15T06:28:17.052Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 使用Swift实现常见的数据结构。 </p><br><a id="more"></a><p></p><h2 id="1-动态数组"><a href="#1-动态数组" class="headerlink" title="1.动态数组"></a>1.动态数组</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 元素数量(只读)</span></span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 使用nil作为占位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> elements: [<span class="type">T</span>?]</span><br><span class="line">    <span class="comment">// 默认10个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">DEFAULT_CAPACITY</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">ELEMENT_NOT_FOUND</span> = -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器, 初始化容量为capaticy的数组</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> capaticy: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> capaticy = capaticy &lt; <span class="type">DEFAULT_CAPACITY</span> ? <span class="type">DEFAULT_CAPACITY</span> : capaticy</span><br><span class="line">        elements = [<span class="type">T</span>?](repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: capaticy)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span> == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> item: T, <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt; <span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="comment">// 越界</span></span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"索引有误, 已经越界"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ensureCapacity()</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> (index...<span class="built_in">count</span>).reversed() &#123;</span><br><span class="line">            elements[idx + <span class="number">1</span>] = elements[idx]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">        elements[index] = item</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 追加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        insert(item, <span class="built_in">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取索引所在元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        checkBounds(index)</span><br><span class="line">        <span class="keyword">return</span> elements[index]!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(<span class="number">_</span> item: T, <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        checkBounds(index)</span><br><span class="line">        elements[index] = item</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ele = <span class="keyword">get</span>(index)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> index..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">            elements[idx] = elements[idx + <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        elements[<span class="built_in">count</span> - <span class="number">1</span>] = <span class="literal">nil</span></span><br><span class="line">        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">            elements[idx] = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否包含某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="number">_</span> item: T)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">// item 不可能为nil</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(item) != <span class="type">ELEMENT_NOT_FOUND</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取某个元素对应的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(<span class="number">_</span> item: T)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的item不可能为nil</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> elements[idx]! == item &#123;</span><br><span class="line">                <span class="keyword">return</span> idx</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ELEMENT_NOT_FOUND</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureCapacity</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> &gt; elements.<span class="built_in">count</span> &gt;&gt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> elements = <span class="keyword">self</span>.elements</span><br><span class="line">            <span class="comment">// 扩容1.5倍</span></span><br><span class="line">            <span class="keyword">let</span> newCapacity = elements.<span class="built_in">count</span> + elements.<span class="built_in">count</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">self</span>.elements = [<span class="type">T</span>?](repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: newCapacity)</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.elements[idx] = elements[idx]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引越界检查</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">checkBounds</span><span class="params">(<span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="comment">// 越界</span></span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"索引有误, 已经越界"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现过程中几个需要注意的点:</p><ol><li>在<code>indexOf()</code>函数中，元素使用<code>==</code>判等，需要遵守Equatable协议</li><li>数组的扩容中，使用位运算符可以避免产生浮点数</li><li>由于Swift中可选类型的存在，可以使用nil来占位。当然，在<code>set()、append()</code>等函数中，由于类型确定也省略了外界传参时对空值的判断</li></ol><h3 id="动态数组优化"><a href="#动态数组优化" class="headerlink" title="动态数组优化"></a>动态数组优化</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OPArrayList</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 元素数量(只读)</span></span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 使用nil作为占位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> elements: [<span class="type">T</span>?]</span><br><span class="line">    <span class="comment">// 首位元素索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> frontIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 默认10个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">DEFAULT_CAPACITY</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">ELEMENT_NOT_FOUND</span> = -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器, 初始化容量为capaticy的数组</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> capaticy: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> capaticy = capaticy &lt; <span class="type">DEFAULT_CAPACITY</span> ? <span class="type">DEFAULT_CAPACITY</span> : capaticy</span><br><span class="line">        elements = [<span class="type">T</span>?](repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: capaticy)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span> == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> item: T, <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt; <span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="comment">// 越界</span></span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"索引有误, 已经越界"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ensureCapacity()</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> (index..&lt;<span class="built_in">count</span>).reversed() &#123;</span><br><span class="line">            elements[actualIndex(idx + <span class="number">1</span>)] = elements[actualIndex(idx)]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">        elements[actualIndex(index)] = item</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 追加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        insert(item, <span class="built_in">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取索引所在元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        checkBounds(index)</span><br><span class="line">        <span class="keyword">return</span> elements[actualIndex(index)]!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(<span class="number">_</span> item: T, <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        checkBounds(index)</span><br><span class="line">        elements[actualIndex(index)] = item</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ele = elements[actualIndex(index)]!</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">            elements[frontIndex] = <span class="literal">nil</span></span><br><span class="line">            frontIndex += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> index..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">                elements[actualIndex(idx)] = elements[actualIndex(idx + <span class="number">1</span>)]</span><br><span class="line">            &#125;</span><br><span class="line">            elements[actualIndex(<span class="built_in">count</span> - <span class="number">1</span>)] = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">            elements[actualIndex(idx)] = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否包含某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="number">_</span> item: T)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">// item 不可能为nil</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(item) != <span class="type">ELEMENT_NOT_FOUND</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取某个元素对应的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(<span class="number">_</span> item: T)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的item不可能为nil</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> elements[actualIndex(idx)]! == item &#123;</span><br><span class="line">                <span class="keyword">return</span> idx</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ELEMENT_NOT_FOUND</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取真实索引: (frontIndex + index) % elements.count</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">actualIndex</span><span class="params">(<span class="number">_</span> idx: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (frontIndex + idx) % elements.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureCapacity</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> == elements.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> elements = <span class="keyword">self</span>.elements</span><br><span class="line">            <span class="comment">// 扩容1.5倍</span></span><br><span class="line">            <span class="keyword">let</span> newCapacity = elements.<span class="built_in">count</span> + elements.<span class="built_in">count</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">self</span>.elements = [<span class="type">T</span>?](repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: newCapacity)</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> index = (frontIndex + idx) % elements.<span class="built_in">count</span></span><br><span class="line">                <span class="keyword">self</span>.elements[idx] = elements[index]</span><br><span class="line">            &#125;</span><br><span class="line">            frontIndex = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引越界检查</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">checkBounds</span><span class="params">(<span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="comment">// 越界</span></span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"索引有误, 已经越界"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组内容打印</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">desc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">"["</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;elements.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="string">", "</span></span><br><span class="line">            <span class="keyword">if</span> idx == <span class="number">0</span> &#123;</span><br><span class="line">                a = <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> elements[idx] != <span class="literal">nil</span> &#123;</span><br><span class="line">                str += <span class="string">"<span class="subst">\(a)</span><span class="subst">\(elements[idx]!)</span>"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str += <span class="string">"<span class="subst">\(a)</span>nil"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str += <span class="string">"], frontIndex = <span class="subst">\(frontIndex)</span>, count = <span class="subst">\(<span class="built_in">count</span>)</span>"</span></span><br><span class="line">        <span class="built_in">print</span>(str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-单向链表"><a href="#2-单向链表" class="headerlink" title="2.单向链表"></a>2.单向链表</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneWayLinkedList</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 元素没有找到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">ELEMENT_NOT_FOUND</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> first: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> firstEle: <span class="type">T</span>?) &#123;</span><br><span class="line">        <span class="keyword">if</span> firstEle == <span class="literal">nil</span> &#123;</span><br><span class="line">            first = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            first = <span class="type">Node</span>(ele: firstEle!, next: <span class="literal">nil</span>)</span><br><span class="line">            <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 便利构造</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结点类</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ele: <span class="type">T</span></span><br><span class="line">        <span class="keyword">var</span> next: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">        <span class="keyword">init</span>(ele: <span class="type">T</span>, next: <span class="type">Node</span>?) &#123;</span><br><span class="line">            <span class="keyword">self</span>.ele = ele</span><br><span class="line">            <span class="keyword">self</span>.next = next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引所在元素获取</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node(index).ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在某索引处插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> item: T, <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt; <span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="comment">// 越界</span></span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"索引有误, 已经越界"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> prev = first</span><br><span class="line">            <span class="keyword">let</span> newNode = <span class="type">Node</span>(ele: item, next: prev)</span><br><span class="line">            first = newNode</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> prev = node(index - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">let</span> newNode = <span class="type">Node</span>(ele: item, next: prev.next)</span><br><span class="line">            prev.next = newNode</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 追加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        insert(item, <span class="built_in">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除某索引的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        checkBounds(index)</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">            first = first?.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> noe = node(index - <span class="number">1</span>)</span><br><span class="line">            noe.next = noe.next?.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取某元素所在索引</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(<span class="number">_</span> item: T)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = first</span><br><span class="line">        <span class="keyword">var</span> idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> node!.ele == item &#123;</span><br><span class="line">                <span class="keyword">return</span> idx</span><br><span class="line">            &#125;</span><br><span class="line">            node = node!.next</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ELEMENT_NOT_FOUND</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.first = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">desc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = first</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> idx == <span class="number">0</span> &#123;</span><br><span class="line">                str += <span class="string">"first:<span class="subst">\(node!.ele)</span>,"</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node!.next != <span class="literal">nil</span> &#123;</span><br><span class="line">                str += <span class="string">" [<span class="subst">\(node!.ele)</span>, <span class="subst">\(node!.next!.ele)</span>]"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str += <span class="string">" [<span class="subst">\(node!.ele)</span>, nil]"</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node!.next</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                str += <span class="string">","</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(str)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取索引所在的结点</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">node</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">Node</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        checkBounds(index)</span><br><span class="line">        <span class="keyword">var</span> node = <span class="keyword">self</span>.first</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;index &#123;</span><br><span class="line">            node = node?.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引越界检查</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">checkBounds</span><span class="params">(<span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="comment">// 越界</span></span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"索引有误, 已经越界"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-单向循环链表"><a href="#3-单向循环链表" class="headerlink" title="3.单向循环链表"></a>3.单向循环链表</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">class OneWayCircularLinkedList&lt;T: Equatable&gt;: OneWayLinkedList<span class="symbol">&lt;T&gt;</span> &#123;</span><br><span class="line">    override func <span class="keyword">insert</span>(_ item: T, _ <span class="built_in">index</span>: Int) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">index</span> &lt; <span class="number">0</span> || <span class="built_in">index</span> &gt; <span class="built_in">count</span> &#123;</span><br><span class="line">            // 越界</span><br><span class="line">            fatalError(<span class="string">"索引有误, 已经越界"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">prev</span> = <span class="keyword">first</span></span><br><span class="line">            <span class="keyword">let</span> newNode = Node(ele: item, nex<span class="variable">t:</span> <span class="keyword">prev</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">prev</span> == nil &#123;</span><br><span class="line">                // 只有一个元素</span><br><span class="line">                newNode.<span class="keyword">next</span> = newNode</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">first</span> = newNode</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">prev</span> = node(<span class="built_in">index</span> - <span class="number">1</span>)</span><br><span class="line">            // 处理添加到最后一个位置</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">fir</span> = (<span class="built_in">index</span> == <span class="built_in">count</span>) ? <span class="keyword">first</span> : <span class="keyword">prev</span>.<span class="keyword">next</span></span><br><span class="line">            <span class="keyword">let</span> newNode = Node(ele: item, nex<span class="variable">t:</span> <span class="keyword">fir</span>)</span><br><span class="line">            <span class="keyword">prev</span>.<span class="keyword">next</span> = newNode</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func <span class="built_in">remove</span>(_ <span class="built_in">index</span>: Int) &#123;</span><br><span class="line">        checkBounds(<span class="built_in">index</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">last</span> = node(<span class="built_in">count</span> - <span class="number">1</span>)</span><br><span class="line">            // 对最后一个元素的处理</span><br><span class="line">            <span class="keyword">first</span> = (<span class="built_in">count</span> - <span class="number">1</span> == <span class="built_in">index</span>) ? nil : <span class="keyword">first</span>?.<span class="keyword">next</span></span><br><span class="line">            <span class="keyword">last</span>.<span class="keyword">next</span> = <span class="keyword">first</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> noe = node(<span class="built_in">index</span> - <span class="number">1</span>)</span><br><span class="line">            noe.<span class="keyword">next</span> = noe.<span class="keyword">next</span>?.<span class="keyword">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func clear() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">last</span> = node(<span class="built_in">count</span> - <span class="number">1</span>)</span><br><span class="line">        // 打破循环引用</span><br><span class="line">        <span class="keyword">last</span>.<span class="keyword">next</span> = nil</span><br><span class="line">        // 调用父类</span><br><span class="line">        super.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-双向链表"><a href="#4-双向链表" class="headerlink" title="4.双向链表"></a>4.双向链表</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoWayLinkedList</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 元素没有找到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">ELEMENT_NOT_FOUND</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">fileprivate</span>(<span class="keyword">set</span>) <span class="keyword">var</span> first: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">    <span class="keyword">fileprivate</span>(<span class="keyword">set</span>) <span class="keyword">var</span> last: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">    <span class="keyword">fileprivate</span>(<span class="keyword">set</span>) <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> ele: <span class="type">T</span>?) &#123;</span><br><span class="line">        <span class="keyword">if</span> ele == <span class="literal">nil</span> &#123;</span><br><span class="line">            first = <span class="literal">nil</span></span><br><span class="line">            last = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            first = <span class="type">Node</span>(ele: ele!, prev: <span class="literal">nil</span>, next: <span class="literal">nil</span>)</span><br><span class="line">            last = first</span><br><span class="line">            <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 便利构造</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结点类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ele: <span class="type">T</span></span><br><span class="line">        <span class="keyword">var</span> prev: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">        <span class="keyword">var</span> next: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">        <span class="keyword">init</span>(ele: <span class="type">T</span>, prev: <span class="type">Node</span>?, next: <span class="type">Node</span>?) &#123;</span><br><span class="line">            <span class="keyword">self</span>.ele = ele</span><br><span class="line">            <span class="keyword">self</span>.prev = prev</span><br><span class="line">            <span class="keyword">self</span>.next = next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引所在元素获取</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        checkBounds(index)</span><br><span class="line">        <span class="keyword">return</span> node(index).ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在某索引处插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> item: T, <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt; <span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="comment">// 越界</span></span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"索引有误, 已经越界"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> prev = last</span><br><span class="line">            <span class="keyword">let</span> newNode = <span class="type">Node</span>(ele: item, prev: prev, next: <span class="literal">nil</span>)</span><br><span class="line">            last = newNode</span><br><span class="line">            prev?.next = newNode</span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">                first = last</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> next = node(index)</span><br><span class="line">            <span class="keyword">let</span> prev = next.prev</span><br><span class="line">            <span class="keyword">let</span> newNode = <span class="type">Node</span>(ele: item, prev: prev, next: next)</span><br><span class="line">            next.prev = newNode</span><br><span class="line">            prev?.next = newNode</span><br><span class="line">            <span class="keyword">if</span> newNode.prev == <span class="literal">nil</span> &#123;</span><br><span class="line">                first = newNode</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 追加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        insert(item, <span class="built_in">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除某索引的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        checkBounds(index)</span><br><span class="line">        <span class="keyword">let</span> old = node(index)</span><br><span class="line">        <span class="keyword">let</span> prev = old.prev</span><br><span class="line">        <span class="keyword">let</span> next = old.next</span><br><span class="line">        <span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line">            last = prev</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next?.prev = prev</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> prev == <span class="literal">nil</span> &#123;</span><br><span class="line">            first = next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev?.next = next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> old.ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取某元素所在索引</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(<span class="number">_</span> item: T)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = first</span><br><span class="line">        <span class="keyword">var</span> idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> node!.ele == item &#123;</span><br><span class="line">                <span class="keyword">return</span> idx</span><br><span class="line">            &#125;</span><br><span class="line">            node = node!.next</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ELEMENT_NOT_FOUND</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 打破循环引用</span></span><br><span class="line">        <span class="keyword">var</span> first = <span class="keyword">self</span>.first</span><br><span class="line">        <span class="keyword">while</span> first != <span class="literal">nil</span> &#123;</span><br><span class="line">            first?.prev = <span class="literal">nil</span></span><br><span class="line">            first = first?.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.first = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.last = <span class="literal">nil</span></span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span> == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">desc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = first</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> idx == <span class="number">0</span> &#123;</span><br><span class="line">                str += <span class="string">"first:<span class="subst">\(node!.ele)</span>,"</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node!.next != <span class="literal">nil</span> &#123;</span><br><span class="line">                str += <span class="string">" [<span class="subst">\(node!.ele)</span>, <span class="subst">\(node!.next!.ele)</span>]"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str += <span class="string">" [<span class="subst">\(node!.ele)</span>, nil]"</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                str += <span class="string">","</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> idx == <span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">                str += <span class="string">" last:<span class="subst">\(node!.ele)</span>"</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node!.next</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(str)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取索引所在的结点</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">node</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">Node</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        checkBounds(index)</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="built_in">count</span> &gt;&gt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 在前半部分查找</span></span><br><span class="line">            <span class="keyword">var</span> node = <span class="keyword">self</span>.first</span><br><span class="line">            <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;index &#123;</span><br><span class="line">                node = node?.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node!</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在后半部分查找</span></span><br><span class="line">            <span class="keyword">var</span> node = <span class="keyword">self</span>.last</span><br><span class="line">            <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> (index + <span class="number">1</span>..&lt;<span class="built_in">count</span>).reversed() &#123;</span><br><span class="line">                node = node?.prev</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引越界检查</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">checkBounds</span><span class="params">(<span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="comment">// 越界</span></span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"索引有误, 已经越界"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-双向循环链表"><a href="#5-双向循环链表" class="headerlink" title="5.双向循环链表"></a>5.双向循环链表</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">class TwoWayCircularLinkedList&lt;T: Equatable&gt;: TwoWayLinkedList<span class="symbol">&lt;T&gt;</span> &#123;</span><br><span class="line">    override func <span class="keyword">insert</span>(_ item: T, _ <span class="built_in">index</span>: Int) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">index</span> &lt; <span class="number">0</span> || <span class="built_in">index</span> &gt; <span class="built_in">count</span> &#123;</span><br><span class="line">            // 越界</span><br><span class="line">            fatalError(<span class="string">"索引有误, 已经越界"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">index</span> == <span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">prev</span> = <span class="keyword">last</span></span><br><span class="line">            <span class="keyword">let</span> newNode = Node(ele: item, <span class="keyword">pre</span><span class="variable">v:</span> <span class="keyword">prev</span>, nex<span class="variable">t:</span> <span class="keyword">first</span>)</span><br><span class="line">            <span class="keyword">last</span> = newNode</span><br><span class="line">            <span class="keyword">prev</span>?.<span class="keyword">next</span> = newNode</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">first</span> = <span class="keyword">last</span></span><br><span class="line">                <span class="keyword">last</span>?.<span class="keyword">next</span> = newNode</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">first</span>?.<span class="keyword">prev</span> = newNode</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">next</span> = node(<span class="built_in">index</span>)</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">prev</span> = <span class="keyword">next</span>.<span class="keyword">prev</span></span><br><span class="line">            <span class="keyword">let</span> newNode = Node(ele: item, <span class="keyword">pre</span><span class="variable">v:</span> <span class="keyword">prev</span>, nex<span class="variable">t:</span> <span class="keyword">next</span>)</span><br><span class="line">            <span class="keyword">next</span>.<span class="keyword">prev</span> = newNode</span><br><span class="line">            <span class="keyword">prev</span>?.<span class="keyword">next</span> = newNode</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">                // 首位插入元素</span><br><span class="line">                <span class="keyword">first</span> = newNode</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func <span class="built_in">remove</span>(_ <span class="built_in">index</span>: Int) -&gt; T &#123;</span><br><span class="line">        checkBounds(<span class="built_in">index</span>)</span><br><span class="line">        <span class="keyword">let</span> old: Node = node(<span class="built_in">index</span>)</span><br><span class="line">        var <span class="keyword">prev</span> = old.<span class="keyword">prev</span></span><br><span class="line">        var <span class="keyword">next</span> = old.<span class="keyword">next</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">1</span> &amp;&amp; <span class="built_in">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">            // 只有一个元素</span><br><span class="line">            <span class="keyword">prev</span> = nil</span><br><span class="line">            <span class="keyword">next</span> = nil</span><br><span class="line">            old.<span class="keyword">next</span> = nil</span><br><span class="line">            old.<span class="keyword">prev</span> = nil</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">first</span> = <span class="keyword">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">index</span> == <span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">last</span> = <span class="keyword">prev</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">prev</span>?.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line">        <span class="keyword">next</span>?.<span class="keyword">prev</span> = <span class="keyword">prev</span></span><br><span class="line">        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> old.ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func clear() &#123;</span><br><span class="line">        // 打破循环引用</span><br><span class="line">        var <span class="keyword">first</span> = self.<span class="keyword">first</span></span><br><span class="line">        <span class="keyword">for</span> idx in <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">first</span>?.<span class="keyword">prev</span> = nil</span><br><span class="line">            <span class="keyword">first</span> = <span class="keyword">first</span>?.<span class="keyword">next</span></span><br><span class="line">            <span class="keyword">if</span> idx == <span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">first</span>?.<span class="keyword">next</span> = nil</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        self.<span class="keyword">first</span> = nil</span><br><span class="line">        self.<span class="keyword">last</span> = nil</span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-栈"><a href="#6-栈" class="headerlink" title="6.栈"></a>6.栈</h2><p>使用动态数组实现。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 设置容量默认为10, 可自动扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> list: <span class="type">ArrayList</span>&lt;<span class="type">T</span>&gt; = <span class="type">ArrayList</span>(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        list.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.remove(size() - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">top</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span> ? <span class="literal">nil</span> : list.<span class="keyword">get</span>(size() - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        list.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-队列"><a href="#7-队列" class="headerlink" title="7.队列"></a>7.队列</h2><p>因为频繁地在开头末尾添加删除元素所以使用链表实现<br>又因为双向链表有头指针和尾指针而单向链表只有头指针所以使用双向链表实现(减少遍历)</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> list: <span class="type">TwoWayLinkedList</span>&lt;<span class="type">T</span>&gt; = <span class="type">TwoWayLinkedList</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enQueue</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        list.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deQueue</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.remove(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">front</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> list.first?.ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        list.clear()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">desc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        list.desc()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用栈实现队列"><a href="#使用栈实现队列" class="headerlink" title="使用栈实现队列"></a>使用栈实现队列</h4><p>原理:</p><ol><li>入队时, 把元素放入inStack中</li><li>出队时, 如果outStack为空, 则把inStack中的全部栈顶元素依次放到outStack中, 返回outStack的栈顶元素, 否则, 直接返回outStack的栈顶元素<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue_UseStack</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 维护两个栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> inStack: <span class="type">Stack</span>&lt;<span class="type">T</span>&gt; = <span class="type">Stack</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> outStack: <span class="type">Stack</span>&lt;<span class="type">T</span>&gt; = <span class="type">Stack</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.size() + outStack.size()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enQueue</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        inStack.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deQueue</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> outStack.isEmpty() &#123;</span><br><span class="line">            <span class="keyword">while</span> inStack.isEmpty() == <span class="literal">false</span> &#123;</span><br><span class="line">                outStack.push(inStack.pop())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">front</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> outStack.isEmpty() &#123;</span><br><span class="line">            <span class="keyword">while</span> inStack.isEmpty() == <span class="literal">false</span> &#123;</span><br><span class="line">                outStack.push(inStack.pop())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.top()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        inStack.clear()</span><br><span class="line">        outStack.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="8-循环队列"><a href="#8-循环队列" class="headerlink" title="8.循环队列"></a>8.循环队列</h2><p>使用动态数组实现, 且各接口优化到O(1)时间复杂度<br>要点:</p><ol><li>有一个指向队头元素的索引frontIndex, 必不可少</li><li>接口索引与真实索引的互换: 真实索引 = (frontIndex + index) % elements.count</li><li>入队</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 指向队头的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> frontIndex: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 使用nil作为占位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> elements: [<span class="type">T</span>?]</span><br><span class="line">    <span class="comment">// 默认10个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">DEFAULT_CAPACITY</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">ELEMENT_NOT_FOUND</span> = -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器, 初始化容量为capaticy的数组</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> capaticy: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> capaticy = capaticy &lt; <span class="type">DEFAULT_CAPACITY</span> ? <span class="type">DEFAULT_CAPACITY</span> : capaticy</span><br><span class="line">        elements = [<span class="type">T</span>?](repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: capaticy)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span> == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enQueue</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        ensureCapacity(<span class="built_in">count</span> + <span class="number">1</span>)</span><br><span class="line">        elements[index(<span class="built_in">count</span>)] = item</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deQueue</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ele = elements[frontIndex]</span><br><span class="line">        <span class="keyword">if</span> ele == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"队列为空"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        elements[frontIndex] = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 不是frontIndex += 1, 要考虑frontIndex == elements.count但是elements有空闲位置的情况</span></span><br><span class="line">        <span class="comment">// 这时应该是frontIndex = (frontIndex + 1) % elements.count, 也就是index(1)</span></span><br><span class="line">        frontIndex = index(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ele!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">front</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[frontIndex]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;elements.<span class="built_in">count</span> &#123;</span><br><span class="line">            elements[idx] = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        frontIndex = <span class="number">0</span></span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureCapacity</span><span class="params">(<span class="number">_</span> capacity: Int)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 不需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt;= capacity &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> elements = <span class="keyword">self</span>.elements</span><br><span class="line">        <span class="comment">// 扩容1.5倍</span></span><br><span class="line">        <span class="keyword">let</span> newCapacity = elements.<span class="built_in">count</span> + elements.<span class="built_in">count</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> newElements = [<span class="type">T</span>?](repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: newCapacity)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">            newElements[idx] = elements[index(idx)]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.elements = newElements</span><br><span class="line">        frontIndex = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取索引对应真实索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (frontIndex + index) % elements.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">desc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"frontIndex: <span class="subst">\(frontIndex)</span>"</span> + <span class="string">" eles: <span class="subst">\(elements)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-双端队列"><a href="#9-双端队列" class="headerlink" title="9.双端队列"></a>9.双端队列</h2><p>两端都可以入队和出队</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleEndedQueue</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> list: <span class="type">TwoWayLinkedList</span>&lt;<span class="type">T</span>&gt; = <span class="type">TwoWayLinkedList</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队头入队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enQueueFront</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        list.insert(item, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队尾入队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enQueueRear</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        list.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队头出队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deQueueFront</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.remove(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队尾出队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deQueueRear</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.remove(list.<span class="built_in">count</span> - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">front</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> list.first?.ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取队尾元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">rear</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> list.last?.ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        list.clear()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">desc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        list.desc()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-循环双端队列"><a href="#10-循环双端队列" class="headerlink" title="10.循环双端队列"></a>10.循环双端队列</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleDoubleEndedQueue</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 指向队头的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> frontIndex: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 使用nil作为占位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> elements: [<span class="type">T</span>?]</span><br><span class="line">    <span class="comment">// 默认10个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">DEFAULT_CAPACITY</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">ELEMENT_NOT_FOUND</span> = -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器, 初始化容量为capaticy的数组</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> capaticy: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> capaticy = capaticy &lt; <span class="type">DEFAULT_CAPACITY</span> ? <span class="type">DEFAULT_CAPACITY</span> : capaticy</span><br><span class="line">        elements = [<span class="type">T</span>?](repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: capaticy)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span> == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队头入队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enQueueFront</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        ensureCapacity(<span class="built_in">count</span> + <span class="number">1</span>)</span><br><span class="line">        frontIndex = index(-<span class="number">1</span>)</span><br><span class="line">        elements[frontIndex] = item</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队尾入队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enQueueRear</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        ensureCapacity(<span class="built_in">count</span> + <span class="number">1</span>)</span><br><span class="line">        elements[index(<span class="built_in">count</span>)] = item</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队头出队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deQueueFront</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"队列为空"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> ele = elements[frontIndex]</span><br><span class="line">        elements[frontIndex] = <span class="literal">nil</span></span><br><span class="line">        frontIndex = index(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ele!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队尾出队</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deQueueRear</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"队列为空"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> ele = elements[index(<span class="built_in">count</span> - <span class="number">1</span>)]!</span><br><span class="line">        elements[index(<span class="built_in">count</span> - <span class="number">1</span>)] = <span class="literal">nil</span></span><br><span class="line">        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">front</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[frontIndex]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取队尾元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">rear</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[index(<span class="built_in">count</span> - <span class="number">1</span>)]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;elements.<span class="built_in">count</span> &#123;</span><br><span class="line">            elements[idx] = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        frontIndex = <span class="number">0</span></span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureCapacity</span><span class="params">(<span class="number">_</span> capacity: Int)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 不需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt;= capacity &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> elements = <span class="keyword">self</span>.elements</span><br><span class="line">        <span class="comment">// 扩容1.5倍</span></span><br><span class="line">        <span class="keyword">let</span> newCapacity = elements.<span class="built_in">count</span> + elements.<span class="built_in">count</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> newElements = [<span class="type">T</span>?](repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: newCapacity)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">            newElements[idx] = elements[index(idx)]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.elements = newElements</span><br><span class="line">        frontIndex = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取索引对应真实索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index = index</span><br><span class="line">        index += frontIndex</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index + elements.<span class="built_in">count</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//        return index % elements.count</span></span><br><span class="line">        <span class="keyword">return</span> index - (index &gt;= elements.<span class="built_in">count</span> ? elements.<span class="built_in">count</span> : <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">desc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"frontIndex: <span class="subst">\(frontIndex)</span>"</span> + <span class="string">",eles: <span class="subst">\(elements)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-二叉树"><a href="#11-二叉树" class="headerlink" title="11. 二叉树"></a>11. 二叉树</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">T</span>: <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> nodeCount = <span class="number">0</span> <span class="comment">// 结点数量</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> root: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;? <span class="comment">// 根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二叉树是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeCount == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        root = <span class="literal">nil</span></span><br><span class="line">        nodeCount = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前序遍历(一般是根左右)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"---------以下是前序遍历的递归方式结果---------"</span>)</span><br><span class="line">        preorderTraversal(root)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"---------以下是前序遍历的非递归方式结果---------"</span>)</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> results = [<span class="type">T</span>]()</span><br><span class="line">        <span class="keyword">let</span> stack = <span class="type">Stack</span>&lt;<span class="type">Node</span>&lt;<span class="type">T</span>&gt;&gt;()</span><br><span class="line">        <span class="keyword">var</span> p = root</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">nil</span> || stack.size() != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 先访问 根</span></span><br><span class="line">                results.append(p!.ele)</span><br><span class="line">                stack.push(p!)</span><br><span class="line">                <span class="comment">// 再访问 左 (持续遍历左子树)</span></span><br><span class="line">                p = p?.<span class="keyword">left</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = stack.pop()</span><br><span class="line">            <span class="comment">// 最后访问 右</span></span><br><span class="line">            p = p?.<span class="keyword">right</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(results)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(<span class="number">_</span> node: Node&lt;T&gt;?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(node!.ele)</span><br><span class="line">        preorderTraversal(node!.<span class="keyword">left</span>)</span><br><span class="line">        preorderTraversal(node!.<span class="keyword">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历(一般是左根右)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"---------以下是中序遍历的递归方式结果---------"</span>)</span><br><span class="line">        inorderTraversal(root)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"---------以下是中序遍历的非递归方式结果---------"</span>)</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> results = [<span class="type">T</span>]()</span><br><span class="line">        <span class="keyword">let</span> stack = <span class="type">Stack</span>&lt;<span class="type">Node</span>&lt;<span class="type">T</span>&gt;&gt;()</span><br><span class="line">        <span class="keyword">var</span> p = root</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">nil</span> || stack.size() != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 持续访问左子树</span></span><br><span class="line">                stack.push(p!)</span><br><span class="line">                p = p?.<span class="keyword">left</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">            p = stack.pop()</span><br><span class="line">            <span class="comment">// 先访问左子树</span></span><br><span class="line">            results.append(p!.ele)</span><br><span class="line">            p = p?.<span class="keyword">right</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(results)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(<span class="number">_</span> node: Node&lt;T&gt;?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        inorderTraversal(node!.<span class="keyword">left</span>)</span><br><span class="line">        <span class="built_in">print</span>(node!.ele)</span><br><span class="line">        inorderTraversal(node!.<span class="keyword">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历(一般是左右根)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"---------以下是后序遍历的递归方式结果---------"</span>)</span><br><span class="line">        postorderTraversal(root)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"---------以下是后序遍历的非递归方式结果---------"</span>)</span><br><span class="line">        <span class="keyword">var</span> results = [<span class="type">T</span>]()</span><br><span class="line">        <span class="keyword">let</span> stack = <span class="type">Stack</span>&lt;<span class="type">Node</span>&lt;<span class="type">T</span>&gt;&gt;()</span><br><span class="line">        <span class="keyword">var</span> p = root</span><br><span class="line">        <span class="keyword">var</span> last: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;? = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">nil</span> || stack.size() != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 持续访问左子树</span></span><br><span class="line">                stack.push(p!)</span><br><span class="line">                p = p?.<span class="keyword">left</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = stack.top()</span><br><span class="line">            <span class="keyword">if</span> p?.<span class="keyword">right</span> == <span class="literal">nil</span> || p?.<span class="keyword">right</span> == last &#123;</span><br><span class="line">                <span class="comment">// 没有右子树或者访问过右子树</span></span><br><span class="line">                results.append(p!.ele)</span><br><span class="line">                <span class="number">_</span> = stack.pop()</span><br><span class="line">                last = p</span><br><span class="line">                p = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p?.<span class="keyword">right</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(results)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(<span class="number">_</span> node: Node&lt;T&gt;?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        postorderTraversal(node!.<span class="keyword">left</span>)</span><br><span class="line">        postorderTraversal(node!.<span class="keyword">right</span>)</span><br><span class="line">        <span class="built_in">print</span>(node!.ele)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 层序遍历--使用队列实现</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">levelOrderTranversal</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> queue = <span class="type">Queue</span>&lt;<span class="type">Node</span>&lt;<span class="type">T</span>&gt;&gt;()</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> results = [<span class="type">T</span>]()</span><br><span class="line">        queue.enQueue(root!)</span><br><span class="line">        <span class="keyword">while</span> queue.size() != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> r = queue.deQueue()</span><br><span class="line">            results.append(r.ele)</span><br><span class="line">            <span class="keyword">if</span> r.<span class="keyword">left</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.enQueue(r.<span class="keyword">left</span>!)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> r.<span class="keyword">right</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.enQueue(r.<span class="keyword">right</span>!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"---------以下是层序遍历的结果---------"</span>)</span><br><span class="line">        <span class="built_in">print</span>(results)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否是一颗完全二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isComplete</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 树为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> isAllLeaf = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> queue = <span class="type">Queue</span>&lt;<span class="type">Node</span>&lt;<span class="type">T</span>&gt;&gt;()</span><br><span class="line">        queue.enQueue(root!)</span><br><span class="line">        <span class="keyword">while</span> queue.size() != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> r = queue.deQueue()</span><br><span class="line">            <span class="keyword">if</span> isAllLeaf &amp;&amp; !r.isLeaf() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> r.<span class="keyword">left</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.enQueue(r.<span class="keyword">left</span>!)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> r.<span class="keyword">left</span> == <span class="literal">nil</span> &amp;&amp; r.<span class="keyword">right</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 左子树为空而右子树不为空, 不是完全二叉树</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> r.<span class="keyword">right</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.enQueue(r.<span class="keyword">right</span>!)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左不为空右为空  或者 左右都为空, 要求之后的必须都是叶子结点</span></span><br><span class="line">                isAllLeaf = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找前驱结点</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">precursor</span><span class="params">(<span class="number">_</span> node: Node&lt;T&gt;?)</span></span> -&gt; <span class="type">Node</span>&lt;<span class="type">T</span>&gt;? &#123;</span><br><span class="line">        <span class="comment">// 1. 空结点, 其前驱为空</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 前驱结点在左结点的右子树上, 比如找6的前驱</span></span><br><span class="line">        <span class="keyword">var</span> p = node!.<span class="keyword">left</span></span><br><span class="line">        <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> p!.<span class="keyword">right</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = p!.<span class="keyword">right</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 前驱结点在父节点\祖父结点上, 比如找9的前驱</span></span><br><span class="line">        p = node</span><br><span class="line">        <span class="keyword">while</span> p!.parent != <span class="literal">nil</span> &amp;&amp; p == p!.parent?.<span class="keyword">left</span> &#123;</span><br><span class="line">            p = p!.parent</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p!.parent</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找后继结点</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">successor</span><span class="params">(<span class="number">_</span> node: Node&lt;T&gt;?)</span></span> -&gt; <span class="type">Node</span>&lt;<span class="type">T</span>&gt;? &#123;</span><br><span class="line">        <span class="comment">// 1. 空结点, 其后继为空</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 后继结点在右结点的左子树上, 比如找7的后继</span></span><br><span class="line">        <span class="keyword">var</span> p = node!.<span class="keyword">right</span></span><br><span class="line">        <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> p!.<span class="keyword">left</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = p!.<span class="keyword">left</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 后继结点在父节点\祖父结点上, 比如找5的后继</span></span><br><span class="line">        p = node</span><br><span class="line">        <span class="keyword">while</span> p!.parent != <span class="literal">nil</span> &amp;&amp; p == p!.parent?.<span class="keyword">right</span> &#123;</span><br><span class="line">            p = p!.parent</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p!.parent</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 树的高度--迭代写法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">height</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 层序遍历法</span></span><br><span class="line">        <span class="keyword">let</span> queue = <span class="type">Queue</span>&lt;<span class="type">Node</span>&lt;<span class="type">T</span>&gt;&gt;()</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> level = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">        queue.enQueue(root!)</span><br><span class="line">        <span class="keyword">while</span> queue.size() != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> r = queue.deQueue()</span><br><span class="line">            level -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r.<span class="keyword">left</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.enQueue(r.<span class="keyword">left</span>!)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> r.<span class="keyword">right</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.enQueue(r.<span class="keyword">right</span>!)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> level == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 这一层遍历结束</span></span><br><span class="line">                level = queue.size()</span><br><span class="line">                height += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height</span><br><span class="line">        <span class="comment">//return height(root)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 树的高度--递归写法</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">height</span><span class="params">(<span class="number">_</span> node: Node&lt;T&gt;?)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(height(node!.<span class="keyword">left</span>), height(node!.<span class="keyword">right</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结点类</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt;: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ele: <span class="type">T</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">        <span class="keyword">var</span> parent: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">        <span class="keyword">init</span>(<span class="number">_</span> ele: <span class="type">T</span>, <span class="number">_</span> parent: <span class="type">Node</span>?) &#123;</span><br><span class="line">            <span class="keyword">self</span>.ele = ele</span><br><span class="line">            <span class="keyword">self</span>.parent = parent</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 叶子结点, 左右结点均为空</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">isLeaf</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">left</span> == <span class="literal">nil</span> &amp;&amp; <span class="keyword">right</span> == <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 有两个结点</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">hasTwoChildren</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">left</span> != <span class="literal">nil</span> &amp;&amp; <span class="keyword">right</span> != <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 是左子结点</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">isLeftChild</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="comment">// 比较指针是否一致</span></span><br><span class="line">            <span class="keyword">return</span> parent != <span class="literal">nil</span> &amp;&amp; parent?.<span class="keyword">left</span> === <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 是右子结点</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">isRightChild</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="comment">// 比较指针是否一致</span></span><br><span class="line">            <span class="keyword">return</span> parent != <span class="literal">nil</span> &amp;&amp; parent?.<span class="keyword">right</span> === <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对等比较</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Node&lt;T&gt;, rhs: Node&lt;T&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.ele == rhs.ele</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-二叉搜索树"><a href="#12-二叉搜索树" class="headerlink" title="12.二叉搜索树"></a>12.二叉搜索树</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">T</span>: <span class="title">Comparable</span>&gt;: <span class="title">BinaryTree</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 查找结点</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">findNode</span><span class="params">(<span class="number">_</span> ele: T)</span></span> -&gt; <span class="type">Node</span>&lt;<span class="type">T</span>&gt;? &#123;</span><br><span class="line">        <span class="keyword">var</span> p = root</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ele == p!.ele &#123;</span><br><span class="line">                <span class="comment">// 元素相等, 直接替换</span></span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ele &lt; p!.ele &#123;</span><br><span class="line">                <span class="comment">// 位于左子树</span></span><br><span class="line">                p = p!.<span class="keyword">left</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 位于右子树</span></span><br><span class="line">                p = p!.<span class="keyword">right</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加结点</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addNode</span><span class="params">(<span class="number">_</span> ele: T)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 添加的是根节点</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            root = <span class="type">Node</span>(ele, <span class="literal">nil</span>)</span><br><span class="line">            nodeCount += <span class="number">1</span></span><br><span class="line">            afterAdd(root!)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// 添加的不是根结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> p = root</span><br><span class="line">            <span class="keyword">var</span> parent = root</span><br><span class="line">            <span class="keyword">while</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">                parent = p</span><br><span class="line">                <span class="keyword">if</span> ele == p!.ele &#123;</span><br><span class="line">                    <span class="comment">// 元素相等, 直接替换</span></span><br><span class="line">                    p?.ele = ele</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ele &lt; p!.ele &#123;</span><br><span class="line">                    <span class="comment">// 位于左子树</span></span><br><span class="line">                    p = p!.<span class="keyword">left</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 位于右子树</span></span><br><span class="line">                    p = p!.<span class="keyword">right</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 得到parent结点</span></span><br><span class="line">            <span class="keyword">let</span> newNode = <span class="type">Node</span>(ele, parent)</span><br><span class="line">            <span class="keyword">if</span> ele &gt; parent!.ele &#123;</span><br><span class="line">                parent?.<span class="keyword">right</span> = newNode</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent?.<span class="keyword">left</span> = newNode</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 总结点数量加1</span></span><br><span class="line">            nodeCount += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            afterAdd(newNode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> ele: T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;? = findNode(ele)</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 没有找到需要删除的结点</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结点数量减1</span></span><br><span class="line">        nodeCount -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 度为2的结点</span></span><br><span class="line">        <span class="keyword">if</span> node!.hasTwoChildren() &#123;</span><br><span class="line">            <span class="comment">// 找它的后继结点</span></span><br><span class="line">            <span class="keyword">let</span> p = successor(node)</span><br><span class="line">            <span class="comment">// 用后继结点内容替换待删除结点内容</span></span><br><span class="line">            node!.ele = p!.ele</span><br><span class="line">            <span class="comment">// 需要删的结点就是node结点了</span></span><br><span class="line">            node = p</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// node是叶子结点而且也是根结点</span></span><br><span class="line">        <span class="keyword">if</span> node?.parent == <span class="literal">nil</span> &#123;</span><br><span class="line">            root = <span class="literal">nil</span></span><br><span class="line">            afterRemove(node!)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要替换的结点</span></span><br><span class="line">        <span class="keyword">let</span> replace = node?.<span class="keyword">left</span> == <span class="literal">nil</span> ? node?.<span class="keyword">right</span> : node?.<span class="keyword">left</span></span><br><span class="line">        <span class="keyword">if</span> replace == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// node没有左子树也没有右子树, 说明node是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> node?.parent?.<span class="keyword">left</span> == node &#123;</span><br><span class="line">                <span class="comment">// node是父结点的左结点</span></span><br><span class="line">                node?.parent?.<span class="keyword">left</span> = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// node是父结点的右结点</span></span><br><span class="line">                node?.parent?.<span class="keyword">right</span> = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            afterRemove(node!)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> node?.parent == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 是根结点</span></span><br><span class="line">                root = replace</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> node?.parent?.<span class="keyword">left</span> == node &#123;</span><br><span class="line">                <span class="comment">// 是左结点</span></span><br><span class="line">                node?.parent?.<span class="keyword">left</span> = replace</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 是右结点</span></span><br><span class="line">                node?.parent?.<span class="keyword">right</span> = replace</span><br><span class="line">            &#125;</span><br><span class="line">            afterRemove(node!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">afterAdd</span><span class="params">(<span class="number">_</span> node: Node&lt;T&gt;)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">afterRemove</span><span class="params">(<span class="number">_</span> node: Node&lt;T&gt;)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-AVLTree"><a href="#13-AVLTree" class="headerlink" title="13.AVLTree"></a>13.AVLTree</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span>&lt;<span class="title">T</span>: <span class="title">Comparable</span>&gt;: <span class="title">BinarySearchTree</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">afterAdd</span><span class="params">(<span class="number">_</span> node: Node&lt;T&gt;)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"已经添加<span class="subst">\(node)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">afterRemove</span><span class="params">(<span class="number">_</span> node: Node&lt;T&gt;)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"已经移除<span class="subst">\(node)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还木有写完。。。。</p><h2 id="14-红黑树"><a href="#14-红黑树" class="headerlink" title="14.红黑树"></a>14.红黑树</h2><h2 id="15-二叉堆"><a href="#15-二叉堆" class="headerlink" title="15.二叉堆"></a>15.二叉堆</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Heap</span>  </span>&#123;</span><br><span class="line">    associatedtype <span class="type">T</span></span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> ele: T)</span></span></span><br><span class="line">    <span class="comment">// 获取堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> -&gt; <span class="type">T</span></span><br><span class="line">    <span class="comment">// 删除堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> -&gt; <span class="type">T</span></span><br><span class="line">    <span class="comment">// 删除堆顶元素的同时插入一个新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">replace</span><span class="params">(<span class="number">_</span> ele: T)</span></span> -&gt; <span class="type">T</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryHeap</span>&lt;<span class="title">T</span>: <span class="title">Comparable</span>&gt;: <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用nil作为占位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> list: [<span class="type">T</span>?]</span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 默认10个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">DEFAULT_CAPACITY</span> = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> capaticy: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> capaticy = capaticy &lt; <span class="type">DEFAULT_CAPACITY</span> ? <span class="type">DEFAULT_CAPACITY</span> : capaticy</span><br><span class="line">        list = [<span class="type">T</span>?](repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: capaticy)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureCapacity</span><span class="params">(<span class="number">_</span> <span class="built_in">count</span>: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> &gt; list.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> oldList = <span class="keyword">self</span>.list</span><br><span class="line">            <span class="comment">// 扩容1.5倍</span></span><br><span class="line">            <span class="keyword">let</span> newCapacity = oldList.<span class="built_in">count</span> + oldList.<span class="built_in">count</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">self</span>.list = [<span class="type">T</span>?](repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: newCapacity)</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;size &#123;</span><br><span class="line">                <span class="keyword">self</span>.list[idx] = oldList[idx]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;size &#123;</span><br><span class="line">            list[idx] = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> ele: T)</span></span> &#123;</span><br><span class="line">        ensureCapacity(size + <span class="number">1</span>)</span><br><span class="line">        list[size] = ele</span><br><span class="line">        size += <span class="number">1</span></span><br><span class="line">        siftUp(size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.isEmpty() &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"堆为空, 无法删除"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list[<span class="number">0</span>]!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.isEmpty() &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"堆为空, 无法删除"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> first = list[<span class="number">0</span>]!</span><br><span class="line">        list[<span class="number">0</span>] = list[size]</span><br><span class="line">        list[size] = <span class="literal">nil</span></span><br><span class="line">        siftDown(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> first</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除堆顶元素的同时插入一个新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">replace</span><span class="params">(<span class="number">_</span> ele: T)</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.isEmpty() &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"堆为空, 无法删除"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> root: <span class="type">T</span>?</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            list[<span class="number">0</span>] = ele</span><br><span class="line">            size += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = list[<span class="number">0</span>];</span><br><span class="line">            list[<span class="number">0</span>] = ele;</span><br><span class="line">            siftDown(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(<span class="number">_</span> eles: [T])</span></span> &#123;</span><br><span class="line">        size = eles.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;eles.<span class="built_in">count</span> &#123;</span><br><span class="line">            list[idx] = eles[idx]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自上而下的上滤O(nlogn)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         for idx in 0..&lt;size &#123;</span></span><br><span class="line"><span class="comment">         siftUp(idx)</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自下而上的上滤O(n)</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> (<span class="number">0</span>...size &gt;&gt; <span class="number">1</span>).reversed() &#123;</span><br><span class="line">            siftDown(idx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// index位置的元素下滤</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">siftDown</span><span class="params">(<span class="number">_</span> idx: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ele = list[idx]!</span><br><span class="line">        <span class="keyword">var</span> idx = idx</span><br><span class="line">        <span class="keyword">while</span> idx &lt; size &gt;&gt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 左结点</span></span><br><span class="line">            <span class="keyword">var</span> childIdx = idx &lt;&lt; <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">var</span> child = list[childIdx]!</span><br><span class="line">            <span class="comment">// 右结点索引</span></span><br><span class="line">            <span class="keyword">let</span> rightIdx = childIdx + <span class="number">1</span></span><br><span class="line">            <span class="comment">// 如果右结点存在, 则取出左右结点中较大的一个</span></span><br><span class="line">            <span class="keyword">if</span> rightIdx &lt; size &amp;&amp; list[rightIdx]! &gt; child &#123;</span><br><span class="line">                childIdx = rightIdx</span><br><span class="line">                child = list[childIdx]!</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果自己不小于较大子结点, 停止下滤</span></span><br><span class="line">            <span class="keyword">if</span> ele &gt;= child &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换自己与较大子结点的位置</span></span><br><span class="line">            list[idx] = child</span><br><span class="line">            idx = childIdx</span><br><span class="line">        &#125;</span><br><span class="line">        list[idx] = ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// index位置的元素上滤</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">siftUp</span><span class="params">(<span class="number">_</span> idx: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> idx = idx</span><br><span class="line">        <span class="keyword">let</span> ele = list[idx]!</span><br><span class="line">        <span class="keyword">while</span> idx &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> parentIdx = (idx - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">let</span> parent = list[parentIdx]!</span><br><span class="line">            <span class="keyword">if</span> parent &gt;= ele &#123;</span><br><span class="line">                <span class="comment">// 父结点不小于自己, 停止上滤</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换自己与父结点的位置</span></span><br><span class="line">            list[idx] = parent</span><br><span class="line">            idx = parentIdx</span><br><span class="line">        &#125;</span><br><span class="line">        list[idx] = ele</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">desc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(list)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上滤</strong><br>1、当插入一个新元素时，放在最末尾。<br>2、若有父节点，将插入节点和父节点比较，如果插入节点大于父节点，交换位置。<br>3、重复2，直至插入节点不小于父节点或者没有父节点，上滤结束。</p><p><strong>下滤</strong><br>1、删除首元素，将最后一个元素移到首节点。<br>2、若有孩子，则比较该节点和最大孩子的值，若小于最大孩子的值，与最大的孩子互换位置。<br>3、重复2，直至该节点的值大于最大孩子的值或者没有孩子，下滤结束，堆序性得以满足。</p><h2 id="16-优先级队列"><a href="#16-优先级队列" class="headerlink" title="16.优先级队列"></a>16.优先级队列</h2><p>使用二叉堆实现。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">T</span>: <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> heap: <span class="type">BinaryHeap</span> = <span class="type">BinaryHeap</span>&lt;<span class="type">T</span>&gt;(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heap.size</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heap.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        heap.clear()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enQueue</span><span class="params">(<span class="number">_</span> ele: T)</span></span> &#123;</span><br><span class="line">        heap.add(ele)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deQueue</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heap.remove()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">front</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="keyword">get</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 使用Swift实现常见的数据结构。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Key-Value Observing源码初探</title>
    <link href="http://blog.chenyalun.com/2019/05/31/Key-Value%20Observing%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/"/>
    <id>http://blog.chenyalun.com/2019/05/31/Key-Value Observing源码初探/</id>
    <published>2019-05-31T11:37:45.000Z</published>
    <updated>2019-09-17T03:33:08.930Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> KVO源码阅读。 </p><a id="more"></a><p>尝试去读一遍KVO的源码，发现它比KVC复杂的多，只能明白个大概。<br>文章最后按照自己的理解，再结合源码的实现流程自己写了一个KVO，锻炼锻炼。</p><h1 id="一、常用接口"><a href="#一、常用接口" class="headerlink" title="一、常用接口"></a>一、常用接口</h1><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// KVO的回调</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">NSKeyValueObserving</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加及移除观察者</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">NSKeyValueObserverRegistration</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="二、技巧回顾"><a href="#二、技巧回顾" class="headerlink" title="二、技巧回顾"></a>二、技巧回顾</h1><h2 id="1-如何使得属性在未改变的情况下不发送通知-手动控制"><a href="#1-如何使得属性在未改变的情况下不发送通知-手动控制" class="headerlink" title="1.如何使得属性在未改变的情况下不发送通知(手动控制)?"></a>1.如何使得属性在未改变的情况下不发送通知(手动控制)?</h2><p>示例如下，主要有:</p><ol><li>重写<code>automaticallyNotifiesObserversForKey:</code>方法</li><li>重写<code>setter</code>方法</li></ol><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAObject</span></span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"name"</span>]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">if</span> (name != _name) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">        _name = name;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="2-如何注册依赖键-多个属性影响到某一个属性"><a href="#2-如何注册依赖键-多个属性影响到某一个属性" class="headerlink" title="2.如何注册依赖键(多个属性影响到某一个属性)?"></a>2.如何注册依赖键(多个属性影响到某一个属性)?</h2><ol><li>重写<code>getter</code>方法，定义依赖关系</li><li>重写<code>keyPathsForValuesAffectingValueForKey:</code>方法，添加依赖的key集合</li></ol><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAObject</span></span></span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="comment">// 定义依赖关系</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"firstName is %@ and lastName is %@"</span>, <span class="keyword">self</span>.firstName, <span class="keyword">self</span>.lastName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"name"</span>]) &#123;</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:@[<span class="string">@"firstName"</span>, <span class="string">@"lastName"</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> // 也可以命名为keyPathsForValuesAffecting&lt;Key&gt;的类方法来达到同样的目的</span></span><br><span class="line"><span class="comment"> + (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingName &#123;</span></span><br><span class="line"><span class="comment">     return [NSSet setWithObjects:@"firstName", @"lastName", nil];</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="3-当NSMutableArray中元素增加和减少时如何监听到"><a href="#3-当NSMutableArray中元素增加和减少时如何监听到" class="headerlink" title="3.当NSMutableArray中元素增加和减少时如何监听到?"></a>3.当NSMutableArray中元素增加和减少时如何监听到?</h2><p>示例代码:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YAObject </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) NSMutableArray *nameList;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> YAObject</span><br><span class="line"><span class="comment">// 实现集合代理对象: 一般建议-countOf&lt;Key&gt;和-objectIn&lt;Key&gt;AtIndex:</span></span><br><span class="line">- (NSUInteger)countOfNameList &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[_nameList count]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">objectInNameListAtIndex</span><span class="selector-pseudo">:(NSUInteger)index</span> &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[_nameList objectAtIndex:index]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 至少实现一个插入方法和一个删除方法</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">insertObject</span><span class="selector-pseudo">:(id)object</span> <span class="selector-tag">inNameListAtIndex</span><span class="selector-pseudo">:(NSUInteger)index</span> &#123;</span><br><span class="line">    <span class="selector-attr">[_nameList insertObject:object atIndex:index]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)<span class="attribute">removeObjectFromNameListAtIndex</span>:(NSUInteger)index &#123;</span><br><span class="line">    <span class="selector-attr">[_nameList removeObjectAtIndex:index]</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>使用:</p><ol><li>务必使用<code>mutableArrayValueForKey</code>获取集合</li><li>使用<code>insertObject</code>方法添加元素</li></ol><p>比如:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">NSMutableArray *nameList = [self.obj <span class="string">mutableArrayValueForKey:</span>@<span class="string">"nameList"</span>];</span><br><span class="line">[nameList <span class="string">insertObject:</span>obj <span class="string">atIndex:</span><span class="number">0</span>];</span><br></pre></td></tr></table></figure><h1 id="三、几个问题"><a href="#三、几个问题" class="headerlink" title="三、几个问题"></a>三、几个问题</h1><p>总结的几个问题。</p><h2 id="1-KVO的实现原理是什么"><a href="#1-KVO的实现原理是什么" class="headerlink" title="1.KVO的实现原理是什么?"></a>1.KVO的实现原理是什么?</h2><blockquote><p>Objective-C依托于强大的runtime机制来实现KVO。当我们第一次观察某个对象的属性时，runtime会创建一个新的继承自这个对象的class的subclass(前缀是<code>NSKVONotifying_</code>)。在这个新的subclass中，它会重写所有被观察的key的setter，然后将object的isa指针指向新创建的class(这个指针告诉Objective-C运行时某个object到底是什么类型的)。所以object神奇地变成了新的子类的实例。</p></blockquote><p>——摘自南峰子的博客。</p><p>新类重写了<code>setter</code>方法、<code>class</code>方法、<code>dealloc</code>方法和<code>_isKVOA</code>方法。如果自己生成重名的NSKVONotifying_XX类，会造成KVO失效。以监听YAPerson对象的age属性为例，主要逻辑的伪代码如下：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YAPerson </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) NSUInteger age;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> YAPerson</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">NSKVONotifying_YAPerson </span>: YAPerson</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> NSKVONotifying_YAPerson</span><br><span class="line">- (void)<span class="attribute">setAge</span>:(NSUInteger)age &#123;</span><br><span class="line">    <span class="selector-tag">_NSSetUnsignedLongLongValueAndNotify</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">_NSSetUnsignedLongLongValueAndNotify</span>() &#123;</span><br><span class="line">    <span class="selector-attr">[self willChangeValueForKey:@"age"]</span>;</span><br><span class="line">    <span class="selector-attr">[super setAge:age]</span>;</span><br><span class="line">    <span class="selector-attr">[self didChangeValueForKey:@"age"]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)<span class="attribute">didChangeValueForKey</span>:(NSString *)key &#123;</span><br><span class="line">    <span class="selector-attr">[observer observeValueForKeyPath:@"age" ofObject:self change:change context:context]</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><h2 id="2-KVO源码中添加观察者时整体的大致流程是什么"><a href="#2-KVO源码中添加观察者时整体的大致流程是什么" class="headerlink" title="2.KVO源码中添加观察者时整体的大致流程是什么?"></a>2.KVO源码中添加观察者时整体的大致流程是什么?</h2><ol><li>将<code>keyPath</code>、<code>class</code>等信息封装成<code>NSKeyValueProperty</code>，分别解析一般属性(<code>@&quot;aa&quot;</code>)、可计算属性(<code>@&quot;@aa&quot;</code>)、属性链(<code>@&quot;aa.bb.@cc.dd&quot;</code>)，进行子类化，缓存在<code>CFMutableSet</code>中方便下次快速取出。</li><li>将<code>NSKeyValueProperty</code>、<code>context</code>、<code>options</code>、<code>observer</code>等信息封装成<code>NSKeyValueObservance</code>，缓存在<code>NSHashTable</code>中。</li><li>倘若设置了<code>NSKeyValueObservingOptionInitial</code>选项，会在注册观察服务时调用一次触发方法。</li><li>动态创建名为<code>NSKVONotifying_+原来类名</code>的新类，重写其<code>dealloc</code>、<code>_isKVOA</code>方法，再重写<code>class</code>方法，利用<code>object_setClass()</code>函数将其isa指针指向原先的类。</li><li>重写<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法，重写被观察属性的<code>setter</code>方法，在<code>setter</code>中先调用<code>willChangeValueForKey:</code>方法，然后调用父类的 <code>setter</code> 方法对成员变量赋值，之后再调用 <code>didChangeValueForKey:</code> 方法。</li><li><code>didChangeValueForKey:</code> 方法中会调用<code>observeValueForKeyPath:ofObject:change:context:</code>方法。</li></ol><h2 id="3-KVO中所封装组件的关系是怎样的"><a href="#3-KVO中所封装组件的关系是怎样的" class="headerlink" title="3.KVO中所封装组件的关系是怎样的?"></a>3.KVO中所封装组件的关系是怎样的?</h2><ol><li>将<code>keyPath、class</code>等信息封装成<code>NSKeyValueProperty</code>，使用<code>CFMutableSet</code>缓存<code>NSKeyValueProperty</code>。</li><li>将<code>observer、property、options、context 、originalObservable</code>等信息封装成<code>NSKeyValueObservance</code>，<code>使用NSHashTable(NSKeyValueShareableObservationInfos)</code>缓存。</li><li><code>NSKeyValueObservationInfo</code>与<code>NSKeyValueObservance</code>的关系是: <code>NSKeyValueObservationInfo</code>中有一个<code>observances</code>数组，数组里面是<code>NSKeyValueObservance</code>对象。</li><li>每一个<code>object</code>都有一个<code>observationInfo</code>属性(<code>void *</code>类型)，它与<code>NSKeyValueObservationInfo</code>会相互转化。</li></ol><p><code>class</code>和<code>keyPath</code>决定了是否是同一个<code>NSKeyValueProperty</code>。<br><code>NSKeyValueProperty</code>、<code>Observer</code>、<code>options</code>、<code>context</code> 决定了是否是同一个<code>NSKeyValueObservance</code>。</p><h2 id="4-KVO多次使用完全相同的参数进行addObserver操作，也会得到相应次数的回调，如何做到"><a href="#4-KVO多次使用完全相同的参数进行addObserver操作，也会得到相应次数的回调，如何做到" class="headerlink" title="4.KVO多次使用完全相同的参数进行addObserver操作，也会得到相应次数的回调，如何做到?"></a>4.KVO多次使用完全相同的参数进行addObserver操作，也会得到相应次数的回调，如何做到?</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[self.obj <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"name"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>NULL];</span><br><span class="line">[self.obj <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"name"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>NULL];</span><br><span class="line">[self.obj <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"name"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>NULL];</span><br><span class="line">[self.obj <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"name"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>NULL];</span><br></pre></td></tr></table></figure><p>如上面代码，会有四次回调。</p><p>在每次添加观察者时，都会获取<code>NSKeyValueObservance</code>对象(可能从缓存中获取也可能新建)，并把它追加到object的<code>observances</code>数组中(即使该数组中已经存在完全相同（指针一致）的<code>NSKeyValueObservance</code>对象)，由此保证了多次<code>addObserver</code>操作会有多次回调。</p><p>通过打印可以证明：</p><p><img src="https://image.chenyalun.com/2019/05/30/001.png" style="zoom:50%"></p><h2 id="5-如何手动触发KVO"><a href="#5-如何手动触发KVO" class="headerlink" title="5.如何手动触发KVO?"></a>5.如何手动触发KVO?</h2><p>手动调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>。也即：<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)invokeKVOForAge &#123;</span><br><span class="line">    [<span class="meta">self.person willChangeValueForKey:@<span class="meta-string">"age"</span></span>];</span><br><span class="line">    [<span class="meta">self.person didChangeValueForKey:@<span class="meta-string">"age"</span></span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只手动调用一个还不行，为什么？由原理可知，<code>didChangeValueForKey:</code>中才真正调用了<code>observeValueForKeyPath:ofObject:change:context</code>方法，所以<code>didChangeValueForKey:</code>毋庸置疑不可或缺。那么为什么还需要<code>willChangeValueForKey:</code>呢？<br>查看文档，苹果一如既往地冷酷：</p><blockquote><p>Calls to this method are always paired with a matching call to willChangeValueForKey:.</p></blockquote><p>意思是，这俩是成对存在的，你只管调就是了。好吧，这块源码确实没看明白，先挖个坑吧。</p><h2 id="6-通过KVC修改属性会触发KVO吗"><a href="#6-通过KVC修改属性会触发KVO吗" class="headerlink" title="6.通过KVC修改属性会触发KVO吗?"></a>6.通过KVC修改属性会触发KVO吗?</h2><p>当KVC是通过setter方法设值时，无需多言，会触发KVO。当KVC是通过成员变量设值时，也会触发KVO，为什么？<br>阅读源码可知，直接通过成员变量设值，会创建NSKeyValueIvarSetter对象，在该对象的构造方法中会调用<code>_NSSetValueAndNotifyForKeyInIvar()</code>函数，其实现如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _NSSetValueAndNotifyForKeyInIvar(<span class="keyword">id</span> object, SEL selector, <span class="keyword">id</span> value, <span class="built_in">NSString</span> *key, Ivar ivar, IMP imp) &#123;</span><br><span class="line">    [object willChangeValueForKey:key];</span><br><span class="line">    </span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">id</span>,<span class="built_in">NSString</span> *, Ivar))imp)(object,<span class="literal">NULL</span>,value,key,ivar);</span><br><span class="line">    </span><br><span class="line">    [object didChangeValueForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真相大白了，它调用了<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法，正是这个触发了KVO。需要注意的是，<strong>直接修改成员变量是不会触发KVO的</strong>。</p><h1 id="四、添加观察者"><a href="#四、添加观察者" class="headerlink" title="四、添加观察者"></a>四、添加观察者</h1><p>这一步骤中封装出了许多的类，同时也把产生的许多对象做了进一步的缓存处理。</p><h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h2><h3 id="1-1接口方法"><a href="#1-1接口方法" class="headerlink" title="1.1接口方法"></a>1.1接口方法</h3><p>加锁，接口方法中使用<code>pthread</code>中的<code>pthread_mutex_lock()</code>和<code>pthread_mutex_unlock</code>函数。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是个接口方法, 添加观察者分为两个流程: 1，根据class和keyPath获取NSKeyValueProperty对象。2，添加对property的观察。</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">d_addObserver:</span>(NSObject *)observer <span class="string">forKeyPath:</span>(NSString *)keyPath <span class="string">options:</span>(NSKeyValueObservingOptions)options <span class="string">context:</span>(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;_NSKeyValueObserverRegistrationLock);</span><br><span class="line">    <span class="comment">// 获取当前线程pthread</span></span><br><span class="line">    _NSKeyValueObserverRegistrationLockOwner = pthread_self();</span><br><span class="line">    <span class="comment">// 根据class和keyPath获取NSKeyValueProperty</span></span><br><span class="line">    NSKeyValueProperty *property = NSKeyValuePropertyForIsaAndKeyPath(object_getClass(self),keyPath);</span><br><span class="line">    <span class="comment">// 添加对property的观察</span></span><br><span class="line">    [self <span class="string">_d_addObserver:</span>observer <span class="string">forProperty:</span>property <span class="string">options:</span>options <span class="string">context:</span>context];</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;_NSKeyValueObserverRegistrationLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-添加对NSKeyValueProperty的观察的具体实现"><a href="#1-2-添加对NSKeyValueProperty的观察的具体实现" class="headerlink" title="1.2.添加对NSKeyValueProperty的观察的具体实现"></a>1.2.添加对NSKeyValueProperty的观察的具体实现</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加观察者过程中, 不是单纯地'观察'keyPath, 而是观察对keyPath封装的NSKeyValueProperty</span></span><br><span class="line">- (<span class="keyword">void</span>)_addObserver:(<span class="keyword">id</span>)observer forProperty:(<span class="built_in">NSKeyValueProperty</span> *)property options:(<span class="keyword">int</span>)options context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span>(options &amp; <span class="built_in">NSKeyValueObservingOptionInitial</span>) &#123;</span><br><span class="line">        <span class="comment">// NSKeyValueObservingOptionInitial: 观察最初的值（在注册观察服务时会调用一次触发方法）</span></span><br><span class="line">        <span class="built_in">NSString</span> *keyPath = [property keyPath];</span><br><span class="line">        _NSKeyValueObserverRegistrationLockOwner = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;_NSKeyValueObserverRegistrationLock);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> newValue = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (options &amp; <span class="built_in">NSKeyValueObservingOptionNew</span>) &#123;</span><br><span class="line">            <span class="comment">// newValue就是当前的值</span></span><br><span class="line">            newValue = [<span class="keyword">self</span> valueForKeyPath:keyPath];</span><br><span class="line">            <span class="keyword">if</span> (!newValue) &#123;</span><br><span class="line">                newValue = [<span class="built_in">NSNull</span> null]; <span class="comment">// 使用NSNull对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSKeyValueChangeDictionary</span> *changeDictionary = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 创建NSKeyValueChangeDetails结构体</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         typedef struct &#123;</span></span><br><span class="line"><span class="comment">             NSKeyValueChange kind;</span></span><br><span class="line"><span class="comment">             id oldValue;</span></span><br><span class="line"><span class="comment">             id newValue;</span></span><br><span class="line"><span class="comment">             NSIndexSet *indexes;</span></span><br><span class="line"><span class="comment">             id extraData;</span></span><br><span class="line"><span class="comment">         &#125; NSKeyValueChangeDetails;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">NSKeyValueChangeDetails</span> changeDetails = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        changeDetails.kind = <span class="built_in">NSKeyValueChangeSetting</span>;</span><br><span class="line">        changeDetails.oldValue = <span class="literal">nil</span>;</span><br><span class="line">        changeDetails.newValue = newValue;</span><br><span class="line">        changeDetails.indexes = <span class="literal">nil</span>;</span><br><span class="line">        changeDetails.extraData = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 函数1: 通知观察者, 传递结构体changeDetails</span></span><br><span class="line">        <span class="built_in">NSKeyValueNotifyObserver</span>(observer,keyPath, <span class="keyword">self</span>, context, <span class="literal">nil</span>, <span class="literal">NO</span>,changeDetails, &amp;changeDictionary);</span><br><span class="line">        </span><br><span class="line">        [changeDictionary release];</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;_NSKeyValueObserverRegistrationLock);</span><br><span class="line">        <span class="comment">// 获取当前pthread</span></span><br><span class="line">        _NSKeyValueObserverRegistrationLockOwner = pthread_self();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数2: 获取oldObservationInfo</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservationInfo</span> *oldObservationInfo = _NSKeyValueRetainedObservationInfoForObject(<span class="keyword">self</span>,property.containerClass);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> cacheHit = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">NSKeyValueObservance</span> *addedObservance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> originalObservable = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((options &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">        <span class="comment">// _CFGetTSD: 获取线程信息</span></span><br><span class="line">        <span class="comment">// Get some thread specific data from a pre-assigned slot.</span></span><br><span class="line">        <span class="built_in">NSKeyValueObservingTSD</span> *TSD = _CFGetTSD(<span class="built_in">NSKeyValueObservingTSDKey</span>);</span><br><span class="line">        <span class="keyword">if</span> (TSD) &#123;</span><br><span class="line">            originalObservable = TSD-&gt;implicitObservanceAdditionInfo.originalObservable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数3: 获取newObservationInfo</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservationInfo</span> *newObservationInfo = _NSKeyValueObservationInfoCreateByAdding(oldObservationInfo, observer, property, options, context, originalObservable,&amp;cacheHit,&amp;addedObservance);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数4: 将self的observationInfo设置为newObservationInfo</span></span><br><span class="line">    _NSKeyValueReplaceObservationInfoForObject(<span class="keyword">self</span>,property.containerClass,oldObservationInfo,newObservationInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// - (void)object:(id)object didAddObservance:(NSKeyValueObservance *)observance recurse:(BOOL)recurse &#123;&#125;</span></span><br><span class="line">    <span class="comment">// 实际上这个方法啥事也没做</span></span><br><span class="line">    [property object:<span class="keyword">self</span> didAddObservance:addedObservance recurse:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心方法: 获取property中已经修改过的class</span></span><br><span class="line">    Class isaForAutonotifying = [property isaForAutonotifying];</span><br><span class="line">    <span class="keyword">if</span>(isaForAutonotifying) &#123;</span><br><span class="line">        Class cls = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">if</span>(cls != isaForAutonotifying) &#123;</span><br><span class="line">            <span class="comment">// 通过 object_setClass()修改isa指针, 设置自己的class为property的isaForAutonotifying</span></span><br><span class="line">            object_setClass(<span class="keyword">self</span>,isaForAutonotifying);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [newObservationInfo release];</span><br><span class="line">    [oldObservationInfo release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数1-设置changeDictionary并调用NSKVONotify-函数"><a href="#函数1-设置changeDictionary并调用NSKVONotify-函数" class="headerlink" title="函数1: 设置changeDictionary并调用NSKVONotify()函数"></a>函数1: 设置changeDictionary并调用NSKVONotify()函数</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">NSKeyValueNotifyObserver</span>(<span class="keyword">id</span> observer,<span class="built_in">NSString</span> * keyPath, <span class="keyword">id</span> object, <span class="keyword">void</span> *context, <span class="keyword">id</span> originalObservable, <span class="built_in">BOOL</span> isPriorNotification, <span class="built_in">NSKeyValueChangeDetails</span> changeDetails, <span class="built_in">NSKeyValueChangeDictionary</span> **changeDictionary) &#123;</span><br><span class="line">    <span class="keyword">if</span>(*changeDictionary) &#123;</span><br><span class="line">        [*changeDictionary setDetailsNoCopy:changeDetails originalObservable:originalObservable];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *changeDictionary =  [[<span class="built_in">NSKeyValueChangeDictionary</span> alloc] initWithDetailsNoCopy:changeDetails originalObservable:originalObservable isPriorNotification:isPriorNotification];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSUInteger</span> retainCountBefore = [*changeDictionary retainCount];</span><br><span class="line">    <span class="built_in">NSKVONotify</span>(observer, keyPath, object, *changeDictionary, context);</span><br><span class="line">    <span class="keyword">if</span>(retainCountBefore != (<span class="built_in">NSUInteger</span>)INTMAX_MAX &amp;&amp; retainCountBefore != [*changeDictionary retainCount]) &#123;</span><br><span class="line">        [*changeDictionary retainObjects];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSKVONotify()函数就是调用observeValueForKeyPath方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">NSKVONotify</span>(<span class="keyword">id</span> observer, <span class="built_in">NSString</span> *keyPath, <span class="keyword">id</span> object, <span class="built_in">NSDictionary</span> *changeDictionary, <span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueObservingAssertRegistrationLockNotHeld</span>();</span><br><span class="line">    [observer observeValueForKeyPath:keyPath ofObject:object change:changeDictionary context:context];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数2-获取object的observationInfo对象"><a href="#函数2-获取object的observationInfo对象" class="headerlink" title="函数2: 获取object的observationInfo对象"></a>函数2: 获取object的observationInfo对象</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSKeyValueObservationInfo</span> *_NSKeyValueRetainedObservationInfoForObject(<span class="keyword">id</span> object, <span class="built_in">NSKeyValueContainerClass</span> *containerClass) &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueObservationInfo</span> *observationInfo = <span class="literal">nil</span>;</span><br><span class="line">    os_lock_lock(&amp;<span class="built_in">NSKeyValueObservationInfoSpinLock</span>);</span><br><span class="line">    <span class="keyword">if</span> (containerClass) &#123;</span><br><span class="line">        <span class="comment">// 调用containerClass的cachedObservationInfoImplementation实现</span></span><br><span class="line">        observationInfo = ((<span class="built_in">NSKeyValueObservationInfo</span> * (*)(<span class="keyword">id</span>,SEL))containerClass.cachedObservationInfoImplementation)(object, <span class="keyword">@selector</span>(observationInfo));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接获取object的d_observationInfo对象</span></span><br><span class="line">        observationInfo = (<span class="built_in">NSKeyValueObservationInfo</span> *)[object d_observationInfo];</span><br><span class="line">    &#125;</span><br><span class="line">    [observationInfo <span class="keyword">retain</span>];</span><br><span class="line">    os_lock_unlock(&amp;<span class="built_in">NSKeyValueObservationInfoSpinLock</span>);</span><br><span class="line">    <span class="keyword">return</span>  observationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数3-获取’添加观察者’时所需要的NSKeyValueObservationInfo"><a href="#函数3-获取’添加观察者’时所需要的NSKeyValueObservationInfo" class="headerlink" title="函数3: 获取’添加观察者’时所需要的NSKeyValueObservationInfo"></a>函数3: 获取’添加观察者’时所需要的NSKeyValueObservationInfo</h4><p>如果<code>baseObservationInfo</code>存在，则一顿封装操作后，会把封装完毕的<code>NSKeyValueObservance</code>“追加”到<code>baseObservationInfo</code>的<code>observances</code>数组中。如果<code>baseObservationInfo</code>不存在，则一顿封装操作后，会把封装完毕的<code>NSKeyValueObservance</code>放到新创建的<code>NSKeyValueObservationInfo</code>对象的<code>observances</code>数组中。最后，<code>cacheHit</code>告诉调用者是否有命中缓存，<code>*addedObservance</code>指向了<code>observance</code>对象。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSKeyValueObservationInfo</span> *_NSKeyValueObservationInfoCreateByAdding(<span class="built_in">NSKeyValueObservationInfo</span> *baseObservationInfo, <span class="keyword">id</span> observer, <span class="built_in">NSKeyValueProperty</span> *property, <span class="keyword">int</span> options, <span class="keyword">void</span> *context, <span class="keyword">id</span> originalObservable,  <span class="built_in">BOOL</span> *cacheHit, <span class="built_in">NSKeyValueObservance</span> **addedObservance) &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueObservationInfo</span> *createdObservationInfo = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    os_lock_lock(&amp;<span class="built_in">NSKeyValueObservationInfoCreationSpinLock</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用弱引用表NSKeyValueShareableObservationInfos缓存观察者对象</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">NSKeyValueShareableObservationInfos</span>) &#123;</span><br><span class="line">        <span class="comment">// 自定义NSPointerFunctions</span></span><br><span class="line">        <span class="built_in">NSPointerFunctions</span> *pointerFunctions = [[<span class="built_in">NSPointerFunctions</span> alloc] initWithOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span>];</span><br><span class="line">        <span class="comment">// 设置hash函数</span></span><br><span class="line">        [pointerFunctions setHashFunction:<span class="built_in">NSKeyValueShareableObservationInfoNSHTHash</span>];</span><br><span class="line">        <span class="comment">// 设置判等函数</span></span><br><span class="line">        [pointerFunctions setIsEqualFunction:<span class="built_in">NSKeyValueShareableObservationInfoNSHTIsEqual</span>];</span><br><span class="line">        <span class="comment">// 创建NSHashTable</span></span><br><span class="line">        <span class="built_in">NSKeyValueShareableObservationInfos</span> = [[<span class="built_in">NSHashTable</span> alloc] initWithPointerFunctions:pointerFunctions capacity:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">NSKeyValueShareableObservationInfoKeyIsa</span>) &#123;</span><br><span class="line">        <span class="built_in">NSKeyValueShareableObservationInfoKeyIsa</span> = [<span class="built_in">NSKeyValueShareableObservationInfoKey</span> <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过这个公共key到缓存表NSKeyValueShareableObservationInfos中查找</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSKeyValueShareableObservationInfoKey</span> * shareableObservationInfoKey;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!shareableObservationInfoKey) &#123;</span><br><span class="line">        <span class="comment">// 第一次使用, 为空时创建</span></span><br><span class="line">        shareableObservationInfoKey = [[<span class="built_in">NSKeyValueShareableObservationInfoKey</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置key的信息</span></span><br><span class="line">    shareableObservationInfoKey.addingNotRemoving = <span class="literal">YES</span>;</span><br><span class="line">    shareableObservationInfoKey.baseObservationInfo = baseObservationInfo;</span><br><span class="line">    shareableObservationInfoKey.additionObserver = observer;</span><br><span class="line">    shareableObservationInfoKey.additionProperty = property;</span><br><span class="line">    shareableObservationInfoKey.additionOptions = options;</span><br><span class="line">    shareableObservationInfoKey.additionContext = context;</span><br><span class="line">    shareableObservationInfoKey.additionOriginalObservable = originalObservable;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据shareableObservationInfoKey的已有信息进行查找</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservationInfo</span> * existsObservationInfo = [<span class="built_in">NSKeyValueShareableObservationInfos</span> member:shareableObservationInfoKey];</span><br><span class="line">    <span class="comment">// 清空shareableObservationInfoKey的废弃信息(主要是减少对observer的引用计数)</span></span><br><span class="line">    shareableObservationInfoKey.additionOriginalObservable = <span class="literal">nil</span>;</span><br><span class="line">    shareableObservationInfoKey.additionObserver = <span class="literal">nil</span>;</span><br><span class="line">    shareableObservationInfoKey.baseObservationInfo = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!existsObservationInfo) &#123; <span class="comment">// 缓存中不存在</span></span><br><span class="line">        <span class="comment">// (一般是第一次使用时)NSHashTable为空, 创建</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">NSKeyValueShareableObservances</span>) &#123;</span><br><span class="line">            <span class="built_in">NSKeyValueShareableObservances</span> = [<span class="built_in">NSHashTable</span> weakObjectsHashTable];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过这个公共key到缓存表NSKeyValueShareableObservances中查找</span></span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">NSKeyValueShareableObservanceKey</span> *shareableObservanceKey;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!shareableObservanceKey) &#123; <span class="comment">// key不存在时创建</span></span><br><span class="line">            shareableObservanceKey = [[<span class="built_in">NSKeyValueShareableObservanceKey</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置key的信息</span></span><br><span class="line">        shareableObservanceKey.observer = observer;</span><br><span class="line">        shareableObservanceKey.property = property;</span><br><span class="line">        shareableObservanceKey.options = options;</span><br><span class="line">        shareableObservanceKey.context = context;</span><br><span class="line">        shareableObservanceKey.originalObservable = originalObservable;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找Observance缓存</span></span><br><span class="line">        <span class="built_in">NSKeyValueObservance</span> *existsObservance = [<span class="built_in">NSKeyValueShareableObservances</span> member:shareableObservanceKey];</span><br><span class="line">        <span class="comment">// 清空shareableObservanceKey的废弃信息</span></span><br><span class="line">        shareableObservanceKey.originalObservable = <span class="literal">nil</span>;</span><br><span class="line">        shareableObservanceKey.observer = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSKeyValueObservance</span> *observance = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!existsObservance) &#123;</span><br><span class="line">            <span class="comment">// 没有找到, 则创建observance</span></span><br><span class="line">            observance = [[<span class="built_in">NSKeyValueObservance</span> alloc] _initWithObserver:observer property:property options:options context:context originalObservable:originalObservable];</span><br><span class="line">            <span class="keyword">if</span>(observance.cachedIsShareable) &#123;</span><br><span class="line">                <span class="comment">// 可以缓存, 放入NSKeyValueShareableObservances中</span></span><br><span class="line">                [<span class="built_in">NSKeyValueShareableObservances</span> addObject:observance];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到了, observance就指向existsObservance</span></span><br><span class="line">            observance = existsObservance;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (baseObservationInfo) &#123;</span><br><span class="line">            <span class="comment">// 复制baseObservationInfo并追加observance</span></span><br><span class="line">            createdObservationInfo = [baseObservationInfo _copyByAddingObservance:observance];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建新的ObservationInfo</span></span><br><span class="line">            createdObservationInfo = [[<span class="built_in">NSKeyValueObservationInfo</span> alloc] _initWithObservances:&amp;observance count:<span class="number">1</span> hashValue:<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (createdObservationInfo.cachedIsShareable)&#123;</span><br><span class="line">            <span class="comment">// 允许缓存, 添加到NSKeyValueShareableObservationInfos中</span></span><br><span class="line">            [<span class="built_in">NSKeyValueShareableObservationInfos</span> addObject:createdObservationInfo];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有命中缓存</span></span><br><span class="line">        *cacheHit = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 设置新添加的Observance</span></span><br><span class="line">        *addedObservance = observance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存中存在</span></span><br><span class="line">        <span class="comment">// 设置命中缓存</span></span><br><span class="line">        *cacheHit = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// observance必定就是已存在的info.observance列表最后一个, 因为判断equal就是按照这个原则去判断的</span></span><br><span class="line">        <span class="comment">// 判等函数: NSKeyValueShareableObservationInfoNSHTIsEqual()</span></span><br><span class="line">        *addedObservance = existsObservationInfo.observances.lastObject;</span><br><span class="line">        <span class="comment">// 设置createdObservationInfo</span></span><br><span class="line">        createdObservationInfo = existsObservationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    os_lock_unlock(&amp;<span class="built_in">NSKeyValueObservationInfoCreationSpinLock</span>);</span><br><span class="line">    <span class="keyword">return</span> createdObservationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数4-将object的observationInfo设置为newObservationInfo"><a href="#函数4-将object的observationInfo设置为newObservationInfo" class="headerlink" title="函数4:将object的observationInfo设置为newObservationInfo"></a>函数4:将object的observationInfo设置为newObservationInfo</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _NSKeyValueReplaceObservationInfoForObject(<span class="keyword">id</span> object, <span class="built_in">NSKeyValueContainerClass</span> * containerClass, <span class="built_in">NSKeyValueObservationInfo</span> *oldObservationInfo, <span class="built_in">NSKeyValueObservationInfo</span> *newObservationInfo) &#123;</span><br><span class="line">    os_lock_lock(&amp;<span class="built_in">NSKeyValueObservationInfoSpinLock</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newObservationInfo) [newObservationInfo <span class="keyword">retain</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不理解??????</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     typedef struct &#123;</span></span><br><span class="line"><span class="comment">         CFMutableArrayRef pendingArray;//0</span></span><br><span class="line"><span class="comment">         ObservationInfoWatcher *firstWatcher;//4</span></span><br><span class="line"><span class="comment">         ImplicitObservanceAdditionInfo  implicitObservanceAdditionInfo;</span></span><br><span class="line"><span class="comment">         ImplicitObservanceRemovalInfo implicitObservanceRemovalInfo;</span></span><br><span class="line"><span class="comment">     &#125; NSKeyValueObservingTSD;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingTSD</span> *TSD = _CFGetTSD(<span class="built_in">NSKeyValueObservingTSDKey</span>);</span><br><span class="line">    <span class="keyword">if</span>(TSD) &#123;</span><br><span class="line">        ObservationInfoWatcher *next = TSD-&gt;firstWatcher;</span><br><span class="line">        <span class="keyword">while</span>(next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;object == object) &#123;</span><br><span class="line">                [next-&gt;observationInfo release];</span><br><span class="line">                next-&gt;observationInfo = [newObservationInfo <span class="keyword">retain</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next = next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(containerClass) &#123;</span><br><span class="line">        <span class="comment">// 调用object的d_setObservationInfo:方法, 并传参数newObservationInfo</span></span><br><span class="line">        containerClass.cacheNSetObservationInfoImplementation(object, <span class="keyword">@selector</span>(d_setObservationInfo:), newObservationInfo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接设置新值</span></span><br><span class="line">        [object d_setObservationInfo: newObservationInfo];</span><br><span class="line">    &#125;</span><br><span class="line">    os_lock_unlock(&amp;<span class="built_in">NSKeyValueObservationInfoSpinLock</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2.缓存"></a>2.缓存</h2><p>缓存查找逻辑是一致的: 确定这些对象的<code>hash</code>和<code>isEqual:</code>方法，通过创建与目标对象判等属性一致的key去查找。</p><h3 id="2-1-NSKeyValueProperty的缓存"><a href="#2-1-NSKeyValueProperty的缓存" class="headerlink" title="2.1.NSKeyValueProperty的缓存"></a>2.1.NSKeyValueProperty的缓存</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">NSKeyValueProperties</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建集合NSKeyValueProperties</span></span><br><span class="line">    <span class="built_in">CFSetCallBacks</span> callbacks = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    callbacks.version =  kCFTypeSetCallBacks.version;</span><br><span class="line">    callbacks.retain =  kCFTypeSetCallBacks.retain;</span><br><span class="line">    callbacks.release =  kCFTypeSetCallBacks.release;</span><br><span class="line">    callbacks.copyDescription =  kCFTypeSetCallBacks.copyDescription;</span><br><span class="line">    <span class="comment">// 设置CFSet集合中元素判等的依据</span></span><br><span class="line">    callbacks.equal =  (<span class="built_in">CFSetEqualCallBack</span>)<span class="built_in">NSKeyValuePropertyIsEqual</span>;</span><br><span class="line">    <span class="comment">// 设置CFSet集合中元素的hash值获取函数</span></span><br><span class="line">    callbacks.hash =  (<span class="built_in">CFSetHashCallBack</span>)<span class="built_in">NSKeyValuePropertyHash</span>;</span><br><span class="line">    <span class="built_in">NSKeyValueProperties</span> =  <span class="built_in">CFSetCreateMutable</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;callbacks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把property添加到NSKeyValueProperties集合中</span></span><br><span class="line"><span class="built_in">CFSetAddValue</span>(<span class="built_in">NSKeyValueProperties</span>, property);</span><br></pre></td></tr></table></figure><p>CFSet集合中元素判等的依据</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> <span class="built_in">NSKeyValuePropertyIsEqual</span>(<span class="built_in">NSKeyValueProperty</span> *property1, <span class="built_in">NSKeyValueProperty</span> *property2) &#123;</span><br><span class="line">    <span class="keyword">return</span> (property1.containerClass == property2.containerClass) &amp;&amp;</span><br><span class="line">    (property1.keyPath == property2.keyPath || [property1.keyPath isEqual: property2.keyPath]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回NSKeyValueProperty的hash值</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">NSUInteger NSKeyValuePropertyHash(NSKeyValueProperty *<span class="keyword">property</span><span class="title"></span>) &#123;</span><br><span class="line">    return <span class="keyword">property</span>.<span class="title"></span>keyPath.hash ^ (NSUInteger)(void *)<span class="keyword">property</span>.<span class="title"></span>containerClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次证明了 <code>class</code>和<code>keyPath</code>决定了是否是同一个<code>NSKeyValueProperty</code>。</p><h3 id="2-2-NSKeyValueObservance的缓存"><a href="#2-2-NSKeyValueObservance的缓存" class="headerlink" title="2.2.NSKeyValueObservance的缓存"></a>2.2.NSKeyValueObservance的缓存</h3><p>缓存查找</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSHashTable</span> *<span class="built_in">NSKeyValueShareableObservances</span>;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">NSKeyValueShareableObservances</span>) &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueShareableObservances</span> = [<span class="built_in">NSHashTable</span> weakObjectsHashTable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// observance查找key</span></span><br><span class="line"><span class="keyword">static</span> DNSKeyValueShareableObservanceKey *shareableObservanceKey;</span><br><span class="line"><span class="keyword">if</span>(!shareableObservanceKey) &#123;</span><br><span class="line">    shareableObservanceKey = [[DNSKeyValueShareableObservanceKey alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">shareableObservanceKey.observer = observer;</span><br><span class="line">shareableObservanceKey.property = property;</span><br><span class="line">shareableObservanceKey.options = options;</span><br><span class="line">shareableObservanceKey.context = context;</span><br><span class="line">shareableObservanceKey.originalObservable = originalObservable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找缓存</span></span><br><span class="line"><span class="built_in">NSKeyValueObservance</span> *existsObservance = [<span class="built_in">NSKeyValueShareableObservances</span> member:shareableObservanceKey];</span><br><span class="line">shareableObservanceKey.originalObservable = <span class="literal">nil</span>;</span><br><span class="line">shareableObservanceKey.observer = <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure><p>重写<code>NSKeyValueObservance</code>的<code>hash</code>和<code>isEqual:</code>方法</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)hash &#123;</span><br><span class="line">    <span class="keyword">return</span> _NSKVOPointersHash(<span class="number">5</span>, _observer, _property, (<span class="keyword">void</span> *)(<span class="built_in">NSUInteger</span>)(_options), _context, _originalObservable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (![object isKindOfClass: <span class="keyword">self</span>.class])  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">NSKeyValueObservance</span> *other = (<span class="built_in">NSKeyValueObservance</span> *)object;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> other.observer == <span class="keyword">self</span>.observer &amp;&amp;</span><br><span class="line">    other.options == <span class="keyword">self</span>.options &amp;&amp;</span><br><span class="line">    other.context == <span class="keyword">self</span>.context &amp;&amp;</span><br><span class="line">    other.originalObservable == <span class="keyword">self</span>.originalObservable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-NSKeyValueObservationInfo的缓存"><a href="#2-3-NSKeyValueObservationInfo的缓存" class="headerlink" title="2.3.NSKeyValueObservationInfo的缓存"></a>2.3.NSKeyValueObservationInfo的缓存</h3><p>缓存查找</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSHashTable</span> *<span class="built_in">NSKeyValueShareableObservationInfos</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// observationInfo缓存</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">NSKeyValueShareableObservationInfos</span>) &#123;</span><br><span class="line">    <span class="built_in">NSPointerFunctions</span> *pointerFunctions = [[<span class="built_in">NSPointerFunctions</span> alloc] initWithOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span>];</span><br><span class="line">    [pointerFunctions setHashFunction:<span class="built_in">NSKeyValueShareableObservationInfoNSHTHash</span>];</span><br><span class="line">    [pointerFunctions setIsEqualFunction:<span class="built_in">NSKeyValueShareableObservationInfoNSHTIsEqual</span>];</span><br><span class="line">    <span class="built_in">NSKeyValueShareableObservationInfos</span> = [[<span class="built_in">NSHashTable</span> alloc] initWithPointerFunctions:pointerFunctions capacity:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-NSKeyValueObservationInfo的存储-observationInfo"><a href="#2-4-NSKeyValueObservationInfo的存储-observationInfo" class="headerlink" title="2.4.NSKeyValueObservationInfo的存储(observationInfo)"></a>2.4.NSKeyValueObservationInfo的存储(observationInfo)</h3><p>当封装成<code>NSKeyValueObservationInfo</code>时，<code>weak</code>的<code>NSHashTable</code>并不负责存储，那么，谁负责真正的存储呢?</p><p>Take or return a pointer that identifies information about all of the observers that are registered with the receiver, the options that were used at registration-time, etc. The default implementation of these methoNS store observation info in a global dictionary keyed by the receivers’ pointers. For improved performance, you can override these methoNS to store the opaque data pointer in an instance variable. Overrides of these methoNS must not attempt to send Objective-C messages to the passed-in observation info, including -retain and -release.</p><blockquote><p>这个方法的默认实现是以对象的指针作为key，从一个全局的字典中获取信息。</p></blockquote><p>如何获取对象的指针？这里有个定义：<br><code>OBSERVATION_INFO_KEY</code>的定义是: <code>#define OBSERVATION_INFO_KEY(object) ((void *)(~(NSUInteger)(object)))</code></p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFMutableDictionaryRef</span> <span class="built_in">NSKeyValueObservationInfoPerObject</span> = <span class="literal">NULL</span>;</span><br><span class="line">- (<span class="keyword">void</span> *)observationInfo &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSKeyValueObservationInfoPerObject</span> ? (<span class="keyword">void</span> *)<span class="built_in">CFDictionaryGetValue</span>(<span class="built_in">NSKeyValueObservationInfoPerObject</span>, OBSERVATION_INFO_KEY(<span class="keyword">self</span>)) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObservationInfo:(<span class="keyword">void</span> *)info &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">NSKeyValueObservationInfoPerObject</span>) &#123;</span><br><span class="line">        <span class="built_in">NSKeyValueObservationInfoPerObject</span> = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info) &#123;</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(<span class="built_in">NSKeyValueObservationInfoPerObject</span>, OBSERVATION_INFO_KEY(<span class="keyword">self</span>), info);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryRemoveValue</span>(<span class="built_in">NSKeyValueObservationInfoPerObject</span>, OBSERVATION_INFO_KEY(<span class="keyword">self</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>即这个方法的默认实现是以对象的指针作为key，从一个全局的字典中获取信息。由此，我们可以理解为，KVO的信息是存储在一个全局字典中，而不是存储在对象本身。<br>不过，为了提高效率，我们可以重写observationInfo属性的set和get方法，以将这个不透明的数据指针存储到一个实例变量中。但是，在重写时，我们不应该尝试去向这些数据发送一个Objective-C消息，包括retain和release。</p></blockquote><h2 id="3-新建与重写"><a href="#3-新建与重写" class="headerlink" title="3.新建与重写"></a>3.新建与重写</h2><p>在这一步骤中，动态创建了原来class的子类，当然，也重写和添加了许多方法。</p><h3 id="3-1动态创建子类的核心实现"><a href="#3-1动态创建子类的核心实现" class="headerlink" title="3.1动态创建子类的核心实现"></a>3.1动态创建子类的核心实现</h3><p>动态创建子类中，重写了<code>dealloc、class、_isKVOA</code>方法。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSKeyValueNotifyingInfo</span> *_NSKVONotifyingCreateInfoWithOriginalClass(Class originalClass) &#123;</span><br><span class="line">    <span class="keyword">static</span> IMP <span class="built_in">NSObjectWillChange</span>;</span><br><span class="line">    <span class="keyword">static</span> IMP <span class="built_in">NSObjectDidChange</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造新的子类名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *originalClassName = class_getName(originalClass);</span><br><span class="line">    size_t size = strlen(originalClassName) + <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">char</span> *newClassName = (<span class="keyword">char</span> *)malloc(size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #define NOTIFY_CLASSNAME_PREFIX "NSKVONotifying_"</span></span><br><span class="line">    strlcpy(newClassName, NOTIFY_CLASSNAME_PREFIX, size);</span><br><span class="line">    strlcat(newClassName, originalClassName, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子类</span></span><br><span class="line">    Class newSubClass = objc_allocateClassPair(originalClass, newClassName, <span class="keyword">sizeof</span>(<span class="built_in">NSKeyValueNotifyingInfo</span>));</span><br><span class="line">    objc_registerClassPair(newSubClass);</span><br><span class="line">    </span><br><span class="line">    free(newClassName);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *ivars = object_getIndexedIvars(newSubClass);</span><br><span class="line">    <span class="comment">// 创建NSKeyValueNotifyingInfo对象, 封装子类\原始类等信息</span></span><br><span class="line">    <span class="built_in">NSKeyValueNotifyingInfo</span> *notifyingInfo = (<span class="built_in">NSKeyValueNotifyingInfo</span> *)ivars;</span><br><span class="line">    notifyingInfo-&gt;originalClass = originalClass;</span><br><span class="line">    notifyingInfo-&gt;newSubClass = newSubClass;</span><br><span class="line">    notifyingInfo-&gt;notifyingKeys = <span class="built_in">CFSetCreateMutable</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;kCFCopyStringSetCallBacks);</span><br><span class="line">    notifyingInfo-&gt;selKeyMap = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">    </span><br><span class="line">    pthread_mutexattr_t mutexattr;</span><br><span class="line">    pthread_mutexattr_init(&amp;mutexattr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;mutexattr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    pthread_mutex_init(&amp;notifyingInfo-&gt;mutex, &amp;mutexattr);</span><br><span class="line">    pthread_mutexattr_destroy(&amp;mutexattr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取NSObject类的 willChangeValueForKey 和 didChangeValueForKey实现</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> <span class="built_in">NSObjectIMPLookupOnce</span>;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;<span class="built_in">NSObjectIMPLookupOnce</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSObjectWillChange</span> = class_getMethodImplementation([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(d_willChangeValueForKey:));</span><br><span class="line">        <span class="built_in">NSObjectDidChange</span> = class_getMethodImplementation([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(d_didChangeValueForKey:));</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断originalClass类是否重写了 willChangeValueForKey 或  didChangeValueForKey</span></span><br><span class="line">    <span class="comment">// 就是拿NSObject的实现与originalClass的实现做对比(函数指针IMP比较)</span></span><br><span class="line">    notifyingInfo-&gt;overrideWillOrDidChange = class_getMethodImplementation(notifyingInfo-&gt;originalClass, <span class="keyword">@selector</span>(d_willChangeValueForKey:)) != <span class="built_in">NSObjectWillChange</span> || class_getMethodImplementation(notifyingInfo-&gt;originalClass, <span class="keyword">@selector</span>(d_didChangeValueForKey:)) != <span class="built_in">NSObjectDidChange</span>;</span><br><span class="line">    <span class="comment">// 对notifyingInfo的originalClass添加 _isKVOA方法</span></span><br><span class="line">    <span class="built_in">NSKVONotifyingSetMethodImplementation</span>(notifyingInfo, ISKVOA_SELECTOR, (IMP)<span class="built_in">NSKVOIsAutonotifying</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 对notifyingInfo的originalClass添加 dealloc方法</span></span><br><span class="line">    <span class="built_in">NSKVONotifyingSetMethodImplementation</span>(notifyingInfo, <span class="keyword">@selector</span>(dealloc), (IMP)<span class="built_in">NSKVODeallocate</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 对notifyingInfo的originalClass添加 class方法</span></span><br><span class="line">    <span class="built_in">NSKVONotifyingSetMethodImplementation</span>(notifyingInfo, <span class="keyword">@selector</span>(<span class="keyword">class</span>), (IMP)<span class="built_in">NSKVOClass</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> notifyingInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-isKVOA方法"><a href="#添加-isKVOA方法" class="headerlink" title="添加_isKVOA方法"></a>添加_isKVOA方法</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> <span class="built_in">NSKVOIsAutonotifying</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重写class方法"><a href="#重写class方法" class="headerlink" title="重写class方法"></a>重写class方法</h4><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">NSKVOClass</span>(<span class="title">id</span> <span class="title">object</span>, <span class="title">SEL</span> <span class="title">selector</span>) &#123;</span></span><br><span class="line">    // 新的<span class="class"><span class="keyword">class</span>: <span class="title">NSKVONotifying_XXXX</span></span></span><br><span class="line">    <span class="class"><span class="keyword">Class</span> <span class="title">currentClass</span> = <span class="title">object_getClass</span>(<span class="title">object</span>);</span></span><br><span class="line">    // 原先的<span class="class"><span class="keyword">class</span>: <span class="title">XXXX</span></span></span><br><span class="line">    <span class="class"><span class="keyword">Class</span> <span class="title">originalClass</span> =  <span class="title">_NSKVONotifyingOriginalClassForIsa</span>(<span class="title">currentClass</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (currentClass == originalClass) &#123;</span><br><span class="line">        // 相同, 返回object的currentClass</span><br><span class="line">        <span class="function"><span class="keyword">Method</span> <span class="title">m</span> =</span> class_getInstanceMethod(currentClass, selector);</span><br><span class="line">        <span class="keyword">return</span> ((<span class="class"><span class="keyword">Class</span> (*)(<span class="title">id</span>,<span class="title">Method</span>))<span class="title">method_invoke</span>)(<span class="title">object</span>, <span class="title">m</span>);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 不同, 返回originalClass</span><br><span class="line">        <span class="keyword">return</span> [originalClass <span class="class"><span class="keyword">class</span>];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重写dealloc方法"><a href="#重写dealloc方法" class="headerlink" title="重写dealloc方法"></a>重写dealloc方法</h4><p>获取<code>object</code>对应的<code>observationInfo</code>(对象)并把它放到结构体中，在调用完<code>object</code>原先的<code>dealloc</code>方法之后判断<code>observationInfo</code>是否还存在，若存在说明<code>observer</code>没有在<code>dealloc</code>之前被移除掉，进而抛出异常。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">NSKVODeallocate</span>(<span class="keyword">id</span> object, SEL selector) &#123;</span><br><span class="line">    <span class="comment">// 获取object对应的observationInfo</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservationInfo</span> *observationInfo = _NSKeyValueRetainedObservationInfoForObject(object, <span class="literal">nil</span>);</span><br><span class="line">    ObservationInfoWatcher watcher = &#123;object, observationInfo, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    _NSKeyValueAddObservationInfoWatcher(&amp;watcher);</span><br><span class="line">    <span class="comment">// 获取notifyInfo</span></span><br><span class="line">    <span class="built_in">NSKeyValueNotifyingInfo</span> *notifyInfo = (<span class="built_in">NSKeyValueNotifyingInfo</span> *)object_getIndexedIvars(object_getClass(object));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用object原来的dealloc实现</span></span><br><span class="line">    Method originDellocMethod = class_getInstanceMethod(notifyInfo-&gt;originalClass, selector);</span><br><span class="line">    ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>,Method))method_invoke)(object, originDellocMethod);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(watcher.observationInfo) &#123;</span><br><span class="line">            <span class="comment">// observationInfo不存在才对, 如果还存在, 说明没有正确地移除observer</span></span><br><span class="line">            <span class="built_in">BOOL</span> keyExistsAndHasValidFormat = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">BOOL</span> cleansUpBeforeThrowing = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            cleansUpBeforeThrowing = (<span class="built_in">BOOL</span>)<span class="built_in">CFPreferencesGetAppBooleanValue</span>(<span class="built_in">CFSTR</span>(<span class="string">"NSKVODeallocateCleansUpBeforeThrowing"</span>), kCFPreferencesCurrentApplication, (Boolean *)&amp;keyExistsAndHasValidFormat);</span><br><span class="line">            <span class="comment">// key存在且key对应的value为YES</span></span><br><span class="line">            cleansUpBeforeThrowing = cleansUpBeforeThrowing &amp;&amp; keyExistsAndHasValidFormat;</span><br><span class="line">            <span class="comment">// dyld_get_program_sdk_version返回系统版本</span></span><br><span class="line">            <span class="keyword">if</span> (dyld_get_program_sdk_version() &gt; <span class="number">0x7FFFF</span> || cleansUpBeforeThrowing) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cleansUpBeforeThrowing) &#123;</span><br><span class="line">                    _NSKeyValueRemoveObservationInfoForObject(object, watcher.observationInfo);</span><br><span class="line">                &#125;</span><br><span class="line">                [<span class="built_in">NSException</span> raise:<span class="built_in">NSInternalInconsistencyException</span> format:<span class="string">@"An instance %p of class %@ was deallocated while key value observers were still registered with it. Current observation info: %@"</span>, object, notifyInfo-&gt;originalClass, watcher.observationInfo];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">NSKVODeallocateBreak</span>(object);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        [exception raise];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@finally</span> &#123;</span><br><span class="line">        <span class="comment">// 移除watcher</span></span><br><span class="line">        _NSKeyValueRemoveObservationInfoWatcher(&amp;watcher);</span><br><span class="line">        </span><br><span class="line">        [watcher.observationInfo release];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-回调通知"><a href="#4-回调通知" class="headerlink" title="4.回调通知"></a>4.回调通知</h2><p>上文分析，<code>NSKeyValueNotifyObserver()</code>就是回调的函数，通过它调用<code>observeValueForKeyPath:ofObject:change:context:</code>方法。这里还剩下最后一个问题，回调是怎么处理的?</p><p>在<code>NSKVONotifyingEnableForInfoAndKey()</code>函数中重写setter方法，之后在<code>NSSetPrimitiveValueAndNotify()</code>函数中先调用<code>willChangeValueForKey</code>，再调用原先的setter方法，再调用<code>didChangeValueForKey</code>。</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static inline void NSSetPrimitiveValueAndNotify(id object,SEL selector, void (^setValueWithImplementation)(IMP imp)) &#123;</span><br><span class="line">    NSKeyValueNotifyingInfo *info = object_getIndexedIvars(object_getClass(object));</span><br><span class="line">    <span class="function"><span class="title">pthread_mutex_lock</span>(&amp;info-&gt;</span>mutex);</span><br><span class="line">    NSS<span class="function"><span class="title">tring</span> *key = CFDictionaryGetValue(info-&gt;</span>selKeyMap, selector);</span><br><span class="line">    key = [key copyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    <span class="function"><span class="title">pthread_mutex_unlock</span>(&amp;info-&gt;</span>mutex);</span><br><span class="line">    <span class="function"><span class="title">if</span> (info-&gt;</span>overrideWillOrDidChange) &#123;</span><br><span class="line">        [object willChangeValueForKey:key];</span><br><span class="line">        IMP <span class="function"><span class="title">imp</span> = class_getMethodImplementation(info-&gt;</span>originalClass, selector);</span><br><span class="line">        setValueWithImplementation(imp);</span><br><span class="line">        [object didChangeValueForKey:key];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [object changeValueForKey:key key:<span class="literal">nil</span> key:<span class="literal">nil</span> usingBlock:^&#123;</span><br><span class="line">            IMP <span class="function"><span class="title">imp</span> = class_getMethodImplementation(info-&gt;</span>originalClass, selector);</span><br><span class="line">            setValueWithImplementation(imp);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [key release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这里的<code>didChangeValueForKey</code>也被重写实现了，它会调用真正的回调<code>observeValueForKeyPath:ofObject:change:context:</code>方法。</p><h1 id="五、移除观察者"><a href="#五、移除观察者" class="headerlink" title="五、移除观察者"></a>五、移除观察者</h1><p>找到NSKeyValueObservance移除即可。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSKeyValueObservationInfo</span> *_NSKeyValueObservationInfoCreateByRemoving(<span class="built_in">NSKeyValueObservationInfo</span> *baseObservationInfo, <span class="keyword">id</span> observer, <span class="built_in">NSKeyValueProperty</span> *property, <span class="keyword">void</span> *context, <span class="built_in">BOOL</span> shouldCompareContext,  <span class="keyword">id</span> originalObservable,  <span class="built_in">BOOL</span> *cacheHit, <span class="built_in">NSKeyValueObservance</span> **removalObservance) &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueObservationInfo</span> *createdObservationInfo = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前已经存在的observance的数量</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> observanceCount = <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)baseObservationInfo.observances);</span><br><span class="line">    <span class="built_in">NSKeyValueObservance</span> *observancesBuff[observanceCount];</span><br><span class="line">    <span class="built_in">CFArrayGetValues</span>((<span class="built_in">CFArrayRef</span>)baseObservationInfo.observances, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, observanceCount), (<span class="keyword">const</span> <span class="keyword">void</span> **)observancesBuff);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSUInteger</span> removalObservanceIndex = <span class="built_in">NSNotFound</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = observanceCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 逐个遍历observancesBuff数组中的元素</span></span><br><span class="line">        <span class="built_in">NSKeyValueObservance</span> *observance = observancesBuff[i];</span><br><span class="line">        <span class="comment">// property和observer一致</span></span><br><span class="line">        <span class="keyword">if</span> (observance.property == property &amp;&amp; observance.observer == observer) &#123;</span><br><span class="line">            <span class="comment">// 不需要比较context或者context一致</span></span><br><span class="line">            <span class="keyword">if</span> (!shouldCompareContext || observance.context == context) &#123;</span><br><span class="line">                <span class="comment">// originalObservable一致</span></span><br><span class="line">                <span class="keyword">if</span> (!originalObservable || observance.originalObservable == originalObservable) &#123;</span><br><span class="line">                    <span class="comment">// 需要移除的observance</span></span><br><span class="line">                    *removalObservance = observance;</span><br><span class="line">                    <span class="comment">// 确定了将要移除的observance的索引</span></span><br><span class="line">                    removalObservanceIndex = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已经找到需要移除的observance</span></span><br><span class="line">    <span class="keyword">if</span> (*removalObservance) &#123;</span><br><span class="line">        <span class="comment">// 原先observance的数量大于1个</span></span><br><span class="line">        <span class="keyword">if</span> (observanceCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            os_lock_lock(&amp;<span class="built_in">NSKeyValueObservationInfoCreationSpinLock</span>);</span><br><span class="line">            <span class="comment">// NSKeyValueShareableObservationInfos缓存不存在, 创建</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NSKeyValueShareableObservationInfos</span>) &#123;</span><br><span class="line">                <span class="built_in">NSPointerFunctions</span> *functions = [[<span class="built_in">NSPointerFunctions</span> alloc] initWithOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span>];</span><br><span class="line">                [functions setHashFunction:<span class="built_in">NSKeyValueShareableObservationInfoNSHTHash</span>];</span><br><span class="line">                [functions setIsEqualFunction:<span class="built_in">NSKeyValueShareableObservationInfoNSHTIsEqual</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">NSKeyValueShareableObservationInfos</span> = [[<span class="built_in">NSHashTable</span> alloc] initWithPointerFunctions:functions capacity:<span class="number">0</span>];</span><br><span class="line">                </span><br><span class="line">                [functions release];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NSKeyValueShareableObservationInfoKeyIsa</span>) &#123;</span><br><span class="line">                <span class="comment">// 就是NSKeyValueShareableObservationInfoKey.class</span></span><br><span class="line">                <span class="built_in">NSKeyValueShareableObservationInfoKeyIsa</span> = <span class="built_in">NSKeyValueShareableObservationInfoKey</span>.self;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">static</span> <span class="built_in">NSKeyValueShareableObservationInfoKey</span> * shareableObservationInfoKey = <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">// 构建查找缓存的Key</span></span><br><span class="line">            <span class="keyword">if</span> (!shareableObservationInfoKey) &#123;</span><br><span class="line">                shareableObservationInfoKey = [[<span class="built_in">NSKeyValueShareableObservationInfoKey</span> alloc] init];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            shareableObservationInfoKey.addingNotRemoving = <span class="literal">NO</span>;</span><br><span class="line">            shareableObservationInfoKey.baseObservationInfo = baseObservationInfo;</span><br><span class="line">            shareableObservationInfoKey.removalObservance = *removalObservance;</span><br><span class="line">            shareableObservationInfoKey.removalObservanceIndex = removalObservanceIndex;</span><br><span class="line">            shareableObservationInfoKey.cachedHash = <span class="built_in">NSKeyValueShareableObservationInfoNSHTHash</span>(shareableObservationInfoKey, <span class="literal">NULL</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试在缓存中查找NSKeyValueObservationInfo</span></span><br><span class="line">            <span class="built_in">NSKeyValueObservationInfo</span> *existsObservationInfo = [<span class="built_in">NSKeyValueShareableObservationInfos</span> member:shareableObservationInfoKey];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 重置key的数据</span></span><br><span class="line">            shareableObservationInfoKey.removalObservance = <span class="literal">nil</span>;</span><br><span class="line">            shareableObservationInfoKey.baseObservationInfo = <span class="literal">nil</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSUInteger</span> cachedHash = shareableObservationInfoKey.cachedHash;</span><br><span class="line">            </span><br><span class="line">            shareableObservationInfoKey.cachedHash = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!existsObservationInfo) &#123;</span><br><span class="line">                <span class="comment">// 在缓存中没有找到, 移除removalObservanceIndex对应的元素</span></span><br><span class="line">                memmove(observancesBuff + removalObservanceIndex, observancesBuff + removalObservanceIndex + <span class="number">1</span>, (observanceCount - (removalObservanceIndex + <span class="number">1</span>)) * <span class="keyword">sizeof</span>(<span class="built_in">NSKeyValueObservance</span> *));</span><br><span class="line">                <span class="comment">// 重新创建ObservationInfo, 数量为observanceCount - 1</span></span><br><span class="line">                createdObservationInfo = [[<span class="built_in">NSKeyValueObservationInfo</span> alloc] _initWithObservances:observancesBuff count:observanceCount - <span class="number">1</span> hashValue:cachedHash];</span><br><span class="line">                <span class="keyword">if</span> (createdObservationInfo.cachedIsShareable) &#123;</span><br><span class="line">                    <span class="comment">// 缓存ObservationInfo</span></span><br><span class="line">                    [<span class="built_in">NSKeyValueShareableObservationInfos</span> addObject:createdObservationInfo];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没有命中缓存</span></span><br><span class="line">                *cacheHit = <span class="literal">NO</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 命中缓存</span></span><br><span class="line">                *cacheHit = <span class="literal">YES</span>;</span><br><span class="line">                <span class="comment">// 直接赋值existsObservationInfo</span></span><br><span class="line">                createdObservationInfo = [existsObservationInfo <span class="keyword">retain</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            os_lock_unlock(&amp;<span class="built_in">NSKeyValueObservationInfoCreationSpinLock</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> createdObservationInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 原先只有一个observance, 命中缓存</span></span><br><span class="line">            *cacheHit = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到需要移除的observance, 返回nil</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、KVO自实现"><a href="#六、KVO自实现" class="headerlink" title="六、KVO自实现"></a>六、KVO自实现</h1><p>有很多同学尝试自己实现了KVO，有按照原生接口的，也有自我发挥直接传递block的。由于之前我已经读过一些开源的代码，见<a href="https://blog.chenyalun.com/2019/01/12/「KVOController」的封装/">《「KVOController」的封装》</a>，作者就是使用了block很好地封装了KVO的回调。所以，这里还是试着按照原生接口实现一下。</p><p>由于对源码理解地不是十分透彻，再加上能力有限，在尝试实现过程中遇到不少问题，幸好都解决了。当然，代码肯定有不少问题的，而且仅仅实现一点核心功能，姑且当做玩具看看吧。</p><h2 id="1-接口"><a href="#1-接口" class="headerlink" title="1.接口"></a>1.接口</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> NSObject(YAKVO)</span><br><span class="line"><span class="meta">@property</span> <span class="keyword">void</span> *ya_observationInfo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">ya_willChangeValueForKey:</span>(NSString *)key;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">ya_didChangeValueForKey:</span>(NSString *)key;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">ya_addObserver:</span>(NSObject *)observer <span class="string">forKeyPath:</span>(NSString *)keyPath <span class="string">options:</span>(NSKeyValueObservingOptions)options <span class="string">context:</span>(<span class="keyword">void</span> *)context;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">ya_removeObserver:</span>(NSObject *)observer <span class="string">forKeyPath:</span>(NSString *)keyPath <span class="string">context:</span>(<span class="keyword">void</span> *)context;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">ya_observeValueForKeyPath:</span>(NSString *)keyPath <span class="string">ofObject:</span>(id)object <span class="string">change:</span>(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change <span class="string">context:</span>(<span class="keyword">void</span> *)context;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define ClassPrefixCStr <span class="meta-string">"YAKVONotifying_"</span> // 新类的前缀</span></span><br><span class="line"><span class="meta">#define ClassPrefix     @ ClassPrefixCStr</span></span><br><span class="line"><span class="meta">#define OBSERVATION_INFO_KEY(object) ((void *)(~(NSUInteger)(object)))</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *YAKeyValueChangeDictionary = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 一些私有方法和属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">YAKVOPrivate</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span>(<span class="title">YAKVOPrivate</span>)</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)ya_isKVOClass &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ya_changeValueForKey:(<span class="built_in">NSString</span> *)key usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    [<span class="keyword">self</span> ya_willChangeValueForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (block) block();</span><br><span class="line">    [<span class="keyword">self</span> ya_didChangeValueForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 包装keyPath和originalClass</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAKeyValueProperty</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) Class isaForAutonotifying;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *keyPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) Class originalClass;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithOriginalClass:(Class)originalClass keyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAKeyValueProperty</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithOriginalClass:(Class)originalClass</span><br><span class="line">                              keyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _originalClass = originalClass;</span><br><span class="line">        _keyPath = keyPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)isaForAutonotifying &#123;</span><br><span class="line">    <span class="comment">// 构造新的子类名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *originalClassName = class_getName(_originalClass);</span><br><span class="line">    size_t size = strlen(originalClassName) + <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">char</span> *newClassName = (<span class="keyword">char</span> *)malloc(size);</span><br><span class="line">    </span><br><span class="line">    strlcpy(newClassName, ClassPrefixCStr, size);</span><br><span class="line">    strlcat(newClassName, originalClassName, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子类</span></span><br><span class="line">    Class newSubClass = objc_allocateClassPair(_originalClass, newClassName, <span class="number">0</span>);</span><br><span class="line">    objc_registerClassPair(newSubClass);</span><br><span class="line">    free(newClassName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Setter方法替换</span></span><br><span class="line">    <span class="built_in">NSString</span> *uppercase= [[_keyPath substringToIndex:<span class="number">1</span>] uppercaseString];</span><br><span class="line">    <span class="built_in">NSString</span> *last = [_keyPath substringFromIndex:<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *<span class="keyword">setter</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@%@:"</span>, uppercase, last];</span><br><span class="line">    SEL sel = <span class="built_in">NSSelectorFromString</span>(<span class="keyword">setter</span>);</span><br><span class="line">    Method method = class_getInstanceMethod(newSubClass, sel);</span><br><span class="line">    <span class="keyword">if</span> (method) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(method);</span><br><span class="line">        class_replaceMethod(newSubClass, sel, (IMP)YASetValueAndNotifyForKey, typeEncoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"缺少参数"</span> reason:<span class="string">@"没有实现Setter方法"</span> userInfo:<span class="literal">nil</span>] raise];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// class方法替换、ya_isKVOClass方法替换</span></span><br><span class="line">    YAKVONotifyingSetMethodImplementation(newSubClass, <span class="keyword">@selector</span>(ya_isKVOClass), (IMP)YAKVOIsAutonotifying);</span><br><span class="line">    YAKVONotifyingSetMethodImplementation(newSubClass, <span class="keyword">@selector</span>(<span class="keyword">class</span>), (IMP)YAKVOClass);</span><br><span class="line">    <span class="keyword">return</span> newSubClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应originalClass的ya_isKVOClass方法</span></span><br><span class="line"><span class="built_in">BOOL</span> YAKVOIsAutonotifying(<span class="keyword">id</span> object, SEL sel) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应originalClass的class方法</span></span><br><span class="line">Class YAKVOClass(<span class="keyword">id</span> object, SEL sel) &#123;</span><br><span class="line">    <span class="comment">// 新的class: NSKVONotifying_XXXX</span></span><br><span class="line">    Class currentClass = object_getClass(object);</span><br><span class="line">    <span class="keyword">if</span> ([object ya_isKVOClass]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *clsStr = [<span class="built_in">NSStringFromClass</span>(currentClass) stringByReplacingOccurrencesOfString:ClassPrefix withString:<span class="string">@""</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NSClassFromString</span>(clsStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应originalClass的setter方法</span></span><br><span class="line"><span class="keyword">void</span> YASetValueAndNotifyForKey(<span class="keyword">id</span> obj, SEL sel, <span class="keyword">id</span> value, IMP imp) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = [[<span class="built_in">NSStringFromSelector</span>(sel) substringFromIndex:<span class="number">3</span>] lowercaseString];</span><br><span class="line">    key = [key substringToIndex:key.length - <span class="number">1</span>];</span><br><span class="line">    [obj ya_changeValueForKey:key usingBlock:^&#123;</span><br><span class="line">        Class cls = [obj <span class="keyword">class</span>];</span><br><span class="line">        <span class="comment">// 调用父类的setter方法</span></span><br><span class="line">        IMP superImp = class_getMethodImplementation(cls, sel);</span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span> ,SEL , <span class="keyword">id</span>))superImp)(obj, sel, value);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对某个class添加实例方法</span></span><br><span class="line"><span class="keyword">void</span> YAKVONotifyingSetMethodImplementation(Class cls, SEL sel, IMP imp) &#123;</span><br><span class="line">    Method originMethod = class_getInstanceMethod(cls, sel);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *encoding = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (originMethod) &#123;</span><br><span class="line">        encoding = method_getTypeEncoding(originMethod);</span><br><span class="line">        class_addMethod(cls, sel, imp, encoding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 包装property、observer、context、options</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAKeyValueObservance</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) YAKeyValueProperty *property;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> observer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">void</span> *context;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> options;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="keyword">id</span>)observer property:(YAKeyValueProperty *)property options:(<span class="keyword">int</span>)options context:(<span class="keyword">void</span> *)context;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAKeyValueObservance</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="keyword">id</span>)observer</span><br><span class="line">                        property:(YAKeyValueProperty *)property</span><br><span class="line">                         options:(<span class="keyword">int</span>)options</span><br><span class="line">                         context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _observer = observer;</span><br><span class="line">        _property = property;</span><br><span class="line">        _options = options;</span><br><span class="line">        _context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)hash &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> observerContextHash = [[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p-%p"</span>, _observer, _context] hash];</span><br><span class="line">    <span class="keyword">return</span> observerContextHash ^ _property.hash ^ _options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (![object isKindOfClass:object_getClass(<span class="keyword">self</span>)]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    YAKeyValueObservance *other = (YAKeyValueObservance *)object;</span><br><span class="line">    <span class="keyword">return</span> other.observer == <span class="keyword">self</span>.observer &amp;&amp;</span><br><span class="line">    other.options == <span class="keyword">self</span>.options &amp;&amp;</span><br><span class="line">    other.context == <span class="keyword">self</span>.context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 包装YAKeyValueObservance数组</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAKeyValueObservationInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;YAKeyValueObservance *&gt; *observances;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObservances:(<span class="built_in">NSArray</span> &lt;YAKeyValueObservance *&gt; *)observances</span><br><span class="line">                              count:(<span class="built_in">NSUInteger</span>)count;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAKeyValueObservationInfo</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObservances:(<span class="built_in">NSArray</span>&lt;YAKeyValueObservance *&gt; *)observances</span><br><span class="line">                              count:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _observances = [[<span class="built_in">NSArray</span> alloc] initWithArray:observances];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 配置YAKeyValueObservationInfoKey，去查询匹配的YAKeyValueObservationInfo</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAKeyValueObservationInfoKey</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) YAKeyValueObservationInfo *baseObservationInfo;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *additionObserver;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) YAKeyValueProperty *additionProperty;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> additionOptions;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">void</span>* additionContext;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAKeyValueObservationInfoKey</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private methods</span></span><br><span class="line"><span class="built_in">BOOL</span> YAKeyValuePropertyIsEqual(YAKeyValueProperty *property1, YAKeyValueProperty *property2) &#123;</span><br><span class="line">    <span class="keyword">return</span> (property1.originalClass == property2.originalClass) &amp;&amp;</span><br><span class="line">    (property1.keyPath == property2.keyPath || [property1.keyPath isEqual: property2.keyPath]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSUInteger</span> YAKeyValuePropertyHash(YAKeyValueProperty *property) &#123;</span><br><span class="line">    <span class="keyword">return</span> property.keyPath.hash ^ (<span class="built_in">NSUInteger</span>)(__bridge <span class="keyword">void</span> *)property.originalClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取YAKeyValueProperty</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> YAKeyValueProperty *getKeyValueProperty(Class cls, <span class="built_in">NSString</span> *keyPath) &#123;</span><br><span class="line">    <span class="comment">// 缓存集合</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFMutableSetRef</span> YAKeyValueProperties;</span><br><span class="line">    <span class="keyword">if</span>(!YAKeyValueProperties) &#123;</span><br><span class="line">        <span class="comment">// 创建YAKeyValueProperties</span></span><br><span class="line">        <span class="built_in">CFSetCallBacks</span> callbacks = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        callbacks.version =  kCFTypeSetCallBacks.version;</span><br><span class="line">        callbacks.retain =  kCFTypeSetCallBacks.retain;</span><br><span class="line">        callbacks.release =  kCFTypeSetCallBacks.release;</span><br><span class="line">        callbacks.copyDescription =  kCFTypeSetCallBacks.copyDescription;</span><br><span class="line">        callbacks.equal =  (<span class="built_in">CFSetEqualCallBack</span>)YAKeyValuePropertyIsEqual;</span><br><span class="line">        callbacks.hash =  (<span class="built_in">CFSetHashCallBack</span>)YAKeyValuePropertyHash;</span><br><span class="line">        YAKeyValueProperties = <span class="built_in">CFSetCreateMutable</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;callbacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> YAKeyValueProperty *finder;</span><br><span class="line">    <span class="keyword">if</span> (!finder) finder = [YAKeyValueProperty new];</span><br><span class="line">    finder.originalClass = cls;</span><br><span class="line">    finder.keyPath = keyPath;</span><br><span class="line">    YAKeyValueProperty *property = <span class="built_in">CFSetGetValue</span>(YAKeyValueProperties, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(finder));</span><br><span class="line">    <span class="keyword">if</span> (!property) &#123;</span><br><span class="line">        <span class="comment">// 缓存中没有找到, 创建</span></span><br><span class="line">        property = [[YAKeyValueProperty alloc] initWithOriginalClass:cls keyPath:keyPath];</span><br><span class="line">        <span class="comment">// 添加到缓存中</span></span><br><span class="line">        <span class="built_in">CFSetAddValue</span>(YAKeyValueProperties, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(property));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取YAKeyValueObservance</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> YAKeyValueObservance *getKeyValueObservance(YAKeyValueProperty *property,</span><br><span class="line">                                                          <span class="keyword">id</span> observer,</span><br><span class="line">                                                          <span class="keyword">void</span> *context,</span><br><span class="line">                                                          <span class="keyword">int</span> options) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSHashTable</span> *YAKeyValueShareableObservances;</span><br><span class="line">    <span class="keyword">if</span> (!YAKeyValueShareableObservances) &#123;</span><br><span class="line">        YAKeyValueShareableObservances = [<span class="built_in">NSHashTable</span> weakObjectsHashTable];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> YAKeyValueObservance *finder;</span><br><span class="line">    <span class="keyword">if</span> (!finder) finder = [YAKeyValueObservance new];</span><br><span class="line">    finder.property = property;</span><br><span class="line">    finder.context = context;</span><br><span class="line">    finder.observer = observer;</span><br><span class="line">    finder.options = options;</span><br><span class="line">    YAKeyValueObservance *observance = [YAKeyValueShareableObservances member:finder];</span><br><span class="line">    <span class="keyword">if</span> (!observance) &#123;</span><br><span class="line">        <span class="comment">// 缓存中没有找到, 创建</span></span><br><span class="line">        observance = [[YAKeyValueObservance alloc] initWithObserver:observer property:property options:options context:context];</span><br><span class="line">        <span class="comment">// 添加到缓存中</span></span><br><span class="line">        [YAKeyValueShareableObservances addObject:observance];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> observance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSUInteger</span> YAKeyValueObservationInfoNSHTHash(<span class="keyword">const</span> <span class="keyword">void</span> *item, <span class="built_in">NSUInteger</span> (*size)(<span class="keyword">const</span> <span class="keyword">void</span> *item)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object_getClass((__bridge <span class="keyword">id</span>)item) == YAKeyValueObservationInfoKey.class) &#123;</span><br><span class="line">        YAKeyValueObservationInfoKey *key = (__bridge YAKeyValueObservationInfoKey *)item;</span><br><span class="line">        <span class="keyword">return</span> key.baseObservationInfo.observances.firstObject.hash;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        YAKeyValueObservationInfo *info = (__bridge YAKeyValueObservationInfo *)item;</span><br><span class="line">        <span class="keyword">return</span> info.observances.firstObject.hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> YAKeyValueObservationInfoNSHTIsEqual(<span class="keyword">const</span> <span class="keyword">void</span> *item1, <span class="keyword">const</span> <span class="keyword">void</span> *item2, <span class="built_in">NSUInteger</span> (* size)(<span class="keyword">const</span> <span class="keyword">void</span> * item)) &#123;</span><br><span class="line">    <span class="comment">// 这里仅仅写了YAKeyValueObservationInfoKey与YAKeyValueObservationInfo的比较</span></span><br><span class="line">    <span class="keyword">if</span> (object_getClass((__bridge <span class="keyword">id</span>)item1) == YAKeyValueObservationInfoKey.class || object_getClass((__bridge <span class="keyword">id</span>)item2) == YAKeyValueObservationInfoKey.class) &#123;</span><br><span class="line">        YAKeyValueObservationInfo *info = <span class="literal">nil</span>;</span><br><span class="line">        YAKeyValueObservationInfoKey *key = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确定哪一个是info, 哪一个是key</span></span><br><span class="line">        <span class="keyword">if</span> (object_getClass((__bridge <span class="keyword">id</span>)item1) == YAKeyValueObservationInfoKey.class) &#123;</span><br><span class="line">            info = (__bridge YAKeyValueObservationInfo *)item2;</span><br><span class="line">            key = (__bridge YAKeyValueObservationInfoKey *)item1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            info = (__bridge YAKeyValueObservationInfo *)item1;</span><br><span class="line">            key = (__bridge YAKeyValueObservationInfoKey *)item2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSArray</span> &lt;YAKeyValueObservance *&gt; *observancesInKey = key.baseObservationInfo.observances;</span><br><span class="line">        <span class="built_in">NSArray</span> &lt;YAKeyValueObservance *&gt; *observancesInInfo = info.observances;</span><br><span class="line">        <span class="comment">// key中observance的数量</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> countInkey = observancesInKey.count;</span><br><span class="line">        <span class="comment">// info中observance的数量</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> countInInfo = observancesInInfo.count;</span><br><span class="line">        <span class="keyword">if</span> (countInkey != countInInfo) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; countInkey; i++) &#123;</span><br><span class="line">            <span class="comment">// 保证每个observance完全匹配</span></span><br><span class="line">            <span class="keyword">if</span> (observancesInKey[i] != observancesInInfo[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Public methods</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span>(<span class="title">YAKVO</span>)</span></span><br><span class="line"><span class="built_in">CFMutableDictionaryRef</span> YAKeyValueObservationInfoPerObject = <span class="literal">NULL</span>;</span><br><span class="line">- (<span class="keyword">void</span> *)ya_observationInfo &#123;</span><br><span class="line">    <span class="keyword">return</span> YAKeyValueObservationInfoPerObject ? (<span class="keyword">void</span> *)<span class="built_in">CFDictionaryGetValue</span>(YAKeyValueObservationInfoPerObject, OBSERVATION_INFO_KEY(<span class="keyword">self</span>)) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setYa_observationInfo:(<span class="keyword">void</span> *)info &#123;</span><br><span class="line">    <span class="keyword">if</span> (!YAKeyValueObservationInfoPerObject) &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryValueCallBacks</span> callbacks = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        callbacks.version = kCFTypeDictionaryKeyCallBacks.version;</span><br><span class="line">        callbacks.retain = kCFTypeDictionaryKeyCallBacks.retain;</span><br><span class="line">        callbacks.release = kCFTypeDictionaryKeyCallBacks.release;</span><br><span class="line">        callbacks.copyDescription = kCFTypeDictionaryKeyCallBacks.copyDescription;</span><br><span class="line">        YAKeyValueObservationInfoPerObject = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;callbacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info) &#123;</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(YAKeyValueObservationInfoPerObject, OBSERVATION_INFO_KEY(<span class="keyword">self</span>), info);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryRemoveValue</span>(YAKeyValueObservationInfoPerObject, OBSERVATION_INFO_KEY(<span class="keyword">self</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ya_willChangeValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!YAKeyValueChangeDictionary) &#123;</span><br><span class="line">        YAKeyValueChangeDictionary = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">id</span> oldValue = <span class="literal">nil</span>;</span><br><span class="line">    oldValue = [<span class="keyword">self</span> valueForKeyPath:key];</span><br><span class="line">    <span class="keyword">if</span> (!oldValue) oldValue = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    [YAKeyValueChangeDictionary setObject:oldValue forKey:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p-old"</span>, <span class="keyword">self</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ya_didChangeValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ya_isKVOClass) &#123;</span><br><span class="line">        YAKeyValueProperty *property = getKeyValueProperty(<span class="keyword">self</span>.class, key);</span><br><span class="line">        YAKeyValueObservationInfo *observation = <span class="keyword">self</span>.ya_observationInfo;</span><br><span class="line">        [observation.observances enumerateObjectsUsingBlock:^(YAKeyValueObservance *obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([obj.property isEqual:property]) &#123;</span><br><span class="line">                <span class="built_in">NSMutableDictionary</span> *change = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">                <span class="keyword">if</span> (obj.options &amp; <span class="built_in">NSKeyValueObservingOptionOld</span>) &#123;</span><br><span class="line">                    <span class="keyword">id</span> old = [YAKeyValueChangeDictionary objectForKey:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p-old"</span>, <span class="keyword">self</span>]];</span><br><span class="line">                    [change setObject:old forKey:<span class="string">@"old"</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    [YAKeyValueChangeDictionary removeObjectForKey:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p-old"</span>, <span class="keyword">self</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (obj.options &amp; <span class="built_in">NSKeyValueObservingOptionNew</span>) &#123;</span><br><span class="line">                    <span class="keyword">id</span> newValue = <span class="literal">nil</span>;</span><br><span class="line">                    newValue = [<span class="keyword">self</span> valueForKeyPath:key];</span><br><span class="line">                    <span class="keyword">if</span> (!newValue) newValue = [<span class="built_in">NSNull</span> null];</span><br><span class="line">                    [YAKeyValueChangeDictionary setObject:newValue forKey:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p-new"</span>, <span class="keyword">self</span>]];</span><br><span class="line">                    [change setObject:newValue forKey:<span class="string">@"new"</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                [obj.observer ya_observeValueForKeyPath:key ofObject:<span class="keyword">self</span> change:change context:<span class="literal">nil</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ya_addObserver:(<span class="built_in">NSObject</span> *)observer</span><br><span class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">               options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</span><br><span class="line">               context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    </span><br><span class="line">    YAKeyValueProperty *property = getKeyValueProperty(<span class="keyword">self</span>.class, keyPath);</span><br><span class="line">    YAKeyValueObservance *observance = getKeyValueObservance(property, observer, context, options);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSHashTable</span> *YAKeyValueShareableObservationInfos;</span><br><span class="line">    <span class="keyword">if</span> (!YAKeyValueShareableObservationInfos) &#123;</span><br><span class="line">        <span class="built_in">NSPointerFunctions</span> *pointerFunctions = [[<span class="built_in">NSPointerFunctions</span> alloc] initWithOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span>];</span><br><span class="line">        [pointerFunctions setHashFunction:YAKeyValueObservationInfoNSHTHash];</span><br><span class="line">        [pointerFunctions setIsEqualFunction:YAKeyValueObservationInfoNSHTIsEqual];</span><br><span class="line">        YAKeyValueShareableObservationInfos = [[<span class="built_in">NSHashTable</span> alloc] initWithPointerFunctions:pointerFunctions capacity:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> YAKeyValueObservationInfoKey *finder;</span><br><span class="line">    <span class="keyword">if</span> (!finder) &#123;</span><br><span class="line">        finder = [YAKeyValueObservationInfoKey new];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    YAKeyValueObservationInfo *info = (__bridge <span class="keyword">id</span>)[<span class="keyword">self</span> ya_observationInfo];</span><br><span class="line">    finder.baseObservationInfo = info;</span><br><span class="line">    finder.additionObserver = observer;</span><br><span class="line">    finder.additionContext = context;</span><br><span class="line">    finder.additionOptions = options;</span><br><span class="line">    finder.additionProperty = property;</span><br><span class="line">    </span><br><span class="line">    YAKeyValueObservationInfo *observation = [YAKeyValueShareableObservationInfos member:finder];</span><br><span class="line">    <span class="comment">// 重置finder数据</span></span><br><span class="line">    finder.baseObservationInfo = <span class="literal">nil</span>;</span><br><span class="line">    finder.additionObserver = <span class="literal">nil</span>;</span><br><span class="line">    finder.additionContext = <span class="literal">NULL</span>;</span><br><span class="line">    finder.additionOptions = <span class="number">0</span>;</span><br><span class="line">    finder.additionProperty = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!observation) &#123;</span><br><span class="line">        <span class="comment">// 缓存中没有找到, 创建</span></span><br><span class="line">        observation = [[YAKeyValueObservationInfo alloc] initWithObservances:@[observance] count:<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 添加到缓存中</span></span><br><span class="line">        [YAKeyValueShareableObservationInfos addObject:observation];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *buffer = [<span class="built_in">NSMutableArray</span> arrayWithArray:observation.observances];</span><br><span class="line">        [buffer addObject:observance];</span><br><span class="line">        observation.observances = [<span class="built_in">NSArray</span> arrayWithArray:buffer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.ya_observationInfo = (__bridge <span class="keyword">void</span> *)(observation);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.ya_isKVOClass) &#123;</span><br><span class="line">        Class isaForAutonotifying = [property isaForAutonotifying];</span><br><span class="line">        <span class="comment">// 更改isa指针</span></span><br><span class="line">        object_setClass(<span class="keyword">self</span>, isaForAutonotifying);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (options &amp; <span class="built_in">NSKeyValueObservingOptionInitial</span>) &#123;</span><br><span class="line">        <span class="keyword">id</span> newValue = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (options &amp; <span class="built_in">NSKeyValueObservingOptionNew</span>) &#123;</span><br><span class="line">            newValue = [<span class="keyword">self</span> valueForKeyPath:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!newValue) newValue = [<span class="built_in">NSNull</span> null]; <span class="comment">// 使用NSNull对象</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *change = @&#123;<span class="string">@"new"</span>: newValue&#125;;</span><br><span class="line">        [observer ya_observeValueForKeyPath:keyPath ofObject:<span class="keyword">self</span> change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ya_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ya_isKVOClass) &#123;</span><br><span class="line">        YAKeyValueProperty *property = getKeyValueProperty(<span class="keyword">self</span>.class, keyPath);</span><br><span class="line">        YAKeyValueObservationInfo *observation = <span class="keyword">self</span>.ya_observationInfo;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *diff = [<span class="built_in">NSMutableArray</span> arrayWithArray:observation.observances];</span><br><span class="line">        __block <span class="built_in">NSInteger</span> removeIdx = <span class="number">-1</span>;</span><br><span class="line">        [diff enumerateObjectsUsingBlock:^(YAKeyValueObservance *obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([obj.property isEqual:property] &amp;&amp; obj.observer == observer &amp;&amp; obj.context == context) &#123;</span><br><span class="line">                removeIdx = idx;</span><br><span class="line">                *stop = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">if</span> (removeIdx != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到需要移除的元素</span></span><br><span class="line">            [diff removeObjectAtIndex:removeIdx];</span><br><span class="line">            observation.observances = [<span class="built_in">NSArray</span> arrayWithArray:diff];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ya_observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123;&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="功能check"><a href="#功能check" class="headerlink" title="功能check"></a>功能check</h2><p>1.添加观察者与设置回调：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> [<span class="keyword">self</span>.obj ya_addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="string">"NULL"</span>];</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)ya_observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, change);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.obj.name = <span class="string">@"Aaron"</span>;</span><br><span class="line"><span class="keyword">self</span>.obj.name = <span class="string">@"Jack"</span>;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">2019<span class="string">-05</span><span class="string">-30</span> 09:41:23.595046<span class="string">+0800</span> Aaron[24893:604622] &#123;</span><br><span class="line">    new = Aaron;</span><br><span class="line">    old = "&lt;null&gt;";</span><br><span class="line">&#125;</span><br><span class="line">2019<span class="string">-05</span><span class="string">-30</span> 09:41:23.595215<span class="string">+0800</span> Aaron[24893:604622] &#123;</span><br><span class="line">    new = Jack;</span><br><span class="line">    old = Aaron;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用NSKeyValueObservingOptionInitial</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[self.obj <span class="string">ya_addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"name"</span> <span class="string">options:</span>NSKeyValueObservingOptionInitial <span class="string">context:</span><span class="string">"NULL"</span>];</span><br><span class="line">self.obj.name = @<span class="string">"Aaron"</span>;</span><br></pre></td></tr></table></figure><p>打印<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-05</span><span class="number">-30</span> <span class="number">09</span>:<span class="type">45</span>:<span class="number">01.717131</span>+<span class="number">0800</span> Aaron[<span class="number">25010</span>:<span class="type">609398</span>] &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type"></span>= <span class="string">"&lt;null&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.多次添加观察者</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[self.obj <span class="string">ya_addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"name"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span><span class="string">"NULL"</span>];</span><br><span class="line">[self.obj <span class="string">ya_addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"name"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span><span class="string">"NULL"</span>];</span><br><span class="line">[self.obj <span class="string">ya_addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"name"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span><span class="string">"NULL"</span>];</span><br><span class="line">self.obj.name = @<span class="string">"Aaron"</span>;</span><br></pre></td></tr></table></figure><p>打印</p><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">2019<span class="string">-05</span><span class="string">-30</span> 09:47:20.625826<span class="string">+0800</span> Aaron[25107:613531] &#123;</span><br><span class="line">    new = Aaron;</span><br><span class="line">&#125;</span><br><span class="line">2019<span class="string">-05</span><span class="string">-30</span> 09:47:20.625992<span class="string">+0800</span> Aaron[25107:613531] &#123;</span><br><span class="line">    new = Aaron;</span><br><span class="line">&#125;</span><br><span class="line">2019<span class="string">-05</span><span class="string">-30</span> 09:47:20.626128<span class="string">+0800</span> Aaron[25107:613531] &#123;</span><br><span class="line">    new = Aaron;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的代码放到了github上：<a href="https://github.com/ChenYalun/Project/tree/master/KVO" target="_blank" rel="noopener">https://github.com/ChenYalun/Project/tree/master/KVO</a></p><h1 id="七、小结"><a href="#七、小结" class="headerlink" title="七、小结"></a>七、小结</h1><p>这里学到一个技巧：如何确认<code>NSUserDefaults</code>中某个key是否存在?</p><p>比如</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">BOOL result</span> = [NSUserDefaults.standardUserDefaults boolForKey:@<span class="string">"key"</span>];</span><br></pre></td></tr></table></figure><p>当result为NO时，怎么判断是存储键<code>@&quot;key&quot;</code>对应的value是NO，还是说压根就没有存过这个key呢?可以使用<code>CFPreferencesGetAppBooleanValue()</code>函数。<br>KVO中有这么一段代码:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> keyExistsAndHasValidFormat = <span class="literal">false</span>; <span class="comment">// key是否存在</span></span><br><span class="line"><span class="built_in">BOOL</span> cleansUpBeforeThrowing = <span class="literal">false</span>; <span class="comment">// 存储的值为YES或者NO</span></span><br><span class="line"></span><br><span class="line">cleansUpBeforeThrowing = (<span class="built_in">BOOL</span>)<span class="built_in">CFPreferencesGetAppBooleanValue</span>(<span class="built_in">CFSTR</span>(<span class="string">"key"</span>), kCFPreferencesCurrentApplication, (Boolean *)&amp;keyExistsAndHasValidFormat);</span><br><span class="line"><span class="comment">// 能判断出key存在</span></span><br><span class="line">cleansUpBeforeThrowing = cleansUpBeforeThrowing &amp;&amp; keyExistsAndHasValidFormat;</span><br></pre></td></tr></table></figure><p>好了，说正题，本文简单总结了KVO的原理，并尝试阅读源码，然而能力有限、时间有限，只能明白个大概。在应用场景方面，就是“观察”，实际开发中，监听UIScrollView（及其子类）的属性比较多。最后，给自己挖了个坑：<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>为什么要成对出现？哪天有时间了，再仔细看一看。</p><hr><p>KVO的源码来自：<a href="https://github.com/renjinkui2719/DIS_KVC_KVO" target="_blank" rel="noopener">https://github.com/renjinkui2719/DIS_KVC_KVO</a> 。感谢作者。</p><blockquote><p>参考文章<br><a href="http://southpeak.github.io/2015/04/23/cocoa-foundation-nskeyvalueobserving/" target="_blank" rel="noopener">Foundation: NSKeyValueObserving(KVO)</a><br><a href="https://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="noopener">如何自己动手实现 KVO</a><br><a href="https://knightsj.github.io/2017/05/15/使用Block实现KVO/" target="_blank" rel="noopener">使用Block实现KVO</a><br><a href="https://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/" target="_blank" rel="noopener">objc kvo简单探索</a><br><a href="http://chuquan.me/2018/12/12/kvo-principle/" target="_blank" rel="noopener">KVO 原理详解</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; KVO源码阅读。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>详解Key-Value Coding源码</title>
    <link href="http://blog.chenyalun.com/2019/05/05/%E8%AF%A6%E8%A7%A3Key-Value%20Coding%E6%BA%90%E7%A0%81/"/>
    <id>http://blog.chenyalun.com/2019/05/05/详解Key-Value Coding源码/</id>
    <published>2019-05-05T12:12:24.000Z</published>
    <updated>2019-09-17T03:32:29.747Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> KVC源码阅读。 </p><br><a id="more"></a><p></p><h1 id="一、接口"><a href="#一、接口" class="headerlink" title="一、接口"></a>一、接口</h1><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">NSKeyValueCoding</span>)</span></span><br><span class="line"><span class="comment">// 是否可以直接访问实例变量(实例变量访问开关, 默认YES)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> accessInstanceVariablesDirectly;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过key访问</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">// 尝试验证将要设定的value(ioValue指针指向的对象)是否合理有效</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> _Nullable * _Nonnull)ioValue forKey:(<span class="built_in">NSString</span> *)inKey error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br><span class="line"><span class="comment">// 获取相对应的精确容器类型</span></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="built_in">NSMutableSet</span> *)mutableSetValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过keyPath访问</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> _Nullable * _Nonnull)ioValue forKeyPath:(<span class="built_in">NSString</span> *)inKeyPath error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="built_in">NSMutableSet</span> *)mutableSetValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找key失败默认抛出异常, 可重写自行实现</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">// 设置value失败默认抛出异常, 可重写自行实现</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">// 设置value为nil时抛出异常, 可重写自行实现</span></span><br><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">// 传入key数组, 返回一个成员变量名和变量值的键值对组成的字典(可用于模型转字典)</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line"><span class="comment">// 字典转模型</span></span><br><span class="line">- (<span class="keyword">void</span>)setValuesForKeysWithDictionary:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)keyedValues;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 容器扩展</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span>&lt;<span class="title">ObjectType</span>&gt;(<span class="title">NSKeyValueCoding</span>)</span></span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDictionary</span>&lt;<span class="title">KeyType</span>, <span class="title">ObjectType</span>&gt;(<span class="title">NSKeyValueCoding</span>)</span></span><br><span class="line">- (<span class="keyword">nullable</span> ObjectType)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSMutableDictionary</span>&lt;<span class="title">KeyType</span>, <span class="title">ObjectType</span>&gt;(<span class="title">NSKeyValueCoding</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> ObjectType)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSSet</span>&lt;<span class="title">ObjectType</span>&gt;(<span class="title">NSKeyValueCoding</span>)</span></span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSOrderedSet</span>&lt;<span class="title">ObjectType</span>&gt;(<span class="title">NSKeyValueCoding</span>)</span></span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="集合代理对象"><a href="#集合代理对象" class="headerlink" title="集合代理对象"></a>集合代理对象</h2><p>这里简单总结集合代理对象的使用。</p><blockquote><p>当我们在对象上调用 <code>-valueForKey:</code> 的时候，它可以返回 <code>NSArray</code>，<code>NSSet</code> 或是 <code>NSOrderedSet</code> 的集合代理对象。这个类没有实现通常的 <code>-&lt;Key&gt;</code> 方法，但是它实现了代理对象所需要使用的很多方法。</p></blockquote><h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Primes</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *primes;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Primes</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> primes; <span class="comment">// 不要生成get方法</span></span><br><span class="line"><span class="keyword">static</span> int32_t <span class="keyword">const</span> primes[] = &#123;</span><br><span class="line">    <span class="number">2</span>, <span class="number">101</span>, <span class="number">233</span>, <span class="number">383</span>, <span class="number">3</span>, <span class="number">103</span>, <span class="number">239</span>, <span class="number">389</span>, <span class="number">5</span>, <span class="number">107</span>, <span class="number">241</span>, <span class="number">397</span>, <span class="number">7</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">251</span>, <span class="number">401</span>, <span class="number">11</span>, <span class="number">113</span>, <span class="number">257</span>, <span class="number">409</span>, <span class="number">13</span>, <span class="number">127</span>, <span class="number">263</span>, <span class="number">419</span>, <span class="number">17</span>, <span class="number">131</span>, <span class="number">269</span>,</span><br><span class="line">    <span class="number">421</span>, <span class="number">19</span>, <span class="number">137</span>, <span class="number">271</span>, <span class="number">431</span>, <span class="number">23</span>, <span class="number">139</span>, <span class="number">277</span>, <span class="number">433</span>, <span class="number">29</span>, <span class="number">149</span>, <span class="number">281</span>, <span class="number">439</span>,</span><br><span class="line">    <span class="number">31</span>, <span class="number">151</span>, <span class="number">283</span>, <span class="number">443</span>, <span class="number">37</span>, <span class="number">157</span>, <span class="number">293</span>, <span class="number">449</span>, <span class="number">41</span>, <span class="number">163</span>, <span class="number">307</span>, <span class="number">457</span>, <span class="number">43</span>,</span><br><span class="line">    <span class="number">167</span>, <span class="number">311</span>, <span class="number">461</span>, <span class="number">47</span>, <span class="number">173</span>, <span class="number">313</span>, <span class="number">463</span>, <span class="number">53</span>, <span class="number">179</span>, <span class="number">317</span>, <span class="number">467</span>, <span class="number">59</span>, <span class="number">181</span>,</span><br><span class="line">    <span class="number">331</span>, <span class="number">479</span>, <span class="number">61</span>, <span class="number">191</span>, <span class="number">337</span>, <span class="number">487</span>, <span class="number">67</span>, <span class="number">193</span>, <span class="number">347</span>, <span class="number">491</span>, <span class="number">71</span>, <span class="number">197</span>, <span class="number">349</span>,</span><br><span class="line">    <span class="number">499</span>, <span class="number">73</span>, <span class="number">199</span>, <span class="number">353</span>, <span class="number">503</span>, <span class="number">79</span>, <span class="number">211</span>, <span class="number">359</span>, <span class="number">509</span>, <span class="number">83</span>, <span class="number">223</span>, <span class="number">367</span>, <span class="number">521</span>,</span><br><span class="line">    <span class="number">89</span>, <span class="number">227</span>, <span class="number">373</span>, <span class="number">523</span>, <span class="number">97</span>, <span class="number">229</span>, <span class="number">379</span>, <span class="number">541</span>, <span class="number">547</span>, <span class="number">701</span>, <span class="number">877</span>, <span class="number">1049</span>,</span><br><span class="line">    <span class="number">557</span>, <span class="number">709</span>, <span class="number">881</span>, <span class="number">1051</span>, <span class="number">563</span>, <span class="number">719</span>, <span class="number">883</span>, <span class="number">1061</span>, <span class="number">569</span>, <span class="number">727</span>, <span class="number">887</span>,</span><br><span class="line">    <span class="number">1063</span>, <span class="number">571</span>, <span class="number">733</span>, <span class="number">907</span>, <span class="number">1069</span>, <span class="number">577</span>, <span class="number">739</span>, <span class="number">911</span>, <span class="number">1087</span>, <span class="number">587</span>, <span class="number">743</span>,</span><br><span class="line">    <span class="number">919</span>, <span class="number">1091</span>, <span class="number">593</span>, <span class="number">751</span>, <span class="number">929</span>, <span class="number">1093</span>, <span class="number">599</span>, <span class="number">757</span>, <span class="number">937</span>, <span class="number">1097</span>, <span class="number">601</span>,</span><br><span class="line">    <span class="number">761</span>, <span class="number">941</span>, <span class="number">1103</span>, <span class="number">607</span>, <span class="number">769</span>, <span class="number">947</span>, <span class="number">1109</span>, <span class="number">613</span>, <span class="number">773</span>, <span class="number">953</span>, <span class="number">1117</span>,</span><br><span class="line">    <span class="number">617</span>, <span class="number">787</span>, <span class="number">967</span>, <span class="number">1123</span>, <span class="number">619</span>, <span class="number">797</span>, <span class="number">971</span>, <span class="number">1129</span>, <span class="number">631</span>, <span class="number">809</span>, <span class="number">977</span>,</span><br><span class="line">    <span class="number">1151</span>, <span class="number">641</span>, <span class="number">811</span>, <span class="number">983</span>, <span class="number">1153</span>, <span class="number">643</span>, <span class="number">821</span>, <span class="number">991</span>, <span class="number">1163</span>, <span class="number">647</span>, <span class="number">823</span>,</span><br><span class="line">    <span class="number">997</span>, <span class="number">1171</span>, <span class="number">653</span>, <span class="number">827</span>, <span class="number">1009</span>, <span class="number">1181</span>, <span class="number">659</span>, <span class="number">829</span>, <span class="number">1013</span>, <span class="number">1187</span>, <span class="number">661</span>,</span><br><span class="line">    <span class="number">839</span>, <span class="number">1019</span>, <span class="number">1193</span>, <span class="number">673</span>, <span class="number">853</span>, <span class="number">1021</span>, <span class="number">1201</span>, <span class="number">677</span>, <span class="number">857</span>, <span class="number">1031</span>,</span><br><span class="line">    <span class="number">1213</span>, <span class="number">683</span>, <span class="number">859</span>, <span class="number">1033</span>, <span class="number">1217</span>, <span class="number">691</span>, <span class="number">863</span>, <span class="number">1039</span>, <span class="number">1223</span>, <span class="number">1229</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)countOfPrimes &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">sizeof</span>(primes) / <span class="keyword">sizeof</span>(*primes));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectInPrimesAtIndex:(<span class="built_in">NSUInteger</span>)idx &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(idx &lt; <span class="keyword">sizeof</span>(primes) / <span class="keyword">sizeof</span>(*primes));</span><br><span class="line">    <span class="keyword">return</span> @(primes[idx]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对于NSArray， 实现<code>-countOf&lt;Key&gt;</code>方法，<code>-objectIn&lt;Key&gt;AtIndex:</code>或者<code>-&lt;key&gt;AtIndexes:</code>中的一个即可，当然如果再实现<code>-get&lt;Key&gt;:range:</code>将会增强性能。</p><p>上面的例子中，key是“primes”，实际上并没有这个primes数组，而是用了一个C数组代理了。<code>@property (nonatomic, copy, readonly) NSArray *primes;</code>和<code>@dynamic primes;</code> 这两句话可以省略（下文的例子就省略了），这里加上的原因是，便于外界知晓具体的key值。</p><p>使用：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">Primes *primes = [Primes <span class="keyword">new</span>];</span><br><span class="line"><span class="regexp">//</span> obj <span class="keyword">is</span> kind <span class="keyword">of</span> <span class="class"><span class="keyword">class</span> '<span class="title">NSKeyValueArray</span>'</span></span><br><span class="line">id obj = [primes valueForKey:@<span class="string">"primes"</span>];</span><br></pre></td></tr></table></figure><p>可见，获得的对象并不是一个NSArray，而是<code>NSKeyValueArray</code>。</p><h3 id="NSSet"><a href="#NSSet" class="headerlink" title="NSSet"></a>NSSet</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PrimesSet</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PrimesSet</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSSet</span> *_numSet;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _numSet = [<span class="built_in">NSSet</span> setWithObjects:@<span class="number">0</span>, @<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, <span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)countOfPrimes &#123;</span><br><span class="line">    <span class="keyword">return</span> _numSet.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSEnumerator</span> *)enumeratorOfPrimes &#123;</span><br><span class="line">    <span class="keyword">return</span> _numSet.objectEnumerator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)memberOfPrimes:(<span class="keyword">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">return</span> [_numSet member:obj];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对于NSSet，要实现<code>-countOf&lt;Key&gt;</code>、<code>-enumeratorOf&lt;Key&gt;</code>和<code>-memberOf&lt;Key&gt;:</code>这三个方法。</p><p>使用：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">PrimesSet *primesSet = [PrimesSet <span class="keyword">new</span>];</span><br><span class="line"><span class="regexp">//</span> obj <span class="keyword">is</span> kind <span class="keyword">of</span> <span class="class"><span class="keyword">class</span> '<span class="title">NSKeyValueSet</span>'</span></span><br><span class="line">id obj = [primesSet valueForKey:@<span class="string">"primes"</span>];</span><br></pre></td></tr></table></figure><p>获取到的对象是<code>NSKeyValueSet</code>。</p><h3 id="NSOrderedSet"><a href="#NSOrderedSet" class="headerlink" title="NSOrderedSet"></a>NSOrderedSet</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PrimesOrderedSet</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PrimesOrderedSet</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSOrderedSet</span> *_numOrderedSet;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _numOrderedSet = [<span class="built_in">NSOrderedSet</span> orderedSetWithObjects:@<span class="number">0</span>, @<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, <span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)countOfPrimes &#123;</span><br><span class="line">    <span class="keyword">return</span> _numOrderedSet.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)indexInPrimesOfObject:(<span class="keyword">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">return</span> [_numOrderedSet indexOfObject:obj];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectInPrimesAtIndex:(<span class="built_in">NSUInteger</span>)idx &#123;</span><br><span class="line">    <span class="keyword">return</span> [_numOrderedSet objectAtIndex:idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于提高性能</span></span><br><span class="line">- (<span class="keyword">void</span>)getPrimes:(<span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> *)buffer range:(<span class="built_in">NSRange</span>)inRange &#123;</span><br><span class="line">    <span class="comment">// 返回提供的缓冲区内指定范围内的数据集合</span></span><br><span class="line">    [_numOrderedSet getObjects:buffer range:inRange];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>必须实现的方法是<code>-countOf&lt;Key&gt;</code>和<code>-indexIn&lt;Key&gt;OfObject:</code>。二选一实现的方法是<code>-objectIn&lt;Key&gt;AtIndex:</code>和<code>-&lt;key&gt;AtIndexes:</code>。如果再实现<code>-get&lt;Key&gt;:range:</code>将会增强性能。</p><p>使用：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">PrimesOrderedSet *primesOrderedSet = [PrimesOrderedSet <span class="keyword">new</span>];</span><br><span class="line"><span class="regexp">//</span> obj <span class="keyword">is</span> kind <span class="keyword">of</span> <span class="class"><span class="keyword">class</span> '<span class="title">NSKeyValueOrderedSet</span>'</span></span><br><span class="line">id obj = [primesOrderedSet valueForKey:@<span class="string">"primes"</span>];</span><br></pre></td></tr></table></figure><p>获取到的对象是<code>NSKeyValueOrderedSet</code>。</p><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>数组最大值：</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">NSArray <span class="symbol">*</span>array = <span class="meta">@[</span><span class="meta">@1,</span> <span class="meta">@8,</span> <span class="meta">@5];</span></span><br><span class="line">[array valueForKeyPath:<span class="meta">@"</span><span class="meta">@max.self"];</span></span><br></pre></td></tr></table></figure><p>模型数组最大值：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">NSArray *<span class="keyword">array</span> = @[person1, person2, person3];</span><br><span class="line">[<span class="keyword">array</span> valueForKeyPath:@<span class="string">"@max.age"</span>];</span><br></pre></td></tr></table></figure><p>其他操作符：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@max</span> <span class="variable">@min</span>: 获得数组中最大(或者最小)的一个元素</span><br><span class="line"><span class="variable">@avg</span>: 将集合中对象转换成double类型，返回数组中指定的平均值的number对象</span><br><span class="line"><span class="variable">@sum</span>: 将集合中每个对象都转换成double类型，然后计算总和，最后返回一个值为这个总和的NSNumber对象</span><br><span class="line"><span class="variable">@count</span>：返回集合中对象总数的NSNumber对象</span><br><span class="line"></span><br><span class="line">返回一个由操作符右边的key path指定的对象属性组成的数组，distincUnionOfObjects会对数组去重。</span><br><span class="line">示例：</span><br><span class="line">[personList <span class="attribute">valueForKeyPath</span>:@<span class="string">"@unionOfObjects.name"</span>];</span><br><span class="line"><span class="selector-attr">[personList valueForKeyPath:@"@distinctUnionOfObjects.name"]</span>;</span><br><span class="line">操作对象：<span class="variable">@unionOfObjects</span>/<span class="variable">@distincUnionOfObjects</span> </span><br><span class="line">操作数组：<span class="variable">@distinctUnionOfArrays</span>/<span class="variable">@unionOfArrays</span></span><br><span class="line">操作集合：<span class="variable">@distinctUnionOfSets</span> 和<span class="variable">@distinctUnionOfArrays</span></span><br></pre></td></tr></table></figure><h2 id="分类的KVC"><a href="#分类的KVC" class="headerlink" title="分类的KVC"></a>分类的KVC</h2><p>一般的场景是这样：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Portion</span> :  <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Portion</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Portion</span> (<span class="title">PrimitiveAccessors</span>)</span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *)primitiveVolume;</span><br><span class="line">- (<span class="keyword">void</span>)setPrimitiveVolume:(<span class="built_in">NSNumber</span> *)value;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Portion</span> (<span class="title">PrimitiveAccessors</span>)</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSNumber</span> *gVolume;</span><br><span class="line">- (<span class="built_in">NSNumber</span> *)primitiveVolume &#123;</span><br><span class="line">    <span class="keyword">return</span> gVolume;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setPrimitiveVolume:(<span class="built_in">NSNumber</span> *)value &#123;</span><br><span class="line">    gVolume = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对于主类中没有的key，分类实现特定的方法后，KVC也将会生效。如果是取值，分类必须实现这样的方法：<code>getPrimitive&lt;key&gt;</code>或者<code>primitive&lt;key&gt;</code>。上面的例子中，key是volume。如果是设值，分类必须实现<code>setPrimitive&lt;key&gt;:</code>方法。</p><p>使用：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Portion *p = [Portion <span class="keyword">new</span>];</span><br><span class="line">[p <span class="string">setValue:</span>@<span class="number">234</span> <span class="string">forKey:</span>@<span class="string">"volume"</span>];</span><br><span class="line">id m = [p <span class="string">valueForKey:</span>@<span class="string">"volume"</span>];</span><br></pre></td></tr></table></figure><p>当然，本质上来讲，KVC并不介意这些方法在主类还是分类实现的，只要有实现就成。上面的只是一个例子，实际上，完全依靠主类也是无妨的。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Portion</span> :  <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *)primitiveVolume;</span><br><span class="line">- (<span class="keyword">void</span>)setPrimitiveVolume:(<span class="built_in">NSNumber</span> *)value;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Portion</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSNumber</span> *gVolume;</span><br><span class="line">- (<span class="built_in">NSNumber</span> *)primitiveVolume &#123;</span><br><span class="line">    <span class="keyword">return</span> gVolume;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setPrimitiveVolume:(<span class="built_in">NSNumber</span> *)value &#123;</span><br><span class="line">    gVolume = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="二、取值"><a href="#二、取值" class="headerlink" title="二、取值"></a>二、取值</h1><h2 id="valueForKey"><a href="#valueForKey" class="headerlink" title="valueForKey:"></a>valueForKey:</h2><p>苹果在接口这里已经给出了其基本原理：</p><blockquote><p>The default implementation of this method does the following:</p><ol><li><p>Searches the class of the receiver for an accessor method whose name matches the pattern <code>-get&lt;Key&gt;, -&lt;key&gt;, or -is&lt;Key&gt;</code>, in that order. If such a method is found it is invoked. If the type of the method’s result is an object pointer type the result is simply returned. If the type of the result is one of the scalar types supported by NSNumber conversion is done and an NSNumber is returned. Otherwise, conversion is done and an NSValue is returned (new in Mac OS 10.5: results of arbitrary type are converted to NSValues, not just NSPoint, NRange, NSRect, and NSSize).</p></li><li><p>(introduced in Mac OS 10.7). Otherwise (no simple accessor method is found), searches the class of the receiver for methods whose names match the patterns <code>-countOf&lt;Key&gt; and -indexIn&lt;Key&gt;OfObject: and -objectIn&lt;Key&gt;AtIndex:</code>(corresponding to the primitive methods defined by the NSOrderedSet class) and also <code>-&lt;key&gt;AtIndexes:</code> (corresponding to -[NSOrderedSet objectsAtIndexes:]). If a count method and an indexOf method and at least one of the other two possible methods are found, a collection proxy object that responds to all NSOrderedSet methods is returned. Each NSOrderedSet message sent to the collection proxy object will result in some combination of<code>-countOf&lt;Key&gt;, -indexIn&lt;Key&gt;OfObject:, -objectIn&lt;Key&gt;AtIndex:, and -&lt;key&gt;AtIndexes:</code> messages being sent to the original receiver of <code>-valueForKey:</code>. If the class of the receiver also implements an optional method whose name matches the pattern -get<key>:range: that method will be used when appropriate for best performance.</key></p></li></ol><ol start="3"><li><p>Otherwise (no simple accessor method or set of ordered set access methods is found), searches the class of the receiver for methods whose names match the patterns <code>-countOf&lt;Key&gt; and -objectIn&lt;Key&gt;AtIndex:</code>(corresponding to the primitive methods defined by the NSArray class) and (introduced in Mac OS 10.4) also<code>-&lt;key&gt;AtIndexes:</code>(corresponding to -[NSArray objectsAtIndexes:]). If a count method and at least one of the other two possible methods are found, a collection proxy object that responds to all NSArray methods is returned. Each NSArray message sent to the collection proxy object will result in some combination of <code>-countOf&lt;Key&gt;, -objectIn&lt;Key&gt;AtIndex:, and -&lt;key&gt;AtIndexes:</code> messages being sent to the original receiver of <code>-valueForKey:</code>. If the class of the receiver also implements an optional method whose name matches the pattern <code>-get&lt;Key&gt;:range:</code> that method will be used when appropriate for best performance.</p></li><li><p>(introduced in Mac OS 10.4). Otherwise (no simple accessor method or set of ordered set or array access methods is found), searches the class of the receiver for a threesome of methods whose names match the patterns <code>-countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, and -memberOf&lt;Key&gt;:</code> (corresponding to the primitive methods defined by the NSSet class). If all three such methods are found a collection proxy object that responds to all NSSet methods is returned. Each NSSet message sent to the collection proxy object will result in some combination of <code>-countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, and -memberOf&lt;Key&gt;:</code>messages being sent to the original receiver of <code>-valueForKey:</code>.</p></li><li><p>Otherwise (no simple accessor method or set of collection access methods is found), if the receiver’s class’ +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern <code>_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;</code>, in that order. If such an instance variable is found, the value of the instance variable in the receiver is returned, with the same sort of conversion to NSNumber or NSValue as in step 1.</p></li><li><p>Otherwise (no simple accessor method, set of collection access methods, or instance variable is found), invokes <code>-valueForUndefinedKey:</code> and returns the result. The default implementation of <code>-valueForUndefinedKey:</code> raises an NSUndefinedKeyException, but you can override it in your application.</p></li></ol><p>Compatibility notes:</p><ul><li>For backward binary compatibility, an accessor method whose name matches the pattern <code>-_get&lt;Key&gt;</code>, or <code>-_&lt;key&gt;</code> is searched for between steps 1 and 3. If such a method is found it is invoked, with the same sort of conversion to NSNumber or NSValue as in step 1. KVC accessor methods whose names start with underscores were deprecated as of Mac OS 10.3 though.</li><li>The behavior described in step 5 is a change from Mac OS 10.2, in which the instance variable search order was <code>&lt;key&gt;, _&lt;key&gt;</code>.</li><li>For backward binary compatibility, <code>-handleQueryWithUnboundKey:</code> will be invoked instead of <code>-valueForUndefinedKey:</code> in step 6, if the implementation of <code>-handleQueryWithUnboundKey:</code> in the receiver’s class is not NSObject’s.</li></ul></blockquote><p>简单翻译如下：</p><ol><li>按照<code>-get&lt;Key&gt;, -&lt;key&gt;, -is&lt;Key&gt;</code>的顺序搜索该类的存取器方法，若找到，则直接调用。如果方法调用的结果是<code>id</code>类型，直接把结果返回。如果方法调用的结果是能够被<code>NSNumber</code>转换的标量类型，则结果会被转为<code>NSNumber</code>返回。否则对于一般的标量类型，这些类型将会被转化为<code>NSValue</code>（在Mac OS 10.5及以后，不仅仅支持<code>NSPoint, NRange, NSRect</code>，以及<code>NSSize</code>这些类型）。</li><li>如果简单的存取器方法没有找到，那么搜索该类的<code>-countOf&lt;Key&gt;, -indexIn&lt;Key&gt;OfObject:</code>方法，还有<code>-objectIn&lt;Key&gt;AtIndex:</code>（对应被<code>NSOrderedSet</code>类所定义的方法），<code>-&lt;key&gt;AtIndexes:</code>（对应<code>-[NSOrderedSet objectsAtIndexes:]</code>）方法。如果<code>-countOf&lt;Key&gt;, -indexIn&lt;Key&gt;OfObject:</code>这两个方法被找到，另外两个方法中的至少一个被找到，那么这个能响应<code>NSOrderedSet</code>所有方法的集合代理对象会被返回。发送给原来消息接收者的<code>-valueForKey:</code>消息，将会被这个集合代理对象的<code>-countOf&lt;Key&gt;, -indexIn&lt;Key&gt;OfObject:, -objectIn&lt;Key&gt;AtIndex:, -&lt;key&gt;AtIndexes:</code>这些方法共同处理。如果这个代理对象也实现了可选的<code>-get&lt;Key&gt;:range:</code>方法，这将有助于增强性能。</li><li>如果存取器方法和<code>ordered set</code>的代理方法没有被找到，那么搜索该类的<code>-countOf&lt;Key&gt;</code>方法，还有<code>-objectIn&lt;Key&gt;AtIndex:</code>（对应被<code>NSArray</code>类所定义的方法），<code>-&lt;key&gt;AtIndexes:</code>（对应<code>-[NSArray objectsAtIndexes:]</code>）方法。如果<code>-countOf&lt;Key&gt;</code>这个方法被找到，另外两个方法中的至少一个被找到，那么这个能响应<code>NSArray</code>所有方法的集合代理对象会被返回。发送给原来消息接收者的<code>-valueForKey:</code>消息，将会被这个集合代理对象的<code>-countOf&lt;Key&gt;, -objectIn&lt;Key&gt;AtIndex:, -&lt;key&gt;AtIndexes:</code>这些方法共同处理。如果这个代理对象也实现了可选的<code>-get&lt;Key&gt;:range:</code>方法，这将有助于增强性能。</li><li>如果存取器方法、<code>ordered set</code>和<code>array</code>的代理方法都没有被找到，那么尝试搜索<code>-countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;,  -memberOf&lt;Key&gt;:</code>这些(被<code>NSSet</code>类所定义的)方法。如果这三个方法都能被找到，那么这个能响应<code>NSSet</code>所有方法的集合代理对象会被返回。发送给原来消息接收者的<code>-valueForKey:</code>消息，将会被这个集合代理对象的<code>countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;,  -memberOf&lt;Key&gt;:</code>这些方法共同处理。</li><li>如果存取器方法、<code>ordered set</code>、<code>array</code>以及<code>set</code>的代理方法都没有被找到，倘若此时消息接收者的<code>+accessInstanceVariablesDirectly</code>属性返回的是<code>YES</code>（默认实现就是返回<code>YES</code>），那么按照<code>_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;</code>的顺序搜索该类的实例变量。如果找到这个实例变量，那么按照步骤1中的类型转换规则返回这个实例变量的值。</li><li>否则(啥也没找到)，调用<code>-valueForUndefinedKey:</code>方法并返回结果。这个方法的默认实现是抛出<code>NSUndefinedKeyException</code>异常，不过你可以重写该方法自行实现。</li></ol><p>兼容性：</p><ul><li><p>为了向后兼容，会在步骤1中查找名称为<code>-_get&lt;Key&gt;,  -_&lt;key&gt;</code>的存取器方法。如果找到了，会进行调用并按照步骤1中的类型转换规则返回调用的结果。</p></li><li><p>从Mac OS 10.2开始，步骤5中的实例变量搜索顺序从原先的<code>&lt;key&gt;, _&lt;key&gt;</code>改为现在的<code>_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;</code>。</p></li><li><p>如果<code>-handleQueryWithUnboundKey:</code>的实现不是<code>NSObject</code>的默认实现（换句话说，自己手动实现了<code>-handleQueryWithUnboundKey:</code>方法），那在步骤6中，<code>-handleQueryWithUnboundKey:</code>方法将会代替<code>-valueForUndefinedKey:</code>方法被调用。</p></li></ul><p>说得清晰明了。流程图如下：</p><p><img src="https://image.chenyalun.com/2019/05/05/001.png" alt></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span>(key) &#123;</span><br><span class="line">        OSSpinLockLock(&amp;<span class="built_in">NSKeyValueCachedAccessorSpinLock</span>);</span><br><span class="line">        <span class="comment">// 创建缓存getter的CFSet集合NSKeyValueCachedGetters</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">NSKeyValueCachedGetters</span>) &#123;</span><br><span class="line">            <span class="comment">// CFSet对象需要的结构体参数, 告诉这个集合怎么管理容器中的对象</span></span><br><span class="line">            <span class="comment">// retain\release是内存管理 equal\hash是对象处理 copyDescription是复制处理</span></span><br><span class="line">            <span class="built_in">CFSetCallBacks</span> callbacks = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            callbacks.version = kCFTypeSetCallBacks.version;</span><br><span class="line">            <span class="comment">// 也可以禁用掉retain和release, 这样当对象销毁时需要及时将其从集合中移除否则会崩溃</span></span><br><span class="line">            <span class="comment">// callbacks.retain = NULL;</span></span><br><span class="line">            <span class="comment">// callbacks.release = NULL;</span></span><br><span class="line">            callbacks.retain = kCFTypeSetCallBacks.retain;</span><br><span class="line">            callbacks.release = kCFTypeSetCallBacks.release;</span><br><span class="line">            callbacks.copyDescription = kCFTypeSetCallBacks.copyDescription;</span><br><span class="line">            callbacks.equal = (<span class="built_in">CFSetEqualCallBack</span>)<span class="built_in">NSKeyValueAccessorIsEqual</span>;</span><br><span class="line">            callbacks.hash = (<span class="built_in">CFSetHashCallBack</span>)<span class="built_in">NSKeyValueAccessorHash</span>;</span><br><span class="line">            <span class="built_in">NSKeyValueCachedGetters</span> = <span class="built_in">CFSetCreateMutable</span>(<span class="literal">NULL</span>,<span class="number">0</span>,&amp;callbacks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据class、key和hash创建唯一的NSKeyValueGetter对象, 作为从缓存集合中查找的"引子"</span></span><br><span class="line">        <span class="comment">// 只要hashValue一致, 不管其他属性是否一致, 就可以判定这两个对象是一致的</span></span><br><span class="line">        <span class="comment">// 这也是为啥首先根据class和key, 创建一个"简单"的finder到缓存集合中查找的原因</span></span><br><span class="line">        <span class="built_in">NSKeyValueGetter</span> *finder = [<span class="built_in">NSKeyValueGetter</span> new];</span><br><span class="line">        finder.containerClassID = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">        finder.key = key;</span><br><span class="line">        finder.hashValue = <span class="built_in">CFHash</span>(key) ^ (<span class="built_in">NSUInteger</span>)(object_getClass(<span class="keyword">self</span>));</span><br><span class="line">        <span class="comment">// 缓存集合中是否含有特定的NSKeyValueGetter</span></span><br><span class="line">        <span class="built_in">NSKeyValueGetter</span> *<span class="keyword">getter</span> =  <span class="built_in">CFSetGetValue</span>(<span class="built_in">NSKeyValueCachedGetters</span>, finder);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">getter</span>) &#123;</span><br><span class="line">            <span class="comment">// 缓存中没有找到, 创建getter</span></span><br><span class="line">            <span class="keyword">getter</span> = [object_getClass(<span class="keyword">self</span>) _createValueGetterWithContainerClassID:object_getClass(<span class="keyword">self</span>) key:key];</span><br><span class="line">            <span class="comment">// 这里的getter相比上面的finder更加具体详细, 虽然根据哈希来说, 二者是"相同的对象"</span></span><br><span class="line">            <span class="comment">// 创建好getter后, 把它放到缓存集合中</span></span><br><span class="line">            <span class="built_in">CFSetAddValue</span>(<span class="built_in">NSKeyValueCachedGetters</span>, <span class="keyword">getter</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        OSSpinLockUnlock(&amp;<span class="built_in">NSKeyValueCachedAccessorSpinLock</span>);</span><br><span class="line">        <span class="comment">// 找到getter, 交给_NSGetUsingKeyValueGetter函数处理</span></span><br><span class="line">        <span class="keyword">return</span> _NSGetUsingKeyValueGetter(<span class="keyword">self</span>, <span class="keyword">getter</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// key为空, 抛出异常</span></span><br><span class="line">        [<span class="built_in">NSException</span> raise:<span class="built_in">NSInvalidArgumentException</span> format:<span class="string">@"%@: attempt to retrieve a value for a nil key"</span>,_NSMethodExceptionProem(<span class="keyword">self</span>,_cmd)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要做了四件事:</p><ol><li><p>取值时，使用<code>OSSpinLockLock</code>保证线程安全</p></li><li><p>根据class和key，生成一个<code>NSKeyValueGetter</code>对象，用于封装信息</p></li><li><p>取值时，会根据class和key配置一个简单的<code>Getter</code>，首先到<code>CFSet</code>缓存集合中进行查找，以提高查找速度</p></li><li><p>当<code>key</code>不存在时，直接抛出异常: 参数有误</p></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>当缓存集合中不存在时，便进入了更为具体的“查找”流程中。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 详细的查找流程(此处假定key为"name")</span></span><br><span class="line">+ (<span class="built_in">NSKeyValueGetter</span> *)_createValueGetterWithContainerClassID:(<span class="keyword">id</span>)containerClassID key:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueGetter</span> * <span class="keyword">getter</span> = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取字节长度</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> keyLen = [key lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="comment">// 这个数组用于存放首字符大写的key, 例如: "Name"</span></span><br><span class="line">    <span class="keyword">char</span> keyCStrUpFirst[keyLen + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将key转为C字符串, 存储在keyCStrUpFirst数组中</span></span><br><span class="line">    [key getCString:keyCStrUpFirst maxLength:keyLen + <span class="number">1</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">if</span> (key.length) &#123;</span><br><span class="line">        <span class="comment">// 将小写字母转为大写字母</span></span><br><span class="line">        keyCStrUpFirst[<span class="number">0</span>] = toupper(keyCStrUpFirst[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个数组用于存放与key一致的字符, 例如: "name"</span></span><br><span class="line">    <span class="keyword">char</span> keyCStr[keyLen + <span class="number">16</span>];</span><br><span class="line">    <span class="comment">// 再将key转为C字符串, 存储在keyCStr数组中</span></span><br><span class="line">    [key getCString:keyCStr maxLength:keyLen + <span class="number">1</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    Method getMethod = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查询方法指针, 使用'逻辑或'固定了默认顺序:getName==&gt;name==&gt;isName==&gt;_getName==&gt;_name</span></span><br><span class="line">    <span class="comment">// 此处证明了接口文档中的第一步</span></span><br><span class="line">    <span class="comment">// 1. Whose name matches the pattern -get&lt;Key&gt;, -&lt;key&gt;, or -is&lt;Key&gt;, in that order.</span></span><br><span class="line">    <span class="comment">// 2. For backward binary compatibility, an accessor method whose name matches the pattern -_get&lt;Key&gt;, or -_&lt;key&gt; is searched for between steps 1 and 3.</span></span><br><span class="line">    <span class="keyword">if</span>((getMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>,<span class="string">"get%s"</span>,keyCStrUpFirst)) ||</span><br><span class="line">       (getMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>,<span class="string">"%s"</span>,keyCStr)) ||</span><br><span class="line">       (getMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>,<span class="string">"is%s"</span>,keyCStrUpFirst)) ||</span><br><span class="line">       (getMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>,<span class="string">"_get%s"</span>,keyCStrUpFirst)) ||</span><br><span class="line">       (getMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>,<span class="string">"_%s"</span>,keyCStr))) &#123;</span><br><span class="line">        <span class="comment">// 成功找到, 创建NSKeyValueMethodGetter对象, 保存找到的method</span></span><br><span class="line">        <span class="keyword">getter</span> = [[<span class="built_in">NSKeyValueMethodGetter</span> alloc] initWithContainerClassID:containerClassID key:key method:getMethod];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        没有找到, 进入下个流程, 假定key为"name", 则:</span></span><br><span class="line"><span class="comment">        ountOf_Method 对应 countOfName</span></span><br><span class="line"><span class="comment">        ObjectIn_AtIndexMethod 对应 objectInNameAtIndex:</span></span><br><span class="line"><span class="comment">        _AtIndexesMethod 对应 nameAtIndexes:</span></span><br><span class="line"><span class="comment">        IndexIn_OfObjectMethod 对应 indexInNameOfObject:</span></span><br><span class="line"><span class="comment">        enumeratorOf_Method 对应 enumeratorOfName</span></span><br><span class="line"><span class="comment">        memberOf_Method 对应 memberOfName:</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method ountOf_Method = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"countOf%"</span>, keyCStrUpFirst);</span><br><span class="line">        Method ObjectIn_AtIndexMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"objectIn%sAtIndex:"</span>, keyCStrUpFirst);</span><br><span class="line">        Method _AtIndexesMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"%sAtIndexes:"</span>, keyCStr);</span><br><span class="line">        Method IndexIn_OfObjectMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"indexIn%sOfObject:"</span>, keyCStrUpFirst);</span><br><span class="line">        </span><br><span class="line">        Method enumeratorOf_Method = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"enumeratorOf%s"</span>, keyCStrUpFirst);</span><br><span class="line">        Method memberOf_Method = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"memberOf%s:"</span>, keyCStrUpFirst);</span><br><span class="line">        <span class="keyword">if</span>(ountOf_Method &amp;&amp; IndexIn_OfObjectMethod &amp;&amp; (ObjectIn_AtIndexMethod || _AtIndexesMethod)) &#123;</span><br><span class="line">            <span class="comment">// 第二步, 针对NSOrderedSet, ountOf_Method、IndexIn_OfObjectMethod，以及ObjectIn_AtIndexMethod或者_AtIndexesMethod中的一个存在(实现代理集合对象)</span></span><br><span class="line">            <span class="built_in">NSKeyValueNonmutatingOrderedSetMethodSet</span> *methodSet = [[<span class="built_in">NSKeyValueNonmutatingOrderedSetMethodSet</span> alloc] init];</span><br><span class="line">            methodSet.count =  ountOf_Method;</span><br><span class="line">            methodSet.objectAtIndex =  ObjectIn_AtIndexMethod;</span><br><span class="line">            methodSet.indexOfObject =  IndexIn_OfObjectMethod;</span><br><span class="line">            methodSet.objectsAtIndexes =  _AtIndexesMethod;</span><br><span class="line">            <span class="comment">// eg: getName:range:方法(用于增强性能)</span></span><br><span class="line">            methodSet.getObjectsRange =  <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"get%s:range:"</span>, keyCStrUpFirst);</span><br><span class="line">            <span class="comment">// NSKeyValueNonmutatingOrderedSetMethodSet就是一个拥有几个属性的简单的对象, 用于保存count、objectAtIndex等方法指针信息</span></span><br><span class="line">            <span class="comment">// 成功找到, 创建NSKeyValueCollectionGetter对象, 保存保存好的methodSet对象</span></span><br><span class="line">            <span class="keyword">getter</span> = [[<span class="built_in">NSKeyValueCollectionGetter</span> alloc] initWithContainerClassID:containerClassID key:key  methods:methodSet proxyClass:<span class="built_in">NSKeyValueOrderedSet</span>.self];</span><br><span class="line">            [methodSet release];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ountOf_Method &amp;&amp; (ObjectIn_AtIndexMethod || _AtIndexesMethod))&#123;</span><br><span class="line">            <span class="comment">// 第三步, 针对NSArray, ountOf_Method、以及ObjectIn_AtIndexMethod或者_AtIndexesMethod中的一个存在</span></span><br><span class="line">            <span class="built_in">NSKeyValueNonmutatingArrayMethodSet</span> *methodSet = [[<span class="built_in">NSKeyValueNonmutatingArrayMethodSet</span> alloc] init];</span><br><span class="line">            methodSet.count =  ountOf_Method;</span><br><span class="line">            methodSet.objectAtIndex =  ObjectIn_AtIndexMethod;</span><br><span class="line">            methodSet.objectsAtIndexes =  _AtIndexesMethod;</span><br><span class="line">            methodSet.getObjectsRange =  <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"get%s:range:"</span>, keyCStrUpFirst);</span><br><span class="line">            <span class="comment">// 同样的, 成功找到, 创建NSKeyValueCollectionGetter对象,保存methodSet</span></span><br><span class="line">            <span class="keyword">getter</span> = [[<span class="built_in">NSKeyValueCollectionGetter</span> alloc] initWithContainerClassID:containerClassID key:key  methods:methodSet proxyClass:<span class="built_in">NSKeyValueArray</span>.self];</span><br><span class="line">            [methodSet release];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ountOf_Method &amp;&amp; enumeratorOf_Method &amp;&amp; memberOf_Method)&#123;</span><br><span class="line">            <span class="comment">// 第四步, 针对NSSet, ountOf_Method、enumeratorOf_Method以及memberOf_Method</span></span><br><span class="line">            <span class="built_in">NSKeyValueNonmutatingSetMethodSet</span> *methodSet = [[<span class="built_in">NSKeyValueNonmutatingSetMethodSet</span> alloc] init];</span><br><span class="line">            methodSet.count =  ountOf_Method;</span><br><span class="line">            methodSet.enumerator =  enumeratorOf_Method;</span><br><span class="line">            methodSet.member =  memberOf_Method;</span><br><span class="line">            <span class="keyword">getter</span> = [[<span class="built_in">NSKeyValueCollectionGetter</span> alloc] initWithContainerClassID:containerClassID key:key  methods:methodSet proxyClass:<span class="built_in">NSKeyValueSet</span>.self];</span><br><span class="line">            [methodSet release];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>([<span class="keyword">self</span> accessInstanceVariablesDirectly]) &#123;</span><br><span class="line">            <span class="comment">// 第五步, 如果允许直接访问实例变量, 也即accessInstanceVariablesDirectly为YES, 则直接取出实例变量</span></span><br><span class="line">            <span class="comment">// 默认顺序为_name==&gt;_isName==&gt;name==&gt;isName</span></span><br><span class="line">            Ivar ivar = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>((ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"_%s"</span>, keyCStr)) ||</span><br><span class="line">               (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"_is%s"</span>, keyCStrUpFirst)) ||</span><br><span class="line">               (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"%s"</span>, keyCStr)) ||</span><br><span class="line">               (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"is%s"</span>, keyCStrUpFirst))</span><br><span class="line">               ) &#123;</span><br><span class="line">                <span class="comment">// 此时ivar有值, 创建NSKeyValueIvarGetter</span></span><br><span class="line">                <span class="keyword">getter</span> = [[<span class="built_in">NSKeyValueIvarGetter</span> alloc] initWithContainerClassID:containerClassID key:key containerIsa:<span class="keyword">self</span> ivar:ivar];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">getter</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后, getter创建失败, 说明方法、实例变量查询失败, 进入下个流程</span></span><br><span class="line">        <span class="keyword">getter</span> = [<span class="keyword">self</span> _createValuePrimitiveGetterWithContainerClassID:containerClassID key:key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">getter</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法详细地设定了查找的顺序，值得关注的是，<code>NSKeyValueMethodForPattern()</code>这个函数调用的次数相当的多。</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最后一次查找</span></span><br><span class="line">+ (<span class="built_in">NSKeyValueGetter</span> *)_createValuePrimitiveGetterWithContainerClassID:(<span class="keyword">id</span>)containerClassID key:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueGetter</span> *<span class="keyword">getter</span> = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> keyCstrLen = [key lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">char</span> keyCstrUpFirst[keyCstrLen + <span class="number">1</span>];</span><br><span class="line">    [key getCString:keyCstrUpFirst maxLength:keyCstrLen + <span class="number">1</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">if</span>(key.length) &#123;</span><br><span class="line">        keyCstrUpFirst[<span class="number">0</span>] = toupper(keyCstrUpFirst[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> keyCstr[keyCstrLen + <span class="number">1</span>];</span><br><span class="line">    [key getCString:keyCstr maxLength:keyCstrLen + <span class="number">1</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    Method getMethod = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 同样的套路, 查找顺序: getPrimitiveName==&gt;primitiveName</span></span><br><span class="line">    <span class="keyword">if</span>((getMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"getPrimitive%s"</span>, keyCstrUpFirst)) ||</span><br><span class="line">       (getMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"primitive%s"</span>, keyCstrUpFirst))</span><br><span class="line">       ) &#123;</span><br><span class="line">        <span class="keyword">getter</span> =  [[<span class="built_in">NSKeyValueMethodGetter</span> alloc] initWithContainerClassID:containerClassID key:key method:getMethod];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>([<span class="keyword">self</span> accessInstanceVariablesDirectly]) &#123;</span><br><span class="line">        Ivar ivar = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 直接访问实例变量</span></span><br><span class="line">        <span class="comment">// 在方法二中找过一遍了, 为啥还要再找一遍?</span></span><br><span class="line">        <span class="comment">// 说明要么是根本没有找到, 要么是虽然找到了, 但是在创建NSKeyValueIvarGetter或者NSKeyValueMethodGetter的时候失败了, 最终的getter还是nil</span></span><br><span class="line">        <span class="keyword">if</span> ((ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"_%s"</span>, keyCstr)) ||</span><br><span class="line">            (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"_is%s"</span>, keyCstrUpFirst)) ||</span><br><span class="line">            (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"%s"</span>, keyCstr)) ||</span><br><span class="line">            (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"is%s"</span>, keyCstrUpFirst))</span><br><span class="line">            ) &#123;</span><br><span class="line">            <span class="keyword">getter</span> = [[<span class="built_in">NSKeyValueIvarGetter</span> alloc] initWithContainerClassID:containerClassID key:key containerIsa:<span class="keyword">self</span> ivar:ivar];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">getter</span>) &#123;</span><br><span class="line">        <span class="keyword">getter</span> = [<span class="keyword">self</span> _createOtherValueGetterWithContainerClassID:containerClassID key:key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">getter</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转发处理给NSKeyValueUndefinedGetter对象</span></span><br><span class="line">+ (id)<span class="string">_createOtherValueGetterWithContainerClassID:</span>(id)containerClassID <span class="string">key:</span>(NSString *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [[NSKeyValueUndefinedGetter alloc] <span class="string">initWithContainerClassID:</span>containerClassID <span class="string">key:</span>key <span class="string">containerIsa:</span>self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSKeyValueUndefinedGetter负责调用其父类(NSKeyValueGetter)的构造方法</span></span><br><span class="line"><span class="meta">@implementation</span> NSKeyValueUndefinedGetter</span><br><span class="line">- (id)<span class="string">initWithContainerClassID:</span>(id)containerClassID <span class="string">key:</span>(NSString *)key <span class="string">containerIsa:</span>(Class)containerIsa &#123;</span><br><span class="line">    <span class="keyword">void</span> *arguments[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    arguments[<span class="number">0</span>] = key;</span><br><span class="line">    <span class="comment">// 调用valueForUndefinedKey方法, 该方法默认实现抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">initWithContainerClassID:</span>containerClassID <span class="string">key:</span>key <span class="string">implementation:</span>methogetImplementation(class_getInstanceMethod(containerIsa,<span class="meta">@selector</span>(<span class="string">valueForUndefinedKey:</span>))) <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">valueForUndefinedKey:</span>) <span class="string">extraArguments:</span>arguments <span class="string">count:</span><span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure><h3 id="方法怎么查找"><a href="#方法怎么查找" class="headerlink" title="方法怎么查找"></a>方法怎么查找</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSKeyValueMethodForPattern</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">NSKeyValueMethodForPattern</span><span class="params">(<span class="keyword">Class</span> <span class="keyword">class</span>, <span class="keyword">const</span> char *pattern,<span class="keyword">const</span> char *param)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    size_t paramLen = strlen(param);</span></span></span><br><span class="line"><span class="function"><span class="comment">    size_t patternLen = strlen(pattern);</span></span></span><br><span class="line"><span class="function"><span class="comment">    char selName[patternLen + paramLen * 2 + 1];</span></span></span><br><span class="line"><span class="function"><span class="comment">    snprintf(selName, (patternLen + paramLen * 2 + 1), pattern,param,param);</span></span></span><br><span class="line"><span class="function"><span class="comment">    // 依赖Runtime的class_getInstanceMethod</span></span></span><br><span class="line"><span class="function"><span class="comment">    return class_getInstanceMethod(class, sel_registerName(selName));</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="实例变量怎么查找"><a href="#实例变量怎么查找" class="headerlink" title="实例变量怎么查找"></a>实例变量怎么查找</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSKeyValueIvarForPattern</span></span><br><span class="line"><span class="function">Ivar <span class="title">NSKeyValueIvarForPattern</span><span class="params">(Class class, <span class="keyword">const</span> <span class="keyword">char</span> *pattern,<span class="keyword">const</span> <span class="keyword">char</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> paramLen = <span class="built_in">strlen</span>(param);</span><br><span class="line">    <span class="keyword">size_t</span> patternLen = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    <span class="keyword">char</span> ivarName[paramLen + patternLen + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(ivarName, paramLen + patternLen + <span class="number">1</span>, pattern,param);</span><br><span class="line">    <span class="comment">// 依赖Runtime的class_getInstanceVariable</span></span><br><span class="line">    <span class="keyword">return</span> class_getInstanceVariable(class, ivarName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NSKeyValueMethodGetter如何创建"><a href="#NSKeyValueMethodGetter如何创建" class="headerlink" title="NSKeyValueMethodGetter如何创建"></a>NSKeyValueMethodGetter如何创建</h3><h4 id="1-NSKeyValueMethodGetter构造方法中生成IMP"><a href="#1-NSKeyValueMethodGetter构造方法中生成IMP" class="headerlink" title="1. NSKeyValueMethodGetter构造方法中生成IMP"></a>1. NSKeyValueMethodGetter构造方法中生成IMP</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSKeyValueMethodGetter</span></span></span><br><span class="line">- (<span class="keyword">id</span>)initWithContainerClassID:(<span class="keyword">id</span>)containerClassID key:(<span class="built_in">NSString</span> *)key method:(Method)method &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> methodArgumentsCount = methogetNumberOfArguments(method);</span><br><span class="line">    <span class="built_in">NSUInteger</span> extraAtgumentCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 默认两个参数((void (*)(id, SEL))objc_msgSend)</span></span><br><span class="line">    <span class="keyword">if</span>(methodArgumentsCount == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *returnType = methocopyReturnType(method);</span><br><span class="line">        IMP imp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">switch</span> (returnType[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'@'</span>: &#123;</span><br><span class="line">                <span class="comment">// 返回类型是对象时, 直接获取method的函数指针</span></span><br><span class="line">                <span class="comment">// 还是以key为"name"举例, 则方法为- (NSString *)name; 这里直接获取其IMP</span></span><br><span class="line">                imp = methogetImplementation(method);</span><br><span class="line">                extraAtgumentCount = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'B'</span>: &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 // 获取将BOOL类型转为NSNumber对象类型的函数指针</span></span><br><span class="line"><span class="comment">                 NSNumber * _NSGetBoolValueWithMethod(id object, SEL selctor, Method method) &#123;</span></span><br><span class="line"><span class="comment">                 return [[[NSNumber alloc] initWithBool: ((BOOL (*)(id,SEL))methogetImplementation(method))(object, methogetName(method))] autorelease];</span></span><br><span class="line"><span class="comment">                 &#125;</span></span><br><span class="line"><span class="comment">                 // 比如key为"isMan", 则方法为 - (BOOL)iaMan;</span></span><br><span class="line"><span class="comment">                 // 获取的IMP便是将普通BOOL类型值转化为NSNumber类型对象的函数指针, 其他类似</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                imp = (IMP)_NSGetBoolValueWithMethod;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>: &#123;imp = (IMP)_NSGetUnsignedCharValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>: &#123;imp = (IMP)_NSGetUnsignedIntValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Q'</span>: &#123;imp = (IMP)_NSGetUnsignedLongLongValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>: &#123;imp = (IMP)_NSGetUnsignedLongValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>: &#123;imp = (IMP)_NSGetUnsignedShortValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'c'</span>: &#123;imp = (IMP)_NSGetCharValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>: &#123;imp = (IMP)_NSGetDoubleValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'f'</span>: &#123;imp = (IMP)_NSGetFloatValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'i'</span>: &#123;imp = (IMP)_NSGetIntValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'l'</span>: &#123;imp = (IMP)_NSGetLongValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'q'</span>: &#123;imp = (IMP)_NSGetLongLongValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>: &#123;imp = (IMP)_NSGetShortValueWithMethod;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#123;'</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (strcmp(returnType, <span class="keyword">@encode</span>(<span class="built_in">CGPoint</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">                    imp = (IMP)_NSGetPointValueWithMethod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(returnType, <span class="keyword">@encode</span>(<span class="built_in">NSRange</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">                    imp = (IMP)_NSGetRangeValueWithMethod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(returnType, <span class="keyword">@encode</span>(<span class="built_in">CGRect</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">                    imp = (IMP)_NSGetRectValueWithMethod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(returnType, <span class="keyword">@encode</span>(<span class="built_in">CGSize</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">                    imp = (IMP)_NSGetSizeValueWithMethod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    imp = (IMP)_NSGetValueWithMethod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        free(returnType);</span><br><span class="line">        <span class="keyword">if</span>(imp) &#123;</span><br><span class="line">            <span class="keyword">void</span> *arguments[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(extraAtgumentCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arguments[<span class="number">0</span>] = method;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将class key selector imp method 参数 参数数量等信息交给父类处理</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">super</span> initWithContainerClassID:containerClassID key:key implementation:imp selector:methogetName(method) extraArguments:arguments count:extraAtgumentCount];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span> release];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> release];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>由于KVC返回的类型为对象<code>(NSObject)</code>，所以需要对方法返回值类型分别进行判断从而为<code>Getter</code>赋值不同的函数指针。也即从<code>BOOL、double、int、CGSize</code>等普通类型转化为<code>NSNumber、NSValue、id</code>等对象类型的函数(指针)。</p><h4 id="2-在父类NSKeyValueAccessor中-对class-key-selector-imp-method-参数-参数数量等信息进行保存"><a href="#2-在父类NSKeyValueAccessor中-对class-key-selector-imp-method-参数-参数数量等信息进行保存" class="headerlink" title="2. 在父类NSKeyValueAccessor中, 对class key selector imp method 参数 参数数量等信息进行保存"></a>2. 在父类<code>NSKeyValueAccessor</code>中, 对<code>class key selector imp method</code> 参数 参数数量等信息进行保存</h4><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">@implementation NSKeyValueAccessor</span><br><span class="line">- (id)initWithContainerClassID:(id)containerClassID key:(NSString *)key implementation:(IMP)implementation selector:(SEL)selector extraArguments:(void *[<span class="number">3</span>])extraArguments <span class="built_in">count</span>:(NSUInteger)<span class="built_in">count</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</span><br><span class="line">        <span class="variable">_containerClassID</span> = containerClassID;</span><br><span class="line">        <span class="variable">_key</span> = key.copy;</span><br><span class="line">        <span class="variable">_implementation</span> = implementation;</span><br><span class="line">        <span class="variable">_selector</span> = selector;</span><br><span class="line">        </span><br><span class="line">        NSUInteger hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (key) &#123;</span><br><span class="line">            hash = CFHash(key);</span><br><span class="line">        &#125;</span><br><span class="line">        hash ^= (NSUInteger)containerClassID;</span><br><span class="line">        <span class="variable">_hashValue</span> = hash;</span><br><span class="line">        <span class="variable">_extraArgumentCount</span> = <span class="built_in">count</span>;</span><br><span class="line">        <span class="variable">_extraArgument1</span> = extraArguments[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">_extraArgument1</span> == key) &#123;</span><br><span class="line">            <span class="variable">_extraArgument1</span> = <span class="variable">_key</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">_extraArgument2</span> = extraArguments[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">_extraArgument2</span> == key) &#123;</span><br><span class="line">            <span class="variable">_extraArgument2</span> = <span class="variable">_key</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">_extraArgument3</span> = extraArguments[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="NSKeyValueIvarGetter如何创建"><a href="#NSKeyValueIvarGetter如何创建" class="headerlink" title="NSKeyValueIvarGetter如何创建"></a>NSKeyValueIvarGetter如何创建</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithContainerClassID:(<span class="keyword">id</span>)containerClassID key:(<span class="built_in">NSString</span> *)key containerIsa:(Class)containerIsa ivar:(Ivar)ivar &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ivarEncoding = ivar_getTypeEncoding(ivar);</span><br><span class="line">    IMP imp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (ivarEncoding[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'@'</span>: &#123;</span><br><span class="line">            objc_ivar_memory_management_t mngment = objc_ivar_memoryUnknown;<span class="comment">//_class_getIvarMemoryManagement(containerIsa, ivar);</span></span><br><span class="line">            <span class="keyword">if</span>(mngment &lt; objc_ivar_memoryWeak) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 id _NSGetObjectGetAssignValueInIvar(id object, SEL selector, Ivar ivar) &#123;</span></span><br><span class="line"><span class="comment">                 return *(id *)object_getIvarAddress(object, ivar);</span></span><br><span class="line"><span class="comment">                 &#125;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                imp = (IMP)_NSGetObjectGetAssignValueInIvar;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mngment == objc_ivar_memoryWeak) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 id _NSGetObjectGetWeakValueInIvar(id object, SEL selector, Ivar ivar) &#123;</span></span><br><span class="line"><span class="comment">                 return objc_loadWeak((id *)object_getIvarAddress(object, ivar));</span></span><br><span class="line"><span class="comment">                 &#125;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                imp = (IMP)_NSGetObjectGetWeakValueInIvar;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mngment == objc_ivar_memoryUnretained) &#123;</span><br><span class="line">                imp = (IMP)_NSGetObjectGetAssignValueInIvar;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                imp = (IMP)_NSGetObjectGetIvarValueInIvar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>: &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             NSNumber * _NSGetUnsignedCharValueInIvar(id object, SEL selector, Ivar ivar) &#123;</span></span><br><span class="line"><span class="comment">             unsigned char value = *(unsigned char *)object_getIvarAddress(object, ivar);</span></span><br><span class="line"><span class="comment">             return [[[NSNumber alloc] initWithUnsignedChar:value] autorelease];</span></span><br><span class="line"><span class="comment">             &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            imp = (IMP)_NSGetUnsignedCharValueInIvar;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'B'</span>: &#123;imp = (IMP)_NSGetBoolValueInIvar;&#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'I'</span>: &#123;imp = (IMP)_NSGetUnsignedIntValueInIvar;&#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>: &#123;imp = (IMP)_NSGetUnsignedLongValueInIvar;&#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Q'</span>: &#123;imp = (IMP)_NSGetUnsignedLongLongValueInIvar;&#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'S'</span>: &#123;imp = (IMP)_NSGetUnsignedShortValueInIvar;&#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&#123;'</span>: &#123;</span><br><span class="line">            <span class="keyword">char</span>* idx = index(ivarEncoding, <span class="string">'='</span>);</span><br><span class="line">            <span class="keyword">if</span> (idx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                imp = (IMP)_NSGetValueInIvar;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(ivarEncoding, <span class="keyword">@encode</span>(<span class="built_in">CGPoint</span>), idx - ivarEncoding) == <span class="number">0</span>)&#123;</span><br><span class="line">                imp = (IMP)_NSGetPointValueInIvar;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(ivarEncoding, <span class="keyword">@encode</span>(<span class="built_in">NSRange</span>), idx - ivarEncoding) == <span class="number">0</span>)&#123;</span><br><span class="line">                imp = (IMP)_NSGetRangeValueInIvar;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(ivarEncoding, <span class="keyword">@encode</span>(<span class="built_in">CGRect</span>), idx - ivarEncoding) == <span class="number">0</span>)&#123;</span><br><span class="line">                imp = (IMP)_NSGetRectValueInIvar;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(ivarEncoding, <span class="keyword">@encode</span>(<span class="built_in">CGSize</span>), idx - ivarEncoding) == <span class="number">0</span>)&#123;</span><br><span class="line">                imp = (IMP)_NSGetSizeValueInIvar;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                imp = (IMP)_NSGetValueInIvar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'c'</span>: &#123;imp = (IMP)_NSGetCharValueInIvar;&#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>: &#123;imp = (IMP)_NSGetDoubleValueInIvar;&#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'f'</span>: &#123;imp = (IMP)_NSGetFloatValueInIvar;&#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'i'</span>: &#123;imp = (IMP)_NSGetIntValueInIvar;&#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'l'</span>: &#123;imp = (IMP)_NSGetLongValueInIvar;&#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'q'</span>: &#123;imp = (IMP)_NSGetLongLongValueInIvar;&#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>: &#123;imp = (IMP)_NSGetShortValueInIvar;&#125;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(imp) &#123;</span><br><span class="line">        <span class="keyword">void</span> *arguments[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        arguments[<span class="number">0</span>] = ivar;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> initWithContainerClassID:containerClassID key:key implementation:imp selector:<span class="literal">NULL</span> extraArguments:arguments count:<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> release];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，判断实例变量的类型编码，进而赋值不同的IMP。</p><h3 id="怎么根据Getter取值"><a href="#怎么根据Getter取值" class="headerlink" title="怎么根据Getter取值"></a>怎么根据Getter取值</h3><h4 id="1-线程校验"><a href="#1-线程校验" class="headerlink" title="1. 线程校验"></a>1. 线程校验</h4><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">void NSKeyValueObservingAssertRegistrationLockNotHeld() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">_NSKeyValueObserverRegistrationEnableLockingAssertions</span> &amp;&amp; <span class="variable">_NSKeyValueObserverRegistrationLockOwner</span> == pthreaself()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(pthreaself() != <span class="variable">_NSKeyValueObserverRegistrationLockOwner</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-直接调用Getter中存储的方法实现-getter-implementation"><a href="#2-直接调用Getter中存储的方法实现-getter-implementation" class="headerlink" title="2. 直接调用Getter中存储的方法实现(getter.implementation)"></a>2. 直接调用Getter中存储的方法实现(getter.implementation)</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> _NSGetUsingKeyValueGetter(<span class="keyword">id</span> object, <span class="built_in">NSKeyValueGetter</span> *<span class="keyword">getter</span>) &#123;</span><br><span class="line">    <span class="comment">// 线程判断</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingAssertRegistrationLockNotHeld</span>();</span><br><span class="line">    <span class="comment">// 根据其他参数数量extraArgumentCount分别进行函数调用</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">getter</span>.extraArgumentCount) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> ( (<span class="keyword">id</span> (*)(<span class="keyword">id</span>,SEL))<span class="keyword">getter</span>.implementation )(object,<span class="keyword">getter</span>.selector);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> ( (<span class="keyword">id</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">void</span>*))<span class="keyword">getter</span>.implementation )(object,<span class="keyword">getter</span>.selector, <span class="keyword">getter</span>.extraArgument1);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> ( (<span class="keyword">id</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">void</span>*,<span class="keyword">void</span>*))<span class="keyword">getter</span>.implementation )(object,<span class="keyword">getter</span>.selector, <span class="keyword">getter</span>.extraArgument1, <span class="keyword">getter</span>.extraArgument2);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> ( (<span class="keyword">id</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">void</span>*,<span class="keyword">void</span>*,<span class="keyword">void</span>*))<span class="keyword">getter</span>.implementation )(object,<span class="keyword">getter</span>.selector, <span class="keyword">getter</span>.extraArgument1, <span class="keyword">getter</span>.extraArgument2, <span class="keyword">getter</span>.extraArgument3);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="valueForKeyPath"><a href="#valueForKeyPath" class="headerlink" title="valueForKeyPath:"></a>valueForKeyPath:</h2><p>假定这里的keyPath为<code>@&quot;key1.key2.key3.key4&quot;</code>。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="keyword">if</span>(keyPath) &#123;</span><br><span class="line">        <span class="comment">// 字符串编码判断</span></span><br><span class="line">        <span class="built_in">CFStringEncoding</span> encoding = __CFDefaultEightBitStringEncoding;</span><br><span class="line">        <span class="keyword">if</span>(encoding == kCFStringEncodingInvalidId) &#123;</span><br><span class="line">            <span class="comment">// 编码无效 kCFStringEncodingInvalidId就是 (0xffffffffU)</span></span><br><span class="line">            encoding = __CFStringComputeEightBitStringEncoding();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建C字符串: "key1.key2.key3.key4"</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *cStr = <span class="built_in">CFStringGetCStringPtr</span>((<span class="built_in">CFStringRef</span>)keyPath, encoding);</span><br><span class="line">        <span class="keyword">if</span>(cStr) &#123;</span><br><span class="line">            <span class="comment">// memchr函数:从头开始搜寻s 所指的内存内容前n 个字节，直到发现第一个值为c 的字节，则返回指向该字节的指针</span></span><br><span class="line">            <span class="comment">// 所以最后获取到包含'点符号'的后部分 即firstDotPointers为 ".key2.key3.key4"</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *firstDotPointer = memchr(cStr, <span class="string">'.'</span>, keyPath.length);</span><br><span class="line">            <span class="keyword">if</span>(firstDotPointer) &#123;</span><br><span class="line">                <span class="comment">// 这里的subKey是 "key1"</span></span><br><span class="line">                <span class="built_in">NSString</span> *subKey =  [[keyPath substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, firstDotPointer - cStr)] <span class="keyword">retain</span>];</span><br><span class="line">                <span class="comment">// 这里的subKeyPathLeft是 "key2.key3.key4"</span></span><br><span class="line">                <span class="built_in">NSString</span> *subKeyPathLeft =  [[keyPath substringWithRange:<span class="built_in">NSMakeRange</span>(firstDotPointer - cStr + <span class="number">1</span>, keyPath.length -  (firstDotPointer - cStr + <span class="number">1</span>))] <span class="keyword">retain</span>];</span><br><span class="line">                <span class="comment">// 先获取到subKey的结果, 然后用它的结果再求subKeyPathLeft, 进入递归中</span></span><br><span class="line">                <span class="keyword">id</span> value = [[<span class="keyword">self</span> valueForKey:subKey] valueForKeyPath:subKeyPathLeft];</span><br><span class="line">                [subKey release];</span><br><span class="line">                [subKeyPathLeft release];</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// firstDotPointer不存在, 说明keyPath中没有'点符号', 则直接调用valueForKey</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> valueForKey:keyPath];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里, 上面代码没有return, 说明keyPath为nil或者cStr为nil</span></span><br><span class="line">    <span class="built_in">NSRange</span> range = [keyPath rangeOfString:<span class="string">@"."</span> options:<span class="built_in">NSLiteralSearch</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, keyPath.length)];</span><br><span class="line">    <span class="keyword">if</span>(range.length) &#123;</span><br><span class="line">        <span class="comment">// range.length不为0, 也即keyPath中有'点符号'</span></span><br><span class="line">        <span class="comment">// subKey为"key1"</span></span><br><span class="line">        <span class="built_in">NSString</span> *subKey =  [[keyPath substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, range.location)] <span class="keyword">retain</span>];</span><br><span class="line">        <span class="comment">// subKeyPathLeft为"key2.key3.key4"</span></span><br><span class="line">        <span class="built_in">NSString</span> *subKeyPathLeft =  [[keyPath substringWithRange:<span class="built_in">NSMakeRange</span>(range.location + <span class="number">1</span>, keyPath.length -  (range.location + <span class="number">1</span>))] <span class="keyword">retain</span>];</span><br><span class="line">        <span class="comment">// 同样的, 先获取到subKey的结果, 然后用它的结果再求subKeyPathLeft, 进入递归中</span></span><br><span class="line">        <span class="keyword">id</span> value = [[<span class="keyword">self</span> valueForKey:subKey] valueForKeyPath:subKeyPathLeft];</span><br><span class="line">        [subKey release];</span><br><span class="line">        [subKeyPathLeft release];</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// keyPath为nil或者keyPath中没有'点符号', 直接调用valueForKey</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> valueForKey:keyPath];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就有一个问题了，相似的把keyPath拆分逻辑的逻辑为啥要写两个，一个转为C字符串拆分，一个直接拆分?  揣测两者的区别主要是对字符串编码的判断。</p><h1 id="三、设值"><a href="#三、设值" class="headerlink" title="三、设值"></a>三、设值</h1><p>设值的流程就比较简单了。</p><blockquote><p>The default implementation of this method does the following:</p><ol><li><p>Searches the class of the receiver for an accessor method whose name matches the pattern <code>-set&lt;Key&gt;:</code>. If such a method is found the type of its parameter is checked. If the parameter type is not an object pointer type but the value is nil <code>-setNilValueForKey:</code> is invoked. The default implementation of <code>-setNilValueForKey:</code> raises an NSInvalidArgumentException, but you can override it in your application. Otherwise, if the type of the method’s parameter is an object pointer type the method is simply invoked with the value as the argument. If the type of the method’s parameter is some other type the inverse of the NSNumber/NSValue conversion done by <code>-valueForKey:</code> is performed before the method is invoked.</p></li><li><p>Otherwise (no accessor method is found), if the receiver’s class’ <code>+accessInstanceVariablesDirectly</code> property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern <code>_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;</code>, in that order. If such an instance variable is found and its type is an object pointer type the value is retained and the result is set in the instance variable, after the instance variable’s old value is first released. If the instance variable’s type is some other type its value is set after the same sort of conversion from NSNumber or NSValue as in step 1.</p></li><li><p>Otherwise (no accessor method or instance variable is found), invokes <code>-setValue:forUndefinedKey:</code>. The default implementation of <code>-setValue:forUndefinedKey:</code> raises an NSUndefinedKeyException, but you can override it in your application.</p></li></ol><p>Compatibility notes:</p><ul><li>For backward binary compatibility with <code>-takeValue:forKey:</code>‘s behavior, a method whose name matches the pattern <code>-_set&lt;Key&gt;:</code> is also recognized in step 1. KVC accessor methods whose names start with underscores were deprecated as of Mac OS 10.3 though.</li><li>For backward binary compatibility, -unableToSetNilForKey: will be invoked instead of <code>-setNilValueForKey:</code> in step 1, if the implementation of <code>-unableToSetNilForKey:</code> in the receiver’s class is not NSObject’s.</li><li>The behavior described in step 2 is different from <code>-takeValue:forKey:</code>‘s, in which the instance variable search order is <code>&lt;key&gt;, _&lt;key&gt;</code>.</li><li>For backward binary compatibility with <code>-takeValue:forKey:</code>‘s behavior, <code>-handleTakeValue:forUnboundKey:</code> will be invoked instead of <code>-setValue:forUndefinedKey:</code> in step 3, if the implementation of <code>-handleTakeValue:forUnboundKey:</code> in the receiver’s class is not NSObject’s.</li></ul></blockquote><p>翻译如下：<br>这个方法的默认实现是这样的：</p><ol><li>搜索该类名称为<code>-set&lt;Key&gt;:</code>的存取器方法，如果找到，检查其参数类型。如果参数为<code>nil</code>，<code>-setNilValueForKey:</code>方法将会被调用。这个方法的默认实现是抛出<code>NSInvalidArgumentException</code>异常，不过你可以重写该方法自行实现。如果参数类型为对象类型，该存取器方法会被直接调用，这个参数也会被直接使用。如果参数能被转化为<code>NSNumber/NSValue</code>类型，参数会在存取器方法被调用之前进行转换。</li><li>如果存取器方法没有被找到，倘若此时消息接收者的<code>+accessInstanceVariablesDirectly</code>属性返回的是<code>YES</code>，那么按照<code>_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;</code>的顺序搜索该类的实例变量。如果找到这个实例变量，当其为对象类型时，该实例变量会在旧值释放之后被设置新值。当其为其他类型时，那么按照步骤1中的类型转换规则设置这个实例变量的值。</li><li>如果存取器方法和实例变量都没有被找到，<code>-setValue:forUndefinedKey:</code>方法将会被调用。这个方法的默认实现是抛出<code>NSUndefinedKeyException</code>异常，不过你可以重写该方法自行实现。</li></ol><p>兼容性：</p><ul><li>为了向后兼容<code>-takeValue:forKey:</code>，名称为<code>-_set&lt;Key&gt;:</code>的方法也会在步骤1中被查找。</li><li>如果<code>-unableToSetNilForKey:</code>的实现不是<code>NSObject</code>的默认实现（换句话说，自己手动实现了<code>-unableToSetNilForKey:</code>方法），那在步骤1中，<code>-unableToSetNilForKey:</code>方法将会代替<code>-setNilValueForKey:</code>方法被调用。</li><li>对于<code>-takeValue:forKey:</code>，其实例变量的查找顺序不同于步骤2所描述的，调用它时，实例变量查找顺序是<code>&lt;key&gt;, _&lt;key&gt;</code>。</li><li>为了向后兼容<code>-takeValue:forKey:</code>，如果<code>-handleTakeValue:forUnboundKey:</code>的实现不是<code>NSObject</code>的默认实现（换句话说，自己手动实现了<code>-handleTakeValue:forUnboundKey:</code>方法），那在步骤3中，<code>-handleTakeValue:forUnboundKey:</code>方法将会代替<code>-setValue:forUndefinedKey:</code>方法被调用。</li></ul><p>流程图如下：<br><img src="https://image.chenyalun.com/2019/05/05/002.png" alt></p><h2 id="setValue"><a href="#setValue" class="headerlink" title="setValue:"></a>setValue:</h2><h3 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h3><p>这里使用<code>NSKeyValueCachedSetters</code>缓存<code>setter</code>。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假定key为@"name"</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        OSSpinLockLock(&amp;<span class="built_in">NSKeyValueCachedAccessorSpinLock</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NSKeyValueCachedSetters</span>) &#123;</span><br><span class="line">            <span class="built_in">CFSetCallBacks</span> callbacks = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            callbacks.version = kCFTypeSetCallBacks.version;</span><br><span class="line">            callbacks.retain = kCFTypeSetCallBacks.retain;</span><br><span class="line">            callbacks.release = kCFTypeSetCallBacks.release;</span><br><span class="line">            callbacks.copyDescription = kCFTypeSetCallBacks.copyDescription;</span><br><span class="line">            callbacks.equal = (<span class="built_in">CFSetEqualCallBack</span>)<span class="built_in">NSKeyValueAccessorIsEqual</span>;</span><br><span class="line">            callbacks.hash = (<span class="built_in">CFSetHashCallBack</span>)<span class="built_in">NSKeyValueAccessorHash</span>;</span><br><span class="line">            <span class="built_in">NSKeyValueCachedSetters</span> = <span class="built_in">CFSetCreateMutable</span>(<span class="literal">NULL</span>,<span class="number">0</span>,&amp;callbacks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSKeyValueSetter</span> *finder = [<span class="built_in">NSKeyValueSetter</span> new];</span><br><span class="line">        finder.containerClassID = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">        finder.key = key;</span><br><span class="line">        finder.hashValue = <span class="built_in">CFHash</span>((<span class="built_in">CFTypeRef</span>)key) ^ (<span class="built_in">NSUInteger</span>)(object_getClass(<span class="keyword">self</span>));</span><br><span class="line">        <span class="comment">// 缓存中取Setter</span></span><br><span class="line">        <span class="built_in">NSKeyValueSetter</span> *<span class="keyword">setter</span> =  <span class="built_in">CFSetGetValue</span>(<span class="built_in">NSKeyValueCachedSetters</span>, (<span class="keyword">void</span> *)finder);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">setter</span>) &#123;</span><br><span class="line">            <span class="keyword">setter</span> = [object_getClass(<span class="keyword">self</span>) _createValueSetterWithContainerClassID:object_getClass(<span class="keyword">self</span>) key:key];</span><br><span class="line">            <span class="built_in">CFSetAddValue</span>(<span class="built_in">NSKeyValueCachedSetters</span>, (<span class="keyword">void</span>*)<span class="keyword">setter</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        OSSpinLockUnlock(&amp;<span class="built_in">NSKeyValueCachedAccessorSpinLock</span>);</span><br><span class="line">        <span class="comment">// 设值</span></span><br><span class="line">        _NSSetUsingKeyValueSetter(<span class="keyword">self</span>,<span class="keyword">setter</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="built_in">NSException</span> raise:<span class="built_in">NSInvalidArgumentException</span> format:<span class="string">@"%@: attempt to set a value for a nil key"</span>,_NSMethodExceptionProem(<span class="keyword">self</span>,_cmd)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSKeyValueSetter</span> *)_createValueSetterWithContainerClassID:(<span class="keyword">id</span>)containerClassID key:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueSetter</span> *<span class="keyword">setter</span> = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> key_cstr_len = [key lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="comment">// 首字符大写的key</span></span><br><span class="line">    <span class="keyword">char</span> key_cstr_upfirst[key_cstr_len + <span class="number">1</span>];</span><br><span class="line">    [key getCString:key_cstr_upfirst maxLength:key_cstr_len + <span class="number">1</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">if</span> (key.length) &#123;</span><br><span class="line">        key_cstr_upfirst[<span class="number">0</span>] = toupper(key_cstr_upfirst[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原来的key</span></span><br><span class="line">    <span class="keyword">char</span> key_cstr[key_cstr_len + <span class="number">1</span>];</span><br><span class="line">    [key getCString:key_cstr maxLength:key_cstr_len + <span class="number">1</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    Method method = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查找方法顺序, 假定key为@"name"</span></span><br><span class="line">    <span class="comment">// setName: ==&gt; _setName: ==&gt; setIsName:</span></span><br><span class="line">    <span class="keyword">if</span> ((method = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"set%s:"</span>, key_cstr_upfirst)) ||</span><br><span class="line">        (method = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"_set%s:"</span>, key_cstr_upfirst)) ||</span><br><span class="line">        (method = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>, <span class="string">"setIs%s:"</span>, key_cstr_upfirst))</span><br><span class="line">        ) &#123;</span><br><span class="line">        <span class="keyword">setter</span> = [[<span class="built_in">NSKeyValueMethodSetter</span> alloc] initWithContainerClassID:containerClassID key:key method:method];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> accessInstanceVariablesDirectly]) &#123;</span><br><span class="line">        Ivar ivar = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 允许直接访问实例变量, 查找顺序为: _name ==&gt; _isName ==&gt; name ==&gt; isName</span></span><br><span class="line">        <span class="keyword">if</span> ((ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"_%s"</span>, key_cstr)) ||</span><br><span class="line">            (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"_is%s"</span>, key_cstr_upfirst)) ||</span><br><span class="line">            (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"%s"</span>, key_cstr)) ||</span><br><span class="line">            (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"is%s"</span>, key_cstr_upfirst))</span><br><span class="line">            ) &#123;</span><br><span class="line">            <span class="keyword">setter</span> = [[<span class="built_in">NSKeyValueIvarSetter</span> alloc] initWithContainerClassID:containerClassID key:key containerIsa:<span class="keyword">self</span> ivar:ivar];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">setter</span>) &#123;</span><br><span class="line">        <span class="keyword">setter</span> = [<span class="keyword">self</span> _createValuePrimitiveSetterWithContainerClassID:containerClassID key:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">setter</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-1"><a href="#方法三-1" class="headerlink" title="方法三"></a>方法三</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSKeyValueSetter</span> *)_createValuePrimitiveSetterWithContainerClassID:(<span class="keyword">id</span>)containerClassID key:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueSetter</span> *<span class="keyword">setter</span> = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> keyCstrLen = [key lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">char</span> keyCstrUpFirst[keyCstrLen + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    [key getCString:keyCstrUpFirst maxLength:keyCstrLen + <span class="number">1</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(key.length) &#123;</span><br><span class="line">        keyCstrUpFirst[<span class="number">0</span>] = toupper(keyCstrUpFirst[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> keyCstr[keyCstrLen + <span class="number">1</span>];</span><br><span class="line">    [key getCString:keyCstr maxLength:keyCstrLen + <span class="number">1</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="comment">// 假定key为@"name", 查询 setPrimitiveName:方法</span></span><br><span class="line">    Method method = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>,<span class="string">"setPrimitive%s:"</span>,keyCstrUpFirst);</span><br><span class="line">    <span class="keyword">if</span>(method) &#123;</span><br><span class="line">        <span class="keyword">setter</span> = [[<span class="built_in">NSKeyValueMethodSetter</span> alloc] initWithContainerClassID:containerClassID key:key method:method];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>([<span class="keyword">self</span> accessInstanceVariablesDirectly]) &#123;</span><br><span class="line">            Ivar ivar = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> ((ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"_%s"</span>, keyCstr)) ||</span><br><span class="line">                (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"_is%s"</span>, keyCstrUpFirst)) ||</span><br><span class="line">                (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"%s"</span>, keyCstr)) ||</span><br><span class="line">                (ivar = <span class="built_in">NSKeyValueIvarForPattern</span>(<span class="keyword">self</span>, <span class="string">"is%s"</span>, keyCstrUpFirst))</span><br><span class="line">                ) &#123;</span><br><span class="line">                <span class="keyword">setter</span> = [[<span class="built_in">NSKeyValueIvarSetter</span> alloc] initWithContainerClassID:containerClassID key:key containerIsa:<span class="keyword">self</span> ivar:ivar];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">setter</span>) &#123;</span><br><span class="line">        <span class="keyword">setter</span> = [<span class="keyword">self</span> _createOtherValueSetterWithContainerClassID:containerClassID key:key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">setter</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四-1"><a href="#方法四-1" class="headerlink" title="方法四"></a>方法四</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">+ (NSKeyValueSetter *)<span class="string">_createOtherValueSetterWithContainerClassID:</span>(id)containerClassID <span class="string">key:</span>(NSString *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [[NSKeyValueUndefinedSetter alloc] <span class="string">initWithContainerClassID:</span>containerClassID <span class="string">key:</span>key <span class="string">containerIsa:</span>self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="怎么根据Setter设值"><a href="#怎么根据Setter设值" class="headerlink" title="怎么根据Setter设值"></a>怎么根据Setter设值</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _NSSetUsingKeyValueSetter(<span class="keyword">id</span> object, <span class="built_in">NSKeyValueSetter</span> *<span class="keyword">setter</span>, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">setter</span>.extraArgumentCount) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">            ( (<span class="keyword">id</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">id</span>))<span class="keyword">setter</span>.implementation )(object,<span class="keyword">setter</span>.selector,value);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">            ( (<span class="keyword">id</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">id</span>,<span class="keyword">void</span>*))<span class="keyword">setter</span>.implementation )(object,<span class="keyword">setter</span>.selector, value, <span class="keyword">setter</span>.extraArgument1);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">            ( (<span class="keyword">id</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">id</span>,<span class="keyword">void</span>*,<span class="keyword">void</span>*))<span class="keyword">setter</span>.implementation )(object,<span class="keyword">setter</span>.selector, value, <span class="keyword">setter</span>.extraArgument1, <span class="keyword">setter</span>.extraArgument2);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">            ( (<span class="keyword">id</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">id</span>,<span class="keyword">void</span>*,<span class="keyword">void</span>*,<span class="keyword">void</span>*))<span class="keyword">setter</span>.implementation )(object,<span class="keyword">setter</span>.selector, value, <span class="keyword">setter</span>.extraArgument1, <span class="keyword">setter</span>.extraArgument2, <span class="keyword">setter</span>.extraArgument3);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用Setter中存储的方法实现(getter.implementation)。</p><h2 id="setValue-forKeyPath"><a href="#setValue-forKeyPath" class="headerlink" title="setValue:forKeyPath:"></a>setValue:forKeyPath:</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="keyword">if</span>(keyPath) &#123;</span><br><span class="line">        <span class="built_in">CFStringEncoding</span> encoding = __CFDefaultEightBitStringEncoding;</span><br><span class="line">        <span class="keyword">if</span>(encoding == kCFStringEncodingInvalidId) &#123;</span><br><span class="line">            encoding = __CFStringComputeEightBitStringEncoding();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *keyPathCStr = <span class="built_in">CFStringGetCStringPtr</span>((<span class="built_in">CFStringRef</span>)keyPath, encoding);</span><br><span class="line">        <span class="keyword">if</span>(keyPathCStr) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *firstDotPointer = memchr(keyPathCStr, <span class="string">'.'</span>, keyPath.length);</span><br><span class="line">            <span class="keyword">if</span>(firstDotPointer) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *subKey =  [[keyPath substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, firstDotPointer - keyPathCStr)] <span class="keyword">retain</span>];</span><br><span class="line">                <span class="built_in">NSString</span> *subKeyPathAfterDot =  [[keyPath substringWithRange:<span class="built_in">NSMakeRange</span>(firstDotPointer - keyPathCStr + <span class="number">1</span>, keyPath.length -  (firstDotPointer - keyPathCStr + <span class="number">1</span>))] <span class="keyword">retain</span>];</span><br><span class="line">                </span><br><span class="line">                [[<span class="keyword">self</span> valueForKey:subKey] setValue:value forKeyPath:subKeyPathAfterDot];</span><br><span class="line">                </span><br><span class="line">                [subKey release];</span><br><span class="line">                [subKeyPathAfterDot release];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                [<span class="keyword">self</span> setValue:value forKey:keyPath];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSRange</span> dotRange = [keyPath rangeOfString:<span class="string">@"."</span> options:<span class="built_in">NSLiteralSearch</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, keyPath.length)];</span><br><span class="line">    <span class="keyword">if</span>(dotRange.length) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *subKey =  [[keyPath substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, dotRange.location)] <span class="keyword">retain</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *subKeyPathAfterDot =  [[keyPath substringWithRange:<span class="built_in">NSMakeRange</span>(dotRange.location + <span class="number">1</span>, keyPath.length -  (dotRange.location + <span class="number">1</span>))] <span class="keyword">retain</span>];</span><br><span class="line">        </span><br><span class="line">        [[<span class="keyword">self</span> valueForKey:subKey] setValue:value forKeyPath:subKeyPathAfterDot];</span><br><span class="line">        </span><br><span class="line">        [subKey release];</span><br><span class="line">        [subKeyPathAfterDot release];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         [<span class="keyword">self</span> setValue:value forKey:keyPath];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本是与取值类似的逻辑。</p><h1 id="四、集合对象的KVC"><a href="#四、集合对象的KVC" class="headerlink" title="四、集合对象的KVC"></a>四、集合对象的KVC</h1><h2 id="NSArray的KVC"><a href="#NSArray的KVC" class="headerlink" title="NSArray的KVC"></a>NSArray的KVC</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> (<span class="title">NSKeyValueCoding</span>)</span></span><br><span class="line"><span class="comment">// 返回Array内每个对象的“key”对应值组成的数组</span></span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">// 如果keyPath中包含集合运算符, 则返回运算结果, 否则返回Array内每个对象的“keyPath”对应值组成的数组</span></span><br><span class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"><span class="comment">// 设置Array里每个对象的key对应值为value</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *operationKey = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 集合运算符:如@count, @firstObject, @lastObject等</span></span><br><span class="line">    <span class="keyword">if</span> (key.length &amp;&amp; [key characterAtIndex:<span class="number">0</span>] == <span class="string">'@'</span> &amp;&amp; (operationKey = [key substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">1</span>, key.length - <span class="number">1</span>)])) &#123;</span><br><span class="line">        <span class="comment">// 去掉'@'便是operationKey</span></span><br><span class="line">        <span class="keyword">id</span> value =  [<span class="keyword">super</span> valueForKey:operationKey];</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建与自身相等数量的array</span></span><br><span class="line">        <span class="keyword">id</span> *objectsBuff = <span class="built_in">NSAllocateObjectArray</span>(<span class="keyword">self</span>.count);</span><br><span class="line">        <span class="comment">// 现在, 指针p与指针objectsBuff指向一致</span></span><br><span class="line">        <span class="keyword">id</span> *p = objectsBuff;</span><br><span class="line">        <span class="comment">// 遍历自身</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">// 取出容器中的元素对应的value</span></span><br><span class="line">            <span class="keyword">id</span> eachValue = [object valueForKey:key];</span><br><span class="line">            <span class="comment">// 如果eachValue不存在, 则p的next指针指向的对象设置成 NSNull实例对象</span></span><br><span class="line">            <span class="comment">// 如果eachValue有值, 则p的next指针指向的对象设置为eachValue</span></span><br><span class="line">            *(p++) = (eachValue ? : [<span class="built_in">NSNull</span> null]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据objectsBuff创建一个数组, 这个objectsBuff就是'eachValue'的集合</span></span><br><span class="line">        <span class="comment">// 也即假定key为@"name", 遍历容器中所有元素, 取出每个元素key为@"name"对应的值, 这些值的集合就是数组arrayValue</span></span><br><span class="line">        <span class="built_in">NSArray</span> *arrayValue = [[[<span class="built_in">NSArray</span> alloc] initWithObjects:objectsBuff count:<span class="keyword">self</span>.count] autorelease];</span><br><span class="line">        <span class="comment">// 释放objectsBuff</span></span><br><span class="line">        <span class="built_in">NSFreeObjectArray</span>(objectsBuff);</span><br><span class="line">        <span class="keyword">return</span> arrayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="comment">// 集合运算符: 如@count, @firstObject, @"@unionOfObjects.friend.name"等</span></span><br><span class="line">    <span class="comment">// 这里以 @"@unionOfObjects.friend"为例</span></span><br><span class="line">    <span class="keyword">if</span>(keyPath.length &amp;&amp; [keyPath characterAtIndex:<span class="number">0</span>] == <span class="string">'@'</span>) &#123;</span><br><span class="line">        <span class="comment">// 说明keyPath中有'@符号', 且'@符号'在第0个位置处</span></span><br><span class="line">        <span class="built_in">NSRange</span> dotRange = [keyPath rangeOfString:<span class="string">@"."</span> options:<span class="built_in">NSLiteralSearch</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, keyPath.length)];</span><br><span class="line">        <span class="keyword">if</span>(dotRange.length) &#123;</span><br><span class="line">            <span class="comment">// dotRange.length不为0, 说明keyPath中有'@符号', 而且还有'点符号'</span></span><br><span class="line">            <span class="comment">// 取出包含运算符的那部分,如 @"unionOfObjects"</span></span><br><span class="line">            <span class="built_in">NSString</span> *operator = [keyPath substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, dotRange.location)];</span><br><span class="line">            <span class="comment">// 取出除运算符之外的那部分,如 @"friend"</span></span><br><span class="line">            <span class="built_in">NSString</span> *keyPathForOperator = [keyPath substringWithRange:<span class="built_in">NSMakeRange</span>(dotRange.location + <span class="number">1</span>, keyPath.length - (dotRange.location + <span class="number">1</span>))];</span><br><span class="line">            <span class="keyword">if</span>(keyPathForOperator) &#123;</span><br><span class="line">                <span class="comment">// 说明含运算符的那部分如 @"unionOfObjects" 和除运算符之外的那部分如 @"friend" 都存在</span></span><br><span class="line">                <span class="built_in">NSUInteger</span> operatorCStrLength = [operator lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">                <span class="keyword">char</span> operatorCStr[operatorCStrLength + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 转为C字符串operatorCStr, 也即 @"unionOfObjects" 转为 "unionOfObjects"</span></span><br><span class="line">                [operator getCString:operatorCStr maxLength:operatorCStrLength + <span class="number">1</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">                <span class="comment">// 查找方法, 即: "unionOfObjectsForKeyPath:"</span></span><br><span class="line">                Method operatorMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>.class, <span class="string">"%sForKeyPath:"</span>, operatorCStr);</span><br><span class="line">                <span class="keyword">if</span>(!operatorMethod) &#123;</span><br><span class="line">                    <span class="comment">// 上面的方法没找到, 就查找带下划线的那个: "_unionOfObjectsForKeyPath:"</span></span><br><span class="line">                    operatorMethod = <span class="built_in">NSKeyValueMethodForPattern</span>(<span class="keyword">self</span>.class, <span class="string">"_%sForKeyPath:"</span>, operatorCStr);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (operatorMethod) &#123;</span><br><span class="line">                    <span class="comment">// 查找成功, 调用运算符对应的方法</span></span><br><span class="line">                    <span class="keyword">id</span> value = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>,Method,<span class="built_in">NSString</span> *))methoinvoke)(<span class="keyword">self</span>,operatorMethod,keyPathForOperator);</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有找到, 说明是不支持的运算符</span></span><br><span class="line">                    [<span class="built_in">NSException</span> raise:<span class="built_in">NSInvalidArgumentException</span> format:<span class="string">@"[&lt;%@ %p&gt; valueForKeyPath:]: this class does not implement the %@ operation."</span>, <span class="keyword">self</span>.class,<span class="keyword">self</span>,operator];</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明只有包含运算符的那部分如 @"friend", 走NSObject的valueForKey逻辑</span></span><br><span class="line">                <span class="keyword">id</span> value = [<span class="keyword">super</span> valueForKey:operator];</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// keyPath中有'@符号', 但是没有'点符号', 取出除'@符号'之外的key</span></span><br><span class="line">            <span class="built_in">NSString</span> *key = [[keyPath substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">1</span>, keyPath.length - <span class="number">1</span>)] <span class="keyword">retain</span>];</span><br><span class="line">            <span class="comment">// 走NSObject的valueForKey逻辑</span></span><br><span class="line">            <span class="keyword">id</span> value = [<span class="keyword">super</span> valueForKey:key];</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有'@符号',可能有'点符号', 走NSObject的valueForKeyPath逻辑</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> valueForKeyPath: keyPath];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 对容器内的每一个元素都设值</span></span><br><span class="line">        [object setValue:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @sum.keyPath, 例如 @"@sum.price", 传递到这个方法中, 参数keyPath为@"price"</span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *)_sumForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="built_in">NSDecimal</span> resultDecimal = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">NSDecimalNumber</span> *zero = [<span class="built_in">NSDecimalNumber</span> zero];</span><br><span class="line">    <span class="keyword">if</span> (zero) resultDecimal = [zero decimalValue];</span><br><span class="line">    <span class="comment">// 这里使用NSDecimalNumber 保证精确度</span></span><br><span class="line">    <span class="built_in">NSDecimal</span> eachDecimal = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i=<span class="number">0</span>; i&lt;<span class="keyword">self</span>.count; ++i) &#123;</span><br><span class="line">        <span class="comment">// 获取每个对象的keyPath(如@"price")对应值</span></span><br><span class="line">        <span class="keyword">id</span> eachValue = [<span class="keyword">self</span> _valueForKeyPath:keyPath ofObjectAtIndex:i];</span><br><span class="line">        <span class="keyword">if</span> (eachValue) &#123;</span><br><span class="line">            eachDecimal = [eachValue decimalValue];</span><br><span class="line">            <span class="comment">// 累加</span></span><br><span class="line">            <span class="built_in">NSDecimalAdd</span>(&amp;resultDecimal, &amp;resultDecimal, &amp;eachDecimal, <span class="built_in">NSRoundBankers</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSDecimalNumber</span> decimalNumberWithDecimal:resultDecimal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求平均值"><a href="#求平均值" class="headerlink" title="求平均值"></a>求平均值</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 Array中每个对象的keyPath对应值 求平均值</span></span><br><span class="line"><span class="comment">// @avg.keyPath</span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *)_avgForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.count) &#123;</span><br><span class="line">        <span class="comment">//总和 / 对象数</span></span><br><span class="line">        <span class="keyword">return</span> [(<span class="built_in">NSDecimalNumber</span>*)[<span class="keyword">self</span> _sumForKeyPath:keyPath]  decimalNumberByDividingBy:(<span class="built_in">NSDecimalNumber</span>*)[<span class="built_in">NSDecimalNumber</span> numberWithUnsignedInteger:<span class="keyword">self</span>.count]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求数量"><a href="#求数量" class="headerlink" title="求数量"></a>求数量</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取对象数目</span></span><br><span class="line"><span class="comment">// @count</span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *)_countForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSNumber</span> numberWithInteger:<span class="keyword">self</span>.count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求最大值"><a href="#求最大值" class="headerlink" title="求最大值"></a>求最大值</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 Array中每个对象的keyPath对应值 求最大值</span></span><br><span class="line"><span class="comment">// @max.keyPath</span></span><br><span class="line">- (<span class="keyword">id</span>)_maxForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="keyword">id</span> maxValue = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i=<span class="number">0</span>; i&lt;<span class="keyword">self</span>.count; ++i) &#123;</span><br><span class="line">        <span class="keyword">id</span> eachValue = [<span class="keyword">self</span> _valueForKeyPath:keyPath ofObjectAtIndex:i];</span><br><span class="line">        <span class="keyword">if</span> (eachValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!maxValue) &#123;</span><br><span class="line">                maxValue = eachValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([maxValue compare:eachValue] == <span class="built_in">NSOrderedAscending</span>)&#123;</span><br><span class="line">                maxValue = eachValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求最小值"><a href="#求最小值" class="headerlink" title="求最小值"></a>求最小值</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 Array中每个对象的keyPath对应值 求最小值</span></span><br><span class="line"><span class="comment">// @min.keyPath</span></span><br><span class="line">- (<span class="keyword">id</span>)_minForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="keyword">id</span> minValue = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i=<span class="number">0</span>; i&lt;<span class="keyword">self</span>.count; ++i) &#123;</span><br><span class="line">        <span class="keyword">id</span> eachValue = [<span class="keyword">self</span> _valueForKeyPath:keyPath ofObjectAtIndex:i];</span><br><span class="line">        <span class="keyword">if</span> (eachValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!minValue) &#123;</span><br><span class="line">                minValue = eachValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([minValue compare:eachValue] == <span class="built_in">NSOrderedDescending</span>)&#123;</span><br><span class="line">                minValue = eachValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取数组"><a href="#获取数组" class="headerlink" title="获取数组"></a>获取数组</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 Array中每个对象的keyPath对应值 组成数组</span></span><br><span class="line"><span class="comment">// @unionOfObjects.keyPath</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)_unionOfObjectsForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *unionArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="keyword">self</span>.count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i=<span class="number">0</span>; i&lt;<span class="keyword">self</span>.count; ++i) &#123;</span><br><span class="line">        <span class="keyword">id</span> eachValue = [<span class="keyword">self</span> _valueForKeyPath:keyPath ofObjectAtIndex:i];</span><br><span class="line">        <span class="keyword">if</span> (eachValue) &#123;</span><br><span class="line">            [unionArray addObject:eachValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取去重数组"><a href="#获取去重数组" class="headerlink" title="获取去重数组"></a>获取去重数组</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 Array中每个对象的keyPath对应值 组成去重数组</span></span><br><span class="line"><span class="comment">// @distinctUnionOfObjects.keyPath</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)_distinctUnionOfObjectsForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *unionArray = [<span class="keyword">self</span> _unionOfObjectsForKeyPath:keyPath];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithArray:unionArray].allObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取成员数组"><a href="#获取成员数组" class="headerlink" title="获取成员数组"></a>获取成员数组</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 Array中每个对象的keyPath对应数组的每个成员 组成数组 这里每个keyPath对应值是也是数组，获取的是每个数组展开后组成的总数组</span></span><br><span class="line"><span class="comment">// @unionOfArrays.keyPath</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)_unionOfArraysForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *unionArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="keyword">self</span>.count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i=<span class="number">0</span>; i&lt;<span class="keyword">self</span>.count; ++i) &#123;</span><br><span class="line">        <span class="keyword">id</span> eachValue = [<span class="keyword">self</span> _valueForKeyPath:keyPath ofObjectAtIndex:i];</span><br><span class="line">        <span class="keyword">if</span> (eachValue) &#123;</span><br><span class="line">            [unionArray addObjectsFromArray:eachValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取去重的成员数组"><a href="#获取去重的成员数组" class="headerlink" title="获取去重的成员数组"></a>获取去重的成员数组</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 Array中每个对象的keyPath对应数组的每个成员 组成的去重复数组.</span></span><br><span class="line"><span class="comment">// @distinctUnionOfArrays.keyPath</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)_distinctUnionOfArraysForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *unionArray = [<span class="keyword">self</span> _unionOfArraysForKeyPath:keyPath];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithArray:unionArray].allObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取集合数组"><a href="#获取集合数组" class="headerlink" title="获取集合数组"></a>获取集合数组</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 Array中每个对象的keyPath对应集合的每个成员 组成的数组. 这里每个keyPath对应值是是集合，获取的是每个集合展开后组成的总数组</span></span><br><span class="line"><span class="comment">// @unionOfSets.keyPath</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)_unionOfSetsForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *unionArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="keyword">self</span>.count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i=<span class="number">0</span>; i&lt;<span class="keyword">self</span>.count; ++i) &#123;</span><br><span class="line">        <span class="keyword">id</span> eachValue = [<span class="keyword">self</span> _valueForKeyPath:keyPath ofObjectAtIndex:i];</span><br><span class="line">        <span class="keyword">if</span> (eachValue) &#123;</span><br><span class="line">            [unionArray addObjectsFromArray:[eachValue allObjects]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取去重的集合数组"><a href="#获取去重的集合数组" class="headerlink" title="获取去重的集合数组"></a>获取去重的集合数组</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 Array中每个对象的keyPath对应集合的每个成员 组成的去重复数组.</span></span><br><span class="line"><span class="comment">// @distinctUnionOfSets.keyPath</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)_distinctUnionOfSetsForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="built_in">NSMutableSet</span> *unionSet = [<span class="built_in">NSMutableSet</span> setWithCapacity:<span class="keyword">self</span>.count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i=<span class="number">0</span>; i&lt;<span class="keyword">self</span>.count; ++i) &#123;</span><br><span class="line">        <span class="keyword">id</span> eachValue = [<span class="keyword">self</span> _valueForKeyPath:keyPath ofObjectAtIndex:i];</span><br><span class="line">        <span class="keyword">if</span> (eachValue) &#123;</span><br><span class="line">            [unionSet unionSet:eachValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet.allObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NSSet的KVC"><a href="#NSSet的KVC" class="headerlink" title="NSSet的KVC"></a>NSSet的KVC</h2><p>与NSArray的逻辑基本保持一致。</p><h2 id="NSOrderedSet的KVC"><a href="#NSOrderedSet的KVC" class="headerlink" title="NSOrderedSet的KVC"></a>NSOrderedSet的KVC</h2><p>与NSArray的逻辑基本保持一致。</p><h2 id="NSDictionary的KVC"><a href="#NSDictionary的KVC" class="headerlink" title="NSDictionary的KVC"></a>NSDictionary的KVC</h2><p>与NSArray相比，主要区别在于：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">- (id)<span class="symbol">valueForKey:</span>(NSString *)key &#123;</span><br><span class="line">    NSString *operationKey = <span class="literal">nil</span>;</span><br><span class="line">    /<span class="regexp">/ key中包含'@字符', 且'@字符'在第0位, 如 @"@count"</span></span><br><span class="line"><span class="regexp">    if(key.length &amp;&amp; [key characterAtIndex:0] == '@' &amp;&amp; (operationKey = [key substringWithRange:NSMakeRange(1, key.length - 1)])) &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 此时, operationKey为 @"count"</span></span><br><span class="line"><span class="regexp">        return [super valueForKey:operationKey];</span></span><br><span class="line"><span class="regexp">    &#125; else &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 没有'@字符', 走字典的objectForKey逻辑</span></span><br><span class="line"><span class="regexp">        return [self objectForKey:key];</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>valueForKey:</code>取值逻辑多了对<code>@</code>字符的处理。</p><p><code>valueForKeyPath:</code>与NSArray的逻辑一致。</p><h1 id="五、其他分类的KVC"><a href="#五、其他分类的KVC" class="headerlink" title="五、其他分类的KVC"></a>五、其他分类的KVC</h1><h2 id="NSMutableDictionary的KVC"><a href="#NSMutableDictionary的KVC" class="headerlink" title="NSMutableDictionary的KVC"></a>NSMutableDictionary的KVC</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@implementation</span> NSMutableDictionary (NSKeyValueCoding)</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">setValue:</span>(id)value <span class="string">forKey:</span>(NSString *)key &#123;</span><br><span class="line">    <span class="keyword">if</span>(value) &#123;</span><br><span class="line">        [self <span class="string">setObject:</span>value <span class="string">forKey:</span>key];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [self <span class="string">removeObjectForKey:</span>key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure><p>相比主类增加的特性是：在<code>NSMutableDictionary</code>中，如果设置的<code>value</code>为空，则自动将<code>key</code>对应的<code>value</code>移除。</p><h2 id="NSUserDefaults的KVC"><a href="#NSUserDefaults的KVC" class="headerlink" title="NSUserDefaults的KVC"></a>NSUserDefaults的KVC</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSUserDefaults</span> (<span class="title">NSKeyValueCoding</span>)</span></span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *subKey = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span>(key.length &amp;&amp; [key characterAtIndex:<span class="number">0</span>] == <span class="string">'@'</span> &amp;&amp; (subKey = [key substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">1</span>, key.length - <span class="number">1</span>)])) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> valueForKey:subKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> objectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span>(value) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setObject:value forKey:key];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>整合了<code>NSDictionary</code>与<code>NSMutableDictionary</code>的特色。</p><ol><li>增加了对<code>@</code>字符的处理。</li><li>如果设置的<code>value</code>为空，则自动将<code>key</code>对应的<code>value</code>移除。</li></ol><h2 id="NSNull的KVC"><a href="#NSNull的KVC" class="headerlink" title="NSNull的KVC"></a>NSNull的KVC</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSNull</span> (<span class="title">NSKeyValueCoding</span>)</span></span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对于<code>NSNull</code>来说，无论怎么设值，取出来的值总是<code>NSNull</code>对象。</p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>纵观全流程，使用KVC与直接使用存取器相比，速度方面稍有逊色，揣测主要原因如下：</p><ol><li>字符串处理。尤其是含有键路径的时候，使用到递归（函数调用栈）。（当然，含有<code>@</code>字符的集合运算符也算。）</li><li>方法查找。流程颇多，尽管有使用<code>CFSet</code>作为缓存。</li><li>装箱拆箱。KVC要求设值参数和取值参数均为对象，这就需要一般值类型和对象类型的相互转换。</li></ol><p>这也是为啥现在字典转模型都不使用KVC了，参见<a href="https://blog.chenyalun.com/2018/12/20/读「YYModel」/">《读YYModel》</a>。</p><p>KVC并没有那么高性能，那么就无用武之地了吗？非也。</p><p><strong>1.访问私有成员变量</strong><br>对于只给出存取方法的对象，可以使用KVC直接访问私有成员变量。不过可能会破坏封装性，毕竟人家没暴露私有成员变量说明不想让人访问。更多的其实是体现在对系统库上访问上，“一不留神”就用到私有API了，我是乖孩子，不敢这么用，万一被苹果发现整个手百App就要被打回了。。。不过非私有API倒也可以尝试下，<a href="https://blog.chenyalun.com/2019/04/25/读「FDFullscreenPopGesture」/">FDFullscreenPopGesture</a>就用到了私有成员变量，极其巧妙地解决了全屏侧滑的问题。</p><p><strong>2.集合操作</strong><br>在文章的第四部分【集合对象的KVC】，就已经描述过，求和、求平均值、去重巴拉巴拉，聊胜于无。</p><p><strong>3.JSON解析</strong><br>前些日子，图搜进行框架改版，下发接口需要完全重构。这可是个危险的工作，今年后端已经出现两次问题了，主要是字段的类型出现错误，造成端启动的Crash。端上做了大量的防护工作，防不胜防，而且代码越来越难看。于是我想到了使用KVC解析字段，重新整理现有逻辑，脱敏后大致是这样：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">handleResponse:</span>(NSDictionary *)response &#123;</span><br><span class="line">    <span class="keyword">if</span> (![response <span class="string">isKindOfClass:</span>NSDictionary.<span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理苹果业务</span></span><br><span class="line">    [self <span class="string">handleAppleConfigWithResponse:</span>[response <span class="string">valueForKeyPath:</span>@<span class="string">"dataset.config1.apple"</span>]];</span><br><span class="line">    <span class="comment">// 处理香蕉业务</span></span><br><span class="line">    [self <span class="string">handleBananaConfigWithResponse:</span>[response <span class="string">valueForKeyPath:</span>@<span class="string">"dataset.config2.banana"</span>]];</span><br><span class="line">    <span class="comment">// 处理橘子业务</span></span><br><span class="line">    [self <span class="string">handleOrangeConfigWithResponse:</span>[response <span class="string">valueForKeyPath:</span>@<span class="string">"dataset.config3.orange"</span>]];</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用keyPath对应到具体的处理逻辑，不同字段之间逻辑隔离，一个字段出错，并不影响其他字段；字段、方法、逻辑一一对应，后期增加或者删减很方便，新同学熟悉业务逻辑也清晰明了；response是字典，不会出现<code>valueForUndefinedKey</code>的异常。在每条处理逻辑中做类型保护工作，方便review，不会遗漏。</p><hr><p>强烈建议阅读：</p><blockquote><p><a href="https://myzerone.com/posts/2016/10/20/KVC(Key-Value-Coding)/" target="_blank" rel="noopener">https://myzerone.com/posts/2016/10/20/KVC(Key-Value-Coding)/</a><br><a href="https://objccn.io/issue-7-3/" target="_blank" rel="noopener">KVC 和 KVO</a></p></blockquote><p>源码来自：<a href="https://github.com/renjinkui2719/DIS_KVC_KVO" target="_blank" rel="noopener">https://github.com/renjinkui2719/DIS_KVC_KVO</a> 。感谢作者。</p><blockquote><p>参考资料<br><a href="https://nshipster.cn/kvc-collection-operators/" target="_blank" rel="noopener">KVC Collection Operators</a><br><a href="https://www.jianshu.com/p/a50ea091e1f4" target="_blank" rel="noopener">iOS KVC</a><br><a href="http://hufeng825.github.io/2013/09/23/ios33/" target="_blank" rel="noopener">iOS开发之你真的了解了KVC吗？</a><br><a href="https://www.jianshu.com/p/938855e842e4" target="_blank" rel="noopener">KVC集合操作符</a><br><a href="https://suhou.github.io/2017/09/29/KVC原理小记/" target="_blank" rel="noopener">KVC原理小记</a><br><a href="http://blog.cocoabit.com/ios-settter-benchmark/" target="_blank" rel="noopener">iOS 对象的 setter 方法性能测试</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; KVC源码阅读。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>读「FDFullscreenPopGesture」</title>
    <link href="http://blog.chenyalun.com/2019/04/25/%E8%AF%BB%E3%80%8CFDFullscreenPopGesture%E3%80%8D/"/>
    <id>http://blog.chenyalun.com/2019/04/25/读「FDFullscreenPopGesture」/</id>
    <published>2019-04-25T11:52:23.000Z</published>
    <updated>2019-09-23T09:13:10.739Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2019.5.29 修改Method Swizzling部分内容</p></blockquote><p></p><p align="center"> 优雅地开启全屏侧滑手势。 </p><br><a id="more"></a><p></p><h2 id="一、使用"><a href="#一、使用" class="headerlink" title="一、使用"></a>一、使用</h2><p>作者给UINavigationController和UIViewController都添加了分类，并进行了默认的参数设置，因此不做任何配置就能拥有这个功能。</p><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p>作者通过方法交换，hook到系统原生push方法中的手势中的target和动画调用selector，创建自己的UIPanGestureRecognizer，并设置它的target和selector。</p><h2 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h2> <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> UINavigationController (FDFullscreenPopGesture)</span><br><span class="line"><span class="comment">// 获取重新实现的侧滑返回手势对象</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong, readonly) UIPanGestureRecognizer *fd_fullscreenPopGestureRecognizer;</span><br><span class="line"><span class="comment">// 是否允许视图控制器单独管理它对应的NavigationBar显示与隐藏.默认是YES</span></span><br><span class="line"><span class="comment">// 这个需要配合视图控制器的fd_prefersNavigationBarHidden属性来使用</span></span><br><span class="line"><span class="comment">// 也就是说如果把这个属性设置为NO, 视图控制器对应的导航栏的隐藏与否不由视图控制器决定</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) BOOL fd_viewControllerBasedNavigationBarAppearanceEnabled;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="variable">@interface</span> UIViewController (FDFullscreenPopGesture)</span><br><span class="line"><span class="comment">// 是否禁用全屏侧滑手势(默认NO)</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) BOOL fd_interactivePopDisabled;</span><br><span class="line"><span class="comment">// 表明当前控制器的导航栏是显示还是隐藏, 默认NO (显示导航栏)</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) BOOL fd_prefersNavigationBarHidden;</span><br><span class="line"><span class="comment">// 设置能够响应侧滑的最大边界(距离)</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) CGFloat fd_interactivePopMaxAllowedInitialDistanceToLeftEdge;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><h2 id="四、源码阅读"><a href="#四、源码阅读" class="headerlink" title="四、源码阅读"></a>四、源码阅读</h2><h3 id="FDFullscreenPopGestureRecognizerDelegate"><a href="#FDFullscreenPopGestureRecognizerDelegate" class="headerlink" title="_FDFullscreenPopGestureRecognizerDelegate"></a>_FDFullscreenPopGestureRecognizerDelegate</h3><p><code>_FDFullscreenPopGestureRecognizerDelegate</code>对象。遵循<code>UIGestureRecognizerDelegate</code>协议，主要用于决定控制器是否能响应手势。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_FDFullscreenPopGestureRecognizerDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">UIGestureRecognizerDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UINavigationController</span> *navigationController;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_FDFullscreenPopGestureRecognizerDelegate</span></span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIPanGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">    <span class="comment">// 栈的最顶层, 不需要响应手势</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.navigationController.viewControllers.count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开了禁用手势的开关</span></span><br><span class="line">    <span class="built_in">UIViewController</span> *topViewController = <span class="keyword">self</span>.navigationController.viewControllers.lastObject;</span><br><span class="line">    <span class="keyword">if</span> (topViewController.fd_interactivePopDisabled) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超过自己设置的left edge</span></span><br><span class="line">    <span class="built_in">CGPoint</span> beginningLocation = [gestureRecognizer locationInView:gestureRecognizer.view];</span><br><span class="line">    <span class="built_in">CGFloat</span> maxAllowedInitialDistance = topViewController.fd_interactivePopMaxAllowedInitialDistanceToLeftEdge;</span><br><span class="line">    <span class="keyword">if</span> (maxAllowedInitialDistance &gt; <span class="number">0</span> &amp;&amp; beginningLocation.x &gt; maxAllowedInitialDistance) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在执行Transition动画</span></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="keyword">self</span>.navigationController valueForKey:<span class="string">@"_isTransitioning"</span>] boolValue]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手机横屏状态下, 适配侧滑方向</span></span><br><span class="line">    <span class="comment">// It tells you how far the touch moved since it was last reset. It resets when the touch goes down or if you reset it yourself.</span></span><br><span class="line">    <span class="built_in">CGPoint</span> translation = [gestureRecognizer translationInView:gestureRecognizer.view];</span><br><span class="line">    <span class="built_in">BOOL</span> isLeftToRight = [<span class="built_in">UIApplication</span> sharedApplication].userInterfaceLayoutDirection == <span class="built_in">UIUserInterfaceLayoutDirectionLeftToRight</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> multiplier = isLeftToRight ? <span class="number">1</span> : - <span class="number">1</span>; <span class="comment">// 只能是从左向右滑</span></span><br><span class="line">    <span class="keyword">if</span> ((translation.x * multiplier) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="UIViewController-FDFullscreenPopGesturePrivate"><a href="#UIViewController-FDFullscreenPopGesturePrivate" class="headerlink" title="UIViewController (FDFullscreenPopGesturePrivate)"></a>UIViewController (FDFullscreenPopGesturePrivate)</h3><p>UIViewController的分类。给其添加关联属性<code>fd_willAppearInjectBlock</code>。hook <code>viewWillAppear</code>方法并在其中调用<code>fd_willAppearInjectBlock</code>回调，hook <code>viewWillDisappear</code>方法，并在其中根据控制器的<code>fd_prefersNavigationBarHidden</code>属性来设置状态栏的显示与否。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^_FDViewControllerWillAppearInjectBlock)(<span class="built_in">UIViewController</span> *viewController, <span class="built_in">BOOL</span> animated);</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewController</span> (<span class="title">FDFullscreenPopGesturePrivate</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) _FDViewControllerWillAppearInjectBlock fd_willAppearInjectBlock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">FDFullscreenPopGesturePrivate</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">// 方法交换, viewWillAppear和fd_viewWillAppear互换, viewWillDisappear和fd_viewWillDisappear互换</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Method viewWillAppear_originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewWillAppear:));</span><br><span class="line">        Method viewWillAppear_swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(fd_viewWillAppear:));</span><br><span class="line">        method_exchangeImplementations(viewWillAppear_originalMethod, viewWillAppear_swizzledMethod);</span><br><span class="line">    </span><br><span class="line">        Method viewWillDisappear_originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewWillDisappear:));</span><br><span class="line">        Method viewWillDisappear_swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(fd_viewWillDisappear:));</span><br><span class="line">        method_exchangeImplementations(viewWillDisappear_originalMethod, viewWillDisappear_swizzledMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fd_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="comment">// 主类的实现 Forward to primary implementation.</span></span><br><span class="line">    [<span class="keyword">self</span> fd_viewWillAppear:animated];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.fd_willAppearInjectBlock) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fd_willAppearInjectBlock(<span class="keyword">self</span>, animated);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fd_viewWillDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="comment">// Forward to primary implementation.</span></span><br><span class="line">    [<span class="keyword">self</span> fd_viewWillDisappear:animated];</span><br><span class="line">    <span class="comment">// 延迟为0相当于直接调用异步</span></span><br><span class="line">    <span class="comment">// dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;);</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">UIViewController</span> *viewController = <span class="keyword">self</span>.navigationController.viewControllers.lastObject;</span><br><span class="line">        <span class="comment">// viewController存在而且它的fd_prefersNavigationBarHidden为NO, 把NavigationBar显示出来</span></span><br><span class="line">        <span class="keyword">if</span> (viewController &amp;&amp; !viewController.fd_prefersNavigationBarHidden) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.navigationController setNavigationBarHidden:<span class="literal">NO</span> animated:<span class="literal">NO</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (_FDViewControllerWillAppearInjectBlock)fd_willAppearInjectBlock &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFd_willAppearInjectBlock:(_FDViewControllerWillAppearInjectBlock)block &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(fd_willAppearInjectBlock), block, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="UINavigationController-FDFullscreenPopGesture"><a href="#UINavigationController-FDFullscreenPopGesture" class="headerlink" title="UINavigationController (FDFullscreenPopGesture)"></a>UINavigationController (FDFullscreenPopGesture)</h3><p>UINavigationController的分类。hook<code>pushViewController:animated:</code>方法，给响应push手势的view添加自定义的<code>fd_fullscreenPopGestureRecognizer</code>手势。当然，<code>fd_fullscreenPopGestureRecognizer</code>的target和selector与push原生手势的target及selector保持一致。除此之外，<code>fd_fullscreenPopGestureRecognizer</code>手势的代理是上面的<code>_FDFullscreenPopGestureRecognizerDelegate</code>对象，目的是决定是否响应手势。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UINavigationController</span> (<span class="title">FDFullscreenPopGesture</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="comment">// Inject "-pushViewController:animated:"</span></span><br><span class="line">    <span class="comment">// 交换pushViewController与fd_pushViewController</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(pushViewController:animated:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(fd_pushViewController:animated:);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BOOL</span> success = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fd_pushViewController:(<span class="built_in">UIViewController</span> *)viewController</span><br><span class="line">                     animated:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="comment">// 保证view只添加一次fd_fullscreenPopGestureRecognizer手势</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.interactivePopGestureRecognizer.view.gestureRecognizers containsObject:<span class="keyword">self</span>.fd_fullscreenPopGestureRecognizer]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Add our own gesture recognizer to where the onboard screen edge pan gesture recognizer is attached to.</span></span><br><span class="line">        [<span class="keyword">self</span>.interactivePopGestureRecognizer.view addGestureRecognizer:<span class="keyword">self</span>.fd_fullscreenPopGestureRecognizer];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取私有变量target和selector</span></span><br><span class="line">        <span class="built_in">NSArray</span> *internalTargets = [<span class="keyword">self</span>.interactivePopGestureRecognizer valueForKey:<span class="string">@"targets"</span>];</span><br><span class="line">        <span class="keyword">id</span> internalTarget = [internalTargets.firstObject valueForKey:<span class="string">@"target"</span>];</span><br><span class="line">        SEL internalAction = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"handleNavigationTransition:"</span>);</span><br><span class="line">        <span class="comment">// 设置滑动手势的代理</span></span><br><span class="line">        <span class="keyword">self</span>.fd_fullscreenPopGestureRecognizer.delegate = <span class="keyword">self</span>.fd_popGestureRecognizerDelegate;</span><br><span class="line">        [<span class="keyword">self</span>.fd_fullscreenPopGestureRecognizer addTarget:internalTarget action:internalAction];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 禁用原生的手势</span></span><br><span class="line">        <span class="keyword">self</span>.interactivePopGestureRecognizer.enabled = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理navigation bar 的显示与隐藏</span></span><br><span class="line">    [<span class="keyword">self</span> fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:viewController];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用原来的方法实现(加一个判断, 避免重复push)</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.viewControllers containsObject:viewController]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> fd_pushViewController:viewController animated:animated];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:(<span class="built_in">UIViewController</span> *)appearingViewController &#123;</span><br><span class="line">    <span class="comment">// 如果fd_viewControllerBasedNavigationBarAppearanceEnabled设置为NO, 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.fd_viewControllerBasedNavigationBarAppearanceEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配合fd_prefersNavigationBarHidden来使用</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    _FDViewControllerWillAppearInjectBlock block = ^(<span class="built_in">UIViewController</span> *viewController, <span class="built_in">BOOL</span> animated) &#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        <span class="keyword">if</span> (strongSelf) &#123;</span><br><span class="line">            [strongSelf setNavigationBarHidden:viewController.fd_prefersNavigationBarHidden animated:animated];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置appearingViewController、disappearingViewController的fd_willAppearInjectBlock</span></span><br><span class="line">    appearingViewController.fd_willAppearInjectBlock = block;</span><br><span class="line">    <span class="built_in">UIViewController</span> *disappearingViewController = <span class="keyword">self</span>.viewControllers.lastObject;</span><br><span class="line">    <span class="keyword">if</span> (disappearingViewController &amp;&amp; !disappearingViewController.fd_willAppearInjectBlock) &#123;</span><br><span class="line">        disappearingViewController.fd_willAppearInjectBlock = block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (_FDFullscreenPopGestureRecognizerDelegate *)fd_popGestureRecognizerDelegate &#123;</span><br><span class="line">    _FDFullscreenPopGestureRecognizerDelegate *delegate = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">    <span class="comment">// 只初始化delegate一次</span></span><br><span class="line">    <span class="keyword">if</span> (!delegate) &#123;</span><br><span class="line">        delegate = [[_FDFullscreenPopGestureRecognizerDelegate alloc] init];</span><br><span class="line">        delegate.navigationController = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, _cmd, delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIPanGestureRecognizer</span> *)fd_fullscreenPopGestureRecognizer &#123;</span><br><span class="line">    <span class="built_in">UIPanGestureRecognizer</span> *panGestureRecognizer = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">    <span class="comment">// 只初始化panGestureRecognizer一次</span></span><br><span class="line">    <span class="keyword">if</span> (!panGestureRecognizer) &#123;</span><br><span class="line">        panGestureRecognizer = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] init];</span><br><span class="line">        panGestureRecognizer.maximumNumberOfTouches = <span class="number">1</span>;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, _cmd, panGestureRecognizer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> panGestureRecognizer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)fd_viewControllerBasedNavigationBarAppearanceEnabled &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *number = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">    <span class="keyword">if</span> (number) &#123; <span class="comment">// BOOL值被封装成对象了</span></span><br><span class="line">        <span class="keyword">return</span> number.boolValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这一步说明还没有设置过关联属性, 手动设置</span></span><br><span class="line">    <span class="keyword">self</span>.fd_viewControllerBasedNavigationBarAppearanceEnabled = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFd_viewControllerBasedNavigationBarAppearanceEnabled:(<span class="built_in">BOOL</span>)enabled &#123;</span><br><span class="line">    SEL key = <span class="keyword">@selector</span>(fd_viewControllerBasedNavigationBarAppearanceEnabled);</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, key, @(enabled), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="UIViewController-FDFullscreenPopGesture"><a href="#UIViewController-FDFullscreenPopGesture" class="headerlink" title="UIViewController (FDFullscreenPopGesture)"></a>UIViewController (FDFullscreenPopGesture)</h3><p>UIViewController的分类。给其添加关联属性<code>fd_interactivePopDisabled</code>、<code>fd_interactivePopMaxAllowedInitialDistanceToLeftEdge</code>和<code>fd_prefersNavigationBarHidden</code>。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">FDFullscreenPopGesture</span>)</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)fd_interactivePopDisabled &#123;</span><br><span class="line">    <span class="comment">// 关于_cmd: 这行代码等价于 return [objc_getAssociatedObject(self, @selector(fd_interactivePopDisabled)) boolValue];</span></span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) boolValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFd_interactivePopDisabled:(<span class="built_in">BOOL</span>)disabled &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(fd_interactivePopDisabled), @(disabled), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)fd_prefersNavigationBarHidden &#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) boolValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFd_prefersNavigationBarHidden:(<span class="built_in">BOOL</span>)hidden &#123;</span><br><span class="line">    <span class="comment">// 存储的时候需要把基本数据类型包装成对象 @(hidden)</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(fd_prefersNavigationBarHidden), @(hidden), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)fd_interactivePopMaxAllowedInitialDistanceToLeftEdge &#123;</span><br><span class="line"><span class="meta">#if CGFLOAT_IS_DOUBLE // CGFLOAT_IS_DOUBLE宏: 64位下是1 否则0, 特别严谨</span></span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) doubleValue];</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) floatValue];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFd_interactivePopMaxAllowedInitialDistanceToLeftEdge:(<span class="built_in">CGFloat</span>)distance &#123;</span><br><span class="line">    SEL key = <span class="keyword">@selector</span>(fd_interactivePopMaxAllowedInitialDistanceToLeftEdge);</span><br><span class="line">    <span class="comment">// 使用@(MAX(0, distance), 适配distance被外界设置为负值的情况</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, key, @(MAX(<span class="number">0</span>, distance)), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="五、再谈Method-Swizzling"><a href="#五、再谈Method-Swizzling" class="headerlink" title="五、再谈Method Swizzling"></a>五、再谈Method Swizzling</h2><h3 id="实例方法交换"><a href="#实例方法交换" class="headerlink" title="实例方法交换"></a>实例方法交换</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewWillAppear:(<span class="keyword">BOOL)animated </span>&#123;</span><br><span class="line">    [super viewWillAppear:animated]<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"原始的方法实现"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController (MethodSwizzling1)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class="line">        Class cls = [self class]<span class="comment">;</span></span><br><span class="line">        SEL <span class="keyword">originalSel </span>= @selector(viewWillAppear:)<span class="comment">;</span></span><br><span class="line">        SEL <span class="keyword">swizzledSel </span>= @selector(ya1_viewWillAppear:)<span class="comment">;</span></span><br><span class="line">        Method <span class="keyword">originalMethod </span>= class_getInstanceMethod(cls, <span class="keyword">originalSel);</span></span><br><span class="line"><span class="keyword"> </span>       Method <span class="keyword">swizzledMethod </span>= class_getInstanceMethod(cls, <span class="keyword">swizzledSel);</span></span><br><span class="line"><span class="keyword"> </span>       if (class_addMethod(cls, <span class="keyword">originalSel, </span>method_getImplementation(<span class="keyword">swizzledMethod), </span>method_getTypeEncoding(<span class="keyword">swizzledMethod))) </span>&#123;</span><br><span class="line">            class_replaceMethod(cls, <span class="keyword">swizzledSel, </span>method_getImplementation(<span class="keyword">originalMethod), </span>method_getTypeEncoding(<span class="keyword">originalMethod));</span></span><br><span class="line"><span class="keyword"> </span>       &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(<span class="keyword">originalMethod, </span><span class="keyword">swizzledMethod);</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ya1_viewWillAppear:(<span class="keyword">BOOL)animated </span> &#123;</span><br><span class="line">    [self ya1_viewWillAppear:animated]<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"第一次在分类里面互换"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="类方法交换"><a href="#类方法交换" class="headerlink" title="类方法交换"></a>类方法交换</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交换类方法</span></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        SEL originalSel = <span class="meta">@selector(a)</span>;</span><br><span class="line">        SEL swizzledSel = <span class="meta">@selector(b)</span>;</span><br><span class="line">        Class <span class="class"><span class="keyword">class</span> = <span class="title">object_getClass</span></span>(self);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">originalSel);</span></span></span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">swizzledSel);</span></span></span><br><span class="line">        <span class="keyword">if</span> (class_addMethod(<span class="class"><span class="keyword">class</span>, <span class="type">originalSel</span>, <span class="type">method_getImplementation</span></span>(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123;</span><br><span class="line">            class_replaceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">swizzledSel</span>, <span class="type">method_getImplementation</span></span>(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)b &#123;</span><br><span class="line">    NSLog(@<span class="string">"b"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题1：实例方法交换与类方法交换有什么区别？"><a href="#问题1：实例方法交换与类方法交换有什么区别？" class="headerlink" title="问题1：实例方法交换与类方法交换有什么区别？"></a>问题1：实例方法交换与类方法交换有什么区别？</h3><p>没有大的变化，唯一的区别在于获取方法所属的对象上，一个获取的是类对象一个获取的是元类对象。即一个是<code>[self class]</code>或者说<code>[self self]</code>，一个是<code>object_getClass(self)</code>（在类方法load中调用的）。<br>为什么会有这种区别？原因在于，实例方法存储在类对象中，类方法存储在元类对象中。</p><p>再一个，看看<code>class</code>的实现：</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">+ (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上许多文章这么说的：</p><blockquote><p>object_getClass与self.class的区别<br>self.class:当self是实例对象的时候，返回的是类对象，否则则返回自身。<br>object_getClass:获得的是isa的指向</p></blockquote><p>这个“返回自身”很含糊。</p><p><code>object_getClass()</code>获取isa指向毋庸置疑。实例对象的isa指向类对象，类对象的isa指向元类对象，元类对象的isa指向根元类，根元类的isa指向它自己，耳熟能详。</p><p>关键是<code>class</code>，self指向了消息的接收者（“the object that’s received this message”），很自然地，实例方法的消息接收者是实例对象，类方法的消息接收者是类对象。根据代码实现来看，实例方法调用<code>class</code>是获取实例对象的isa指向，即类对象。而类对象调用<code>class</code>返回的消息接收者自己，<strong>这个“自身”指的就是类对象</strong>。于是，不管是实例对象还是类对象调用<code>class</code>方法，返回的总是类对象。</p><p>同样地，在实例方法的交换中，这几种获取类对象的方式是等价的：</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span> <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">self</span>];</span><br><span class="line"><span class="keyword">Class</span> <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line"><span class="keyword">Class</span> <span class="keyword">class</span> = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure><p>调用<code>self</code>的<code>self</code>方法也没啥奇怪的，源码是这样的：</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">- (id)<span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题2：能否做到实例方法与类方法交换？"><a href="#问题2：能否做到实例方法与类方法交换？" class="headerlink" title="问题2：能否做到实例方法与类方法交换？"></a>问题2：能否做到实例方法与类方法交换？</h3><p>实例方法与实例方法互换、类方法与类方法互换都很容易做到。那一个实例方法与一个类方法互换，或者一个类方法与一个实例方法互换可以做到吗？答案是肯定的。<br>根据上文讨论，关键在于获取方法所属的对象上，即巧妙控制好获取的类对象和元类对象即可。</p><h4 id="（1）实例方法与类方法互换（新的实例方法交换原先的类方法）"><a href="#（1）实例方法与类方法互换（新的实例方法交换原先的类方法）" class="headerlink" title="（1）实例方法与类方法互换（新的实例方法交换原先的类方法）"></a>（1）实例方法与类方法互换（新的实例方法交换原先的类方法）</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">SEL originalSel</span> = @selector(classMethod);</span><br><span class="line"><span class="attribute">SEL swizzledSel</span> = @selector(newInstanceMethod);</span><br><span class="line"><span class="attribute">Class originClass</span> = object_getClass(self);</span><br><span class="line"><span class="attribute">Class swizzleClass</span> = self;</span><br></pre></td></tr></table></figure><h4 id="（2）类方法与实例方法互换（新的类方法交换原先的实例方法）"><a href="#（2）类方法与实例方法互换（新的类方法交换原先的实例方法）" class="headerlink" title="（2）类方法与实例方法互换（新的类方法交换原先的实例方法）"></a>（2）类方法与实例方法互换（新的类方法交换原先的实例方法）</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">SEL originalSel</span> = @selector(instanceMethod);</span><br><span class="line"><span class="attribute">SEL swizzledSel</span> = @selector(newClassMethod);</span><br><span class="line"><span class="attribute">Class originClass</span> = self;</span><br><span class="line"><span class="attribute">Class swizzleClass</span> = object_getClass(self);</span><br></pre></td></tr></table></figure><p>二者的共同实现是这样的：</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">originalMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">(originClass, originalSel)</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">swizzledMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">(swizzleClass, swizzledSel)</span>;</span></span><br><span class="line"><span class="keyword">if</span> (class_addMethod(originClass, originalSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">       class_replaceMethod(originClass, swizzledSel, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span></span><br><span class="line"><span class="comment">&#125;</span> <span class="keyword">else</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">       method_exchangeImplementations(originalMethod, swizzledMethod);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="问题3：方法二次交换是否会影响第一次交换（造成第一次交换失效）？"><a href="#问题3：方法二次交换是否会影响第一次交换（造成第一次交换失效）？" class="headerlink" title="问题3：方法二次交换是否会影响第一次交换（造成第一次交换失效）？"></a>问题3：方法二次交换是否会影响第一次交换（造成第一次交换失效）？</h3><p>比如：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@implementation ViewController (MethodSwizzling2)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class="line">        SEL <span class="keyword">originalSel </span>= @selector(viewWillAppear:)<span class="comment">;</span></span><br><span class="line">        SEL <span class="keyword">swizzledSel </span>= @selector(ya2_viewWillAppear:)<span class="comment">;</span></span><br><span class="line">        Method <span class="keyword">originalMethod </span>= class_getInstanceMethod(self, <span class="keyword">originalSel);</span></span><br><span class="line"><span class="keyword"> </span>       Method <span class="keyword">swizzledMethod </span>= class_getInstanceMethod(self, <span class="keyword">swizzledSel);</span></span><br><span class="line"><span class="keyword"> </span>       if (class_addMethod(self, <span class="keyword">originalSel, </span>method_getImplementation(<span class="keyword">swizzledMethod), </span>method_getTypeEncoding(<span class="keyword">swizzledMethod))) </span>&#123;</span><br><span class="line">            class_replaceMethod(self, <span class="keyword">swizzledSel, </span>method_getImplementation(<span class="keyword">originalMethod), </span>method_getTypeEncoding(<span class="keyword">originalMethod));</span></span><br><span class="line"><span class="keyword"> </span>       &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(<span class="keyword">originalMethod, </span><span class="keyword">swizzledMethod);</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ya2_viewWillAppear:(<span class="keyword">BOOL)animated </span> &#123;</span><br><span class="line">    [self ya2_viewWillAppear:animated]<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"第二次在分类里面互换"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>很明显不会。</p><p>原因: <code>Compile Sources</code>中设定了分类的编译顺序为<code>ViewController+MethodSwizzling.m --&gt; ViewController+MethodSwizzling2.m</code>，<code>load</code>方法的调用顺序也是这样。最新先调用主类的<code>viewWillAppear:</code>方法不必多说，接着调用分类<code>ViewController+MethodSwizzling</code>中的方法互换逻辑，使得第一次方法互换成功。紧接着调用分类<code>ViewController+MethodSwizzling2</code>中的方法互换逻辑，这个不会影响第一次方法互换的逻辑，相当于在第一次的方法互换之后再互换一次。<br><img src="https://image.chenyalun.com/2019/04/23/001.png" style="zoom:50%"></p><p>第一次: <code>ya_viewWillAppear</code>的实现与<code>viewWillAppear</code>的实现互换<br>第二次: <code>ya2_viewWillAppear</code>的实现与<code>ya_viewWillAppear</code>的实现互换，因为<code>viewWillAppear</code>的实现被<code>ya_viewWillAppear</code>代替了。所以主类和各个分类的方法都被清晰地调用了。<br><img src="https://image.chenyalun.com/2019/04/23/002.png" style="zoom:50%"></p><h3 id="问题4：为什么需要class-replaceMethod-函数"><a href="#问题4：为什么需要class-replaceMethod-函数" class="headerlink" title="问题4：为什么需要class_replaceMethod()函数?"></a>问题4：为什么需要class_replaceMethod()函数?</h3><p>原先的方法存在(有实现)，自不必说，使用<code>method_exchangeImplementations()</code>直接交换函数指针即可。<br>那么有个问题，假定原先的方法不存在，那直接使用<code>class_addMethod()</code>函数把swizzledMethod方法的实现“交给了”原先的originalMethod方法，此时原先的originalMethod方法和新的swizzledMethod方法都指向了同一个实现：swizzledMethod方法的实现。进行到这一步足够了，<code>class_addMethod()</code>函数既判断了原先的方法是否实现，倘若未实现又自动把新方法的实现“交给了”它，完全解决了问题，还需要<code>class_replaceMethod()</code>函数做啥?</p><p>首先要明确：<strong><code>class_addMethod()</code>的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。</strong>“原先的方法没有实现”有两种情况，第一种:该方法是仅仅属于这个类的，父类没有。第二种:该方法是继承自这个类的父类的，父类中有实现，而它自己却没有实现。<br>对于第二种情况，倘若仅仅使用<code>class_addMethod()</code>函数而没有使用<code>class_replaceMethod()</code>函数，会造成<strong>“丢失掉原先的父类的实现”</strong>。</p><p>示例代码:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MainObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MainObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)a &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super-main"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AObject继承自MainObject</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AObject</span> : <span class="title">MainObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AObject</span> (<span class="title">Object</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AObject</span> (<span class="title">Object</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        SEL originalSel = <span class="keyword">@selector</span>(a);</span><br><span class="line">        SEL swizzledSel = <span class="keyword">@selector</span>(b);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSel);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>, swizzledSel);</span><br><span class="line">        <span class="keyword">if</span> (class_addMethod(<span class="keyword">self</span>, originalSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123;</span><br><span class="line">            <span class="comment">// 什么也不做</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)b &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"b-method"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">AObject *obj = [AObject new];</span><br><span class="line">[obj performSelector:<span class="keyword">@selector</span>(a)];</span><br><span class="line">[obj performSelector:<span class="keyword">@selector</span>(b)];</span><br></pre></td></tr></table></figure><p>很明显，打印了两次”b-method”。</p><blockquote><p>2019-05-29 20:01:19.934449+0800 Aaron[35973:604269] b-method<br>2019-05-29 20:01:19.934591+0800 Aaron[35973:604269] b-method</p></blockquote><p>而如果添加上<code>class_replaceMethod()</code>函数，先给originalSel添加上swizzledMethod的实现，再把父类的实现originalMethod替换到swizzledSel中，这样父类的实现就会得到调用:</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">///......</span><br><span class="line"><span class="symbol">if</span> (class_addMethod(<span class="keyword">self, </span>originalSel, method_getImplementation(<span class="keyword">swizzledMethod), </span>method_getTypeEncoding(<span class="keyword">swizzledMethod))) </span>&#123;</span><br><span class="line">    class_replaceMethod(<span class="keyword">self, </span><span class="keyword">swizzledSel, </span>method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))<span class="comment">;</span></span><br><span class="line">&#125; <span class="meta">else</span> &#123;</span><br><span class="line">    method_exchangeImplementations(originalMethod, <span class="keyword">swizzledMethod);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">///......</span></span><br></pre></td></tr></table></figure><p>打印：</p><blockquote><p>2019-05-29 20:06:39.298454+0800 Aaron[36191:611275] b-method<br>2019-05-29 20:06:39.298605+0800 Aaron[36191:611275] super-main</p></blockquote><p>因此，当“主类本身没有实现需要替换的方法，而是继承了父类的实现”时，比如一开始的例子<code>viewWillAppear</code>方法，就可以调用到父类的实现，避免出现问题。对于完全“无中生有”的比如<code>aaa</code>方法，用不用<code>class_replaceMethod()</code>都无妨。</p><h3 id="问题5：方法交换的标准姿势为什么是load方法配合dispatch-once？"><a href="#问题5：方法交换的标准姿势为什么是load方法配合dispatch-once？" class="headerlink" title="问题5：方法交换的标准姿势为什么是load方法配合dispatch_once？"></a>问题5：方法交换的标准姿势为什么是load方法配合dispatch_once？</h3><p>常与<code>+ (void)load;</code>方法在一起比较的是<code>+ (void)initialize;</code>方法。<br><strong>为什么是<code>+ (void)load;</code>方法？</strong></p><ol><li><code>+ (void)load;</code>是在该类被加载到Runtime时调用的，在手动实现之后，一定会被调用，且正常情况下只会被调用一次，子类也不会多次调用父类的load方法（因为load方法时通过函数指针直接调用，而普通方法是通过消息机制调用。）。</li><li><code>+ (void)initialize;</code>是在该类收到第一条消息前被调用，如果不向它发送消息（调用类方法或者实例方法），则该方法不会被调用。如果一个子类没有实现<code>+ (void)initialize;</code>方法，那么父类的该方法会被调用多次。</li></ol><p>希望方法交换的逻辑<strong>一定会被执行</strong>，所以选择了load方法。最根本也最具有说服力的原因是initialize是基于消息机制的，如果在主类的initialize方法中实现了方法交换逻辑，在分类中又实现了initialize方法，由于分类中的方法在元类对象方法列表的前面，所以会造成方法交换逻辑并不会生效。而load方法是通过函数指针直接调用，父类、子类、父类的分类和子类的分类的load方法都会被依次调用，同样的情况，方法交换逻辑却依然会生效。再者，假定在父类的initialize方法中实现了方法交换逻辑，子类会调用父类的initialize方法，如果没有使用<code>dispatch_once</code>，会造成方法交换逻辑多次执行。而load方法，不需要也不应该调用<code>[super load]</code>，总而言之就是，“initialize方法会造成方法交换不具备稳定性”。</p><p><strong>为什么是<code>dispatch_once</code>？</strong><br>正常情况下load方法只会被执行一次，但是要考虑手动调用的情况（一般来说不需要手动调用）：<code>[ViewController load];</code>。使用dispatch_once更加完备地保证只执行一次。</p><h2 id="六、自定义侧滑手势"><a href="#六、自定义侧滑手势" class="headerlink" title="六、自定义侧滑手势"></a>六、自定义侧滑手势</h2><p>除了全屏侧滑之外，有些情况下需要自定义侧滑手势，这时可以使用<code>UIScreenEdgePanGestureRecognizer</code>实现。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">UIView</span> *orangeView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="keyword">self</span>.view.bounds];</span><br><span class="line">    orangeView.backgroundColor = <span class="built_in">UIColor</span>.orangeColor;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:orangeView];</span><br><span class="line">    <span class="built_in">UIScreenEdgePanGestureRecognizer</span> *pan = [[<span class="built_in">UIScreenEdgePanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(handlePop:)];</span><br><span class="line">    pan.edges = <span class="built_in">UIRectEdgeLeft</span>;</span><br><span class="line">    [orangeView addGestureRecognizer:pan];</span><br><span class="line">    <span class="keyword">self</span>.orangeView = orangeView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)handlePop:(<span class="built_in">UIScreenEdgePanGestureRecognizer</span> *)pan &#123;</span><br><span class="line">    <span class="keyword">void</span> (^setOriginX)(<span class="built_in">UIView</span> *, <span class="built_in">CGFloat</span>) = ^(<span class="built_in">UIView</span> *view, <span class="built_in">CGFloat</span> x) &#123;</span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.15</span> animations:^&#123;</span><br><span class="line">            <span class="built_in">CGRect</span> frame = view.frame;</span><br><span class="line">            frame.origin.x = x;</span><br><span class="line">            view.frame = frame;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *targetView = pan.view;</span><br><span class="line">    <span class="built_in">CGFloat</span> offsetX = [pan translationInView:targetView].x;</span><br><span class="line">    <span class="keyword">if</span> (pan.state == <span class="built_in">UIGestureRecognizerStateChanged</span>) &#123;</span><br><span class="line">        targetView.center = <span class="built_in">CGPointMake</span>(targetView.center.x + offsetX, targetView.center.y);</span><br><span class="line">        [pan setTranslation:<span class="built_in">CGPointZero</span> inView:targetView.superview];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pan.state == <span class="built_in">UIGestureRecognizerStateEnded</span> || pan.state == <span class="built_in">UIGestureRecognizerStateCancelled</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (targetView.frame.origin.x / targetView.frame.size.width &gt; <span class="number">0.3</span>) &#123;</span><br><span class="line">            setOriginX(targetView, targetView.bounds.size.width);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setOriginX(targetView, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>作为FDFullscreenPopGesture的源码阅读文章，实际上重心却不在它这。拜读下来，其实都是些常见的东西：关联属性，方法交换。其实解决问题最重要的，是思路。不然可能自己写了一大堆代码，也不能很好高效地解决问题。</p><p>以FDFullscreenPopGesture为引子，又重点回顾了方法交换，作为拓展，回答了引出的许多问题，像实例方法与类方法交换完全是脑洞来的，工作中我还没这么用过😂😂。最后简单介绍了UIScreenEdgePanGestureRecognizer，这个很好使的。</p><blockquote><p>参考资料<br><a href="http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/" target="_blank" rel="noopener">一个丝滑的全屏滑动返回手势</a><br><a href="https://www.jianshu.com/p/d39f7d22db6c" target="_blank" rel="noopener">iOS利用Runtime自定义控制器POP手势动画</a><br><a href="https://juejin.im/entry/5bea8d6de51d454fbd6b472f" target="_blank" rel="noopener">iOS-FDFullscreenPopGesture详解</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2019.5.29 修改Method Swizzling部分内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 优雅地开启全屏侧滑手势。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>开源项目：PageMenu</title>
    <link href="http://blog.chenyalun.com/2019/03/21/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9APageMenu/"/>
    <id>http://blog.chenyalun.com/2019/03/21/开源项目：PageMenu/</id>
    <published>2019-03-21T11:42:23.000Z</published>
    <updated>2019-09-16T09:10:17.293Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 一个使用Swift写的PageMenu。 </p><br><a id="more"></a><p></p><p>一个使用Swift写的PageMenu。没有那么多接口，自己可以根据实际需要扩展。写这个的目的一是为了练手，毕竟工作中使用Swift极少，再一个，PageMenu使用场景挺多的，我遇到过好几次，这次做一个总结。</p><p>项目地址:<a href="https://github.com/ChenYalun/PageMenu" target="_blank" rel="noopener">https://github.com/ChenYalun/PageMenu</a></p><h1 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h1><p>MenuStyle: 用于标题的样式配置<br>PageTitleView: 私有的单个标题控件<br>PageTitle: 标题区视图<br>PageContent: 内容区视图<br>PageMenu: 继承自UIViewController的视图控制器，用于连接PageTitle和PageContent<br>UIColor+RGB: 一些对UIColor的拓展，主要是支持RGB的方式设置颜色</p><h1 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h1><h2 id="MenuStyle"><a href="#MenuStyle" class="headerlink" title="MenuStyle"></a>MenuStyle</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuStyle</span>: <span class="type">UIView &#123;</span></span></span><br><span class="line">    <span class="comment">// 标题之间的间距</span></span><br><span class="line">    <span class="keyword">var</span> margin: CGFloat = <span class="number">10</span></span><br><span class="line">    <span class="comment">// 默认颜色</span></span><br><span class="line">    <span class="keyword">var</span> defaultColor = UIColor(r: <span class="number">0</span>, g: <span class="number">0</span>, b: <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 默认字体</span></span><br><span class="line">    <span class="keyword">var</span> defaultFont = UIFont.systemFont(ofSize: <span class="number">17</span>)</span><br><span class="line">    <span class="comment">// 选中态颜色</span></span><br><span class="line">    <span class="keyword">var</span> selectedColor = UIColor(r: <span class="number">239</span>, g: <span class="number">154</span>, b: <span class="number">64</span>)</span><br><span class="line">    <span class="comment">// 选中态字体</span></span><br><span class="line">    <span class="keyword">var</span> selectedFont = UIFont.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指示条高度, 为0表示隐藏</span></span><br><span class="line">    <span class="keyword">var</span> lineHeight: CGFloat = <span class="number">2</span></span><br><span class="line">    <span class="comment">// 指示条宽度, 为0表示自适应</span></span><br><span class="line">    <span class="keyword">var</span> lineWidth: CGFloat = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 指示条颜色, 默认与selectedColor保持一致</span></span><br><span class="line">    <span class="keyword">var</span> lineColor: UIColor?</span><br><span class="line">    <span class="comment">// 是否开启指示条颜色渐变</span></span><br><span class="line">    <span class="keyword">var</span> lineColorGradual = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 指示条圆角</span></span><br><span class="line">    <span class="keyword">var</span> lineCornerRadius: CGFloat = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标题区的frame</span></span><br><span class="line">    <span class="keyword">var</span> pageTitleFrame = CGRect(x: <span class="number">0</span>, y: <span class="number">20</span>, width: UIScreen.main.bounds.width, height: <span class="number">25</span>)</span><br><span class="line">    <span class="comment">// 标题区与内容区的间距</span></span><br><span class="line">    <span class="keyword">var</span> titleContentMargin: CGFloat = <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PageTitle"><a href="#PageTitle" class="headerlink" title="PageTitle"></a>PageTitle</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PageTitleDelegate</span> : <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pageTitleDidSelected</span><span class="params">(pageTitle: PageTitle, pageTitleView: PageTitleView)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标题视图组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageTitleView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    <span class="keyword">var</span> index: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 标题</span></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span>?</span><br><span class="line">    <span class="comment">// 渐变颜色</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span>? &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            label.textColor = color</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 样式</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> style: <span class="type">MenuStyle</span></span><br><span class="line">    <span class="comment">// 选中状态</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> isSelected: <span class="type">Bool</span> = <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123; reloadState() &#125;<span class="comment">// 刷新数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自身宽度</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> width: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title?.size(withAttributes: [<span class="type">NSAttributedString</span>.<span class="type">Key</span>.font: font]).width ?? <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 字体大小</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> font: <span class="type">UIFont</span> &#123; <span class="keyword">return</span> isSelected ? style.selectedFont : style.defaultFont &#125;</span><br><span class="line">    <span class="comment">// 字体颜色</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> fontColor: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> isSelected ? style.selectedColor : style.defaultColor &#125;</span><br><span class="line">    <span class="comment">// 点击回调</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> tapCallBack: ((<span class="number">_</span> view: <span class="type">PageTitleView</span>) -&gt; <span class="type">Void</span>)?</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>()</span><br><span class="line">        <span class="keyword">let</span> gesture = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(action(<span class="number">_</span>:)))</span><br><span class="line">        label.addGestureRecognizer(gesture)</span><br><span class="line">        label.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>?, isSelected: <span class="type">Bool</span>, style: <span class="type">MenuStyle</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.isSelected = isSelected</span><br><span class="line">        <span class="keyword">self</span>.style = style</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>.zero)</span><br><span class="line">        reloadState()</span><br><span class="line">        <span class="keyword">self</span>.addSubview(label)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态链接</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(<span class="number">_</span> tap: UITapGestureRecognizer)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> tapCallBack != <span class="literal">nil</span> &#123;</span><br><span class="line">            tapCallBack!(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷新数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">reloadState</span><span class="params">()</span></span> &#123;</span><br><span class="line">        label.text = title</span><br><span class="line">        label.textColor = fontColor</span><br><span class="line">        label.font = font</span><br><span class="line">        label.sizeToFit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标题视图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageTitle</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">PageTitleDelegate</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> titleList: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> scrollView: <span class="type">UIScrollView</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> scrollView = <span class="type">UIScrollView</span>(frame: bounds)</span><br><span class="line">        scrollView.showsHorizontalScrollIndicator = <span class="literal">false</span></span><br><span class="line">        addSubview(scrollView)</span><br><span class="line">        <span class="keyword">return</span> scrollView</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 指示器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> lineView: <span class="type">UIView</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> lineView = <span class="type">UIView</span>()</span><br><span class="line">        lineView.backgroundColor = menuStyle.lineColor ?? menuStyle.selectedColor</span><br><span class="line">        lineView.layer.cornerRadius = menuStyle.lineCornerRadius</span><br><span class="line">        lineView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">        scrollView.addSubview(lineView)</span><br><span class="line">        <span class="keyword">return</span> lineView</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 样式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> menuStyle: <span class="type">MenuStyle</span></span><br><span class="line">    <span class="comment">// 当前选中标题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentSelectedView: <span class="type">PageTitleView</span>?</span><br><span class="line">    <span class="comment">// 标题列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> titleViewList = [<span class="type">PageTitleView</span>]()</span><br><span class="line">    <span class="keyword">init</span>(frame: <span class="type">CGRect</span>, menuStyle: <span class="type">MenuStyle</span>, titleList: [<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.menuStyle = menuStyle</span><br><span class="line">        <span class="keyword">self</span>.titleList = titleList</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">        setupSubViews()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupSubViews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> totalWidth: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 设置子控件</span></span><br><span class="line">        <span class="keyword">for</span> (idx, title) <span class="keyword">in</span> titleList.enumerated() &#123;</span><br><span class="line">            <span class="keyword">let</span> view = <span class="type">PageTitleView</span>(title: title <span class="keyword">as</span> <span class="type">String</span>, isSelected: <span class="literal">false</span>, style: menuStyle)</span><br><span class="line">            view.index = idx</span><br><span class="line">            titleViewList.append(view)</span><br><span class="line">            <span class="keyword">let</span> x = <span class="type">CGFloat</span>(idx + <span class="number">1</span>) * menuStyle.margin + totalWidth</span><br><span class="line">            view.frame = <span class="type">CGRect</span>(x: x, y: <span class="number">0</span>, width: view.width, height: frame.height - menuStyle.lineHeight)</span><br><span class="line">            totalWidth += view.width</span><br><span class="line">            scrollView.addSubview(view)</span><br><span class="line">            view.tapCallBack = &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] view <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                <span class="keyword">self</span>.changeToSelectedIndex(idx: view.index)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scrollView.contentSize = <span class="type">CGSize</span>(width: totalWidth + <span class="type">CGFloat</span>(titleList.<span class="built_in">count</span> + <span class="number">1</span>) * menuStyle.margin, height: <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 默认选中的索引 0</span></span><br><span class="line">        changeToSelectedIndex()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: 切换过程中需要调用的函数</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PageTitle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">changeToSelectedIndex</span><span class="params">(idx: Int = <span class="number">0</span>, progress: CGFloat = <span class="number">1</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 索引值越界</span></span><br><span class="line">        <span class="keyword">if</span> idx &gt; titleViewList.<span class="built_in">count</span> - <span class="number">1</span> || idx &lt; <span class="number">0</span> || titleViewList.<span class="built_in">count</span> &lt;= <span class="number">0</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> fromView, toView: <span class="type">PageTitleView</span></span><br><span class="line">        <span class="keyword">if</span> currentSelectedView == <span class="literal">nil</span> &#123;</span><br><span class="line">            fromView = titleViewList.first!</span><br><span class="line">            toView = fromView</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fromView = currentSelectedView!</span><br><span class="line">            toView = titleViewList[idx]</span><br><span class="line">            <span class="comment">// 同一个标题</span></span><br><span class="line">            <span class="keyword">if</span> fromView == toView &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> menuStyle.lineHeight != <span class="number">0</span> &#123;</span><br><span class="line">            refreshBottomLineFrame(fromView.frame, toView.frame, progress)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> menuStyle.lineColorGradual &#123;</span><br><span class="line">            refreshTitleViewColor(fromView, toView, progress)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> progress == <span class="number">1</span> &#123;</span><br><span class="line">            refreshTitleViewState(fromView, toView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置指示条frame</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshBottomLineFrame</span><span class="params">(<span class="number">_</span> from: CGRect, <span class="number">_</span> to: CGRect, <span class="number">_</span> progress: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> from = from</span><br><span class="line">        <span class="keyword">var</span> to = to</span><br><span class="line">        <span class="keyword">let</span> lineHeight = menuStyle.lineHeight</span><br><span class="line">        <span class="keyword">let</span> lineWidth = menuStyle.lineWidth</span><br><span class="line">        <span class="keyword">let</span> y = frame.height - lineHeight</span><br><span class="line">        <span class="keyword">let</span> isFixedLineWidth = lineWidth != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> fromWidth = isFixedLineWidth ? lineWidth : from.width</span><br><span class="line">        <span class="keyword">let</span> toWidth = isFixedLineWidth ? lineWidth : to.width</span><br><span class="line">        <span class="keyword">let</span> fromMinX = isFixedLineWidth ? from.midX - lineWidth * <span class="number">0.5</span> : from.minX</span><br><span class="line">        <span class="keyword">let</span> fromMaxX = isFixedLineWidth ? fromMinX + lineWidth : from.maxX</span><br><span class="line">        <span class="keyword">let</span> toMinX = isFixedLineWidth ? to.midX - lineWidth * <span class="number">0.5</span> : to.minX</span><br><span class="line">        <span class="keyword">let</span> toMaxX = isFixedLineWidth ? toMinX + lineWidth : to.maxX</span><br><span class="line">        from = <span class="type">CGRect</span>(x: fromMinX, y: y, width: fromWidth, height: lineHeight)</span><br><span class="line">        to = <span class="type">CGRect</span>(x: toMinX, y: y, width: toWidth, height: lineHeight)</span><br><span class="line">        <span class="keyword">let</span> isToLeft = toMinX &lt; fromMinX <span class="comment">// 向左</span></span><br><span class="line">        <span class="keyword">if</span> progress &lt; <span class="number">0.5</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isToLeft &#123; <span class="comment">// 向左移动</span></span><br><span class="line">                <span class="keyword">let</span> offsetWidth = (fromMinX - toMinX) * <span class="number">2</span> * progress</span><br><span class="line">                lineView.frame = <span class="type">CGRect</span>(x: fromMinX - offsetWidth, y: y, width:  fromMaxX - fromMinX + offsetWidth, height: lineHeight)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> offsetWidth = (toMaxX - fromMaxX) * <span class="number">2</span> * progress</span><br><span class="line">                lineView.frame = <span class="type">CGRect</span>(x: fromMinX, y: y, width:from.width + offsetWidth, height: lineHeight)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isToLeft &#123; <span class="comment">// 向左移动</span></span><br><span class="line">                <span class="keyword">let</span> offsetWidth = (fromMaxX - to.maxX) * (<span class="number">1</span> - (progress - <span class="number">0.5</span>) * <span class="number">2</span>)</span><br><span class="line">                lineView.frame = <span class="type">CGRect</span>(x: toMinX, y: y, width:to.width + offsetWidth, height: lineHeight)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> offsetWidth = (toMinX - fromMinX) * (<span class="number">1</span> - (progress - <span class="number">0.5</span>) * <span class="number">2</span>)</span><br><span class="line">                lineView.frame = <span class="type">CGRect</span>(x: toMinX - offsetWidth, y: y, width:toMaxX - toMinX + offsetWidth, height: lineHeight)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷新标题状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshTitleViewState</span><span class="params">(<span class="number">_</span> fromView: PageTitleView, <span class="number">_</span> toView: PageTitleView)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 更新currentSelectedView</span></span><br><span class="line">        currentSelectedView?.isSelected = <span class="literal">false</span></span><br><span class="line">        toView.isSelected = <span class="literal">true</span></span><br><span class="line">        currentSelectedView = toView</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置标题居中</span></span><br><span class="line">        <span class="keyword">let</span> width = scrollView.bounds.width</span><br><span class="line">        <span class="keyword">let</span> contentWidth = scrollView.contentSize.width</span><br><span class="line">        <span class="keyword">var</span> offsetX = toView.center.x - width * <span class="number">0.5</span></span><br><span class="line">        offsetX = <span class="built_in">max</span>(offsetX, <span class="number">0</span>)</span><br><span class="line">        offsetX = <span class="built_in">min</span>(contentWidth - width, offsetX)</span><br><span class="line">        <span class="keyword">if</span> contentWidth &lt;= width &#123; <span class="comment">// 保持居中</span></span><br><span class="line">            <span class="keyword">let</span> viewWidth = <span class="type">CGFloat</span>(titleViewList.last?.frame.maxX ?? <span class="number">0</span>) - <span class="type">CGFloat</span>(titleViewList.first?.frame.minX ?? <span class="number">0</span>)</span><br><span class="line">            offsetX = -(width - viewWidth) * <span class="number">0.5</span> + menuStyle.margin</span><br><span class="line">        &#125;</span><br><span class="line">        scrollView.setContentOffset(<span class="type">CGPoint</span>(x: offsetX, y: <span class="number">0</span>), animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> delegate != <span class="literal">nil</span> &#123;</span><br><span class="line">            delegate?.pageTitleDidSelected(pageTitle: <span class="keyword">self</span>, pageTitleView: toView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标题颜色渐变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshTitleViewColor</span><span class="params">(<span class="number">_</span> fromView: PageTitleView, <span class="number">_</span> toView: PageTitleView, <span class="number">_</span> progress: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> toRGB = <span class="type">UIColor</span>.rgbValue(menuStyle.selectedColor)</span><br><span class="line">        <span class="keyword">let</span> fromRGB = <span class="type">UIColor</span>.rgbValue(menuStyle.defaultColor)</span><br><span class="line">        <span class="keyword">let</span> deltaRGB = (toRGB.<span class="number">0</span> - fromRGB.<span class="number">0</span>, toRGB.<span class="number">1</span> - fromRGB.<span class="number">1</span>, toRGB.<span class="number">2</span> - fromRGB.<span class="number">2</span>)</span><br><span class="line">        fromView.color = <span class="type">UIColor</span>(r: toRGB.<span class="number">0</span> - deltaRGB.<span class="number">0</span> * progress, g: toRGB.<span class="number">1</span> - deltaRGB.<span class="number">1</span> * progress, b: toRGB.<span class="number">2</span> - deltaRGB.<span class="number">2</span> * progress)</span><br><span class="line">        toView.color = <span class="type">UIColor</span>(r: fromRGB.<span class="number">0</span> + deltaRGB.<span class="number">0</span> * progress, g: fromRGB.<span class="number">1</span> + deltaRGB.<span class="number">1</span> * progress, b: fromRGB.<span class="number">2</span> + deltaRGB.<span class="number">2</span> * progress)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: PageContentDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PageTitle</span> : <span class="title">PageContentDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pageContentDidChange</span><span class="params">(pageContent: PageContent, targetIndex: Int, progress: CGFloat)</span></span> &#123;</span><br><span class="line">        changeToSelectedIndex(idx: targetIndex, progress: progress)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PageContent"><a href="#PageContent" class="headerlink" title="PageContent"></a>PageContent</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PageContentDelegate</span> : <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pageContentDidChange</span><span class="params">(pageContent: PageContent, targetIndex: Int, progress: CGFloat)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageContent</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">PageContentDelegate</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> controllerList: [<span class="type">UIViewController</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> identifier = <span class="string">"PageMenu_CollectionView_Identifier"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> shouldCallDelegate = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> layout = <span class="type">UICollectionViewFlowLayout</span>()</span><br><span class="line">        layout.itemSize = bounds.size</span><br><span class="line">        layout.scrollDirection = .horizontal</span><br><span class="line">        layout.minimumLineSpacing = <span class="number">0</span></span><br><span class="line">        layout.minimumInteritemSpacing = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> collectionView = <span class="type">UICollectionView</span>(frame: bounds, collectionViewLayout: layout)</span><br><span class="line">        collectionView.dataSource = <span class="keyword">self</span> <span class="keyword">as</span> <span class="type">UICollectionViewDataSource</span></span><br><span class="line">        collectionView.delegate = <span class="keyword">self</span> <span class="keyword">as</span> <span class="type">UICollectionViewDelegate</span></span><br><span class="line">        collectionView.showsHorizontalScrollIndicator = <span class="literal">false</span></span><br><span class="line">        collectionView.scrollsToTop = <span class="literal">false</span></span><br><span class="line">        collectionView.isPagingEnabled = <span class="literal">true</span></span><br><span class="line">        collectionView.bounces = <span class="literal">false</span></span><br><span class="line">        collectionView.backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line">        <span class="comment">// 注册cell</span></span><br><span class="line">        collectionView.register(<span class="type">UICollectionViewCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: identifier)</span><br><span class="line">        addSubview(collectionView)</span><br><span class="line">        <span class="keyword">return</span> collectionView</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">init</span>(frame: <span class="type">CGRect</span>, controllerList: [<span class="type">UIViewController</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.controllerList = controllerList</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">        <span class="keyword">self</span>.collectionView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: UICollectionViewDataSource</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PageContent</span> : <span class="title">UICollectionViewDataSource</span>, <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> controllerList.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: identifier, <span class="keyword">for</span>: indexPath)</span><br><span class="line">        <span class="keyword">let</span> view = controllerList[indexPath.row].view!</span><br><span class="line">        view.frame = cell.bounds</span><br><span class="line">        cell.contentView.addSubview(view)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: UIScrollViewDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PageContent</span> : <span class="title">UIScrollViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndDecelerating</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="type">Int</span>(scrollView.contentOffset.x / scrollView.bounds.width)</span><br><span class="line">        currentIndex = index</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillBeginDragging</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">        shouldCallDelegate = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScroll</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !shouldCallDelegate &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> width = scrollView.bounds.width</span><br><span class="line">        <span class="keyword">let</span> offsetX = scrollView.contentOffset.x - <span class="type">CGFloat</span>(currentIndex) * width</span><br><span class="line">        <span class="keyword">let</span> offsetIndex = offsetX &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> progress = <span class="built_in">abs</span>(offsetX) / width</span><br><span class="line">        <span class="keyword">if</span> delegate != <span class="literal">nil</span> &#123;</span><br><span class="line">            delegate?.pageContentDidChange(pageContent: <span class="keyword">self</span>, targetIndex: currentIndex + offsetIndex, progress: progress)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: PageTitleDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PageContent</span> : <span class="title">PageTitleDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">pageTitleDidSelected</span><span class="params">(pageTitle: PageTitle, pageTitleView: PageTitleView)</span></span> &#123;</span><br><span class="line">        shouldCallDelegate = <span class="literal">false</span></span><br><span class="line">        collectionView.scrollToItem(at: <span class="type">IndexPath</span>(item: pageTitleView.index, section: <span class="number">0</span>), at: .<span class="keyword">left</span>, animated: <span class="literal">false</span>)</span><br><span class="line">        currentIndex = pageTitleView.index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PageMenu"><a href="#PageMenu" class="headerlink" title="PageMenu"></a>PageMenu</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageMenu</span> : <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pageTitle: <span class="type">PageTitle</span></span><br><span class="line">    <span class="keyword">var</span> pageContent: <span class="type">PageContent</span></span><br><span class="line">    <span class="keyword">var</span> menuStyle: <span class="type">MenuStyle</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> controllerList: [<span class="type">UIViewController</span>]</span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> menuStyle: <span class="type">MenuStyle</span>, <span class="number">_</span> controllerList: [<span class="type">UIViewController</span>]) &#123;</span><br><span class="line">        <span class="keyword">var</span> titleList = [<span class="type">String</span>]()</span><br><span class="line">        <span class="keyword">for</span> controller <span class="keyword">in</span> controllerList &#123;</span><br><span class="line">            titleList.append(controller.title ?? <span class="string">"null"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.pageTitle = <span class="type">PageTitle</span>(frame: menuStyle.pageTitleFrame, menuStyle: menuStyle, titleList: titleList)</span><br><span class="line">        <span class="keyword">self</span>.pageContent = <span class="type">PageContent</span>(frame: <span class="type">CGRect</span>(x: pageTitle.frame.minX, y: pageTitle.frame.maxY + menuStyle.titleContentMargin, width: pageTitle.frame.width, height: <span class="type">UIScreen</span>.main.bounds.height - pageTitle.frame.height), controllerList: controllerList)</span><br><span class="line">        <span class="keyword">self</span>.menuStyle = menuStyle</span><br><span class="line">        <span class="keyword">self</span>.controllerList = controllerList</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">        configureComponent()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">configureComponent</span><span class="params">()</span></span> &#123;</span><br><span class="line">        view.addSubview(pageTitle)</span><br><span class="line">        view.addSubview(pageContent)</span><br><span class="line">        <span class="keyword">for</span> controller <span class="keyword">in</span> controllerList &#123;</span><br><span class="line">            addChild(controller)</span><br><span class="line">        &#125;</span><br><span class="line">        pageTitle.delegate = pageContent</span><br><span class="line">        pageContent.delegate = pageTitle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UIColor-RGB"><a href="#UIColor-RGB" class="headerlink" title="UIColor+RGB"></a>UIColor+RGB</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(r : <span class="type">CGFloat</span>, g : <span class="type">CGFloat</span>, b : <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(red: r / <span class="number">255.0</span>, green: g / <span class="number">255.0</span>, blue: b / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">rgbValue</span>(<span class="title">_</span> <span class="title">color</span> : <span class="title">UIColor</span>) -&gt; (<span class="title">CGFloat</span>, <span class="title">CGFloat</span>, <span class="title">CGFloat</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> components = color.cgColor.components <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"颜色按照RGB设置"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (components[<span class="number">0</span>] * <span class="number">255</span>, components[<span class="number">1</span>] * <span class="number">255</span>, components[<span class="number">2</span>] * <span class="number">255</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><p>简单配置一下MenuStyle，创建自己的视图控制器，就能直接使用了。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    <span class="selector-tag">var</span> controllerList = [UIViewController]()</span><br><span class="line">    let style: MenuStyle = MenuStyle()</span><br><span class="line">    <span class="comment">// 创建style并配置样式</span></span><br><span class="line">    style<span class="selector-class">.margin</span> = <span class="number">30</span></span><br><span class="line">    style<span class="selector-class">.defaultColor</span> = UIColor(r: <span class="number">135</span>, g: <span class="number">135</span>, <span class="selector-tag">b</span>: <span class="number">135</span>)</span><br><span class="line">    style<span class="selector-class">.selectedColor</span> = UIColor(r: <span class="number">0</span>, g: <span class="number">0</span>, <span class="selector-tag">b</span>: <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 创建控制器</span></span><br><span class="line">    let red = UIViewController()</span><br><span class="line">    red<span class="selector-class">.view</span><span class="selector-class">.backgroundColor</span> = UIColor.red</span><br><span class="line">    red<span class="selector-class">.title</span> = <span class="string">"关注"</span></span><br><span class="line">    let blue = UIViewController()</span><br><span class="line">    blue<span class="selector-class">.view</span><span class="selector-class">.backgroundColor</span> = UIColor.blue</span><br><span class="line">    blue<span class="selector-class">.title</span> = <span class="string">"热门"</span></span><br><span class="line">    controllerList = [red, blue]</span><br><span class="line">    <span class="comment">// 创建PageMenu</span></span><br><span class="line">    let pageMenu = PageMenu(style, controllerList)</span><br><span class="line">    pageMenu<span class="selector-class">.pageTitle</span><span class="selector-class">.backgroundColor</span> = UIColor(r: <span class="number">45</span>, g: <span class="number">184</span>, <span class="selector-tag">b</span>: <span class="number">105</span>)</span><br><span class="line">    addChild(pageMenu)</span><br><span class="line">    view.addSubview(pageMenu.view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、效果"><a href="#四、效果" class="headerlink" title="四、效果"></a>四、效果</h1><p>微博样式：<br><img src="https://image.chenyalun.com/2019/03/22/weibo.gif" style="zoom:60%"></p><p>it之家样式：<br><img src="https://image.chenyalun.com/2019/03/22/ithome.gif" style="zoom:60%"></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>处理起来比较麻烦一点的就是，标题区指示条的frame渐变，要考虑左滑和右滑的情况，还要考虑进度progress的问题。不过还好，仔细想想都能解决的。</p><p>再一个，PageTitle和PageContent之间互相通信的方案，我选择的是代理。PageTitle是PageContent的代理，同时，PageContent又是PageTitle的代理。由PageMenu负责连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 一个使用Swift写的PageMenu。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="开源项目" scheme="http://blog.chenyalun.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>App界面优化Tips</title>
    <link href="http://blog.chenyalun.com/2019/03/15/App%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96Tips/"/>
    <id>http://blog.chenyalun.com/2019/03/15/App界面优化Tips/</id>
    <published>2019-03-15T13:15:23.000Z</published>
    <updated>2019-12-21T07:51:01.424Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> App界面优化的小Tips。</p><br><a id="more"></a><p></p><p>本来这篇文章只是阅读YYAsyncLayer后的体会，后来一再扩充，变成了App界面优化的小Tips。。。</p><h1 id="一、列表视图"><a href="#一、列表视图" class="headerlink" title="一、列表视图"></a>一、列表视图</h1><h2 id="定高Cell"><a href="#定高Cell" class="headerlink" title="定高Cell"></a>定高Cell</h2><h3 id="1，复用"><a href="#1，复用" class="headerlink" title="1，复用"></a>1，复用</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kWBStatusCellIdentifier = <span class="string">@"kWBStatusCellIdentifier"</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView</span><br><span class="line">         cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    WBStatusCell *cell = [tableView dequeueReusableCellWithIdentifier:kWBStatusCellIdentifier forIndexPath:indexPath];</span><br><span class="line">    [cell setLayout:_layouts[indexPath.row]];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准化的写法是这样的。<code>dequeueReusableCellWithIdentifier:forIndexPath:</code>方法比<code>dequeueReusableCellWithIdentifier:</code>方法多了“自动创建”。cell的重用ID最好使用静态常量，尽管直接使用<code>@&quot;kWBStatusCellIdentifier&quot;</code>，编译器层面也会做优化，帮我们生成静态常量，但是意义不一样。</p><p>cell的种类不要太多，尽量通过hidden subview来区别。</p><h3 id="2，设置行高"><a href="#2，设置行高" class="headerlink" title="2，设置行高"></a>2，设置行高</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">_tableView.rowHeight = <span class="number">60</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>由于是固定行高，直接在配置TableView的懒加载中直接设置rowHeight属性即可。如果使用代理，会使TableView多次询问，增加不必要的调用。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">60</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，能使用整数的地方就不要使用小数，<code>60</code>要比<code>60.2</code>更好一点，CPU不喜欢小数。不仅仅指rowHeight这个属性，其他视图的width、height等属性，在满足UE要求的情况下，都可以尽可能地采用整数。</p><h3 id="3，模型生成"><a href="#3，模型生成" class="headerlink" title="3，模型生成"></a>3，模型生成</h3><p>采用MVVM，需要字典转模型；去Model化，需要格式化字典；无论怎样，都要把数据转换成视图喜欢的样子，这些操作就可以放到子线程中进行。尤其是遇到DateFormatter、stringWithFormat这些稍微耗性能的方法，该缓存就缓存，该替换就替换。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">   <span class="comment">// 字典转模型</span></span><br><span class="line">   WBTimelineItem *item = [WBTimelineItem modelWithJSON:data];</span><br><span class="line">   _statuses = item.statuses;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 主线程刷新</span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       [_tableView reloadData];</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4，subviews操作"><a href="#4，subviews操作" class="headerlink" title="4，subviews操作"></a>4，subviews操作</h3><p>1，子视图越少，出现问题的可能性也越小。所以在构思的时候，一个视图能解决的问题，没必要多写几个视图。比如需要在同一行展示内容a和内容b，可以考虑只使用一个Label。<br>2，视图的动态创建和销毁也是很heavily的，考虑设置hidden属性来控制显示和隐藏。<br>3，尽量选用轻量级的控件，不需要用户响应的可以换成CALayer，比如CALayer替代UIImageView：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CALayer</span> *)photoImageViewLayer &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_photoImageViewLayer) &#123;</span><br><span class="line">        _photoImageViewLayer = [[<span class="built_in">CALayer</span> alloc] init];</span><br><span class="line">        _photoImageViewLayer.contentsGravity = <span class="string">@"resizeAspectFill"</span>;</span><br><span class="line">        _photoImageViewLayer.masksToBounds = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _photoImageViewLayer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line">[<span class="keyword">self</span>.photoImageViewLayer yy_setImageWithURL:url</span><br><span class="line">                                    placeholder:<span class="built_in">UIImage</span>.randomColorImage</span><br><span class="line">                                        options:options</span><br><span class="line">                                    completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p><p>但是CALayer不能设置约束，这就需要自己计算frame了。</p><h3 id="5，触发离屏渲染"><a href="#5，触发离屏渲染" class="headerlink" title="5，触发离屏渲染"></a>5，触发离屏渲染</h3><p>离屛渲染需要开辟一块新的缓冲区，在渲染的过程中还会有多次的切换上下文，这些很消耗性能。</p><blockquote><p>如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。</p></blockquote><p>1， layer.cornerRadius + layer.masksToBounds一起设置<br>2， 设置图层阴影layer.shadow<br>3， 设置蒙层layer.mask<br>4， layer.allowsGroupOpacity 设置为YES同时layer.opacity小于1.0<br>5， layer.shouldRasterize设置为YES。<br>开启 Rasterization 后，GPU 只合成一次内容，然后复用合成的结果；合成的内容超过100ms没有使用会从缓存里移除，所以对于不连续使用的内容进行光栅化是既没有意义又浪费资源的，在更新内容时还会产生更多的离屏渲染。对于内容不发生变化的视图，进行光栅化会使原本拖后腿的离屏渲染就成为了助力；如果视图内容是动态变化的，使用这个方案有可能让性能变得更糟。不要过度使用，系统限制缓存的大小为 2.5x screen size，过度使用的话也会造成离屏渲染。（一般用在单独的视图上，而不是cell的layer）<br>6， 使用UIBlurEffect</p><p><a href="https://zhuanlan.zhihu.com/p/72653360" target="_blank" rel="noopener">即刻App</a>的优化思路是这样：<br>1，对于图片的圆角，统一采用“precomposite”的策略，也就是不经由容器来做剪切，而是预先使用CoreGraphics为图片裁剪圆角<br>2，对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的layer盖住四个角，从视觉上制造圆角的效果<br>3，对于view的圆形边框，如果没有backgroundColor，可以放心使用cornerRadius来做<br>4，对于所有的阴影，使用shadowPath来规避离屏渲染<br>5，对于特殊形状的view，使用layer mask并打开shouldRasterize来对渲染结果进行缓存<br>6，对于模糊效果，不采用系统提供的UIVisualEffect，而是另外实现模糊效果（CIGaussianBlur），并手动管理渲染结果</p><h3 id="6，圆角"><a href="#6，圆角" class="headerlink" title="6，圆角"></a>6，圆角</h3><p>“cornerRadius和maskToBounds一起设置会触发离屏渲染”，这句话需要讨论一下了：</p><p>1，UIView这般设置圆角不会产生离屏渲染。<br>2，iOS9.0之后UIImageView中的png图片这般设置圆角不会触发离屏渲染，但是如果UIImageView的backgroundColor不是clearColor或者不是nil，则会触发离屏渲染。</p><p>上面两条是我搜了很多资料发现的，亲自验证了一下，在iOS13上第一条是真的。第二条试着不设置backgroundColor果然也没有出现离屏渲染。但是，是不是从iOS9开始的，我没有真机也没法做判断，而且也没有找到官方的说明。</p><p><strong>下面是之前的UIImageView设置圆角的处理方式</strong><br>直接使用layer.mask来达到圆角效果同样会触发离屏渲染，对于网络图片的圆角处理通常是先下载后圆角化。<br>下载逻辑（以我喜欢的YYWebImage为例）：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">NSString *radiusKey = [url.absoluteString <span class="string">stringByAppendingString:</span>@<span class="string">"radiusCache"</span>];</span><br><span class="line">UIImage *radiusImage = [YYImageCache.sharedCache <span class="string">getImageForKey:</span>radiusKey];</span><br><span class="line"><span class="keyword">if</span> (radiusImage) &#123;</span><br><span class="line">   self.photoImageView.image = radiusImage;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   [YYWebImageManager.sharedManager <span class="string">requestImageWithURL:</span>url <span class="string">options:</span>YYWebImageOptionShowNetworkActivity <span class="string">progress:</span>nil <span class="string">transform:</span>nil <span class="string">completion:</span>^(UIImage *image, NSURL *url, YYWebImageFromType from, YYWebImageStage stage, NSError * error) &#123;</span><br><span class="line">       dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           <span class="keyword">if</span> (!error &amp;&amp; image) &#123;</span><br><span class="line">               [YYImageCache.sharedCache <span class="string">setImage:</span>radiusImage <span class="string">imageData:</span>nil <span class="string">forKey:</span>radiusKey <span class="string">withType:</span>YYImageCacheTypeAll];</span><br><span class="line">               self.photoImageView.image = image.radiusImage;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>图片下载完毕后做圆角处理并保存，但是有几个问题需要思考：<br>1，这张图片的圆角半径在业务上是固定的吗，如果不固定（比如需要10px、20px两种）那就需要存储多份了；<br>2，这张图片的展示效果是否只有圆角一种，是否同时存在有方图和圆角图两种形式？需要保留原图吗；</p><p>这个是使用Core Graphics创建圆角图片的不会触发离屏渲染的示例，可以子线程绘制：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)radiusImage &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</span><br><span class="line">    <span class="built_in">CGFloat</span> radius = <span class="number">100.</span>f; <span class="comment">// 这个度量是图片的，而不是imageView的</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">false</span>, <span class="built_in">UIScreen</span>.mainScreen.scale);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect byRoundingCorners:<span class="built_in">UIRectCornerAllCorners</span> cornerRadii:<span class="built_in">CGSizeMake</span>(radius, radius)];</span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(context, path.CGPath);</span><br><span class="line">    <span class="built_in">CGContextClip</span>(context);</span><br><span class="line">    [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathFillStroke);</span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="7，阴影"><a href="#7，阴影" class="headerlink" title="7，阴影"></a>7，阴影</h3><p>假如需要这么设置阴影效果：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">button.layer.shadowColor </span>= UIColor.<span class="keyword">blackColor.CGColor;</span></span><br><span class="line"><span class="keyword">button.layer.shadowOpacity </span>= <span class="number">0</span>.<span class="number">5</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">button.layer.shadowRadius </span>= <span class="number">10</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">button.layer.shadowOffset </span>= CGSizeMake(<span class="number">10</span>, <span class="number">10</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>只需要再加上一句话就能避免离屏渲染了：<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">button</span>.layer.shadowPath = [UIBezierPath bezierPathWithRect:<span class="keyword">button</span>.bounds].CGPath;</span><br></pre></td></tr></table></figure></p><p>但是有个小问题，如果这个具有阴影效果的视图需要做frame动画，那它的shadow效果是不会改变的，这还得再想办法解决：<a href="https://www.jianshu.com/p/fd0e7709a404" target="_blank" rel="noopener">显式指定shadowPath的动画效果</a>。</p><h2 id="不定高cell"><a href="#不定高cell" class="headerlink" title="不定高cell"></a>不定高cell</h2><p>不定高的cell需要计算cell的高度。有两种方式：一是自己在后台根据模型数据配置子视图的布局，手动计算，并把高度存储到对应的模型中；二是借助自动布局，保证子视图“撑满”cell，自动更新cell的高度。</p><p>如果对性能要求不高，或者开发周期短，可以直接使用Auto Layout，再配合<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell/" target="_blank" rel="noopener">FDTemplateLayoutCell</a>的高度缓存机制，可以说已经很方便了。不然只能自己计算并做缓存处理。</p><h1 id="二、异步渲染"><a href="#二、异步渲染" class="headerlink" title="二、异步渲染"></a>二、异步渲染</h1><p>TableView和CollectionView的优化也可以借助异步渲染，YYAsyncLayer描述了异步渲染的核心原理。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YYAsyncLayer </span>: CALayer</span><br><span class="line"><span class="comment">// Default is YES.</span></span><br><span class="line"><span class="variable">@property</span> BOOL displaysAsynchronously;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@protocol</span> YYAsyncLayerDelegate &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@required</span></span><br><span class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将要绘制、正在绘制、绘制完毕 对应的block</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">YYAsyncLayerDisplayTask </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nullable, nonatomic, copy) void (^willDisplay)(CALayer *layer);</span><br><span class="line"><span class="variable">@property</span> (nullable, nonatomic, copy) void (^display)(CGContextRef context, CGSize size, BOOL(^isCancelled)(void));</span><br><span class="line"><span class="variable">@property</span> (nullable, nonatomic, copy) void (^didDisplay)(CALayer *layer, BOOL finished);</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>视图在初始化过程之前调用UIView类方法layerClass，并且使用返回的类来创建layer对象。通过创建UIView的子类，重写layerClass类函数可以改变创建图层时的默认的CALayer类。在自定义视图对象中，返回一个YYAsyncLayerDisplayTask，这个task承担着绘制的任务。</p><h3 id="异步绘制文字"><a href="#异步绘制文字" class="headerlink" title="异步绘制文字"></a>异步绘制文字</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YALabel</span> : <span class="title">UIView</span> &lt;<span class="title">YYAsyncLayerDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSAttributedString</span> *attributedString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YALabel</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAttributedString:(<span class="built_in">NSAttributedString</span> *)attributedString &#123;</span><br><span class="line">    _attributedString = attributedString;</span><br><span class="line">    <span class="comment">// YYTransaction let you perform a selector once before current runloop sleep.</span></span><br><span class="line">    [[YYTransaction transactionWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(setTextNeedsDisplay)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    [[YYTransaction transactionWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(setTextNeedsDisplay)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTextNeedsDisplay &#123;</span><br><span class="line">    [<span class="keyword">self</span>.layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    <span class="keyword">return</span> YYAsyncLayer.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask &#123;</span><br><span class="line">    YYAsyncLayerDisplayTask *task = [YYAsyncLayerDisplayTask new];</span><br><span class="line">    task.display = ^(<span class="built_in">CGContextRef</span> context, <span class="built_in">CGSize</span> size, <span class="built_in">BOOL</span> (^isCancelled)(<span class="keyword">void</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled() || <span class="keyword">self</span>.attributedString.string.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 修复绘制文字会颠倒</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="keyword">self</span>.bounds.size.height);</span><br><span class="line">            <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="built_in">NSAttributedString</span> *str = <span class="keyword">self</span>.attributedString;</span><br><span class="line">        [str enumerateAttribute:<span class="built_in">NSFontAttributeName</span> inRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, str.length) options:<span class="built_in">NSAttributedStringEnumerationLongestEffectiveRangeNotRequired</span> usingBlock:^(<span class="built_in">UIFont</span> *font, <span class="built_in">NSRange</span> range, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="comment">// 根据字体设置pointSize</span></span><br><span class="line">            <span class="built_in">CGContextSetTextPosition</span>(context, <span class="number">0</span>, font.pointSize);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">// 绘制</span></span><br><span class="line">        <span class="built_in">CTLineRef</span> line = <span class="built_in">CTLineCreateWithAttributedString</span>((__bridge <span class="built_in">CFAttributedStringRef</span>)str);</span><br><span class="line">        <span class="built_in">CTLineDraw</span>(line, context);</span><br><span class="line">        <span class="built_in">CFRelease</span>(line);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用的时候很简单了，设置一个AttributedString即可：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">YALabel *<span class="keyword">label</span><span class="bash"> = [YALabel new];</span></span><br><span class="line"><span class="bash">NSAttributedString *str = [[NSAttributedString alloc] initWithString:@<span class="string">"😀😁🤣😂Label的异步绘制"</span> attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:15]&#125;];</span></span><br><span class="line"><span class="bash">label.attributedString = str;</span></span><br><span class="line"><span class="bash">label.backgroundColor = UIColor.orangeColor;</span></span><br><span class="line"><span class="bash">label.frame = CGRectMake(100, 100, 200, 50);</span></span><br><span class="line"><span class="bash">[self.view addSubview:label];</span></span><br></pre></td></tr></table></figure></p><p>这里的newAsyncDisplayTask比较简单，只绘制了单行文本，如果真的要应用到项目中，可以利用CoreText更加完善些，加上自动换行，自适应size，图文混排等功能。</p><p>有前辈写了一个IM的Demo，里面有用到异步绘制：<a href="https://github.com/Yuzeyang/GCAsyncDisplayDemo，读一读还是很棒的。" target="_blank" rel="noopener">https://github.com/Yuzeyang/GCAsyncDisplayDemo，读一读还是很棒的。</a></p><h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>源码不是很多，就几个文件，但是跟作者的其他框架一样，代码特别优秀。</p><h3 id="YYSentinel"><a href="#YYSentinel" class="headerlink" title="YYSentinel"></a>YYSentinel</h3><p>这是一个线程安全的计数器，内部维护了一个实例变量。如何做到线程安全? 主要是依赖于原子函数<code>OSAtomicIncrement32()</code>。</p><blockquote><p>如果我们想要初始化一个共享的数据结构，然后自动增加某个变量值来标识初始化操作完成，则我们必须使用<code>OSAtomicIncrement32Barrier</code>来确保数据结构的存储操作在变量自动增加前完成。</p></blockquote><p>使用这个类的目的： 标记某个操作是否完成，也即判断或者标记异步渲染操作的完成情况</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;libkern/OSAtomic.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程安全的计数器</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYSentinel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) int32_t value;</span><br><span class="line">- (int32_t)increase;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYSentinel</span> </span>&#123;</span><br><span class="line">    int32_t _value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int32_t)value &#123;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int32_t)increase &#123;</span><br><span class="line">    <span class="keyword">return</span> OSAtomicIncrement32(&amp;_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="YYTransaction"><a href="#YYTransaction" class="headerlink" title="YYTransaction"></a>YYTransaction</h3><p>只有两个方法接口。<br>方法一： 包装<code>target</code>和<code>selector</code>并生成一个<code>YYTransaction</code>对象。<br>方法二： commit这个对象。<br>包装成YYTransaction对象的方法不用多说，其内部使用实例变量引用着传递的参数。<br>最关键的是<code>commit</code>方法。It will perform the selector on the target once before main runloop’s current loop sleep. If the same transaction (same target and same selector) has already commit to runloop in this loop, this method do nothing. 也就是说在Runloop每次休眠之前只调用一次<code>target</code>的<code>selector</code>方法。</p><p>commit方法内部使用transactionSet集合添加了这个<code>YYTransaction</code>对象。作者给Runloop添加了一个observer，在 <code>kCFRunLoopBeforeWaiting</code> 和 <code>kCFRunLoopExit</code>这两种状态下会调用指定的<code>YYRunLoopObserverCallBack()</code>函数。这个函数的作用很简单：逐个遍历transactionSet集合中的所有元素，使其<code>target</code>调用对应的<code>selector</code>。</p><p><code>YYTransaction</code>重写了<code>- (NSUInteger)hash</code>方法和<code>- (BOOL)isEqual:(id)object</code>方法来确定“对象相等”。这保证了Set集合中的元素唯一性。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYTransaction</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (YYTransaction *)transactionWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector;</span><br><span class="line">- (<span class="keyword">void</span>)commit;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYTransaction</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SEL selector;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *transactionSet = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐个遍历transactionSet中的所有元素，使其target调用对应的selector</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> YYRunLoopObserverCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (transactionSet.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">NSSet</span> *currentSet = transactionSet;</span><br><span class="line">    transactionSet = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">    [currentSet enumerateObjectsUsingBlock:^(YYTransaction *transaction, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">        [transaction.target performSelector:transaction.selector];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Runloop处于kCFRunLoopBeforeWaiting或者kCFRunLoopExit的状态的时候调用YYRunLoopObserverCallBack()函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> YYTransactionSetup() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        transactionSet = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> runloop = <span class="built_in">CFRunLoopGetMain</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopObserverRef</span> observer;</span><br><span class="line">        </span><br><span class="line">        observer = <span class="built_in">CFRunLoopObserverCreate</span>(<span class="built_in">CFAllocatorGetDefault</span>(),</span><br><span class="line">                                           kCFRunLoopBeforeWaiting | kCFRunLoopExit,</span><br><span class="line">                                           <span class="literal">true</span>,      <span class="comment">// repeat</span></span><br><span class="line">                                           <span class="number">0xFFFFFF</span>,  <span class="comment">// after CATransaction(2000000)</span></span><br><span class="line">                                           YYRunLoopObserverCallBack, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(runloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">        <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYTransaction</span></span></span><br><span class="line"></span><br><span class="line">+ (YYTransaction *)transactionWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector&#123;</span><br><span class="line">    <span class="keyword">if</span> (!target || !selector) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    YYTransaction *t = [YYTransaction new];</span><br><span class="line">    t.target = target;</span><br><span class="line">    t.selector = selector;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把生成的YYTransaction对象放入transactionSet中</span></span><br><span class="line">- (<span class="keyword">void</span>)commit &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_target || !_selector) <span class="keyword">return</span>;</span><br><span class="line">    YYTransactionSetup();</span><br><span class="line">    [transactionSet addObject:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isEqual: 是通过hash方法来判等的</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)hash &#123;</span><br><span class="line">    <span class="keyword">long</span> v1 = (<span class="keyword">long</span>)((<span class="keyword">void</span> *)_selector);</span><br><span class="line">    <span class="keyword">long</span> v2 = (<span class="keyword">long</span>)_target;</span><br><span class="line">    <span class="keyword">return</span> v1 ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要_target和_selector都一致，就说明'YYTransaction'是同一个</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == object) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (![object isMemberOfClass:<span class="keyword">self</span>.class]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    YYTransaction *other = object;</span><br><span class="line">    <span class="keyword">return</span> other.selector == _selector &amp;&amp; other.target == _target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="YYAsyncLayer"><a href="#YYAsyncLayer" class="headerlink" title="YYAsyncLayer"></a>YYAsyncLayer</h3><p>最后是YYAsyncLayer的实现，最核心的逻辑就在这里了。我一年之前就曾经读过这块源码，当时有好多疑惑，现在再来看，有的疑惑已经解开了，有的还没有，在这记录一下。</p><h4 id="1，子线程的处理"><a href="#1，子线程的处理" class="headerlink" title="1，子线程的处理"></a>1，子线程的处理</h4><p>异步，自然要放到子线程。主队列对应的是主线程，4个不同优先级的全局队列并不对应4个子线程。毅然放在全局队列不太可取，可能会出现App在同一时刻存在几十个线程同时运行、创建、销毁的情况。“当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。”。使用串行队列又无法充分利用多核CPU的资源。作者在YYAsyncLayer中的思路是：创建和 CPU 数量相同的串行queue（最多16个），放到一个数组中，每次从数组中随机获取其中的一个queue。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Global display queue, used for content rendering.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> dispatch_queue_t <span class="title">YYAsyncLayerGetDisplayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_QUEUE_COUNT 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> queueCount;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span> queues[MAX_QUEUE_COUNT];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int32_t</span> counter = <span class="number">0</span>;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 获取运行该进程的系统的处于激活状态的处理器数量, iPhone 6s 是2个</span></span><br><span class="line">        queueCount = (<span class="keyword">int</span>)[NSProcessInfo processInfo].activeProcessorCount;</span><br><span class="line">        queueCount = queueCount &lt; <span class="number">1</span> ? <span class="number">1</span> : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</span><br><span class="line">        <span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; queueCount; i++) &#123;</span><br><span class="line">            <span class="keyword">dispatch_queue_attr_t</span> attr =</span><br><span class="line">            <span class="comment">// QOS_CLASS_USER_INITIATED 用户发起并等待的优先级</span></span><br><span class="line">            dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 创建串行队列</span></span><br><span class="line">            queues[i] = dispatch_queue_create(<span class="string">"com.ibireme.yykit.render"</span>, attr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 大量使用 OSAtomicIncrement32,由于该函数对某个值进行自增计算,而且是线程安全的,所以被用来作为绘制时的标记位(哨兵).异步绘制的关键在于每次调用 setNeedDisplay 时都会将哨兵变量自增,在 display 方法中,根据这个哨兵变量来确定是否继续绘制还是停止绘制.一致则继续绘制, 不一致则停止绘制</span></span><br><span class="line">    <span class="keyword">int32_t</span> cur = OSAtomicIncrement32(&amp;counter); <span class="comment">// counter自增一, 并取出该值,</span></span><br><span class="line">    <span class="keyword">if</span> (cur &lt; <span class="number">0</span>) cur = -cur; <span class="comment">// 啥时候会出现?? counter取INT_MAX的时候出现</span></span><br><span class="line">    <span class="keyword">return</span> queues[(cur) % queueCount]; <span class="comment">// 取余</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> MAX_QUEUE_COUNT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单纯就子线程绘制这个问题而言，思考一下，既然会出现“同一时刻存在几十个线程同时运行、创建、销毁”的情况，那如果直接操作线程呢，直接创建三五个NSThread对象，让它们处理App中的所有异步渲染操作。如果这样的话，就需要对这三五个NSThread对象进行线程保活，保证它们永远存在。再者只能通过performSelector:onThread:进行方法调用（或者再做一个block方式的封装）。<strong>最后也是最重要的是，没办法利用设备多核的优势。</strong>单核中的多线程实际上是每个时间片上只有一个线程在运行，而多核实际上是真的多线程，每一个时间片每个核都有一个线程在执行。dispatch_async是多核级别编程框架调度函数，这才真正决定了为啥要使用GCD。</p><h4 id="2，异步绘制开关控制"><a href="#2，异步绘制开关控制" class="headerlink" title="2，异步绘制开关控制"></a>2，异步绘制开关控制</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写修改CALayer或其子类属性的默认值，key为属性名称，如果没有该属性则返回nil。</span></span><br><span class="line">+ (<span class="keyword">id</span>)defaultValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"displaysAsynchronously"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(<span class="literal">YES</span>); <span class="comment">// 仅仅针对displaysAsynchronously这个属性修改</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> defaultValueForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="comment">// 设置屏幕缩放比例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CGFloat</span> scale; <span class="comment">// global</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        scale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">self</span>.contentsScale = scale;</span><br><span class="line">    <span class="comment">// 计数器, 控制多线程访问</span></span><br><span class="line">    _sentinel = [YYSentinel new];</span><br><span class="line">    <span class="comment">// 默认是YES</span></span><br><span class="line">    _displaysAsynchronously = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>displaysAsynchronously</code>来控制是否开启异步渲染。<br>但是这里有个问题想不通，YYAsyncLayer的init方法中已经初始化<code>_displaysAsynchronously</code>的值为YES了，但是作者又重写defaultValueForKey方法并在其中再次设置displaysAsynchronously属性为YES。这两个方式的效果一样呀，会不会多此一举了呢？</p><h4 id="3，绘制时机"><a href="#3，绘制时机" class="headerlink" title="3，绘制时机"></a>3，绘制时机</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">// layer销毁的时候, 计数器加1, 表示原先的绘制需要取消</span></span><br><span class="line">    [<span class="meta">_sentinel increase</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setNeedsDisplay &#123;</span><br><span class="line">    <span class="comment">// 被标记需要重新绘制, 则取消上次的异步调用</span></span><br><span class="line">    [<span class="meta">self _cancelAsyncDisplay</span>];</span><br><span class="line">    [<span class="meta">super setNeedsDisplay</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reload the content of this layer.</span></span><br><span class="line"><span class="comment">// Subclasses can override this method and use it to set the layer’s contents property directly. You might do this if your custom layer subclass handles layer updates differently.</span></span><br><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="comment">// 这个赋值是因为这样吗??</span></span><br><span class="line">    <span class="comment">// Assigning a value to this property causes the layer to use your image rather than create a separate backing store.</span></span><br><span class="line">    super.contents = super.contents;</span><br><span class="line">    [<span class="meta">self _displayAsync:_displaysAsynchronously</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_cancelAsyncDisplay &#123;</span><br><span class="line">    <span class="comment">// increase增加1, 与目前的不一致了, 表示目前的渲染已取消</span></span><br><span class="line">    [<span class="meta">_sentinel increase</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际的绘制逻辑中，是通过判断计数器<code>_sentinel</code>的值来确定是否取消绘制：<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">YYSentinel *sentinel = <span class="number">_</span>sentinel;</span><br><span class="line">int<span class="number">32_</span>t <span class="keyword">value</span> = sentinel.<span class="keyword">value</span>;</span><br><span class="line">BOOL (^isCancelled)(<span class="keyword">void</span>) = ^BOOL() &#123;</span><br><span class="line">  <span class="comment">// 值相等, 说明正在绘制没有取消, 否则说明已经取消啦</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span> != sentinel.<span class="keyword">value</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>反过来，只需要把计数器的值自增（<code>[_sentinel increase]</code>）就可以表示目前的绘制操作取消了。在Layer销毁的时候（dealloc）和被标记需要重新绘制的时候（setNeedsDisplay）应该取消原先的绘制操作。</p><p>按照苹果的说明，CALayer的子类可以重写display方法并在其中直接设置contents。YYAsyncLayer便在其中做了异步绘制操作。这里的<code>super.contents = super.contents;</code>一句话确实当然没看懂，后来发现也有小伙伴跟我一样没弄明白，然后查阅资料发现了苹果的解释：Assigning a value to this property causes the layer to use your image rather than create a separate backing store.</p><h4 id="4，绘制操作"><a href="#4，绘制操作" class="headerlink" title="4，绘制操作"></a>4，绘制操作</h4><p>最后便是绘制的操作了，写了很详细的注释：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心方法</span></span><br><span class="line">- (<span class="keyword">void</span>)_displayAsync:(<span class="built_in">BOOL</span>)async &#123;</span><br><span class="line">    <span class="comment">// 强引用代理, 避免释放</span></span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span>&lt;YYAsyncLayerDelegate&gt; delegate = (<span class="keyword">id</span>)<span class="keyword">self</span>.delegate;</span><br><span class="line">    <span class="comment">// 获取一个Display Task</span></span><br><span class="line">    YYAsyncLayerDisplayTask *task = [delegate newAsyncDisplayTask];</span><br><span class="line">    <span class="keyword">if</span> (!task.display) &#123; <span class="comment">// 没有需要绘制的内容, 设置contents为空</span></span><br><span class="line">        <span class="keyword">if</span> (task.willDisplay) task.willDisplay(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">self</span>.contents = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">YES</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (async) &#123; <span class="comment">// 异步绘制</span></span><br><span class="line">        <span class="keyword">if</span> (task.willDisplay) task.willDisplay(<span class="keyword">self</span>);</span><br><span class="line">        YYSentinel *sentinel = _sentinel;</span><br><span class="line">        int32_t value = sentinel.value;</span><br><span class="line">        <span class="built_in">BOOL</span> (^isCancelled)(<span class="keyword">void</span>) = ^<span class="built_in">BOOL</span>() &#123;</span><br><span class="line">            <span class="comment">// 值相等, 说明正在绘制没有取消, 否则说明已经取消啦</span></span><br><span class="line">            <span class="keyword">return</span> value != sentinel.value;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.bounds.size;</span><br><span class="line">        <span class="built_in">BOOL</span> opaque = <span class="keyword">self</span>.opaque;</span><br><span class="line">        <span class="built_in">CGFloat</span> scale = <span class="keyword">self</span>.contentsScale;</span><br><span class="line">        <span class="comment">// 获取背景色</span></span><br><span class="line">        <span class="built_in">CGColorRef</span> backgroundColor = (opaque &amp;&amp; <span class="keyword">self</span>.backgroundColor) ? <span class="built_in">CGColorRetain</span>(<span class="keyword">self</span>.backgroundColor) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (size.width &lt; <span class="number">1</span> || size.height &lt; <span class="number">1</span>) &#123; <span class="comment">// 宽或者高小于1的情况</span></span><br><span class="line">            <span class="comment">// 获取图片再释放掉, 为啥要多此一举?</span></span><br><span class="line">            <span class="comment">// 因为赋值给contents的就是一个CGImageRef, 如果直接self.contents = nil;会造成这个image在当前线程(主线程)释放。作者手动把这个image取出来的目的就是把'release'操作放在YYAsyncLayerGetReleaseQueue()这个队列中</span></span><br><span class="line">            <span class="built_in">CGImageRef</span> image = (__bridge_retained <span class="built_in">CGImageRef</span>)(<span class="keyword">self</span>.contents);</span><br><span class="line">            <span class="keyword">self</span>.contents = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(YYAsyncLayerGetReleaseQueue(), ^&#123;</span><br><span class="line">                    <span class="built_in">CFRelease</span>(image);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">YES</span>);</span><br><span class="line">            <span class="built_in">CGColorRelease</span>(backgroundColor);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从这里开始进入子线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(YYAsyncLayerGetDisplayQueue(), ^&#123;</span><br><span class="line">            <span class="comment">// 进入子线程后, 第1次取消绘制判断</span></span><br><span class="line">            <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                <span class="built_in">CGColorRelease</span>(backgroundColor);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开启图形上下文</span></span><br><span class="line">            <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, opaque, scale);</span><br><span class="line">            <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">            <span class="keyword">if</span> (opaque) &#123;</span><br><span class="line">            <span class="comment">// UIGraphicsPushContext:压栈当前的绘制对象, 生成新的绘制图层。UIKit的绘制必须在当前的上下文中绘制，而UIGraphicsPushContext可以将当前的参数context转化为可以UIKit绘制的上下文，进行绘制图片。</span></span><br><span class="line">            <span class="comment">// CGContextSaveGState:压栈当前的绘制状态</span></span><br><span class="line">                <span class="comment">// 这里是为了不"污染"原先的context内容, 保存状态后绘制新的内容</span></span><br><span class="line">                <span class="built_in">CGContextSaveGState</span>(context);</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 没有背景色或者 透明度小于1, 使用白色填充</span></span><br><span class="line">                    <span class="keyword">if</span> (!backgroundColor || <span class="built_in">CGColorGetAlpha</span>(backgroundColor) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="built_in">CGContextSetFillColorWithColor</span>(context, [<span class="built_in">UIColor</span> whiteColor].CGColor);</span><br><span class="line">                        <span class="built_in">CGContextAddRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width * scale, size.height * scale));</span><br><span class="line">                        <span class="built_in">CGContextFillPath</span>(context);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 这里使用backgroundColor填充</span></span><br><span class="line">                    <span class="keyword">if</span> (backgroundColor) &#123;</span><br><span class="line">                        <span class="built_in">CGContextSetFillColorWithColor</span>(context, backgroundColor);</span><br><span class="line">                        <span class="built_in">CGContextAddRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width * scale, size.height * scale));</span><br><span class="line">                        <span class="built_in">CGContextFillPath</span>(context);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">CGContextRestoreGState</span>(context);</span><br><span class="line">                <span class="built_in">CGColorRelease</span>(backgroundColor);</span><br><span class="line">            &#125;</span><br><span class="line">            task.display(context, size, isCancelled);</span><br><span class="line">            <span class="comment">// display完毕后, 第2次取消绘制判断</span></span><br><span class="line">            <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                <span class="comment">// 如果确定已经取消绘制了, 关闭图形上下文</span></span><br><span class="line">                <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">NO</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从当前上下文中获取生成的新内容</span></span><br><span class="line">            <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">            <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">            <span class="comment">// 从上下文中获取图片后, 第3次取消绘制判断</span></span><br><span class="line">            <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">NO</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="comment">// 转到主线程对contents赋值，第4次取消绘制判断</span></span><br><span class="line">                <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">NO</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 在这里对contents赋值</span></span><br><span class="line">                    <span class="keyword">self</span>.contents = (__bridge <span class="keyword">id</span>)(image.CGImage);</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">YES</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非异步绘制</span></span><br><span class="line">        <span class="comment">// 不需要进行线程安全判断了</span></span><br><span class="line">        [_sentinel increase];</span><br><span class="line">        <span class="comment">// 下面的代码都是和异步绘制相同的套路</span></span><br><span class="line">        <span class="keyword">if</span> (task.willDisplay) task.willDisplay(<span class="keyword">self</span>);</span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size, <span class="keyword">self</span>.opaque, <span class="keyword">self</span>.contentsScale);</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.opaque) &#123;</span><br><span class="line">            <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.bounds.size;</span><br><span class="line">            size.width *= <span class="keyword">self</span>.contentsScale;</span><br><span class="line">            size.height *= <span class="keyword">self</span>.contentsScale;</span><br><span class="line">            <span class="built_in">CGContextSaveGState</span>(context); &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">self</span>.backgroundColor || <span class="built_in">CGColorGetAlpha</span>(<span class="keyword">self</span>.backgroundColor) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">CGContextSetFillColorWithColor</span>(context, [<span class="built_in">UIColor</span> whiteColor].CGColor);</span><br><span class="line">                    <span class="built_in">CGContextAddRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</span><br><span class="line">                    <span class="built_in">CGContextFillPath</span>(context);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundColor) &#123;</span><br><span class="line">                    <span class="built_in">CGContextSetFillColorWithColor</span>(context, <span class="keyword">self</span>.backgroundColor);</span><br><span class="line">                    <span class="built_in">CGContextAddRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</span><br><span class="line">                    <span class="built_in">CGContextFillPath</span>(context);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="built_in">CGContextRestoreGState</span>(context);</span><br><span class="line">        &#125;</span><br><span class="line">        task.display(context, <span class="keyword">self</span>.bounds.size, ^&#123;<span class="keyword">return</span> <span class="literal">NO</span>;&#125;);</span><br><span class="line">        <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        <span class="keyword">self</span>.contents = (__bridge <span class="keyword">id</span>)(image.CGImage);</span><br><span class="line">        <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">YES</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起来貌似很多，实际的绘制原理三行代码可以说清楚：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1，从当前图形上下文中获取Image</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="comment">// 2，关闭图形上下文</span></span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"><span class="comment">// 3，将image赋值给layer的contents属性</span></span><br><span class="line"><span class="keyword">self</span>.contents = (__bridge <span class="keyword">id</span>)(image.CGImage);</span><br></pre></td></tr></table></figure><p>在这之外更多的是 是否取消绘制的判断、没有背景色或者透明度小于1的处理、size极小值的处理等等。</p><p>当然还有那个巧妙的子线程异步释放对象的逻辑，记得也见过好多次了：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGImageRef</span> image = (__bridge_retained <span class="built_in">CGImageRef</span>)(<span class="keyword">self</span>.contents);</span><br><span class="line"><span class="keyword">self</span>.contents = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (image) &#123;</span><br><span class="line"> <span class="built_in">dispatch_async</span>(YYAsyncLayerGetReleaseQueue(), ^&#123;</span><br><span class="line">     <span class="built_in">CFRelease</span>(image);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>平时的业务开发中我们也可以这么用，比如：<br><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">// 含有大量元素的数组</span><br><span class="line">NSMutableArray *array = self.itemArray;</span><br><span class="line">self.itemArray = nil;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">  <span class="built_in"> array </span>= nil; // 子线程释放</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">《iOS 保持界面流畅的技巧》</a>这篇文章想必很多人都有人阅读过，也都能从中受益。<br>这里回顾一下ibireme大神的微博Demo性能优化技巧：<br><strong>1，预排版</strong><br>这里是指不定高cell的预排版，本文也已经提过，frame布局，可以子线程手动计算并把layout数据缓存在模型中，autolayout布局，可以借助FDTemplateLayoutCell做高度缓存。<br><strong>2，预渲染</strong><br>作者举了一个圆角图片预先裁剪并做缓存处理来避免离屏渲染的例子，也正如上文所说，layer.cornerRadius + layer.masksToBounds一起设置在新版本系统上已经不会触发离屏渲染（大多数人说是iOS9，我还没有确认），但是这个思路可以举一反三，很多可以提前的工作没必要等到cell要展示了才开始做。<br><strong>3，异步绘制+全局并发控制</strong></p><ul><li>借助YYDispatchQueuePool把App内所有异步操作按优先级不同放入了全局的 serial queue 中执行，尽量避免了过多线程导致的性能问题。</li><li>借助YYAsyncLayer和CoreText实现富文本的异步绘制（当然也可以直接使用功能更强大的YYText，作者把路都给铺好了😂）。<br><strong>4，异步图片加载</strong><br>大多时候，只是显示简单的单张图片，可以直接使用UIView.layer.contents，而不需要使用UIImageView。当然，SDWebImage和YYWebImage把很多工作都做好了。<br><strong>5，不需要触摸事件的UIView换成CALayer</strong><br>可以这么做，但是CALayer没法设置约束了，如果使用自动布局就很蛋疼了。<br><strong>6，多个视觉元素合成一张图</strong><br>也是一种思路，甚至也一定条件下可以把cell的全部内容合成一张图片，但是可能性比较小，需要根据业务来走。<br>以微博为例，“来自iPhone”、会员图标、话题、转发微博原作者昵称、微博内容的链接这些元素都需要响应点击事件，根本不可能用一种图片代替。<br>百度的feed流，很多新闻的样式是相同的，而且不像微博需要处理很多子元素的点击事件，很多情况下只需要处理cell的点击事件就可以了，这才有合成一张图片的可能性。</li></ul><p>过早的优化是万恶之源，所有的tips都只是建议，需要具体问题具体分析。很多前辈给我们提供了诸多便利的工具，对于我们，平时踏踏实实写代码，少写bug，不写crash，这才是最重要的。</p><blockquote><p>参考资料：<br><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">《iOS 保持界面流畅的技巧》</a><br><a href="http://tutuge.me/2015/02/19/提升UITableView性能-复杂页面的优化/" target="_blank" rel="noopener">《提升UITableView性能-复杂页面的优化》</a><br><a href="https://www.jianshu.com/p/15b8b1844e9c" target="_blank" rel="noopener">《iOS 阴影，圆角，避免离屏渲染》</a><br><a href="https://juejin.im/post/5acf34eff265da237314d6e0" target="_blank" rel="noopener">《UITableView 性能优化》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; App界面优化的小Tips。&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.chenyalun.com/categories/iOS/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>NSNotificationCenter探索</title>
    <link href="http://blog.chenyalun.com/2019/01/28/NSNotificationCenter%E6%8E%A2%E7%B4%A2/"/>
    <id>http://blog.chenyalun.com/2019/01/28/NSNotificationCenter探索/</id>
    <published>2019-01-28T13:12:23.000Z</published>
    <updated>2019-10-15T02:20:11.886Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2019年10月14日 更新源码</p></blockquote><p></p><p align="center"> 探究NSNotificationCenter的实现并尝试自实现。 </p><br><a id="more"></a><p></p><h1 id="一、同步通知"><a href="#一、同步通知" class="headerlink" title="一、同步通知"></a>一、同步通知</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>NSNotification并不复杂，封装了name、object以及userInfo，使用指定构造器初始化即可。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotification</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSNotificationName</span> name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="keyword">id</span> object;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *userInfo;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSNotificationName</span>)name object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)userInfo;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotification</span> (<span class="title">NSNotificationCreation</span>)</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)notificationWithName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)notificationWithName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>NSNotificationCenter则给我们提供了添加通知接收者、发送通知的接口。NSNotificationName就是<code>NSString *</code>，defaultCenter是单例。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotificationCenter</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="keyword">void</span> *_impl;</span><br><span class="line">    <span class="keyword">void</span> *_callback;</span><br><span class="line">    <span class="keyword">void</span> *_pad[<span class="number">11</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSNotificationCenter</span> *defaultCenter;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotification:(<span class="built_in">NSNotification</span> *)notification;</span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer;</span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span> &lt;<span class="built_in">NSObject</span>&gt;)addObserverForName:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)name object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)obj queue:(<span class="keyword">nullable</span> <span class="built_in">NSOperationQueue</span> *)queue usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSNotification</span> *note))block;</span><br><span class="line">    <span class="comment">// The return value is retained by the system, and should be held onto by the caller in order to remove the observer with removeObserver: later, to stop observation.</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><h2 id="添加observer"><a href="#添加observer" class="headerlink" title="添加observer"></a>添加observer</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br></pre></td></tr></table></figure><p>最常用的就是这个方法，指定observer、selector、name以及object即可。它做了什么呢？<br>苹果官方文档解释如下：</p><blockquote><p>Adds an entry to the notification center’s dispatch table with an observer and a notification selector, and an optional notification name and sender.<br>Parameters</p></blockquote><blockquote><p>observer: Object registering as an observer.</p></blockquote><blockquote><p>aSelector: Selector that specifies the message the receiver sends observer to notify it of the notification posting. The method specified by aSelector must have one and only one argument (an instance of NSNotification).</p></blockquote><blockquote><p>aName: The name of the notification for which to register the observer; that is, only notifications with this name are delivered to the observer.<br>If you pass nil, the notification center doesn’t use a notification’s name to decide whether to deliver it to the observer.</p></blockquote><blockquote><p>anObject: The object whose notifications the observer wants to receive; that is, only notifications sent by this sender are delivered to the observer.<br>If you pass nil, the notification center doesn’t use a notification’s sender to decide whether to deliver it to the observer.</p></blockquote><blockquote><p>If your app targets iOS 9.0 and later or macOS 10.11 and later, you don’t need to unregister an observer in its dealloc method. Otherwise, you should call removeObserver:name:object: before observer or any object passed to this method is deallocated</p></blockquote><p>简单解释就是，把必需的observer、selector和可选的name、object注册到通知中心。这个selector有且只有一个参数，参数是NSNotification对象。若指定了通知的name，则observer必须匹配相同的name通知中心才会把消息分发给它，同样，若指定了通知的object，则observer必须匹配相同的object通知中心才会把消息分发给它。在iOS9.0或者macOS 10.11之后，咱们不必要在observer的dealloc方法中取消注册了（现在基本都要求最低是iOS9了）。</p><p>再看看坊间GNU的解释：</p><blockquote><p>Registers observer to receive notifications with the name<br> notificationName and/or containing object (one or both of these two must be<br> non-nil; nil acts like a wildcard).  When a notification of name name<br> containing object is posted, observer receives a selector message with this<br> notification as the argument.  The notification center waits for the<br> observer to finish processing the message, then informs the next registree<br> matching the notification, and after all of this is done, control returns<br> to the poster of the notification.  Therefore the processing in the<br> selector implementation should be short.</p></blockquote><blockquote><p>The notification center does not retain observer or object. Therefore,<br> you should always send removeObserver: or removeObserver:name:object: to<br> the notification center before releasing these objects.</p></blockquote><blockquote><p>As a convenience, when built with garbage collection, you do not need to<br> remove any garbage collected observer as the system will do it implicitly.</p></blockquote><blockquote><p>NB. For MacOS-X compatibility, adding an observer multiple times will<br> register it to receive multiple copies of any matching notification, however<br> removing an observer will remove <em>all</em> of the multiple registrations.</p></blockquote><p>我们得到的重要信息是：</p><ol><li>通知中心会等待所有符合条件的observer把通知消息处理完毕之后才会return，也即发送通知是同步的。这要求我们处理通知消息的逻辑应该“简短”、不会长时间阻塞。</li><li>通知中心并不增加observer和object的引用计数，建议我们适时removeObserver。</li><li>注册完全一致的observer信息（含name、object、selector）多次，回调也是有多次的，而只移除一次完全一致的observer信息，却会把所有的observer信息都移除掉。</li></ol><p>对于第三条这么理解，注册3次，回调也是有三次；而移除一次，所有的该通知都被移除了：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[NSNotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">dealWithNoti:</span>) <span class="string">name:</span>name <span class="string">object:</span>obj];</span><br><span class="line">[NSNotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">dealWithNoti:</span>) <span class="string">name:</span>name <span class="string">object:</span>obj];</span><br><span class="line">[NSNotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">dealWithNoti:</span>) <span class="string">name:</span>name <span class="string">object:</span>obj];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[NSNotificationCenter.defaultCenter <span class="string">removeObserver:</span>self <span class="string">name:</span>name <span class="string">object:</span>obj];</span><br></pre></td></tr></table></figure></p><p>源码逻辑是这样的：<br><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">- (void)addObserver:(id)observer</span><br><span class="line">           selector:(SEL)selector</span><br><span class="line">               <span class="keyword">name</span>:(NSString *)<span class="keyword">name</span></span><br><span class="line">             object:(id)object &#123;</span><br><span class="line">    Observation*list;</span><br><span class="line">    Observation*o;</span><br><span class="line">    NSIMapTablem;</span><br><span class="line">    NSIMapNoden;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lockNCTable(_table);</span><br><span class="line">    <span class="comment">// 根据observer和selector获取Observation</span></span><br><span class="line">    o = obsNew(_table, selector, observer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">name</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据name在named表中搜索对应的NSIMapNode</span></span><br><span class="line">        <span class="function"><span class="title">n</span> = NSIMapNodeForKey(_table-&gt;</span>named, (NSIMapKey)(id)<span class="keyword">name</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="comment">// 没有在named表中找到</span></span><br><span class="line">            <span class="comment">// 优先在_table的缓存中查找, 找不到则创建</span></span><br><span class="line">            m = mapNew(_table);</span><br><span class="line">            <span class="comment">// 将name转换为不可变的name</span></span><br><span class="line">            <span class="keyword">name</span> = [<span class="keyword">name</span> copyWithZone:NSDefaultMallocZone()];</span><br><span class="line">            <span class="comment">// 把name作为key, 将新创建的m(NSIMapTable)设置到named表中</span></span><br><span class="line">            NSIM<span class="function"><span class="title">apAddPair</span>(_table-&gt;</span>named, (NSIMapKey)(id)<span class="keyword">name</span>, (NSIMapVal)(void *)m);</span><br><span class="line">            NS_CONSUMED(<span class="keyword">name</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在named表中找到了, 取出NSIMapNode对应的value</span></span><br><span class="line">            <span class="function"><span class="title">m</span> = (NSIMapTable)n-&gt;</span>value.ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// object作为key, 取出其在m表中对应的NSIMapNode</span></span><br><span class="line">        n = NSIMapNodeForSimpleKey(m, (NSIMapKey)object);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="title">o</span>-&gt;</span>next = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// m表中取不到object对应的值, 把Observation直接存到m表中</span></span><br><span class="line">            NSIMapAddPair(m, (NSIMapKey)object, (NSIMapVal)o);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// object作为key, 取出其在m表中对应的NSIMapNode, 获取node中的链表</span></span><br><span class="line">            <span class="function"><span class="title">list</span> = (Observation *)n-&gt;</span>value.ptr;</span><br><span class="line">            <span class="comment">// 把Observation追加到链表的最前面</span></span><br><span class="line">            <span class="function"><span class="title">o</span>-&gt;</span><span class="function"><span class="title">next</span> = list-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">list</span>-&gt;</span>next = o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object) &#123;</span><br><span class="line">        <span class="comment">// name不存在, 则从nameless表中搜索对应的NSIMapNode</span></span><br><span class="line">        <span class="function"><span class="title">n</span> = NSIMapNodeForSimpleKey(_table-&gt;</span>nameless, (NSIMapKey)object);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 同样的逻辑, 把Observation追加到链表的最前面</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="title">o</span>-&gt;</span>next = ENDOBS;</span><br><span class="line">            NSIM<span class="function"><span class="title">apAddPair</span>(_table-&gt;</span>nameless, (NSIMapKey)object, (NSIMapVal)o);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">list</span> = (Observation *)n-&gt;</span>value.ptr;</span><br><span class="line">            <span class="function"><span class="title">o</span>-&gt;</span><span class="function"><span class="title">next</span> = list-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">list</span>-&gt;</span>next = o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// name和object都为空, 把Observation追加到wildcard表的最前面</span></span><br><span class="line">        <span class="function"><span class="title">o</span>-&gt;</span><span class="function"><span class="title">next</span> = _table-&gt;</span>wildcard;</span><br><span class="line">        _<span class="function"><span class="title">table</span>-&gt;</span>wildcard = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlockNCTable(_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>named表的结构大致如此：<br><img src="https://image.chenyalun.com/2019/01/28/002.png" style="zoom:50%"></p><p>而nameless表则更简单，object作为key，observer数组作为value。</p><p>还有一种是以block的形式添加观察者：<br><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>addObserverForName:<span class="params">(NSString *)</span>name</span><br><span class="line">                  object:<span class="params">(id)</span>object</span><br><span class="line">                   queue:<span class="params">(NSOperationQueue *)</span>queue</span><br><span class="line">              usingBlock:<span class="params">(NSNotificationBlock)</span>block</span><br></pre></td></tr></table></figure></p><p>不需要设置selector，还能方便地在block中执行。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)addObserverForName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                  object:(<span class="keyword">id</span>)object</span><br><span class="line">                   queue:(<span class="built_in">NSOperationQueue</span> *)queue</span><br><span class="line">              usingBlock:(<span class="built_in">NSNotificationBlock</span>)block &#123;</span><br><span class="line">    <span class="built_in">NSNotificationObserver</span> *observer =</span><br><span class="line">    [[<span class="built_in">NSNotificationObserver</span> alloc] initWithQueue:queue block:block];</span><br><span class="line">    [<span class="keyword">self</span> addObserver:observer</span><br><span class="line">         selector:<span class="keyword">@selector</span>(didReceiveNotification:)</span><br><span class="line">             name:name</span><br><span class="line">           object:object];</span><br><span class="line">    <span class="keyword">return</span> observer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码来看，这个方法实际上也是调用了addObserver:selector:name:object方法。observer没有变，但是把selector替换成了didReceiveNotification:，它的实现是这样的：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveNotification: (<span class="built_in">NSNotification</span> *)notif &#123;</span><br><span class="line">    <span class="keyword">if</span> (_queue != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSNotificationBlockOperation</span> *op = [[<span class="built_in">NSNotificationBlockOperation</span> alloc] </span><br><span class="line">initWithNotification:notif block:_block];</span><br><span class="line">        [_queue addOperation:op];</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">CALL_BLOCK</span>(_block, notif);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>didReceiveNotification:方法处理了Queue的逻辑。如果Queue不存在，则直接调用block。如果Queue是存在的，继承自NSOperation的NSNotificationBlockOperation封装了需要回调的block和回传的NSNotification，并在main方法中调用了这个block。最后，这个operation被添加到指定的Queue中执行。</p><h2 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br></pre></td></tr></table></figure><p>发送通知最终是调用这个方法。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                      object:(<span class="keyword">id</span>)object</span><br><span class="line">                    userInfo:(<span class="built_in">NSDictionary</span> *)info &#123;</span><br><span class="line">    <span class="built_in">NSNotification</span> *notification;</span><br><span class="line">    notification = (<span class="keyword">id</span>)<span class="built_in">NSAllocateObject</span>(concrete, <span class="number">0</span>, <span class="built_in">NSDefaultMallocZone</span>());</span><br><span class="line">    notification-&gt;_name = [name copyWithZone: [<span class="keyword">self</span> zone]];</span><br><span class="line">    notification-&gt;_object = [object <span class="keyword">retain</span>];</span><br><span class="line">    notification-&gt;_info = [info <span class="keyword">retain</span>];</span><br><span class="line">    [<span class="keyword">self</span> _postAndRelease: notification];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键的是<code>_postAndRelease:</code>的实现：<br><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">- (void)_postAndRelease:(NSNotification *)notification &#123;</span><br><span class="line">    Observation*o;</span><br><span class="line">    unsigned count;</span><br><span class="line">    NSString *<span class="keyword">name</span> = [notification <span class="keyword">name</span>];</span><br><span class="line">    id object;</span><br><span class="line">    GSIMapNoden;</span><br><span class="line">    GSIMapTablem;</span><br><span class="line">    GSIArrayItem i[<span class="number">64</span>];</span><br><span class="line">    GSIArray_t b;</span><br><span class="line">    GSIArray a = &amp;b;</span><br><span class="line">    <span class="comment">// 获取object</span></span><br><span class="line">    object = [notification object];</span><br><span class="line"></span><br><span class="line">    GSIArrayInitWithZoneAndStaticCapacity(a, _zone, <span class="number">64</span>, i);</span><br><span class="line">    lockNCTable(_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取没有指定name也没有指定object的所有observer</span></span><br><span class="line">    <span class="function"><span class="title">for</span> (o = _table-&gt;</span><span class="function"><span class="title">wildcard</span> = purgeCollected(WILDCARD); o != ENDOBS; o = o-&gt;</span>next) &#123;</span><br><span class="line">        GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定object但是没有指定name的所有observer</span></span><br><span class="line">    <span class="keyword">if</span> (object) &#123;</span><br><span class="line">        <span class="function"><span class="title">n</span> = GSIMapNodeForSimpleKey(_table-&gt;</span>nameless, (GSIMapKey)object);</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="title">o</span> = ((Observation *)n-&gt;</span>value.ext)</span><br><span class="line">            <span class="keyword">while</span> (o != (Observation *)-<span class="number">1</span>) &#123;</span><br><span class="line">                GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">                <span class="function"><span class="title">o</span> = o-&gt;</span>next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指定name而且object也与通知要求的object相匹配的所有observer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">name</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">n</span> = GSIMapNodeForKey(_table-&gt;</span>named, (GSIMapKey)((id)<span class="keyword">name</span>));</span><br><span class="line">        <span class="keyword">if</span> (n) &#123;</span><br><span class="line">            <span class="function"><span class="title">m</span> = (GSIMapTable)n-&gt;</span>value.ptr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// object为空</span></span><br><span class="line">            n = GSIMapNodeForSimpleKey(m, (GSIMapKey)object);</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="title">o</span> = ((Observation *)n-&gt;</span>value.ext)</span><br><span class="line">                <span class="keyword">while</span> (o != (Observation *)-<span class="number">1</span>) &#123;</span><br><span class="line">                    GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">                    <span class="function"><span class="title">o</span> = o-&gt;</span>next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// object不为空, 且匹配</span></span><br><span class="line">            <span class="keyword">if</span> (object != <span class="literal">nil</span>) &#123;</span><br><span class="line">                n = GSIMapNodeForSimpleKey(m, (GSIMapKey)<span class="literal">nil</span>);</span><br><span class="line">                <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="function"><span class="title">o</span> = ((Observation *)n-&gt;</span>value.ext)</span><br><span class="line">                    <span class="keyword">while</span> (o != (Observation *)-<span class="number">1</span>) &#123;</span><br><span class="line">                        GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">                        <span class="function"><span class="title">o</span> = o-&gt;</span>next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlockNCTable(TABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数组a, 逐个发送通知</span></span><br><span class="line">    count = GSIArrayCount(a);</span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        o = GSIArrayItemAtIndex(a, count).ext;</span><br><span class="line">        <span class="function"><span class="title">if</span> (o-&gt;</span>next != <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="function"><span class="title">o</span>-&gt;</span><span class="function"><span class="title">observer</span> performSelector:o-&gt;</span>selector withObject:notification];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 置空数组a</span></span><br><span class="line">    lockNCTable(_table);</span><br><span class="line">    GSIArrayEmpty(a);</span><br><span class="line">    unlockNCTable(_table);</span><br><span class="line">    <span class="comment">// release通知对象</span></span><br><span class="line">    RELEASE(notification);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键在于从表中获取符合要求的Observation：在wildcard表中获取匿名且没有指定object的Observation；在nameless表中获取匹配object但是匿名的Observation；在named表中获取object为空的Observation和object匹配的Observation。把这些Observation添加到一个数组中，遍历，逐个调用selector。</p><p>那么，移除通知自然也是根据name、object、observer，找到匹配的Observation对象，从相应的表中移除，不再赘述。</p><h1 id="二、异步通知"><a href="#二、异步通知" class="headerlink" title="二、异步通知"></a>二、异步通知</h1><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle;</span><br><span class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle coalesceMask:(<span class="built_in">NSNotificationCoalescing</span>)coalesceMask forModes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dequeueNotificationsMatching:(<span class="built_in">NSNotification</span> *)notification coalesceMask:(<span class="built_in">NSUInteger</span>)coalesceMask;</span><br></pre></td></tr></table></figure><p>通过NSNotificationQueue可以实现异步通知。NSNotificationCoalescing提供了聚合选项，不聚合、根据name聚合以及根据发送者聚合，也即如果在队列中已有该种通知，如果满足选项，则不会进入队列，只保留第一个通知。NSPostingStyle则可以设置通知发送的时机，立即同步发送、尽可能快地发送，以及在Runloop空闲时发送。</p><p><strong>场景如下：</strong><br>NSPostWhenIdle：比如当用户正在输入文字，需要在某个控件上实时展示文字的长度的时候，可以用到这个选项。<br>NSPostNow：实时发送通知，但是与同步通知相比，关键在于聚合选项：队列中已有满足选项的通知时，是否只保留一个。<br>NSPostASAP：多个通知进入到缓冲区后，利用聚合选项，只留下一个，并尽可能快地发送通知。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification</span><br><span class="line">               postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle</span><br><span class="line">               coalesceMask:(<span class="built_in">NSUInteger</span>)coalesceMask</span><br><span class="line">                   forModes:(<span class="built_in">NSArray</span> *)modes &#123;</span><br><span class="line">    <span class="keyword">if</span> (modes == <span class="literal">nil</span>) modes = defaultMode; <span class="comment">// 默认模式</span></span><br><span class="line">    <span class="keyword">if</span> (coalesceMask != <span class="built_in">NSNotificationNoCoalescing</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要聚合, 则先把队列中的相应的notification移除</span></span><br><span class="line">        [<span class="keyword">self</span> dequeueNotificationsMatching:notification</span><br><span class="line">    coalesceMask:coalesceMask];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> (postingStyle) &#123;</span><br><span class="line">        <span class="comment">// 同步发送</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSPostNow</span>: &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *mode = [[<span class="built_in">NSRunLoop</span> currentRunLoop] currentMode];</span><br><span class="line">            <span class="comment">// 要求当前Runloop的mode需要匹配, 不然无效</span></span><br><span class="line">            <span class="keyword">if</span> (mode == <span class="literal">nil</span> || [modes indexOfObject:mode] != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">                [_center postNotification: notification];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 尽可能早发送(as soon as possible)</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSPostASAP</span>:</span><br><span class="line">            add_to_queue(_asapQueue, notification, modes, _zone); <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 在Runloop空闲时发送</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSPostWhenIdle</span>:</span><br><span class="line">            add_to_queue(_idleQueue, notification, modes, _zone); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从入口方法来看，关键在于add_to_queue()函数，根据NSPostingStyle选项，把通知添加到_asapQueue队列或者_idleQueue队列。</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static void add_to_queue(NSNotificationQueueList *queue,</span><br><span class="line">                         NSNotification *notification,</span><br><span class="line">                         NSArray *modes, NSZone *_zone) &#123;</span><br><span class="line">    NSNotificationQueueRegistration *item;</span><br><span class="line">    item = NSZoneCalloc(_zone, <span class="number">1</span>, sizeof(NSNotificationQueueRegistration));</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span>notification = RETAIN(notification);</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span><span class="keyword">name</span> = [notification <span class="keyword">name</span>];</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span>object = [notification object];</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span>modes = [modes copyWithZone: [modes zone]];</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span>next = NULL;</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span><span class="function"><span class="title">prev</span> = queue-&gt;</span>tail;</span><br><span class="line">    <span class="function"><span class="title">queue</span>-&gt;</span>tail = item;</span><br><span class="line">    <span class="function"><span class="title">if</span> (item-&gt;</span><span class="function"><span class="title">prev</span>) item-&gt;</span><span class="function"><span class="title">prev</span>-&gt;</span>next = item;</span><br><span class="line">    <span class="function"><span class="title">if</span> (!queue-&gt;</span><span class="function"><span class="title">head</span>) queue-&gt;</span>head = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，把notification和modes封装成NSNotificationQueueRegistration，并把它插入到双向链表queue的尾部。</p><p>以NSPostWhenIdle选项为例，在Runloop的<code>acceptInputForMode:beforeDate:</code>方法中找到了通知的发送痕迹：GSPrivateNotifyIdle(mode)。</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void GSPrivateNotifyIdle(NSString *mode) &#123;</span><br><span class="line">    NotificationQueueList*item;</span><br><span class="line">    <span class="function"><span class="title">for</span> (item = currentList(); item; item = item-&gt;</span>next) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span> (item-&gt;</span>queue) &#123;</span><br><span class="line">            <span class="function"><span class="title">notify</span>(item-&gt;</span><span class="function"><span class="title">queue</span>-&gt;</span>_center,</span><br><span class="line">                   <span class="function"><span class="title">item</span>-&gt;</span><span class="function"><span class="title">queue</span>-&gt;</span>_idleQueue,</span><br><span class="line">                   mode,</span><br><span class="line">                   <span class="function"><span class="title">item</span>-&gt;</span><span class="function"><span class="title">queue</span>-&gt;</span>_zone);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就很明朗了，notify()的逻辑是这样的：</p><ol><li>从双向链表list中取出所有的结点对象NSNotificationQueueRegistration，并把它放到一个数组中。</li><li>遍历该数组，逐个从list中移除：<code>remove_from_queue(list, item, zone);</code>。</li><li>遍历该数组，逐个发送通知<code>[NSNotificationCenter.defaultCenter postNotification:notification];</code>，而<code>postNotification:</code>方法本质上还是调用同步通知中的<code>_postAndRelease:</code>方法。</li></ol><p>什么时候发送，交由Runloop处理。</p><h1 id="三、子线程通知"><a href="#三、子线程通知" class="headerlink" title="三、子线程通知"></a>三、子线程通知</h1><p>子线程通知苹果给出了标准的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG" target="_blank" rel="noopener">解决方案</a>：利用NSMachPort。假定在A线程发送通知，需要在B线程处理通知，那么B线程中注册NSMachPort，A线程中使用此port发送通知，则B线程就能收到消息并进行处理。</p><p>简单概述实现思路就是：维护一个NSNotification数组，接收到通知时，如果通知分发的线程与期望的线程（处理通知的线程）不一致，则把这个通知添加到NSNotification数组中，并利用NSMachPort发送一个“信号”到期望的线程（也就是创建NSMachPort对象的线程）中，在期望的线程中收到信号后，把通知从NSNotification数组中移除，并处理。</p><p>比如，需要在主线程发送通知，而在子线程接收并处理通知，结合苹果给出的示例代码，可以这么做：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通知名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSNotificationName</span> YADemoNotification = <span class="string">@"YADemoNotification"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAThreadedNotificationHandler</span>: <span class="title">NSObject</span> &lt;<span class="title">NSMachPortDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *notifications;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *notificationThread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSLock</span> *notificationLock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMachPort</span> *notificationPort;</span><br><span class="line">- (<span class="keyword">void</span>)setUpThreadingSupport;</span><br><span class="line">- (<span class="keyword">void</span>)processNotification:(<span class="built_in">NSNotification</span> *)notification;</span><br><span class="line"><span class="comment">// Mach port delegate</span></span><br><span class="line">- (<span class="keyword">void</span>)handleMachMessage:(<span class="keyword">void</span> *)msg;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAThreadedNotificationHandler</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setUpThreadingSupport];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(processNotification:) name:YADemoNotification object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private methods</span></span><br><span class="line">- (<span class="keyword">void</span>)setUpThreadingSupport &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.notifications) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">self</span>.notifications      = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.notificationLock   = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="comment">// 配置期望线程（当前线程）</span></span><br><span class="line">    <span class="keyword">self</span>.notificationThread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置端口消息处理的线程（当前线程）</span></span><br><span class="line">    <span class="keyword">self</span>.notificationPort = [[<span class="built_in">NSMachPort</span> alloc] init];</span><br><span class="line">    [<span class="keyword">self</span>.notificationPort setDelegate:<span class="keyword">self</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:<span class="keyword">self</span>.notificationPort forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口代理</span></span><br><span class="line">- (<span class="keyword">void</span>)handleMachMessage:(<span class="keyword">void</span> *)msg &#123;</span><br><span class="line">    [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    <span class="keyword">while</span> ([<span class="keyword">self</span>.notifications count]) &#123;</span><br><span class="line">        <span class="built_in">NSNotification</span> *notification = [<span class="keyword">self</span>.notifications objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notifications removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span> processNotification:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    &#125;;</span><br><span class="line">    [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理通知</span></span><br><span class="line">- (<span class="keyword">void</span>)processNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread] != <span class="keyword">self</span>.notificationThread) &#123;</span><br><span class="line">        <span class="comment">// Forward the notification to the correct thread.</span></span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">        [<span class="keyword">self</span>.notifications addObject:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span>.notificationPort sendBeforeDate:[<span class="built_in">NSDate</span> date]</span><br><span class="line">                components:<span class="literal">nil</span></span><br><span class="line">                from:<span class="literal">nil</span></span><br><span class="line">                reserved:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Process the notification here;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"处理通知在%@线程"</span>, <span class="built_in">NSThread</span>.currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在控制器中，这样发送通知：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *thread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) YAThreadedNotificationHandler *notificationHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)startThread &#123;</span><br><span class="line">    <span class="keyword">self</span>.notificationHandler = [YAThreadedNotificationHandler new];</span><br><span class="line">    <span class="comment">// 主线程发送通知</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="built_in">NSNotificationCenter</span>.defaultCenter postNotificationName:YADemoNotification object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 子线程手动开启Runloop</span></span><br><span class="line">    [<span class="built_in">NSRunLoop</span>.currentRunLoop run];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(startThread) object:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.thread start];    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四、自实现"><a href="#四、自实现" class="headerlink" title="四、自实现"></a>四、自实现</h1><p>有几个弱引用容器在日常工作中没有用过，但是又特别想亲手实践一番。偶尔看到一篇文章，说是自己实现了系统中通知中心的功能，出于好奇，自己也尝试一番，便在这里模仿了同步通知的实现。</p><p>主要原理就是创建一个字典observerMap，notification name作为key，NSMapTable作为value。在这个NSMapTable中，object作为key，用于存放observer的NSHashSet容器作为value。</p><h2 id="接口文件"><a href="#接口文件" class="headerlink" title="接口文件"></a>接口文件</h2><p>接口与系统保持一致。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> *YANotificationName <span class="built_in">NS_EXTENSIBLE_STRING_ENUM</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YANotificationCenter</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) YANotificationCenter *defaultCenter;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name:(<span class="keyword">nullable</span> YANotificationName)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer;</span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer name:(<span class="keyword">nullable</span> YANotificationName)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure><h2 id="Checklist"><a href="#Checklist" class="headerlink" title="Checklist"></a>Checklist</h2><ul><li style="list-style: none"><input type="checkbox" checked> 不增加observer和object的引用计数</li><li style="list-style: none"><input type="checkbox" checked> 支持携带参数信息userInfo</li><li style="list-style: none"><input type="checkbox" checked> 可以不指定object</li><li style="list-style: none"><input type="checkbox" checked> 添加观察者时指定object，post通知时只有相同的object才会有效</li><li style="list-style: none"><input type="checkbox" checked> observer为nil，发送通知时没有作用</li><li style="list-style: none"><input type="checkbox" checked> 指定线程发送通知，则在指定线程调用</li><li style="list-style: none"><input type="checkbox" checked> 没有及时移除通知，observer销毁之后继续发送通知不会产生异常<br>(从iOS 9开始，即使不移除观察者对象，程序也不会出现异常。)</li><li style="list-style: none"><input type="checkbox" checked> 支持多个observer监听同一个通知</li><li style="list-style: none"><input type="checkbox" checked> 如果notificationName为nil，object有值，则接收所有指定为object的通知</li><li style="list-style: none"><input type="checkbox" checked> 如果notificationName为nil，且object也为nil，则接收系统内所有通知<br>(也即YANotificationCenter发出的所有通知)</li><li style="list-style: none"><input type="checkbox" checked> 移除所有通知后，相关方法不再调用</li><li style="list-style: none"><input type="checkbox" checked> 移除指定通知后，相关方法不再调用</li><li style="list-style: none"><input type="checkbox" checked> 同步处理通知消息</li><li style="list-style: none"><input type="checkbox"> 多次添加observer，发送通知时多次调用</li><li style="list-style: none"><input type="checkbox"> 支持异步发布通知（NotificationQueue）</li></ul><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 不对observer和object强引用</span><br><span class="line"><span class="number">2.</span> 可以携带参数userInfo</span><br><span class="line"><span class="number">3.</span> 添加观察者时object为nil，post通知时object有值，依然有效(表示不限于指定的object)</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_1"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_1"</span> <span class="string">object:</span>self <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">4.</span> 添加观察者时指定object，post通知时相同的object，有效，不同的object，无效</span><br><span class="line"><span class="comment">// 有效</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_2"</span> <span class="string">object:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_2"</span> <span class="string">object:</span>self <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_3"</span> <span class="string">object:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_3"</span> <span class="string">object:</span>a <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 可以添加n次observer，发送通知时对应调用n次(不支持)</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_4"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_4"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_4"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">6.</span> 未添加observer，发送通知时没有作用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_5"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 指定线程发送通知，则在指定线程调用</span><br><span class="line"><span class="comment">// print方法是在发送通知的线程中调用的</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_6"</span> <span class="string">object:</span>nil];</span><br><span class="line">dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">NSLog(@<span class="string">"当前线程:%@"</span>,[NSThread currentThread]);</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_6"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> 没有在observer的dealloc方法中移除通知，observer销毁之后继续发送通知，无影响(从iOS <span class="number">9</span>开始，即使不移除观察者对象，程序也不会出现异常。)</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_7"</span> <span class="string">object:</span>nil];</span><br><span class="line"><span class="comment">// a对象销毁之后继续发送通知</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_7"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 多个observer监听同一个通知，所有observer的相关方法均得到调用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>b <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>c <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">10.</span> 如果notificationName为nil，object有值，则接收所有指定为object的通知</span><br><span class="line"><span class="comment">// 接收self发送的所有通知</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>nil <span class="string">object:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_9"</span> <span class="string">object:</span>self <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">11.</span> 如果notificationName为nil，且object也为nil，则接收系统内所有通知(也即YANotificationCenter发出的所有通知)</span><br><span class="line"><span class="comment">// 接收系统内所有通知，也即任意一个通知都会触发</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>nil <span class="string">object:</span>nil];</span><br><span class="line"><span class="number">12.</span> 移除所有通知后，相关方法不再调用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>@<span class="string">"Noti_10"</span> <span class="string">object:</span>nil];</span><br><span class="line"><span class="comment">// 移除所有通知后，再次发送通知没有效果</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">removeObserver:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_10"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> 移除指定通知后，相关方法不再调用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>@<span class="string">"Noti_11"</span> <span class="string">object:</span>nil];</span><br><span class="line"><span class="comment">// 移除指定通知后，再次发送通知没有效果</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">removeObserver:</span>self <span class="string">name:</span>@<span class="string">"Noti_11"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_11"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br></pre></td></tr></table></figure><h2 id="实现文件"><a href="#实现文件" class="headerlink" title="实现文件"></a>实现文件</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YANotificationCenter.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, YANotificationSenderType) &#123;</span><br><span class="line">    YANotificationSenderTypeObject   = <span class="number">0</span>, <span class="comment">// 指定对象</span></span><br><span class="line">    YANotificationSenderTypeObserver = <span class="number">1</span>, <span class="comment">// 观察者</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YANotificationCenter</span>()</span></span><br><span class="line"><span class="comment">// Recorder observer.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *observerMap;</span><br><span class="line"><span class="comment">// Recorder all the selector.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *selectorMap;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YANotificationCenter</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _observerMap = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        _selectorMap = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (YANotificationCenter *)defaultCenter &#123;</span><br><span class="line">    <span class="keyword">static</span> YANotificationCenter *center = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        center = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name:(YANotificationName)aName object:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line">    <span class="keyword">if</span> (!observer) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!aName) aName = (<span class="keyword">id</span>)kCFNull;</span><br><span class="line">    <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:aName];</span><br><span class="line">    <span class="keyword">if</span> (!map) map = [<span class="built_in">NSMapTable</span> weakToStrongObjectsMapTable];</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        <span class="built_in">NSHashTable</span> *set = [map objectForKey:observer];</span><br><span class="line">        <span class="keyword">if</span> (!set || ![set isKindOfClass:[<span class="built_in">NSHashTable</span> <span class="keyword">class</span>]]) set = [<span class="built_in">NSHashTable</span> weakObjectsHashTable];</span><br><span class="line">        [set addObject:anObject];</span><br><span class="line">        [map setObject:set forKey:observer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [map setObject:(<span class="keyword">id</span>)kCFNull forKey:observer];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.observerMap setObject:map forKey:aName];</span><br><span class="line">    <span class="built_in">NSString</span> *key = generateKey(observer, anObject, aName);</span><br><span class="line">    [<span class="keyword">self</span>.selectorMap setObject:<span class="built_in">NSStringFromSelector</span>(aSelector) forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line">    [<span class="keyword">self</span> postNotificationName:aName object:anObject userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(YANotificationName)aName object:(<span class="keyword">id</span>)anObject userInfo:(<span class="built_in">NSDictionary</span> *)aUserInfo &#123;</span><br><span class="line">    <span class="comment">// When the notification name is nil.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:(<span class="keyword">id</span>)kCFNull];</span><br><span class="line">        <span class="keyword">id</span> key = <span class="literal">nil</span>;</span><br><span class="line">        <span class="built_in">NSEnumerator</span> *enumerator = map.keyEnumerator;</span><br><span class="line">        <span class="keyword">while</span> (key = [enumerator nextObject]) &#123;</span><br><span class="line">            <span class="built_in">NSHashTable</span> *set = [map objectForKey:key];</span><br><span class="line">            <span class="built_in">NSArray</span> *selectorList = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (set == (<span class="keyword">id</span>)kCFNull) &#123;</span><br><span class="line">                selectorList = <span class="keyword">self</span>.selectorMap.allValues;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([set containsObject:anObject]) &#123;</span><br><span class="line">                selectorList = selectorListForSender(<span class="keyword">self</span>, anObject, YANotificationSenderTypeObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!selectorList) <span class="keyword">break</span>;</span><br><span class="line">            [selectorList enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *selector, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">                SEL sel = <span class="built_in">NSSelectorFromString</span>(selector);</span><br><span class="line">                ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))[key methodForSelector:sel])(<span class="keyword">self</span>, sel, aUserInfo);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normal process.</span></span><br><span class="line">    <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:aName];</span><br><span class="line">    <span class="keyword">id</span> key = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSEnumerator</span> *enumerator = map.keyEnumerator;</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        <span class="keyword">while</span> (key = [enumerator nextObject]) &#123;</span><br><span class="line">            <span class="built_in">NSHashTable</span> *set = [map objectForKey:key];</span><br><span class="line">            <span class="keyword">if</span> (set == (<span class="keyword">id</span>)kCFNull || [set containsObject:anObject]) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *selector = [<span class="keyword">self</span>.selectorMap objectForKey:generateKey(key, anObject, aName)];</span><br><span class="line">                <span class="keyword">if</span> (!selector) <span class="keyword">return</span>;</span><br><span class="line">                SEL sel = <span class="built_in">NSSelectorFromString</span>(selector);</span><br><span class="line">                ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))[key methodForSelector:sel])(<span class="keyword">self</span>, sel, aUserInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (key = [enumerator nextObject]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *selector = [<span class="keyword">self</span>.selectorMap objectForKey:generateKey(key, anObject, aName)];</span><br><span class="line">            <span class="keyword">if</span> (!selector) <span class="keyword">return</span>;</span><br><span class="line">            SEL sel = <span class="built_in">NSSelectorFromString</span>(selector);</span><br><span class="line">            ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))[key methodForSelector:sel])(<span class="keyword">self</span>, sel, aUserInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.observerMap.allValues enumerateObjectsUsingBlock:^(<span class="built_in">NSMapTable</span> *map, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        [map removeObjectForKey:observer];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.selectorMap removeObjectsForKeys:selectorListForSender(<span class="keyword">self</span>, observer, YANotificationSenderTypeObserver)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer name:(YANotificationName)aName object:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line">    <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:aName];</span><br><span class="line">    <span class="comment">// Remove selector.</span></span><br><span class="line">    [<span class="keyword">self</span>.selectorMap removeObjectForKey:generateKey(observer, anObject, aName)];</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        <span class="built_in">NSHashTable</span> *set = [map objectForKey:observer];</span><br><span class="line">        [set removeObject:anObject];</span><br><span class="line">        <span class="keyword">if</span> (set.count == <span class="number">0</span>) [map removeObjectForKey:observer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [map removeObjectForKey:observer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map.count == <span class="number">0</span>) [<span class="keyword">self</span>.observerMap removeObjectForKey:aName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">NSString</span> *generateKey(<span class="keyword">id</span> observer, <span class="keyword">id</span> anObject, YANotificationName name) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p_%@_%p"</span> ,anObject, name, observer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@_%p"</span>, name, observer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">NSArray</span> *selectorListForSender(YANotificationCenter *<span class="keyword">self</span>, <span class="keyword">id</span> object, YANotificationSenderType type) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *p = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, object];</span><br><span class="line">    <span class="built_in">NSPredicate</span> *predicate = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == YANotificationSenderTypeObject) &#123;</span><br><span class="line">        predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF BEGINSWITH %@"</span>, p];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF ENDSWITH %@"</span>, p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSArray</span> *keys = [<span class="keyword">self</span>.selectorMap.allKeys filteredArrayUsingPredicate:predicate];</span><br><span class="line">    <span class="built_in">NSArray</span> *result = [<span class="keyword">self</span>.selectorMap objectsForKeys:keys notFoundMarker:(<span class="keyword">id</span>)kCFNull];</span><br><span class="line">    <span class="keyword">return</span> result.count == <span class="number">0</span> ? <span class="literal">nil</span> : result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h1><ol><li>同步通知内部实现是维护了两层映射：第一层name作为key，第二层object作为key，最终把observer保存在数组中。iOS9之后对observer是安全的弱引用。</li><li>异步通知内部维护了一个双向链表以满足“聚合（NSNotificationCoalescing）”选项，依赖Runloop的迭代以满足“时机（NSPostingStyle）”选项。</li><li>使用子线程通知需要依靠NSMachPort的通信。</li></ol><p>日常开发中同步通知能满足绝大多数场景，异步通知的场景有限，苹果给出的几个例子还是很经典的。子线程通知也是常见的，比如子线程发通知主线程处理通知，但是我看大家都习惯直接利用GCD从子线程环境切换到主线程，再发出通知。</p><blockquote><p>参考资料：<br><a href="http://southpeak.github.io/2015/03/20/cocoa-foundation-nsnotificationcenter/" target="_blank" rel="noopener">《Notification与多线程》</a><br><a href="http://cloverkim.com/ios_notification-principle.html" target="_blank" rel="noopener">《NSNotification原理理解》</a><br><a href="https://philm.gitbook.io/philm-ios-wiki/mei-zhou-yue-du/shen-ru-si-kao-nsnotification" target="_blank" rel="noopener">《深入思考NSNotification》</a><br><a href="[](https://www.jianshu.com/p/83770200d476">《深入理解iOS NSNotification》</a>)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2019年10月14日 更新源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 探究NSNotificationCenter的实现并尝试自实现。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Weak Associated Object</title>
    <link href="http://blog.chenyalun.com/2019/01/20/Weak%20Associated%20Object/"/>
    <id>http://blog.chenyalun.com/2019/01/20/Weak Associated Object/</id>
    <published>2019-01-20T13:22:23.000Z</published>
    <updated>2019-08-28T12:04:08.062Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 给分类添加weak属性的几种方法。 </p><br><a id="more"></a><p></p><p>众所周知，通过Runtime的关联属性来给分类添加“属性”，这里的属性缺少了严格意义上的成员变量，而且是自己手动实现了getter方法和setter方法。几种关联策略中并没有与weak效果相媲美的选项，<code>OBJC_ASSOCIATION_ASSIGN</code>策略与weak效果的主要区别在于weak自动能将指向已销毁对象的指针指为nil。</p><h1 id="危险的ASSIGN"><a href="#危险的ASSIGN" class="headerlink" title="危险的ASSIGN"></a>危险的ASSIGN</h1><p>单纯使用ASSIGN容易诱发坏内存访问，原因无需多言。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">Default</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">id</span> strongObj;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span>(<span class="title">Default</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setStrongObj:(<span class="keyword">id</span>)strongObj &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(strongObj), strongObj, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)strongObj &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(strongObj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例如下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="built_in">NSObject</span> *main = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    main.strongObj = obj;</span><br><span class="line">    obj = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, main.strongObj); <span class="comment">// Crash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="极简方案"><a href="#极简方案" class="headerlink" title="极简方案"></a>极简方案</h1><p>这是一种极好的给分类添加<code>weak</code>属性的实现方式。看到这种实现方式后极为兴奋，实在太简洁、巧妙了。<code>__weak</code>本身就会把指针指向nil，那直接利用就是了。使用<code>OBJC_ASSOCIATION_COPY</code>关联策略将block copy到堆上，利用block把持有的<code>weak</code>对象返回，如果对象不存在了，返回的便是空值。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">Weak</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">id</span> object;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span>(<span class="title">Weak</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> weakObject = object;</span><br><span class="line">    <span class="keyword">id</span> (^block)(<span class="keyword">void</span>) = ^&#123; <span class="keyword">return</span> weakObject; &#125;;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(object), block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">id</span> (^block)(<span class="keyword">void</span>) = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(object));</span><br><span class="line">    <span class="keyword">return</span> (block ? block() : <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>这种方式是通过包装一个对象实现的。要求设置的关联对象是<code>YAWeakObject</code>类型。当这个对象销毁的时候调用<code>deallocBlock</code>，而在这个block中把关联的对象重新设置为<code>nil</code>(不可使用<code>objc_removeAssociatedObjects</code>直接移除关联对象)，这样访问这个关联对象的时候得到的就是nil值了。</p><p>这种方式会污染<code>weak</code>属性，要求被设置为<code>weak</code>属性的对象必须是某种类型，不是太好。当然根据这种思路，还可以进一步封装，最终的落脚点无非是提供新的方法接口替代原生的运行时方法(见<a href="https://www.jianshu.com/p/ed65d71554d8" target="_blank" rel="noopener">参考文章</a>)。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">WeakClass</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) YAWeakObject *weakObject;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span>(<span class="title">WeakClass</span>)</span></span><br><span class="line">- (YAWeakObject *)weakObject &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObject));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWeakObject:(YAWeakObject *)weakObject &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObject), weakObject, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    <span class="keyword">typeof</span>(<span class="keyword">self</span>) slf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="keyword">typeof</span>(slf) <span class="keyword">self</span> = slf;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObject), <span class="literal">nil</span>, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    &#125;;</span><br><span class="line">    [weakObject setDeallocBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><h1 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h1><p>实际上使用支持弱引用的容器如<code>NSHashTable</code>、<code>NSMapTable</code>、<code>NSPointerArray</code>都是可以实现的。原理很简单，使用容器持有关联的对象，当该对象不存在时，容器自身便有自动移除已销毁对象的特性，这样就实现了<code>weak</code>属性。</p><blockquote><p>NSMapTable 可以持有键和值的弱引用，当键或者值当中的一个被释放时，整个这一项就会被移除掉。<br>NSHashTable 可以持有成员的弱引用。<br>NSPointerArray 可以持有成员的弱引用，当成员不存在时自动把所在index置为NULL。</p></blockquote><p>这种做法需要创建一个容器，相对比较麻烦。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">WeakContainer</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">id</span> weakObj;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span>(<span class="title">WeakContainer</span>)</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSPointerArray</span> *gPointerArray = <span class="literal">nil</span>;</span><br><span class="line">- (<span class="keyword">id</span>)weakObj &#123;</span><br><span class="line">    <span class="keyword">if</span> (!gPointerArray) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// Removes NULL values from the receiver.(sometimes doesn't work as documented)</span></span><br><span class="line">    [gPointerArray compact];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> gPointerArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObj));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gPointerArray = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWeakObj:(<span class="keyword">id</span>)weakObj &#123;</span><br><span class="line">    <span class="keyword">if</span> (weakObj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!gPointerArray) gPointerArray = [<span class="built_in">NSPointerArray</span> weakObjectsPointerArray];</span><br><span class="line">        [gPointerArray addPointer:(__bridge <span class="keyword">void</span> *)weakObj];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObj), weakObj, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>其实看到作者的思路（极简方案）确实挺有感触的，完全利用现有的<code>__weak</code>关键字配合block，没有冗余的包装，方法精简且巧妙。去年在想这个问题的时候，也是考虑很多，在<a href="https://blog.chenyalun.com/2018/07/10/Runtime基础/#关联引用">《Runtime基础》</a>一文中描述了我当时的思路，基本上也是从<strong>把指针置为nil</strong>这个角度出发，或者派生子类重写dealloc，或者使用弱引用容器，都不够巧妙。</p><p>很多时候，好的思路，灵光一现的想法，真的无比重要。就像bang哥在<a href="https://github.com/bang590/JSPatch/wiki/JSPatch-实现原理详解" target="_blank" rel="noopener">写JSPatch</a>时：</p><blockquote><p>当时继续苦苦寻找解决方案，若按 JS 语法，这是唯一的方法，但若不按 JS 语法呢？突然脑洞开了下，CoffieScript/JSX 都可以用 JS 实现一个解释器实现自己的语法，我也可以通过类似的方式做到，再进一步想到其实我想要的效果很简单，就是调用一个不存在方法时，能转发到一个指定函数去执行，就能解决一切问题了，这其实可以用简单的字符串替换，把 JS 脚本里的方法调用都替换掉。</p></blockquote><p>还有一个东西在作者的文章里看到，比较有意思，这里提一下。</p><p><strong>Weak Singleton</strong></p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedWeakInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> __<span class="keyword">weak</span> <span class="keyword">id</span> weakObj = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> strongObj = weakObj;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strongObj) &#123;</span><br><span class="line">            strongObj = [[<span class="keyword">self</span> <span class="keyword">class</span>] new];</span><br><span class="line">            weakObj = strongObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strongObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>应用场景:不需要保存公共的信息、用户状态等，符合“用完就走”。如果类似LoginManager管理登录状态，继承自 AFHttpSessionManager的NetworkManager单例，App单例ClientManager等则不适用这种方式。</p></blockquote><blockquote><p>参考资料：<br><a href="https://www.jianshu.com/p/ed65d71554d8" target="_blank" rel="noopener">如何使用 Runtime 给现有的类添加 weak 属性</a><br><a href="https://blog.csdn.net/yan_1564335/article/details/53996538" target="_blank" rel="noopener">iOS给类别添加weak属性</a><br><a href="http://mrpeak.cn/blog/ios-weak/" target="_blank" rel="noopener">iOS weak 关键字漫谈</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 给分类添加weak属性的几种方法。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>「KVOController」的封装</title>
    <link href="http://blog.chenyalun.com/2019/01/12/%E3%80%8CKVOController%E3%80%8D%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://blog.chenyalun.com/2019/01/12/「KVOController」的封装/</id>
    <published>2019-01-12T13:45:10.000Z</published>
    <updated>2019-08-28T11:42:20.827Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 学习KVO的封装。 </p><br><a id="more"></a><p></p><p>KVOController源码只有700行左右，读一遍下来还是比较通畅的。这里做一个记录。</p><h1 id="一、使用"><a href="#一、使用" class="headerlink" title="一、使用"></a>一、使用</h1><p>使用起来极其简便。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置所观察的对象及其keyPath</span></span><br><span class="line">[<span class="keyword">self</span>.KVOController observe:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, change[<span class="built_in">NSKeyValueChangeNewKey</span>]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这里的<code>self.KVOController</code>可以自己创建，也可以使用默认，因为<code>KVOController</code>是懒加载的。</p><p>一般情况下是像上面这样使用的，还有一种情况，不需要强持有被观察者的时候：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.KVOControllerNonRetaining observe:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, change[<span class="built_in">NSKeyValueChangeNewKey</span>]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>只需使用<code>self.KVOControllerNonRetaining</code>即可不增加被观察者<code>self.myButton</code>的引用计数。</p><h1 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h1><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> NSObject (FBKVOController)</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) FBKVOController *KVOController;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) FBKVOController *KVOControllerNonRetaining;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>要实现以上使用的方式，是给 <code>NSObject</code> 分类添加两个属性:<code>KVOController</code>和<code>KVOControllerNonRetaining</code>。这个比较简单，使用<code>Runtime</code> 的关联属性即可。值得一提的是作者在 <code>getter</code> 方法里使用了懒加载，只有当使用到<code>KVOController</code>或者<code>KVOControllerNonRetaining</code>的时候，才会创建。当然，也可以选择自行创建。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (FBKVOController *)KVOController &#123;</span><br><span class="line">  <span class="keyword">id</span> controller = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">NSObjectKVOControllerKey</span>);</span><br><span class="line">  <span class="comment">// 懒加载KVOController, 用到时才会创建</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == controller) &#123;</span><br><span class="line">    controller = [FBKVOController controllerWithObserver:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">self</span>.KVOController = controller;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (FBKVOController *)KVOControllerNonRetaining &#123;</span><br><span class="line">  <span class="keyword">id</span> controller = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">NSObjectKVOControllerNonRetainingKey</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == controller) &#123;</span><br><span class="line">    controller = [[FBKVOController alloc] initWithObserver:<span class="keyword">self</span> retainObserved:<span class="literal">NO</span>];</span><br><span class="line">    <span class="keyword">self</span>.KVOControllerNonRetaining = controller;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个 <code>getter</code> 方法分别对应强引用被观察者和弱引用被观察者。</p><h1 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h1><p>由此可以看到，核心功能的实现依赖于<code>FBKVOController</code>。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)controllerWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造器</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer retainObserved:(<span class="built_in">BOOL</span>)retainObserved <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new <span class="built_in">NS_UNAVAILABLE</span>;</span><br></pre></td></tr></table></figure><p>构造方法里主要暴露了两种初始化方式，其中通过<code>initWithObserver</code>这个方法可以设置参数<code>retainObserved</code>以表明是否需要强引用被观察者。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> observer;</span><br></pre></td></tr></table></figure><p>只有一个只读属性，给出被观察者对象。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options block:(FBKVONotificationBlock)block;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options action:(SEL)action;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure><p>作者给出了回调的三个选项：block回调，选择子回调以及 KVO 默认方法回调。可以在添加被观察者的时候自行选择。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPaths options:(<span class="built_in">NSKeyValueObservingOptions</span>)options block:(FBKVONotificationBlock)block;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPaths options:(<span class="built_in">NSKeyValueObservingOptions</span>)options action:(SEL)action;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPaths options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure><p>考虑到不一定只观察一个对象的一个成员变量，因此作者提供了<code>keyPaths</code>选项，可以同时观察一个对象的多个keyPath：传入一个字符串数组即可。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="keyword">void</span>)unobserveAll;</span><br></pre></td></tr></table></figure><p>移除监听提供三种接口：移除某个对象某个keyPath 的监听，移除对某个对象的监听，取消观察者对所有对象的所有监听。</p><h1 id="四、FBKVOController实现"><a href="#四、FBKVOController实现" class="headerlink" title="四、FBKVOController实现"></a>四、FBKVOController实现</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FBKVOController</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSMapTable</span>&lt;<span class="keyword">id</span>, <span class="built_in">NSMutableSet</span>&lt;_FBKVOInfo *&gt; *&gt; *_objectInfosMap;</span><br><span class="line">  pthread_mutex_t _lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FBKVOController</code>主要维护了一个<code>NSMapTable</code>。<code>key</code> 是所观察的对象，<code>value</code> 是<code>NSMutableSet</code>类型的集合(内部元素是<code>_FBKVOInfo</code>类型)。维护一个<code>NSMapTable</code>的原因是：便于观察一个对象的多个<code>keyPath</code>，这个对象作为 <code>key</code>，这许多个<code>keyPath</code>封装成一个个<code>_FBKVOInfo</code>存入<code>NSMutableSet</code>中。另外一个成员变量<code>_lock</code>主要是保证线程安全。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer retainObserved:(<span class="built_in">BOOL</span>)retainObserved &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) &#123;</span><br><span class="line">    _observer = observer;</span><br><span class="line">    <span class="comment">// 根据是否retainObserved，选择NSMapTable的"强-强"或者"弱-强"</span></span><br><span class="line">    <span class="built_in">NSPointerFunctionsOptions</span> keyOptions = retainObserved ? <span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> : <span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span>;</span><br><span class="line">    _objectInfosMap = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:keyOptions valueOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPersonality</span> capacity:<span class="number">0</span>];</span><br><span class="line">    pthread_mutex_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FBKVOController</code>所有暴露的构造方法接口都指向了上面的那个实现。这个方法只做了三件事: 1，初始化线程锁<code>_lock</code>，2，根据<code>retainObserved</code>参数创建不同类型的<code>NSMapTable</code>，是选择”强-强”还是选择”弱-强”。3，属性<code>observer</code>赋值。</p><p>由此可见，<code>FBKVOController</code>本身对被观察者<code>observer</code>是弱引用的(有一个 <code>weak</code> 属性的<code>observer</code>成员变量)，通过维护一个<code>NSMapTable</code>来最终确定对被观察者的强弱引用关系。</p><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">observe:</span>(nullable id)object <span class="string">keyPath:</span>(NSString *)keyPath <span class="string">options:</span>(NSKeyValueObservingOptions)options <span class="string">block:</span>(FBKVONotificationBlock)block &#123;</span><br><span class="line">  <span class="keyword">if</span> (nil == object || <span class="number">0</span> == keyPath.length || NULL == block) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建数据结构_FBKVOInfo</span></span><br><span class="line">  _FBKVOInfo *info = [[_FBKVOInfo alloc] <span class="string">initWithController:</span>self <span class="string">keyPath:</span>keyPath <span class="string">options:</span>options <span class="string">block:</span>block];</span><br><span class="line">  <span class="comment">// 添加对object的观察, 并传入info</span></span><br><span class="line">  [self <span class="string">_observe:</span>object <span class="string">info:</span>info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以添加一个被观察者并且回调是 block 为例。在这个方法里首先是对参数的合理性判断，要求<code>object</code>、<code>keyPath</code>以及<code>block</code>均是合理值。<br> 接着把<code>keyPath</code>、<code>options</code>、<code>block</code>包装成一个数据结构<code>_FBKVOInfo</code>。<br> 最后调用自己的<code>_observe:info:</code>方法，传入<code>object</code>和<code>info</code>。</p><h3 id="FBKVOInfo数据结构"><a href="#FBKVOInfo数据结构" class="headerlink" title="_FBKVOInfo数据结构"></a>_FBKVOInfo数据结构</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">_FBKVOInfo </span>: NSObject</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> _FBKVOInfo &#123;</span><br><span class="line"><span class="variable">@public</span></span><br><span class="line">  __weak FBKVOController *_controller;</span><br><span class="line">  <span class="selector-tag">NSString</span> *<span class="selector-tag">_keyPath</span>;</span><br><span class="line">  <span class="selector-tag">NSKeyValueObservingOptions</span> <span class="selector-tag">_options</span>;</span><br><span class="line">  <span class="selector-tag">SEL</span> <span class="selector-tag">_action</span>;</span><br><span class="line">  <span class="selector-tag">void</span> *<span class="selector-tag">_context</span>;</span><br><span class="line">  <span class="selector-tag">FBKVONotificationBlock</span> <span class="selector-tag">_block</span>;</span><br><span class="line">  <span class="selector-tag">_FBKVOInfoState</span> <span class="selector-tag">_state</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_FBKVOInfo</code>是一个数据结构，包含了监听的<code>keyPath</code>、<code>block</code>、选择子、<code>context</code>等等元素。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithController:(FBKVOController *)controller</span><br><span class="line">                           keyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                           options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</span><br><span class="line">                             block:(<span class="keyword">nullable</span> FBKVONotificationBlock)block</span><br><span class="line">                            action:(<span class="keyword">nullable</span> SEL)action</span><br><span class="line">                           context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) &#123;</span><br><span class="line">    _controller = controller;</span><br><span class="line">    _block = [block <span class="keyword">copy</span>];</span><br><span class="line">    _keyPath = [keyPath <span class="keyword">copy</span>];</span><br><span class="line">    _options = options;</span><br><span class="line">    _action = action;</span><br><span class="line">    _context = context;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法的实现就是这样，不过有两个关键点:<code>block</code>和<code>keyPath</code>调用一下 <code>copy</code> 方法。<br><code>keyPath</code>调用一下 <code>copy</code>的原因是，这里的<code>_keyPath</code>是使用<code>__strong</code>修饰的，如果外面传进来的是不可变字符串，自然没有啥问题，可是一旦传进来一个可变字符串，如果直接赋值<code>_keyPath = keyPath;</code>，当这个可变字符串改变就会造成<code>_keyPath</code>也改变，比较容易产生不可控事件，所以调用 <code>copy</code>方法，也即是深复制浅复制的问题。</p><p>没有深复制的示例如下：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"key"</span>];</span><br><span class="line"><span class="comment">// 假定是_keyPath = keyPath;而不是_keyPath = [keyPath copy];</span></span><br><span class="line">_FBKVOInfo *info = [[_FBKVOInfo alloc] initWithController:<span class="keyword">self</span> keyPath:str options:<span class="built_in">NSKeyValueObservingOptionNew</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">   </span><br><span class="line">&#125; action:<span class="keyword">@selector</span>(push) context:<span class="literal">nil</span>];</span><br><span class="line">[str appendString:<span class="string">@"new"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, info-&gt;_keyPath); <span class="comment">//info-&gt;_keyPath不符合预期的改变了</span></span><br></pre></td></tr></table></figure><p>同样，<code>block</code> 的<code>copy</code>是把<code>block</code>从栈拷贝到堆中，防止被释放。因为<code>block</code>作为参数传入函数不会被 <code>copy</code>，依然在栈上，方法执行完立即释放的。</p><blockquote><p>在ARC下：大部分情况下系统会把Block自动copy到堆上。</p><p>Block作为变量：<br>方法中声明一个 block 的时候是在栈上；<br>引用了外部局部变量或成员变量, 并且有赋值操作（有名字），会被 copy 到堆上；<br>赋值给附有__strong修饰符的id类型的类或者Blcok类型成员变量时；<br>赋值给一个 weak 变量不会被 copy；</p><p>Block作为属性：<br>用 copy 修饰会被 copy；</p><p>Block作为函数参数：<br>作为参数传入函数不会被 copy，依然在栈上，方法执行完即释放；<br>作为函数的返回值会被 copy 到堆；</p></blockquote><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">  <span class="keyword">return</span> [_keyPath hash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)<span class="keyword">object</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nil == <span class="keyword">object</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self == <span class="keyword">object</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (![<span class="keyword">object</span> isKindOfClass:[self <span class="class"><span class="keyword">class</span>]]) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [_keyPath isEqualToString:((_FBKVOInfo *)<span class="keyword">object</span>)-&gt;_keyPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_FBKVOInfo</code>还做了一点其他的事：<br>1.重写了<code>- (NSUInteger)hash;</code>方法，使用<code>_keyPath</code>的 <code>hash</code> 值来作为<code>_FBKVOInfo</code>的 <code>hash</code> 值。分配的这个<code>hash</code>值(即用于查找集合中成员的位置标识)，就是通过<code>hash</code>方法计算得来的，且<code>hash</code>方法返回的<code>hash</code>值最好唯一。<br>2.重写了<code>- (BOOL)isEqual:(id)object;</code>方法，满足<code>Equal</code>的条件有两个: 首先是类对象一致，再者是<code>_keyPath</code>匹配。换句话说，<code>_keyPath</code>决定了<code>_FBKVOInfo</code>是否是同一个。为了优化判等的效率，基于<code>hash</code>的<code>NSSet</code>和<code>NSDictionary</code>在判断成员是否相等时， 会这样做Step1: 成员的<code>hash</code>值是否和目标<code>hash</code>值相等，如果相同进入Step 2，如果不等，直接判断不相等<br>Step 2: <code>hash</code>值相同(即Step 1)的情况下，再进行对象判等， 作为判等的结果。</p><blockquote><p>hash值是对象判等的必要非充分条件</p></blockquote><p><code>NSPointerFunctionsObjectPointerPersonality</code>对于 <code>isEqual:</code> 和 <code>hash</code> 使用直接的指针比较。使用移位指针(shifted pointer)来做hash检测及确定两个对象是否相等；同时使用description方法来做描述字符串。</p><blockquote><p>Personalities determine hashing and equality. NSPointerFunctionsObjectPersonality provides the standard Foundation behavior of using hash and isEqual:. You can also use NSPointerFunctionsObjectPointerPersonality, which treats the contents as objects, but uses direct pointer value comparison; this is useful if you need a collection to work with object identity rather than value.<br>NSPointerFunctionsObjectPointerPersonality 使用 <code>==</code>判断相等<br>NSPointerFunctionsObjectPersonality 使用<code>hash</code>和<code>isEqual:</code>判断相等 </p></blockquote><h3 id="observe-info-方法"><a href="#observe-info-方法" class="headerlink" title="_observe:info:方法"></a>_observe:info:方法</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)<span class="variable">_observe</span>:(id)object info:(<span class="variable">_FBKVOInfo</span> *)info &#123;</span><br><span class="line">  <span class="comment">// lock</span></span><br><span class="line">  pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">  NSMutableSet *infos = [<span class="variable">_objectInfosMap</span> objectForKey:object];</span><br><span class="line">  <span class="comment">// 检查infos是否存在于_objectInfosMap中</span></span><br><span class="line">  <span class="variable">_FBKVOInfo</span> *existingInfo = [infos member:info];</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != existingInfo) &#123;</span><br><span class="line">    <span class="comment">// 已经存在了，return</span></span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不存在，创建infos并保存于_objectInfosMap中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == infos) &#123;</span><br><span class="line">    infos = [NSMutableSet <span class="built_in">set</span>];</span><br><span class="line">    [<span class="variable">_objectInfosMap</span> setObject:infos forKey:object];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把info添加到infos中</span></span><br><span class="line">  [infos addObject:info];</span><br><span class="line">  pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">  <span class="comment">// _FBKVOSharedController添加观察</span></span><br><span class="line">  [[<span class="variable">_FBKVOSharedController</span> sharedController] observe:object info:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先加锁。把被观察的对象<code>object</code>作为<code>key</code>从自己的<code>_objectInfosMap</code>获取其对应的<code>NSMutableSet</code>类型的集合，如果这个集合包含了已经封装好的<code>info</code>对象，说明已经对这个<code>info</code>添加过监听了，解锁直接 return 就是了。<br>如果这个<code>infos</code>集合不存在，创建。把<code>info</code>元素添加到这个<code>infos</code>集合中。解锁。调用<code>[[_FBKVOSharedController sharedController] observe:object info:info];</code>方法。</p><p>可见这个方法主要是使用<code>_objectInfosMap</code>保存了封装好的<code>info</code>对象，具体监听调用逻辑依赖于<code>_FBKVOSharedController</code>。</p><h1 id="五、-FBKVOSharedController实现"><a href="#五、-FBKVOSharedController实现" class="headerlink" title="五、_FBKVOSharedController实现"></a>五、_FBKVOSharedController实现</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_FBKVOSharedController</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedController;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">id</span>)object info:(<span class="keyword">nullable</span> _FBKVOInfo *)info;</span><br><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">id</span>)object info:(<span class="keyword">nullable</span> _FBKVOInfo *)info;</span><br><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">id</span>)object infos:(<span class="keyword">nullable</span> <span class="built_in">NSSet</span> *)infos;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_FBKVOSharedController</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSHashTable</span>&lt;_FBKVOInfo *&gt; *_infos;</span><br><span class="line">  pthread_mutex_t _mutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_FBKVOSharedController</code>是一个单例。作用是观察 <code>_FBKVOInfo</code> 中的 <code>keyPath</code>，并给予回调(回调的类型可以是 <code>block</code>、<code>selector</code>、系统回调方法)。</p><p> 暴露出两个方法:</p><ol><li>添加监听，参数为<code>_infos</code></li><li><p>移除监听，参数为<code>_FBKVOInfo</code>或者<code>NSSet</code>类型的<code>infos</code>(容器内的元素仍然是<code>_FBKVOInfo</code>)</p><p>内部维护了一个哈希表(NSHashTable)<code>_infos</code>，用于保存这些<code>_FBKVOInfo</code>。除此之外还有一个锁:<code>_mutex</code>，用于实现线程安全。</p><p>哈希表的创建:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSHashTable</span> *infos = [<span class="built_in">NSHashTable</span> alloc];</span><br><span class="line">_infos = [infos initWithOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> capacity:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSPointerFunctionsWeakMemory</span>: 持弱指针引用着_FBKVOInfo对象。</span><br><span class="line"><span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> 使用==判定相等。</span><br></pre></td></tr></table></figure></li></ol><p>可见<code>_FBKVOSharedController</code>只是单纯地掌管<code>_FBKVOInfo</code>集合，它只需要解析<code>_FBKVOInfo</code>并给observer回调即可，其他的一切都不关心。</p><h2 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">observe:</span>(id)object <span class="string">info:</span>(nullable _FBKVOInfo *)info &#123;</span><br><span class="line">  <span class="keyword">if</span> (nil == info) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// _infos添加对象</span></span><br><span class="line">  pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">  [_infos <span class="string">addObject:</span>info];</span><br><span class="line">  pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">  <span class="comment">// 添加观察，传入的context是info</span></span><br><span class="line">  [object <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>info-&gt;_keyPath <span class="string">options:</span>info-&gt;_options <span class="string">context:</span>(<span class="keyword">void</span> *)info];</span><br><span class="line">  <span class="keyword">if</span> (info-&gt;_state == _FBKVOInfoStateInitial) &#123;</span><br><span class="line">    info-&gt;_state = _FBKVOInfoStateObserving; <span class="comment">// 初始状态转监听状态</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;_state == _FBKVOInfoStateNotObserving) &#123; <span class="comment">// 未监听状态便移除</span></span><br><span class="line">    <span class="comment">// this could happen when `NSKeyValueObservingOptionInitial` is one of the NSKeyValueObservingOptions,</span></span><br><span class="line">    <span class="comment">// and the observer is unregistered within the callback block.</span></span><br><span class="line">    <span class="comment">// at this time the object has been registered as an observer (in Foundation KVO),</span></span><br><span class="line">    <span class="comment">// so we can safely unobserve it.</span></span><br><span class="line">    <span class="comment">// NSKeyValueObservingOptionInitial：添加观察者时就触发回调，并且在后面赋值时也会触发回调，但是都只返回NSKeyValueChangeKindKey。观察者在callback block中取消观察，所以在这里removeObserver</span></span><br><span class="line">    [object <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>info-&gt;_keyPath <span class="string">context:</span>(<span class="keyword">void</span> *)info];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器中添加 info 元素，添加监听。</p><h2 id="移除监听"><a href="#移除监听" class="headerlink" title="移除监听"></a>移除监听</h2><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)unobserve:(id)object info:(nullable <span class="variable">_FBKVOInfo</span> *)info &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == info) return;</span><br><span class="line">  <span class="comment">// 哈希表中移除info</span></span><br><span class="line">  pthread_mutex_lock(&amp;<span class="variable">_mutex</span>);</span><br><span class="line">  [<span class="variable">_infos</span> removeObject:info];</span><br><span class="line">  pthread_mutex_unlock(&amp;<span class="variable">_mutex</span>);</span><br><span class="line">  <span class="comment">// 移除监听</span></span><br><span class="line">  <span class="keyword">if</span> (info-&gt;<span class="variable">_state</span> == <span class="variable">_FBKVOInfoStateObserving</span>) &#123;</span><br><span class="line">    [object removeObserver:self forKeyPath:info-&gt;<span class="variable">_keyPath</span> context:(void *)info];</span><br><span class="line">  &#125;</span><br><span class="line">  info-&gt;<span class="variable">_state</span> = <span class="variable">_FBKVOInfoStateNotObserving</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器中移除 info 元素，移除监听。</p><h2 id="系统KVO调用"><a href="#系统KVO调用" class="headerlink" title="系统KVO调用"></a>系统KVO调用</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change</span><br><span class="line">                       context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context &#123;</span><br><span class="line">  _FBKVOInfo *info;</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    <span class="comment">// 看看info是否存在于_infos中，如果存在，返回info</span></span><br><span class="line">    info = [_infos member:(__bridge <span class="keyword">id</span>)context];</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != info) &#123;</span><br><span class="line">    <span class="comment">// 局部变量强引用controller</span></span><br><span class="line">    FBKVOController *controller = info-&gt;_controller;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != controller) &#123;</span><br><span class="line">      <span class="comment">// 局部变量强引用observer</span></span><br><span class="line">      <span class="keyword">id</span> observer = controller.observer;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">nil</span> != observer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;_block) &#123;  <span class="comment">// 回调 block</span></span><br><span class="line">          <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *changeWithKeyPath = change;</span><br><span class="line">          <span class="keyword">if</span> (keyPath) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *mChange = [<span class="built_in">NSMutableDictionary</span> dictionaryWithObject:keyPath forKey:FBKVONotificationKeyPathKey];</span><br><span class="line">            [mChange addEntriesFromDictionary:change];</span><br><span class="line">            changeWithKeyPath = [mChange <span class="keyword">copy</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          info-&gt;_block(observer, object, changeWithKeyPath);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;_action) &#123; <span class="comment">// 回调 selector</span></span><br><span class="line">          [observer performSelector:info-&gt;_action withObject:change withObject:object];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 调用KVO 系统方法</span></span><br><span class="line">          [observer observeValueForKeyPath:keyPath ofObject:object change:change context:info-&gt;_context];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终在系统方法中给予不同类型的回调。</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(uint8_t, <span class="variable">_FBKVOInfoState</span>) &#123;</span><br><span class="line">  <span class="variable">_FBKVOInfoStateInitial</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="variable">_FBKVOInfoStateObserving</span>,</span><br><span class="line">  <span class="variable">_FBKVOInfoStateNotObserving</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作者使用了三个枚举值来记录监听状态。会不会是多此一举呢？不会。作用主要体现在添加监听的方法里有个移除监听操作：</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 添加观察，传入的context是info</span></span><br><span class="line">[<span class="function"><span class="title">object</span> addObserver:self forKeyPath:info-&gt;</span>_<span class="function"><span class="title">keyPath</span> options:info-&gt;</span>_options context:(void *)info];</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="title">if</span> (info-&gt;</span>_state == _FBKVOInfoStateInitial) &#123;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>_state = _FBKVOInfoStateObserving; <span class="comment">// 初始状态转监听状态</span></span><br><span class="line">  &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (info-&gt;</span>_state == _FBKVOInfoStateNotObserving) &#123; <span class="comment">// 未监听状态便移除</span></span><br><span class="line">    [<span class="function"><span class="title">object</span> removeObserver:self forKeyPath:info-&gt;</span>_keyPath context:(void *)info];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>“未监听状态便移除“是怎么出现的？示例如下：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.KVOController observe:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span> options:<span class="built_in">NSKeyValueObservingOptionInitial</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">     [<span class="keyword">self</span>.KVOController unobserve:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>包含了<code>NSKeyValueObservingOptionInitial</code>选项且在回调中移除了监听就会出现这种情况。因为如果有<code>NSKeyValueObservingOptionInitial</code>选项，在添加监听的时候就会有回调。调用栈如下：<br><img src="https://image.chenyalun.com/2019/01/07/001.png" style="zoom:70%"><br>执行到<code>[object addObserver:self forKeyPath:info-&gt;_keyPath options:info-&gt;_options context:(void *)info];</code>这行代码的时候，首先添加监听，接着调用回调，而回调中又移除了观察，这时info的状态被设置为<code>_FBKVOInfoStateNotObserving</code>。接着进入了下面的 if-else 判断中，才有了移除监听的操作。可见逻辑非常严谨。</p><p>NSKeyValueObservingOption参考：</p><blockquote><p>NSKeyValueObservingOptionNew：接收方法中使用change参数传入变化后的新值，键为：&gt;NSKeyValueChangeNewKey；<br>NSKeyValueObservingOptionOld：接收方法中使用change参数传入变化前的旧值，键为：&gt;NSKeyValueChangeOldKey；<br>NSKeyValueObservingOptionInitial：注册之后立刻调用接收方法，如果配置了&gt;NSKeyValueObservingOptionNew，change参数内容会包含新值，键为：&gt;NSKeyValueChangeNewKey；<br>NSKeyValueObservingOptionPrior：如果加入这个参数，接收方法会在变化前后分别调用一次，共两&gt;次，变化前的通知change参数包含notificationIsPrior = 1。其他内容根据&gt;NSKeyValueObservingOptionNew和NSKeyValueObservingOptionOld的配置确定。</p></blockquote><h1 id="六、一个函数"><a href="#六、一个函数" class="headerlink" title="六、一个函数"></a>六、一个函数</h1><p>其实不是一个函数，不过是为了实现一个功能，核心还是一个函数。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.枚举字符串化</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *describe_option(<span class="built_in">NSKeyValueObservingOptions</span> option) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionNew</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionNew"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionOld</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionOld"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionInitial</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionInitial"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionPrior</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionPrior"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"unexpected option %tu"</span>, option);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.拼接option</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> append_option_description(<span class="built_in">NSMutableString</span> *s, <span class="built_in">NSUInteger</span> option) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == s.length) &#123;</span><br><span class="line">        [s appendString:describe_option(option)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [s appendString:<span class="string">@"|"</span>];</span><br><span class="line">        [s appendString:describe_option(option)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.NSKeyValueObservingOptions类型值遍历</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSUInteger</span> enumerate_flags(<span class="built_in">NSUInteger</span> *ptrFlags) &#123;</span><br><span class="line">    <span class="built_in">NSCAssert</span>(ptrFlags, <span class="string">@"expected ptrFlags"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ptrFlags) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> flags = *ptrFlags;</span><br><span class="line">    <span class="keyword">if</span> (!flags)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> flag = <span class="number">1</span> &lt;&lt; __builtin_ctzl(flags);</span><br><span class="line">    flags &amp;= ~flag;</span><br><span class="line">    *ptrFlags = flags;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.把options所有值都拼出来</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *describe_options(<span class="built_in">NSKeyValueObservingOptions</span> options) &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *s = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    <span class="built_in">NSUInteger</span> option;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != (option = enumerate_flags(&amp;options))) &#123;</span><br><span class="line">        append_option_description(s, option);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不使用 switch-case 把位移枚举的值遍历出来了。</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Similar to __builtin_ctz, except the argument type is unsigned long.</span></span><br><span class="line"><span class="comment">// __builtin_ctz(x)：x末尾0的个数</span></span><br><span class="line"><span class="comment">// 左移__builtin_ctz(x)位得到原先的枚举值</span></span><br><span class="line">NSUInteger flag = <span class="number">1</span> &lt;&lt; __builtin_ctzl(<span class="keyword">flags</span>);</span><br><span class="line"><span class="comment">// flags 去除已经取到的值</span></span><br><span class="line"><span class="keyword">flags</span> &amp;= ~flag;</span><br><span class="line"><span class="comment">// 把更新后的flags赋予指向ptrFlags的指针</span></span><br><span class="line">*ptrFlags = <span class="keyword">flags</span>;</span><br></pre></td></tr></table></figure><p>不失为一个好办法。</p><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><blockquote><p>使用 KVOController 进行键值观测可以说完美地解决了在使用原生 KVO 时遇到的各种问题。</p><p>1.不需要手动移除观察者；<br>2.实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；<br>3.使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；<br>4.每一个 keyPath 会对应一个属性，不需要在 block 中使用 if 判断 keyPath；</p></blockquote><p>以上引自draveness。解释如下：<br>1.NSMapTable 可以持有键和值的弱引用，当键或者值当中的一个被释放时，整个这一项就会被移除掉。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里使用被观察者observer作为强引用或者弱引用的key，使用_FBKVOInfo作为强引用的value</span></span><br><span class="line"><span class="built_in">NSPointerFunctionsOptions</span> keyOptions = retainObserved ? <span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> : <span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span>;</span><br><span class="line">_objectInfosMap = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:keyOptions valueOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPersonality</span> capacity:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>2.因为是在@selector(observeValueForKeyPath:ofObject:change:context:)中处理的回调。<br>3.使用FBKVONotificationBlock。<br>4._FBKVOInfo封装。</p><p>纵观全部代码，作者首先给分类添加了两个属性，用于接口调用。这些属性都指向了FBKVOController，FBKVOController主要维护了一个NSMapTable。key 是所观察的对象，value 是NSMutableSet类型的集合，其内部元素是_FBKVOInfo类型对象。一个_FBKVOInfo对象对应一个信息封装。之所以使用NSMapTable集合是便于对同一个对象的多个keyPath进行观察，同时处理被观察者的强弱引用。另外_FBKVOInfo对象是对FBKVOController、keyPath、context、回调block等信息的封装。最后，各个FBKVOController把所有对观察的处理交给单例_FBKVOSharedController，这个单例调用系统KVO方法回调、处理包含所有_FBKVOInfo对象的NSHashTable集合。</p><blockquote><p>参考资料<br><a href="https://github.com/draveness/analyze/blob/master/contents/KVOController/KVOController.md" target="_blank" rel="noopener">KVOController</a><br><a href="https://blog.csdn.net/DonnyDN/article/details/77750751" target="_blank" rel="noopener">iOS中Block使用注意点</a><br><a href="https://www.jianshu.com/p/915356e280fc" target="_blank" rel="noopener">isEqual与hash</a><br><a href="https://blog.kyleduo.com/2014/10/20/ios_learning-kvo/" target="_blank" rel="noopener">iOS学习笔记——KVO</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 学习KVO的封装。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>读「YYCache」</title>
    <link href="http://blog.chenyalun.com/2019/01/02/%E8%AF%BB%E3%80%8CYYCache%E3%80%8D/"/>
    <id>http://blog.chenyalun.com/2019/01/02/读「YYCache」/</id>
    <published>2019-01-02T07:22:17.000Z</published>
    <updated>2019-09-17T07:12:50.754Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 关于YYCache的简单总结。 </p><br><a id="more"></a><p></p><p>阅读YYCache源码有3遍了，自我感觉“需要理解”的部分掌握的差不多了，做个记录。</p><h1 id="一、接口"><a href="#一、接口" class="headerlink" title="一、接口"></a>一、接口</h1><p>API 类似字典，比较容易理解。</p><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYMemoryCache *memoryCache;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYDiskCache *diskCache;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)cacheWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)cacheWithPath:(<span class="built_in">NSString</span> *)path;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</span><br></pre></td></tr></table></figure><h2 id="2-是否存在"><a href="#2-是否存在" class="headerlink" title="2.是否存在"></a>2.是否存在</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block;</span><br></pre></td></tr></table></figure><h2 id="3-查询"><a href="#3-查询" class="headerlink" title="3.查询"></a>3.查询</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object))block;</span><br></pre></td></tr></table></figure><h2 id="4-设值"><a href="#4-设值" class="headerlink" title="4.设值"></a>4.设值</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br></pre></td></tr></table></figure><h2 id="5-移除"><a href="#5-移除" class="headerlink" title="5.移除"></a>5.移除</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key))block;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</span><br></pre></td></tr></table></figure><h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYCache</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>) init &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Use \"initWithName\" or \"initWithPath\" to create YYCache instance."</span>);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:<span class="string">@""</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *cacheFolder = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) firstObject];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [cacheFolder stringByAppendingPathComponent:name];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    YYDiskCache *diskCache = [[YYDiskCache alloc] initWithPath:path];</span><br><span class="line">    <span class="keyword">if</span> (!diskCache) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *name = [path lastPathComponent];</span><br><span class="line">    YYMemoryCache *memoryCache = [YYMemoryCache new];</span><br><span class="line">    memoryCache.name = name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    _name = name;</span><br><span class="line">    _diskCache = diskCache;</span><br><span class="line">    _memoryCache = memoryCache;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)cacheWithName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithName:name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)cacheWithPath:(<span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithPath:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [_memoryCache containsObjectForKey:key] || [_diskCache containsObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (!block) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([_memoryCache containsObjectForKey:key]) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">            block(key, <span class="literal">YES</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">        [_diskCache containsObjectForKey:key withBlock:block];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object = [_memoryCache objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">        object = [_diskCache objectForKey:key];</span><br><span class="line">        <span class="keyword">if</span> (object) &#123;</span><br><span class="line">            [_memoryCache setObject:object forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (!block) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object = [_memoryCache objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (object) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">            block(key, object);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [_diskCache objectForKey:key withBlock:^(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object) &#123;</span><br><span class="line">            <span class="keyword">if</span> (object &amp;&amp; ![_memoryCache objectForKey:key]) &#123;</span><br><span class="line">                [_memoryCache setObject:object forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            block(key, object);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    [_memoryCache setObject:object forKey:key];</span><br><span class="line">    [_diskCache setObject:object forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    [_memoryCache setObject:object forKey:key];</span><br><span class="line">    [_diskCache setObject:object forKey:key withBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    [_memoryCache removeObjectForKey:key];</span><br><span class="line">    [_diskCache removeObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span> *key))block &#123;</span><br><span class="line">    [_memoryCache removeObjectForKey:key];</span><br><span class="line">    [_diskCache removeObjectForKey:key withBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</span><br><span class="line">    [_memoryCache removeAllObjects];</span><br><span class="line">    [_diskCache removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    [_memoryCache removeAllObjects];</span><br><span class="line">    [_diskCache removeAllObjectsWithBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</span><br><span class="line">                                 endBlock:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end &#123;</span><br><span class="line">    [_memoryCache removeAllObjects];</span><br><span class="line">    [_diskCache removeAllObjectsWithProgressBlock:progress endBlock:end];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="keyword">if</span> (_name) <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p&gt; (%@)"</span>, <span class="keyword">self</span>.class, <span class="keyword">self</span>, _name];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p&gt;"</span>, <span class="keyword">self</span>.class, <span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>整体来看还是比较容易理解的，YYCache 整合了内存缓存和磁盘缓存，主要做了这些事：</p><ol><li>初始化YYCache实例，要求缓存路径要合理。</li><li>查询缓存对象先从内存缓存中查找，如果没有，再从磁盘缓存中查找。当磁盘缓存中有而内存缓存中没有的时候，把取得的缓存对象保存在内存缓存中。</li><li>缓存对象的存取和移除，内存缓存和磁盘缓存两者保持同步。</li></ol><h2 id="1-YYMemoryCache"><a href="#1-YYMemoryCache" class="headerlink" title="1.YYMemoryCache"></a>1.YYMemoryCache</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nullable, copy) NSString *name;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>(readonly) NSUInteger totalCount;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>(readonly) NSUInteger totalCost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#pragma mark - Limit</span></span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>NSUInteger countLimit;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>NSUInteger costLimit;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>NSTimeInterval ageLimit;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>NSTimeInterval autoTrimInterval;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>BOOL shouldRemoveAllObjectsOnMemoryWarning;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>BOOL shouldRemoveAllObjectsWhenEnteringBackground;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nullable, copy) void(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nullable, copy) void(^didEnterBackgroundBlock)(YYMemoryCache *cache);</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>BOOL releaseOnMainThread;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>BOOL releaseAsynchronously;</span><br></pre></td></tr></table></figure><p>类似于NSCache，提供包括缓存数量、缓存花费、缓存时间的管理。除此之外，当接收到内存警告时<code>(shouldRemoveAllObjectsOnMemoryWarning)</code>或者 App 进入到后台时<code>(shouldRemoveAllObjectsWhenEnteringBackground)</code>可以选择释放缓存对象。而对缓存对象释放也可以进行控制，比如可以选择在主线程释放<code>(releaseOnMainThread)</code>或者异步释放<code>(releaseAsynchronously)</code>。</p><h3 id="存取接口"><a href="#存取接口" class="headerlink" title="存取接口"></a>存取接口</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</span><br></pre></td></tr></table></figure><p> 除了基本的存取方法之外，YYMemoryCache 还暴露了三个移除缓存对象的方法。<br> trimToCount：根据限制的数量(countLimit)进行移除缓存对象操作，直到满足数量限制要求。<br> trimToCost：根据限制的花费(costLimit)进行移除缓存对象操作，直到满足花费限制要求。<br> trimToAge：根据缓存对象的过期时间(ageLimit)进行移除缓存对象操作，直到满足要求。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>在具体实现中，作者考虑了以下要求:</p><ol><li>缓存对象的存取。要保证效率就要求存取时间复杂度最好是O(1)。</li><li>缓存对象的移除。要保证能按照 <code>cost、age、count</code> 等条件对所有不符合要求的对象进行移除。</li><li>线程安全。需要加锁。<br>第一条：要求时间复杂度是 O(1)，那就可以采用哈希表、字典等。作者使用了字典，且是效率更高的<code>CFMutableDictionaryRef</code>。<br>第二条：记录 <code>cost、age、count</code>等属性，肯定需要对缓存对象进行包装。再者需要考虑LRU(Least Recently Used)，就需要保证顺序。而要使得字典中的对象(value)有顺序，必须有一个指向其他对象的指针(属性）。可以使用双向链表包装缓存对象。<br>第三条：存取的线程安全，使用GCD线程锁。</li></ol><h4 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h4><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">@interface <span class="variable">_YYLinkedMapNode</span> : NSObject &#123;</span><br><span class="line">    @package</span><br><span class="line">    <span class="variable">__unsafe_unretained</span> <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_prev</span>; <span class="comment">// retained by dic</span></span><br><span class="line">    <span class="variable">__unsafe_unretained</span> <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_next</span>; <span class="comment">// retained by dic</span></span><br><span class="line">    id <span class="variable">_key</span>;</span><br><span class="line">    id <span class="variable">_value</span>;</span><br><span class="line">    NSUInteger <span class="variable">_cost</span>;</span><br><span class="line">    NSTimeInterval <span class="variable">_time</span>;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>链表的结点中保存着key 和 value，这是对缓存对象的包装。_cost和_time记录着缓存对象的花费和过期时间。而使用<code>__unsafe_unretained</code>修饰的_prev和_next则分别指向前一个对象和后一个对象。由于这些结点已经被字典持有了，所以直接使用<code>__unsafe_unretained</code>修饰，不必再增加它的引用计数，提高效率。这一点与隐式参数<code>self</code>很像，<code>self</code>其实也是使用<code>__unsafe_unretained</code>修饰的。</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">@interface <span class="variable">_YYLinkedMap</span> : NSObject &#123;</span><br><span class="line">    @package</span><br><span class="line">    CFMutableDictionaryRef <span class="variable">_dic</span>; <span class="comment">// do not set object directly</span></span><br><span class="line">    NSUInteger <span class="variable">_totalCost</span>;</span><br><span class="line">    NSUInteger <span class="variable">_totalCount</span>;</span><br><span class="line">    <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_head</span>; <span class="comment">// MRU, do not change it directly</span></span><br><span class="line">    <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_tail</span>; <span class="comment">// LRU, do not change it directly</span></span><br><span class="line">    BOOL <span class="variable">_releaseOnMainThread</span>;</span><br><span class="line">    BOOL <span class="variable">_releaseAsynchronously</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)insertNodeAtHead:(<span class="variable">_YYLinkedMapNode</span> *)node;</span><br><span class="line">- (void)bringNodeToHead:(<span class="variable">_YYLinkedMapNode</span> *)node;</span><br><span class="line">- (void)removeNode:(<span class="variable">_YYLinkedMapNode</span> *)node;</span><br><span class="line">- (<span class="variable">_YYLinkedMapNode</span> *)removeTailNode;</span><br><span class="line">- (void)removeAll;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>一个 <code>YYMemoryCache</code> 对象有一个链表。这个链表使用<code>_dic</code>保存着所有包装好的缓存对象(<code>_YYLinkedMapNode</code>)，记录着总的花费(<code>_totalCost</code>)和总的数量(<code>_totalCount</code>)。当然，还使用<code>_head</code>指着链表的头指针，使用<code>_tail</code>指着链表的尾指针。<code>_releaseOnMainThread</code>和<code>_releaseAsynchronously</code>用于设置对缓存对象释放操作的选项:主线程释放或者异步释放。</p><p><code>_YYLinkedMap</code>暴露出的五个方法很清晰地表明它的作用：每次当缓存取到某个对象时，把它置在头结点的位置。这样随着时间的推移，很轻松地使得那些不经常使用的对象处在链表的后端，经常使用的对象处在链表的前端，这样就实现了 <code>LRU</code>。</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">- (void)insertNodeAtHead:(_YYLinkedMapNode *)<span class="keyword">node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    CFDictionarySetValue</span>(_dic, (__bridge const void *)(<span class="keyword">node</span><span class="title">-&gt;_key</span>), (__bridge const void *)(<span class="keyword">node</span><span class="title">));</span></span><br><span class="line"><span class="title">    _totalCost</span> += <span class="keyword">node</span><span class="title">-&gt;_cost</span>;</span><br><span class="line">    _totalCount++;</span><br><span class="line">    if (_head) &#123;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;_next</span> = _head;</span><br><span class="line">        _head-&gt;_prev = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">        _head</span> = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125; else</span> &#123;</span><br><span class="line">        _head = _tail = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">- (void</span>)bringNodeToHead:(_YYLinkedMapNode *)<span class="keyword">node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    if</span> (_head == <span class="keyword">node</span><span class="title">) return</span>;</span><br><span class="line">    </span><br><span class="line">    if (_tail == <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">        _tail</span> = <span class="keyword">node</span><span class="title">-&gt;_prev</span>;</span><br><span class="line">        _tail-&gt;_next = nil;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;_next-</span>&gt;_prev = <span class="keyword">node</span><span class="title">-&gt;_prev</span>;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;_prev-</span>&gt;_next = <span class="keyword">node</span><span class="title">-&gt;_next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">node</span><span class="title">-&gt;_next</span> = _head;</span><br><span class="line">    <span class="keyword">node</span><span class="title">-&gt;_prev</span> = nil;</span><br><span class="line">    _head-&gt;_prev = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    _head</span> = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">- (void</span>)removeNode:(_YYLinkedMapNode *)<span class="keyword">node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    CFDictionaryRemoveValue</span>(_dic, (__bridge const void *)(<span class="keyword">node</span><span class="title">-&gt;_key</span>));</span><br><span class="line">    _totalCost -= <span class="keyword">node</span><span class="title">-&gt;_cost</span>;</span><br><span class="line">    _totalCount--;</span><br><span class="line">    if (<span class="keyword">node</span><span class="title">-&gt;_next</span>) <span class="keyword">node</span><span class="title">-&gt;_next-</span>&gt;_prev = <span class="keyword">node</span><span class="title">-&gt;_prev</span>;</span><br><span class="line">    if (<span class="keyword">node</span><span class="title">-&gt;_prev</span>) <span class="keyword">node</span><span class="title">-&gt;_prev-</span>&gt;_next = <span class="keyword">node</span><span class="title">-&gt;_next</span>;</span><br><span class="line">    if (_head == <span class="keyword">node</span><span class="title">) _head</span> = <span class="keyword">node</span><span class="title">-&gt;_next</span>;</span><br><span class="line">    if (_tail == <span class="keyword">node</span><span class="title">) _tail</span> = <span class="keyword">node</span><span class="title">-&gt;_prev</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (_YYLinkedMapNode *)removeTailNode &#123;</span><br><span class="line">    if (!_tail) return nil;</span><br><span class="line">    _YYLinkedMapNode *tail = _tail;</span><br><span class="line">    CFDictionaryRemoveValue(_dic, (__bridge const void *)(_tail-&gt;_key));</span><br><span class="line">    _totalCost -= _tail-&gt;_cost;</span><br><span class="line">    _totalCount--;</span><br><span class="line">    if (_head == _tail) &#123;</span><br><span class="line">        _head = _tail = nil;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _tail = _tail-&gt;_prev;</span><br><span class="line">        _tail-&gt;_next = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对结点的插入、移除、调整位置，是数据结构的基础操作。令人怀念！</p><p><code>_releaseOnMainThread</code>和<code>_releaseAsynchronously</code>这两个选项的实现也很简单。作者自己维护了一个队列:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> dispatch_queue_t <span class="title">YYMemoryCacheGetReleaseQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除的时候有所判断：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">CFDictionaryGetCount</span>(_dic) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="built_in">CFMutableDictionaryRef</span> holder = _dic;</span><br><span class="line">   _dic = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (_releaseAsynchronously) &#123;</span><br><span class="line">       <span class="built_in">dispatch_queue_t</span> queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">       <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">           <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">       <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">CFRelease</span>(holder);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据线程、是否异步决定具体的逻辑，把release操作放到相应线程中。这里使用一个临时变量holder，很是巧妙。</p><h3 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">@implementation YYMemoryCache &#123;</span><br><span class="line">    pthread_mutex_t _lock<span class="comment">;</span></span><br><span class="line">    _YYLinkedMap *_lru<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t </span>_queue<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出<code>YYMemoryCache</code>使用<code>pthread_mutex_t</code>保证线程安全。</p><p>最关键的还是对无效缓存对象的释放，以 <code>count</code> 为例，当缓存的对象数量超过了 <code>count</code> 限制，就需要对链表后端不常使用的缓存对象进行移除操作，直到满足 <code>count</code> 限制。</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)<span class="variable">_trimToCount</span>:(NSUInteger)countLimit &#123;</span><br><span class="line">    BOOL finish = NO;</span><br><span class="line">    pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    <span class="keyword">if</span> (countLimit == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="variable">_lru</span> removeAll];</span><br><span class="line">        finish = YES;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_totalCount</span> &lt;= countLimit) &#123;</span><br><span class="line">        finish = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    <span class="keyword">if</span> (finish) return;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *holder = [NSMutableArray new];</span><br><span class="line">    <span class="keyword">while</span> (!finish) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;<span class="variable">_lock</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_totalCount</span> &gt; countLimit) &#123;</span><br><span class="line">                <span class="variable">_YYLinkedMapNode</span> *node = [<span class="variable">_lru</span> removeTailNode];</span><br><span class="line">                <span class="keyword">if</span> (node) [holder addObject:node];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finish = YES;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder.<span class="built_in">count</span>) &#123;</span><br><span class="line">        dispatch_queue_t queue = <span class="variable">_lru</span>-&gt;<span class="variable">_releaseOnMainThread</span> ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            [holder <span class="built_in">count</span>]; <span class="comment">// release in queue</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法做了什么？</p><ol><li>使用<code>pthread_mutex_lock(&amp;_lock);pthread_mutex_unlock(&amp;_lock);</code>对操作加锁解锁来保证线程安全。</li><li>对参数 countLimit 判断：<br>如果countLimit为0，也就是说缓存数量限制为0，那移除所有缓存对象就是了。如果当前所缓存的对象数量小于countLimit，那说明满足数量限制要求，就不需要移除操作了。</li><li>作者创建一个可变字典holder，当不满足countLimit限制要求的时候，对链表尾结点进行移除操作，并把这个尾结点添加到holder中持有。当然，这里有加锁操作。这个 while 循环结束，所有多余的缓存对象就在holder中了。<br>4.对holder中所有元素进行 release 操作。<br>其他的如:</li></ol><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>_trimToAge:<span class="params">(NSTimeInterval)</span>ageLimit; </span><br><span class="line">- <span class="params">(void)</span>_trimToCost:<span class="params">(NSUInteger)</span>costLimit</span><br></pre></td></tr></table></figure><p>操作同理。</p><h3 id="内存警告"><a href="#内存警告" class="headerlink" title="内存警告"></a>内存警告</h3><p>内存警告语 App 进入后台时释放缓存对象的操作，作者接受了系统通知，直接处理即可。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span> <span class="selector-tag">selector</span>:@<span class="keyword">selector</span>(<span class="keyword">_appDidReceiveMemoryWarningNotification</span>) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span> <span class="selector-tag">selector</span>:@<span class="keyword">selector</span>(<span class="keyword">_appDidEnterBackgroundNotification</span>) name:UIApplicationDidEnterBackgroundNotification object:nil];</span><br></pre></td></tr></table></figure><h3 id="存取实现"><a href="#存取实现" class="headerlink" title="存取实现"></a>存取实现</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="built_in">BOOL</span> contains = <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">return</span> contains;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    [<span class="keyword">self</span> setObject:object forKey:key withCost:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对缓存对象的读取自然是根据 key 读取到字典中对应的 value，这个 value 是个结点(<code>_YYLinkedMapNode</code>)，再取出这个结点的value 属性，便是最原始的缓存对象了:<code>node-&gt;_value</code>。</p><h2 id="2-关键点"><a href="#2-关键点" class="headerlink" title="2.关键点"></a>2.关键点</h2><p>1.字典CFMutableDictionaryRef的使用</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">声明: <span class="built_in">CFMutableDictionaryRef</span> _dic;</span><br><span class="line">创建: _dic = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">设值: <span class="built_in">CFDictionarySetValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key), (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node));</span><br><span class="line">取值: <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">移除: <span class="built_in">CFDictionaryRemoveValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key));</span><br><span class="line">获取数量: <span class="built_in">CFDictionaryGetCount</span>(_dic);</span><br><span class="line">是否存在: <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">释放: <span class="built_in">CFRelease</span>(_dic);</span><br></pre></td></tr></table></figure><p>2.容器中对象销毁控制</p><blockquote><p>“对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去…”</p></blockquote><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组中的所有元素在子线程释放</span></span><br><span class="line">&#123; </span><br><span class="line">   <span class="built_in">NSArray</span> *holder = tmp;</span><br><span class="line">   tmp = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">   <span class="keyword">if</span> (holder.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">           [holder count];</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中的某个元素在子线程释放</span></span><br><span class="line">&#123; </span><br><span class="line">   <span class="keyword">id</span> obj = tmp[<span class="number">2</span>];</span><br><span class="line">   <span class="built_in">NSMutableArray</span> *holder = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">   [holder addObject:obj];</span><br><span class="line">   [tmp removeObject:obj];</span><br><span class="line">   <span class="keyword">if</span> (holder.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">           [holder count];</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.线程安全的实现</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取值线程安全</span></span><br><span class="line">&#123;  </span><br><span class="line">    pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    BOOL releaseAsynchronously = <span class="variable">_lru</span>-&gt;<span class="variable">_releaseAsynchronously</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    return releaseAsynchronously;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设值线程安全</span></span><br><span class="line">&#123; </span><br><span class="line">    pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    <span class="variable">_lru</span>-&gt;<span class="variable">_releaseAsynchronously</span> = releaseAsynchronously;</span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<code>pthread_mutex_lock</code>使用</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">声明锁: pthread_mutex_t <span class="variable">_lock</span>;</span><br><span class="line">创建锁: pthread_mutex_init(&amp;<span class="variable">_lock</span>, NULL);</span><br><span class="line">加锁: pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">解锁: pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">尝试加锁:</span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_trylock(&amp;<span class="variable">_lock</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></span><br><span class="line">&#125;</span><br><span class="line">销毁锁: pthread_mutex_destroy(&amp;<span class="variable">_lock</span>);</span><br></pre></td></tr></table></figure><p>5.if-else 单句</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_name) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure><h2 id="3-YYDiskCache"><a href="#3-YYDiskCache" class="headerlink" title="3.YYDiskCache"></a>3.YYDiskCache</h2><p>YYDiskCache主要调用了YYKVStorage的接口，并提供对外 API。</p><h4 id="五个函数"><a href="#五个函数" class="headerlink" title="五个函数"></a>五个函数</h4><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">/// <span class="type">Free</span> disk space <span class="keyword">in</span> bytes.</span><br><span class="line"><span class="keyword">static</span> int64_t _YYDiskSpaceFree() &#123;</span><br><span class="line">    <span class="type">NSError</span> *error = <span class="keyword">nil</span>;</span><br><span class="line">    <span class="type">NSDictionary</span> *attrs = [[<span class="type">NSFileManager</span> defaultManager] attributesOfFileSystemForPath:<span class="type">NSHomeDirectory</span>() error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    int64_t space =  [[attrs objectForKey:<span class="type">NSFileSystemFreeSize</span>] longLongValue];</span><br><span class="line">    <span class="keyword">if</span> (space &lt; <span class="number">0</span>) space = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> space;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// <span class="type">String</span>'s md5 hash.</span><br><span class="line"><span class="keyword">static</span> <span class="type">NSString</span> *_YYNSStringMD5(<span class="type">NSString</span> *<span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">string</span>) <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">    <span class="type">NSData</span> *data = [<span class="built_in">string</span> dataUsingEncoding:<span class="type">NSUTF8StringEncoding</span>];</span><br><span class="line">    unsigned <span class="built_in">char</span> <span class="literal">result</span>[<span class="type">CC_MD5_DIGEST_LENGTH</span>];</span><br><span class="line">    <span class="type">CC_MD5</span>(data.bytes, (<span class="type">CC_LONG</span>)data.length, <span class="literal">result</span>);</span><br><span class="line">    <span class="keyword">return</span> [<span class="type">NSString</span> stringWithFormat:</span><br><span class="line">                @<span class="string">"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"</span>,</span><br><span class="line">                <span class="literal">result</span>[<span class="number">0</span>],  <span class="literal">result</span>[<span class="number">1</span>],  <span class="literal">result</span>[<span class="number">2</span>],  <span class="literal">result</span>[<span class="number">3</span>],</span><br><span class="line">                <span class="literal">result</span>[<span class="number">4</span>],  <span class="literal">result</span>[<span class="number">5</span>],  <span class="literal">result</span>[<span class="number">6</span>],  <span class="literal">result</span>[<span class="number">7</span>],</span><br><span class="line">                <span class="literal">result</span>[<span class="number">8</span>],  <span class="literal">result</span>[<span class="number">9</span>],  <span class="literal">result</span>[<span class="number">10</span>], <span class="literal">result</span>[<span class="number">11</span>],</span><br><span class="line">                <span class="literal">result</span>[<span class="number">12</span>], <span class="literal">result</span>[<span class="number">13</span>], <span class="literal">result</span>[<span class="number">14</span>], <span class="literal">result</span>[<span class="number">15</span>]</span><br><span class="line">            ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">void</span> _YYDiskCacheInitGlobal() &#123;</span><br><span class="line">    <span class="keyword">static</span> dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _globalInstancesLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _globalInstances = [[<span class="type">NSMapTable</span> alloc] initWithKeyOptions:<span class="type">NSPointerFunctionsStrongMemory</span> valueOptions:<span class="type">NSPointerFunctionsWeakMemory</span> capacity:<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">YYDiskCache</span> *_YYDiskCacheGetGlobal(<span class="type">NSString</span> *path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    dispatch_semaphore_wait(_globalInstancesLock, <span class="type">DISPATCH_TIME_FOREVER</span>);</span><br><span class="line">    id cache = [_globalInstances objectForKey:path];</span><br><span class="line">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">void</span> _YYDiskCacheSetGlobal(<span class="type">YYDiskCache</span> *cache) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.path.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    dispatch_semaphore_wait(_globalInstancesLock, <span class="type">DISPATCH_TIME_FOREVER</span>);</span><br><span class="line">    [_globalInstances setObject:cache forKey:cache.path];</span><br><span class="line">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_YYDiskSpaceFree()</code>提供剩余磁盘空间的查询。<br><code>_YYNSStringMD5(NSString *string)</code>提供字符串转 md5。</p><p><code>_YYDiskCacheInitGlobal()</code>用于初始化一个强-弱的<code>NSMapTable</code>，保存<code>YYDiskCache</code>对象。<br><code>_YYDiskCacheGetGlobal(NSString *path)</code>用于根据路径 path 获取对应的<code>YYDiskCache</code>对象。<br><code>_YYDiskCacheSetGlobal(YYDiskCache *cache)</code>用于根据路径 path 在<code>NSMapTable</code>保存一个<code>YYDiskCache</code>对象。</p><h4 id="主要实现"><a href="#主要实现" class="headerlink" title="主要实现"></a>主要实现</h4><p>YYDiskCache的功能比如移除过期的对象、移除超过数量限制的对象等，主要通过YYKVStorage实现。<br>作者把保存类型分为三种：</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSUInteger</span>, <span class="type">YYKVStorageType</span>) &#123;</span><br><span class="line">    /// file system.</span><br><span class="line">    <span class="type">YYKVStorageTypeFile</span> = 0,</span><br><span class="line">    ///  in sqlite.</span><br><span class="line">    <span class="type">YYKVStorageTypeSQLite</span> = 1,</span><br><span class="line">    ///  based on your choice.</span><br><span class="line">    <span class="type">YYKVStorageTypeMixed</span> = 2,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作者指明了原因：Typically, write data to sqlite is faster than extern file, but<br> reading performance is dependent on data size. In my test (on iPhone 6 64G),<br> read data from extern file is faster than from sqlite when the data is larger<br> than 20KB.</p><ul><li>If you want to store large number of small datas (such as contacts cache),<br>use YYKVStorageTypeSQLite to get better performance.</li><li>If you want to store large files (such as image cache),<br>use YYKVStorageTypeFile to get better performance.</li><li><p>You can use YYKVStorageTypeMixed and choice your storage type for each item.</p><p>20kb 以下的持久化，放到文件中。 20kb 以上的持久化，放到数据库sqlite中。也可以选择混合存储。</p></li></ul><h3 id="4-YYKVStorage"><a href="#4-YYKVStorage" class="headerlink" title="4.YYKVStorage"></a>4.YYKVStorage</h3><p>YYKVStorage没有阅读。乍一看是许多琐碎的 SQL 操作和文件操作，没有纳入阅读计划。</p><h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p>YYCache属于小家碧玉型的开源作品，代码量不是很多，但是很精美。LRU配合双向链表也是很经典的算法题。我觉得最好玩的是容器元素的异步释放逻辑，以前确实没见过这种写法，作者也给出了解释，很值得学习借鉴。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 关于YYCache的简单总结。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>读「YYModel」</title>
    <link href="http://blog.chenyalun.com/2018/12/20/%E8%AF%BB%E3%80%8CYYModel%E3%80%8D/"/>
    <id>http://blog.chenyalun.com/2018/12/20/读「YYModel」/</id>
    <published>2018-12-20T11:32:33.000Z</published>
    <updated>2019-03-29T03:01:31.589Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 关于YYModel的简单总结。 </p><br><a id="more"></a><p></p><p>尝试阅读YYModel源码，发现有一些细节并不能十分透彻地理解清楚，只能略微窥探到其中主要原理。这里就当做第一遍阅读笔记😂😂😂。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">YYModel</span>)</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)yy_modelWithJSON:(<span class="keyword">id</span>)json;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)yy_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary;</span><br><span class="line">- (<span class="built_in">BOOL</span>)yy_modelSetWithJSON:(<span class="keyword">id</span>)json;</span><br><span class="line">- (<span class="built_in">BOOL</span>)yy_modelSetWithDictionary:(<span class="built_in">NSDictionary</span> *)dic;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)yy_modelToJSONObject;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)yy_modelToJSONData;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)yy_modelToJSONString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)yy_modelCopy;</span><br><span class="line">- (<span class="keyword">void</span>)yy_modelEncodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder;</span><br><span class="line">- (<span class="keyword">id</span>)yy_modelInitWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)yy_modelHash;</span><br><span class="line">- (<span class="built_in">BOOL</span>)yy_modelIsEqual:(<span class="keyword">id</span>)model;</span><br><span class="line">- (<span class="built_in">NSString</span> *)yy_modelDescription;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> (<span class="title">YYModel</span>)</span></span><br><span class="line"><span class="comment">// json到模型数组</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSArray</span> *)yy_modelArrayWithClass:(Class)cls json:(<span class="keyword">id</span>)json;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDictionary</span> (<span class="title">YYModel</span>)</span></span><br><span class="line"><span class="comment">// json到字典</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)yy_modelDictionaryWithClass:(Class)cls json:(<span class="keyword">id</span>)json;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YYModel</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">// 自定义模型属性与json's key的映射</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)modelCustomPropertyMapper;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)modelCustomPropertyMapper &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123; <span class="string">@"name"</span> : <span class="string">@"n"</span>,</span><br><span class="line">              <span class="string">@"count"</span> : <span class="string">@"ext.c"</span>,</span><br><span class="line">              <span class="string">@"desc1"</span> : <span class="string">@"ext.d"</span>,</span><br><span class="line">              <span class="string">@"desc4"</span> : <span class="string">@".ext"</span>,</span><br><span class="line">              <span class="string">@"modelID"</span> : @[<span class="string">@"ID"</span>, <span class="string">@"Id"</span>, <span class="string">@"id"</span>, <span class="string">@"ext.id"</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 黑名单, 若实现该方法, 黑名单之内的key均不作处理</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)modelPropertyBlacklist;</span><br><span class="line">+ (<span class="built_in">NSArray</span> *)modelPropertyBlacklist &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>, <span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白名单, 若实现该方法, 白名单之外的key均不作处理</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)modelPropertyWhitelist;</span><br><span class="line">+ (<span class="built_in">NSArray</span> *)modelPropertyWhitelist &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.要在JSON转Model的过程中根据情况创建不同类型的实例</span></span><br><span class="line">+ (<span class="keyword">nullable</span> Class)modelCustomClassForDictionary:(<span class="built_in">NSDictionary</span> *)dictionary;</span><br><span class="line">+ (Class)modelCustomClassForDictionary:(<span class="built_in">NSDictionary</span>*)dictionary &#123;</span><br><span class="line">    <span class="keyword">if</span> (dictionary[<span class="string">@"localName"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [YYLocalUser <span class="keyword">class</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dictionary[<span class="string">@"remoteName"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [YYRemoteUser <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [YYBaseUser <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.该方法发生在字典转模型之前, 最后对字典做一次处理</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)modelCustomWillTransformFromDictionary:(<span class="built_in">NSDictionary</span> *)dic;</span><br><span class="line"><span class="comment">//- (NSDictionary *)modelCustomWillTransformFromDictionary:(NSDictionary *)dic&#123;</span></span><br><span class="line">    <span class="keyword">if</span> ([dic[<span class="string">@"sex"</span>] isEqualToString:<span class="string">@"Man"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.JSON转为Model后, 进行数据校验</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)modelCustomTransformFromDictionary:(<span class="built_in">NSDictionary</span> *)dic;</span><br><span class="line">- (<span class="built_in">BOOL</span>)modelCustomTransformFromDictionary:(<span class="built_in">NSDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *timestamp = dic[<span class="string">@"timestamp"</span>];</span><br><span class="line">    <span class="keyword">if</span> (![timestamp isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    _createdAt = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:timestamp.floatValue];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型容器属性中的所需要存放的数据类型</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)modelContainerPropertyGenericClass;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)modelContainerPropertyGenericClass &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"shadows"</span> : [Shadow <span class="keyword">class</span>],</span><br><span class="line">             <span class="string">@"borders"</span> : Border.class,</span><br><span class="line">             <span class="string">@"attachments"</span> : <span class="string">@"Attachment"</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Model转为JSON后, 进行数据校验</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)modelCustomTransformToDictionary:(<span class="built_in">NSMutableDictionary</span> *)dic;</span><br><span class="line">- (<span class="built_in">BOOL</span>)modelCustomTransformToDictionary:(<span class="built_in">NSMutableDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_createdAt) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    dic[<span class="string">@"timestamp"</span>] = @(_createdAt.timeIntervalSince1970);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 函数1: 根据class信息获取其对应的类型</span></span><br><span class="line"><span class="keyword">static</span> force_inline YYEncodingNSType YYClassGetNSType(Class cls) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> YYEncodingTypeNSUnknown;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSMutableString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSMutableString;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSString;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSDecimalNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSDecimalNumber;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSNumber;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSValue</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSValue;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSMutableData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSMutableData;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSData;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSDate;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSURL;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSMutableArray;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSArray;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSMutableDictionary;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSDictionary;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSMutableSet</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSMutableSet;</span><br><span class="line">    <span class="keyword">if</span> ([cls isSubclassOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> YYEncodingTypeNSSet;</span><br><span class="line">    <span class="keyword">return</span> YYEncodingTypeNSUnknown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数2: 判断YYEncodingType是不是一个数字(整形\长整型\浮点型等)</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">BOOL</span> YYEncodingTypeIsCNumber(YYEncodingType type) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeBool:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeInt8:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeUInt8:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeInt16:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeUInt16:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeInt32:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeUInt32:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeInt64:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeUInt64:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeFloat:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeDouble:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeLongDouble: <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数3: 根据一个id类型的对象创建一个NSNumber类型的对象</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">NSNumber</span> *YYNSNumberCreateFromID(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSCharacterSet</span> *dot;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDictionary</span> *dic;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        dot = [<span class="built_in">NSCharacterSet</span> characterSetWithRange:<span class="built_in">NSMakeRange</span>(<span class="string">'.'</span>, <span class="number">1</span>)];</span><br><span class="line">        dic = @&#123;<span class="string">@"TRUE"</span> :   @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"True"</span> :   @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"true"</span> :   @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"FALSE"</span> :  @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"False"</span> :  @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"false"</span> :  @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"YES"</span> :    @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"Yes"</span> :    @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"yes"</span> :    @(<span class="literal">YES</span>),</span><br><span class="line">                <span class="string">@"NO"</span> :     @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"No"</span> :     @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"no"</span> :     @(<span class="literal">NO</span>),</span><br><span class="line">                <span class="string">@"NIL"</span> :    (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"Nil"</span> :    (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"nil"</span> :    (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"NULL"</span> :   (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"Null"</span> :   (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"null"</span> :   (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"(NULL)"</span> : (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"(Null)"</span> : (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"(null)"</span> : (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"&lt;NULL&gt;"</span> : (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"&lt;Null&gt;"</span> : (<span class="keyword">id</span>)kCFNull,</span><br><span class="line">                <span class="string">@"&lt;null&gt;"</span> : (<span class="keyword">id</span>)kCFNull&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// kCFNull单例</span></span><br><span class="line">    <span class="keyword">if</span> (!value || value == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// NSNumber直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">// NSString, 取出dic中对应的值</span></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> *num = dic[value];</span><br><span class="line">        <span class="keyword">if</span> (num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个字符串中含有 ".", 例如 @"12.344"</span></span><br><span class="line">        <span class="keyword">if</span> ([(<span class="built_in">NSString</span> *)value rangeOfCharacterFromSet:dot].location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *cstring = ((<span class="built_in">NSString</span> *)value).UTF8String;</span><br><span class="line">            <span class="keyword">if</span> (!cstring) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">double</span> num = atof(cstring);</span><br><span class="line">            <span class="comment">// isfinite()测试某个浮点数是不是有限的数</span></span><br><span class="line">            <span class="comment">// isinf()测试某个浮点数是否是无限大</span></span><br><span class="line">            <span class="comment">// isnan()测试某个浮点数是否是 非数字</span></span><br><span class="line">            <span class="keyword">if</span> (isnan(num) || isinf(num)) <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">// num是否是无限大或者是否是非数字</span></span><br><span class="line">            <span class="keyword">return</span> @(num); <span class="comment">// return @(12.344);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 字符串中没有".", 例如 @"1323"</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *cstring = ((<span class="built_in">NSString</span> *)value).UTF8String;<span class="comment">// 转化为C字符串"1323"</span></span><br><span class="line">            <span class="keyword">if</span> (!cstring) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">// atoi函数：将字符串转化为int类型变量. atol函数：将字符串转化为long类型变量.</span></span><br><span class="line">            <span class="comment">// atoll函数：将字符串转化为long long类型变量.atof函数：将字符串转化为double类型变量</span></span><br><span class="line">            <span class="keyword">return</span> @(atoll(cstring)); <span class="comment">// 转换为long long类型变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数4: 将字符串转化为日期NSDate</span></span><br><span class="line"><span class="comment">// 根据string的length判断需要调用哪一个block, 为了避免效率较低的if-else, 采用block数组的形式, string的length正好对应blocks数组的索引, 即查表法, 效率得到提升.</span></span><br><span class="line"><span class="comment">// YYNSDateParseBlock parser = blocks[string.length];</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">NSDate</span> *YYNSDateFromString(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">NSDate</span>* (^YYNSDateParseBlock)(<span class="built_in">NSString</span> *string);</span><br><span class="line">    <span class="meta">#define kParserNum 34</span></span><br><span class="line">    <span class="comment">// 定义一个block数组, 数组是C数组</span></span><br><span class="line">    <span class="keyword">static</span> YYNSDateParseBlock blocks[kParserNum + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             2014-01-20  // Google , 10个字符, 对应blocks[10]</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter.dateFormat = <span class="string">@"yyyy-MM-dd"</span>;</span><br><span class="line">            blocks[<span class="number">10</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             2014-01-20 12:24:48 // 19个字符, 对应blocks[19]</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48   // Google, 19个字符, 对应blocks[19]</span></span><br><span class="line"><span class="comment">             2014-01-20 12:24:48.000 // 23个字符, 对应blocks[23]</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48.000 // 23个字符, 对应blocks[23]</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter1 = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter1.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter1.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter1.dateFormat = <span class="string">@"yyyy-MM-dd'T'HH:mm:ss"</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter2 = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter2.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter2.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter2.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter3 = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter3.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter3.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter3.dateFormat = <span class="string">@"yyyy-MM-dd'T'HH:mm:ss.SSS"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter4 = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter4.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter4.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter4.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm:ss.SSS"</span>;</span><br><span class="line">            </span><br><span class="line">            blocks[<span class="number">19</span>] = ^(<span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([string characterAtIndex:<span class="number">10</span>] == <span class="string">'T'</span>) &#123;<span class="comment">// 2014-01-20T12:24:48</span></span><br><span class="line">                    <span class="keyword">return</span> [formatter1 dateFromString:string];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// 2014-01-20 12:24:48</span></span><br><span class="line">                    <span class="keyword">return</span> [formatter2 dateFromString:string];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            blocks[<span class="number">23</span>] = ^(<span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([string characterAtIndex:<span class="number">10</span>] == <span class="string">'T'</span>) &#123;<span class="comment">// 2014-01-20T12:24:48.000</span></span><br><span class="line">                    <span class="keyword">return</span> [formatter3 dateFromString:string];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// 2014-01-20 12:24:48.000</span></span><br><span class="line">                    <span class="keyword">return</span> [formatter4 dateFromString:string];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48Z        // Github, Apple</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48+0800    // Facebook</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48+12:00   // Google</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48.000Z</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48.000+0800</span></span><br><span class="line"><span class="comment">             2014-01-20T12:24:48.000+12:00</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter = [<span class="built_in">NSDateFormatter</span> new];</span><br><span class="line">            formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter.dateFormat = <span class="string">@"yyyy-MM-dd'T'HH:mm:ssZ"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter2 = [<span class="built_in">NSDateFormatter</span> new];</span><br><span class="line">            formatter2.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter2.dateFormat = <span class="string">@"yyyy-MM-dd'T'HH:mm:ss.SSSZ"</span>;</span><br><span class="line"></span><br><span class="line">            blocks[<span class="number">20</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]; &#125;;</span><br><span class="line">            blocks[<span class="number">24</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]?: [formatter2 dateFromString:string]; &#125;;</span><br><span class="line">            blocks[<span class="number">25</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]; &#125;;</span><br><span class="line">            blocks[<span class="number">28</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter2 dateFromString:string]; &#125;;</span><br><span class="line">            blocks[<span class="number">29</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter2 dateFromString:string]; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             Fri Sep 04 00:12:21 +0800 2015 // Weibo, Twitter</span></span><br><span class="line"><span class="comment">             Fri Sep 04 00:12:21.000 +0800 2015</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter = [<span class="built_in">NSDateFormatter</span> new];</span><br><span class="line">            formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter.dateFormat = <span class="string">@"EEE MMM dd HH:mm:ss Z yyyy"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter2 = [<span class="built_in">NSDateFormatter</span> new];</span><br><span class="line">            formatter2.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">            formatter2.dateFormat = <span class="string">@"EEE MMM dd HH:mm:ss.SSS Z yyyy"</span>;</span><br><span class="line"></span><br><span class="line">            blocks[<span class="number">30</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]; &#125;;</span><br><span class="line">            blocks[<span class="number">34</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter2 dateFromString:string]; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!string) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; kParserNum) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    YYNSDateParseBlock parser = blocks[string.length];</span><br><span class="line">    <span class="keyword">if</span> (!parser) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> parser(string);</span><br><span class="line">    <span class="meta">#undef kParserNum</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数5: 获取NSBlock类</span></span><br><span class="line"><span class="keyword">static</span> force_inline Class YYNSBlockClass() &#123;</span><br><span class="line">    <span class="keyword">static</span> Class cls;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;&#125;;</span><br><span class="line">        cls = ((<span class="built_in">NSObject</span> *)block).class;</span><br><span class="line">        <span class="keyword">while</span> (class_getSuperclass(cls) != [<span class="built_in">NSObject</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">            cls = class_getSuperclass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cls; <span class="comment">// current is "NSBlock"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数6: 获取ISO NSDateFormatter</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> example:</span></span><br><span class="line"><span class="comment"> 2010-07-09T16:13:30+12:00</span></span><br><span class="line"><span class="comment"> 2011-01-11T11:11:11+0000</span></span><br><span class="line"><span class="comment"> 2011-01-26T19:06:43Z</span></span><br><span class="line"><span class="comment"> length: 20/24/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">NSDateFormatter</span> *YYISODateFormatter() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *formatter = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">        formatter.dateFormat = <span class="string">@"yyyy-MM-dd'T'HH:mm:ssZ"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> formatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    "version": "1.1",</span></span><br><span class="line"><span class="comment">    "object": &#123;</span></span><br><span class="line"><span class="comment">        "data": &#123;</span></span><br><span class="line"><span class="comment">            "phone": "12332123"</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 函数7: 根据keypath从字典中获取对应的值(这个值是id类型)</span></span><br><span class="line"><span class="comment">// keyPaths: @[@"object", @"data", @"phone"] 对应的值是 @"12332123"</span></span><br><span class="line"><span class="comment">// keyPaths: @[@"object", @"data"] 对应的值是 @&#123;@"phone": @"12332123"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="keyword">id</span> YYValueForKeyPath(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSDictionary</span> *dic, __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSArray</span> *keyPaths) &#123;</span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = keyPaths.count; i &lt; max; i++) &#123;</span><br><span class="line">        value = dic[keyPaths[i]];</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; max) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                dic = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数8: 根据可变的keypath从字典中获取对应的值(这个值是id类型)</span></span><br><span class="line"><span class="comment">// multiKeys: @[ @[@"object", @"data"], @"phone"] 对应的值是 @&#123;@"phone": @"12332123"&#125;</span></span><br><span class="line"><span class="comment">// multiKeys: @[@"object", @"data"] 对应的值是 @&#123;@"data": @&#123;@"phone": @"12332123"&#125;&#125;</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="keyword">id</span> YYValueForMultiKeys(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSDictionary</span> *dic, __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSArray</span> *multiKeys) &#123;</span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> multiKeys) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([key isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            value = dic[key];</span><br><span class="line">            <span class="keyword">if</span> (value) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value = YYValueForKeyPath(dic, (<span class="built_in">NSArray</span> *)key);</span><br><span class="line">            <span class="keyword">if</span> (value) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数9: 从模型中的属性(_YYModelPropertyMeta类型)中获取NSNumber</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">NSNumber</span> *ModelCreateNumberFromProperty(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model,</span><br><span class="line">                                                            __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *meta) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (meta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeBool: &#123;</span><br><span class="line">            <span class="keyword">return</span> @(((<span class="keyword">bool</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, meta-&gt;_<span class="keyword">getter</span>));&#125;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数10: 对模型中的属性(_YYModelPropertyMeta类型)设值. 和函数9类似</span></span><br><span class="line"><span class="keyword">static</span> force_inline <span class="keyword">void</span> ModelSetNumberToProperty(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model,</span><br><span class="line">                                                  __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSNumber</span> *num,</span><br><span class="line">                                                  __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *meta) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (meta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeBool: &#123;</span><br><span class="line">            ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">bool</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, num.boolValue);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数11: 对模型中的属性(_YYModelPropertyMeta类型)设值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetValueForProperty(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model,</span><br><span class="line">                                     __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> value,</span><br><span class="line">                                     __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *meta) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *modelMeta;  <span class="comment">///&lt; _YYModelMeta</span></span><br><span class="line">    <span class="keyword">void</span> *model;      <span class="comment">///&lt; id (self)</span></span><br><span class="line">    <span class="keyword">void</span> *dictionary; <span class="comment">///&lt; NSDictionary (json)</span></span><br><span class="line">&#125; ModelSetContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数12: 对模型(_context.modelMeta and _context.model)设置 key-value键值对</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetWithDictionaryFunction(<span class="keyword">const</span> <span class="keyword">void</span> *_key, <span class="keyword">const</span> <span class="keyword">void</span> *_value, <span class="keyword">void</span> *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta);</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge <span class="keyword">id</span>)(_key)];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model = (__bridge <span class="keyword">id</span>)(context-&gt;model);</span><br><span class="line">    <span class="keyword">while</span> (propertyMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_<span class="keyword">setter</span>) &#123;</span><br><span class="line">            ModelSetValueForProperty(model, (__bridge __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>)_value, propertyMeta);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有多个属性映射到同一个 key 则指向下一个模型属性元</span></span><br><span class="line">        propertyMeta = propertyMeta-&gt;_next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Apply function for model property meta, to set dictionary to model.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param _propertyMeta should not be nil, _YYModelPropertyMeta.</span></span><br><span class="line"><span class="comment"> @param _context      _context.model and _context.dictionary should not be nil.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 函数13:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetWithPropertyMetaArrayFunction(<span class="keyword">const</span> <span class="keyword">void</span> *_propertyMeta, <span class="keyword">void</span> *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSDictionary</span> *dictionary = (__bridge <span class="built_in">NSDictionary</span> *)(context-&gt;dictionary);</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = (__bridge _YYModelPropertyMeta *)(_propertyMeta);</span><br><span class="line">    <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">setter</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyArray) &#123;</span><br><span class="line">        value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;_mappedToKeyArray);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123;</span><br><span class="line">        value = YYValueForKeyPath(dictionary, propertyMeta-&gt;_mappedToKeyPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = [dictionary objectForKey:propertyMeta-&gt;_mappedToKey];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model = (__bridge <span class="keyword">id</span>)(context-&gt;model);</span><br><span class="line">        ModelSetValueForProperty(model, value, propertyMeta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns a valid JSON object (NSArray/NSDictionary/NSString/NSNumber/NSNull),</span></span><br><span class="line"><span class="comment"> or nil if an error occurs.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param model Model, can be nil.</span></span><br><span class="line"><span class="comment"> @return JSON object, nil if an error occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 函数14: 模型转 json</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> ModelToJSONObjectRecursive(<span class="built_in">NSObject</span> *model) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!model || model == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:model]) <span class="keyword">return</span> model;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *newDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        [((<span class="built_in">NSDictionary</span> *)model) enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *stringKey = [key isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] ? key : key.description;</span><br><span class="line">            <span class="keyword">if</span> (!stringKey) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">            <span class="keyword">if</span> (!jsonObj) jsonObj = (<span class="keyword">id</span>)kCFNull;</span><br><span class="line">            newDic[stringKey] = jsonObj;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> newDic;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = ((<span class="built_in">NSSet</span> *)model).allObjects;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:array]) <span class="keyword">return</span> array;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> array) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] || [obj isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                [newArray addObject:obj];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">                <span class="keyword">if</span> (jsonObj &amp;&amp; jsonObj != (<span class="keyword">id</span>)kCFNull) [newArray addObject:jsonObj];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArray;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:model]) <span class="keyword">return</span> model;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)model) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] || [obj isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                [newArray addObject:obj];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">                <span class="keyword">if</span> (jsonObj &amp;&amp; jsonObj != (<span class="keyword">id</span>)kCFNull) [newArray addObject:jsonObj];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArray;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSURL</span> *)model).absoluteString;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSAttributedString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSAttributedString</span> *)model).string;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> [YYISODateFormatter() stringFromDate:(<span class="keyword">id</span>)model];</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model <span class="keyword">class</span>]];</span><br><span class="line">    <span class="keyword">if</span> (!modelMeta || modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *result = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">64</span>];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSMutableDictionary</span> *dic = result; <span class="comment">// avoid retain and release in block</span></span><br><span class="line">    [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">getter</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_isCNumber) &#123;</span><br><span class="line">            value = ModelCreateNumberFromProperty(model, propertyMeta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_nsType) &#123;</span><br><span class="line">            <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">            value = ModelToJSONObjectRecursive(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                    <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = ModelToJSONObjectRecursive(v);</span><br><span class="line">                    <span class="keyword">if</span> (value == (<span class="keyword">id</span>)kCFNull) value = <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                    Class v = ((Class (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromClass</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeSEL: &#123;</span><br><span class="line">                    SEL v = ((SEL (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromSelector</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *superDic = dic;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *subDic = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *key = propertyMeta-&gt;_mappedToKeyPath[i];</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == max) &#123; <span class="comment">// end</span></span><br><span class="line">                    <span class="keyword">if</span> (!superDic[key]) superDic[key] = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                subDic = superDic[key];</span><br><span class="line">                <span class="keyword">if</span> (subDic) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ([subDic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                        subDic = subDic.mutableCopy;</span><br><span class="line">                        superDic[key] = subDic;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    subDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">                    superDic[key] = subDic;</span><br><span class="line">                &#125;</span><br><span class="line">                superDic = subDic;</span><br><span class="line">                subDic = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</span><br><span class="line">                dic[propertyMeta-&gt;_mappedToKey] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformToDictionary) &#123;</span><br><span class="line">        <span class="comment">// 当 Model 转为 JSON 完成后，该方法会被调用。</span></span><br><span class="line">        <span class="comment">// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。</span></span><br><span class="line">        <span class="comment">// 你也可以在这里做一些自动转换不能完成的工作。</span></span><br><span class="line">        <span class="built_in">BOOL</span> suc = [((<span class="keyword">id</span>&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (!suc) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 函数15: Add indent to string (exclude first line)</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableString</span> *ModelDescriptionAddIndent(<span class="built_in">NSMutableString</span> *desc, <span class="built_in">NSUInteger</span> indent) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = desc.length; i &lt; max; i++) &#123;</span><br><span class="line">        <span class="keyword">unichar</span> c = [desc characterAtIndex:i];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; indent; j++) &#123;</span><br><span class="line">                [desc insertString:<span class="string">@"    "</span> atIndex:i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i += indent * <span class="number">4</span>;</span><br><span class="line">            max += indent * <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 函数16: 根据model生成一个描述字符串</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *ModelDescription(<span class="built_in">NSObject</span> *model) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kDescMaxLength = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (!model) <span class="keyword">return</span> <span class="string">@"&lt;nil&gt;"</span>;</span><br><span class="line">    <span class="keyword">if</span> (model == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="string">@"&lt;null&gt;"</span>;</span><br><span class="line">    <span class="keyword">if</span> (![model isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,model];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:model.class];</span><br><span class="line">    <span class="keyword">switch</span> (modelMeta-&gt;_nsType) &#123;</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSString: <span class="keyword">case</span> YYEncodingTypeNSMutableString: &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"\"%@\""</span>,model];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSValue:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSData: <span class="keyword">case</span> YYEncodingTypeNSMutableData: &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *tmp = model.description;</span><br><span class="line">            <span class="keyword">if</span> (tmp.length &gt; kDescMaxLength) &#123;</span><br><span class="line">                tmp = [tmp substringToIndex:kDescMaxLength];</span><br><span class="line">                tmp = [tmp stringByAppendingString:<span class="string">@"..."</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSNumber:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSDecimalNumber:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSDate:</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSURL: &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,model];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSSet: <span class="keyword">case</span> YYEncodingTypeNSMutableSet: &#123;</span><br><span class="line">            model = ((<span class="built_in">NSSet</span> *)model).allObjects;</span><br><span class="line">        &#125; <span class="comment">// no break</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSArray: <span class="keyword">case</span> YYEncodingTypeNSMutableArray: &#123;</span><br><span class="line">            <span class="built_in">NSArray</span> *array = (<span class="keyword">id</span>)model;</span><br><span class="line">            <span class="built_in">NSMutableString</span> *desc = [<span class="built_in">NSMutableString</span> new];</span><br><span class="line">            <span class="keyword">if</span> (array.count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> [desc stringByAppendingString:<span class="string">@"[]"</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [desc appendFormat:<span class="string">@"[\n"</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = array.count; i &lt; max; i++) &#123;</span><br><span class="line">                    <span class="built_in">NSObject</span> *obj = array[i];</span><br><span class="line">                    [desc appendString:<span class="string">@"    "</span>];</span><br><span class="line">                    [desc appendString:ModelDescriptionAddIndent(ModelDescription(obj).mutableCopy, <span class="number">1</span>)];</span><br><span class="line">                    [desc appendString:(i + <span class="number">1</span> == max) ? <span class="string">@"\n"</span> : <span class="string">@";\n"</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                [desc appendString:<span class="string">@"]"</span>];</span><br><span class="line">                <span class="keyword">return</span> desc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> YYEncodingTypeNSDictionary: <span class="keyword">case</span> YYEncodingTypeNSMutableDictionary: &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *dic = (<span class="keyword">id</span>)model;</span><br><span class="line">            <span class="built_in">NSMutableString</span> *desc = [<span class="built_in">NSMutableString</span> new];</span><br><span class="line">            <span class="keyword">if</span> (dic.count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> [desc stringByAppendingString:<span class="string">@"&#123;&#125;"</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">NSArray</span> *keys = dic.allKeys;</span><br><span class="line">                </span><br><span class="line">                [desc appendFormat:<span class="string">@"&#123;\n"</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = keys.count; i &lt; max; i++) &#123;</span><br><span class="line">                    <span class="built_in">NSString</span> *key = keys[i];</span><br><span class="line">                    <span class="built_in">NSObject</span> *value = dic[key];</span><br><span class="line">                    [desc appendString:<span class="string">@"    "</span>];</span><br><span class="line">                    [desc appendFormat:<span class="string">@"%@ = %@"</span>,key, ModelDescriptionAddIndent(ModelDescription(value).mutableCopy, <span class="number">1</span>)];</span><br><span class="line">                    [desc appendString:(i + <span class="number">1</span> == max) ? <span class="string">@"\n"</span> : <span class="string">@";\n"</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                [desc appendString:<span class="string">@"&#125;"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> desc;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="built_in">NSMutableString</span> *desc = [<span class="built_in">NSMutableString</span> new];</span><br><span class="line">            [desc appendFormat:<span class="string">@"&lt;%@: %p&gt;"</span>, model.class, model];</span><br><span class="line">            <span class="keyword">if</span> (modelMeta-&gt;_allPropertyMetas.count == <span class="number">0</span>) <span class="keyword">return</span> desc;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// sort property names</span></span><br><span class="line">            <span class="built_in">NSArray</span> *properties = [modelMeta-&gt;_allPropertyMetas</span><br><span class="line">                                   sortedArrayUsingComparator:^<span class="built_in">NSComparisonResult</span>(_YYModelPropertyMeta *p1, _YYModelPropertyMeta *p2) &#123;</span><br><span class="line">                                       <span class="keyword">return</span> [p1-&gt;_name compare:p2-&gt;_name];</span><br><span class="line">                                   &#125;];</span><br><span class="line">            </span><br><span class="line">            [desc appendFormat:<span class="string">@" &#123;\n"</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = properties.count; i &lt; max; i++) &#123;</span><br><span class="line">                _YYModelPropertyMeta *property = properties[i];</span><br><span class="line">                <span class="built_in">NSString</span> *propertyDesc;</span><br><span class="line">                <span class="keyword">if</span> (property-&gt;_isCNumber) &#123;</span><br><span class="line">                    <span class="built_in">NSNumber</span> *num = ModelCreateNumberFromProperty(model, property);</span><br><span class="line">                    propertyDesc = num.stringValue;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (property-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                            <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, property-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                            propertyDesc = ModelDescription(v);</span><br><span class="line">                            <span class="keyword">if</span> (!propertyDesc) propertyDesc = <span class="string">@"&lt;nil&gt;"</span>;</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                            <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, property-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                            propertyDesc = ((<span class="built_in">NSObject</span> *)v).description;</span><br><span class="line">                            <span class="keyword">if</span> (!propertyDesc) propertyDesc = <span class="string">@"&lt;nil&gt;"</span>;</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeSEL: &#123;</span><br><span class="line">                            SEL sel = ((SEL (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, property-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                            <span class="keyword">if</span> (sel) propertyDesc = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">                            <span class="keyword">else</span> propertyDesc = <span class="string">@"&lt;NULL&gt;"</span>;</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeBlock: &#123;</span><br><span class="line">                            <span class="keyword">id</span> block = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, property-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                            propertyDesc = block ? ((<span class="built_in">NSObject</span> *)block).description : <span class="string">@"&lt;nil&gt;"</span>;</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeCArray: <span class="keyword">case</span> YYEncodingTypeCString: <span class="keyword">case</span> YYEncodingTypePointer: &#123;</span><br><span class="line">                            <span class="keyword">void</span> *pointer = ((<span class="keyword">void</span>* (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, property-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                            propertyDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>,pointer];</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> YYEncodingTypeStruct: <span class="keyword">case</span> YYEncodingTypeUnion: &#123;</span><br><span class="line">                            <span class="built_in">NSValue</span> *value = [model valueForKey:property-&gt;_name];</span><br><span class="line">                            propertyDesc = value ? value.description : <span class="string">@"&#123;unknown&#125;"</span>;</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: propertyDesc = <span class="string">@"&lt;unknown&gt;"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                propertyDesc = ModelDescriptionAddIndent(propertyDesc.mutableCopy, <span class="number">1</span>);</span><br><span class="line">                [desc appendFormat:<span class="string">@"    %@ = %@"</span>,property-&gt;_name, propertyDesc];</span><br><span class="line">                [desc appendString:(i + <span class="number">1</span> == max) ? <span class="string">@"\n"</span> : <span class="string">@";\n"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            [desc appendFormat:<span class="string">@"&#125;"</span>];</span><br><span class="line">            <span class="keyword">return</span> desc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><p> 1.强制内联</p> <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">#define force_inline __inline__ __attribute__((<span class="name">always_inline</span>))</span><br></pre></td></tr></table></figure><p>2.使用代码块, 节省许多变量名</p> <figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init]<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用block数组</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSDate</span>* (^YYNSDateParseBlock)(<span class="built_in">NSString</span> *string);</span><br><span class="line"><span class="comment">// 定义一个block数组</span></span><br><span class="line"><span class="keyword">static</span> YYNSDateParseBlock blocks[<span class="number">35</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>4.获取NSBlock类</p><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;&#125;;</span><br><span class="line">cls = ((NSObject *)block).<span class="keyword">class</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">class</span><span class="number">_</span>getSuperclass(cls) != [NSObject <span class="keyword">class</span>]) &#123;</span><br><span class="line">    cls = <span class="keyword">class</span><span class="number">_</span>getSuperclass(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 5.函数参数使用<code>__unsafe_unretained</code><br> 在 ARC 条件下，默认声明的对象是 <code>__strong</code> 类型的，赋值时有可能会产生<code>retain/release</code>调用，如果一个变量在其生命周期内不会被释放，则使用<code>__unsafe_unretained `</code>会节省很大的开销。</p><p> 访问具有 <code>__weak</code>属性的变量时，实际上会调用 <code>objc_loadWeak()</code> 和 <code>objc_storeWeak()</code> 来完成，这也会带来很大的开销，所以要避免使用 <code>__weak</code>属性。</p><p> 创建和使用对象时，要尽量避免对象进入<code>autoreleasepool</code>，以避免额外的资源开销。</p><p> 6.for循环中定义变量, 使用unsigned</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, <span class="built_in">max</span> = keyPaths.count; i &lt; <span class="built_in">max</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 7.可变量创建静态不变量, 静态常量配合dispatch_once使用</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSSet</span> *types = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"><span class="built_in">NSMutableSet</span> *set = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">    types = set;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 8.线程安全的缓存字典</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> cacheWithKey(<span class="built_in">NSString</span> *key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> cache;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> dispatch_semaphore_t lock;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        cache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="keyword">id</span> obj = <span class="built_in">CFDictionaryGetValue</span>(cache, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    dispatch_semaphore_signal(lock);</span><br><span class="line">    <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">        obj = [<span class="built_in">NSObject</span> new]; <span class="comment">// Other operation.</span></span><br><span class="line">        <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(cache, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key), (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(obj));</span><br><span class="line">            dispatch_semaphore_signal(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.消息发送调用格式</p><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">((<span class="name">int32_t</span> (<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))(<span class="name">void</span> *) objc_msgSend)((<span class="name"><span class="builtin-name">id</span></span>)model, meta-&gt;_getter)</span><br></pre></td></tr></table></figure><p>10.<code>NSNull</code>的单例<code>kCFNull</code>, 推荐使用, 而不是创建<code>[NSNull null]</code></p> <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNull</span> *null1 = (<span class="keyword">id</span>)kCFNull;</span><br><span class="line"><span class="built_in">NSNull</span> *null2 = [<span class="built_in">NSNull</span> null];</span><br><span class="line"></span><br><span class="line">Class <span class="keyword">class</span> = Nil;</span><br><span class="line"><span class="built_in">NSDate</span> *date = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>11.<code>YYClassIvarInfo</code>中的 <code>name</code> 和 <code>typeEncoding</code> 属性都用 <code>strong</code> 修饰。<br>NSString 这类属性在确定其不会在初始化之后被修改的情况下，使用 strong 做一次单纯的强引用在性能上讲比 copy 要高一些。</p><p>12.<code>NSString</code>转C字符串</p><p> <code>const char *cstring = ((NSString *)value).UTF8String;</code></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p> YYModel 最核心的便是通过遍历模型的所有属性，根据字典值来调用属性的 setter 方法。没有使用效率低下的 KVC（效率低下的原因可能是需要对方法进行搜索吧，有空深究）。鉴于此，用了300行代码简单写了一个字典转模型的玩具，权当做是读完 YYModel 的实践吧。试了一下，效果还可以😂。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">@protocol</span> <span class="title">YAModelProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span>;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)customPropertyKey;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, Class&gt;*)classInArray;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">YAModel</span>)</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)ya_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dict;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)ya_modelWithJSON:(<span class="built_in">NSData</span> *)data;</span><br><span class="line">+ (<span class="built_in">NSArray</span> *)ya_modelArrayWithKeyValuesArray:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSDictionary</span> *&gt;*)dictArray;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编码类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, YAType) &#123;</span><br><span class="line">    YATypeMask              = <span class="number">0xFF</span>,</span><br><span class="line">    YATypeUnknown           = <span class="number">0</span>,</span><br><span class="line">    YATypeBOOL              = <span class="number">1</span>,</span><br><span class="line">    YATypeNSInteger         = <span class="number">2</span>,</span><br><span class="line">    YATypeNSUInteger        = <span class="number">3</span>,</span><br><span class="line">    YATypeCGFloat           = <span class="number">4</span>,</span><br><span class="line">    YATypeObject            = <span class="number">5</span>,</span><br><span class="line">    YATypeDate              = <span class="number">6</span>,</span><br><span class="line">    YATypeClass             = <span class="number">7</span>,</span><br><span class="line">    YATypeSEL               = <span class="number">8</span>,</span><br><span class="line">    YATypeArray             = <span class="number">9</span>,</span><br><span class="line">    YATypeMutableArray      = <span class="number">10</span>,</span><br><span class="line">    YATypeDictionary        = <span class="number">11</span>,</span><br><span class="line">    YATypeMutableDictionary = <span class="number">12</span>,</span><br><span class="line">    YATypeSet               = <span class="number">13</span>,</span><br><span class="line">    YATypeMutableSet        = <span class="number">14</span>,</span><br><span class="line">    YATypeString            = <span class="number">15</span>,</span><br><span class="line">    YATypeMutableString     = <span class="number">16</span>,</span><br><span class="line">    YATypeData              = <span class="number">17</span>,</span><br><span class="line">    YATypeNumber            = <span class="number">18</span>,</span><br><span class="line">    YATypeDecimalNumber     = <span class="number">19</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">YAModel</span>)</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDictionary</span> *classArrayDict = <span class="literal">nil</span>;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)ya_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dict &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dict || ![dict isKindOfClass:<span class="built_in">NSDictionary</span>.class]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *propertyList = PropertyList(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">id</span> obj = [<span class="keyword">self</span> new];</span><br><span class="line">    ObjSetWithKeyValueList(obj, propertyList, dict);</span><br><span class="line">    classArrayDict = <span class="literal">nil</span>; <span class="comment">// Clean memory.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)ya_modelWithJSON:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || ![data isKindOfClass:<span class="built_in">NSData</span>.class]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> json = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> ([json isKindOfClass:<span class="built_in">NSDictionary</span>.class]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> ya_modelWithDictionary:json];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)ya_modelArrayWithKeyValuesArray:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSDictionary</span> *&gt; *)dictArray &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dictArray || ![dictArray isKindOfClass:<span class="built_in">NSArray</span>.class]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *tmp = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:dictArray.count];</span><br><span class="line">    [dictArray enumerateObjectsUsingBlock:^(<span class="built_in">NSDictionary</span> * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSDictionary</span>.class]) &#123;</span><br><span class="line">            <span class="keyword">id</span> model = [[<span class="keyword">self</span> <span class="keyword">class</span>] ya_modelWithDictionary:obj];</span><br><span class="line">            [tmp addObject:model];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:tmp] ?: <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性列表 key:属性名 value: 属性类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDictionary</span> *PropertyList(Class cls) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    objc_property_t *properties = class_copyPropertyList(cls, &amp;count);</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *tempDict = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        objc_property_t property = properties[i];</span><br><span class="line">        <span class="built_in">NSString</span> *propertyName = [<span class="built_in">NSString</span> stringWithUTF8String:property_getName(property)];</span><br><span class="line">        <span class="built_in">NSString</span> *propertyAttr = [<span class="built_in">NSString</span> stringWithUTF8String:property_getAttributes(property)];</span><br><span class="line">        <span class="built_in">NSString</span> *type = [propertyAttr substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">1</span>, <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">if</span> ([type isEqualToString:<span class="string">@"@"</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSArray</span> *components = [propertyAttr componentsSeparatedByString:<span class="string">@"\""</span>];</span><br><span class="line">            <span class="keyword">if</span> (components.count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                Class propCls = <span class="built_in">NSClassFromString</span>(components[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (propCls == <span class="built_in">NSDate</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"1"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSArray</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"2"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSMutableArray</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"3"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSDictionary</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"4"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSMutableDictionary</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"5"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSSet</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"6"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSMutableSet</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"7"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSString</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"8"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSMutableString</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"9"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSData</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"10"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSNumber</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"11"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSDecimalNumber</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"12"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propCls == <span class="built_in">NSObject</span>.class) &#123;</span><br><span class="line">                    type = <span class="string">@"@"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    type = components[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSNumber</span> *myType = TypeForProperty(type);</span><br><span class="line">        [tempDict setObject:myType forKey:propertyName];</span><br><span class="line">        <span class="keyword">if</span> (myType.integerValue == <span class="number">0</span>) &#123;</span><br><span class="line">            [tempDict setObject:type forKey:propertyName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(properties);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:tempDict];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSNumber</span> *TypeForProperty(<span class="built_in">NSString</span> *type) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDictionary</span> *_SELDictionary = <span class="literal">nil</span>;;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _SELDictionary = @&#123;</span><br><span class="line">                           <span class="string">@"B"</span>: @(YATypeBOOL),</span><br><span class="line">                           <span class="string">@"q"</span>: @(YATypeNSInteger),</span><br><span class="line">                           <span class="string">@"Q"</span>: @(YATypeNSUInteger),</span><br><span class="line">                           <span class="string">@"d"</span>: @(YATypeCGFloat),</span><br><span class="line">                           <span class="string">@"#"</span>: @(YATypeClass),</span><br><span class="line">                           <span class="string">@":"</span>: @(YATypeSEL),</span><br><span class="line">                           <span class="string">@"@"</span>: @(YATypeObject),</span><br><span class="line">                           <span class="string">@"1"</span>: @(YATypeDate),</span><br><span class="line">                           <span class="string">@"2"</span>: @(YATypeArray),</span><br><span class="line">                           <span class="string">@"3"</span>: @(YATypeMutableArray),</span><br><span class="line">                           <span class="string">@"4"</span>: @(YATypeDictionary),</span><br><span class="line">                           <span class="string">@"5"</span>: @(YATypeMutableDictionary),</span><br><span class="line">                           <span class="string">@"6"</span>: @(YATypeSet),</span><br><span class="line">                           <span class="string">@"7"</span>: @(YATypeMutableSet),</span><br><span class="line">                           <span class="string">@"8"</span>: @(YATypeString),</span><br><span class="line">                           <span class="string">@"9"</span>: @(YATypeMutableString),</span><br><span class="line">                           <span class="string">@"10"</span>: @(YATypeData),</span><br><span class="line">                           <span class="string">@"11"</span>: @(YATypeNumber),</span><br><span class="line">                           <span class="string">@"12"</span>: @(YATypeDecimalNumber),</span><br><span class="line">                           &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _SELDictionary[type] ?: @(YATypeUnknown);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ObjSetWithArray(Class cls, <span class="built_in">NSDictionary</span> *propertyDict, <span class="built_in">NSArray</span> **keyValueArray) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *tmpArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [*keyValueArray enumerateObjectsUsingBlock:^(<span class="keyword">id</span> keyValue, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([keyValue isKindOfClass:<span class="built_in">NSDictionary</span>.class]) &#123;</span><br><span class="line">            <span class="keyword">id</span> obj = [cls new];</span><br><span class="line">            ObjSetWithKeyValueList(obj, PropertyList([obj <span class="keyword">class</span>]), keyValue);</span><br><span class="line">            [tmpArray addObject:obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    *keyValueArray = [<span class="built_in">NSArray</span> arrayWithArray:tmpArray];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ObjSetWithKeyValueList(<span class="keyword">id</span> obj, <span class="built_in">NSDictionary</span> *propertyDict, <span class="built_in">NSDictionary</span> *dict) &#123;</span><br><span class="line">    Class cls = [obj <span class="keyword">class</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *customPropertyKeyDict = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(customPropertyKey)]) &#123;</span><br><span class="line">        customPropertyKeyDict = [cls customPropertyKey];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(classInArray)] &amp;&amp; !classArrayDict) &#123;</span><br><span class="line">        classArrayDict = [cls classInArray];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [propertyDict.allKeys enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *name, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        SEL <span class="keyword">setter</span> = SetterSelectorFromString(name);</span><br><span class="line">        <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (customPropertyKeyDict[name]) &#123;</span><br><span class="line">            value = customPropertyKeyDict[name];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value = dict[name];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">id</span> propType = propertyDict[name];</span><br><span class="line">        YAType type = [propType integerValue];</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (type &amp; YATypeMask) &#123;</span><br><span class="line">                <span class="keyword">case</span> YATypeBOOL: &#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">bool</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, [value boolValue]);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeNSInteger: &#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, int64_t))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, (int64_t)[value longLongValue]);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeNSUInteger: &#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, uint64_t))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, (uint64_t)[value unsignedLongLongValue]);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeCGFloat: &#123;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">double</span> d = [value doubleValue];</span><br><span class="line">                    <span class="keyword">if</span> (isnan(d) || isinf(d)) d = <span class="number">0</span>;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">long</span> <span class="keyword">double</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, (<span class="keyword">long</span> <span class="keyword">double</span>)d);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeDecimalNumber: &#123;</span><br><span class="line">                    <span class="keyword">if</span> ([value isKindOfClass:<span class="built_in">NSNumber</span>.class]) &#123;</span><br><span class="line">                        <span class="built_in">NSDecimalNumber</span> *decNum = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithDecimal:[value decimalValue]];</span><br><span class="line">                        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">NSDecimalNumber</span> *))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, decNum);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeClass: &#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, Class))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, <span class="built_in">NSClassFromString</span>(value));</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeSEL:&#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, <span class="built_in">NSSelectorFromString</span>(value));</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeDate:&#123;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, DateFromString(value));</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeArray: &#123;</span><br><span class="line">                    Class cls = classArrayDict[name];</span><br><span class="line">                    <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">                        ObjSetWithArray(cls, PropertyList(cls), &amp;value);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeMutableArray: &#123;</span><br><span class="line">                    <span class="built_in">NSString</span> *clsStr = classArrayDict[name];</span><br><span class="line">                    <span class="keyword">if</span> (clsStr) &#123;</span><br><span class="line">                        Class cls = <span class="built_in">NSClassFromString</span>(clsStr);</span><br><span class="line">                        ObjSetWithArray(cls, PropertyList(cls), &amp;value);</span><br><span class="line">                    &#125;</span><br><span class="line">                    value = [<span class="built_in">NSMutableArray</span> arrayWithArray:value];</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeSet: &#123;</span><br><span class="line">                    value = [<span class="built_in">NSSet</span> setWithArray:value];</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeMutableSet: &#123;</span><br><span class="line">                    value = [<span class="built_in">NSMutableSet</span> setWithArray:value];</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeMutableString:</span><br><span class="line">                <span class="keyword">case</span> YATypeMutableDictionary: &#123;</span><br><span class="line">                    value = [value mutableCopy];</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YATypeString:</span><br><span class="line">                <span class="keyword">case</span> YATypeDictionary:</span><br><span class="line">                <span class="keyword">case</span> YATypeNumber:</span><br><span class="line">                <span class="keyword">case</span> YATypeUnknown:</span><br><span class="line">                <span class="keyword">case</span> YATypeObject: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (type == YATypeUnknown &amp;&amp; [propType isKindOfClass:<span class="built_in">NSString</span>.class]) &#123; <span class="comment">// 嵌套模型</span></span><br><span class="line">                        Class cls = <span class="built_in">NSClassFromString</span>(propType);</span><br><span class="line">                        <span class="keyword">if</span> (cls &amp;&amp; [value isKindOfClass:<span class="built_in">NSDictionary</span>.class]) &#123;</span><br><span class="line">                            <span class="keyword">id</span> obj = [cls new];</span><br><span class="line">                            ObjSetWithKeyValueList(obj, PropertyList(cls), value);</span><br><span class="line">                            value = obj;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)obj, <span class="keyword">setter</span>, value);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name  ==&gt; setName:</span></span><br><span class="line"><span class="keyword">static</span> SEL SetterSelectorFromString(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str || str.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *result = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@%@:"</span>, [str substringToIndex:<span class="number">1</span>].uppercaseString, [str substringFromIndex:<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSSelectorFromString</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// date string ==&gt; data // @"2016-7-16 09:33:22"</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDate</span> *DateFromString(<span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">NSDate</span>* (^DateParseBlock)(<span class="built_in">NSString</span> *string);</span><br><span class="line">    <span class="keyword">static</span> DateParseBlock blocks[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// @"2016-07-16 09:33:22" // 19个字符, 对应blocks[19]</span></span><br><span class="line">        <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">        formatter.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">        formatter.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">        blocks[<span class="number">19</span>] = ^(<span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">            <span class="keyword">return</span> [formatter dateFromString:string];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!string || string.length &gt; <span class="number">19</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    DateParseBlock parser = blocks[string.length];</span><br><span class="line">    <span class="keyword">if</span> (!parser) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> parser(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>具体源码放在了我的代码工具库里，YAKit：<a href="https://github.com/ChenYalun/YAKit/tree/master/Util/Model" target="_blank" rel="noopener">https://github.com/ChenYalun/YAKit/tree/master/Util/Model</a></p><blockquote><p>参考资料<br> <a href="https://juejin.im/post/5a097435f265da431769a49c" target="_blank" rel="noopener">https://juejin.im/post/5a097435f265da431769a49c</a><br> <a href="https://juejin.im/post/5a1296e36fb9a044fb075d5e" target="_blank" rel="noopener">https://juejin.im/post/5a1296e36fb9a044fb075d5e</a><br> <a href="https://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/</a><br> <a href="https://blog.csdn.net/game3108/article/details/52416868" target="_blank" rel="noopener">https://blog.csdn.net/game3108/article/details/52416868</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 关于YYModel的简单总结。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>PerformSelector原理</title>
    <link href="http://blog.chenyalun.com/2018/09/30/PerformSelector%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.chenyalun.com/2018/09/30/PerformSelector原理/</id>
    <published>2018-09-30T09:22:13.000Z</published>
    <updated>2019-09-22T07:22:44.642Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> PerformSelector相关知识。 </p><a id="more"></a><p>performSelector系列是个很神奇的存在，能传参，能延迟，还能子线程调，能让任意对象执行任意方法，读了gnustep中有关performSelector的源码后，这里做个总结。</p><blockquote><p>源码地址：<a href="https://github.com/gnustep/libs-base/releases/tag/base-1_25_1" target="_blank" rel="noopener">https://github.com/gnustep/libs-base/releases/tag/base-1_25_1</a></p></blockquote><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>最基本的performSelector有三个接口方法，可以不传参，传一个参数以及传两个参数。</p><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object1 withObject:<span class="params">(id)</span>object2;</span><br></pre></td></tr></table></figure><p>使用示例:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参 </span></span><br><span class="line">id obj1 = [self <span class="string">performSelector:</span><span class="meta">@selector</span>(printString)];</span><br><span class="line"><span class="comment">// 一个参数</span></span><br><span class="line">id obj2 = [self <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">printString:</span>) <span class="string">withObject:</span>@<span class="string">"string"</span>];</span><br><span class="line"><span class="comment">// 两个参数</span></span><br><span class="line">id obj3 = [self <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">printString:</span><span class="string">str2:</span>) <span class="string">withObject:</span>@<span class="string">"string"</span> <span class="string">withObject:</span>@&#123;@<span class="string">"key"</span>: @(<span class="number">3</span>)&#125;];</span><br></pre></td></tr></table></figure><p>以传递两个参数为例，它的实现是这样的：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector</span><br><span class="line">           withObject:(<span class="keyword">id</span>)object1</span><br><span class="line">           withObject:(<span class="keyword">id</span>)object2 &#123;</span><br><span class="line">    IMP msg;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="built_in">NSException</span> raise: <span class="built_in">NSInvalidArgumentException</span></span><br><span class="line">                    format: <span class="string">@"%@ null selector given"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">    &#125;</span><br><span class="line">    msg = objc_msg_lookup(<span class="keyword">self</span>, aSelector);</span><br><span class="line">    <span class="keyword">if</span> (!msg) &#123;</span><br><span class="line">        [<span class="built_in">NSException</span> raise: <span class="built_in">NSGenericException</span></span><br><span class="line">                    format: <span class="string">@"invalid selector '%s' passed to %s"</span>,</span><br><span class="line">         sel_getName(aSelector), sel_getName(_cmd)];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*msg)(<span class="keyword">self</span>, aSelector, object1, object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见就是根据方法名，<strong>使用Runtime中的<code>objc_msg_lookup()</code>获取到函数指针IMP，进而进行函数调用。</strong>当然，还有对方法名和函数指针的容错处理。</p><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>performSelector系列颇具有动态性，当使用这三个方法时，编译器很容易就给出警告：PerformSelector may cause a leak because its selector is unknown。为什么会提示有内存泄漏问题呢？</p><p>首先要明确：<strong>调用<code>performSelector:</code>编译器会假设调用方法的返回值是一个对象，且不会对返回值进行retain/release</strong>。</p><p>如果调用的方法是<code>alloc, new, copy, mutableCopy</code>方法家族中的方法(包含以它们开头)，方法调用的结果是开辟了一块内存空间，但是系统仍然按照非retain/release处理，没有对它们的引用计数纳入管理，这时内存空间无法释放，就会产生内存泄露。</p><p>当<strong>显式调用</strong>这些方法时，编译器都能明显分析出来，并给出提示：Error：PerformSelector names a selector which retains the object。告诉我们这不符合引用计数管理的规则，编译不通过。</p><p>There are really only 4 things that ARC would consider for the return value:4</p><ul><li>Ignore non-object types (void, int, etc)</li><li>Retain object value, then release when it is no longer used (standard assumption)</li><li>Release new object values when no longer used (methods in the init/ copy family or attributed with ns_returns_retained)</li><li>Do nothing &amp; assume returned object value will be valid in local scope (until inner most release pool is drained, attributed with ns_returns_autoreleased)</li></ul><p>The call to methodForSelector: assumes that the return value of the method it’s calling is an object, but does not retain/release it. So you could end up creating a leak if your object is supposed to be released as in #3 above (that is, the method you’re calling returns a new object).</p><p>比如这样：<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">- (id)<span class="keyword">new</span><span class="type">Object</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [NSObject <span class="keyword">new</span><span class="type"></span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用method family中的方法：</span></span><br><span class="line">[str <span class="string">performSelector:</span><span class="meta">@selector</span>(copy)];</span><br><span class="line"><span class="comment">// 调用以method family中的方法名开头的方法：</span></span><br><span class="line">[self <span class="string">performSelector:</span><span class="meta">@selector</span>(newObject)];</span><br></pre></td></tr></table></figure><p>但是<strong>隐式调用</strong>的时候，编译器无能为力了，只能给出警告：PerformSelector may cause a leak because its selector is unknown。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐式调用无法分析出错误: 出现内存泄露</span></span><br><span class="line"><span class="keyword">id</span> obj1 = [str performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"copy"</span>)];</span><br><span class="line">[str performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"mutableCopy"</span>)];</span><br><span class="line"><span class="keyword">id</span> obj2 = [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"new"</span>)];</span><br><span class="line"><span class="keyword">id</span> obj3 = [<span class="keyword">self</span> performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)];</span><br></pre></td></tr></table></figure><h3 id="消除waring"><a href="#消除waring" class="headerlink" title="消除waring"></a>消除waring</h3><p>最简单的，可以利用<code>#pragma</code>消除警告。</p><figure class="highlight leaf"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic push"</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic ignored \"</span>-<span class="variable">Warc</span>-<span class="variable">performSelector</span>-<span class="variable">leaks</span>\<span class="string">""</span>)</span></span></span><br><span class="line">[person performSelector:selector]; // 插入需要消除警告的代码</span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="title">pragma</span><span class="params">(<span class="string">"clang diagnostic pop"</span>)</span></span></span><br></pre></td></tr></table></figure><p>或者换种思路，根据<code>performSelector</code>的实现，效果上可以直接使用<code>IMP</code>，也可以使用<code>objc_msgSend()</code>，甚至使用<code>NSInvocation</code>、<code>sendAction</code>等，这样就达到同等实现而没有警告了。</p><p>方式1：methodForSelector<br><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!person) return;</span><br><span class="line"><span class="comment">// 获取函数指针</span></span><br><span class="line">IMP imp = [person methodForSelector:<span class="keyword">selector</span>];</span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line">void <span class="comment">(*func)(id, SEL) = (void *)</span>imp;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">func(person, <span class="keyword">selector</span>);</span><br></pre></td></tr></table></figure></p><p>方式2：methodForSelector简化版<br><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">((<span class="name">void</span> (<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))[person methodForSelector:selector])(<span class="name">self</span>, selector)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>方式3：使用objc_msgSend<br><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">((<span class="name">void</span> *(<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))objc_msgSend)((<span class="name"><span class="builtin-name">id</span></span>)self, NSSelectorFromString(@<span class="string">"show"</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>方式4：NSInvocation<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"show"</span>);</span><br><span class="line"><span class="built_in">NSMethodSignature</span> *methodSig = [[<span class="keyword">self</span> <span class="keyword">class</span>] instanceMethodSignatureForSelector:selector];</span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:methodSig];</span><br><span class="line">[invocation setSelector:selector];</span><br><span class="line">[invocation setTarget:<span class="keyword">self</span>];</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure></p><p>方式5: sendAction<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIApplication</span>.sharedApplication sendAction:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"show"</span>) to:<span class="keyword">self</span> from:<span class="literal">nil</span> forEvent:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p><h3 id="解决内存泄漏"><a href="#解决内存泄漏" class="headerlink" title="解决内存泄漏"></a>解决内存泄漏</h3><p>当我们一定要调用<code>newObject</code>这类特殊的方法时（可能性极小），怎么解决内存泄漏问题呢？把return的对象的引用计数减少即可，比如：</p><p>当使用<code>objc_msgSend()</code>时<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = <span class="built_in">CFBridgingRelease</span>(((<span class="keyword">void</span> *(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(<span class="keyword">self</span>, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)));</span><br></pre></td></tr></table></figure></p><p>当使用<code>methodForSelector</code>时<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = <span class="built_in">CFBridgingRelease</span>(((<span class="keyword">void</span> *(*)(<span class="keyword">id</span>, SEL))[<span class="keyword">self</span> methodForSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)])(<span class="keyword">self</span>, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"newObject"</span>)));</span><br></pre></td></tr></table></figure></p><h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument;</span><br><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget;</span><br></pre></td></tr></table></figure><h3 id="performSelector-withObject-afterDelay"><a href="#performSelector-withObject-afterDelay" class="headerlink" title="performSelector:withObject:afterDelay:"></a>performSelector:withObject:afterDelay:</h3><p>源码实现:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector</span><br><span class="line">             withObject:(<span class="keyword">id</span>)argument</span><br><span class="line">             afterDelay:(<span class="built_in">NSTimeInterval</span>)seconds &#123;</span><br><span class="line">    <span class="built_in">NSRunLoop</span> *loop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    GSTimedPerformer *item;</span><br><span class="line">    <span class="comment">// item引用计数+1</span></span><br><span class="line">    item = [[GSTimedPerformer alloc] initWithSelector:aSelector</span><br><span class="line">                                               target:<span class="keyword">self</span></span><br><span class="line">                                             argument:argument</span><br><span class="line">                                                delay:seconds];</span><br><span class="line">    <span class="comment">// 持有item</span></span><br><span class="line">    [[loop _timedPerformers] addObject:item];</span><br><span class="line">    <span class="comment">// item引用计数-1</span></span><br><span class="line">    RELEASE(item);</span><br><span class="line">    <span class="comment">// 持有timer</span></span><br><span class="line">    [loop addTimer:item-&gt;timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要做了这些事:</p><ol><li>获取当前线程的Runloop对象。</li><li>根据方法名、方法参数、方法调用者及延迟时间等信息创建一个<code>GSTimedPerformer</code>对象，把该对象添加到Runloop的<code>_timedPerformers</code>数组中保存。</li><li>把GSTimedPerformer中的定时器timer添加到Runloop中。</li></ol><p>如官方文档所说:This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode.</p><p>看看GSTimedPerformer做了什么:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GSTimedPerformer</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">  SEL selector;</span><br><span class="line">  <span class="keyword">id</span> target;</span><br><span class="line">  <span class="keyword">id</span> argument;</span><br><span class="line">  <span class="built_in">NSTimer</span> *timer;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)fire;</span><br><span class="line">- (<span class="keyword">id</span>)initWithSelector:(SEL)aSelector</span><br><span class="line">                target:(<span class="keyword">id</span>)target</span><br><span class="line">              argument:(<span class="keyword">id</span>)argument</span><br><span class="line">                 delay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line">- (<span class="keyword">void</span>)invalidate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GSTimedPerformer</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span> finalize];</span><br><span class="line">    TEST_RELEASE(timer);</span><br><span class="line">    <span class="comment">// 释放target对象</span></span><br><span class="line">    RELEASE(target);</span><br><span class="line">    RELEASE(argument);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)finalize &#123;</span><br><span class="line">    [<span class="keyword">self</span> invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fire &#123;</span><br><span class="line">    DESTROY(timer);</span><br><span class="line">    [target performSelector:selector withObject:argument];</span><br><span class="line">    [[[<span class="built_in">NSRunLoop</span> currentRunLoop] _timedPerformers] removeObjectIdenticalTo:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithSelector:(SEL)aSelector</span><br><span class="line">                target:(<span class="keyword">id</span>)aTarget</span><br><span class="line">              argument:(<span class="keyword">id</span>)anArgument</span><br><span class="line">                 delay:(<span class="built_in">NSTimeInterval</span>)delay &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        selector = aSelector;</span><br><span class="line">        <span class="comment">// 持有target</span></span><br><span class="line">        target = RETAIN(aTarget);</span><br><span class="line">        argument = RETAIN(anArgument);</span><br><span class="line">        timer = [[<span class="built_in">NSTimer</span> allocWithZone:<span class="built_in">NSDefaultMallocZone</span>()]</span><br><span class="line">                 initWithFireDate:<span class="literal">nil</span></span><br><span class="line">                 interval:delay</span><br><span class="line">                 target:<span class="keyword">self</span></span><br><span class="line">                 selector:<span class="keyword">@selector</span>(fire)</span><br><span class="line">                 userInfo:<span class="literal">nil</span></span><br><span class="line">                 repeats:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">        DESTROY(timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>The GSTimedPerformer class is used to hold information about messages which are due to be sent to objects at a particular time.</p><p>可见，<code>GSTimedPerformer</code>作用就是保存关于消息的信息，具体方法的延迟和调用主要还是依靠其内部的定时器。分析源码可知，Runloop的<code>_timedPerformers</code>数组持有了<code>GSTimedPerformer</code>，Runloop还持有<code>GSTimedPerformer</code>内部的定时器<code>timer</code>，定时器<code>timer</code>持有着<code>target(self)</code>。而<code>GSTimedPerformer</code>持有着<code>target(self)</code>和定时器<code>timer</code>。</p><p>引用关系如图所示：<br><img src="https://image.chenyalun.com/2018/09/30/002.png" style="zoom:40%"></p><p>当设置的时间到的时候，<code>GSTimedPerformer</code>内部的<code>fire</code>方法得到调用，此时外界的<code>target</code>便调用了被设置的<code>selector</code>，起到了延迟执行的效果。紧接着，Runloop的<code>_timedPerformers</code>数组移除了对<code>GSTimedPerformer</code>的引用，<code>GSTimedPerformer</code>自然会销毁，它的<code>dealloc</code>方法得到调用。而<code>GSTimedPerformer</code>中的<code>dealloc</code>内部调用了<code>finalize</code>方法，<code>finalize</code>方法的目的是<code>invalidate</code>掉定时器<code>timer</code>并减少它的引用计数。此时，<code>timer</code>只有Runloop持有着它了，关键是timer一旦被<code>invalidate</code>，Runloop也不会再持有它了（Timers are removed automatically when they are invalid）。这样，<code>timer</code>彻底死掉，对<code>target</code>的强引用也没有了，一切恢复如初。</p><p>这一切的前提建立在Runloop运行在<code>NSDefaultRunLoopMode</code>模式下并顺利调用<code>fire</code>方法。<strong>当延迟方法因种种原因没有执行就可能出现内存泄露。</strong></p><p>很经典的例子：从A控制器push到B控制器，B控制器此时执行一个方法：<code>[self performSelector:@selector(printInfo) withObject:nil afterDelay:100];</code>。此时从B控制器pop到A控制器，很明显B控制器并没有销毁，因为Runloop还（间接）强引用着它，可以理解为出现了内存泄露(尽管100s后<code>printInfo</code>方法得到执行，B控制器会销毁)。</p><blockquote><p>performSelector关于内存管理的执行原理是这样的执行 [self performSelector:@selector(method1:) withObject:self afterDelay:3]; 的时候，系统会将self的引用计数加1，执行完这个方法时，还会将self的引用计数减1，当方法还没有执行的时候，要返回父视图释放当前视图的时候，self的计数没有减少到0，而导致无法调用dealloc方法，出现了内存泄露。 </p></blockquote><p><img src="https://image.chenyalun.com/2018/09/30/001.png" style="zoom:60%"></p><p>比较好的做法是及时取消掉之前的延迟调用:<code>cancelPreviousPerformRequestsWithTarget: selector:object:</code>，那么<code>cancelPreviousPerformRequestsWithTarget: selector:object:</code>做了什么呢?</p><p><span id="jump1"></span></p><h3 id="cancelPreviousPerformRequestsWithTarget-selector-object"><a href="#cancelPreviousPerformRequestsWithTarget-selector-object" class="headerlink" title="cancelPreviousPerformRequestsWithTarget: selector:object:"></a>cancelPreviousPerformRequestsWithTarget: selector:object:</h3><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">NSObject</span> cancelPreviousPerformRequestsWithTarget:self]<span class="comment">;</span></span><br><span class="line">[<span class="name">NSObject</span> cancelPreviousPerformRequestsWithTarget:self selector:NSSelectorFromString(<span class="name">@</span><span class="string">"printString:"</span>) object:@<span class="string">"str"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这两个方法可以取消perform延迟调用，它们内部做了什么？</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)targe</span><br><span class="line">                                       selector:(SEL)aSelector</span><br><span class="line">                                         object:(id)arg &#123;</span><br><span class="line">    NSMutableArray *perf = [[NSRunLoop currentRunLoop] _timedPerformers];</span><br><span class="line">    unsigned <span class="built_in">count</span> = [perf <span class="built_in">count</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        GSTimedPerformer *array[<span class="built_in">count</span>];</span><br><span class="line">        IF_NO_GC(RETAIN(<span class="keyword">target</span>));</span><br><span class="line">        IF_NO_GC(RETAIN(arg));</span><br><span class="line">        [perf getObjects: array];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">count</span>-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            // 遍历查找</span><br><span class="line">            GSTimedPerformer *p = array[<span class="built_in">count</span>];</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;<span class="keyword">target</span> == <span class="keyword">target</span> &amp;&amp; sel_isEqual(p-&gt;selector, aSelector)</span><br><span class="line">                &amp;&amp; (p-&gt;argument == arg || [p-&gt;argument isEqual:arg])) &#123;</span><br><span class="line">                // <span class="keyword">target</span>\sel\argument均一致</span><br><span class="line">                [p invalidate];</span><br><span class="line">                [perf removeObjectAtIndex: <span class="built_in">count</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(arg);</span><br><span class="line">        RELEASE(<span class="keyword">target</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取Runloop内部持有的<code>_timedPerformers</code>数组(数组中的是<code>GSTimedPerformer</code>对象)。</li><li>创建一个C语言数组，并把<code>_timedPerformers</code>数组中的内容copy到这个C语言数组array。</li><li>遍历该C语言数组array：如果给定参数中的<code>target</code>、<code>argument</code>、<code>selector</code>均<strong>一一对应</strong>，那么销毁<code>GSTimedPerformer</code>对象中的定时器，并根据当前的索引移除<code>_timedPerformers</code>数组的<code>GSTimedPerformer</code>对象。</li></ol><p>换句话说，如果<code>target</code>、<code>argument</code>、<code>selector</code>中有一个参数没有对应，那么便不会执行销毁定时器操作和移除操作。那么，判定<code>target</code>、<code>argument</code>、<code>selector</code>均一一对应的标准是：Matching of the argument may be either by pointer equality or by use of the [NSObject -isEqual:] method.就是指针比较以及<code>isEqual</code>方法。</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(p-&gt;</span>target == target </span><br><span class="line">&amp;&amp; <span class="function"><span class="title">sel_isEqual</span>(p-&gt;</span>selector, aSelector)</span><br><span class="line">&amp;&amp; (<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">argument</span> == arg || [p-&gt;</span>argument isEqual:arg])) </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>其实这里的<code>sel_isEqual</code>就等价于<code>==</code>，多说一句，<code>SEL</code>实际上就是根据方法名hash化了的一个字符串（<code>char *</code>），对于字符串的比较只要比较地址就可以了。</p><p>同理，<code>+ (void)cancelPreviousPerformRequestsWithTarget:(id)target</code>方法实现原理与上面的方法类似，只是不用比较<code>argument</code>和<code>selector</code>参数，把<code>target</code>有关的所有定时器都销毁，并把所有与之相关的<code>GSTimedPerformer</code>对象都从<code>_timedPerformers</code>数组中移除。<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">count</span>-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   GSTimedPerformer *p = array[<span class="built_in">count</span>];</span><br><span class="line">   <span class="keyword">if</span> (p-&gt;<span class="keyword">target</span> == <span class="keyword">target</span>) &#123;</span><br><span class="line">       [p invalidate];</span><br><span class="line">       [perf removeObjectAtIndex:<span class="built_in">count</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当手动销毁定时器并把<code>GSTimedPerformer</code>从Runloop中移除时，定时器对<code>target</code>的强引用不存在；<code>GSTimedPerformer</code>销毁，<code>GSTimedPerformer</code>对<code>target</code>的强引用也不存在，这样，内存泄露问题解决了。这也是为什么使用<code>cancelPreviousPerformRequestsWithTarget</code>取消还没有执行的perform就可以解决<code>target</code>无法释放掉的原因。</p><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p><span id="jump2"></span></p><h3 id="performSelector-target-argument-order-modes"><a href="#performSelector-target-argument-order-modes" class="headerlink" title="performSelector:target:argument:order:modes:"></a>performSelector:target:argument:order:modes:</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector target:(<span class="keyword">id</span>)target argument:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg order:(<span class="built_in">NSUInteger</span>)order modes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line">- (<span class="keyword">void</span>)cancelPerformSelector:(SEL)aSelector target:(<span class="keyword">id</span>)target argument:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg;</span><br><span class="line">- (<span class="keyword">void</span>)cancelPerformSelectorsWithTarget:(<span class="keyword">id</span>)target;</span><br></pre></td></tr></table></figure><p>这里主要看<code>performSelector:target:argument:order:modes:</code>是如何实现的。</p><p>Sets up sending of aSelector to target with argument. The selector is sent before the next runloop iteration (unless cancelled before then) in any of the specified modes.The target and argument objects are retained.<br>The order value is used to determine the order in which messages are sent if multiple messages have been set up. Messages with a lower order value are sent first.If the modes array is empty, this method has no effect.<br>说的很明白了，就是在指定模式的Runloop下一次迭代之前把selector、argument等信息丢给target，以便调用。这里的<code>order</code>指定了这个调用的优先级，值越小，越早被调用。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector</span><br><span class="line">                 target:(<span class="keyword">id</span>)target</span><br><span class="line">               argument:(<span class="keyword">id</span>)argument</span><br><span class="line">                  order:(<span class="built_in">NSUInteger</span>)order</span><br><span class="line">                  modes:(<span class="built_in">NSArray</span> *)modes &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> count = [modes count];</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *array[count];</span><br><span class="line">        GSRunLoopPerformer *item;</span><br><span class="line">        item = [[GSRunLoopPerformer alloc] initWithSelector:aSelector</span><br><span class="line">                                                     target:target</span><br><span class="line">                                                   argument:argument</span><br><span class="line">                                                      order:order];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把modes中的内容copy到array</span></span><br><span class="line">        <span class="keyword">if</span> ([modes isProxy]) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                array[i] = [modes objectAtIndex:i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [modes getObjects:array];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有mode</span></span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *mode = array[count];</span><br><span class="line">            <span class="keyword">unsigned</span> end;</span><br><span class="line">            <span class="keyword">unsigned</span> i;</span><br><span class="line">            GSRunLoopCtxt *context;</span><br><span class="line">            GSIArray performers;</span><br><span class="line">            </span><br><span class="line">            context = <span class="built_in">NSMapGet</span>(_contextMap, mode);</span><br><span class="line">            <span class="keyword">if</span> (context == <span class="literal">nil</span>) &#123;</span><br><span class="line">                context = [[GSRunLoopCtxt alloc] initWithMode:mode extra:_extra];</span><br><span class="line">                <span class="built_in">NSMapInsert</span>(_contextMap, context-&gt;mode, context);</span><br><span class="line">                RELEASE(context);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取Runloop某个mode下对应的context中的performers</span></span><br><span class="line">            performers = context-&gt;performers;</span><br><span class="line">            <span class="comment">// performers的数量</span></span><br><span class="line">            end = GSIArrayCount(performers);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; end; i++) &#123;</span><br><span class="line">                <span class="comment">// 遍历整个performers数组</span></span><br><span class="line">                GSRunLoopPerformer *p;</span><br><span class="line">                p = GSIArrayItemAtIndex(performers, i).obj;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;order &gt; order) &#123;</span><br><span class="line">                    <span class="comment">// 新添加进来的item的优先级高于当前索引i对应item的优先级, 插入</span></span><br><span class="line">                    GSIArrayInsertItem(performers, (GSIArrayItem)((<span class="keyword">id</span>)item), i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一种可能: i和end都为0, performers数组为空, 上面的for循环没有执行</span></span><br><span class="line">            <span class="comment">// 第二种可能: 新添加进来的item的优先级最低, 上面的for循环没有执行, 把它添加到数组的最后位置</span></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                GSIArrayInsertItem(performers, (GSIArrayItem)((<span class="keyword">id</span>)item), i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            i = GSIArrayCount(performers);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span> &amp;&amp; i &gt; context-&gt;maxPerformers) &#123;</span><br><span class="line">                <span class="comment">// 更新context中的performer最大数量</span></span><br><span class="line">                context-&gt;maxPerformers = i;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"WARNING ... there are %u performers scheduled"</span></span><br><span class="line">                      <span class="string">@" in mode %@ of %@\n(Latest: [%@ %@])"</span>,</span><br><span class="line">                      i, mode, <span class="keyword">self</span>, <span class="built_in">NSStringFromClass</span>([target <span class="keyword">class</span>]),</span><br><span class="line">                      <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据方法实现来看，这个方法做了这些事:</p><ol><li>如果数组modes中没有内容就直接return。</li><li>把<code>target</code>、<code>argument</code>、<code>selector</code>、<code>order</code>等信息包装成一个<code>GSRunLoopPerformer</code>对象。</li><li>创建一个字符串数组array，把modes中的内容copy到array。</li><li>遍历array。找到每一种mode(<code>NSString</code>类型)在<code>_contextMap</code>(<code>NSMapTable</code>类型)表中对应的context(<code>GSRunLoopCtxt</code>类型)，获得context中需要执行的performers(<code>GSIArray</code>类型)数组。</li><li>遍历原来的performers数组，根据第2步中包装好的<code>GSRunLoopPerformer</code>对象的优先级order，插入到performers中的合适位置。</li></ol><p>总而言之，就是把<code>target</code>、<code>argument</code>、<code>selector</code>、<code>order</code>等信息包装成一个<code>GSRunLoopPerformer</code>对象，并把该对象添加到Runloop（中的<code>_contextMap</code>）里面的performers，供其在合适的时机调用。具体啥时候调用呢？官方文档说是Runloop的下一次迭代的时候。</p><p>自不必说，<code>cancelPerformSelector:target:argument:</code>就是根据<code>selector</code>、<code>target</code>和<code>argument</code>移除performers数组中的<code>GSRunLoopPerformer</code>。要求三者完全对应。<br><code>cancelPerformSelector:target:</code>是根据<code>selector</code>、<code>target</code>移除performers数组中相关的所有的<code>GSRunLoopPerformer</code>对象。原理与上文中所说的<a href="#jump1">cancelPreviousPerformRequestsWithTarget:</a>基本一致。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="performSelector-onThread-withObject-waitUntilDone-modes"><a href="#performSelector-onThread-withObject-waitUntilDone-modes" class="headerlink" title="performSelector:onThread:withObject:waitUntilDone:modes:"></a>performSelector:onThread:withObject:waitUntilDone:modes:</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line"><span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line"><span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg;</span><br></pre></td></tr></table></figure><p>第二个方法与第一个方法对应，其modes是<code>kCFRunLoopCommonModes</code>，selector在主线程执行。<br>第四个方法与第三个方法对应，其modes是<code>kCFRunLoopCommonModes</code>，selector在指定的子线程执行。<br>第五个方法省略很多参数，selector在内置的子线程执行。</p><p>先分析第四个方法即可。具体的实现如下所示:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector</span><br><span class="line">               onThread:(<span class="built_in">NSThread</span> *)aThread</span><br><span class="line">             withObject:(<span class="keyword">id</span>)anObject</span><br><span class="line">          waitUntilDone:(<span class="built_in">BOOL</span>)aFlag</span><br><span class="line">                  modes:(<span class="built_in">NSArray</span>*)anArray &#123;</span><br><span class="line">    GSRunLoopThreadInfo  *info;</span><br><span class="line">    <span class="built_in">NSThread</span> *t;</span><br><span class="line">    <span class="keyword">if</span> ([anArray count] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    t = GSCurrentThread();</span><br><span class="line">    <span class="keyword">if</span> (aThread == <span class="literal">nil</span>) aThread = t;</span><br><span class="line">    info = GSRunLoopInfoForThread(aThread);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t == aThread) &#123;</span><br><span class="line">        <span class="comment">// Perform in current thread.</span></span><br><span class="line">        <span class="keyword">if</span> (aFlag == <span class="literal">YES</span> || info-&gt;loop == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">// Wait until done or no run loop.</span></span><br><span class="line">            [<span class="keyword">self</span> performSelector:aSelector withObject:anObject];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Don't wait ... schedule operation in run loop.</span></span><br><span class="line">            [info-&gt;loop performSelector:aSelector</span><br><span class="line">                                 target:<span class="keyword">self</span></span><br><span class="line">                               argument:anObject</span><br><span class="line">                                  order:<span class="number">0</span></span><br><span class="line">                                  modes:anArray];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GSPerformHolder *h;</span><br><span class="line">        <span class="built_in">NSConditionLock</span> *l = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 线程Finished判断</span></span><br><span class="line">        <span class="keyword">if</span> ([aThread isFinished] == <span class="literal">YES</span>) &#123;</span><br><span class="line">            [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                        format: <span class="string">@"perform on finished thread"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 阻塞等待加锁</span></span><br><span class="line">        <span class="keyword">if</span> (aFlag == <span class="literal">YES</span>) &#123;</span><br><span class="line">            l = [[<span class="built_in">NSConditionLock</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        h = [GSPerformHolder newForReceiver:<span class="keyword">self</span></span><br><span class="line">                                   argument:anObject</span><br><span class="line">                                   selector:aSelector</span><br><span class="line">                                      modes:anArray</span><br><span class="line">                                       lock:l];</span><br><span class="line">        [info addPerformer:h];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 条件锁创建成功(也即参数aFlag为YES)</span></span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">nil</span>) &#123;</span><br><span class="line">            [l lockWhenCondition:<span class="number">1</span>]; <span class="comment">// 当条件为1时加锁</span></span><br><span class="line">            [l unlock];</span><br><span class="line">            RELEASE(l);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// holder已经失效则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> ([h isInvalidated] == <span class="literal">YES</span>) &#123;</span><br><span class="line">                RELEASE(h);</span><br><span class="line">                [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                            format: <span class="string">@"perform on finished thread"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// holder自身就产生exception了, 那么再次抛出异常</span></span><br><span class="line">            <span class="comment">// If we have an exception passed back from the remote thread, re-raise it.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nil</span> != h-&gt;exception) &#123;</span><br><span class="line">                <span class="built_in">NSException</span> *e = AUTORELEASE(RETAIN(h-&gt;exception));</span><br><span class="line">                RELEASE(h);</span><br><span class="line">                [e raise];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要做了这些什么?</p><ol><li>首先对传进来的<code>modes</code>(Runloop模式数组)个数进行判断，如果为0，则直接return。</li><li>获取该方法执行上下文中的线程： <code>t</code>，并把它与作为参数传进来的线程<code>aThread</code>进行比较，看是否一致。当然，如果传进来的<code>aThread</code>为空，那么执行<code>aThread = t;</code>，就让<code>selector</code>在当前上下文中的线程中执行。</li><li>当两个线程一致时，如果参数<code>aFlag</code>为YES或者线程对应的Runloop为空，说明需要等待，也即这个方法应该等到selector被执行完毕后再return。这就好办了，直接调用<code>[self performSelector: aSelector withObject: anObject];</code>方法，同步执行即可。如果不需要等待呢? 把<code>selector</code>、<code>argument</code>、<code>modes</code>等信息交给线程对应的Runloop再进一步处理（schedule operation in run loop）。</li><li>当两个线程不一致时，首先判断<code>aThread</code>有没有<code>finished</code>，线程死了自然<code>selector</code>无法执行，抛出异常。再者判断是否需要阻塞等待，如果需要的话就创建一个条件锁。接着把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个<code>GSPerformHolder</code>对象，并把它交给封装线程信息的<code>GSRunLoopThreadInfo</code>对象。之后是一些收尾工作：设置条件锁的condition及一些异常判断。</li></ol><p>需要着重说明的是参数<code>aFlag</code>： 是否立即返回。如果参数<code>aFlag</code>为YES，则这个方法应该等到<code>selector</code>被执行完毕后再return。如果<code>selector</code>是在当前方法上下文的线程中执行，且该线程对应的Runloop没有run，那么会忽略<code>modes</code>，直接执行：<code>performSelector:aSelector withObject:</code>。</p><p>当两个线程一致时，也即<code>selector</code>执行的线程就是当前方法上下文中的线程，这比较好处理，把<code>selector</code>、<code>argument</code>、<code>modes</code>等信息交给线程对应的Runloop即可，就是模式中的方法：<a href="#jump2">performSelector:target:argument:order:modes:</a>。</p><p><strong>GSPerformHolder</strong></p><p>两个线程不一致时，“把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个<code>GSPerformHolder</code>对象，并把它交给封装线程信息的<code>GSRunLoopThreadInfo</code>对象”又是怎么做的呢?</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(GSPerformHolder</span> <span class="string">*)h</span> <span class="string">=</span> <span class="string">[GSPerformHolder</span> <span class="attr">newForReceiver:self</span></span><br><span class="line"><span class="attr">                                             argument:</span><span class="string">anObject</span></span><br><span class="line"><span class="attr">                                             selector:</span><span class="string">aSelector</span></span><br><span class="line"><span class="attr">                                                modes:</span><span class="string">anArray</span></span><br><span class="line"><span class="attr">                                                 lock:</span><span class="string">l];</span></span><br><span class="line"><span class="string">[(GSRunLoopThreadInfo</span> <span class="string">*)info</span> <span class="attr">addPerformer:h];</span></span><br></pre></td></tr></table></figure><p><code>newForReceiver:argument:selector:modes:lock:</code> 这个方法就是做一些信息封装，无需多言。主要是这个<code>addPerformer</code>，删除<code>#if defined(_WIN32)</code>的代码后具体实现如下:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addPerformer:(<span class="keyword">id</span>)performer &#123;</span><br><span class="line">    <span class="built_in">BOOL</span>  signalled = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">// NSLock加锁</span></span><br><span class="line">    [lock lock];</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> start = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 使用write函数向 outputFd 中写入 1 字节数据，数据为: "0"。</span></span><br><span class="line">    <span class="keyword">while</span> (outputFd &gt;= <span class="number">0</span> &amp;&amp; <span class="literal">NO</span> == (signalled = (write(outputFd, <span class="string">"0"</span>, <span class="number">1</span>) == <span class="number">1</span>) ? <span class="literal">YES</span> : <span class="literal">NO</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSTimeInterval</span>    now = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0.0</span> == start) &#123;</span><br><span class="line">            start = now;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now - start &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Unable to signal %@ within a second; blocked?"</span>, <span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock];</span><br><span class="line">        [lock lock];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据成功，把performer添加到GSRunLoopThreadInfo数组中</span></span><br><span class="line">    <span class="keyword">if</span> (signalled) [performers addObject: performer];</span><br><span class="line">    <span class="comment">// NSLock解锁</span></span><br><span class="line">    [lock unlock];</span><br><span class="line">    <span class="comment">// 写入数据失败，销毁performer</span></span><br><span class="line">    <span class="keyword">if</span> (!signalled) [performer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充write函数知识点:</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * <span class="built_in">write</span>函数</span><br><span class="line"> * ssize_t  <span class="built_in">write</span>(int __fd, const void * __buf, size_t __nbyte) __DARWIN_ALIAS_C(<span class="built_in">write</span>);</span><br><span class="line"> * <span class="built_in">write</span> 函数向 __fd 中写入 __nbyte 字节数据，数据来源为 __buf 。返回值一般总是等于 __nbyte</span><br><span class="line"> * 返回值如果不是等于__nbyte，就是出错了。常见的出错原因是磁盘空间满了或者超过了文件大小限制。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* The <span class="built_in">write</span> could concievably fail <span class="keyword">if</span> <span class="keyword">the</span> pipe <span class="keyword">is</span> full.</span><br><span class="line"> * In <span class="keyword">that</span> case we need <span class="keyword">to</span> release <span class="keyword">the</span> lock temporarily <span class="keyword">to</span> allow <span class="keyword">the</span> other</span><br><span class="line"> * thread <span class="keyword">to</span> consume data <span class="keyword">from</span> <span class="keyword">the</span> pipe.  It's possible <span class="keyword">that</span> <span class="keyword">the</span> thread</span><br><span class="line"> * <span class="keyword">and</span> <span class="keyword">its</span> runloop might stop during <span class="keyword">that</span> ... so we need <span class="keyword">to</span> check <span class="keyword">that</span></span><br><span class="line"> * outputFd <span class="keyword">is</span> still valid.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>不是十分理解write函数在这里的作用，根据一些异常信息<code>&quot;Failed to set non block flag for perform in thread&quot; &quot;Failed to create event to handle perform in thread&quot;</code>，可能是向文件中写入一些flag表示线程指定事件对象的信号状态吧。</p><p>如果信号状态设置成功，就把这个perform对象(<code>GSPerformHolder</code>类型)添加到<code>GSRunLoopThreadInfo</code>的performers数组中。</p><p>这个<code>GSRunLoopThreadInfo</code>对象把<code>GSPerformHolder</code>对象添加到自己数组中后，具体最原先的perform什么时候执行呢? <strong>是在调用<code>GSRunLoopThreadInfo</code>对象的<code>fire</code>方法时逐个执行</strong>：</p><p>GSRunLoopThreadInfo对象的<code>fire</code>方法部分实现:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">for</span> <span class="string">(i</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span> <span class="string">i</span> <span class="string">&lt;</span> <span class="string">c;</span> <span class="string">i++)</span> <span class="string">&#123;</span></span><br><span class="line">   <span class="string">GSPerformHolder</span> <span class="meta">*h</span> <span class="string">=</span> <span class="string">[toDo</span> <span class="attr">objectAtIndex:i];</span></span><br><span class="line">   </span><br><span class="line">   <span class="string">[loop</span> <span class="attr">performSelector:@selector(fire)</span></span><br><span class="line"><span class="attr">                  target:</span><span class="string">h</span></span><br><span class="line"><span class="attr">                argument:</span><span class="string">nil</span></span><br><span class="line"><span class="attr">                   order:</span><span class="number">0</span></span><br><span class="line"><span class="attr">                   modes:</span><span class="string">[h</span> <span class="string">modes]];</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>可见是逐个取出数组中的<code>GSPerformHolder</code>对象，一个接一个地调用<code>GSPerformHolder</code>的<code>fire</code>方法，这也是个<code>fire</code>方法，它内部做了什么？就是<code>[receiver performSelector: selector withObject: argument];</code>。</p><p>捋一捋: 两个线程不一致时，把<code>selector</code>、<code>argument</code>、<code>modes</code>及条件锁等信息封装成一个<code>GSPerformHolder</code>对象，并把它添加到<code>GSRunLoopThreadInfo</code>对象的performers数组中。当调用<code>GSRunLoopThreadInfo</code>对象的<code>fair</code>方法时会遍历performers数组，然后逐个调用数组中每一个元素的<code>fair</code>方法，而这个<code>fair</code>方法内部就是调用<code>performSelector:withObject</code>方法。</p><p>最最关键的一个问题: 什么时候调用<code>GSRunLoopThreadInfo</code>对象的<code>fair</code>方法? 官方文档说:<strong> May only be called from the runloop when the event/descriptor is triggered.</strong></p><p>我在Runloop的<code>+(BOOL)awakenedBefore:</code>和 <code>-(BOOL)pollUntil:within:</code>方法中找到了调用痕迹。</p><h3 id="任意线程调用"><a href="#任意线程调用" class="headerlink" title="任意线程调用"></a>任意线程调用</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">- (void)performSelector:(SEL)aSelector</span><br><span class="line"><span class="symbol">               onThread:</span>(NSThread*)aThread</span><br><span class="line"><span class="symbol">             withObject:</span>(id)anObject</span><br><span class="line"><span class="symbol">          waitUntilDone:</span>(BOOL)<span class="class">aFlag </span>&#123;</span><br><span class="line">    [self performSelector:aSelector</span><br><span class="line"><span class="symbol">                 onThread:</span>aThread</span><br><span class="line"><span class="symbol">               withObject:</span>anObject</span><br><span class="line"><span class="symbol">            waitUntilDone:</span>aFlag</span><br><span class="line"><span class="symbol">                    modes:</span>commonModes()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runloop的五种mode分别是:<code>NSDefaultRunLoopMode，NSConnectionReplyMode，NSModalPanelRunLoopMode，NSEventTrackingRunLoopMode，NSRunLoopCommonModes</code>。<br><strong>这个方法省略了modes参数，内部使用common mode</strong>，也即<code>NSDefaultRunLoopMode</code>和<code>NSConnectionReplyMode</code>(不是<code>NSEventTrackingRunLoopMode</code>)。所以如果有鼠标或者手势事件需要处理，省略modes参数可能不是个好做法。</p><h3 id="主线程调用"><a href="#主线程调用" class="headerlink" title="主线程调用"></a>主线程调用</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector</span><br><span class="line"><span class="symbol">                         withObject:</span>(id)anObject</span><br><span class="line"><span class="symbol">                      waitUntilDone:</span>(BOOL)aFlag</span><br><span class="line"><span class="symbol">                              modes:</span>(NSArray*)<span class="class">anArray </span>&#123;</span><br><span class="line">    if (defaultThread == nil) defaultThread = [NSThread mainThread];</span><br><span class="line">    [self performSelector:aSelector</span><br><span class="line"><span class="symbol">                 onThread:</span>defaultThread</span><br><span class="line"><span class="symbol">               withObject:</span>anObject</span><br><span class="line"><span class="symbol">            waitUntilDone:</span>aFlag</span><br><span class="line"><span class="symbol">                    modes:</span>anArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个方法指定了主线程。</strong></p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector</span><br><span class="line"><span class="symbol">                         withObject:</span>(id)anObject</span><br><span class="line"><span class="symbol">                      waitUntilDone:</span>(BOOL)<span class="class">aFlag </span>&#123;</span><br><span class="line">    [self performSelectorOnMainThread:aSelector</span><br><span class="line"><span class="symbol">                           withObject:</span>anObject</span><br><span class="line"><span class="symbol">                        waitUntilDone:</span>aFlag</span><br><span class="line"><span class="symbol">                                modes:</span>commonModes()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这两个方法指定了主线程，内部使用common mode。</strong></p><h3 id="Background调用"><a href="#Background调用" class="headerlink" title="Background调用"></a>Background调用</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">- (void)performSelectorInBackground:(SEL)aSelector</span><br><span class="line"><span class="symbol">                         withObject:</span>(id)<span class="class">anObject </span>&#123;</span><br><span class="line">    [NSThread detachNewThreadSelector:aSelector</span><br><span class="line"><span class="symbol">                             toTarget:</span>self</span><br><span class="line"><span class="symbol">                           withObject:</span>anObject];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个方法会创建一条任意的线程执行<code>selector</code>方法。</strong></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="printInfo方法会执行吗"><a href="#printInfo方法会执行吗" class="headerlink" title="printInfo方法会执行吗"></a>printInfo方法会执行吗</h3><h4 id="GCD调用"><a href="#GCD调用" class="headerlink" title="GCD调用"></a>GCD调用</h4><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [self performSelector:@selector(<span class="name">printInfo</span>) withObject<span class="symbol">:nil</span> afterDelay:<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>很明显是不会的。因为<code>performSelector</code>具体实现中并没有主动触发线程对应Runloop运行。子线程对应的Runloop没有run。怎么让它执行？启动Runloop:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [self performSelector:@selector(<span class="name">printInfo</span>) withObject<span class="symbol">:nil</span> afterDelay:<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    [[NSRunLoop currentRunLoop] run]<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="NSThread调用"><a href="#NSThread调用" class="headerlink" title="NSThread调用"></a>NSThread调用</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] <span class="string">initWithBlock:</span>^&#123;</span><br><span class="line">   [self <span class="string">performSelector:</span><span class="meta">@selector</span>(printInfo) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">1</span>];</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure><p>同理:</p><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">NSThread *thread = <span class="comment">[<span class="comment">[NSThread alloc]</span> initWithBlock:^&#123;</span></span><br><span class="line"><span class="comment">   <span class="comment">[self performSelector:@selector(printInfo) withObject:nil afterDelay:1]</span>;</span></span><br><span class="line"><span class="comment">   <span class="comment">[<span class="comment">[NSRunLoop currentRunLoop]</span> run]</span>;</span></span><br><span class="line"><span class="comment">&#125;]</span>;</span><br><span class="line"><span class="comment">[thread start]</span>;</span><br></pre></td></tr></table></figure><p>这就有一个问题了。在GCD中<code>[[NSRunLoop currentRunLoop] run];</code>放在<code>performSelector</code>前面或者后面貌似都是可以的，但是在NSThread中<code>[[NSRunLoop currentRunLoop] run];</code>只能放在<code>performSelector</code>的后面。</p><p>在NSThread方法中:</p><blockquote><p>因为run方法只是尝试想要开启当前线程中的runloop，但是如果该线程中并没有任何事件(source、timer、observer)的话，并不会成功的开启。</p></blockquote><p>为什么GCD中即使<code>[[NSRunLoop currentRunLoop] run];</code>放在前面<code>printInfo</code>方法还是调用了呢? 代码实际测试，延迟效果没有了，并且有时方法执行，有时方法没有执行。</p><p>综上，<strong>在子线程中使用performSelector的延迟方法，需要加上<code>[[NSRunLoop currentRunLoop] run];</code>使得Runloop能够运行，并且该方法要放在<code>performSelector</code>的后面来保证Runloop成功运行。</strong></p><h4 id="NSThread无效"><a href="#NSThread无效" class="headerlink" title="NSThread无效"></a>NSThread无效</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] <span class="string">initWithBlock:</span>^&#123;&#125;];</span><br><span class="line">[thread start];</span><br><span class="line">[self <span class="string">performSelector:</span><span class="meta">@selector</span>(printMainInfo) <span class="string">onThread:</span>thread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br></pre></td></tr></table></figure><p>上面这段代码为什么没有执行printMainInfo方法?</p><p>子线程执行完操作之后就会立即释放，即使我们使用强引用引用子线程使子线程不被释放，也不能给子线程再次添加操作，或者再次开启。这里可以使用Runloop。子线程获取其对应的Runloop对象并使之运行。一般使用常驻子线程。</p><p>正确实践：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">   <span class="comment">// 执行一次而已</span></span><br><span class="line">   <span class="built_in">NSRunLoop</span> *currentRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">   [currentRunLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(printMainInfo) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>梳理本文，比较重要的几个小点如下：</p><ol><li><code>performSelector</code>内部的实现就是使用<code>IMP</code>直接调用对象的方法。</li><li>严格遵守ARC规则，注意方法的命名，不然会为内存泄漏埋下伏笔。</li><li>反射<code>NSSelectorFromString()</code>很强大，但是使用<code>@selector()</code>显式告诉编译器将要调用的方法是更优的选择。</li><li><code>performSelector</code>能实现延迟是因为定时器，要及时取消无法执行的延迟方法。</li><li>子线程中使用延迟方法，需要主动使Runloop能够运行。</li><li>NSTimer在其<code>invalidate</code>方法调用后，Runloop会自动移除对它的引用。</li></ol><p>具体在业务上，可以举几个简单的场景。</p><p>对于文件或者模型的下载，有时候需要用到进度条提示。这时候可以在子线程下载，跑到主线程更新UI：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[self <span class="string">performSelectorOnMainThread:</span><span class="meta">@selector</span>(updateProgress) <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br></pre></td></tr></table></figure></p><p>有些时候需要进行简单的Tip提示，3秒后自动让它自动隐藏：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[self.tipView <span class="string">performSelector:</span><span class="meta">@selector</span>(dismiss) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">3.</span>f];</span><br></pre></td></tr></table></figure></p><p>当使用多态的时候，动态调用方法创建实例对象：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Class cls = Nil;</span><br><span class="line"><span class="keyword">if</span> (item.isForChinese) &#123;</span><br><span class="line">    cls = NSClassFromString(@<span class="string">"YAChinesePopView"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cls = NSClassFromString(@<span class="string">"YAEnglishPopView"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> [cls <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">popViewWithItem:</span>) <span class="string">withObject:</span>item];</span><br></pre></td></tr></table></figure></p><p>偶然间发现一个好玩的例子：直接调用某个对象的某个方法，而不导入其头文件。比如手百自定义一个继承自WKWebView的子类，并把这个实例暴露出来，我们想让它执行某段JavaScript，但是又不想导入繁重的头文件：</p><pre><code>if ([obj respondsToSelector:@selector(evaluateJavaScript:completionHandler:)]) {    [obj performSelector:@selector(evaluateJavaScript:completionHandler:) withObject:js withObject:nil];} </code></pre><p>上面的只是冰山一角，其合理性需要结合具体的业务场景具体分析，只是想阐明，performSelector在一些情况下是很有用的。</p><hr><blockquote><p>参考资料<br><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html" target="_blank" rel="noopener">Advanced Memory Management Programming Guide</a><br><a href="https://zhongwuzw.github.io/2017/01/19/Objective-C之performSelector编译器内存泄露警告/" target="_blank" rel="noopener">Objective-C之performSelector编译器内存泄露警告</a><br><a href="https://blog.csdn.net/dean19900504/article/details/8067679" target="_blank" rel="noopener">用performSelector的时候要注意别内存泄露了</a><br><a href="https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown" target="_blank" rel="noopener">PerformSelector May Cause a Leak</a><br><a href="https://blog.csdn.net/wei371522/article/details/81216853" target="_blank" rel="noopener">performSelector 注意问题及原理</a><br><a href="https://blog.csdn.net/king16304/article/details/52192259" target="_blank" rel="noopener">c/c++ read 函数和 write 函数</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; PerformSelector相关知识。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Runtime基础</title>
    <link href="http://blog.chenyalun.com/2018/07/10/Runtime%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.chenyalun.com/2018/07/10/Runtime基础/</id>
    <published>2018-07-10T15:02:17.000Z</published>
    <updated>2019-08-28T11:30:10.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018.8.26 更新Class定义<br>2019.3.25 更新设置weak关联属性</p></blockquote><p></p><p align="center"> 关于Runtime的简单总结。 </p><br><a id="more"></a><p></p><p>简单总结一些比较好玩的用法，但是后来我才发现，南峰子大神的<a href="http://southpeak.github.io/2014/10/25/objective-c-runtime-1/" target="_blank" rel="noopener">Runtime系列</a>总结的很详细很完整了。文章舍不得删，就当抛砖引玉吧。</p><h2 id="一、Runtime"><a href="#一、Runtime" class="headerlink" title="一、Runtime"></a>一、Runtime</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Objective-C2<span class="number">.0</span>之前Class的定义</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">    <span class="comment">// 父类</span></span><br><span class="line">    Class super_class;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">long</span> version;</span><br><span class="line">    <span class="keyword">long</span> info;</span><br><span class="line">    <span class="keyword">long</span> instance_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>;</span></span><br><span class="line">    <span class="comment">// 方法缓存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied;</span><br><span class="line">    Method buckets[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">根据源码，最新定义大致如下:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;<span class="comment">// 方法缓存</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits; <span class="comment">// 用于获取具体的类信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实例演练</p><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">YAPerson *person = [[YAPerson alloc] init];</span><br><span class="line">Class cls = [person <span class="keyword">class</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取实例对象对应的Class</span></span><br><span class="line">Class <span class="keyword">class</span><span class="number">1</span> = <span class="keyword">object</span><span class="number">_</span>getClass(person);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取指定名称的类对象</span></span><br><span class="line">Class <span class="keyword">class</span><span class="number">3</span> = objc<span class="number">_</span>getClass(<span class="string">"YAPerson"</span>);</span><br><span class="line">Class <span class="keyword">class</span><span class="number">2</span> = objc<span class="number">_</span>getRequiredClass(<span class="string">"YAPerson"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取指定名称的元类对象</span></span><br><span class="line">Class <span class="keyword">class</span><span class="number">4</span> = objc<span class="number">_</span>getMetaClass(<span class="string">"YAPerson"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 找到指定名称的类对象</span></span><br><span class="line">Class <span class="keyword">class</span><span class="number">5</span> = objc<span class="number">_</span>lookUpClass(<span class="string">"NSObject"</span>);</span><br><span class="line">NSLog(@<span class="string">"%@%@%@%@%@"</span>,<span class="keyword">class</span><span class="number">1</span>,<span class="keyword">class</span><span class="number">2</span>,<span class="keyword">class</span><span class="number">3</span>,<span class="keyword">class</span><span class="number">4</span>,<span class="keyword">class</span><span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置对象对应的Class,返回原先的class</span></span><br><span class="line">Class oriClass = <span class="keyword">object</span><span class="number">_</span>setClass(person, [NSObject <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是类对象或元类对象</span></span><br><span class="line">BOOL isClass = <span class="keyword">object</span><span class="number">_</span>isClass(person);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 是否是元类对象</span></span><br><span class="line">BOOL isMetaClass = <span class="keyword">class</span><span class="number">_</span>isMetaClass(<span class="keyword">class</span><span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取父类</span></span><br><span class="line">Class superClass = <span class="keyword">class</span><span class="number">_</span>getSuperclass(cls);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取类的版本</span></span><br><span class="line">int version = <span class="keyword">class</span><span class="number">_</span>getVersion(cls);</span><br><span class="line"><span class="comment">// 设置类的版本</span></span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>setVersion(cls, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例大小</span></span><br><span class="line">typedef <span class="number">__</span>SIZE<span class="number">_T</span>YPE<span class="number">__</span> size<span class="number">_</span>t;</span><br><span class="line">    </span><br><span class="line">size<span class="number">_</span>t size = <span class="keyword">class</span><span class="number">_</span>getInstanceSize(cls);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    int objc_getClassList(Class *buffer, int bufferCount)</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    Class *objc_copyClassList(unsigned int *outCount)</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">// 获取类的名称</span></span><br><span class="line">const char *name = <span class="keyword">class</span><span class="number">_</span>getName(cls);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 动态创建类</span></span><br><span class="line"><span class="comment">//Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</span></span><br><span class="line"><span class="comment">//void objc_registerClassPair(Class cls)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 动态废弃类</span></span><br><span class="line"><span class="comment">//Class objc_duplicateClass(Class original, const char *name, size_t extraBytes)</span></span><br><span class="line"><span class="comment">//void objc_disposeClassPair(Class cls)</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//id o = objc_storeWeak(&amp;weakObject, weakObject);</span></span><br><span class="line"><span class="comment">//id result = objc_loadWeak(&amp;weakObject);</span></span><br></pre></td></tr></table></figure><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">给<span class="keyword">block创建一个关联的函数指针</span></span><br><span class="line"><span class="keyword">IMP </span>imp_implementationWithBlock(id <span class="keyword">block)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">获取函数指针关联的block</span></span><br><span class="line"><span class="keyword">id </span>imp_getBlock(IMP anImp)</span><br><span class="line"></span><br><span class="line">移除函数指针对应的<span class="keyword">block</span></span><br><span class="line"><span class="keyword">BOOL </span>imp_removeBlock(IMP anImp)</span><br></pre></td></tr></table></figure><p>实例演练</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^Block) ();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义block</span></span><br><span class="line">Block block = ^() &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"哈哈哈"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 给block创建一个关联的函数指针</span></span><br><span class="line">IMP imp = imp_implementationWithBlock(block);</span><br><span class="line"><span class="comment">// 调用block</span></span><br><span class="line">(*imp)();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取函数指针关联的block</span></span><br><span class="line"><span class="keyword">id</span> blockObject = imp_getBlock(imp);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,blockObject);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 移除函数指针对应的block</span></span><br><span class="line"><span class="built_in">BOOL</span> isRemoveBlock = imp_removeBlock(imp);</span><br><span class="line"><span class="keyword">if</span> (isRemoveBlock) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"成功移除"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">获取<span class="keyword">SEL的名称(char </span>*类型)</span><br><span class="line"><span class="symbol">const</span> char *<span class="keyword">sel_getName(SEL </span><span class="keyword">sel)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">注册SEL</span></span><br><span class="line"><span class="keyword">SEL </span><span class="keyword">sel_registerName(const </span>char *<span class="keyword">str)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">比较SEL</span></span><br><span class="line"><span class="keyword">BOOL </span><span class="keyword">sel_isEqual(SEL </span>lhs, <span class="keyword">SEL </span>rhs)</span><br></pre></td></tr></table></figure><p>实例演练</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取SEL的名称(char *类型)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *selName = sel_getName(<span class="keyword">@selector</span>(viewWillAppear:));</span><br><span class="line">printf(<span class="string">"%s"</span>,selName);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 注册SEL</span></span><br><span class="line">SEL newSel = sel_registerName(<span class="string">"haha"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 比较SEL</span></span><br><span class="line"><span class="built_in">BOOL</span> isEqual = sel_isEqual(<span class="keyword">@selector</span>(viewWillAppear:), newSel);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,isEqual);</span><br></pre></td></tr></table></figure><h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">定义一个objc_ivar结构体指针Ivar</span><br><span class="line"><span class="keyword">typedef</span> struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct objc_ivar &#123;</span><br><span class="line">    成员变量名称</span><br><span class="line">    <span class="keyword">char</span> *ivar_name;</span><br><span class="line">    成员变量类型                                         </span><br><span class="line">    <span class="keyword">char</span> *ivar_type;                                          </span><br><span class="line">    偏移量</span><br><span class="line">    <span class="keyword">int</span> ivar_offset;                                          </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space;                                                </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于偏移量的定义(就是整型)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__PTRDIFF_TYPE__)</span></span><br><span class="line">    <span class="keyword">typedef</span> __PTRDIFF_TYPE____darwin_ptrdiff_t;<span class="comment">/* ptr1 - ptr2 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__LP64__)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span>__darwin_ptrdiff_t;<span class="comment">/* ptr1 - ptr2 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span>__darwin_ptrdiff_t;<span class="comment">/* ptr1 - ptr2 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __GNUC__ */</span></span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _PTRDIFF_T</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PTRDIFF_T</span></span><br><span class="line">    <span class="keyword">typedef</span> __darwin_ptrdiff_t ptrdiff_t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _PTRDIFF_T */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">成员变量列表</span><br><span class="line">struct objc_ivar_list &#123;</span><br><span class="line">    成员变量数量</span><br><span class="line">    <span class="keyword">int</span> ivar_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    struct objc_ivar ivar_list[<span class="number">1</span>];</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">获取实例变量</span><br><span class="line">Ivar class_getInstanceVariable(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取类变量</span></span><br><span class="line"><span class="comment">//Ivar class_getClassVariable(Class cls, const char *name)</span></span><br><span class="line">    </span><br><span class="line">获取成员变量列表</span><br><span class="line">Ivar *class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line">   </span><br><span class="line">获取Ivar变量的名称</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getName(Ivar v)</span><br><span class="line">    </span><br><span class="line">获取Ivar变量的偏移量</span><br><span class="line">ptrdiff_t ivar_getOffset(Ivar v)</span><br><span class="line">    </span><br><span class="line">获取Ivar变量的编码</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getTypeEncoding(Ivar v)</span><br><span class="line">    </span><br><span class="line">设置成员变量的值</span><br><span class="line"><span class="keyword">void</span> object_setIvarWithStrongDefault(id obj, Ivar ivar, id value)</span><br><span class="line"></span><br><span class="line">设置成员变量的值</span><br><span class="line"><span class="keyword">void</span> object_setIvar(id obj, Ivar ivar, id value)</span><br><span class="line"></span><br><span class="line">获取Ivar对应的成员变量对象</span><br><span class="line">id object_getIvar(id obj, Ivar ivar)</span><br><span class="line"></span><br><span class="line">IvarLayout相关</span><br><span class="line"><span class="keyword">const</span> uint8_t *class_getIvarLayout(Class cls)</span><br><span class="line"><span class="keyword">const</span> uint8_t *class_getWeakIvarLayout(Class cls)</span><br><span class="line"><span class="keyword">void</span> class_setIvarLayout(Class cls, <span class="keyword">const</span> uint8_t *layout)</span><br><span class="line"><span class="keyword">void</span> class_setWeakIvarLayout(Class cls, <span class="keyword">const</span> uint8_t *layout)</span><br><span class="line">    </span><br><span class="line">添加成员变量</span><br><span class="line">BOOL class_addIvar(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t <span class="built_in">size</span>,</span><br><span class="line">                  uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br></pre></td></tr></table></figure><p>实例演示</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    YAPerson *person = [[YAPerson alloc] init];</span><br><span class="line">    Class cls = [person <span class="keyword">class</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取实例变量</span></span><br><span class="line">    Ivar ivar_num = class_getInstanceVariable(cls, <span class="string">"num"</span>);</span><br><span class="line">    </span><br><span class="line">    Ivar ivar_name = class_getInstanceVariable(cls, <span class="string">"name"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取类变量</span></span><br><span class="line">    <span class="comment">//Ivar class_getClassVariable(Class cls, const char *name)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Ivar变量的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar_name);</span><br><span class="line">    printf(<span class="string">"%s\n"</span>,name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Ivar变量的偏移量</span></span><br><span class="line">    ptrdiff_t p = ivar_getOffset(ivar_num);</span><br><span class="line">    printf(<span class="string">"%td"</span>,p); <span class="comment">// 打印16</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Ivar变量的编码</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = ivar_getTypeEncoding(ivar_name);</span><br><span class="line">    printf(<span class="string">"%s\n"</span>,typeEncoding); <span class="comment">// 打印 @"NSString"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置成员变量的值</span></span><br><span class="line">    object_setIvarWithStrongDefault(person, ivar_name, <span class="string">@"haha"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person-&gt;name);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置成员变量对应的值</span></span><br><span class="line">    object_setIvar(person, ivar_name, <span class="string">@"hahaaaaaa"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person-&gt;name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Ivar对应的成员变量对象</span></span><br><span class="line">    <span class="keyword">id</span> object = object_getIvar(person, ivar_name);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,object);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态添加成员变量</span></span><br><span class="line">    <span class="comment">// 必须在 objc_allocateClassPair 之后 和 在objc_registerClassPair之前调用</span></span><br><span class="line">    <span class="comment">// 不能给一个已经存在的类添加成员变量</span></span><br><span class="line">    Class peopleClass = objc_allocateClassPair(cls, <span class="string">"YAPeople"</span>, <span class="number">0</span>);</span><br><span class="line">    class_addIvar(peopleClass, <span class="string">"_gayFriend"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">    class_addIvar(peopleClass, <span class="string">"_girlFriend"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">    class_addIvar(peopleClass, <span class="string">"_company"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">    objc_registerClassPair(peopleClass);</span><br><span class="line">    <span class="comment">// 打印成员变量列表</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="keyword">self</span> ya_getIvarList:peopleClass]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IvarLayout相关</span></span><br><span class="line">    <span class="comment">// ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t *ivarLayoutArray= class_getIvarLayout(cls);</span><br><span class="line">    <span class="keyword">const</span> uint8_t *weakIvarLayoutArray = class_getWeakIvarLayout(cls);</span><br><span class="line">    <span class="keyword">if</span> (ivarLayoutArray) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        uint8_t value_s = ivarLayoutArray[i];</span><br><span class="line">        <span class="keyword">while</span> (value_s != <span class="number">0x0</span>) &#123;</span><br><span class="line">            printf(<span class="string">"\\x%02x\n"</span>, value_s);</span><br><span class="line">            value_s = ivarLayoutArray[++i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//void class_setIvarLayout(Class cls, const uint8_t *layout)</span></span><br><span class="line">    <span class="comment">//void class_setWeakIvarLayout(Class cls, const uint8_t *layout)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据class获取成员变量列表<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据class获取成员变量列表</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param class 类</span></span><br><span class="line"><span class="comment"> @return 成员变量字典(名称:类型)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)ya_getIvarList:(Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取成员变量列表</span></span><br><span class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">class</span>, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储成员变量</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取成员变量类型与成员变量名称</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 成员变量类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *c_ivarType = ivar_getTypeEncoding(ivarList[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 成员变量名称</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *c_ivarName = ivar_getName(ivarList[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用字典存储,格式为 成员变量名称:对应的成员变量类型</span></span><br><span class="line">        <span class="built_in">NSString</span> *ivarName = [<span class="built_in">NSString</span> stringWithUTF8String:c_ivarName];</span><br><span class="line">        dict[ivarName] = [<span class="built_in">NSString</span> stringWithUTF8String:c_ivarType];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要手动free</span></span><br><span class="line">    free(ivarList);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:dict];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>值得一提的是方法编码和类型编码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ID       <span class="meta-string">'@'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CLASS    <span class="meta-string">'#'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_SEL      <span class="meta-string">':'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CHR      <span class="meta-string">'c'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UCHR     <span class="meta-string">'C'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_SHT      <span class="meta-string">'s'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_USHT     <span class="meta-string">'S'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_INT      <span class="meta-string">'i'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UINT     <span class="meta-string">'I'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_LNG      <span class="meta-string">'l'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ULNG     <span class="meta-string">'L'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_LNG_LNG  <span class="meta-string">'q'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ULNG_LNG <span class="meta-string">'Q'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_FLT      <span class="meta-string">'f'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_DBL      <span class="meta-string">'d'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_BFLD     <span class="meta-string">'b'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_BOOL     <span class="meta-string">'B'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_VOID     <span class="meta-string">'v'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UNDEF    <span class="meta-string">'?'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_PTR      <span class="meta-string">'^'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CHARPTR  <span class="meta-string">'*'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ATOM     <span class="meta-string">'%'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ARY_B    <span class="meta-string">'['</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ARY_E    <span class="meta-string">']'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UNION_B  <span class="meta-string">'('</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UNION_E  <span class="meta-string">')'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_STRUCT_B <span class="meta-string">'&#123;'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_STRUCT_E <span class="meta-string">'&#125;'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_VECTOR   <span class="meta-string">'!'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CONST    <span class="meta-string">'r'</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Code</th><th>Meaning</th></tr></thead><tbody><tr><td>r</td><td>const</td></tr><tr><td>n</td><td>in</td></tr><tr><td>N</td><td>inout</td></tr><tr><td>o</td><td>out</td></tr><tr><td>O</td><td>bycopy</td></tr><tr><td>R</td><td>byref</td></tr><tr><td>V</td><td>oneway</td></tr></tbody></table><p>以上信息在具体应用时，可以自定义一个枚举获取。</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line"></span><br><span class="line">struct objc_method <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    // 方法的名称</span></span><br><span class="line"><span class="comment">    SEL method_name;                                          </span></span><br><span class="line"><span class="comment">    // 方法的参数类型</span></span><br><span class="line"><span class="comment">    char *method_types;                                       </span></span><br><span class="line"><span class="comment">    // 方法的实现(函数指针)</span></span><br><span class="line"><span class="comment">    IMP method_imp;                                           </span></span><br><span class="line"><span class="comment">&#125;</span>                                                            </span><br><span class="line"></span><br><span class="line">根据方法名称获取<span class="function"><span class="keyword">Method</span></span></span><br><span class="line"><span class="function"><span class="title">Method</span> <span class="title">class_getInstanceMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span></span></span><br><span class="line"><span class="function"><span class="title">Method</span> <span class="title">class_getClassMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取<span class="title">Method</span>的方法名称</span></span><br><span class="line"><span class="function"><span class="title">SEL</span> <span class="title">method_getName</span><span class="params">(<span class="keyword">Method</span> m)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取<span class="title">Method</span>的方法实现</span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">method_getImplementation</span><span class="params">(<span class="keyword">Method</span> m)</span> </span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">class_getMethodImplementation</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取<span class="title">Method</span>的返回值类型<span class="params">(需手动释放)</span></span></span><br><span class="line"><span class="function"><span class="title">char</span> *<span class="title">method_copyReturnType</span><span class="params">(<span class="keyword">Method</span> m)</span></span></span><br><span class="line"><span class="function">//<span class="title">void</span> <span class="title">method_getReturnType</span><span class="params">(<span class="keyword">Method</span> m, char *dst, size_t dst_len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取指定<span class="title">Method</span>的类型</span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">char</span> *<span class="title">method_getTypeEncoding</span><span class="params">(<span class="keyword">Method</span> m)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取<span class="title">Method</span>的参数数量</span></span><br><span class="line"><span class="function"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">method_getNumberOfArguments</span><span class="params">(<span class="keyword">Method</span> m)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取<span class="title">Method</span>中第<span class="title">i</span>个参数的类型<span class="params">(Char *类型)</span><span class="params">(需手动释放)</span></span></span><br><span class="line"><span class="function"><span class="title">char</span> *<span class="title">method_copyArgumentType</span><span class="params">(<span class="keyword">Method</span> m, unsigned int <span class="keyword">index</span>)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">获取方法列表</span></span><br><span class="line"><span class="function"><span class="title">Method</span> *<span class="title">class_copyMethodList</span><span class="params">(<span class="keyword">Class</span> cls, unsigned int *outCount)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">设置<span class="title">IMP</span></span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">method_setImplementation</span><span class="params">(<span class="keyword">Method</span> m, IMP imp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">交换方法实现</span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(<span class="keyword">Method</span> m1, <span class="keyword">Method</span> m2)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">添加方法</span></span><br><span class="line"><span class="function"><span class="title">BOOL</span> <span class="title">class_addMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name, IMP imp, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> char *types)</span> </span></span><br><span class="line"><span class="function">替换方法                                 </span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">class_replaceMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name, IMP imp, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> char *types)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">标明需要手动释放的动态内存<span class="params">(如返回值类型/参数类型)</span></span></span><br><span class="line"><span class="function">// 及时释放</span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(argumentType)</span> <span class="title">free</span><span class="params">(argumentType)</span>;</span></span><br></pre></td></tr></table></figure><p>实例演示</p><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="built_in">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    YAPerson *person = [[YAPerson alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 获取<span class="function"><span class="keyword">Method</span></span></span><br><span class="line">    <span class="function"><span class="keyword">Method</span> <span class="title">method</span> =</span> class_getInstanceMethod([person <span class="class"><span class="keyword">class</span>] , <span class="title">NSSelectorFromString</span>(@"<span class="title">nameWithArg</span>:<span class="title">arg</span>:<span class="title">arg</span>:<span class="title">arg</span>:<span class="title">arg</span>:"));</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 获取<span class="function"><span class="keyword">Method</span>的方法名称</span></span><br><span class="line">    SEL sel = method_getName(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">    NSLog(@<span class="string">"%@"</span>,NSStringFromSelector(sel));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 获取<span class="function"><span class="keyword">Method</span>的方法实现</span></span><br><span class="line">    IMP imp1 = method_getImplementation(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">    IMP imp2 = class_getMethodImplementation([person <span class="class"><span class="keyword">class</span>],<span class="title">sel</span>);</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 获取<span class="function"><span class="keyword">Method</span>的返回值类型(</span>需手动释放)</span><br><span class="line">    char *returnType = method_copyReturnType(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (returnType) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>,[NSString stringWithUTF8String:returnType]);</span><br><span class="line">        free(returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 获取指定<span class="function"><span class="keyword">Method</span>的类型</span></span><br><span class="line">    <span class="keyword">const</span> char *typeEncoding = method_getTypeEncoding(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (typeEncoding) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>,[NSString stringWithUTF8String:typeEncoding]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取<span class="function"><span class="keyword">Method</span>的参数数量</span></span><br><span class="line">    unsigned int arguementCount = method_getNumberOfArguments(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (arguementCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (unsigned int i = <span class="number">0</span>; i &lt; arguementCount; i++) &#123;</span><br><span class="line">            //获取<span class="function"><span class="keyword">Method</span>中第<span class="title">i</span>个参数的类型(</span>Char *类型)(需手动释放)</span><br><span class="line">            char *arguementType = method_copyArgumentType(<span class="function"><span class="keyword">method</span>, <span class="title">i</span>);</span></span><br><span class="line">            NSLog(@<span class="string">"%@"</span>,[NSString stringWithUTF8String:arguementType]);</span><br><span class="line">            </span><br><span class="line">            // 手动释放</span><br><span class="line">            <span class="keyword">if</span> (arguementType) &#123;</span><br><span class="line">                free(arguementType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 设置新的方法实现IMP,并返回原先的IMP</span><br><span class="line">    IMP imp3 = method_setImplementation(<span class="function"><span class="keyword">method</span>, <span class="title">imp2</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Method Swizzling</strong><br>使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全地替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现。</p><p>Swizzling应该总是在+load中执行</p><blockquote><p>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证–事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p></blockquote><p>Swizzling应该总是在dispatch_once中执行</p><blockquote><p>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Method Swizzling</span></span><br><span class="line"><span class="comment"> 一般放在load方法中,并且使用dispatch_once,需要调用 class_addMethod 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (void)load &#123;</span><br><span class="line"> </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class cls = [self <span class="class"><span class="keyword">class</span>];</span></span><br><span class="line">        </span><br><span class="line">        SEL oldSelector = NSSelectorFromString(@<span class="string">"XXXX"</span>);</span><br><span class="line">        SEL newSelector = NSSelectorFromString(@<span class="string">"XXXXXXXX"</span>);</span><br><span class="line">        </span><br><span class="line">        Method oldMethod = class_getInstanceMethod(cls, oldSelector);</span><br><span class="line">        Method newMethod = class_getInstanceMethod(cls, newSelector);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试给旧的方法oldSelector添加新的方法newSelectot的实现,如果已经存在方法实现,则添加失败</span></span><br><span class="line">        BOOL isSuccess = class_addMethod(cls, oldSelector, method_getImplementation(newMethod), method_getTypeEncoding(newMethod));</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123; <span class="comment">// 添加成功,那么用旧的方法实现替换新的方法实现</span></span><br><span class="line">            class_replaceMethod(cls, newSelector, method_getImplementation(oldMethod), method_getTypeEncoding(oldMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 旧的方法已经有了实现,直接交换即可</span></span><br><span class="line">            method_exchangeImplementations(newMethod, oldMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据class获取方法列表</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> class 类</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> 方法名称数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">+ (NSArray *)ya_getMethodList:(Class)<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法列表数量</span></span><br><span class="line">    unsigned int methodCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取方法列表</span></span><br><span class="line">    Method *methodList = class_copyMethodList(<span class="class"><span class="keyword">class</span>, <span class="type">&amp;methodCount);</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储方法名称</span></span><br><span class="line">    NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">    <span class="keyword">if</span> (methodList) &#123;</span><br><span class="line">        <span class="keyword">for</span> (unsigned int i = <span class="number">0</span>; i &lt; methodCount; i ++) &#123;</span><br><span class="line">            <span class="comment">// 获取方法</span></span><br><span class="line">            Method method = methodList[i];</span><br><span class="line">            <span class="comment">// 获取方法名称</span></span><br><span class="line">            SEL sel = method_getName(method);</span><br><span class="line">            </span><br><span class="line">            [array addObject:NSStringFromSelector(sel)];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手动释放</span></span><br><span class="line">        free(methodList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [NSArray arrayWithArray:array];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 交换实例方法实现</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> class 类</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> aSEL 方法一的名称</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> bSEL 方法二的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (void)ya_exchangeInstanceMethod:(Class)<span class="class"><span class="keyword">class</span> <span class="title">firstMethod</span>:<span class="type"></span></span>(SEL)aSEL secondMethod:(SEL)bSEL &#123;</span><br><span class="line">    Method aMethad = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">aSEL);</span></span></span><br><span class="line">    Method bMethod = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">bSEL);</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换方法实现</span></span><br><span class="line">    method_exchangeImplementations(aMethad, bMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 交换类方法实现</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> class 类</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> aSEL 方法一的名称</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> bSEL 方法二的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (void)ya_exchangeClassMethod:(Class)<span class="class"><span class="keyword">class</span> <span class="title">firstMethod</span>:<span class="type"></span></span>(SEL)aSEL secondMethod:(SEL)bSEL &#123;</span><br><span class="line">    Method aMethad = class_getClassMethod(<span class="class"><span class="keyword">class</span>, <span class="type">aSEL);</span></span></span><br><span class="line">    Method bMethod = class_getClassMethod(<span class="class"><span class="keyword">class</span>, <span class="type">bSEL);</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换方法实现</span></span><br><span class="line">    method_exchangeImplementations(aMethad, bMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 为类添加名为newSEL的(实例)方法</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> class 类</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> aSEL 新的方法名称</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> bSEL 已经存在的方法名称</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)ya_addMethod:(Class)<span class="class"><span class="keyword">class</span> <span class="title">newSEL</span>:<span class="type"></span></span>(SEL)aSEL existSEL:(SEL)bSEL &#123;</span><br><span class="line">    <span class="comment">// 获取已经存在的方法</span></span><br><span class="line">    Method method = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">bSEL);</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取已经存在的方法的实现</span></span><br><span class="line">    IMP imp = class_getMethodImplementation(<span class="class"><span class="keyword">class</span>, <span class="type">bSEL);</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取type</span></span><br><span class="line">    const char *type = method_getTypeEncoding(method);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给class添加名称为aSEL的方法实现</span></span><br><span class="line">    <span class="keyword">return</span> class_addMethod(<span class="class"><span class="keyword">class</span>, <span class="type">aSEL</span>, <span class="type">imp</span>, <span class="type">type);</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果父类中已经有该名称的方法,那么调用后将重写该方法</span></span><br><span class="line"><span class="comment">    如果本类中已经有了该名称的方法实现,那么将添加失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line">属性相关信息</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;         </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          </span><br><span class="line">&#125; objc_property_attribute_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">获取属性</span><br><span class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"></span><br><span class="line">获取属性列表</span><br><span class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line">获取属性信息列表</span><br><span class="line">objc_property_attribute_t *property_copyAttributeList(objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line">获取属性信息中某个Value</span><br><span class="line"><span class="keyword">char</span> *property_copyAttributeValue(objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName)</span><br><span class="line"></span><br><span class="line">添加属性</span><br><span class="line"><span class="built_in">BOOL</span> class_addProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span><br><span class="line"></span><br><span class="line">替换属性</span><br><span class="line"><span class="keyword">void</span> class_replaceProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span><br><span class="line"></span><br><span class="line">获取属性名称</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property) </span><br><span class="line"></span><br><span class="line">获取属性相关信息</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getAttributes(objc_property_t property)</span><br></pre></td></tr></table></figure><p>实例演示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">    YAPerson *person = [[YAPerson alloc] init];</span><br><span class="line">    Class cls = [person class];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性</span></span><br><span class="line">    <span class="keyword">objc_property_t</span> property = class_getProperty(cls, <span class="string">"school"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,propertyName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性信息列表</span></span><br><span class="line">    <span class="comment">// objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性相关信息</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *propertyAttributes = property_getAttributes(property);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,propertyAttributes); <span class="comment">// 打印 T@"NSObject",W,N,V_school</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据获取属性信息中的name获取对应的Value</span></span><br><span class="line">    <span class="keyword">char</span> *propertyValue = property_copyAttributeValue(property, <span class="string">"T"</span>); <span class="comment">// 类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,propertyValue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     T 类型 例如:NSObject</span></span><br><span class="line"><span class="comment">     V 值(成员变量) 例如 _school</span></span><br><span class="line"><span class="comment">     C copy</span></span><br><span class="line"><span class="comment">     N nonatommic</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加属性</span></span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> type = &#123; <span class="string">"T"</span>, [[NSString stringWithFormat:@<span class="string">"@\"%@\""</span>,NSStringFromClass([NSString class])] UTF8String] &#125;; <span class="comment">//type</span></span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> ownership0 = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;; <span class="comment">// C = copy</span></span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> ownership = &#123; <span class="string">"N"</span>, <span class="string">""</span> &#125;; <span class="comment">//N = nonatomic</span></span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> backingivar  = &#123; <span class="string">"V"</span>, [[NSString stringWithFormat:@<span class="string">"_%s"</span>, <span class="string">"propertyName"</span>] UTF8String] &#125;;  <span class="comment">//variable name</span></span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> attrs[] = &#123; type, ownership0, ownership, backingivar &#125;;</span><br><span class="line">    <span class="keyword">if</span> (class_addProperty(cls, <span class="string">"propertyName"</span>, attrs, <span class="number">4</span>)) &#123;</span><br><span class="line">        NSLog(@<span class="string">"添加成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 替换属性</span></span><br><span class="line">    <span class="comment">//void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据class获取类的属性列表</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param class 类</span></span><br><span class="line"><span class="comment"> @return 属性列表数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (NSArray *)ya_getPropertyList:(Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="comment">// 私有/公有/类扩展中的所有属性数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性列表</span></span><br><span class="line">    <span class="keyword">objc_property_t</span> *propertyList = class_copyPropertyList(class, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储属性名称</span></span><br><span class="line">    NSMutableArray *<span class="built_in">array</span> = [NSMutableArray <span class="built_in">array</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* c_propertyName = property_getName(propertyList[i]);</span><br><span class="line">        [<span class="built_in">array</span> addObject:[NSString stringWithUTF8String:c_propertyName]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手动释放</span></span><br><span class="line">    <span class="built_in">free</span>(propertyList);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [NSArray arrayWithArray:<span class="built_in">array</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p>本部分应用较少，未做详细实践。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_protocol_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *next;</span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Protocol *list[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">是否遵循协议</span><br><span class="line"><span class="built_in">BOOL</span> class_conformsToProtocol(Class cls, Protocol *protocol)</span><br><span class="line"></span><br><span class="line">协议列表</span><br><span class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *class_copyProtocolList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *objc_copyProtocolList(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *protocol_copyProtocolList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line">动态添加协议</span><br><span class="line"><span class="built_in">BOOL</span> class_addProtocol(Class cls, Protocol *protocol) </span><br><span class="line"></span><br><span class="line">获取指定名称的协议</span><br><span class="line">Protocol *objc_getProtocol(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"></span><br><span class="line">协议A是否遵循协议B</span><br><span class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol(Protocol *proto, Protocol *other)</span><br><span class="line"></span><br><span class="line">两个协议是否相等</span><br><span class="line"><span class="built_in">BOOL</span> protocol_isEqual(Protocol *proto, Protocol *other)</span><br><span class="line"></span><br><span class="line">获取某个协议的名称</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *protocol_getName(Protocol *p)</span><br><span class="line"></span><br><span class="line">动态生成协议</span><br><span class="line">Protocol *objc_allocateProtocol(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="keyword">void</span> objc_registerProtocol(Protocol *proto) </span><br><span class="line"></span><br><span class="line">给协议添加方法</span><br><span class="line"><span class="keyword">void</span> protocol_addMethodDescription(Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod) </span><br><span class="line"></span><br><span class="line">给协议添加协议</span><br><span class="line"><span class="keyword">void</span> protocol_addProtocol(Protocol *proto, Protocol *addition) </span><br><span class="line"></span><br><span class="line">给协议添加属性</span><br><span class="line"><span class="keyword">void</span> protocol_addProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty)</span><br></pre></td></tr></table></figure><p>根据class获取遵循的协议列表<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据class获取遵循的协议列表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param class 类</span></span><br><span class="line"><span class="comment"> @return 协议名称列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)ya_getProtocolList:(Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">// 协议列表数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取协议列表</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Protocol **protocolList = class_copyProtocolList(<span class="keyword">class</span>, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储协议</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">        <span class="comment">// 获取协议</span></span><br><span class="line">        Protocol *protocol = protocolList[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取协议名称</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *c_protocolName = protocol_getName(protocol);</span><br><span class="line">        </span><br><span class="line">        [array addObject:[<span class="built_in">NSString</span> stringWithUTF8String:c_protocolName]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手动释放</span></span><br><span class="line">    free(protocolList);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二、技能"><a href="#二、技能" class="headerlink" title="二、技能"></a>二、技能</h2><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p><strong>第一步：</strong><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel_isEqual(sel, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"ss"</span>))) &#123;</span><br><span class="line">        <span class="comment">// 要求参数要匹配</span></span><br><span class="line">        [YARuntime ya_addMethod:[<span class="keyword">self</span> <span class="keyword">class</span>] newSEL:sel existSEL:<span class="keyword">@selector</span>(printPersonalInfo)];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>第二步：</strong><br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (id)<span class="string">forwardingTargetForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel_isEqual(aSelector, NSSelectorFromString(@<span class="string">"ss"</span>))) &#123;</span><br><span class="line">        <span class="comment">// 转发给已经存在的对象</span></span><br><span class="line">        <span class="keyword">return</span> [[YAPerson alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">forwardingTargetForSelector:</span>aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>第三步：</strong><br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>aSelector];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有找到signature(方法签名),只能手动提供</span></span><br><span class="line">    <span class="keyword">if</span> (signature == nil) &#123;</span><br><span class="line">        signature = [NSMethodSignature <span class="string">signatureWithObjCTypes:</span><span class="string">"@@:"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation &#123;</span><br><span class="line">    YAPerson *personClass = [[YAPerson alloc] init];</span><br><span class="line">    SEL sel = anInvocation.selector;</span><br><span class="line">    <span class="keyword">if</span> ([personClass <span class="string">respondsToSelector:</span>sel]) &#123;</span><br><span class="line">        <span class="comment">// 最后一次机会</span></span><br><span class="line">        [anInvocation <span class="string">invokeWithTarget:</span>personClass];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 回天乏力</span></span><br><span class="line">        [self <span class="string">doesNotRecognizeSelector:</span>sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><blockquote><p>不会做菜的程序员不是好男人。</p></blockquote><p>YADeveloper 继承自 YAMan，想让YADeveloper实例对象同时具备响应 YAMan方法和 YACook方法的能力。</p><p>YAMan:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YAMan </span>: NSObject</span><br><span class="line">- (void)printMan;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> YAMan</span><br><span class="line">- (void)printMan &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"我是一个男人"</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>YACook:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YACook </span>: NSObject </span><br><span class="line">- (void)printCook;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> YACook</span><br><span class="line">- (void)printCook &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"我是个会做菜的人"</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>YADeveloper:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@class</span> YACook;</span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">YADeveloper </span>: YAMan</span><br><span class="line"><span class="variable">@property</span> (nonatomic,strong) YACook *cook;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">printDev</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明YACook的方法,使编译通过</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">printCook</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">implementation</span> <span class="selector-tag">YADeveloper</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">printDev</span> &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"我是个会写程序的人"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">forwardingTargetForSelector</span><span class="selector-pseudo">:(SEL)aSelector</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (sel_isEqual(aSelector, NSSelectorFromString(@<span class="string">"printCook"</span>))) &#123;</span><br><span class="line">        <span class="comment">// 需要预先对self.cook初始化</span></span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">self</span><span class="selector-class">.cook</span>;</span><br><span class="line">        <span class="comment">// 或者直接创建</span></span><br><span class="line">        <span class="comment">// return [[YACook alloc] init];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[super forwardingTargetForSelector:aSelector]</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><h3 id="关联引用"><a href="#关联引用" class="headerlink" title="关联引用"></a>关联引用</h3><p>注意点:</p><ol><li>objc_removeAssociatedObjects 函数一般不可手动调用，因为这个函数会移除一个对象的所有关联对象，将该对象恢复成“原始”状态。这样做就很有可能把别人添加的关联对象也一并移除，这并不是我们所希望的。所以一般的做法是通过给 objc_setAssociatedObject 函数传入 nil 来移除某个已有的关联对象。</li><li>关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的。<h4 id="给分类添加weak属性"><a href="#给分类添加weak属性" class="headerlink" title="给分类添加weak属性"></a>给分类添加weak属性</h4><blockquote><p>给任意对象A 添加 weak属性 B</p></blockquote></li></ol><p>问题关键点:在属性销毁的时候，将其置为空(或者说在关联对象销毁的时候，使objc_getAssociatedObject得到的是nil)。</p><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>通过继承关联对象B ，重写其dealloc方法即可适时把A中的关联对象返回值设置为nil，达到自动置空的目的，这也是最本能的方法。</p><p>给NSObject添加分类，也即任何继承自NSObject的对象都可以有weak属性。</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> NSObject (YAWeakProperty)</span><br><span class="line"><span class="variable">@property</span> (nonatomic, weak) YAProperty *property;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> NSObject (YAWeakProperty)</span><br><span class="line"><span class="comment">// const static char *key = "key";</span></span><br><span class="line">- (id)property &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">objc_getAssociatedObject</span>(self, <span class="variable">@selector</span>(property));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setProperty</span><span class="selector-pseudo">:(YAProperty</span> *)<span class="selector-tag">property</span> &#123;</span><br><span class="line">    <span class="selector-tag">objc_setAssociatedObject</span>(self, <span class="variable">@selector</span>(property), property, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    <span class="selector-attr">[property setAssociate:self selector:@selector(setProperty:)]</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>关联引用的key一般使用getter方法的selector，此时get方法中的key也可使用_cmd，二者等效。</p><p>属性的实现:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAProperty</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setAssociate:(<span class="built_in">NSObject</span> *)associatedObject selector:(SEL)sel;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类扩展</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAProperty</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">   __<span class="keyword">weak</span> <span class="keyword">id</span> _associatedObject;</span><br><span class="line">   SEL _sel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAProperty</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setAssociate:(<span class="built_in">NSObject</span> *)associatedObject selector:(SEL)sel &#123;</span><br><span class="line">    _associatedObject = associatedObject;</span><br><span class="line">    _sel = sel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL,<span class="keyword">id</span>)) objc_msgSend)(_associatedObject, _sel, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然而有个问题：添加的属性继承自NSObject时非常完美，但是实际项目中不可能给任意对象添加的属性都是NSObject，有可能是NSString/NSArray/NSDictionary/NSSet等等。那么就只能继承自NSString/NSArray/NSDictionary/NSSet等系统类，这样会出现一系列一系列一系列问题，苹果并不建议我们使用NSString/NSArray/NSDictionary/NSSet等的派生类(这些类已经足够好了，不需要画蛇添足)。</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><blockquote><p>用一个NSPointerArray（弱引用类型的数组）包一层就可以了。虽然关联属性的policy不支持weak，但是你可以把要关联的对象放入一个弱引用数组里面，然后把这个弱引用数组设置为关联对象，每次取值的时候，只需要从这个弱引用数组里面取就可以了。一样可以达到关联弱引用对象的效果。</p></blockquote><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><p>A 关联 C<br>B 关联 C<br>C 销毁 通知B<br>B 再告诉 A</p><h5 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h5><p>阅读大神博客发现的新方法，见2019年新写的文章： <a href="https://blog.chenyalun.com/2019/01/20/Weak%20Associated%20Object/">Weak Associated Object</a></p><h2 id="三、要点"><a href="#三、要点" class="headerlink" title="三、要点"></a>三、要点</h2><h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>() 函数用来释放动态分配的内存空间，其原型为：</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span> <span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>() 可以释放由 <span class="built_in">malloc</span>()、<span class="built_in">calloc</span>()、<span class="built_in">realloc</span>() 分配的内存空间，以便其他程序再次使用。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 及时释放字符串常量</span></span><br><span class="line"><span class="keyword">if</span> (argumentType) <span class="built_in">free</span>(argumentType);</span><br></pre></td></tr></table></figure><h3 id="NONNULL"><a href="#NONNULL" class="headerlink" title="NONNULL"></a>NONNULL</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span>和<span class="built_in">NS_ASSUME_NONNULL_END</span>。</span><br><span class="line">在这两个宏之间的代码，所有简单指针对象都被假定为 <span class="keyword">nonnull</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define NS_ASSUME_NONNULL_BEGIN _Pragma(<span class="meta-string">"clang assume_nonnull begin"</span>)</span></span><br><span class="line"><span class="meta">#define NS_ASSUME_NONNULL_END   _Pragma(<span class="meta-string">"clang assume_nonnull end"</span>)</span></span><br></pre></td></tr></table></figure><h3 id="covariant"><a href="#covariant" class="headerlink" title="__covariant"></a>__covariant</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">__covariant</span> - 协变性，子类型可以强转到父类型（里氏替换原则）</span><br><span class="line"><span class="variable">__contravariant</span> - 逆变性，父类型可以强转到子类型（WTF）</span><br></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">__kindof</span></span><br></pre></td></tr></table></figure><h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">__attribute__</span>((always_inline)) 的意思是强制内联</span><br></pre></td></tr></table></figure><blockquote><p>参考并感谢<br><a href="http://www.cnblogs.com/ludashi/p/6294112.html" target="_blank" rel="noopener">青玉伏案</a><br><a href="http://southpeak.github.io/2014/11/06/objective-c-runtime-4/" target="_blank" rel="noopener">南峰子</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2018.8.26 更新Class定义&lt;br&gt;2019.3.25 更新设置weak关联属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 关于Runtime的简单总结。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>开源项目：YAScrollPlaceView</title>
    <link href="http://blog.chenyalun.com/2017/10/01/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9AYAScrollPlaceView/"/>
    <id>http://blog.chenyalun.com/2017/10/01/开源项目：YAScrollPlaceView/</id>
    <published>2017-10-01T12:22:33.000Z</published>
    <updated>2019-08-21T07:57:47.135Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2019.8.4 补充内容</p></blockquote><p></p><p align="center"> 可以给UIScrollView、UITableView添加头尾视图。 </p><br><a id="more"></a><p></p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>百度畅听是我工作后的第一个项目，大概就是手百里面的“喜马拉雅”。</p><p>某一天UE提了个需求，大意就是在<code>UITableView</code>底部加个logo图片，要求这张图片能随着<code>UITableViewCell</code>的滑动而跟着滑动。乍一想，可以使用直接使用<code>UITableView</code>的<code>tableFooterView</code>，赋值个<code>UIImageView</code>即可，可是还有一个要求：当数据很少的时候，这个logo图片必须紧挨着屏幕最下方。很显然，<code>tableFooterView</code>自己会跑到顶部，满足不了需求。</p><p>关键是，那一阵子刚读了<code>MJRefresh</code>的源码，又痴迷于<code>Runtime</code>的各种魔法，走火入魔的厉害，还特别想写一个开源项目逞能，于是这个能给<code>UIScrollView</code>添加头部、尾部视图的框架产生了。</p><p>项目地址:<a href="https://github.com/ChenYalun/YAScrollPlaceView" target="_blank" rel="noopener">https://github.com/ChenYalun/YAScrollPlaceView</a></p><h1 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h1><p>思路很简单。</p><ol><li>使用KVO监听<code>UIScrollView</code>的<code>contentSize</code>和<code>contentOffset</code>。</li><li><p>根据<code>contentSize</code>确定FooterView的位置。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">HeaderView<span class="selector-class">.y</span> = -size.<span class="attribute">height</span>;</span><br><span class="line">FooterView<span class="selector-class">.y</span> = contentSize.<span class="attribute">height</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置<code>UIScrollView</code>的<code>contentInset</code>，给占位视图腾出空间。</p></li><li>根据<code>contentOffset.y</code>确定当前占位视图是否可以跟着滑动。<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="built_in">if</span> (contentOffset.y + scrollView.<span class="built_in">height</span> - scrollView.contentInset.bottom - scrollView.contentSize.<span class="built_in">height</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    FooterView.y = contentOffset.y + scrollView.<span class="built_in">height</span> - scrollView.contentInset.bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>大致就是这样，剩下的就是时机和接口了。</p><ol><li><p>在<code>didMoveToSuperview</code>中添加KVO，在<code>willMoveToSuperview</code>中移除KVO。</p><p> 这两个成双成对，之所以不放在<code>dealloc</code>里面移除，是考虑到有同一个视图被<code>didMoveToSuperview</code>多次的情况。当然，视图<code>dealloc</code>的时候是会调用<code>willMoveToSuperview</code>方法的，只不过这个<code>newSuperview</code>为空。</p></li><li><p>给<code>UIScrollView</code>添加关联属性。<br>无需多言，没有侵入性。</p> <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (YAScrollHeaderView *)<span class="selector-tag">scrollHeaderView</span> &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">objc_getAssociatedObject</span>(self, <span class="variable">@selector</span>(scrollHeaderView));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setScrollHeaderView</span><span class="selector-pseudo">:(YAScrollHeaderView</span> *)<span class="selector-tag">scrollHeaderView</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (scrollHeaderView == self.scrollHeaderView) <span class="selector-tag">return</span> ;</span><br><span class="line">    <span class="selector-attr">[self.scrollHeaderView removeFromSuperview]</span>;</span><br><span class="line">    <span class="selector-attr">[self addSubview:scrollHeaderView]</span>;</span><br><span class="line">    <span class="selector-tag">objc_setAssociatedObject</span>(self, <span class="variable">@selector</span>(scrollHeaderView), scrollHeaderView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结构设计</p></li></ol><ul><li><code>YAScrollHeaderView</code>和<code>YAScrollFooterView</code>均继承自<code>YAScrollPlaceView</code>。（这是模仿了<code>MJRefresh</code>）。核心逻辑统一在上层实现。</li><li><code>YAScrollHeaderView</code>在初始化的时候设置自己<code>scrollPlaceViewType</code>为<code>YAScrollPlaceViewTypeHeader</code>。</li><li><code>YAScrollFooterView</code>在初始化的时候设置自己<code>scrollPlaceViewType</code>为<code>YAScrollPlaceViewTypeFooter</code>。<br>这样，<code>YAScrollPlaceView</code>就可以根据子类来确定占位视图的逻辑。</li></ul><h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><p>暴露出来的接口很清晰。<code>isFixed</code>用于设置占位视图是否在offset超出可见区域（过大或者过小）时跟随着滑动。这个占位视图可以动态显示或者隐藏，<code>canAnimate</code>设置其动画效果，<code>showAnimationDuration</code>和<code>dismissAnimationDuration</code>不必多说，是动画时间。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isFixed; <span class="comment">///&lt; default NO.Fix the place view to the top or bottom.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> canAnimate; <span class="comment">///&lt; default YES.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> height; <span class="comment">///&lt; default 0</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> isVisible;; <span class="comment">///&lt; default NO.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> showAnimationDuration;    <span class="comment">///&lt; default 0.15</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> dismissAnimationDuration;   <span class="comment">///&lt; default 0.15</span></span><br><span class="line">- (<span class="keyword">void</span>)showWithCompletion:(YAScrollPlaceViewShowCompletion)completion;</span><br><span class="line">- (<span class="keyword">void</span>)dismissWithCompletion:(YAScrollPlaceViewDismissCompletion)completion;</span><br></pre></td></tr></table></figure><h3 id="给ScrollView设置占位图片"><a href="#给ScrollView设置占位图片" class="headerlink" title="给ScrollView设置占位图片"></a>给ScrollView设置占位图片</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">UIImage *headerImage = [UIImage imageNamed:@<span class="string">"header"</span>]<span class="comment">;</span></span><br><span class="line">YAScrollHeaderView *headerView = [YAScrollHeaderView <span class="keyword">scrollHeaderViewWithSize:CGSizeMake(self.view.bounds.size.width, </span><span class="number">100</span>) <span class="keyword">backgroundImage:headerImage];</span></span><br><span class="line"><span class="keyword">self.scrollView.scrollHeaderView </span>= headerView<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>左图：数据较多时，视图固定（也可以配置不固定）；<br>右图：数据极少时，视图不固定、跟着滑动（也可以配置为固定）。</p><p><img src="https://image.chenyalun.com/2017/10/01/003.gif" style="zoom:40%"><img src="https://image.chenyalun.com/2017/10/01/005.gif" style="zoom:40%"></p><h3 id="给tableView设置空白占位"><a href="#给tableView设置空白占位" class="headerlink" title="给tableView设置空白占位"></a>给tableView设置空白占位</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">YAScrollFooterView *footerView = [YAScrollFooterView new]<span class="comment">;</span></span><br><span class="line">footerView.height = <span class="number">100</span><span class="comment">;</span></span><br><span class="line">footerView.isFixed = YES<span class="comment">;</span></span><br><span class="line">self.tableView.<span class="keyword">scrollFooterView </span>= footerView<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="动态地显示或者隐藏"><a href="#动态地显示或者隐藏" class="headerlink" title="动态地显示或者隐藏"></a>动态地显示或者隐藏</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">self</span>.tableView.scrollHeaderView = <span class="built_in">self</span>.<span class="keyword">header</span>;</span><br><span class="line"><span class="built_in">self</span>.<span class="keyword">header</span>.showAnimationDuration = <span class="number">0.8</span>f;</span><br><span class="line"><span class="built_in">self</span>.<span class="keyword">header</span>.dismissAnimationDuration = <span class="number">0.8</span>f;</span><br><span class="line"><span class="meta">[</span><span class="built_in">self</span>.<span class="keyword">header</span> show<span class="meta">]</span>;</span><br><span class="line">// <span class="meta">[</span><span class="built_in">self</span>.<span class="keyword">header</span> dismissWithCompletion:nil<span class="meta">]</span>;</span><br></pre></td></tr></table></figure><p><img src="https://image.chenyalun.com/2017/10/01/001.gif" style="zoom:40%"><img src="https://image.chenyalun.com/2017/10/01/002.gif" style="zoom:40%"></p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>整体而言，实现起来还是比较轻松的，没有啥极其复杂的逻辑。不过作为我的第一个开源Framework，还挺有纪念意义的。有一方有二，二生三，三生万物。</p><blockquote><p>后记<br>2018年秋，存在两年的百度畅听正式下线。喜马拉雅、懒人听书，还活着。<br>2019年8月，整理博客时，完善文章内容并修复框架的bug。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2019.8.4 补充内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt; 可以给UIScrollView、UITableView添加头尾视图。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="开源项目" scheme="http://blog.chenyalun.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>查找算法总结</title>
    <link href="http://blog.chenyalun.com/2017/04/21/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.chenyalun.com/2017/04/21/查找算法总结/</id>
    <published>2017-04-21T11:10:17.000Z</published>
    <updated>2019-03-29T03:02:01.090Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 关于查找算法。 </p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文”完全二叉树”的定义采用国内定义<br>B-树 即 B树,两者是相同概念,而非指二叉搜索树(百度百科)</p></blockquote><h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>1.国内早期教材中，满二叉树一般指 perfect binary tree，所以会有满二叉树是完全二叉树的一个特例的说法.</p><p>2.树的深度的定义，有的根结点从0开始计数，有的从1开始计数.</p><p>3.结点 与 节点 是对Node的翻译,可以看做等同.</p><h2 id="维基百科定义"><a href="#维基百科定义" class="headerlink" title="维基百科定义"></a>维基百科定义</h2><p>1.根二叉树(Rooted Binary Tree)：<br>有一个根结点，每个结点至多有两个孩子。</p><p>2.满二叉树(Full Binary Tree)：<br>要么是叶子结点(结点的度为0)，要么结点同时具有左右子树(结点的度为2)。</p><p>3.完全二叉树(Complete Binary Tree)：<br>每层结点都完全填满，在最后一层上如果不是满的，则只缺少右边的若干结点。</p><p>4.完美二叉树(Perfect Binary Tree)<br>所有的非叶子结点都有两个孩子，所有的叶子结点都在同一层。即每层结点都完全填满。</p><p>5.无限完全二叉树(Infinite Complete Binary Tree)：    每个结点都有两个孩子，结点的层数是无限的。</p><p>6.平衡二叉树(Balanced Binary Tree)：<br>也称为AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><strong>满二叉树(Full Binary Tree)</strong><br>如果一棵二叉树的结点要么是叶子要么有两个孩子结点,则为满二叉树</p><p>性质:<br>1.总结点个数呈现个数为:0 1 3 7 15…满足2^(n) -1,其中n为树的深度(最大层)</p><p>2.第k层(k不为0)结点个数:1 2 4 8…满足2^(k - 1)</p><p>3.满二叉树是完全二叉树</p><p><strong>完全二叉树(Complete Binary Tree)</strong><br>若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><p>性质:完全二叉树中度为1的结点数只有两种可能0或1,那么:<br>总结点数为n,有  <strong>n0=n/2</strong> 或 <strong>n0=(n+1)/2</strong></p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>顺序存储的排序数组<br><img src="http://static.chenyalun.com/2017/04/21/170421004.jpg" alt><br>插入和删除的时候时间复杂度达到O(n),顺序存储结构不适于动态的情况</p><p>链式存储<br><img src="http://static.chenyalun.com/2017/04/21/170421005.jpg" alt><br>链表的查找需要O(n)</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找表:由同一类型的数据元素构成的集合.<br>关键字:数据元素中某个数据项的值.<br>主关键字:可以唯一地标识一个记录.<br>次关键字:可以识别多个数据元素.<br>查找:根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素(或记录).<br>静态查找表:只作查找操作的查找表.<br>动态查找表:在查找过程中同时插入查找表中不存在的数据元素,或者从查找表中删除已经存在的某个数据元素.</p><h2 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h2><p>顺序查找(线性查找):从表中第一个记录开始,逐个进行记录的关键字和给定值的比较.</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 顺序查找的实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequentialSearch</span><span class="params">(key, numbers)</span></span><span class="symbol">:</span></span><br><span class="line">    length = len(numbers)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(length)<span class="symbol">:</span></span><br><span class="line">        <span class="comment"># 查找成功返回索引</span></span><br><span class="line">        <span class="keyword">if</span> key == numbers[i]<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="comment"># 查找失败返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>最好情况:在第一个位置找到,时间复杂度为O(1)<br>最坏情况:在最后一个位置找到,时间复杂度O(n)<br>查找不成功:时间复杂度O(n)<br>平均查找次数:(n+1)/2<br>平均时间复杂度:O(n)</p><h2 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h2><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><p> 折半查找(二分查找):在线性表中的记录有序的前提下进行查找.取中间元素作为比较对象,若给定值与中间元素相等,则查找成功,若给定值小于中间元素,则在中间元素的左半区继续查找,若给定值大于中间元素,则在中间元素的右半区继续查找,不断重复查找过程,直到查找成功,或查找失败.</p><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 二分查找的实现</span></span><br><span class="line">def binarySearch(<span class="keyword">key</span>, numbers):</span><br><span class="line">    <span class="meta"># 左边界</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    <span class="meta"># 右边界</span></span><br><span class="line">    high = len(numbers) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        <span class="meta"># 中间元素索引</span></span><br><span class="line">        <span class="keyword">mid</span> = (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="meta"># 查找成功</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] == <span class="keyword">key</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">mid</span></span><br><span class="line">        <span class="meta"># 在左区间</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] &gt; <span class="keyword">key</span>:</span><br><span class="line">            high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">        <span class="meta"># 在右区间</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] &lt; <span class="keyword">key</span>:</span><br><span class="line">            low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="meta"># 查找失败返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>最好情况:是中间元素,一次即可找到,时间复杂度O(1)<br>最坏情况:完全二叉树的深度加1,即floor(logn) + 1次,时间复杂度O(logn).(注意:logn这里指以2为底,floor表示向下取整)</p><h3 id="2-插值查找"><a href="#2-插值查找" class="headerlink" title="2.插值查找"></a>2.插值查找</h3><p>二分查找的优化版,核心是插值公式:<br>(key - numbers[low]) / (numbers[high] - numbers[low])</p><p>核心代码:</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插值</span></span><br><span class="line">mid = low + <span class="comment">(high - low)</span> * <span class="comment">(key - numbers[low])</span> / <span class="comment">(numbers[high] - numbers[low])</span></span><br></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 插值查找的实现</span></span><br><span class="line">def interpolationSearch(<span class="keyword">key</span>, numbers):</span><br><span class="line">    <span class="meta"># 左边界</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    <span class="meta"># 右边界</span></span><br><span class="line">    high = len(numbers) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        <span class="meta"># 核心代码</span></span><br><span class="line">        <span class="keyword">mid</span> = low + (high - low) * (<span class="keyword">key</span> - numbers[low]) / (numbers[high] - numbers[low])</span><br><span class="line">        <span class="meta"># 查找成功</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] == <span class="keyword">key</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">mid</span></span><br><span class="line">        <span class="meta"># 在左区间</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] &gt; <span class="keyword">key</span>:</span><br><span class="line">            high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">        <span class="meta"># 在右区间</span></span><br><span class="line">        <span class="keyword">if</span> numbers[<span class="keyword">mid</span>] &lt; <span class="keyword">key</span>:</span><br><span class="line">            low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="meta"># 查找失败返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>从时间复杂度上,依然是O(logn),但是对于表长较大,关键字分布比较均匀的查找表,性能相对二分查找更好.<br>但是,分布极不均匀的数据,不是很合适,比如[1,2,4,3000,3003…9988899,8988998]</p><p>插值查找在实际使用时，一般要满足两个假设条件：</p><p>(1)每一次对数据的访问与通常的指令相比，费用都是相当昂贵的。例如，待查找的表一定是在磁盘而非内存中，因而每一次比较都要进行磁盘访问。</p><p>(2)数据不仅是已被排好序的，而且呈现均匀分布特征。</p><h3 id="3-斐波那契查找"><a href="#3-斐波那契查找" class="headerlink" title="3.斐波那契查找"></a>3.斐波那契查找</h3><p>利用黄金分割原理实现,折半查找算法来进行修改和改进.<br>对于斐波那契数列,前后两个数字的比值随着数列的增加,越来越接近黄金比值:0.618</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">0<span class="selector-class">.0</span></span><br><span class="line">1<span class="selector-class">.0</span></span><br><span class="line">0<span class="selector-class">.5</span></span><br><span class="line">0<span class="selector-class">.666666666667</span></span><br><span class="line">0<span class="selector-class">.6</span></span><br><span class="line">0<span class="selector-class">.625</span></span><br><span class="line">0<span class="selector-class">.615384615385</span></span><br><span class="line">0<span class="selector-class">.619047619048</span></span><br><span class="line">0<span class="selector-class">.617647058824</span></span><br><span class="line">0<span class="selector-class">.618181818182</span></span><br><span class="line">0<span class="selector-class">.61797752809</span></span><br><span class="line">0<span class="selector-class">.618055555556</span></span><br><span class="line">0<span class="selector-class">.618025751073</span></span><br><span class="line">0<span class="selector-class">.618037135279</span></span><br><span class="line">0<span class="selector-class">.618032786885</span></span><br><span class="line">0<span class="selector-class">.618034447822</span></span><br><span class="line">0<span class="selector-class">.6180338134</span></span><br><span class="line">0<span class="selector-class">.618034055728</span></span><br><span class="line">0<span class="selector-class">.618033963167</span></span><br><span class="line">0<span class="selector-class">.618033998522</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>对于斐波那契数列:<br>0 1 1 2 3 5 8 13 21 34 55 89 …</p><p><strong>原理:</strong><br>比如这里的89，假定它是整个有序表的元素个数，而89是由前面的两个数34和55相加之后的和，也即把元素个数为89的有序表分成由前55个数据元素组成的前半段和由后34个数据元素组成的后半段，那么前半段元素个数和整个有序表长度的比值就接近黄金比值0.618，假如要查找的元素在前半段，那么继续按照斐波那契数列来看，55 = 34 + 21，所以继续把前半段分成前34个数据元素的前半段和后21个元素的后半段，继续查找，如此反复，直到查找成功或失败.</p><p>当有序表的元素个数不是斐波那契数列中的某个数字时，需要把有序表的元素个数长度补齐，让它成为斐波那契数列中的一个数值,也即<strong>把需要补齐的的元素都赋值为有序表的最大值</strong>。</p><p><strong>核心:</strong><br>(1)当key == numbers[mid],查找成功<br>(2)当key &lt; numbers[mid],新范围是第low个到第mid-1个,范围个数是F(k-1) - 1个,即有序列表左边的长度<br>(3)当key &gt; numbers[mid]时,新范围是第mid+1到第high个,范围个数是F(k-2) - 1个,即有序列表右边的长度</p><p>k 表示列表的长度<br>k-1表示索引<br>F(k-1)表示列表最后一个元素</p><p>元素总个数 = 左区间个数 + 右区间个数 + 中间的一个元素,即:</p><pre><code>F(k)-1 = F(k-1)-1  +   F(k-2)-1    +     1</code></pre><p>斐波那契查找算法如下：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 斐波那契查找</span></span><br><span class="line">def Fbonacci(index):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="literal">return</span> </span><br><span class="line">    <span class="keyword">a</span>, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(index):</span><br><span class="line">        <span class="keyword">a</span>, b = b, <span class="keyword">a</span> + b</span><br><span class="line">    <span class="literal">return</span> <span class="keyword">a</span></span><br><span class="line">    </span><br><span class="line">def FbonacciSearch(key, numbers):</span><br><span class="line">    <span class="comment"># 确定该序列在斐波那契数列中的位置</span></span><br><span class="line">    n, <span class="built_in">length</span> = <span class="number">0</span>, <span class="built_in">len</span>(numbers)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span> &gt; Fbonacci(n) - <span class="number">1</span>:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 填满元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n,Fbonacci(n)):</span><br><span class="line">        numbers.append(numbers[<span class="number">-1</span>])</span><br><span class="line">    </span><br><span class="line">    low, high = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        <span class="comment"># 获取黄金分割下标</span></span><br><span class="line">        <span class="keyword">mid</span> = low + Fbonacci(n - <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左区间</span></span><br><span class="line">        <span class="comment">#若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1</span></span><br><span class="line">        <span class="keyword">if</span> key &lt; numbers[<span class="keyword">mid</span>]:</span><br><span class="line">            high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 右区间</span></span><br><span class="line">        <span class="comment">#若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1</span></span><br><span class="line">        <span class="keyword">if</span> key &gt; numbers[<span class="keyword">mid</span>]:</span><br><span class="line">            low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">            n -= <span class="number">2</span></span><br><span class="line">        <span class="comment"># 相等</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 成功找到</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">mid</span> &lt;= n:</span><br><span class="line">                <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">            <span class="comment"># 补全的数,返回n</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="literal">return</span> n</span><br><span class="line">    <span class="literal">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="4-比较"><a href="#4-比较" class="headerlink" title="4.比较"></a>4.比较</h3><p>二分查找是加法与除法运算<br>插值查找是复杂的四则运算<br>斐波那契查找是加减法运算</p><h2 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h2><p>索引:把一个关键字与它对应的记录相关联的过程.<br>线性索引:把索引项集合组织为线性结构,也即索引表</p><h3 id="1-稠密索引"><a href="#1-稠密索引" class="headerlink" title="1.稠密索引"></a>1.稠密索引</h3><p>稠密索引:将数据集的每个记录对应一个索引项,且索引项一定按照关键码有序排列.</p><h3 id="2-分块索引"><a href="#2-分块索引" class="headerlink" title="2.分块索引"></a>2.分块索引</h3><p>对数据集进行分块,使分块有序,然后对每一块建立一个索引项,从而减少索引项的个数.</p><p>块需要满足的条件:<br>(1)块内无序:每一块的记录不要求有序.<br>(2)块间有序:比如,要求第二块所有记录的关键字均要大于第一块所有记录的关键字.第三块大于第二块…</p><p>分块索引的索引项结构:</p><ul><li>最大关键码:存储每一块中点最大关键字</li><li>存储块中记录的个数,便于循环</li><li>用于指向块首数据元素的指针,便于遍历</li></ul><p>查找分两步:<br>(1)在分块索引表中查找关键字所在的块.<br>(2)根据块首指针找到相应的块,并在块中顺序查找关键码.</p><p>设n个记录被平均分成m块,每个块t条记录,则n=mt<br>查找索引表的平均查找长度:(1+m)/2<br>查找记录的平均查找长度:(t+1)/2</p><p>则块中查找记录的平均查找长度:</p><pre><code>  (1+m)/2 + (t+1)/2 = (m+t)/2+1 = (n/t+t)/2+1</code></pre><p>最佳情况:m与t相等,也即n = t^2 = m^2 ,则原式为:</p><pre><code>= (t*t/t+t)/2+1= t+1= n^0.5 + 1 (^ 表示次方)</code></pre><p>由此分块索引比顺序查找O(n)提高不少.</p><h3 id="3-倒排索引"><a href="#3-倒排索引" class="headerlink" title="3.倒排索引"></a>3.倒排索引</h3><p>索引项的结构:次关键码与记录号表<br>根据属性(次关键码,字段)的值查找记录.<br>该索引表中的每一项包括一个属性值和具有该属性值的各记录的地址.<br>由于不是由记录确定属性值而是由属性值确定记录,因而称为倒排索引.</p><p>优点:生成索引表后不用读取记录就可知道结果,查找非常快<br>缺点:记录号不定长</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>如果查找的数据集是有序线性表,并且是顺序存储的,可以使用二分查找/插值查找/斐波那契查找,但是在插入删除操作上耗费大量时间,由此引出既可以使得插入删除效率不错又可以高效率查找的算法====&gt;使用二叉树数据结构:在创建集合时就考虑使用二叉树结果,而且是排好序的二叉树.构造二叉搜索树的目的不是为了排序,而是为了提高插入/删除的效率.</p><p>二叉查找树,也称(二叉搜索树,有序二叉树,排序二叉树,二叉排序树）,是指<strong>一棵空树</strong>或者具有下列性质的<strong>二叉树</strong>：</p><ul><li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ul><p>性质:<br>1.左小于根小于右<br>2.值不重复<br>3.”中序遍历“可以让结点有序<br>4.二叉搜索树有两种结点删除方式:取被删除结点的右子树中的最小元素替代或者取被删除结点的左子树中的最大元素替代</p><p>优势:<br>查找、插入的时间复杂度较低。为O(log n)<br>二叉查找树的最坏效率是O(n),此时退化为线性结构</p><p><img src="http://static.chenyalun.com/2017/04/21/170421006.jpg" alt></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeNode</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,val = <span class="number">0</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.val = val</span><br><span class="line"><span class="keyword">self</span>.left = None</span><br><span class="line"><span class="keyword">self</span>.right = None</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找结点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(<span class="keyword">self</span>, data)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.val == <span class="symbol">data:</span></span><br><span class="line"><span class="keyword">return</span> True</span><br><span class="line">elif data &lt; <span class="keyword">self</span>.val <span class="keyword">and</span> <span class="keyword">self</span>.<span class="symbol">left:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.left.find(data)</span><br><span class="line">elif data &gt; <span class="keyword">self</span>.val <span class="keyword">and</span> <span class="keyword">self</span>.<span class="symbol">right:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.right.find(data)</span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找最小结点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMinData</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">left:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.left.findMinData()</span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找最大结点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxData</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">right:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.right.findMaxData()</span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.val</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入结点</span></span><br><span class="line"><span class="comment"># 当data与二叉搜索树中某结点val相等时不作处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertNode</span><span class="params">(<span class="keyword">self</span>, data)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="comment"># 在右子树上</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.val &lt; <span class="symbol">data:</span></span><br><span class="line"><span class="keyword">if</span>  <span class="keyword">self</span>.<span class="symbol">right:</span></span><br><span class="line"><span class="keyword">self</span>.right.insertNode(data)</span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="keyword">self</span>.right = BinarySearchTreeNode(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在左子树上</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.val &gt; <span class="symbol">data:</span></span><br><span class="line"><span class="keyword">if</span>  <span class="keyword">self</span>.<span class="symbol">left:</span></span><br><span class="line"><span class="keyword">self</span>.left.insertNode(data)</span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="keyword">self</span>.left = BinarySearchTreeNode(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印二叉搜索树</span></span><br><span class="line"><span class="comment"># 左根右遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printTree</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">left:</span></span><br><span class="line"><span class="keyword">self</span>.left.printTree()</span><br><span class="line">print <span class="keyword">self</span>.val,</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">right:</span></span><br><span class="line"><span class="keyword">self</span>.right.printTree()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结点的删除</span></span><br><span class="line"><span class="comment"># 当删除一个叶子结点时,直接删除即可</span></span><br><span class="line"><span class="comment"># 当删除的结点只有一个孩子时,用该孩子替换</span></span><br><span class="line"><span class="comment"># 当删除的结点有两个孩子时,寻找该结点右子树中的最小数据代替子节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">daleteNode</span><span class="params">(<span class="keyword">self</span>, data)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="comment"># 前提是该结点在二叉搜索树中能找到</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.find(data)<span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line"><span class="keyword">if</span> data &lt; <span class="keyword">self</span>.<span class="symbol">val:</span></span><br><span class="line"><span class="keyword">self</span>.left = <span class="keyword">self</span>.left.daleteNode(data)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">elif data &gt; <span class="keyword">self</span>.<span class="symbol">val:</span></span><br><span class="line"><span class="keyword">self</span>.right = <span class="keyword">self</span>.right.daleteNode(data)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">elif <span class="keyword">self</span>.left <span class="keyword">and</span> <span class="keyword">self</span>.<span class="symbol">right:</span></span><br><span class="line"><span class="comment"># 找到右子树最小的结点,获取值</span></span><br><span class="line">val = <span class="keyword">self</span>.right.findMinData()</span><br><span class="line"><span class="comment"># 把最小结点的值给自己</span></span><br><span class="line"><span class="keyword">self</span>.val = val</span><br><span class="line"><span class="comment"># 删除右子树中的最小结点,使self.right指向右子树的根节点</span></span><br><span class="line"><span class="comment"># self.right.daleteNode(val)最终返回右子树的根节点</span></span><br><span class="line"><span class="keyword">self</span>.right = <span class="keyword">self</span>.right.daleteNode(val)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="comment"># 左结点存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">left:</span></span><br><span class="line"><span class="comment"># 直接指向左结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.left</span><br><span class="line"><span class="comment"># 右结点存在,或不存在结点</span></span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line"><span class="comment"># 直接指向右结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = BinarySearchTreeNode(<span class="number">10</span>)</span><br><span class="line">a.insertNode(<span class="number">8</span>)</span><br><span class="line">a.insertNode(<span class="number">12</span>)</span><br><span class="line">a.insertNode(<span class="number">6</span>)</span><br><span class="line">a.insertNode(<span class="number">9</span>)</span><br><span class="line">a.insertNode(<span class="number">11</span>)</span><br><span class="line">a.insertNode(<span class="number">14</span>)</span><br><span class="line">a.insertNode(<span class="number">7</span>)</span><br><span class="line">a.insertNode(<span class="number">13</span>)</span><br><span class="line">a.insertNode(<span class="number">5</span>)</span><br><span class="line">a.insertNode(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">a.printTree()</span><br><span class="line">print <span class="string">"\n"</span></span><br><span class="line">print a.find(<span class="number">11</span>)</span><br><span class="line">print a.find(<span class="number">100000</span>)</span><br><span class="line">print a.findMaxData()</span><br><span class="line">print a.findMinData()</span><br><span class="line"></span><br><span class="line">a.daleteNode(<span class="number">1000000</span>)</span><br><span class="line">a.daleteNode(<span class="number">10</span>)</span><br><span class="line">a.daleteNode(<span class="number">14</span>)</span><br><span class="line">a.daleteNode(<span class="number">2</span>)</span><br><span class="line">a.printTree()</span><br></pre></td></tr></table></figure><p>二叉搜索树以链接的方式存储,保持了链接存储结构在执行插入或删除时的优越性.</p><p><img src="http://static.chenyalun.com/2017/04/21/170421002.png" alt></p><p>对于二叉搜索树的查找,比较次数等于给定值的结点在二叉搜索树的层数.最少为1次(为根节点),最多不超过树的深度(最差是极端的右斜树或左斜树).</p><p><img src="http://static.chenyalun.com/2017/04/21/170421001.png" alt></p><p>二叉排序树倘若是平衡的,其深度与完全二叉树相同,均为<code>floor(logn) + 1</code>,查找的时间复杂度为O(logn),近似与折半查找,若不是平衡的,甚至演化为极端的右斜树或左斜树,查找的时间复杂度为O(n),等同于顺序查找.</p><p>因此,平衡至关重要.</p><h2 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h2><p>平衡二叉搜索树是改进的二叉搜索树,也是二叉搜索树。</p><p>一般的二叉搜索树的查询复杂度是跟深度有关，因此当结点的深度普遍较大时，查询的均摊复杂度会上升，为了更高效的查询，平衡树应运而生了。</p><p>可以使查找树的高度为 O (log(n)) </p><p>定义:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>AVL树中的每个结点都有一个平衡因子（balance factor，BF），它表示这个结点的左、右子树的深度差，也就是左子树的深度减去右子树的深度的结果值。AVL树上所有结点的BF值只能是-1、0、1。反之，只要二叉树上一个结点的BF的绝对值大于1，则该二叉树就不是平衡二叉树。在进行插入和删除的时候找出失去平衡的节点，进行必要的旋转操作保证树的平衡。</p><p>查找、插入和删除在平均和最坏情况下都是O（log n）</p><h3 id="最少结点"><a href="#最少结点" class="headerlink" title="最少结点"></a>最少结点</h3><p>设n(h)是高度为h的AVL树，则结点数最少时有:<br>n(h) = n(h-1) + n(h-2) + 1</p><table><thead><tr><th>h(VAL树的高度)</th><th>最少结点数</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>2</td><td>4</td></tr><tr><td>3</td><td>7</td></tr><tr><td>4</td><td>12</td></tr><tr><td>5</td><td>20</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>显而易见，满足的关系为:<br>高度为h的AVL树，其最少结点数量为<code>F(h+2) - 1</code>，其中F(x)为斐波那契数列逗号且规定从1开始，即F(0) = 1，F(1) = 2</p><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><p>RR(右单旋):麻烦结点在发现结点的右子树的右子树上</p><p>RL():麻烦结点在发现结点的右子树的左子树上</p><p>LL(左单旋):麻烦结点在发现结点的左子树的左子树上</p><p>LR():麻烦结点在发现结点的左子树的右子树上</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆:用数组表示的完全二叉树<br>有序性:任一结点的关键字是其子树所有结点的最大值(或者最小值)，从根结点到任意结点路径上结点序列的有序性。<br>最大堆,也称为大顶堆:最大值<br>最小堆,也称为小顶堆:最小值</p><p>最大堆的建立:<br>方法一:自底向上调整堆，首先将n个节点按输入顺序存入，使其满足完全二叉树的结构特性，然后调整各节点的位置。</p><p>方法二:通过插入操作，将n个元素一个个地相继插入到一个初始为空的堆中，其时间代价最大为O(nlogn)。</p><p>堆顶元素的删除<br>元素的插入</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>带权路径长度:设二叉树有n个叶子节点，每个叶子节点带有权值W，从根节点到每个叶子节点的长度为L，则每个叶子节点的带权路径长度之和为WPL=∑WL。<br>哈夫曼树即是最优二叉树:WPL最小的二叉树。</p><p>性质:</p><ol><li>没有度为1的结点(按照构造哈夫曼树的规则，显而易见)。</li><li>n个叶子节点的哈夫曼树共有 <code>2 * n - 1</code>个结点。</li><li>哈夫曼树的任意非叶子结点的左右子树交换后仍是哈夫曼树。</li><li>对同一组权值的，可能存在不同结构的几棵哈夫曼树，但是它们的WPL是相同的。</li></ol><p>性质2推导:根据哈夫曼树没有度为1的结点，则 n1 = 0，又根据 n0 = n2 + 1，sum = n0 + n1 + n2，则有:</p><pre><code>sum = n0 + n1 + n2    = n0 + n2    = n0 + n0 - 1    = 2 * n0 - 1    = 2 * n - 1 // n即n0</code></pre><p>图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片<br><img src alt></p><p>图a的WPL为 5 <em> 2 + 7 </em> 2 + 2 <em> 2 + 13 </em> 2 = 54<br>图b的WPL为 13 <em> 1 + 7 </em> 2 + 2 <em> 3 + 5 </em> 3 = 48<br>PL的计算方式为:该节点的权值 * 从根节点到该节点的树枝数量</p><p>哈夫曼树的构造:每次把权值最小的两个二叉树合并，参照最大堆的调整。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p><p>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）每个红色节点必须有两个黑色的子节点。<br>（5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。  </p><p>一棵n个结点是红黑树始终保持了logn的高度,所以红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</p><p>红黑树之所以是平衡的二叉查找树，是因为每个节点都有表示其颜色的域值：红或黑，在插入和删除操作的时候依据节点的颜色向平衡的方向调整。</p><p><img src="http://static.chenyalun.com/2017/04/21/170421007.png" alt></p><p>“叶结点” 或”NULL结点”，它不包含数据而只充当树在此结束的指示，这些结点以及它们的父结点，在绘图中都会经常被省略。</p><p>当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。 为了继续保持红黑树的性质，我们可以通过对结点进行重新着色，以及对树进行相关的旋转操作</p><p>左旋:左右左<br>右旋:右左右</p><h2 id="多路查找树-B树"><a href="#多路查找树-B树" class="headerlink" title="多路查找树(B树)"></a>多路查找树(B树)</h2><p>B树即为B-树、B_树,又叫平衡多路查找树.<br>多路查找树:其每一个结点的孩子数可以多于两个,每一个结点处可以存储多个元素.</p><p>一个节点只能存储一个元素,在元素非常多的时候,就使得要么树的度非常大,要么树的高度非常大,甚至两者都必须足够大才可以,这使得内存存取外村次数非常多,造成了时间效率上的瓶颈,于是引入多路查找树.</p><p>树的高度越高，查找文件所需要的磁盘IO读写次数越多，所以为了减少磁盘的IO读写，要想办法进一步降低树的高度。 因此，具有多个孩子的B树便应运而生，因为B树每一个结点可以有几个到几千个孩子，使得在结点数目一定的情况下，树的高度会大大降低，从而有效减少磁盘IO读写消耗。</p><p>B+树、B树等的根结点和部分顶层数据存在内存中，大部分下层数据存在磁盘上。</p><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>2-3树是这样一棵多路查找树:其中的每一个结点都具有两个孩子或三个孩子.</p><ol><li><p>一个2结点包含一个元素和两个孩子(或没有孩子),与二叉排序树类似,左子树包含的元素小于该元素,右子树包含的元素大于该元素,与二叉排序树不同的是,这个2结点要么没有孩子,要么就有两个,不能只有一个孩子.</p></li><li><p>一个3结点包含一小一大两个元素和三个孩子(或没有孩子),一个3结点要么没有孩子,要么具有3个孩子.如果具有3个孩子的话,左子树包含的元素小于较小元素的元素,右子树包含的元素大于较大元素的元素,中间子树包含介于两元素之间的元素.</p></li><li><p>并且2-3树中所有叶子都在同一层次上.</p></li></ol><p>2-3树的插入</p><p>2-3树的删除</p><h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p>2-3树的概念扩展,包括了4结点的使用.一个4结点包含小中大三个元素和四个孩子(或者没有孩子).</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树是一种平衡的多路查找树,2-3树和2-3-4树都是B树的特例.<br>结点最大的孩子数目称为B树的阶.<br>2-3树是3阶B树,2-3-4树是4阶B树.</p><p>A B-tree of order m is a tree which satisfies the following properties:</p><pre><code>Every node has at most m children.Every non-leaf node (except root) has at least ⌈m/2⌉ children.The root has at least two children if it is not a leaf node.A non-leaf node with k children contains k−1 keys.All leaves appear in the same level</code></pre><p>一棵m阶的B树满足以下条件<br>1.每个结点至多有m棵子树<br>2.除根结点外,其他分支结点至少有ceil(m/2)棵子树(ceil()函数向上取整<br>3.根结点至少有两棵子树,除非树只包含一个结点<br>4.有k个孩子的非叶结点有k-1个关键码,关键码按递增次序排列<br>5.所有叶子结点在同一层</p><h4 id="B树如何做到减少访问外存次数"><a href="#B树如何做到减少访问外存次数" class="headerlink" title="B树如何做到减少访问外存次数"></a>B树如何做到减少访问外存次数</h4><p>硬盘将信息分割成相等大小的页面,每次硬盘读写都是一个或者多个完整的页面,对一个硬盘来说,一页的长度可能是211到214字节.</p><p>在一个典型的B树应用中,要处理的硬盘数据量很大,因此无法一次全部装入内存,因此需要对B树进行调整,使得B树的阶树与硬盘存储的页面大小相匹配.在有限内存的情况下,每一次磁盘的访问我们都可以获得最大量的数据,由于B树每节点可以具有比二叉树多得多的元素,所以减少了必须访问结点和数据块的数量,提高了性能.<br>B树的数据结构就是为内外存的数据交互准备的.</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+ 树是一种树数据结构，通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。</p><p>B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。</p><p>一棵m阶的B+树与B树的区别在于:</p><ol><li>有n棵子树的结点包含有n个关键字</li><li>所有的叶子节点包含全部的关键字信息,以及指向含这些关键字记录的指针,叶子节点本身依关键字的大小自小而大顺序链接</li><li>所有分支结点可以看成是索引,结点中仅含有其子树的最大(最小)关键字.</li></ol><p>好处:<br>如果要随机查找,就从根节点出发,与B树的查找方式相同,只不过即使在分支结点找到了待查找的关键字,它也只是用来索引的,不能提供实际记录的访问,还是需要到达包含此关键字的终端结点.</p><p>如果需要从最小关键字进行自小而大的顺序查找,可以从最左端的叶子结点出发,不经过分支结点,而是沿着指向下一叶子的指针就可遍历所有的关键字.</p><p>B+树适合有范围的查找(比如年龄18–22),从根节点出发找到18,再在叶子结点中按顺序找到符合要求的记录.</p><p>B+树的插入/删除与B树类似,只不过插入删除的元素都是在叶子结点上进行.</p><h2 id="散列表查找"><a href="#散列表查找" class="headerlink" title="散列表查找"></a>散列表查找</h2><p>存储位置 = f(关键字)</p><p>记录的存储位置和它的关键字之间建立的一个确定的对应关系.每个关键字key对应一个存储位置f(key),查找时根据这个确定的对应关系找到给定key的映射f(key).</p><p>f称为散列函数,又称哈希函数,采用散列技术将记录存储在一块连续的存储空间中,这块连续的存储空间称为散列表或哈希表,关键字对应的记录存储位置称为散列地址.</p><p>冲突:key1不等于key2,但是f(key1)=f(key2),key1和key2称为散列函数的同义词.</p><h3 id="常用的散列函数"><a href="#常用的散列函数" class="headerlink" title="常用的散列函数"></a>常用的散列函数</h3><h4 id="1-直接定址法"><a href="#1-直接定址法" class="headerlink" title="1.直接定址法"></a>1.直接定址法</h4><pre><code>f(key) = a * key + b  (a,b为常数)</code></pre><ul><li>优点:简单均匀,不会产生冲突,但需要事先知道关键字的分布情况,适合查找表较小且连续的情况.</li></ul><h4 id="2-数字分析法"><a href="#2-数字分析法" class="headerlink" title="2.数字分析法"></a>2.数字分析法</h4><p>手机号码等,对数字进行抽取,反转,左环位移,右环位移等方式合理地将关键字分配到散列表的各位置.</p><ul><li>适合处理关键字位数比较大的情况,如果事先知道关键字的分布且关键字的若干位分布均匀,可以使用.</li></ul><h4 id="3-平方取中法"><a href="#3-平方取中法" class="headerlink" title="3.平方取中法"></a>3.平方取中法</h4><p>关键字1234—-&gt;平方后:1522756—–&gt;抽取中间的3位——&gt;227,用作散列地址.</p><ul><li>适合不知道关键字的分布,而位数又不是很大的情况</li></ul><h4 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="4.折叠法"></a>4.折叠法</h4><p>从左到右分割成位数相等的几部分,叠加求和,按照散列表长,取后几位作为散列地址.</p><p>9876543210—–&gt;987  654  321 0—–&gt;求和987+654+321+0=1962,求后三位:962</p><ul><li>适合不需要事先知道关键字的分布.适合关键字位数较多的情况.</li></ul><h4 id="5-除留余数法"><a href="#5-除留余数法" class="headerlink" title="5.除留余数法"></a>5.除留余数法</h4><p>最常用,散列表长为m的公式:</p><pre><code>f(key) = key mod p (p&lt;=m)</code></pre><ul><li>若散列表表长m,通常p为小于或者等于表长的最小质数或不包含小于20质因子的合数.</li></ul><h4 id="6-随机数法"><a href="#6-随机数法" class="headerlink" title="6.随机数法"></a>6.随机数法</h4><pre><code>f(key) = random(key)</code></pre><ul><li>当关键字的长度不等时,采用这个方法.</li></ul><h3 id="常用的处理冲突方法"><a href="#常用的处理冲突方法" class="headerlink" title="常用的处理冲突方法"></a>常用的处理冲突方法</h3><h4 id="1-开放定址法"><a href="#1-开放定址法" class="headerlink" title="1.开放定址法"></a>1.开放定址法</h4><p>线性探测法</p><pre><code>f(key) = (f(key) + d) mod m  (d = 1,2,3...)</code></pre><p>二次探测法</p><pre><code>f(key) = (f(key) + d) mod m  (d = 1^2,-1^2,2^2,-2^2,3^2,-3^2...q^2,-q^2,其中q&lt;=m/2)</code></pre><p>随机探测法</p><pre><code>f(key) = (f(key) + d) mod m  (d 是一个随机数列)</code></pre><h4 id="2-再散列函数法"><a href="#2-再散列函数法" class="headerlink" title="2.再散列函数法"></a>2.再散列函数法</h4><pre><code>f(key) = RH(key)</code></pre><p>每次发生散列冲突时,就换一个散列函数计算.</p><h4 id="3-链地址法"><a href="#3-链地址法" class="headerlink" title="3.链地址法"></a>3.链地址法</h4><p>提供绝不会找不到地址的保障,但是带来查找时需要遍历单链表的性能损耗.</p><h4 id="4-公共溢出区法"><a href="#4-公共溢出区法" class="headerlink" title="4.公共溢出区法"></a>4.公共溢出区法</h4><p>增添溢出表.<br>对给定值通过散列函数计算出散列地址后,先与基本表的相应位置进行比对,如果相等,成功,否则,到溢出表中进行<strong>顺序查找</strong>.    </p><blockquote><p>参考并致谢<br><a href="https://www.zhihu.com/question/19809666/answer/88158084" target="_blank" rel="noopener">知乎 灰杉树</a><br><a href="http://haiyangxu.github.io/posts/2014/2014-05-05-binary_search_tree.html" target="_blank" rel="noopener">HAIYANG XU</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="noopener">v_JULY_v</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt; 关于查找算法。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
