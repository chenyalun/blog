<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ya</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.chenyalun.com/"/>
  <updated>2018-08-26T06:33:45.735Z</updated>
  <id>http://blog.chenyalun.com/</id>
  
  <author>
    <name>Ya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读「YYModel」</title>
    <link href="http://blog.chenyalun.com/2018/07/10/%E8%AF%BB%E3%80%8CYYModel%E3%80%8D/"/>
    <id>http://blog.chenyalun.com/2018/07/10/读「YYModel」/</id>
    <published>2018-07-10T15:02:17.000Z</published>
    <updated>2018-08-26T06:33:45.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018.8.26 更新Class定义</p></blockquote><p></p><p align="center"> 关于YYModel和Runtime的简单总结。 </p><br><a id="more"></a><p></p><p>核心是运用runtime获取类结构体中Ivars，进行KVC操作，然后根据不同情况进行分别处理。</p><p>代码中省略<code>OBJC2_UNAVAILABLE</code>,也即不可直接访问结构体中的成员.</p><h2 id="一、Runtime"><a href="#一、Runtime" class="headerlink" title="一、Runtime"></a>一、Runtime</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">Objective-C2<span class="number">.0</span>之前Class的定义</div><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    <span class="comment">// 父类</span></div><div class="line">    Class super_class;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">long</span> version;</div><div class="line">    <span class="keyword">long</span> info;</div><div class="line">    <span class="keyword">long</span> instance_size;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists;</div><div class="line">    <span class="comment">// 方法缓存</span></div><div class="line">    <span class="keyword">struct</span> objc_cache *cache;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_cache &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied;</div><div class="line">    Method buckets[<span class="number">1</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">根据源码，最新定义大致如下:</div><div class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</div><div class="line">    <span class="comment">// Class ISA;</span></div><div class="line">    Class isa;</div><div class="line">    Class superclass;</div><div class="line">    <span class="keyword">cache_t</span> cache;<span class="comment">// 方法缓存</span></div><div class="line">    <span class="keyword">class_data_bits_t</span> bits; <span class="comment">// 用于获取具体的类信息</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"> YAPerson *person = [[YAPerson alloc] init];</div><div class="line">    Class cls = [person <span class="keyword">class</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 获取实例对象对应的Class</span></div><div class="line">    Class class1 = object_getClass(person);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取指定名称的类对象</span></div><div class="line">    Class class3 = objc_getClass(<span class="string">"YAPerson"</span>);</div><div class="line">    Class class2 = objc_getRequiredClass(<span class="string">"YAPerson"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取指定名称的元类对象</span></div><div class="line">    Class class4 = objc_getMetaClass(<span class="string">"YAPerson"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 找到指定名称的类对象</span></div><div class="line">    Class class5 = objc_lookUpClass(<span class="string">"NSObject"</span>);</div><div class="line">    NSLog(@<span class="string">"%@%@%@%@%@"</span>,class1,class2,class3,class4,class5);</div><div class="line">    </div><div class="line">    <span class="comment">// 设置对象对应的Class,返回原先的class</span></div><div class="line">    Class oriClass = object_setClass(person, [NSObject <span class="keyword">class</span>]);</div><div class="line"></div><div class="line">    <span class="comment">// 是否是类对象或元类对象</span></div><div class="line">    BOOL isClass = object_isClass(person);</div><div class="line">    </div><div class="line">    <span class="comment">// 是否是元类对象</span></div><div class="line">    BOOL isMetaClass = class_isMetaClass(class4);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取父类</span></div><div class="line">    Class superClass = class_getSuperclass(cls);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取类的版本</span></div><div class="line">    <span class="keyword">int</span> version = class_getVersion(cls);</div><div class="line">    <span class="comment">// 设置类的版本</span></div><div class="line">    class_setVersion(cls, <span class="number">88</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 获取实例大小</span></div><div class="line">    <span class="keyword">typedef</span> <span class="number">__</span>SIZE_TYPE__ <span class="keyword">size_t</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">size_t</span> size = class_getInstanceSize(cls);</div><div class="line">    </div><div class="line"><span class="comment">//    int objc_getClassList(Class *buffer, int bufferCount)</span></div><div class="line"><span class="comment">//    </span></div><div class="line"><span class="comment">//    Class *objc_copyClassList(unsigned int *outCount)</span></div><div class="line"><span class="comment">//    </span></div><div class="line">    <span class="comment">// 获取类的名称</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = class_getName(cls);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 动态创建类</span></div><div class="line">    <span class="comment">//Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</span></div><div class="line">    <span class="comment">//void objc_registerClassPair(Class cls)</span></div><div class="line">    </div><div class="line">    <span class="comment">// 动态废弃类</span></div><div class="line">    <span class="comment">//Class objc_duplicateClass(Class original, const char *name, size_t extraBytes)</span></div><div class="line">    <span class="comment">//void objc_disposeClassPair(Class cls)</span></div><div class="line">    </div><div class="line"></div><div class="line">    <span class="comment">//id o = objc_storeWeak(&amp;weakObject, weakObject);</span></div><div class="line">    <span class="comment">//id result = objc_loadWeak(&amp;weakObject);</span></div></pre></td></tr></table></figure><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><div class="line">给<span class="keyword">block创建一个关联的函数指针</span></div><div class="line"><span class="symbol">IMP</span> imp_implementationWithBlock(id <span class="keyword">block)</span></div><div class="line"></div><div class="line">获取函数指针关联的<span class="keyword">block</span></div><div class="line"><span class="symbol">id</span> imp_getBlock(IMP anImp)</div><div class="line"></div><div class="line">移除函数指针对应的<span class="keyword">block</span></div><div class="line"><span class="keyword">BOOL </span>imp_removeBlock(IMP anImp)</div></pre></td></tr></table></figure><p>实例演练</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 声明block</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^Block) ();</div><div class="line"></div><div class="line"><span class="comment">// 定义block</span></div><div class="line">Block block = ^() &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"哈哈哈"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 给block创建一个关联的函数指针</span></div><div class="line">IMP imp = imp_implementationWithBlock(block);</div><div class="line"><span class="comment">// 调用block</span></div><div class="line">(*imp)();</div><div class="line"></div><div class="line"><span class="comment">// 获取函数指针关联的block</span></div><div class="line"><span class="keyword">id</span> blockObject = imp_getBlock(imp);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,blockObject);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 移除函数指针对应的block</span></div><div class="line"><span class="built_in">BOOL</span> isRemoveBlock = imp_removeBlock(imp);</div><div class="line"><span class="keyword">if</span> (isRemoveBlock) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"成功移除"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><div class="line">获取<span class="keyword">SEL的名称(char </span>*类型)</div><div class="line"><span class="symbol">const</span> char *<span class="keyword">sel_getName(SEL </span><span class="keyword">sel)</span></div><div class="line"></div><div class="line">注册<span class="keyword">SEL</span></div><div class="line"><span class="keyword">SEL </span><span class="keyword">sel_registerName(const </span>char *<span class="keyword">str)</span></div><div class="line"></div><div class="line">比较<span class="keyword">SEL</span></div><div class="line"><span class="keyword">BOOL </span><span class="keyword">sel_isEqual(SEL </span>lhs, <span class="keyword">SEL </span>rhs)</div></pre></td></tr></table></figure><p>实例演练</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取SEL的名称(char *类型)</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *selName = sel_getName(<span class="keyword">@selector</span>(viewWillAppear:));</div><div class="line">printf(<span class="string">"%s"</span>,selName);</div><div class="line"></div><div class="line"><span class="comment">// 注册SEL</span></div><div class="line">SEL newSel = sel_registerName(<span class="string">"haha"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 比较SEL</span></div><div class="line"><span class="built_in">BOOL</span> isEqual = sel_isEqual(<span class="keyword">@selector</span>(viewWillAppear:), newSel);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,isEqual);</div></pre></td></tr></table></figure><h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><div class="line">定义一个objc_ivar结构体指针Ivar</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_ivar &#123;</div><div class="line">    成员变量名称</div><div class="line">    <span class="keyword">char</span> *ivar_name;</div><div class="line">    成员变量类型                                         </div><div class="line">    <span class="keyword">char</span> *ivar_type;                                          </div><div class="line">    偏移量</div><div class="line">    <span class="keyword">int</span> ivar_offset;                                          </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space;                                                </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line">关于偏移量的定义(就是整型)</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__PTRDIFF_TYPE__)</span></div><div class="line">    <span class="keyword">typedef</span> __PTRDIFF_TYPE____darwin_ptrdiff_t;<span class="comment">/* ptr1 - ptr2 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__LP64__)</span></div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span>__darwin_ptrdiff_t;<span class="comment">/* ptr1 - ptr2 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span>__darwin_ptrdiff_t;<span class="comment">/* ptr1 - ptr2 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __GNUC__ */</span></span></div><div class="line">    </div><div class="line">    </div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _PTRDIFF_T</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _PTRDIFF_T</span></div><div class="line">    <span class="keyword">typedef</span> __darwin_ptrdiff_t ptrdiff_t;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _PTRDIFF_T */</span></span></div><div class="line"></div><div class="line"></div><div class="line">成员变量列表</div><div class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</div><div class="line">    成员变量数量</div><div class="line">    <span class="keyword">int</span> ivar_count;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* variable length structure */</span></div><div class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>];</div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line">获取实例变量</div><div class="line">Ivar class_getInstanceVariable(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">    </div><div class="line"><span class="comment">//获取类变量</span></div><div class="line"><span class="comment">//Ivar class_getClassVariable(Class cls, const char *name)</span></div><div class="line">    </div><div class="line">获取成员变量列表</div><div class="line">Ivar *class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div><div class="line">   </div><div class="line">获取Ivar变量的名称</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getName(Ivar v)</div><div class="line">    </div><div class="line">获取Ivar变量的偏移量</div><div class="line">ptrdiff_t ivar_getOffset(Ivar v)</div><div class="line">    </div><div class="line">获取Ivar变量的编码</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getTypeEncoding(Ivar v)</div><div class="line">    </div><div class="line">设置成员变量的值</div><div class="line"><span class="keyword">void</span> object_setIvarWithStrongDefault(id obj, Ivar ivar, id value)</div><div class="line"></div><div class="line">设置成员变量的值</div><div class="line"><span class="keyword">void</span> object_setIvar(id obj, Ivar ivar, id value)</div><div class="line"></div><div class="line">获取Ivar对应的成员变量对象</div><div class="line">id object_getIvar(id obj, Ivar ivar)</div><div class="line"></div><div class="line">IvarLayout相关</div><div class="line"><span class="keyword">const</span> uint8_t *class_getIvarLayout(Class cls)</div><div class="line"><span class="keyword">const</span> uint8_t *class_getWeakIvarLayout(Class cls)</div><div class="line"><span class="keyword">void</span> class_setIvarLayout(Class cls, <span class="keyword">const</span> uint8_t *layout)</div><div class="line"><span class="keyword">void</span> class_setWeakIvarLayout(Class cls, <span class="keyword">const</span> uint8_t *layout)</div><div class="line">    </div><div class="line">添加成员变量</div><div class="line">BOOL class_addIvar(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t <span class="built_in">size</span>,</div><div class="line">                  uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types)</div></pre></td></tr></table></figure><p>实例演示</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line"></div><div class="line">    YAPerson *person = [[YAPerson alloc] init];</div><div class="line">    Class cls = [person <span class="keyword">class</span>];</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 获取实例变量</span></div><div class="line">    Ivar ivar_num = class_getInstanceVariable(cls, <span class="string">"num"</span>);</div><div class="line">    </div><div class="line">    Ivar ivar_name = class_getInstanceVariable(cls, <span class="string">"name"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//获取类变量</span></div><div class="line">    <span class="comment">//Ivar class_getClassVariable(Class cls, const char *name)</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取Ivar变量的名称</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar_name);</div><div class="line">    printf(<span class="string">"%s\n"</span>,name);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取Ivar变量的偏移量</span></div><div class="line">    ptrdiff_t p = ivar_getOffset(ivar_num);</div><div class="line">    printf(<span class="string">"%td"</span>,p); <span class="comment">// 打印16</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取Ivar变量的编码</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = ivar_getTypeEncoding(ivar_name);</div><div class="line">    printf(<span class="string">"%s\n"</span>,typeEncoding); <span class="comment">// 打印 @"NSString"</span></div><div class="line">    </div><div class="line">    <span class="comment">// 设置成员变量的值</span></div><div class="line">    object_setIvarWithStrongDefault(person, ivar_name, <span class="string">@"haha"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person-&gt;name);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 设置成员变量对应的值</span></div><div class="line">    object_setIvar(person, ivar_name, <span class="string">@"hahaaaaaa"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person-&gt;name);</div><div class="line">    </div><div class="line">    <span class="comment">//获取Ivar对应的成员变量对象</span></div><div class="line">    <span class="keyword">id</span> object = object_getIvar(person, ivar_name);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,object);</div><div class="line">    </div><div class="line">    <span class="comment">// 动态添加成员变量</span></div><div class="line">    <span class="comment">// 必须在 objc_allocateClassPair 之后 和 在objc_registerClassPair之前调用</span></div><div class="line">    <span class="comment">// 不能给一个已经存在的类添加成员变量</span></div><div class="line">    Class peopleClass = objc_allocateClassPair(cls, <span class="string">"YAPeople"</span>, <span class="number">0</span>);</div><div class="line">    class_addIvar(peopleClass, <span class="string">"_gayFriend"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</div><div class="line">    class_addIvar(peopleClass, <span class="string">"_girlFriend"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</div><div class="line">    class_addIvar(peopleClass, <span class="string">"_company"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</div><div class="line">    objc_registerClassPair(peopleClass);</div><div class="line">    <span class="comment">// 打印成员变量列表</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="keyword">self</span> ya_getIvarList:peopleClass]);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// IvarLayout相关</span></div><div class="line">    <span class="comment">// ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型</span></div><div class="line">    <span class="keyword">const</span> uint8_t *ivarLayoutArray= class_getIvarLayout(cls);</div><div class="line">    <span class="keyword">const</span> uint8_t *weakIvarLayoutArray = class_getWeakIvarLayout(cls);</div><div class="line">    <span class="keyword">if</span> (ivarLayoutArray) &#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        uint8_t value_s = ivarLayoutArray[i];</div><div class="line">        <span class="keyword">while</span> (value_s != <span class="number">0x0</span>) &#123;</div><div class="line">            printf(<span class="string">"\\x%02x\n"</span>, value_s);</div><div class="line">            value_s = ivarLayoutArray[++i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//void class_setIvarLayout(Class cls, const uint8_t *layout)</span></div><div class="line">    <span class="comment">//void class_setWeakIvarLayout(Class cls, const uint8_t *layout)</span></div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 根据class获取成员变量列表</div><div class="line"> </div><div class="line"> @param class 类</div><div class="line"> @return 成员变量字典(名称:类型)</div><div class="line"> */</div><div class="line">- (<span class="built_in">NSDictionary</span> *)ya_getIvarList:(Class)<span class="keyword">class</span> &#123;</div><div class="line">    <span class="comment">// 成员变量数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 获取成员变量列表</span></div><div class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">class</span>, &amp;count);</div><div class="line">    </div><div class="line">    <span class="comment">// 存储成员变量</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    </div><div class="line">    <span class="comment">// 获取成员变量类型与成员变量名称</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="comment">// 成员变量类型</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *c_ivarType = ivar_getTypeEncoding(ivarList[i]);</div><div class="line">        </div><div class="line">        <span class="comment">// 成员变量名称</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *c_ivarName = ivar_getName(ivarList[i]);</div><div class="line">        </div><div class="line">        <span class="comment">// 利用字典存储,格式为 成员变量名称:对应的成员变量类型</span></div><div class="line">        <span class="built_in">NSString</span> *ivarName = [<span class="built_in">NSString</span> stringWithUTF8String:c_ivarName];</div><div class="line">        dict[ivarName] = [<span class="built_in">NSString</span> stringWithUTF8String:c_ivarType];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 需要手动free</span></div><div class="line">    free(ivarList);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:dict];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>值得一提的是方法编码和类型编码:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ID       <span class="meta-string">'@'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CLASS    <span class="meta-string">'#'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_SEL      <span class="meta-string">':'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CHR      <span class="meta-string">'c'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UCHR     <span class="meta-string">'C'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_SHT      <span class="meta-string">'s'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_USHT     <span class="meta-string">'S'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_INT      <span class="meta-string">'i'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UINT     <span class="meta-string">'I'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_LNG      <span class="meta-string">'l'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ULNG     <span class="meta-string">'L'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_LNG_LNG  <span class="meta-string">'q'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ULNG_LNG <span class="meta-string">'Q'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_FLT      <span class="meta-string">'f'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_DBL      <span class="meta-string">'d'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_BFLD     <span class="meta-string">'b'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_BOOL     <span class="meta-string">'B'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_VOID     <span class="meta-string">'v'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UNDEF    <span class="meta-string">'?'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_PTR      <span class="meta-string">'^'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CHARPTR  <span class="meta-string">'*'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ATOM     <span class="meta-string">'%'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ARY_B    <span class="meta-string">'['</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_ARY_E    <span class="meta-string">']'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UNION_B  <span class="meta-string">'('</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_UNION_E  <span class="meta-string">')'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_STRUCT_B <span class="meta-string">'&#123;'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_STRUCT_E <span class="meta-string">'&#125;'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_VECTOR   <span class="meta-string">'!'</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_CONST    <span class="meta-string">'r'</span></span></div></pre></td></tr></table></figure><table><thead><tr><th>Code</th><th>Meaning</th></tr></thead><tbody><tr><td>r</td><td>const</td></tr><tr><td>n</td><td>in</td></tr><tr><td>N</td><td>inout</td></tr><tr><td>o</td><td>out</td></tr><tr><td>O</td><td>bycopy</td></tr><tr><td>R</td><td>byref</td></tr><tr><td>V</td><td>oneway</td></tr></tbody></table><p>以上信息在具体应用时,可以自定义一个枚举获取.</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><div class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></div><div class="line"></div><div class="line"></div><div class="line">struct objc_method <span class="comment">&#123;</span></div><div class="line">    // 方法的名称</div><div class="line">    SEL method_name;                                          </div><div class="line">    // 方法的参数类型</div><div class="line">    char *method_types;                                       </div><div class="line">    // 方法的实现(函数指针)</div><div class="line">    IMP method_imp;                                           </div><div class="line">&#125;                                                            </div><div class="line"></div><div class="line">根据方法名称获取<span class="function"><span class="keyword">Method</span></span></div><div class="line"><span class="title">Method</span> <span class="title">class_getInstanceMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span></div><div class="line"><span class="title">Method</span> <span class="title">class_getClassMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span></div><div class="line"></div><div class="line">获取<span class="title">Method</span>的方法名称</div><div class="line"><span class="title">SEL</span> <span class="title">method_getName</span><span class="params">(<span class="keyword">Method</span> m)</span></div><div class="line"></div><div class="line">获取<span class="title">Method</span>的方法实现</div><div class="line"><span class="title">IMP</span> <span class="title">method_getImplementation</span><span class="params">(<span class="keyword">Method</span> m)</span> </div><div class="line"><span class="title">IMP</span> <span class="title">class_getMethodImplementation</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span> </div><div class="line"></div><div class="line">获取<span class="title">Method</span>的返回值类型<span class="params">(需手动释放)</span></div><div class="line"><span class="title">char</span> *<span class="title">method_copyReturnType</span><span class="params">(<span class="keyword">Method</span> m)</span></div><div class="line">//<span class="title">void</span> <span class="title">method_getReturnType</span><span class="params">(<span class="keyword">Method</span> m, char *dst, size_t dst_len)</span></div><div class="line"></div><div class="line">获取指定<span class="title">Method</span>的类型</div><div class="line"><span class="title">const</span> <span class="title">char</span> *<span class="title">method_getTypeEncoding</span><span class="params">(<span class="keyword">Method</span> m)</span> </div><div class="line"></div><div class="line">获取<span class="title">Method</span>的参数数量</div><div class="line"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">method_getNumberOfArguments</span><span class="params">(<span class="keyword">Method</span> m)</span></div><div class="line"></div><div class="line">获取<span class="title">Method</span>中第<span class="title">i</span>个参数的类型<span class="params">(Char *类型)</span><span class="params">(需手动释放)</span></div><div class="line"><span class="title">char</span> *<span class="title">method_copyArgumentType</span><span class="params">(<span class="keyword">Method</span> m, unsigned int <span class="keyword">index</span>)</span> </div><div class="line"></div><div class="line">获取方法列表</div><div class="line"><span class="title">Method</span> *<span class="title">class_copyMethodList</span><span class="params">(<span class="keyword">Class</span> cls, unsigned int *outCount)</span> </div><div class="line"></div><div class="line">设置<span class="title">IMP</span></div><div class="line"><span class="title">IMP</span> <span class="title">method_setImplementation</span><span class="params">(<span class="keyword">Method</span> m, IMP imp)</span></div><div class="line"></div><div class="line">交换方法实现</div><div class="line"><span class="title">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(<span class="keyword">Method</span> m1, <span class="keyword">Method</span> m2)</span> </div><div class="line"></div><div class="line">添加方法</div><div class="line"><span class="title">BOOL</span> <span class="title">class_addMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name, IMP imp, </span></div><div class="line">                                 <span class="keyword">const</span> char *types) </div><div class="line">替换方法                                 </div><div class="line"><span class="title">IMP</span> <span class="title">class_replaceMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name, IMP imp, </span></div><div class="line">                                    <span class="keyword">const</span> char *types) </div><div class="line"></div><div class="line"></div><div class="line">标明需要手动释放的动态内存<span class="params">(如返回值类型/参数类型)</span></div><div class="line">// 及时释放</div><div class="line"><span class="title">if</span> <span class="params">(argumentType)</span> <span class="title">free</span><span class="params">(argumentType)</span>;</div></pre></td></tr></table></figure><p>实例演示</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    YAPerson *person = [[YAPerson alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">// 获取Method</span></div><div class="line">    Method method = class_getInstanceMethod([person <span class="keyword">class</span>] , <span class="built_in">NSSelectorFromString</span>(<span class="string">@"nameWithArg:arg:arg:arg:arg:"</span>));</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="comment">// 获取Method的方法名称</span></div><div class="line">    SEL sel = method_getName(method);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromSelector</span>(sel));</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="comment">// 获取Method的方法实现</span></div><div class="line">    IMP imp1 = method_getImplementation(method);</div><div class="line">    IMP imp2 = class_getMethodImplementation([person <span class="keyword">class</span>],sel);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 获取Method的返回值类型(需手动释放)</span></div><div class="line">    <span class="keyword">char</span> *returnType = method_copyReturnType(method);</div><div class="line">    <span class="keyword">if</span> (returnType) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSString</span> stringWithUTF8String:returnType]);</div><div class="line">        free(returnType);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 获取指定Method的类型</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(method);</div><div class="line">    <span class="keyword">if</span> (typeEncoding) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSString</span> stringWithUTF8String:typeEncoding]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 获取Method的参数数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> arguementCount = method_getNumberOfArguments(method);</div><div class="line">    <span class="keyword">if</span> (arguementCount &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguementCount; i++) &#123;</div><div class="line">            <span class="comment">//获取Method中第i个参数的类型(Char *类型)(需手动释放)</span></div><div class="line">            <span class="keyword">char</span> *arguementType = method_copyArgumentType(method, i);</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSString</span> stringWithUTF8String:arguementType]);</div><div class="line">            </div><div class="line">            <span class="comment">// 手动释放</span></div><div class="line">            <span class="keyword">if</span> (arguementType) &#123;</div><div class="line">                free(arguementType);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="comment">// 设置新的方法实现IMP,并返回原先的IMP</span></div><div class="line">    IMP imp3 = method_setImplementation(method, imp2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> Method Swizzling</div><div class="line"> 一般放在load方法中,并且使用dispatch_once,需要调用 class_addMethod 方法</div><div class="line"> */</div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line"> </div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        Class cls = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">        </div><div class="line">        SEL oldSelector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"XXXX"</span>);</div><div class="line">        SEL newSelector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"XXXXXXXX"</span>);</div><div class="line">        </div><div class="line">        Method oldMethod = class_getInstanceMethod(cls, oldSelector);</div><div class="line">        Method newMethod = class_getInstanceMethod(cls, newSelector);</div><div class="line">        </div><div class="line">        <span class="comment">// 尝试给旧的方法oldSelector添加新的方法newSelectot的实现,如果已经存在方法实现,则添加失败</span></div><div class="line">        <span class="built_in">BOOL</span> isSuccess = class_addMethod(cls, oldSelector, method_getImplementation(newMethod), method_getTypeEncoding(newMethod));</div><div class="line">        <span class="keyword">if</span> (isSuccess) &#123; <span class="comment">// 添加成功,那么用旧的方法实现替换新的方法实现</span></div><div class="line">            class_replaceMethod(cls, newSelector, method_getImplementation(oldMethod), method_getTypeEncoding(oldMethod));</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 旧的方法已经有了实现,直接交换即可</span></div><div class="line">            method_exchangeImplementations(newMethod, oldMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line"><span class="comment">/*    </span></div><div class="line"></div><div class="line">使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全地替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现。</div><div class="line"></div><div class="line">Swizzling应该总是在+load中执行</div><div class="line">在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证–事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</div><div class="line"></div><div class="line"></div><div class="line">Swizzling应该总是在dispatch_once中执行</div><div class="line">与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。</div><div class="line"></div><div class="line"></div><div class="line">*/</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 根据class获取方法列表</div><div class="line"> </div><div class="line"> @param class 类</div><div class="line"> @return 方法名称数组</div><div class="line"> */</div><div class="line"></div><div class="line">+ (<span class="built_in">NSArray</span> *)ya_getMethodList:(Class)<span class="keyword">class</span> &#123;</div><div class="line">    <span class="comment">// 方法列表数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 获取方法列表</span></div><div class="line">    Method *methodList = class_copyMethodList(<span class="keyword">class</span>, &amp;methodCount);</div><div class="line">    </div><div class="line">    <span class="comment">// 存储方法名称</span></div><div class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    <span class="keyword">if</span> (methodList) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i ++) &#123;</div><div class="line">            <span class="comment">// 获取方法</span></div><div class="line">            Method method = methodList[i];</div><div class="line">            <span class="comment">// 获取方法名称</span></div><div class="line">            SEL sel = method_getName(method);</div><div class="line">            </div><div class="line">            [array addObject:<span class="built_in">NSStringFromSelector</span>(sel)];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 手动释放</span></div><div class="line">        free(methodList);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:array];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 交换实例方法实现</div><div class="line"> </div><div class="line"> @param class 类</div><div class="line"> @param aSEL 方法一的名称</div><div class="line"> @param bSEL 方法二的名称</div><div class="line"> */</div><div class="line">+ (<span class="keyword">void</span>)ya_exchangeInstanceMethod:(Class)<span class="keyword">class</span> firstMethod:(SEL)aSEL secondMethod:(SEL)bSEL &#123;</div><div class="line">    Method aMethad = class_getInstanceMethod(<span class="keyword">class</span>, aSEL);</div><div class="line">    Method bMethod = class_getInstanceMethod(<span class="keyword">class</span>, bSEL);</div><div class="line">    </div><div class="line">    <span class="comment">// 交换方法实现</span></div><div class="line">    method_exchangeImplementations(aMethad, bMethod);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 交换类方法实现</div><div class="line"> </div><div class="line"> @param class 类</div><div class="line"> @param aSEL 方法一的名称</div><div class="line"> @param bSEL 方法二的名称</div><div class="line"> */</div><div class="line">+ (<span class="keyword">void</span>)ya_exchangeClassMethod:(Class)<span class="keyword">class</span> firstMethod:(SEL)aSEL secondMethod:(SEL)bSEL &#123;</div><div class="line">    Method aMethad = class_getClassMethod(<span class="keyword">class</span>, aSEL);</div><div class="line">    Method bMethod = class_getClassMethod(<span class="keyword">class</span>, bSEL);</div><div class="line">    </div><div class="line">    <span class="comment">// 交换方法实现</span></div><div class="line">    method_exchangeImplementations(aMethad, bMethod);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 为类添加名为newSEL的(实例)方法</div><div class="line"> </div><div class="line"> @param class 类</div><div class="line"> @param aSEL 新的方法名称</div><div class="line"> @param bSEL 已经存在的方法名称</div><div class="line"> @return 是否添加成功</div><div class="line"> */</div><div class="line">+ (<span class="built_in">BOOL</span>)ya_addMethod:(Class)<span class="keyword">class</span> newSEL:(SEL)aSEL existSEL:(SEL)bSEL &#123;</div><div class="line">    <span class="comment">// 获取已经存在的方法</span></div><div class="line">    Method method = class_getInstanceMethod(<span class="keyword">class</span>, bSEL);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取已经存在的方法的实现</span></div><div class="line">    IMP imp = class_getMethodImplementation(<span class="keyword">class</span>, bSEL);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取type</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type = method_getTypeEncoding(method);</div><div class="line">    </div><div class="line">    <span class="comment">// 给class添加名称为aSEL的方法实现</span></div><div class="line">    <span class="keyword">return</span> class_addMethod(<span class="keyword">class</span>, aSEL, imp, type);</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">    如果父类中已经有该名称的方法,那么调用后将重写该方法</div><div class="line">    如果本类中已经有了该名称的方法实现,那么将添加失败</div><div class="line">    */</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</div><div class="line"></div><div class="line">属性相关信息</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;         </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          </div><div class="line">&#125; objc_property_attribute_t;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">获取属性</div><div class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line"></div><div class="line">获取属性列表</div><div class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div><div class="line"></div><div class="line">获取属性信息列表</div><div class="line">objc_property_attribute_t *property_copyAttributeList(objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div><div class="line"></div><div class="line">获取属性信息中某个Value</div><div class="line"><span class="keyword">char</span> *property_copyAttributeValue(objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName)</div><div class="line"></div><div class="line">添加属性</div><div class="line"><span class="built_in">BOOL</span> class_addProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</div><div class="line"></div><div class="line">替换属性</div><div class="line"><span class="keyword">void</span> class_replaceProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</div><div class="line"></div><div class="line">获取属性名称</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property) </div><div class="line"></div><div class="line">获取属性相关信息</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getAttributes(objc_property_t property)</div></pre></td></tr></table></figure><p>实例演示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line"></div><div class="line">YAPerson *person = [[YAPerson alloc] init];</div><div class="line">    Class cls = [person <span class="keyword">class</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 获取属性</span></div><div class="line">    <span class="keyword">objc_property_t</span> property = class_getProperty(cls, <span class="string">"school"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取属性名称</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,propertyName);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取属性信息列表</span></div><div class="line">    <span class="comment">// objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取属性相关信息</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *propertyAttributes = property_getAttributes(property);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,propertyAttributes); <span class="comment">// 打印 T@"NSObject",W,N,V_school</span></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 根据获取属性信息中的name获取对应的Value</span></div><div class="line">    <span class="keyword">char</span> *propertyValue = property_copyAttributeValue(property, <span class="string">"T"</span>); <span class="comment">// 类型</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,propertyValue);</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     T 类型 例如:NSObject</div><div class="line">     V 值(成员变量) 例如 _school</div><div class="line">     C copy</div><div class="line">     N nonatommic</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="comment">// 添加属性</span></div><div class="line">    <span class="keyword">objc_property_attribute_t</span> type = &#123; <span class="string">"T"</span>, [[NSString stringWithFormat:@<span class="string">"@\"%@\""</span>,NSStringFromClass([NSString <span class="keyword">class</span>])] UTF8String] &#125;; <span class="comment">//type</span></div><div class="line">    <span class="keyword">objc_property_attribute_t</span> ownership0 = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;; <span class="comment">// C = copy</span></div><div class="line">    <span class="keyword">objc_property_attribute_t</span> ownership = &#123; <span class="string">"N"</span>, <span class="string">""</span> &#125;; <span class="comment">//N = nonatomic</span></div><div class="line">    <span class="keyword">objc_property_attribute_t</span> backingivar  = &#123; <span class="string">"V"</span>, [[NSString stringWithFormat:@<span class="string">"_%s"</span>, <span class="string">"propertyName"</span>] UTF8String] &#125;;  <span class="comment">//variable name</span></div><div class="line">    <span class="keyword">objc_property_attribute_t</span> attrs[] = &#123; type, ownership0, ownership, backingivar &#125;;</div><div class="line">    <span class="keyword">if</span> (class_addProperty(cls, <span class="string">"propertyName"</span>, attrs, <span class="number">4</span>)) &#123;</div><div class="line">        NSLog(@<span class="string">"添加成功"</span>);</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 替换属性</span></div><div class="line">    <span class="comment">//void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)</span></div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 根据class获取类的属性列表</div><div class="line"> </div><div class="line"> @param class 类</div><div class="line"> @return 属性列表数组</div><div class="line"> */</div><div class="line">+ (NSArray *)ya_getPropertyList:(Class)<span class="keyword">class</span> &#123;</div><div class="line">    <span class="comment">// 私有/公有/类扩展中的所有属性数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 获取属性列表</span></div><div class="line">    <span class="keyword">objc_property_t</span> *propertyList = class_copyPropertyList(<span class="keyword">class</span>, &amp;count);</div><div class="line">    </div><div class="line">    <span class="comment">// 存储属性名称</span></div><div class="line">    NSMutableArray *<span class="built_in">array</span> = [NSMutableArray <span class="built_in">array</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* c_propertyName = property_getName(propertyList[i]);</div><div class="line">        [<span class="built_in">array</span> addObject:[NSString stringWithUTF8String:c_propertyName]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 手动释放</span></div><div class="line">    <span class="built_in">free</span>(propertyList);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [NSArray arrayWithArray:<span class="built_in">array</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p>本部分应用较少,未做详细实践.</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_protocol_list &#123;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *next;</div><div class="line">    <span class="keyword">long</span> count;</div><div class="line">    __<span class="keyword">unsafe_unretained</span> Protocol *list[<span class="number">1</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">是否遵循协议</div><div class="line"><span class="built_in">BOOL</span> class_conformsToProtocol(Class cls, Protocol *protocol)</div><div class="line"></div><div class="line">协议列表</div><div class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *class_copyProtocolList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div><div class="line"></div><div class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *objc_copyProtocolList(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div><div class="line"></div><div class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *protocol_copyProtocolList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div><div class="line"></div><div class="line">动态添加协议</div><div class="line"><span class="built_in">BOOL</span> class_addProtocol(Class cls, Protocol *protocol) </div><div class="line"></div><div class="line">获取指定名称的协议</div><div class="line">Protocol *objc_getProtocol(<span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line"></div><div class="line">协议A是否遵循协议B</div><div class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol(Protocol *proto, Protocol *other)</div><div class="line"></div><div class="line">两个协议是否相等</div><div class="line"><span class="built_in">BOOL</span> protocol_isEqual(Protocol *proto, Protocol *other)</div><div class="line"></div><div class="line">获取某个协议的名称</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *protocol_getName(Protocol *p)</div><div class="line"></div><div class="line">动态生成协议</div><div class="line">Protocol *objc_allocateProtocol(<span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line"><span class="keyword">void</span> objc_registerProtocol(Protocol *proto) </div><div class="line"></div><div class="line">给协议添加方法</div><div class="line"><span class="keyword">void</span> protocol_addMethodDescription(Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod) </div><div class="line"></div><div class="line">给协议添加协议</div><div class="line"><span class="keyword">void</span> protocol_addProtocol(Protocol *proto, Protocol *addition) </div><div class="line"></div><div class="line">给协议添加属性</div><div class="line"><span class="keyword">void</span> protocol_addProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 根据class获取遵循的协议列表</div><div class="line"></div><div class="line"> @param class 类</div><div class="line"> @return 协议名称列表</div><div class="line"> */</div><div class="line">+ (<span class="built_in">NSArray</span> *)ya_getProtocolList:(Class)<span class="keyword">class</span> &#123;</div><div class="line">    <span class="comment">// 协议列表数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 获取协议列表</span></div><div class="line">    __<span class="keyword">unsafe_unretained</span> Protocol **protocolList = class_copyProtocolList(<span class="keyword">class</span>, &amp;count);</div><div class="line">    </div><div class="line">    <span class="comment">// 存储协议</span></div><div class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</div><div class="line">        <span class="comment">// 获取协议</span></div><div class="line">        Protocol *protocol = protocolList[i];</div><div class="line">        </div><div class="line">        <span class="comment">// 获取协议名称</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *c_protocolName = protocol_getName(protocol);</div><div class="line">        </div><div class="line">        [array addObject:[<span class="built_in">NSString</span> stringWithUTF8String:c_protocolName]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 手动释放</span></div><div class="line">    free(protocolList);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:array];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、技能"><a href="#二、技能" class="headerlink" title="二、技能"></a>二、技能</h2><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (sel_isEqual(sel, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"ss"</span>))) &#123;</div><div class="line">        <span class="comment">// 要求参数要匹配</span></div><div class="line">        [YARuntime ya_addMethod:[<span class="keyword">self</span> <span class="keyword">class</span>] newSEL:sel existSEL:<span class="keyword">@selector</span>(printPersonalInfo)];</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">forwardingTargetForSelector</span><span class="selector-pseudo">:(SEL)aSelector</span> &#123;</div><div class="line">    <span class="selector-tag">if</span> (sel_isEqual(aSelector, NSSelectorFromString(@<span class="string">"ss"</span>))) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 转发给已经存在的对象</span></div><div class="line">        return <span class="selector-attr">[[YAPerson alloc]</span> <span class="selector-tag">init</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return <span class="selector-attr">[super forwardingTargetForSelector:aSelector]</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)aSelector &#123;</div><div class="line">    NSMethodSignature *signature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>aSelector];</div><div class="line">    </div><div class="line">    <span class="comment">// 没有找到signature(方法签名),只能手动提供</span></div><div class="line">    <span class="keyword">if</span> (signature == nil) &#123;</div><div class="line">        signature = [NSMethodSignature <span class="string">signatureWithObjCTypes:</span><span class="string">"@@:"</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation &#123;</div><div class="line">    YAPerson *personClass = [[YAPerson alloc] init];</div><div class="line">    SEL sel = anInvocation.selector;</div><div class="line">    <span class="keyword">if</span> ([personClass <span class="string">respondsToSelector:</span>sel]) &#123;</div><div class="line">        <span class="comment">// 最后一次机会</span></div><div class="line">        [anInvocation <span class="string">invokeWithTarget:</span>personClass];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 回天乏力</span></div><div class="line">        [self <span class="string">doesNotRecognizeSelector:</span>sel];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><blockquote><p>不会做菜的程序员不是好男人。</p></blockquote><p>YADeveloper 继承自 YAMan,想让YADeveloper实例对象同时具备响应 YAMan方法和 YACook方法的能力。</p><p>YAMan:</p><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="variable">@interface</span> <span class="attribute">YAMan </span>: NSObject</div><div class="line">- (void)printMan;</div><div class="line"><span class="variable">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="variable">@implementation</span> YAMan</div><div class="line">- (void)printMan &#123;</div><div class="line">    NSLog(@"我是一个男人");</div><div class="line">&#125;</div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure><p>YACook:</p><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="variable">@interface</span> <span class="attribute">YACook </span>: NSObject </div><div class="line">- (void)printCook;</div><div class="line"><span class="variable">@end</span></div><div class="line"></div><div class="line"><span class="variable">@implementation</span> YACook</div><div class="line">- (void)printCook &#123;</div><div class="line">    NSLog(@"我是个会做菜的人");</div><div class="line">&#125;</div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure><p>YADeveloper:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">YACook</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YADeveloper</span> : <span class="title">YAMan</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) YACook *cook;</div><div class="line">- (<span class="keyword">void</span>)printDev;</div><div class="line"></div><div class="line"><span class="comment">// 声明YACook的方法,使编译通过</span></div><div class="line">- (<span class="keyword">void</span>)printCook;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YADeveloper</span></span></div><div class="line">- (<span class="keyword">void</span>)printDev &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我是个会写程序的人"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="keyword">if</span> (sel_isEqual(aSelector, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"printCook"</span>))) &#123;</div><div class="line">        <span class="comment">// 需要预先对self.cook初始化</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.cook;</div><div class="line">        </div><div class="line">        <span class="comment">// 或者直接创建</span></div><div class="line">        <span class="comment">// return [[YACook alloc] init];</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><h3 id="关联引用"><a href="#关联引用" class="headerlink" title="关联引用"></a>关联引用</h3><p>注意点:</p><ol><li>objc_removeAssociatedObjects 函数一般不可手动调用，因为这个函数会移除一个对象的所有关联对象，将该对象恢复成“原始”状态。这样做就很有可能把别人添加的关联对象也一并移除，这并不是我们所希望的。所以一般的做法是通过给 objc_setAssociatedObject 函数传入 nil 来移除某个已有的关联对象。</li><li>关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的。<h4 id="给分类添加weak属性"><a href="#给分类添加weak属性" class="headerlink" title="给分类添加weak属性"></a>给分类添加weak属性</h4><blockquote><p>给任意对象A 添加 weak属性 B</p></blockquote></li></ol><p>问题关键点:在属性销毁的时候，将其置为空(或者说在关联对象销毁的时候，使objc_getAssociatedObject得到的是nil)。</p><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>通过继承关联对象B ，重写其dealloc方法即可适时把A中的关联对象返回值设置为nil，达到自动置空的目的，这也是最本能的方法。</p><p>给NSObject添加分类，也即任何继承自NSObject的对象都可以有weak属性。</p><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="variable">@interface</span> NSObject (YAWeakProperty)</div><div class="line"><span class="variable">@property</span> (nonatomic, weak) YAProperty *property;</div><div class="line"><span class="variable">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="variable">@implementation</span> NSObject (YAWeakProperty)</div><div class="line"></div><div class="line"><span class="comment">// const static char *key = "key";</span></div><div class="line"></div><div class="line">- (id)property &#123;</div><div class="line">    return objc_getAssociatedObject(self, <span class="variable">@selector</span>(property));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)<span class="attribute">setProperty</span>:(YAProperty *)property &#123;</div><div class="line">    objc_setAssociatedObject(self, <span class="variable">@selector</span>(property), property, OBJC_ASSOCIATION_ASSIGN);</div><div class="line">    <span class="selector-attr">[property setAssociate:self selector:@selector(setProperty:)]</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure><p>关联引用的key一般使用getter方法的selector，此时get方法中的key也可使用_cmd，二者等效。</p><p>属性的实现:</p><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="variable">@interface</span> <span class="attribute">YAProperty </span>: NSObject</div><div class="line">- (void)<span class="attribute">setAssociate</span>:(NSObject *)associatedObject <span class="attribute">selector</span>:(SEL)sel;</div><div class="line"><span class="variable">@end</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 类扩展</span></div><div class="line"><span class="variable">@interface</span> YAProperty()</div><div class="line">&#123;</div><div class="line">   __weak id _associatedObject;</div><div class="line">   SEL _sel;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="variable">@end</span></div><div class="line"></div><div class="line"><span class="variable">@implementation</span> YAProperty</div><div class="line"></div><div class="line">- (void)<span class="attribute">setAssociate</span>:(NSObject *)associatedObject <span class="attribute">selector</span>:(SEL)sel &#123;</div><div class="line">    _associatedObject = associatedObject;</div><div class="line">    _sel = sel;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    ((void (*)(id, SEL,id)) objc_msgSend)(_associatedObject, _sel, nil);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure><p>然而有个问题:添加的属性继承自NSObject时非常完美，但是实际项目中不可能给任意对象添加的属性都是NSObject，有可能是NSString/NSArray/NSDictionary/NSSet等等。那么就只能继承自NSString/NSArray/NSDictionary/NSSet等系统类，这样会出现一系列一系列一系列问题，苹果并不建议我们使用NSString/NSArray/NSDictionary/NSSet等的派生类(这些类已经足够好了，不需要画蛇添足)。</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><blockquote><p>用一个NSPointerArray（弱引用类型的数组）包一层就可以了。虽然关联属性的policy不支持weak，但是你可以把要关联的对象放入一个弱引用数组里面，然后把这个弱引用数组设置为关联对象，每次取值的时候，只需要从这个弱引用数组里面取就可以了。一样可以达到关联弱引用对象的效果。</p></blockquote><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><p>A 关联 C<br>B 关联 C<br>C 销毁 通知B<br>B 再告诉 A</p><h2 id="三、要点"><a href="#三、要点" class="headerlink" title="三、要点"></a>三、要点</h2><h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">free</span>() 函数用来释放动态分配的内存空间，其原型为：</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span> <span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="built_in">free</span>() 可以释放由 <span class="built_in">malloc</span>()、<span class="built_in">calloc</span>()、<span class="built_in">realloc</span>() 分配的内存空间，以便其他程序再次使用。</div><div class="line"></div><div class="line"><span class="comment">// 及时释放字符串常量</span></div><div class="line"><span class="keyword">if</span> (argumentType) <span class="built_in">free</span>(argumentType);</div></pre></td></tr></table></figure><h3 id="NONNULL"><a href="#NONNULL" class="headerlink" title="NONNULL"></a>NONNULL</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span>和<span class="built_in">NS_ASSUME_NONNULL_END</span>。</div><div class="line">在这两个宏之间的代码，所有简单指针对象都被假定为 <span class="keyword">nonnull</span></div><div class="line"></div><div class="line"><span class="meta">#define NS_ASSUME_NONNULL_BEGIN _Pragma(<span class="meta-string">"clang assume_nonnull begin"</span>)</span></div><div class="line"><span class="meta">#define NS_ASSUME_NONNULL_END   _Pragma(<span class="meta-string">"clang assume_nonnull end"</span>)</span></div></pre></td></tr></table></figure><h3 id="covariant"><a href="#covariant" class="headerlink" title="__covariant"></a>__covariant</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="attribute">__covariant</span> - 协变性，子类型可以强转到父类型（里氏替换原则）</div><div class="line">__contravariant - 逆变性，父类型可以强转到子类型（WTF）</div></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="code"><pre><div class="line">__kindof</div></pre></td></tr></table></figure><h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line"><span class="strong">__attribute__</span>((always_inline)) 的意思是强制内联</div></pre></td></tr></table></figure><blockquote><p>参考并感谢<br><a href="http://www.cnblogs.com/ludashi/p/6294112.html" target="_blank" rel="external">青玉伏案</a><br><a href="http://southpeak.github.io/2014/11/06/objective-c-runtime-4/" target="_blank" rel="external">南峰子</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2018.8.26 更新Class定义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;p align = &quot;center&quot;&gt; 关于YYModel和Runtime的简单总结。 &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>查找算法总结</title>
    <link href="http://blog.chenyalun.com/2017/04/21/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.chenyalun.com/2017/04/21/查找算法总结/</id>
    <published>2017-04-21T11:10:17.000Z</published>
    <updated>2017-04-30T09:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 关于查找算法。 </p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文”完全二叉树”的定义采用国内定义<br>B-树 即 B树,两者是相同概念,而非指二叉搜索树(百度百科)</p></blockquote><h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>1.国内早期教材中，满二叉树一般指 perfect binary tree，所以会有满二叉树是完全二叉树的一个特例的说法.</p><p>2.树的深度的定义，有的根结点从0开始计数，有的从1开始计数.</p><p>3.结点 与 节点 是对Node的翻译,可以看做等同.</p><h2 id="维基百科定义"><a href="#维基百科定义" class="headerlink" title="维基百科定义"></a>维基百科定义</h2><p>1.根二叉树(Rooted Binary Tree)：<br>有一个根结点，每个结点至多有两个孩子。</p><p>2.满二叉树(Full Binary Tree)：<br>要么是叶子结点(结点的度为0)，要么结点同时具有左右子树(结点的度为2)。</p><p>3.完全二叉树(Complete Binary Tree)：<br>每层结点都完全填满，在最后一层上如果不是满的，则只缺少右边的若干结点。</p><p>4.完美二叉树(Perfect Binary Tree)<br>所有的非叶子结点都有两个孩子，所有的叶子结点都在同一层。即每层结点都完全填满。</p><p>5.无限完全二叉树(Infinite Complete Binary Tree)：    每个结点都有两个孩子，结点的层数是无限的。</p><p>6.平衡二叉树(Balanced Binary Tree)：<br>也称为AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><strong>满二叉树(Full Binary Tree)</strong><br>如果一棵二叉树的结点要么是叶子要么有两个孩子结点,则为满二叉树</p><p>性质:<br>1.总结点个数呈现个数为:0 1 3 7 15…满足2^(n) -1,其中n为树的深度(最大层)</p><p>2.第k层(k不为0)结点个数:1 2 4 8…满足2^(k - 1)</p><p>3.满二叉树是完全二叉树</p><p><strong>完全二叉树(Complete Binary Tree)</strong><br>若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><p>性质:完全二叉树中度为1的结点数只有两种可能0或1,那么:<br>总结点数为n,有  <strong>n0=n/2</strong> 或 <strong>n0=(n+1)/2</strong></p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>顺序存储的排序数组<br><img src="http://static.chenyalun.com/2017/04/21/170421004.jpg" alt=""><br>插入和删除的时候时间复杂度达到O(n),顺序存储结构不适于动态的情况</p><p>链式存储<br><img src="http://static.chenyalun.com/2017/04/21/170421005.jpg" alt=""><br>链表的查找需要O(n)</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找表:由同一类型的数据元素构成的集合.<br>关键字:数据元素中某个数据项的值.<br>主关键字:可以唯一地标识一个记录.<br>次关键字:可以识别多个数据元素.<br>查找:根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素(或记录).<br>静态查找表:只作查找操作的查找表.<br>动态查找表:在查找过程中同时插入查找表中不存在的数据元素,或者从查找表中删除已经存在的某个数据元素.</p><h2 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h2><p>顺序查找(线性查找):从表中第一个记录开始,逐个进行记录的关键字和给定值的比较.</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 顺序查找的实现</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequentialSearch</span><span class="params">(key, numbers)</span>:</span></div><div class="line">    length = len(numbers)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(length):</div><div class="line">        <span class="comment"># 查找成功返回索引</span></div><div class="line">        <span class="keyword">if</span> key == numbers[i]:</div><div class="line">            <span class="keyword">return</span> i</div><div class="line">    <span class="comment"># 查找失败返回-1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure><p>最好情况:在第一个位置找到,时间复杂度为O(1)<br>最坏情况:在最后一个位置找到,时间复杂度O(n)<br>查找不成功:时间复杂度O(n)<br>平均查找次数:(n+1)/2<br>平均时间复杂度:O(n)</p><h2 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h2><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><p> 折半查找(二分查找):在线性表中的记录有序的前提下进行查找.取中间元素作为比较对象,若给定值与中间元素相等,则查找成功,若给定值小于中间元素,则在中间元素的左半区继续查找,若给定值大于中间元素,则在中间元素的右半区继续查找,不断重复查找过程,直到查找成功,或查找失败.</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 二分查找的实现</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(key, numbers)</span>:</span></div><div class="line">    <span class="comment"># 左边界</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    <span class="comment"># 右边界</span></div><div class="line">    high = len(numbers) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        <span class="comment"># 中间元素索引</span></div><div class="line">        mid = (low + high) / <span class="number">2</span></div><div class="line">        <span class="comment"># 查找成功</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] == key:</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">        <span class="comment"># 在左区间</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] &gt; key:</div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">        <span class="comment"># 在右区间</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] &lt; key:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">    <span class="comment"># 查找失败返回-1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure><p>最好情况:是中间元素,一次即可找到,时间复杂度O(1)<br>最坏情况:完全二叉树的深度加1,即floor(logn) + 1次,时间复杂度O(logn).(注意:logn这里指以2为底,floor表示向下取整)</p><h3 id="2-插值查找"><a href="#2-插值查找" class="headerlink" title="2.插值查找"></a>2.插值查找</h3><p>二分查找的优化版,核心是插值公式:<br>(key - numbers[low]) / (numbers[high] - numbers[low])</p><p>核心代码:</p><figure class="highlight gcode"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 插值</span></div><div class="line">mid = low + <span class="comment">(high - low)</span> * <span class="comment">(key - numbers[low])</span> / <span class="comment">(numbers[high] - numbers[low])</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 插值查找的实现</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">interpolationSearch</span><span class="params">(key, numbers)</span>:</span></div><div class="line">    <span class="comment"># 左边界</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    <span class="comment"># 右边界</span></div><div class="line">    high = len(numbers) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        <span class="comment"># 核心代码</span></div><div class="line">        mid = low + (high - low) * (key - numbers[low]) / (numbers[high] - numbers[low])</div><div class="line">        <span class="comment"># 查找成功</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] == key:</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">        <span class="comment"># 在左区间</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] &gt; key:</div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">        <span class="comment"># 在右区间</span></div><div class="line">        <span class="keyword">if</span> numbers[mid] &lt; key:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">    <span class="comment"># 查找失败返回-1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure><p>从时间复杂度上,依然是O(logn),但是对于表长较大,关键字分布比较均匀的查找表,性能相对二分查找更好.<br>但是,分布极不均匀的数据,不是很合适,比如[1,2,4,3000,3003…9988899,8988998]</p><p>插值查找在实际使用时，一般要满足两个假设条件：</p><p>(1)每一次对数据的访问与通常的指令相比，费用都是相当昂贵的。例如，待查找的表一定是在磁盘而非内存中，因而每一次比较都要进行磁盘访问。</p><p>(2)数据不仅是已被排好序的，而且呈现均匀分布特征。</p><h3 id="3-斐波那契查找"><a href="#3-斐波那契查找" class="headerlink" title="3.斐波那契查找"></a>3.斐波那契查找</h3><p>利用黄金分割原理实现,折半查找算法来进行修改和改进.<br>对于斐波那契数列,前后两个数字的比值随着数列的增加,越来越接近黄金比值:0.618</p><figure class="highlight css"><table><tr><td class="code"><pre><div class="line">0<span class="selector-class">.0</span></div><div class="line">1<span class="selector-class">.0</span></div><div class="line">0<span class="selector-class">.5</span></div><div class="line">0<span class="selector-class">.666666666667</span></div><div class="line">0<span class="selector-class">.6</span></div><div class="line">0<span class="selector-class">.625</span></div><div class="line">0<span class="selector-class">.615384615385</span></div><div class="line">0<span class="selector-class">.619047619048</span></div><div class="line">0<span class="selector-class">.617647058824</span></div><div class="line">0<span class="selector-class">.618181818182</span></div><div class="line">0<span class="selector-class">.61797752809</span></div><div class="line">0<span class="selector-class">.618055555556</span></div><div class="line">0<span class="selector-class">.618025751073</span></div><div class="line">0<span class="selector-class">.618037135279</span></div><div class="line">0<span class="selector-class">.618032786885</span></div><div class="line">0<span class="selector-class">.618034447822</span></div><div class="line">0<span class="selector-class">.6180338134</span></div><div class="line">0<span class="selector-class">.618034055728</span></div><div class="line">0<span class="selector-class">.618033963167</span></div><div class="line">0<span class="selector-class">.618033998522</span></div><div class="line">......</div></pre></td></tr></table></figure><p>对于斐波那契数列:<br>0 1 1 2 3 5 8 13 21 34 55 89 …</p><p><strong>原理:</strong><br>比如这里的89，假定它是整个有序表的元素个数，而89是由前面的两个数34和55相加之后的和，也即把元素个数为89的有序表分成由前55个数据元素组成的前半段和由后34个数据元素组成的后半段，那么前半段元素个数和整个有序表长度的比值就接近黄金比值0.618，假如要查找的元素在前半段，那么继续按照斐波那契数列来看，55 = 34 + 21，所以继续把前半段分成前34个数据元素的前半段和后21个元素的后半段，继续查找，如此反复，直到查找成功或失败.</p><p>当有序表的元素个数不是斐波那契数列中的某个数字时，需要把有序表的元素个数长度补齐，让它成为斐波那契数列中的一个数值,也即<strong>把需要补齐的的元素都赋值为有序表的最大值</strong>。</p><p><strong>核心:</strong><br>(1)当key == numbers[mid],查找成功<br>(2)当key &lt; numbers[mid],新范围是第low个到第mid-1个,范围个数是F(k-1) - 1个,即有序列表左边的长度<br>(3)当key &gt; numbers[mid]时,新范围是第mid+1到第high个,范围个数是F(k-2) - 1个,即有序列表右边的长度</p><p>k 表示列表的长度<br>k-1表示索引<br>F(k-1)表示列表最后一个元素</p><p>元素总个数 = 左区间个数 + 右区间个数 + 中间的一个元素,即:</p><pre><code>F(k)-1 = F(k-1)-1  +   F(k-2)-1    +     1</code></pre><p>斐波那契查找算法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 斐波那契查找</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fbonacci</span><span class="params">(index)</span>:</span></div><div class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> </div><div class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(index):</div><div class="line">        a, b = b, a + b</div><div class="line">    <span class="keyword">return</span> a</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">FbonacciSearch</span><span class="params">(key, numbers)</span>:</span></div><div class="line">    <span class="comment"># 确定该序列在斐波那契数列中的位置</span></div><div class="line">    n, length = <span class="number">0</span>, len(numbers)</div><div class="line">    <span class="keyword">while</span> length &gt; Fbonacci(n) - <span class="number">1</span>:</div><div class="line">        n += <span class="number">1</span></div><div class="line">    <span class="comment"># 填满元素</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n,Fbonacci(n)):</div><div class="line">        numbers.append(numbers[<span class="number">-1</span>])</div><div class="line">    </div><div class="line">    low, high = <span class="number">0</span>, n - <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        <span class="comment"># 获取黄金分割下标</span></div><div class="line">        mid = low + Fbonacci(n - <span class="number">1</span>) - <span class="number">1</span></div><div class="line">        </div><div class="line">        <span class="comment"># 左区间</span></div><div class="line">        <span class="comment">#若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1</span></div><div class="line">        <span class="keyword">if</span> key &lt; numbers[mid]:</div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">            n -= <span class="number">1</span></div><div class="line">            </div><div class="line">        <span class="comment"># 右区间</span></div><div class="line">        <span class="comment">#若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1</span></div><div class="line">        <span class="keyword">if</span> key &gt; numbers[mid]:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">            n -= <span class="number">2</span></div><div class="line">        <span class="comment"># 相等</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 成功找到</span></div><div class="line">            <span class="keyword">if</span> mid &lt;= n:</div><div class="line">                <span class="keyword">return</span> mid</div><div class="line">            <span class="comment"># 补全的数,返回n</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> n</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure><h3 id="4-比较"><a href="#4-比较" class="headerlink" title="4.比较"></a>4.比较</h3><p>二分查找是加法与除法运算<br>插值查找是复杂的四则运算<br>斐波那契查找是加减法运算</p><h2 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h2><p>索引:把一个关键字与它对应的记录相关联的过程.<br>线性索引:把索引项集合组织为线性结构,也即索引表</p><h3 id="1-稠密索引"><a href="#1-稠密索引" class="headerlink" title="1.稠密索引"></a>1.稠密索引</h3><p>稠密索引:将数据集的每个记录对应一个索引项,且索引项一定按照关键码有序排列.</p><h3 id="2-分块索引"><a href="#2-分块索引" class="headerlink" title="2.分块索引"></a>2.分块索引</h3><p>对数据集进行分块,使分块有序,然后对每一块建立一个索引项,从而减少索引项的个数.</p><p>块需要满足的条件:<br>(1)块内无序:每一块的记录不要求有序.<br>(2)块间有序:比如,要求第二块所有记录的关键字均要大于第一块所有记录的关键字.第三块大于第二块…</p><p>分块索引的索引项结构:</p><ul><li>最大关键码:存储每一块中点最大关键字</li><li>存储块中记录的个数,便于循环</li><li>用于指向块首数据元素的指针,便于遍历</li></ul><p>查找分两步:<br>(1)在分块索引表中查找关键字所在的块.<br>(2)根据块首指针找到相应的块,并在块中顺序查找关键码.</p><p>设n个记录被平均分成m块,每个块t条记录,则n=mt<br>查找索引表的平均查找长度:(1+m)/2<br>查找记录的平均查找长度:(t+1)/2</p><p>则块中查找记录的平均查找长度:</p><pre><code>  (1+m)/2 + (t+1)/2 = (m+t)/2+1 = (n/t+t)/2+1</code></pre><p>最佳情况:m与t相等,也即n = t^2 = m^2 ,则原式为:</p><pre><code>= (t*t/t+t)/2+1= t+1= n^0.5 + 1 (^ 表示次方)</code></pre><p>由此分块索引比顺序查找O(n)提高不少.</p><h3 id="3-倒排索引"><a href="#3-倒排索引" class="headerlink" title="3.倒排索引"></a>3.倒排索引</h3><p>索引项的结构:次关键码与记录号表<br>根据属性(次关键码,字段)的值查找记录.<br>该索引表中的每一项包括一个属性值和具有该属性值的各记录的地址.<br>由于不是由记录确定属性值而是由属性值确定记录,因而称为倒排索引.</p><p>优点:生成索引表后不用读取记录就可知道结果,查找非常快<br>缺点:记录号不定长</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>如果查找的数据集是有序线性表,并且是顺序存储的,可以使用二分查找/插值查找/斐波那契查找,但是在插入删除操作上耗费大量时间,由此引出既可以使得插入删除效率不错又可以高效率查找的算法====&gt;使用二叉树数据结构:在创建集合时就考虑使用二叉树结果,而且是排好序的二叉树.构造二叉搜索树的目的不是为了排序,而是为了提高插入/删除的效率.</p><p>二叉查找树,也称(二叉搜索树,有序二叉树,排序二叉树,二叉排序树）,是指<strong>一棵空树</strong>或者具有下列性质的<strong>二叉树</strong>：</p><ul><li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ul><p>性质:<br>1.左小于根小于右<br>2.值不重复<br>3.”中序遍历“可以让结点有序<br>4.二叉搜索树有两种结点删除方式:取被删除结点的右子树中的最小元素替代或者取被删除结点的左子树中的最大元素替代</p><p>优势:<br>查找、插入的时间复杂度较低。为O(log n)<br>二叉查找树的最坏效率是O(n),此时退化为线性结构</p><p><img src="http://static.chenyalun.com/2017/04/21/170421006.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeNode</span><span class="params">()</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val = <span class="number">0</span>)</span>:</span></div><div class="line">self.val = val</div><div class="line">self.left = <span class="keyword">None</span></div><div class="line">self.right = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="comment"># 寻找结点</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, data)</span>:</span></div><div class="line"><span class="keyword">if</span> self.val == data:</div><div class="line"><span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"><span class="keyword">elif</span> data &lt; self.val <span class="keyword">and</span> self.left:</div><div class="line"><span class="keyword">return</span> self.left.find(data)</div><div class="line"><span class="keyword">elif</span> data &gt; self.val <span class="keyword">and</span> self.right:</div><div class="line"><span class="keyword">return</span> self.right.find(data)</div><div class="line"><span class="keyword">else</span>:</div><div class="line"><span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="comment"># 寻找最小结点</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMinData</span><span class="params">(self)</span>:</span></div><div class="line"><span class="keyword">if</span> self.left:</div><div class="line"><span class="keyword">return</span> self.left.findMinData()</div><div class="line"><span class="keyword">else</span>:</div><div class="line"><span class="keyword">return</span> self.val</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 寻找最大结点</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxData</span><span class="params">(self)</span>:</span></div><div class="line"><span class="keyword">if</span> self.right:</div><div class="line"><span class="keyword">return</span> self.right.findMaxData()</div><div class="line"><span class="keyword">else</span>:</div><div class="line"><span class="keyword">return</span> self.val</div><div class="line"></div><div class="line"><span class="comment"># 插入结点</span></div><div class="line"><span class="comment"># 当data与二叉搜索树中某结点val相等时不作处理</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertNode</span><span class="params">(self, data)</span>:</span></div><div class="line"><span class="comment"># 在右子树上</span></div><div class="line"><span class="keyword">if</span> self.val &lt; data:</div><div class="line"><span class="keyword">if</span>  self.right:</div><div class="line">self.right.insertNode(data)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">self.right = BinarySearchTreeNode(data)</div><div class="line"></div><div class="line"><span class="comment"># 在左子树上</span></div><div class="line"><span class="keyword">if</span> self.val &gt; data:</div><div class="line"><span class="keyword">if</span>  self.left:</div><div class="line">self.left.insertNode(data)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">self.left = BinarySearchTreeNode(data)</div><div class="line"></div><div class="line"><span class="comment"># 打印二叉搜索树</span></div><div class="line"><span class="comment"># 左根右遍历</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printTree</span><span class="params">(self)</span>:</span></div><div class="line"><span class="keyword">if</span> self.left:</div><div class="line">self.left.printTree()</div><div class="line"><span class="keyword">print</span> self.val,</div><div class="line"><span class="keyword">if</span> self.right:</div><div class="line">self.right.printTree()</div><div class="line"></div><div class="line"><span class="comment"># 结点的删除</span></div><div class="line"><span class="comment"># 当删除一个叶子结点时,直接删除即可</span></div><div class="line"><span class="comment"># 当删除的结点只有一个孩子时,用该孩子替换</span></div><div class="line"><span class="comment"># 当删除的结点有两个孩子时,寻找该结点右子树中的最小数据代替子节点</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">daleteNode</span><span class="params">(self, data)</span>:</span></div><div class="line"><span class="comment"># 前提是该结点在二叉搜索树中能找到</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.find(data):</div><div class="line"><span class="keyword">return</span> self</div><div class="line"><span class="keyword">if</span> data &lt; self.val:</div><div class="line">self.left = self.left.daleteNode(data)</div><div class="line"><span class="keyword">return</span> self</div><div class="line"><span class="keyword">elif</span> data &gt; self.val:</div><div class="line">self.right = self.right.daleteNode(data)</div><div class="line"><span class="keyword">return</span> self</div><div class="line"><span class="keyword">elif</span> self.left <span class="keyword">and</span> self.right:</div><div class="line"><span class="comment"># 找到右子树最小的结点,获取值</span></div><div class="line">val = self.right.findMinData()</div><div class="line"><span class="comment"># 把最小结点的值给自己</span></div><div class="line">self.val = val</div><div class="line"><span class="comment"># 删除右子树中的最小结点,使self.right指向右子树的根节点</span></div><div class="line"><span class="comment"># self.right.daleteNode(val)最终返回右子树的根节点</span></div><div class="line">self.right = self.right.daleteNode(val)</div><div class="line"><span class="keyword">return</span> self</div><div class="line"><span class="keyword">else</span>:</div><div class="line"><span class="comment"># 左结点存在</span></div><div class="line"><span class="keyword">if</span> self.left:</div><div class="line"><span class="comment"># 直接指向左结点</span></div><div class="line"><span class="keyword">return</span> self.left</div><div class="line"><span class="comment"># 右结点存在,或不存在结点</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line"><span class="comment"># 直接指向右结点</span></div><div class="line"><span class="keyword">return</span> self.right</div><div class="line"></div><div class="line"></div><div class="line">a = BinarySearchTreeNode(<span class="number">10</span>)</div><div class="line">a.insertNode(<span class="number">8</span>)</div><div class="line">a.insertNode(<span class="number">12</span>)</div><div class="line">a.insertNode(<span class="number">6</span>)</div><div class="line">a.insertNode(<span class="number">9</span>)</div><div class="line">a.insertNode(<span class="number">11</span>)</div><div class="line">a.insertNode(<span class="number">14</span>)</div><div class="line">a.insertNode(<span class="number">7</span>)</div><div class="line">a.insertNode(<span class="number">13</span>)</div><div class="line">a.insertNode(<span class="number">5</span>)</div><div class="line">a.insertNode(<span class="number">2</span>)</div><div class="line"></div><div class="line">a.printTree()</div><div class="line"><span class="keyword">print</span> <span class="string">"\n"</span></div><div class="line"><span class="keyword">print</span> a.find(<span class="number">11</span>)</div><div class="line"><span class="keyword">print</span> a.find(<span class="number">100000</span>)</div><div class="line"><span class="keyword">print</span> a.findMaxData()</div><div class="line"><span class="keyword">print</span> a.findMinData()</div><div class="line"></div><div class="line">a.daleteNode(<span class="number">1000000</span>)</div><div class="line">a.daleteNode(<span class="number">10</span>)</div><div class="line">a.daleteNode(<span class="number">14</span>)</div><div class="line">a.daleteNode(<span class="number">2</span>)</div><div class="line">a.printTree()</div></pre></td></tr></table></figure><p>二叉搜索树以链接的方式存储,保持了链接存储结构在执行插入或删除时的优越性.</p><p><img src="http://static.chenyalun.com/2017/04/21/170421002.png" alt=""></p><p>对于二叉搜索树的查找,比较次数等于给定值的结点在二叉搜索树的层数.最少为1次(为根节点),最多不超过树的深度(最差是极端的右斜树或左斜树).</p><p><img src="http://static.chenyalun.com/2017/04/21/170421001.png" alt=""></p><p>二叉排序树倘若是平衡的,其深度与完全二叉树相同,均为<code>floor(logn) + 1</code>,查找的时间复杂度为O(logn),近似与折半查找,若不是平衡的,甚至演化为极端的右斜树或左斜树,查找的时间复杂度为O(n),等同于顺序查找.</p><p>因此,平衡至关重要.</p><h2 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h2><p>平衡二叉搜索树是改进的二叉搜索树,也是二叉搜索树。</p><p>一般的二叉搜索树的查询复杂度是跟深度有关，因此当结点的深度普遍较大时，查询的均摊复杂度会上升，为了更高效的查询，平衡树应运而生了。</p><p>可以使查找树的高度为 O (log(n)) </p><p>定义:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>AVL树中的每个结点都有一个平衡因子（balance factor，BF），它表示这个结点的左、右子树的深度差，也就是左子树的深度减去右子树的深度的结果值。AVL树上所有结点的BF值只能是-1、0、1。反之，只要二叉树上一个结点的BF的绝对值大于1，则该二叉树就不是平衡二叉树。在进行插入和删除的时候找出失去平衡的节点，进行必要的旋转操作保证树的平衡。</p><p>查找、插入和删除在平均和最坏情况下都是O（log n）</p><h3 id="最少结点"><a href="#最少结点" class="headerlink" title="最少结点"></a>最少结点</h3><p>设n(h)是高度为h的AVL树，则结点数最少时有:<br>n(h) = n(h-1) + n(h-2) + 1</p><table><thead><tr><th>h(VAL树的高度)</th><th>最少结点数</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>2</td><td>4</td></tr><tr><td>3</td><td>7</td></tr><tr><td>4</td><td>12</td></tr><tr><td>5</td><td>20</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>显而易见，满足的关系为:<br>高度为h的AVL树，其最少结点数量为<code>F(h+2) - 1</code>，其中F(x)为斐波那契数列逗号且规定从1开始，即F(0) = 1，F(1) = 2</p><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><p>RR(右单旋):麻烦结点在发现结点的右子树的右子树上</p><p>RL():麻烦结点在发现结点的右子树的左子树上</p><p>LL(左单旋):麻烦结点在发现结点的左子树的左子树上</p><p>LR():麻烦结点在发现结点的左子树的右子树上</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆:用数组表示的完全二叉树<br>有序性:任一结点的关键字是其子树所有结点的最大值(或者最小值)，从根结点到任意结点路径上结点序列的有序性。<br>最大堆,也称为大顶堆:最大值<br>最小堆,也称为小顶堆:最小值</p><p>最大堆的建立:<br>方法一:自底向上调整堆，首先将n个节点按输入顺序存入，使其满足完全二叉树的结构特性，然后调整各节点的位置。</p><p>方法二:通过插入操作，将n个元素一个个地相继插入到一个初始为空的堆中，其时间代价最大为O(nlogn)。</p><p>堆顶元素的删除<br>元素的插入</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>带权路径长度:设二叉树有n个叶子节点，每个叶子节点带有权值W，从根节点到每个叶子节点的长度为L，则每个叶子节点的带权路径长度之和为WPL=∑WL。<br>哈夫曼树即是最优二叉树:WPL最小的二叉树。</p><p>性质:</p><ol><li>没有度为1的结点(按照构造哈夫曼树的规则，显而易见)。</li><li>n个叶子节点的哈夫曼树共有 <code>2 * n - 1</code>个结点。</li><li>哈夫曼树的任意非叶子结点的左右子树交换后仍是哈夫曼树。</li><li>对同一组权值的，可能存在不同结构的几棵哈夫曼树，但是它们的WPL是相同的。</li></ol><p>性质2推导:根据哈夫曼树没有度为1的结点，则 n1 = 0，又根据 n0 = n2 + 1，sum = n0 + n1 + n2，则有:</p><pre><code>sum = n0 + n1 + n2    = n0 + n2    = n0 + n0 - 1    = 2 * n0 - 1    = 2 * n - 1 // n即n0</code></pre><p>图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片图片<br><img src="" alt=""></p><p>图a的WPL为 5 <em> 2 + 7 </em> 2 + 2 <em> 2 + 13 </em> 2 = 54<br>图b的WPL为 13 <em> 1 + 7 </em> 2 + 2 <em> 3 + 5 </em> 3 = 48<br>PL的计算方式为:该节点的权值 * 从根节点到该节点的树枝数量</p><p>哈夫曼树的构造:每次把权值最小的两个二叉树合并，参照最大堆的调整。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p><p>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）每个红色节点必须有两个黑色的子节点。<br>（5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。  </p><p>一棵n个结点是红黑树始终保持了logn的高度,所以红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</p><p>红黑树之所以是平衡的二叉查找树，是因为每个节点都有表示其颜色的域值：红或黑，在插入和删除操作的时候依据节点的颜色向平衡的方向调整。</p><p><img src="http://static.chenyalun.com/2017/04/21/170421007.png" alt=""></p><p>“叶结点” 或”NULL结点”，它不包含数据而只充当树在此结束的指示，这些结点以及它们的父结点，在绘图中都会经常被省略。</p><p>当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。 为了继续保持红黑树的性质，我们可以通过对结点进行重新着色，以及对树进行相关的旋转操作</p><p>左旋:左右左<br>右旋:右左右</p><h2 id="多路查找树-B树"><a href="#多路查找树-B树" class="headerlink" title="多路查找树(B树)"></a>多路查找树(B树)</h2><p>B树即为B-树、B_树,又叫平衡多路查找树.<br>多路查找树:其每一个结点的孩子数可以多于两个,每一个结点处可以存储多个元素.</p><p>一个节点只能存储一个元素,在元素非常多的时候,就使得要么树的度非常大,要么树的高度非常大,甚至两者都必须足够大才可以,这使得内存存取外村次数非常多,造成了时间效率上的瓶颈,于是引入多路查找树.</p><p>树的高度越高，查找文件所需要的磁盘IO读写次数越多，所以为了减少磁盘的IO读写，要想办法进一步降低树的高度。 因此，具有多个孩子的B树便应运而生，因为B树每一个结点可以有几个到几千个孩子，使得在结点数目一定的情况下，树的高度会大大降低，从而有效减少磁盘IO读写消耗。</p><p>B+树、B树等的根结点和部分顶层数据存在内存中，大部分下层数据存在磁盘上。</p><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>2-3树是这样一棵多路查找树:其中的每一个结点都具有两个孩子或三个孩子.</p><ol><li><p>一个2结点包含一个元素和两个孩子(或没有孩子),与二叉排序树类似,左子树包含的元素小于该元素,右子树包含的元素大于该元素,与二叉排序树不同的是,这个2结点要么没有孩子,要么就有两个,不能只有一个孩子.</p></li><li><p>一个3结点包含一小一大两个元素和三个孩子(或没有孩子),一个3结点要么没有孩子,要么具有3个孩子.如果具有3个孩子的话,左子树包含的元素小于较小元素的元素,右子树包含的元素大于较大元素的元素,中间子树包含介于两元素之间的元素.</p></li><li><p>并且2-3树中所有叶子都在同一层次上.</p></li></ol><p>2-3树的插入</p><p>2-3树的删除</p><h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p>2-3树的概念扩展,包括了4结点的使用.一个4结点包含小中大三个元素和四个孩子(或者没有孩子).</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树是一种平衡的多路查找树,2-3树和2-3-4树都是B树的特例.<br>结点最大的孩子数目称为B树的阶.<br>2-3树是3阶B树,2-3-4树是4阶B树.</p><p>A B-tree of order m is a tree which satisfies the following properties:</p><pre><code>Every node has at most m children.Every non-leaf node (except root) has at least ⌈m/2⌉ children.The root has at least two children if it is not a leaf node.A non-leaf node with k children contains k−1 keys.All leaves appear in the same level</code></pre><p>一棵m阶的B树满足以下条件<br>1.每个结点至多有m棵子树<br>2.除根结点外,其他分支结点至少有ceil(m/2)棵子树(ceil()函数向上取整<br>3.根结点至少有两棵子树,除非树只包含一个结点<br>4.有k个孩子的非叶结点有k-1个关键码,关键码按递增次序排列<br>5.所有叶子结点在同一层</p><h4 id="B树如何做到减少访问外存次数"><a href="#B树如何做到减少访问外存次数" class="headerlink" title="B树如何做到减少访问外存次数"></a>B树如何做到减少访问外存次数</h4><p>硬盘将信息分割成相等大小的页面,每次硬盘读写都是一个或者多个完整的页面,对一个硬盘来说,一页的长度可能是211到214字节.</p><p>在一个典型的B树应用中,要处理的硬盘数据量很大,因此无法一次全部装入内存,因此需要对B树进行调整,使得B树的阶树与硬盘存储的页面大小相匹配.在有限内存的情况下,每一次磁盘的访问我们都可以获得最大量的数据,由于B树每节点可以具有比二叉树多得多的元素,所以减少了必须访问结点和数据块的数量,提高了性能.<br>B树的数据结构就是为内外存的数据交互准备的.</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+ 树是一种树数据结构，通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。</p><p>B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。</p><p>一棵m阶的B+树与B树的区别在于:</p><ol><li>有n棵子树的结点包含有n个关键字</li><li>所有的叶子节点包含全部的关键字信息,以及指向含这些关键字记录的指针,叶子节点本身依关键字的大小自小而大顺序链接</li><li>所有分支结点可以看成是索引,结点中仅含有其子树的最大(最小)关键字.</li></ol><p>好处:<br>如果要随机查找,就从根节点出发,与B树的查找方式相同,只不过即使在分支结点找到了待查找的关键字,它也只是用来索引的,不能提供实际记录的访问,还是需要到达包含此关键字的终端结点.</p><p>如果需要从最小关键字进行自小而大的顺序查找,可以从最左端的叶子结点出发,不经过分支结点,而是沿着指向下一叶子的指针就可遍历所有的关键字.</p><p>B+树适合有范围的查找(比如年龄18–22),从根节点出发找到18,再在叶子结点中按顺序找到符合要求的记录.</p><p>B+树的插入/删除与B树类似,只不过插入删除的元素都是在叶子结点上进行.</p><h2 id="散列表查找"><a href="#散列表查找" class="headerlink" title="散列表查找"></a>散列表查找</h2><p>存储位置 = f(关键字)</p><p>记录的存储位置和它的关键字之间建立的一个确定的对应关系.每个关键字key对应一个存储位置f(key),查找时根据这个确定的对应关系找到给定key的映射f(key).</p><p>f称为散列函数,又称哈希函数,采用散列技术将记录存储在一块连续的存储空间中,这块连续的存储空间称为散列表或哈希表,关键字对应的记录存储位置称为散列地址.</p><p>冲突:key1不等于key2,但是f(key1)=f(key2),key1和key2称为散列函数的同义词.</p><h3 id="常用的散列函数"><a href="#常用的散列函数" class="headerlink" title="常用的散列函数"></a>常用的散列函数</h3><h4 id="1-直接定址法"><a href="#1-直接定址法" class="headerlink" title="1.直接定址法"></a>1.直接定址法</h4><pre><code>f(key) = a * key + b  (a,b为常数)</code></pre><ul><li>优点:简单均匀,不会产生冲突,但需要事先知道关键字的分布情况,适合查找表较小且连续的情况.</li></ul><h4 id="2-数字分析法"><a href="#2-数字分析法" class="headerlink" title="2.数字分析法"></a>2.数字分析法</h4><p>手机号码等,对数字进行抽取,反转,左环位移,右环位移等方式合理地将关键字分配到散列表的各位置.</p><ul><li>适合处理关键字位数比较大的情况,如果事先知道关键字的分布且关键字的若干位分布均匀,可以使用.</li></ul><h4 id="3-平方取中法"><a href="#3-平方取中法" class="headerlink" title="3.平方取中法"></a>3.平方取中法</h4><p>关键字1234—-&gt;平方后:1522756—–&gt;抽取中间的3位——&gt;227,用作散列地址.</p><ul><li>适合不知道关键字的分布,而位数又不是很大的情况</li></ul><h4 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="4.折叠法"></a>4.折叠法</h4><p>从左到右分割成位数相等的几部分,叠加求和,按照散列表长,取后几位作为散列地址.</p><p>9876543210—–&gt;987  654  321 0—–&gt;求和987+654+321+0=1962,求后三位:962</p><ul><li>适合不需要事先知道关键字的分布.适合关键字位数较多的情况.</li></ul><h4 id="5-除留余数法"><a href="#5-除留余数法" class="headerlink" title="5.除留余数法"></a>5.除留余数法</h4><p>最常用,散列表长为m的公式:</p><pre><code>f(key) = key mod p (p&lt;=m)</code></pre><ul><li>若散列表表长m,通常p为小于或者等于表长的最小质数或不包含小于20质因子的合数.</li></ul><h4 id="6-随机数法"><a href="#6-随机数法" class="headerlink" title="6.随机数法"></a>6.随机数法</h4><pre><code>f(key) = random(key)</code></pre><ul><li>当关键字的长度不等时,采用这个方法.</li></ul><h3 id="常用的处理冲突方法"><a href="#常用的处理冲突方法" class="headerlink" title="常用的处理冲突方法"></a>常用的处理冲突方法</h3><h4 id="1-开放定址法"><a href="#1-开放定址法" class="headerlink" title="1.开放定址法"></a>1.开放定址法</h4><p>线性探测法</p><pre><code>f(key) = (f(key) + d) mod m  (d = 1,2,3...)</code></pre><p>二次探测法</p><pre><code>f(key) = (f(key) + d) mod m  (d = 1^2,-1^2,2^2,-2^2,3^2,-3^2...q^2,-q^2,其中q&lt;=m/2)</code></pre><p>随机探测法</p><pre><code>f(key) = (f(key) + d) mod m  (d 是一个随机数列)</code></pre><h4 id="2-再散列函数法"><a href="#2-再散列函数法" class="headerlink" title="2.再散列函数法"></a>2.再散列函数法</h4><pre><code>f(key) = RH(key)</code></pre><p>每次发生散列冲突时,就换一个散列函数计算.</p><h4 id="3-链地址法"><a href="#3-链地址法" class="headerlink" title="3.链地址法"></a>3.链地址法</h4><p>提供绝不会找不到地址的保障,但是带来查找时需要遍历单链表的性能损耗.</p><h4 id="4-公共溢出区法"><a href="#4-公共溢出区法" class="headerlink" title="4.公共溢出区法"></a>4.公共溢出区法</h4><p>增添溢出表.<br>对给定值通过散列函数计算出散列地址后,先与基本表的相应位置进行比对,如果相等,成功,否则,到溢出表中进行<strong>顺序查找</strong>.    </p><blockquote><p>参考并致谢<br><a href="https://www.zhihu.com/question/19809666/answer/88158084" target="_blank" rel="external">知乎 灰杉树</a><br><a href="http://haiyangxu.github.io/posts/2014/2014-05-05-binary_search_tree.html" target="_blank" rel="external">HAIYANG XU</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="external">v_JULY_v</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 关于查找算法。 &lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://blog.chenyalun.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>读《Objective-C高级编程》</title>
    <link href="http://blog.chenyalun.com/2017/04/13/%E8%AF%BB%E3%80%8AObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"/>
    <id>http://blog.chenyalun.com/2017/04/13/读《Objective-C高级编程》/</id>
    <published>2017-04-13T13:05:17.000Z</published>
    <updated>2017-04-13T13:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 关于ARC/Block/GCD。 </p><a id="more"></a><h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>寒假里就大致看了一遍，但是吸收的不完全，尤其是block部分。这两三天又赶紧从图书馆借来翻一翻，还是收获满满。不过C++不够扎实，很多源码还是看不明白(摊手)。这里把一些重点问题整理出来，以问答的形式进行总结，所有代码都尝试验证一下，没毛病。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="一-为什么苹果主要采用散列表管理引用计数"><a href="#一-为什么苹果主要采用散列表管理引用计数" class="headerlink" title="一.为什么苹果主要采用散列表管理引用计数"></a>一.为什么苹果主要采用散列表管理引用计数</h2><p><strong>GNUstep将引用计数保存在对象占用内存块头部的变量中。</strong><br>优点：</p><ol><li>只需少量代码。</li><li>能统一管理引用计数用内存块与对象用内存块。</li></ol><p><strong>苹果采用散列表（引用计数表，DenseMap 类实现）管理引用计数。</strong><br>优点：</p><ol><li>对象用内存块的分配无需考虑内存块头部。</li><li>引用计数表记录中存有内存块地址，可追溯各对象的内存块。有助于检测对象的持有者是否存在，可检测内存泄漏。</li></ol><p>注:如果设备是 64 位环境并且使用 Objective-C 2.0，那么“一些”对象会使用其 isa 指针的一部分空间来存储它的引用计数。</p><p><strong>苹果为什么不采用垃圾回收（GC）？</strong></p><p>苹果曾在OS X 10.5 尝试使用，不过在 10.7 的时候把 GC 换成了 ARC。GC 有个问题让苹果不能忍：垃圾回收的时候，整个程序需要暂停，英文把这个过程叫做：Stop the World。所有的对象都需要一起回收时，造成用户体验不好。</p><p><strong>ARC相对于GC所具有的优点：</strong></p><ol><li><p>ARC工作在编译期，在运行时没有额外开销。</p></li><li><p>ARC的内存回收是平稳进行的，对象不被使用时会立即被回收。而GC的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。</p></li></ol><p><strong>简单介绍GC的原理</strong><br>基于事实：大部分的对象的生命期都很短。</p><p>GC 将内存中的对象主要分成两个区域：Young 区和 Old 区。<br>对象先在 Young 区被创建，然后如果经过一段时间还存活着，则被移动到Old 区。（其实还有一个Perm区，但是内存回收算法通常不涉及这个区域）</p><p>Young区的对象因为大部分生命期都很短，每次回收之后只有少部分能够存活，所以采用的算法叫Copying算法，简单说来就是直接把活着的对象复制到另一个地方。Young 区内部又分成了三块区域：Eden区 ,From区 ,To区。每次执行 Copying 算法时，即将存活的对象从 Eden 区和 From 区复制到To区，然后交换 From 区和To区的名字（即From 区变成 To 区，To区变成From区）。</p><p>Old区的回收算法叫 Mark-Sweep 算法。简单来说，就是只是把不用的对象先标记（Mark）出来，然后回收（Sweep），活着的对象就不动它了。因为大部分对象都活着，所以回收下来的对象并不多。但是这个算法会有一个问题：它会产生内存碎片，所以它一般还会带有整理内存碎片的逻辑，在算法中叫做 Compact。</p><h2 id="二-如何提高Objective-C方法的速度"><a href="#二-如何提高Objective-C方法的速度" class="headerlink" title="二.如何提高Objective-C方法的速度"></a>二.如何提高Objective-C方法的速度</h2><p>采用IMP Caching。一般而言速度是其他方法的两倍。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> autorelease_class = [<span class="built_in">NSAutoreleasePool</span> <span class="keyword">class</span>];</div><div class="line">SEL autorelease_sel = <span class="keyword">@selector</span>(addObject:);</div><div class="line">IMP autorelease_imp = [autorelease_class methodForSelector:autorelease_sel];</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>) autorelease</div><div class="line">&#123;</div><div class="line">    (* autorelease_imp)(autorelease_class,autorelease_sel,<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)autorelease</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">NSAutoreleasePool</span> addObject:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>IMP的使用:实例方法+有参数+有返回值</strong></p><p>IMP默认是无参数，无返回值类型，且自带_cmd和selector。如果要使用带参数或者带返回值的IMP有两种方法。<br>方式一：关闭Xcode中的编译选项。<br><img src="http://static.chenyalun.com/2017/04/13/20170413001.png" alt=""></p><p>方式二：重新定义一个“IMP”，但不能同名，否则会报错，显示</p><p><code>Typedef redefinition with different types (&#39;id (*)(__strong id, SEL, ...)&#39; vs &#39;void (*)(void)&#39;)</code></p><p>这里统一采取第二种方式，即重新定义函数指针_IMP。</p><p><code>typedef id (*_IMP)(id, SEL,...);</code></p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// .h文件</span></div><div class="line">- (<span class="built_in">NSString</span> *)print:(<span class="built_in">NSString</span> *)name;</div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// .m文件</span></div><div class="line">- (<span class="built_in">NSString</span> *)print:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,name);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"因为我刚好遇见你"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line"><span class="comment">// 创建对象</span></div><div class="line">YAUser *user = [[YAUser alloc] init];</div><div class="line">user.name = @<span class="string">"张无忌"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 获取SEL</span></div><div class="line">SEL sel = @selector(print:);</div><div class="line"></div><div class="line"><span class="comment">// 获取函数指针</span></div><div class="line">_IMP instanceIMP1 = (_IMP)[YAUser instanceMethodForSelector:sel];</div><div class="line">_IMP instanceIMP2 = (_IMP)[user methodForSelector:sel];</div><div class="line"></div><div class="line"><span class="comment">// 调用方法并返回字符串</span></div><div class="line">NSString *name1 = (*instanceIMP1)(user, sel, user.name);</div><div class="line">NSString *name2 = (*instanceIMP2)(user, sel, user.name);</div><div class="line">NSLog(@"%@--%@",name1, name2);</div></pre></td></tr></table></figure><p><strong>IMP的使用:类方法+有参数+有返回值</strong></p><figure class="highlight monkey"><table><tr><td class="code"><pre><div class="line">+ (NSString *)printClassName:(<span class="class"><span class="keyword">Class</span>)<span class="title">className</span>;</span></div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"></div><div class="line">+ (<span class="built_in">NSString</span> *)printClassName:(Class)className &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,className);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"原谅我这一生不羁放纵爱自由"</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSStringFromClass</span>(className);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 调用</span></div><div class="line"><span class="comment">// 创建对象</span></div><div class="line">YAUser *user = [[YAUser alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 获取SEL</span></div><div class="line">SEL sel = <span class="meta">@selector(printClassName:)</span>;</div><div class="line"></div><div class="line"><span class="comment">// 获取函数指针</span></div><div class="line">_IMP classIMP = (_IMP)[[YAUser <span class="class"><span class="keyword">class</span>] <span class="title">methodForSelector</span>:<span class="type">sel];</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 调用方法并返回字符串</span></div><div class="line">NSString *name = (*classIMP)(user, sel, [user <span class="class"><span class="keyword">class</span>]);</span></div><div class="line">NSLog(@<span class="string">"%@"</span>,name);</div></pre></td></tr></table></figure><p><strong>实例方法/类方法+无参数+无返回值</strong></p><figure class="highlight lisp"><table><tr><td class="code"><pre><div class="line">- (<span class="name">void</span>)print<span class="comment">;</span></div><div class="line">+ (<span class="name">void</span>)printName<span class="comment">;</span></div></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="code"><pre><div class="line">- <span class="params">(void)</span>print&#123;</div><div class="line">    </div><div class="line">    NSLog<span class="params">(@<span class="string">"留下足迹才美丽"</span>)</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ <span class="params">(void)</span>printName &#123;</div><div class="line">    NSLog<span class="params">(@<span class="string">"风吹花落美如玉"</span>)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取SEL</span></div><div class="line">SEL sel1 = <span class="meta">@selector(print)</span>;</div><div class="line">SEL sel2 = <span class="meta">@selector(printName)</span>;</div><div class="line"></div><div class="line"><span class="comment">// 获取函数指针</span></div><div class="line">IMP instanceIMP = [[YAUser <span class="class"><span class="keyword">class</span>] <span class="title">instanceMethodForSelector</span>:<span class="type">sel1];</span></span></div><div class="line">IMP classIMP = [YAUser methodForSelector:sel2];</div><div class="line"></div><div class="line"><span class="comment">// 调用方法</span></div><div class="line">(*instanceIMP)();</div><div class="line">(*classIMP)();</div></pre></td></tr></table></figure><h2 id="三-非显式使用-autoreleasing的场景有哪些"><a href="#三-非显式使用-autoreleasing的场景有哪些" class="headerlink" title="三.非显式使用__autoreleasing的场景有哪些"></a>三.非显式使用__autoreleasing的场景有哪些</h2><p><strong>场景一:@autoreleasepool。</strong></p><p>编译器会检查@autoreleasepool块中的方法,如果<strong>不是</strong>以alloc/new/copy/mutableCopy开头，则自动把方法返回值的对象注册到autoreleasepool中。</p><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="variable">@autoreleasepool</span> &#123;</div><div class="line">    NSObject  *object = <span class="selector-attr">[[NSObject alloc]</span> <span class="selector-tag">init</span>];</div><div class="line">    <span class="comment">// ==&gt;NSObject __strong *object = [[NSObject alloc] init];</span></div><div class="line">    </div><div class="line">    NSArray *array = <span class="selector-attr">[NSArray array]</span>;</div><div class="line">    <span class="comment">// ==&gt;NSArray __autoreleasing  *array = [NSArray array];</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>场景二:方法的返回值。</strong></p><p>没有显式指定所有权修饰符，所以默认为__strong。由于return使得变量array超出作用域，强引用对应持有的对象会释放。但是该对象作为方法的返回值，编译器自动将其注册到自动释放池中，延缓释放(否则如果立即释放，那返回值就没有意义了)。</p><figure class="highlight ada"><table><tr><td class="code"><pre><div class="line">- (id)<span class="keyword">array</span> &#123;</div><div class="line">    NSArray *<span class="keyword">array</span> = [NSArray <span class="keyword">array</span>];</div><div class="line">    // ==&gt;NSArray __strong *<span class="keyword">array</span> = [NSArray <span class="keyword">array</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">array</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>场景三:<code>__weak</code>修饰的变量。</strong><br><code>__weak</code>修饰的变量会被自动注册到自动释放池中。由于<code>__weak</code>不持有对象的强引用，在访问该对象的时候，该对象有可能已经释放，但是要保证能访问到该对象，所以把它注册到自动释放池中，确保@autoreleasepool块结束之前该对象存在。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> object;</div></pre></td></tr></table></figure><p><strong>场景四:指向对象的指针的指针。</strong><br>指向对象的指针默认<strong>strong修饰。<br>指向对象的指针的指针默认</strong>autoreleasing修饰。</p><figure class="highlight abnf"><table><tr><td class="code"><pre><div class="line">NSObject *o<span class="comment">;</span></div><div class="line">// ==&gt;NSObject __strong *o<span class="comment">;</span></div><div class="line"></div><div class="line">NSObject **o<span class="comment">;</span></div><div class="line">// ==&gt;NSObject* __autoreleasing *o<span class="comment">;</span></div></pre></td></tr></table></figure><p><strong>为什么要使用指向对象的指针的指针?</strong><br>通常是回传值。<br>在C函数中，无法返回多个值，借助指针可以回传值。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 求两个数的和 积</span></div><div class="line"><span class="built_in">NSInteger</span> sum(<span class="built_in">NSInteger</span> a, <span class="built_in">NSInteger</span> b, <span class="built_in">NSInteger</span> *product) &#123;</div><div class="line">    <span class="comment">// 计算乘积</span></div><div class="line">    *product = a * b;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回求和</span></div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line">    <span class="built_in">NSInteger</span> a = <span class="number">3</span>, b = <span class="number">32</span>, summation, product;</div><div class="line">    summation = sum(a,b,&amp;product);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld--%ld"</span>,summation,product);</div></pre></td></tr></table></figure><p>在Objective-C中常用于NSError对象。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"这里是URL"</span>];</div><div class="line">[<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</div></pre></td></tr></table></figure><p><code>stringWithContentsOfURL:encoding:error:</code>方法返回字符串，但是在获取字符串的时候可能发生错误，于是传入指向NSError对象的指针的指针，用于回传值(error是指向对象的指针，*error是该对象，&amp;error是指向对象的指针的指针)。</p><p>赋给对象指针时，变量所有权修饰符必须保持一致，否则会出错。修饰error的是<strong>strong，而这里要求传入的指针的类型是</strong>autoreleasing:<code>(NSError * _Nullable __autoreleasing * _Nullable)</code>，修饰符不一致，不符合规则，但是编译器做了转换。</p><figure class="highlight subunit"><table><tr><td class="code"><pre><div class="line">// 转换所有权修饰符</div><div class="line">NSError *error = nil;</div><div class="line">NSError __autoreleasing *tmp = error;</div><div class="line">BOOL result = [obj performOperationWithError:&amp;tmp];</div><div class="line"><span class="keyword">error </span>= tmp;</div></pre></td></tr></table></figure><p><strong>可是为什么要使用__autoreleasing呢?</strong></p><p>实际上不注册到自动释放池也能传(返回)值，就像C函数中的回传乘积值一样。但是这样做不符合内存管理原则，只有作为alloc/new/copy/mutableCopy 开头的方法，能够自己生成并持有。也即其他方法的返回值取得对象(就像场景二中的返回值取得对象一样)需要注册到自动释放池，这便是原则。</p><p>如这种不符合内存管理原则的代码:</p><figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="type">CFGetRetainCount</span>(<span class="class"><span class="keyword">object</span>) <span class="title">!=</span> 1) </span>&#123;</div><div class="line">   <span class="type">CFRelease</span>(<span class="class"><span class="keyword">object</span>)</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (_objc_rootRetainCount(<span class="class"><span class="keyword">object</span>) <span class="title">!=</span> 1) </span>&#123;</div><div class="line">   _objc_rootRelease(<span class="class"><span class="keyword">object</span>)</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h2 id="四-内存泄漏的场景有哪些"><a href="#四-内存泄漏的场景有哪些" class="headerlink" title="四.内存泄漏的场景有哪些"></a>四.内存泄漏的场景有哪些</h2><h4 id="1-Core-Fundation的类型转换"><a href="#1-Core-Fundation的类型转换" class="headerlink" title="1. Core Fundation的类型转换"></a>1. Core Fundation的类型转换</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"></div><div class="line">CFMutableArrayRef <span class="built_in">array</span> = CFArrayCreateMutable(kCFAllocatorDefault, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="comment">// 引用计数为1</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</div><div class="line"></div><div class="line">id obj = (<span class="number">__b</span>ridge id)<span class="built_in">array</span>;</div><div class="line"></div><div class="line"><span class="comment">// 引用计数为2</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</div><div class="line"></div><div class="line"><span class="comment">// 不要使用_objc_rootRetainCount(),很不准很不准很不准</span></div><div class="line"><span class="comment">//NSLog(@"%d",_objc_rootRetainCount(fontRef));</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 如果不使用CFRelease()就会造成内存泄漏</span></div><div class="line">CFRelease(<span class="built_in">array</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</div></pre></td></tr></table></figure><p>主要原因是获取到CF对象后没有对其引用计数做出合适的处理。</p><h4 id="2-使用calloc函数创建动态数组"><a href="#2-使用calloc函数创建动态数组" class="headerlink" title="2. 使用calloc函数创建动态数组"></a>2. 使用calloc函数创建动态数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">//  声明动态数组</span></div><div class="line"><span class="comment">// 默认为__autoreleasing修饰,需显式指明为__strong</span></div><div class="line">id <span class="number">__</span>strong *<span class="built_in">array</span> = nil;</div><div class="line"></div><div class="line"><span class="comment">// 使用calloc分配内存</span></div><div class="line"><span class="built_in">array</span> = (id <span class="number">__</span>strong *)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(id));</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line"><span class="built_in">array</span>[<span class="number">0</span>] = @<span class="string">"Aaren"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 简单释放内存,造成内存泄漏</span></div><div class="line"><span class="comment">// 实际上对象array[0]还存在</span></div><div class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</div></pre></td></tr></table></figure><p>正确做法:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">//  声明动态数组</span></div><div class="line"><span class="comment">// 默认为__autoreleasing修饰,需显式指明为__strong</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> *array = <span class="literal">nil</span>;</div><div class="line"></div><div class="line"><span class="comment">// 声明容量</span></div><div class="line"><span class="built_in">NSInteger</span> num = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// 使用calloc分配内存</span></div><div class="line">array = (<span class="keyword">id</span> __<span class="keyword">strong</span> *)calloc(num, <span class="keyword">sizeof</span>(<span class="keyword">id</span>));</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line">array[<span class="number">0</span>] = <span class="string">@"Aaren"</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>;i &lt; num; i ++)&#123;</div><div class="line">    array[i] = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 释放内存</span></div><div class="line">free(array);</div></pre></td></tr></table></figure><p>注意:<br>1.不要使用malloc函数分配内存，malloc函数分配内存区域没有被初始化为0，可能产生随机访问导致错误，所以还需要使用memset()函数将内存填充为0。</p><p>2.对于NSMutableSet/NSMutableArray/NSMutableDictionary等容器，不需要人为手动管理。</p><h4 id="3-MRC下的匿名对象"><a href="#3-MRC下的匿名对象" class="headerlink" title="3. MRC下的匿名对象"></a>3. MRC下的匿名对象</h4><figure class="highlight clojure"><table><tr><td class="code"><pre><div class="line">[[NSObject alloc] init]<span class="comment">;</span></div></pre></td></tr></table></figure><p>匿名对象在MRC下会造成内存泄漏(C++中的匿名对象创建完毕后立即调用析构函数做销毁处理)。</p><p>但是在ARC环境下，不会造成内存泄漏。</p><figure class="highlight lisp"><table><tr><td class="code"><pre><div class="line">id temp = objc_msgSend(<span class="name">NSObject</span>, @selector(<span class="name">alloc</span>))<span class="comment">;</span></div><div class="line">objc_msgSend(<span class="name">temp</span>,@selector(<span class="name">init</span>))<span class="comment">;</span></div><div class="line">objc_release(<span class="name">temp</span>)<span class="comment">;</span></div></pre></td></tr></table></figure><p>创建完毕立即销毁，这也解释了为什么使用__weak修饰将要创建的对象会有警告。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> * __<span class="keyword">weak</span> object = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> object = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure><p>警告:Assigning retained object to weak variable; object will be released after assignment</p><h4 id="4-block的循环引用"><a href="#4-block的循环引用" class="headerlink" title="4. block的循环引用"></a>4. block的循环引用</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAUser</span> ()</span></div><div class="line">&#123;</div><div class="line">    block _block;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)func &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 循环引用</span></div><div class="line">    _block = ^() &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>,<span class="keyword">self</span>);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="五-weak如何实现"><a href="#五-weak如何实现" class="headerlink" title="五.__weak如何实现"></a>五.__weak如何实现</h2><p>weak 表的作用是在对象执行 dealloc 的时候将所有指向该对象的 weak 指针的值设为 nil，避免悬空指针。苹果使用一个全局的 weak 表来保存所有的 weak 引用。并将对象作为键，weak_entry_t 作为值。weak_entry_t 中保存了所有指向该对象的 weak 指针。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="keyword">weak_table_t</span> &#123;</div><div class="line">    <span class="keyword">weak_entry_t</span> *weak_entries;</div><div class="line">    <span class="keyword">size_t</span>    num_entries;</div><div class="line">    <span class="keyword">uintptr_t</span> mask;</div><div class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="六-Core-Fundation-与-Foundation如何转换"><a href="#六-Core-Fundation-与-Foundation如何转换" class="headerlink" title="六.Core Fundation 与 Foundation如何转换"></a>六.Core Fundation 与 Foundation如何转换</h2><p>1.<strong>__bridge</strong><br>只做类型转换，不修改相关对象的引用计数，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">CFMutableArrayRef <span class="built_in">array</span> = CFArrayCreateMutable(kCFAllocatorDefault, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="comment">// 引用计数为1</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</div><div class="line"></div><div class="line"><span class="comment">// obj强引用该对象(默认为__strong)</span></div><div class="line">id obj = (<span class="number">__b</span>ridge id)<span class="built_in">array</span>;</div><div class="line"></div><div class="line"><span class="comment">// 引用计数为2</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 如果不使用CFRelease()就会造成内存泄漏</span></div><div class="line">CFRelease(<span class="built_in">array</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,CFGetRetainCount(<span class="built_in">array</span>));</div></pre></td></tr></table></figure><p><img src="http://static.chenyalun.com/2017/04/13/20170413002.png" alt=""></p><p>2.<strong>__bridge_transfer</strong><br>常用在CF对象转化成OC对象时，将CF对象的所有权交给OC对象，此时ARC就能自动管理该内存,作用同CFBridgingRelease()</p><figure class="highlight smali"><table><tr><td class="code"><pre><div class="line"></div><div class="line">CFMutableArrayRef<span class="built_in"> array </span>= CFArrayCreateMutable(kCFAllocatorDefault, 0, NU<span class="class">LL);</span></div><div class="line"></div><div class="line">// 引用计数为1</div><div class="line">printf(<span class="string">"%ld\n"</span>,CFGetRetainCount(array));</div><div class="line"></div><div class="line">// obj持有对象 array放弃持有对象,相当于做了CFRelease()    </div><div class="line">id obj = (__bridge_transfer  id)array;</div></pre></td></tr></table></figure><p>3.<strong>bridge_retained</strong><br>与bridge_transfer 相反，常用在将OC对象转化成CF对象，且OC对象的所有权也交给CF对象来管理，即OC对象转化成CF对象时，涉及到对象类型和对象所有权的转化，作用同CFBridgingRetain()</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *obj = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line"><span class="built_in">CFMutableArrayRef</span> array2 = (__bridge_retained <span class="built_in">CFMutableArrayRef</span>)obj;</div><div class="line"></div><div class="line"><span class="comment">// 引用计数为2,obj持有对象,array2也持有对象</span></div><div class="line">printf(<span class="string">"%ld\n"</span>,<span class="built_in">CFGetRetainCount</span>(array2));</div><div class="line"></div><div class="line"><span class="comment">// 使用完毕,手动release,否则内存泄漏</span></div><div class="line"><span class="built_in">CFRelease</span>((array2));</div></pre></td></tr></table></figure><h2 id="七-简单介绍block"><a href="#七-简单介绍block" class="headerlink" title="七.简单介绍block"></a>七.简单介绍block</h2><p>block是能持有作用域变量的匿名函数，本质上是Objective-C对象。<br>语法格式:<code>^ 返回值类型 参数列表 表达式</code>,其中返回值类型可省略，无参数时参数列表可省略。<br>声明block与声明函数指针类似，执行block与调用函数类似。</p><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 返回值类型 (*f) 参数类型</span></div><div class="line"><span class="keyword">int</span> (*f)(<span class="keyword">int</span>) = &amp;<span class="function"><span class="keyword">func</span>;</span></div><div class="line"></div><div class="line">// 声明<span class="title">block</span></div><div class="line"><span class="title">int</span> <span class="params">(^blk)</span><span class="params">(<span class="keyword">int</span>)</span>;</div><div class="line"></div><div class="line">// 赋值</div><div class="line"><span class="title">int</span> <span class="params">(^blk2)</span><span class="params">(<span class="keyword">int</span>)</span> = ^<span class="params">(<span class="keyword">int</span> a)</span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 起别名</span></div><div class="line">typedef <span class="keyword">int</span> (^block) (<span class="keyword">int</span>);</div></pre></td></tr></table></figure><h3 id="block的三种类型"><a href="#block的三种类型" class="headerlink" title="block的三种类型"></a>block的三种类型</h3><ol><li>如果block没有访问外部的局部变量，或者访问的局部变量被static修饰，block存储在静态区，是NSConcreteGlobalBlock。</li><li>其他情况下，语法生成的block存放在栈中，是NSConcreteStackBlock。</li><li>当把栈中的block复制到堆上时，是NSConcreteMallocBlock。</li></ol><h3 id="block复制到堆上的情况"><a href="#block复制到堆上的情况" class="headerlink" title="block复制到堆上的情况"></a>block复制到堆上的情况</h3><p>大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上，只有当 block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；</p><p>编译器或者方法内部已经实现copy代码的情况:</p><ol><li>block作为函数返回值</li><li>赋值给 __strong id 类型的对象或 block 的成员变量</li><li>Cocoa框架方法名含有usingBlock</li><li>GCD中的API</li></ol><p>其他情况需要手动复制:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"> <span class="comment">// 程序异常:栈上的block被废弃 </span></div><div class="line"> </div><div class="line"> <span class="keyword">typedef</span> <span class="keyword">void</span>(^block) (<span class="keyword">void</span>);</div><div class="line"> </div><div class="line">- (<span class="keyword">id</span>)getBlockArray</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line">    <span class="keyword">return</span> [[<span class="built_in">NSArray</span> alloc] initWithObjects:</div><div class="line">            ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk0:%d"</span>, val);&#125;,</div><div class="line">            ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk1:%d"</span>, val);&#125;, <span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    block b = [<span class="keyword">self</span> getBlockArray][<span class="number">0</span>];</div><div class="line">    </div><div class="line">    b();</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>手动将block 复制到堆上:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^block) (<span class="keyword">void</span>);</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)getBlockArray</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line">    <span class="keyword">return</span> [[<span class="built_in">NSArray</span> alloc] initWithObjects:</div><div class="line">            [^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk0:%d"</span>, val);&#125; <span class="keyword">copy</span>],</div><div class="line">            [^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk1:%d"</span>, val);&#125; <span class="keyword">copy</span>], <span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    block b = [<span class="keyword">self</span> getBlockArray][<span class="number">0</span>];</div><div class="line">    </div><div class="line">    b();</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="block捕获变量"><a href="#block捕获变量" class="headerlink" title="block捕获变量"></a>block捕获变量</h3><p><strong>1.对于实例变量、静态全局变量、静态局部变量，全局变量，无论其为基本类型还是对象类型，在block中可读可写。</strong></p><p>定义在函数内部的变量称为局部变量（Local Variable）。<br>在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域默认是整个程序，也就是所有的源文件。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 静态全局变量</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> globalAge = <span class="number">10</span>;</div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *globalName = <span class="string">@"Aaren"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 局部变量</span></div><div class="line">    <span class="built_in">NSInteger</span> age = <span class="number">12</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 静态局部变量</span></div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSInteger</span> staticAge = <span class="number">17</span>;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *staticName = <span class="string">@"Bob"</span>;</div><div class="line"></div><div class="line">    YAUser *user = [[YAUser alloc] init];</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^func)() = ^() &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 修改实例变量</span></div><div class="line">        user.age = <span class="number">18</span>;</div><div class="line">        user.name = <span class="string">@"Jack"</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,user.age);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,user.name);</div><div class="line">        </div><div class="line">        <span class="comment">// 修改静态局部变量</span></div><div class="line">        staticAge = <span class="number">22</span>;</div><div class="line">        staticName = <span class="string">@"Lucy"</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,staticAge);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,staticName);</div><div class="line">        </div><div class="line">        <span class="comment">// 修改静态全局变量</span></div><div class="line">        globalAge = <span class="number">14</span>;</div><div class="line">        globalName = <span class="string">@"Allen"</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,globalAge);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,globalName);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    func();</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,user.age);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,user.name);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,staticAge);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,staticName);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,globalAge);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,globalName);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p><strong>2.对于局部变量，无论其是基本类型还是对象类型，在block中为只读，当使用<strong>block修饰时，变量可读可写。</strong>block修饰的对象类型变量，在ARC环境下，block对其强引用。在非ARC环境下，block不会对其retain。</strong></p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 局部变量</span></div><div class="line">     __block <span class="built_in">NSInteger</span> age = <span class="number">17</span>;</div><div class="line">     __block <span class="built_in">NSString</span> *name = <span class="string">@"Bob"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (^func)() = ^() &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 修改局部变量</span></div><div class="line">        age = <span class="number">18</span>;</div><div class="line">        name = <span class="string">@"Jack"</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,age);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,name);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    func();</div><div class="line">    </div><div class="line">    <span class="comment">// 修改局部变量</span></div><div class="line">    age = <span class="number">22</span>;</div><div class="line">    name = <span class="string">@"Aaren"</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,age);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,name);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="block的循环引用"><a href="#block的循环引用" class="headerlink" title="block的循环引用"></a>block的循环引用</h3><p>Capturing ‘self’ strongly in this block is likely to lead to a retain cycle.</p><p>.h文件</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAUser</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *object;</div><div class="line">- (<span class="keyword">void</span>)func;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>.m文件</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^block) ();</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAUser</span> ()</span></div><div class="line">&#123;</div><div class="line">    block _block;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAUser</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)func &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 循环引用</span></div><div class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    </div><div class="line">    _block = ^() &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.object);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    _block();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>由于block语法赋值给了成员变量，所以在栈上生成的block被复制到堆上。而block强引用了self的成员变量object，实际上是持有了self，self持有block的同时block持有self，于是self和block循环引用。</p><p><img src="http://static.chenyalun.com/2017/04/13/20170413003.png" alt=""><br>解决方案一:采用__weak修饰。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)func &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// __weak解决循环引用</span></div><div class="line">    <span class="keyword">self</span>.name = <span class="string">@"Aaren"</span>;</div><div class="line">    __<span class="keyword">weak</span> <span class="built_in">NSString</span> *weakName = <span class="keyword">self</span>.name;</div><div class="line"></div><div class="line">    <span class="comment">// ---此时weakName和self.name是同一个变量</span></div><div class="line"></div><div class="line">    _block = ^() &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,weakName);</div><div class="line">        </div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    _block();</div><div class="line"></div><div class="line">    <span class="comment">// ---此时weakName和self.name是同一个变量</span></div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.name = <span class="string">@"Jack"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// ---此时weakName和self.name不是同一个变量</span></div><div class="line"></div><div class="line">    <span class="comment">// 结果依然是@"Aaren"</span></div><div class="line">    _block();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)func &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// __weak解决循环引用</span></div><div class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">// 声明了一个self类型的weak指针，名字叫做weakSelf.</span></div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    _block = ^() &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,weakSelf.object);</div><div class="line">        </div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    _block();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>更改一方的强引用为弱引用打破了循环引用。但是有瑕疵:block内部可能捕获到空值。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)func &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// __weak解决循环引用</span></div><div class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    </div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    _block = ^() &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 现在立即使用weakSelf.object</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,weakSelf.object);</div><div class="line">        </div><div class="line">        <span class="comment">// 需要异步执行,但是却无法保证weakSelf.object一定存在</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,weakSelf.object);</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">// 调用block</span></div><div class="line">    _block();</div><div class="line">    </div><div class="line">    <span class="comment">// 自以为block调用完毕,不再需要self.object的值了,大胆地将self.object改为其他值</span></div><div class="line">    <span class="keyword">self</span>.object = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种情况就造成block内部正在使用持有变量的时候，变量的值却意外地改变了，甚至为nil，极易引发问题。<br>最佳方案:弱引用加强引用:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)func &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// __weak解决循环引用</span></div><div class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    </div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line">    </div><div class="line">   </div><div class="line">    _block = ^() &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// __strong可以不加,默认为__strong,但最好加上,更醒目</span></div><div class="line">        __<span class="keyword">strong</span> <span class="built_in">NSObject</span> *strongObject = weakSelf.object;</div><div class="line">        </div><div class="line">        <span class="comment">// 最好加上判断,保证strongObject不为空</span></div><div class="line">        <span class="keyword">if</span> (strongObject) &#123;</div><div class="line">            <span class="comment">// 现在立即使用weakSelf.object</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strongObject);</div><div class="line">            </div><div class="line">            <span class="comment">// 需要异步执行,可以保证weakSelf.object的值不改变</span></div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strongObject);</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 调用block</span></div><div class="line">    _block();</div><div class="line">    </div><div class="line">    <span class="comment">// 放心地将self.object改为其他值</span></div><div class="line">    <span class="keyword">self</span>.object = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这么做可以保证在block执行期间持有的变量不改变。但如果在block执行之前该变量已经为nil，那回天乏力。</p><p><strong>评价:</strong><br>这种方式不会造成循环引用:block弱引用的方式持有self.object，即不会影响self.object的释放。在block中是通过<strong>局部变量</strong>强引用self.object，作用域结束，局部变量销毁，不再强引用，从此你我是路人。</p><p><strong>注意事项:</strong><br>1.除了使用typeof()之外，还可以直接声明与self相同类型的变量，但依然需要使用__weak修饰。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">__<span class="keyword">weak</span> YAUser *weakSelf = <span class="keyword">self</span>;</div></pre></td></tr></table></figure><p>2.循环引用的本质是block强引用了self。但是如果以 以上代码为例:block持有了self的成员变量，完全可以通过以下方式解决。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)func &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 循环引用</span></div><div class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    <span class="built_in">NSObject</span> *weakObject = <span class="keyword">self</span>.object;</div><div class="line">    </div><div class="line">    _block = ^() &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,weakObject);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    _block();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>3.如果可以放宽要求，那么不把block设置为成员变量、把block中调用的代码抽取出来等都可以解决循环引用。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)func &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 循环引用</span></div><div class="line">    <span class="keyword">self</span>.object = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line">    </div><div class="line">    _block = ^() &#123;</div><div class="line">        [weakSelf log];</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    _block();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 把方法抽取出来</span></div><div class="line">- (<span class="keyword">void</span>)log &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.object);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>使用场景:</strong><br>不需要对block中持有的变量进行写入操作，也即仅仅读取变量。<br>当block异步使用持有的变量时，注意弱引用+强引用配合使用。<br>建议统一采用 <code>typeof(self) + 弱引用 + 强引用的形式</code>。</p><p>解决方案二:采用__block修饰。</p><p>产生循环引用的代码:</p><figure class="highlight erlang"><table><tr><td class="code"><pre><div class="line">- <span class="params">(void)</span>func &#123;</div><div class="line"></div><div class="line">    // 循环引用</div><div class="line">    _block = ^<span class="params">()</span> &#123;</div><div class="line">        NSLog<span class="params">(@<span class="string">"%p"</span>,self)</span>;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- <span class="params">(void)</span>execBlock &#123;</div><div class="line">    _block<span class="params">()</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解决循环引用:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)func &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 解决循环引用</span></div><div class="line">    __block <span class="keyword">id</span> tmp = <span class="keyword">self</span>;</div><div class="line">    _block = ^() &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>,tmp);</div><div class="line">        </div><div class="line">        <span class="comment">// 关键所在</span></div><div class="line">        tmp = <span class="literal">nil</span>;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)execBlock &#123;</div><div class="line">    _block();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>评价:</strong><br><strong>block本身不能解决循环引用，关键在于 在block中将</strong>block修饰的变量置为空。<br>当需要对持有的变量进行写入操作时可以使用。</p><p><strong>注意事项:</strong><br><strong>block必须执行</strong>，否则仍然不会解决循环引用。如下面代码:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)func &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 解决循环引用</span></div><div class="line">    __block <span class="keyword">id</span> tmp = <span class="keyword">self</span>;</div><div class="line">    _block = ^() &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>,tmp);</div><div class="line">        tmp = <span class="literal">nil</span>;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)execBlock &#123;</div><div class="line">    <span class="comment">// block没有执行,扔不能解决循环引用</span></div><div class="line">    <span class="comment">// _block();</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>为什么block没有执行就无法解决循环引用呢?</strong><br>在block中出现tmp的那刻起，block就已经持有了self，即产生了循环引用，如:</p><figure class="highlight ini"><table><tr><td class="code"><pre><div class="line"><span class="attr">_block</span> = ^() &#123;tmp;&#125;;</div></pre></td></tr></table></figure><p>而只有通过执行block才能把nil赋给tmp，才能打破循环引用。因此，执行block的目的是把nil赋予tmp，而把nil赋予tmp便能解决循环引用的原因是打破了self对block的强引用(self已经不存在了)。</p><h2 id="八-简要介绍GCD常用API"><a href="#八-简要介绍GCD常用API" class="headerlink" title="八.简要介绍GCD常用API"></a>八.简要介绍GCD常用API</h2><h3 id="1-dispatch-async与dispatch-sync"><a href="#1-dispatch-async与dispatch-sync" class="headerlink" title="1.dispatch_async与dispatch_sync"></a>1.dispatch_async与dispatch_sync</h3><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 异步执行</span></div><div class="line"><span class="selector-tag">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 同步执行dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;);</span></div></pre></td></tr></table></figure><h3 id="2-dispatch-queue-t"><a href="#2-dispatch-queue-t" class="headerlink" title="2.dispatch_queue_t"></a>2.dispatch_queue_t</h3><p>使用系统提供的queue</p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 主队列:串行队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</div><div class="line"></div><div class="line"><span class="comment">// 全局队列:并行队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> globalQueue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line"><span class="keyword">dispatch_queue_t</span> globalQueue2 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="keyword">dispatch_queue_t</span> globalQueue3 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</div><div class="line"><span class="keyword">dispatch_queue_t</span> globalQueue4 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</div></pre></td></tr></table></figure><p>自己创建queue</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 一般指定这两种类型</span></div><div class="line"><span class="comment">// DISPATCH_QUEUE_SERIAL</span></div><div class="line"><span class="comment">// DISPATCH_QUEUE_CONCURRENT</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.chenyalun.gcd.createQueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(createQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"  "</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// If your deployment target is iOS 6.0 or Mac OS X 10.8 or later</span></div><div class="line"><span class="comment">//dispatch_release(createQueue);</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 指定创建的队列与globalQueue享有同一优先级</span></div><div class="line"><span class="comment">// 不可指定系统的队列</span></div><div class="line">dispatch_set_target_queue(createQueue, globalQueue);</div></pre></td></tr></table></figure><p>注意:</p><ol><li>现在适配的版本一般大于iOS6,因此不必也不能对自己创建的queue进行dispatch_release，不会造成内存泄漏。</li><li>自己创建的队列严格按照格式来，尤其是作为第一个参数的queue的名称:”com.chenyalun.gcd.createQueue”</li><li>第二个参数设置为NULL，则为串行队列。specify DISPATCH_QUEUE_SERIAL (or NULL) to create a serial queue or specify DISPATCH_QUEUE_CONCURRENT to create a concurrent queue. In earlier versions, you must specify NULL for this parameter.</li></ol><h3 id="3-dispatch-resume-dispatch-suspend"><a href="#3-dispatch-resume-dispatch-suspend" class="headerlink" title="3.dispatch_resume/dispatch_suspend"></a>3.dispatch_resume/dispatch_suspend</h3><p>队列的挂起与恢复</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 全局队列:并行队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"你在何方 眼看天亮"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 挂起</span></div><div class="line">dispatch_suspend(globalQueue);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"都怪这夜色 撩人的疯狂"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 恢复执行</span></div><div class="line">dispatch_resume(globalQueue);</div></pre></td></tr></table></figure><h3 id="4-dispatch-apply"><a href="#4-dispatch-apply" class="headerlink" title="4.dispatch_apply"></a>4.dispatch_apply</h3><figure class="highlight gherkin"><table><tr><td class="code"><pre><div class="line"></div><div class="line">// 指定迭代的次数</div><div class="line">NSArray <span class="symbol">*</span>array = <span class="meta">@[</span><span class="meta">@1,</span> <span class="meta">@2,</span> <span class="meta">@3,</span> <span class="meta">@4,</span> <span class="meta">@5,</span> <span class="meta">@6,</span> <span class="meta">@7];</span></div><div class="line">dispatch_apply(array.count, globalQueue, ^(size_t index) &#123;</div><div class="line">    NSLog(<span class="meta">@"%</span><span class="meta">@",</span> [array objectAtIndex:index]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="5-dispatch-group"><a href="#5-dispatch-group" class="headerlink" title="5.dispatch_group"></a>5.dispatch_group</h3><figure class="highlight xquery"><table><tr><td class="code"><pre><div class="line"></div><div class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</div><div class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"这夜的风儿吹"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"我要 美丽的衣裳"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"为你 对镜贴花黄"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 保证以上三个任务执行完毕再执行下面的任务</div><div class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@<span class="string">"这夜色太紧张"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="code"><pre><div class="line"></div><div class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</div><div class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"这夜的风儿吹"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"我要 美丽的衣裳"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"为你 对镜贴花黄"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 保证以上三个任务执行完毕再执行下面的任务</span></div><div class="line"><span class="comment">// DISPATCH_TIME_NOW 不等待</span></div><div class="line"><span class="comment">// DISPATCH_TIME_FOREVER 永久等待</span></div><div class="line">NSInteger result = dispatch_group_wait(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER);</div><div class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// group中的任务全部执行完毕</span></div><div class="line">    NSLog(@<span class="string">"这夜色太紧张"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 任务没有执行完毕</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="6-dispatch-barrier"><a href="#6-dispatch-barrier" class="headerlink" title="6.dispatch_barrier"></a>6.dispatch_barrier</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一个任务"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二个任务"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 栅栏函数</span></div><div class="line">dispatch_barrier_async(globalQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"英雄之所以被称为英雄，可能只是第一枪打中了而已。"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第四个任务。"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第五个任务"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="7-dispatch-once"><a href="#7-dispatch-once" class="headerlink" title="7.dispatch_once"></a>7.dispatch_once</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// typedef long dispatch_once_t;</span></div><div class="line"><span class="comment">// static long onceToken;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"仅仅执行一次"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="8-dispatch-after"><a href="#8-dispatch-after" class="headerlink" title="8.dispatch_after"></a>8.dispatch_after</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><div class="line"><span class="keyword">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, </span>(int64_t)(<span class="number">3</span>.<span class="number">0</span> * NSEC_PER_SEC)), <span class="keyword">dispatch_get_main_queue(), </span>^&#123;</div><div class="line">        NSLog(@<span class="string">"你在何方 眼看天亮"</span>)<span class="comment">;</span></div><div class="line">    &#125;)<span class="comment">;</span></div></pre></td></tr></table></figure><p>指定3秒之后把要执行的任务追加到主队列中。最早3.0秒后执行，最迟3+1/60秒后执行，若主线程有延迟，时间会更长。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// DISPATCH_TIME_NOW</span></div><div class="line"><span class="comment">// DISPATCH_TIME_FOREVER</span></div><div class="line"><span class="comment">// 时间的单位为毫微秒</span></div><div class="line"><span class="keyword">dispatch_time_t</span> time = dispatch_time(DISPATCH_TIME_FOREVER, <span class="number">3000000</span>);</div></pre></td></tr></table></figure><h3 id="7-dispatch-semaphore"><a href="#7-dispatch-semaphore" class="headerlink" title="7.dispatch_semaphore"></a>7.dispatch_semaphore</h3><p>更细粒度的排他控制<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 全局队列:并行队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 设置信号量为1,也即保证同时访问的数量为1</span></div><div class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);</div><div class="line">NSMutableArray *<span class="built_in">array</span> = [NSMutableArray <span class="built_in">array</span>];</div><div class="line"></div><div class="line"><span class="comment">// 迭代添加对象</span></div><div class="line">dispatch_apply(<span class="number">100</span>, globalQueue, ^(<span class="keyword">size_t</span> index) &#123;</div><div class="line">    <span class="comment">// 将要添加元素前一直等待信号量为1</span></div><div class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">    </div><div class="line">    <span class="comment">// 放心地给数组添加元素</span></div><div class="line">    [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:(<span class="keyword">int</span>)index]];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加完成后释放信号量</span></div><div class="line">    dispatch_semaphore_signal(semaphore);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 关于ARC/Block/GCD。 &lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>读《SQL必知必会》</title>
    <link href="http://blog.chenyalun.com/2017/04/09/%E8%AF%BB%E3%80%8ASQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"/>
    <id>http://blog.chenyalun.com/2017/04/09/读《SQL必知必会》/</id>
    <published>2017-04-09T09:28:14.000Z</published>
    <updated>2017-04-09T09:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 关于SQLite数据库。 </p><a id="more"></a><p>采用 SQLite 数据库<br>所有命令都敲了一遍，没毛病。</p><h1 id="一、提要"><a href="#一、提要" class="headerlink" title="一、提要"></a>一、提要</h1><h2 id="1-语言"><a href="#1-语言" class="headerlink" title="1.语言"></a>1.语言</h2><ol><li><p>数据定义语言<br>CREATE 创建表/视图/其他对象<br>ALTER 修改对象<br>DROP 删除表/视图/其他对象</p></li><li><p>数据操纵语言<br>SELECT 检索数据<br>INSERT 创建记录<br>UPDATE 修改记录<br>DELETE 删除记录</p></li><li><p>数据控制语言<br>GRANT 赋予用户特权<br>REVOKE 收回用户特权</p></li></ol><h2 id="2-概念"><a href="#2-概念" class="headerlink" title="2.概念"></a>2.概念</h2><p>表:某种特定类型数据的结构化清单<br>字段:限定数据中的列(名)<br>记录:水平排列的数据的实体<br>列:表中的一个字段<br>模式:数据库和表的布局及特性<br>NULL值:表中以空白形式出现的值，表示没有设值<br>主键值:不重复，不为空，不能修改，不能重用</p><h2 id="3-类型"><a href="#3-类型" class="headerlink" title="3.类型"></a>3.类型</h2><p>SQLite无类型，在表声明中明确了字段类型，仍然可以在该字段中存储其它类型的数据。</p><p>NULL: 表示该值为NULL值。<br>INTEGER: 无符号整型值。<br>REAL: 浮点值。<br>TEXT: 文本字符串，存储使用的编码方式为UTF-8、UTF-16BE、UTF-16LE。<br>BLOB: 存储Blob数据，该类型数据和输入数据完全相同。<br>布尔数据类型：SQLite并没有提供专门的布尔存储类型，取而代之的是存储整型1表示true，0表示false。<br>日期和时间数据类型：以TEXT、REAL和INTEGER类型分别不同的格式表示该类型，如：</p><pre><code>TEXT: &quot;YYYY-MM-DD HH:MM:SS.SSS&quot;REAL: 以Julian日期格式存储INTEGER: 以Unix时间形式保存数据值，即从1970-01-01 00:00:00到当前时间所流经的秒数。</code></pre><h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h2><ol><li>正行注释 <code># 注释内容</code></li><li>多行注释 <code>/* 注释内容  */</code></li><li>行尾注释 <code>--注释内容</code></li></ol><h2 id="5-提示"><a href="#5-提示" class="headerlink" title="5.提示"></a>5.提示</h2><ol><li>多条语句必须以分号分隔。</li><li>SQL语句不区分大小写。</li><li>空格会被忽略，可以写成多行。</li></ol><h2 id="6-约束"><a href="#6-约束" class="headerlink" title="6.约束"></a>6.约束</h2><ol><li><p>NOT NULL:非空约束，不能有NULL值。</p><pre><code>ID INTEGER NOT NULL</code></pre></li><li><p>DEFAULT:默认值，数据未指定的默认值，如默认时间:<code>date(&#39;now&#39;)</code>。</p><pre><code>SALARY REAL DEFAULT 5000.0</code></pre> <figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 删除默认约束</span></div><div class="line"><span class="comment">-- 在SQLite中不可用</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t</div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> SALARY <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span></div></pre></td></tr></table></figure></li><li><p>UNIQUE:唯一,列中所有数据各不相同。</p><pre><code>AGE INTEGER UNIQUE</code></pre></li><li><p>主键:唯一标识数据表中的记录，不为空。</p><pre><code>PRIMARY KEY(ID,name)</code></pre> <figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 增加主键(前提列已经声明为非空)</span></div><div class="line"><span class="comment">-- 在SQLite中不可用</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">ID</span>)</div><div class="line"></div><div class="line"><span class="comment">-- 删除主键</span></div><div class="line"><span class="comment">-- 在SQLite中不可用</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span></div></pre></td></tr></table></figure></li><li><p>外键:唯一标识其他表中的一条记录。</p><pre><code>FOREIGN KEY(name) REFERENCES q(name)</code></pre> <figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 增加外键</span></div><div class="line"><span class="comment">-- 在SQLite中不可用</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t</div><div class="line"><span class="keyword">ADD</span> FOREIGN <span class="keyword">KEY</span> (C_ID) <span class="keyword">REFERENCES</span> <span class="keyword">USER</span> (<span class="keyword">ID</span>)</div><div class="line"><span class="comment">-- 删除外键</span></div><div class="line"><span class="comment">-- 在SQLite中不可用</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">DROP</span> FOREIGN <span class="keyword">KEY</span></div></pre></td></tr></table></figure></li><li><p>CHECK:保证列中所有值满足某一条件。</p><pre><code>AGE INT NOT NULL CHECK(AGE&lt;=18)</code></pre><pre><code>增加CHECK-- 在SQLite中不可用ALTER TABLE tMODIFY AGE INT NOT NULL CHECK(AGE&gt;=18)或者ALTER TABLE tADD CONSTRAINT checkConstraint CHECK(AGE&gt;=18)-- 删除CHECK-- 在SQLite中不可用ALTER TABLE tDROP CONSTRAINT checkConstraint</code></pre></li></ol><h2 id="7-范式"><a href="#7-范式" class="headerlink" title="7.范式"></a>7.范式</h2><p>第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列,如”地址”可以细分为:”省,市”。</p><p>第二范式（2NF）：首先是 1NF，其次一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。</p><p>第三范式（3NF）：首先是 2NF，其次非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8.函数"></a>8.函数</h2><blockquote><p>传送门：<br><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/02/15/2322027.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/02/15/2322027.html</a></p></blockquote><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理:"></a>字符串处理:</h3><p>UPPER() 大写转换<br>LENGTH() 字符串长度<br>LOWER() 小写转换<br>LTRIM() 去掉字符串左边的空格<br>RTRIM() 去掉字符串右边的空格</p><h3 id="日期时间处理"><a href="#日期时间处理" class="headerlink" title="日期时间处理"></a>日期时间处理</h3><p>date(‘now’) 返回当前日期。</p><p><code>date(&#39;now&#39;,&#39;start of month&#39;,&#39;1 month&#39;,&#39;-1 day&#39;)</code>返回当前月的最后一天。</p><h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><p>ABS() 绝对值<br>COS() 角度的余弦<br>EXP() 数的指数值<br>PI() 返回圆周率<br>SIN() 角度的正弦值<br>SQRT() 平方根<br>TAN() 角度的正切</p><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>AVG() 平均值,忽略NULL值</p><p>COUNT() 某列的行数,若指定列名则会忽略NULL值,而<code>COUNT(*)</code>对表中行的数目进行计数,无论是否为NULL都计数,DISTINCT不能用于<code>COUNT(*)</code>,如COUNT(DISTINCT *)为错误写法</p><p>MAX() 某列的最大值,忽略NULL值<br>MIN() 某列的最小值,忽略NULL值<br>SUM() 某列值的和,忽略NULL值</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>查看版本</p><pre><code>select sqlite_version();</code></pre><h2 id="9-视图"><a href="#9-视图" class="headerlink" title="9.视图"></a>9.视图</h2><p>视图只不过是通过相关的名称存储在数据库中的一个 SQLite 语句。视图实际上是一个以预定义的 SQLite 查询形式存在的表的组合。</p><p>SQLite仅支持只读视图，所以视图可以创建，可以读，但其内容不能更改。</p><p>视图的作用:<br>视图是一种虚表，允许用户实现以下几点：</p><ul><li><p>用户或用户组查找结构数据的方式更自然或直观。</p></li><li><p>限制数据访问，用户只能看到有限的数据，而不是完整的表。</p></li><li><p>汇总各种表中的数据，用于生成报告。</p></li></ul><h2 id="10-事务"><a href="#10-事务" class="headerlink" title="10.事务"></a>10.事务</h2><p>事务是一个对数据库执行工作单元,是以逻辑顺序完成的工作单位或序列。</p><p>事务是指一个或多个更改数据库的扩展。例如，如果正在创建一个记录或者更新一个记录或者从表中删除一个记录，那么正在该表上执行事务。重要的是要控制事务以确保数据的完整性和处理数据库错误。</p><p>可以把许多的 SQLite 查询联合成一组，把所有这些放在一起作为事务的一部分进行执行。</p><p>事务具有以下四个标准属性，通常根据首字母缩写为 ACID：</p><ul><li><p>Atomicity（原子性）原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p></li><li><p>Consistency（一致性）一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 </p></li><li><p>Isolation（隔离性）多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p></li><li><p>Durability（持久性）持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p></li></ul><p>撤销<br>ROLLBACK 命令是用于撤消尚未保存到数据库的事务的事务命令。<br>ROLLBACK 命令只能用于撤销自上次发出 COMMIT 或 ROLLBACK 命令以来的事务。</p><pre><code>BEGIN TRANSACTION;DELETE FROM t WHERE ID = 6;ROLLBACK;</code></pre><p>提交</p><pre><code>BEGIN TRANSACTION;DELETE FROM t WHERE ID = 5;-- 要做的事END TRANSACTION;-- 或者使用以下语法BEGIN;DELETE FROM t WHERE ID = 6;COMMIt;</code></pre><p><strong>注意:保存点在 SQLite (≥ 3.6.8)支持</strong><br>保留点,保留点越多越好</p><pre><code>SAVEPOINT delRow;  ROLLBACK TO delRow;  </code></pre><h2 id="11-索引"><a href="#11-索引" class="headerlink" title="11.索引"></a>11.索引</h2><p>索引是一种特殊的查找表，数据库搜索引擎用来加快数据检索，简单地说，索引是一个指向表中数据的指针。</p><pre><code>创建索引CREATE INDEX in_name_age ON t(name, age);删除索引DROP INDEX in_name;</code></pre><h2 id="12-顺序"><a href="#12-顺序" class="headerlink" title="12.顺序"></a>12.顺序</h2><table><thead><tr><th>子句</th><th>说明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>返回列</td><td>是</td></tr><tr><td>FROM</td><td>检索的表</td><td>从表中选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组</td><td>按组计算聚集时使用</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序</td><td>否</td></tr></tbody></table><p>妙记:</p><pre><code>SELECT kindID, COUNT(*)FROM tableWHERE PRICE &gt; 10GROUP BY kindIDHAVING COUNT(*) &gt;=2ORDER BY kindID;</code></pre><h1 id="二、命令"><a href="#二、命令" class="headerlink" title="二、命令"></a>二、命令</h1><h2 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1.SELECT"></a>1.SELECT</h2><p>检索单个列</p><pre><code>-- SELECT 列名 FROM 表名SELECT age FROM t;</code></pre><p>检索多个列</p><pre><code>SELECT name, age, groupID FROM t;</code></pre><p>检索所有列</p><pre><code>SELECT * FROM t;-- 检索不必要的列会降低检索和应用程序的性能</code></pre><p>检索并返回不同的值</p><pre><code>SELECT DISTINCT name, age FROM t;-- DISTINCT作用于所有的列,如SELECT DISTINCT groupID, age FROM t;-- 作用于groupID, age两列-- 当groupID, age双双重复,只会返回一个结果</code></pre><p>限制结果</p><pre><code>-- 不超过5行SELECT  name, age FROM t LIMIT 5;-- 从第10行开始检索,不超过7行SELECT  name, age FROM t LIMIT 5 OFFSET 3;</code></pre><p>1.LIMIT限制返回的行数，OFFSET指定从哪开始。<br>2.行数指的是索引行，即从第0行开始。</p><h2 id="2-ORDEY-BY"><a href="#2-ORDEY-BY" class="headerlink" title="2.ORDEY BY"></a>2.ORDEY BY</h2><p>ORDEY BY子句要保证放到最后</p><p>单个列排序</p><pre><code>-- 以age值的字母顺序/大小排列SELECT  name FROM t ORDER BY age;</code></pre><p>多个列排序</p><pre><code>-- 首先按照age,在age中按照nameSELECT  name, age FROM t ORDER BY age, name;</code></pre><p>按列位置排序</p><pre><code>-- 首先按照age,在age中按照name-- 3对应age, 1对应IDSELECT ID, name, age FROM t ORDER BY 3, 1;</code></pre><p>按降序排序</p><pre><code>-- DESC 只作用在它前面的列SELECT ID, name, age FROM t ORDER BY 3 DESC;SELECT ID, name, age FROM t ORDER BY 1 DESC,3 DESC;</code></pre><h2 id="3-WHERE"><a href="#3-WHERE" class="headerlink" title="3.WHERE"></a>3.WHERE</h2><p>常用操作符:<br>一般:=  !  =  &lt;  &gt;   &gt;=  &lt;=<br>介于之间:BETWEEN AND<br>为空值:IS NULL</p><p>一般使用</p><pre><code>SELECT age, name FROM table WHERE age &lt; 10;-- 单引号用来限定字符串-- 将值与字符串类型的列比较需要限定引号-- 将值与数值列进行比较不用引号SELECT ID, name, age FROM t WHERE age = 18;SELECT ID, name, age FROM t WHERE name = &apos;张无忌&apos;;</code></pre><p>范围筛选</p><pre><code>SELECT ID, name, age FROM t WHERE age BETWEEN 18 AND 22;</code></pre><p>空值检查</p><pre><code>SELECT ID, name, age FROM t WHERE sex IS NULL;</code></pre><h2 id="4-AND-OR"><a href="#4-AND-OR" class="headerlink" title="4.AND OR"></a>4.AND OR</h2><p>AND 优先级大于OR<br>组合使用注意加括号</p><pre><code>SELECT ID, name, age FROM t WHERE age = 18 AND name = &apos;唐僧&apos;;SELECT ID, name, age FROM t WHERE age = 18 OR groupID = 1;</code></pre><p>组合使用</p><pre><code>SELECT ID, name, age FROM t WHERE (age = 18 OR ID &lt; 12) AND groupID = 1;</code></pre><h2 id="5-IN"><a href="#5-IN" class="headerlink" title="5.IN"></a>5.IN</h2><p>关键字匹配</p><pre><code>-- 18,19岁SELECT ID, name, age FROM t WHERE age IN (18, 19);</code></pre><h2 id="6-NOT"><a href="#6-NOT" class="headerlink" title="6.NOT"></a>6.NOT</h2><p>否定其后的限定条件</p><pre><code>SELECT ID, name, age FROM t WHERE age NOT IN (18, 19);SELECT ID, name, age FROM t WHERE NOT age &lt; 22;</code></pre><h2 id="7-LIKE"><a href="#7-LIKE" class="headerlink" title="7.LIKE"></a>7.LIKE</h2><p>% 通配符<br>表示任何字符出现任意次数,不会匹配NULL</p><pre><code>SELECT ID, name, age FROM t WHERE name LIKE &apos;张%&apos;;SELECT ID, name, age FROM t WHERE name LIKE &apos;%六&apos;;</code></pre><p>_ 通配符<br>匹配单个字符,注意LIKE后的值使用字符串</p><pre><code>SELECT ID, name, age FROM t WHERE age LIKE &apos;2_&apos;;</code></pre><p><strong>注意:SQLite 不支持[] 通配符</strong><br><del>[] 通配符<br>指定一系列的字符,只要满足这些字符其中之一,且位置出现在“[]”通配符的位置的字符串就满足查询条件</del></p><pre><code>SELECT ID, name, age FROM t WHERE name LIKE &apos;[牛]%&apos;;-- 否定SELECT ID, name, age FROM t WHERE name LIKE &apos;[^牛]%&apos;;</code></pre><p>注意:少使用通配符,尽量不要把通配符置于开始处</p><h2 id="8-拼接"><a href="#8-拼接" class="headerlink" title="8.拼接"></a>8.拼接</h2><p>使用 || 拼接多个列</p><pre><code>SELECT age || &apos;(&apos; || name || &apos;)&apos; FROM t;-- 结果: 23(牛魔王)</code></pre><p>使用RTRIM去除填充列宽的文本值</p><pre><code>SELECT age || &apos;(&apos; || RTRIM(name) || &apos;)&apos; FROM t;RTRIM() 去掉字符串右边的空格LTRIM() 去掉字符串左边的空格TRIM() 去掉字符串左右两边的空格</code></pre><p>使用别名AS<br>  要求得到的是一列</p><pre><code>SELECT age || &apos;(&apos; || RTRIM(name) || &apos;)&apos;  AS Results FROM t;</code></pre><p>执行计算</p><pre><code>SELECT age + 3, name  FROM t;</code></pre><h2 id="9-GROUP-BY"><a href="#9-GROUP-BY" class="headerlink" title="9.GROUP BY"></a>9.GROUP BY</h2><p>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</p><pre><code>SELECT groupID, COUNT(*)  FROM t GROUP BY groupID;/* 含有COUNT(*)的分组的结果不该包含每列独有的字段,如name,ID等, 而应该是共性的字段,如分组ID等,因为目的是得知某组的COUNT */SELECT name FROM t GROUP BY name;</code></pre><h2 id="10-HAVING"><a href="#10-HAVING" class="headerlink" title="10.HAVING"></a>10.HAVING</h2><p>1.WHERE过滤行，而HAVING过滤分组,HAVING支持所有WHERE操作符<br>2.WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤</p><pre><code>SELECT groupID, COUNT(*)  FROM t GROUP BY groupID HAVING COUNT(*) &gt; 5;-- 筛选每组数量大于5</code></pre><h2 id="11-ORDER-BY"><a href="#11-ORDER-BY" class="headerlink" title="11.ORDER BY"></a>11.ORDER BY</h2><p>排序<br>HAVING常与GROUP BY连用</p><pre><code>SELECT groupID, COUNT(*)  FROM t WHERE age &gt; 18  GROUP BY groupID HAVING COUNT(*) &gt; 2ORDER BY groupID DESC;</code></pre><h2 id="12-子查询"><a href="#12-子查询" class="headerlink" title="12.子查询"></a>12.子查询</h2><p>在SELECT语句中，子查询总是从内向外处理。<br>作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误。</p><pre><code>SELECT name, age FROM t WHERE age IN (SELECT age FROM t WHERE age &gt; 10 AND sex IS NULL);</code></pre><h2 id="13-连接"><a href="#13-连接" class="headerlink" title="13.连接"></a>13.连接</h2><p>内连接是据根据每个表共有的列的值匹配两个表中的行</p><pre><code>SELECT t.name, age FROM t INNER JOIN q ON t.ID = q.ID;SELECT t.name, t.age FROM t, q WHERE t.name = q.name; -- 注意表的名称要匹配</code></pre><p>自连接,查询中需要的两个表实际上是相同的表</p><pre><code>SELECT a.name, a.age FROM t AS a, t AS b WHERE a.name = b.name AND b.ID = 10;</code></pre><p>外连接<br>1.外连接可以是左向外连接、右向外连接或完整外部连接<br>2.在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表(RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表)。<br>3.左向外连接的结果集包括LEFT  OUTER子句中指定的左表的所有行，而不仅仅是连接列所匹配的行。<br>4.右向外连接是左向外连接的反向连接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。   </p><p>SQLite支持左外连接LEFT OUTER JOIN，但不支持RIGHT OUTER JOIN 和 FULL OUTER JOIN语法。</p><pre><code>SELECT t.*, q.*  FROM t LEFt JOIN q ON t.ID = q.ID;   </code></pre><p>交叉连接。交叉连接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉连接也称作笛卡尔积。 </p><p>总结:<br>左外连接显示左表所有行+匹配行<br>右外连接显示右表所有行+匹配行<br>完整外部连接显示左表和右表中的所有行<br>内连接显示根据比较运算符匹配两个表中的行<br>自连接需要的两个表实际上是相同的表<br>交叉连接显示左表所有行+左表每一行与右表所有行的组合<br>连接不匹配时显示空值</p><h2 id="14-UNION"><a href="#14-UNION" class="headerlink" title="14.UNION"></a>14.UNION</h2><p>将结果组合成一个结果集<br>1.UNION中的每个查询必须包含相同的列、表达式或聚集函数<br>2.UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔<br>3.列数据类型必须兼容</p><pre><code>SELECT name, age FROM t WHERE name LIKE &apos;张%&apos; UNION SELECT name, age FROM t WHERE age &gt; 22;-- 相当于 &quot;并&quot;在一起</code></pre><h2 id="15-INSERT"><a href="#15-INSERT" class="headerlink" title="15.INSERT"></a>15.INSERT</h2><p>插入记录</p><pre><code>INSERT INTO t VALUES(13,      &apos;白骨精&apos;,      &apos;1543&apos;,      1,      NULL,      19,      1.68);INSERT INTOt(ID, name, phone, groupID, sex, age, height) VALUES(14, &apos;白龙马&apos;, &apos;1323&apos;, 0, NULL, 20, 1.69);</code></pre><p>VALUES必须以其指定的次序匹配指定的列名,更推荐这种方式<br>省略列:允许NULL或者有默认值</p><h2 id="16-CREATE-AS"><a href="#16-CREATE-AS" class="headerlink" title="16.CREATE AS"></a>16.CREATE AS</h2><p>复制表</p><pre><code>CREATE TABLE c AS SELECT * FROM t;</code></pre><h2 id="17-UPDATE"><a href="#17-UPDATE" class="headerlink" title="17.UPDATE"></a>17.UPDATE</h2><p>更新行</p><pre><code>UPDATE t SET height = 1.66 WHERE name = &apos;白龙马&apos;;-- 删除某列的值UPDATE t SET height = NULL  WHERE name = &apos;韦小宝&apos;;    </code></pre><p>更新多列,注意逗号</p><pre><code>UPDATE t SET height = 1.55, phone = &apos;1888&apos;, groupID = 0  WHERE name = &apos;唐僧&apos;;</code></pre><h2 id="18-DELETE"><a href="#18-DELETE" class="headerlink" title="18.DELETE"></a>18.DELETE</h2><p>删除行</p><pre><code>DELETE FROM t WHERE name = &apos;白龙马&apos;;</code></pre><h2 id="19-CREATE"><a href="#19-CREATE" class="headerlink" title="19.CREATE"></a>19.CREATE</h2><p>创建表</p><pre><code>CREATE TABLE d(ID INTEGER NOT NULL UNIQUE,name TEXT NOT NULL,sex INTEGER DEFAULT 0,height REAL CHECK(height &gt; 0),PRIMARY KEY(&apos;ID&apos;)FOREIGN KEY(name) REFERENCES q(name));</code></pre><p>主键单独标明。</p><h2 id="20-ALTER"><a href="#20-ALTER" class="headerlink" title="20.ALTER"></a>20.ALTER</h2><p>给表增加一列</p><pre><code>ALTER TABLE bADD place TEXT;    </code></pre><p>重命名表</p><pre><code>ALTER TABLE bRENAME TO bbb;</code></pre><p>在 SQLite 中，除了重命名表和在已有的表中添加列，ALTER TABLE 命令不支持其他操作,包括删除列,定义主键和外键等.</p><p>SQLite不支持删除列</p><pre><code>ALTER TABLE t DROP COLUMN vend_phone;</code></pre><h2 id="21-DROP"><a href="#21-DROP" class="headerlink" title="21.DROP"></a>21.DROP</h2><p>删除表</p><pre><code>DROP TABLE t;</code></pre><h2 id="22-视图"><a href="#22-视图" class="headerlink" title="22.视图"></a>22.视图</h2><p>创建视图</p><pre><code>CREATE VIEW view_b AS SELECT name, age FROM t;</code></pre><p>查看视图</p><pre><code>SELECT * FROM view_b;</code></pre><p>删除视图</p><pre><code>DROP VIEW view_b;</code></pre><blockquote><p>参考感谢：<br><a href="http://zhiwei.li/text/2010/08/23/sqlite%E5%A4%96%E9%94%AE/" target="_blank" rel="external">http://zhiwei.li/text/2010/08/23/sqlite%E5%A4%96%E9%94%AE/</a><br><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/02/22/2325258.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/02/22/2325258.html</a><br><a href="http://www.runoob.com/sqlite/sqlite-syntax.html" target="_blank" rel="external">http://www.runoob.com/sqlite/sqlite-syntax.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 关于SQLite数据库。 &lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="数据库" scheme="http://blog.chenyalun.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>读《Effective Objective-C 2.0》</title>
    <link href="http://blog.chenyalun.com/2017/04/05/%E8%AF%BB%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B/"/>
    <id>http://blog.chenyalun.com/2017/04/05/读《Effective Objective-C 2.0》/</id>
    <published>2017-04-05T04:02:17.000Z</published>
    <updated>2017-04-05T05:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 许多小技巧。 </p><a id="more"></a><h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>一晚上加一早上时间读了一遍,很多技巧都屡有耳闻,不过还是收获许多.</p><h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><ol><li>.h文件中使用@class声明类,.m文件中使用import导入其他头文件,而不是只在.h文件中import头文件</li><li>常量使用static const,其他情况(如[NSNotificationCenter defaultCenter])使用宏</li><li>不需要位或运算的枚举使用NS_ENUM,需要使用位或运算的枚举使用NS_OPTIONS,避免C语言中的enum</li><li>switch状态机下避免default分支(确保switch正确处理已知情况,往后增加新的的枚举值会有警告)</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="1-属性声明为-dynamic后该怎么做"><a href="#1-属性声明为-dynamic后该怎么做" class="headerlink" title="1.属性声明为@dynamic后该怎么做"></a>1.属性声明为@dynamic后该怎么做</h2><p>.h文件暴露属性</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div></pre></td></tr></table></figure><p>.m文件动态添加方法</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAHeader</span> ()</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *_name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAHeader</span></span></div><div class="line"><span class="keyword">@dynamic</span> name;</div><div class="line"></div><div class="line"><span class="comment">// 添加set方法,要传入参数</span></div><div class="line"><span class="keyword">void</span> dynamicSetMethodIMP(YAHeader *<span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *prame) &#123;</div><div class="line">    <span class="keyword">self</span>-&gt;_name = prame;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 添加get方法,要返回NSString *类型</span></div><div class="line"><span class="built_in">NSString</span> *dynamicGetMethodIMP(YAHeader *<span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;_name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(setName:)) &#123;</div><div class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)dynamicSetMethodIMP, <span class="string">"v@:@"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(name)) &#123;</div><div class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)dynamicGetMethodIMP, <span class="string">"v@:"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>注意:<br>1.按照本书所说,使用@dynamic将仅仅生成get/set方法的声明,不会生成get/set方法的实现,也不会合成成员变量</p><p>2.由于没有合成成员变量,所以手动添加</p><p>3.使用@property但是却没有合成成员变量的情景有:<br>(1):同时使用@property和@dynamic<br>(2):set和get方法均手动实现<br>(3):分类中@property<br>值得一提的是,当使用<code>@synthesize num;</code>时,将不会生成成员变量<code>_num</code>,而是生成成员变量<code>num</code></p><h2 id="2-关联对象中为什么使用static修饰的指针"><a href="#2-关联对象中为什么使用static修饰的指针" class="headerlink" title="2.关联对象中为什么使用static修饰的指针"></a>2.关联对象中为什么使用static修饰的指针</h2><p>static的作用之一便是使变量在内存中只有一份拷贝,由于需要objc_setAssociatedObject和objc_getAssociatedObject中的两个键(void *key)需要匹配同一个值(关联的对象),所以需要两者是完全相同的指针,故而使用静态全局变量做键</p><h2 id="3-简述Objective-C在发送消息时的动态性"><a href="#3-简述Objective-C在发送消息时的动态性" class="headerlink" title="3.简述Objective-C在发送消息时的动态性"></a>3.简述Objective-C在发送消息时的动态性</h2><p>静态绑定:将在运行期间调用的函数在编译期间已经确定<br>动态绑定:发送的消息部分转化为objc_msgSend函数,传入将要调用函数的对象、将要调用的函数以及将要调用的函数的参数,具体调用哪个函数,通过快速映射表、方法列表亦或是消息转发确定<br>objc_msgSend_stret:消息返回结构体调用<br>objc_msgSend_fpret:消息返回浮点数调用<br>objc_msgSendSuper:给超类发送消息调用</p><h2 id="4-如何解决unrecognized-selector-send-to-instance"><a href="#4-如何解决unrecognized-selector-send-to-instance" class="headerlink" title="4.如何解决unrecognized selector send to instance"></a>4.如何解决unrecognized selector send to instance</h2><p>消息转发的三个流程<br>1.对象收到无法识别的消息,根据使类方法还是对象方法调用<br><code>+ (BOOL)resolveInstanceMethod:(SEL)selector</code><br><code>+ (BOOL)resolveClassMethod:(SEL)selector</code><br>前提:相关方法的实现代码已经写好<br>使用:根据类方法还是对象方法,在resolveMethod中为无法响应的selector动态添加方法实现(提供函数指针IMP)<br><figure class="highlight lisp"><table><tr><td class="code"><pre><div class="line">class_addMethod(<span class="name">self</span>, selector, (<span class="name">IMP</span>)methodImplemention,<span class="string">"v@:@"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>若没有做出处理,返回NO</p><p>2.倘若没有相关方法实现,进入<br><code>- (id)forwardingTargetForSelector:(SEL)selector</code><br>将消息转发给其他对象,若找不到,返回nil</p><p>3.完整的消息转发,调用对象方法<br><code>- (void)forwardInvocation:(NSInvocation *)invocation</code><br>首先发送-methodSignatureForSelector:获取函数的参数和返回值类型,若返回nil,直接挂掉,否则Runtime创建一个NSIn<br>vocation对象,发送forwardInvocation消息给目标对象</p><h2 id="5-如何实现多重继承"><a href="#5-如何实现多重继承" class="headerlink" title="5.如何实现多重继承"></a>5.如何实现多重继承</h2><p>C类 继承自 A类,想让C类对象同时具备A类方法和 B类方法的能力<br>使C类对象中拥有B类对象(组合),在C类对象中实现对象方法forwardingTargetForSelect:方法,将发送来的B类方法转发给所拥有的B类对象处理</p><h2 id="6-怎么实现方法实现的交换"><a href="#6-怎么实现方法实现的交换" class="headerlink" title="6.怎么实现方法实现的交换"></a>6.怎么实现方法实现的交换</h2><figure class="highlight ceylon"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取通过SEL获取一个方法</span></div><div class="line"><span class="keyword">class</span><span class="number">_</span>getInstanceMethod</div><div class="line"></div><div class="line"><span class="comment">// 获取一个方法的实现</span></div><div class="line">method<span class="number">_</span>getImplementation</div><div class="line"></div><div class="line"><span class="comment">// 获取一个OC实现的编码类型</span></div><div class="line">method<span class="number">_</span>getTypeEncoding</div><div class="line"></div><div class="line"><span class="comment">// 給方法添加实现</span></div><div class="line"><span class="keyword">class</span><span class="number">_</span>addMethod</div><div class="line"></div><div class="line"><span class="comment">// 用一个方法的实现替换另一个方法的实现</span></div><div class="line"><span class="keyword">class</span><span class="number">_</span>replaceMethod</div><div class="line"></div><div class="line"><span class="comment">// 交换两个方法的实现</span></div><div class="line">method<span class="number">_</span>exchangeImplementations</div></pre></td></tr></table></figure><p>获取Method<br><figure class="highlight monkey"><table><tr><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">Method</span> <span class="title">lowercaseString</span> =</span> class_getInstanceMethod([NSString <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">lowercaseString</span>));</span></div><div class="line">    <span class="function"><span class="keyword">Method</span> <span class="title">uppercaseString</span> =</span> class_getInstanceMethod([NSString <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">uppercaseString</span>));</span></div><div class="line">    method_exchangeImplementations(lowercaseString, uppercaseString);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>表面上看是死循环:</p><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (NSString *)<span class="selector-tag">lowercaseString</span> &#123;</div><div class="line">    return self<span class="selector-class">.lowercaseString</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">-</span> (NSString *)<span class="selector-tag">uppercaseString</span> &#123;</div><div class="line">    return self<span class="selector-class">.uppercaseString</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="7-简述为代码加锁的方式"><a href="#7-简述为代码加锁的方式" class="headerlink" title="7.简述为代码加锁的方式"></a>7.简述为代码加锁的方式</h2><p>同步块:</p><pre><code>@synchronized(self) {//...}</code></pre><p>滥用@synchronized(self)很危险,所有的块都会彼此抢夺同一个锁.</p><p>锁对象:<br><figure class="highlight prolog"><table><tr><td class="code"><pre><div class="line"><span class="symbol">_lock</span> = [[<span class="symbol">NSLock</span> alloc] init];</div><div class="line"></div><div class="line">[<span class="symbol">_lock</span> lock];</div><div class="line">// ...</div><div class="line">[<span class="symbol">_lock</span> unlock];</div></pre></td></tr></table></figure></p><h2 id="8-原子性一定安全吗-如何确保属性的线程安全"><a href="#8-原子性一定安全吗-如何确保属性的线程安全" class="headerlink" title="8.原子性一定安全吗,如何确保属性的线程安全"></a>8.原子性一定安全吗,如何确保属性的线程安全</h2><p>不一定.<br>原子性能保证存取方法的线程安全,也即读写操作是原子性的,在读或者写发生的时候,其他读或者写操作必须等待.<br>然而同一个线程上多次调用get方法,每一次获取到的值未必相同,多次访问期间,其他线程可能会写入新的值.比如当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全.</p><p>线程安全:不会出现数据不一致或者数据污染。</p><p>使用串行同步队列,将读取以及写入操作都安排在同一个队列中,即可保证数据同步.</p><p>方式一:同步派发(在set方法简单的时候使用)</p><p>.h文件<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div></pre></td></tr></table></figure></p><p>.m文件<br>1.创建串行队列<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAHeader</span> ()</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> _serialQueue;</div><div class="line">&#125;</div><div class="line"><span class="keyword">char</span> * <span class="keyword">const</span> label = <span class="string">"label"</span>;</div><div class="line"> _serialQueue = dispatch_queue_create(label, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p><p>2.合成属性(由于需要重写get/set方法,编译器已取消自动合成)<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAHeader</span></span></div><div class="line"></div><div class="line"><span class="keyword">@synthesize</span> name = _name;</div><div class="line"><span class="keyword">char</span> * <span class="keyword">const</span> label = <span class="string">"label"</span>;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="built_in">dispatch_sync</span>(_serialQueue, ^&#123;</div><div class="line">        _name = name;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">   </div><div class="line">    __block <span class="built_in">NSString</span> *localName;</div><div class="line">    <span class="built_in">dispatch_sync</span>(_serialQueue, ^&#123;</div><div class="line">        localName = _name;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> localName;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p><p>方式二:异步派发(在set方法复杂的时候使用)<br>改动set方法</p><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">name</span> &#123;</div><div class="line">    <span class="selector-tag">dispatch_async</span>(_serialQueue, ^&#123;</div><div class="line">         _name = name;</div><div class="line">         </div><div class="line">         <span class="comment">// ...(还有许多操作)</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在异步派发的时候需要拷贝block,需要消耗一定时间,所以在set方法更复杂的场景下使用</p><h2 id="9-performSelector的局限性有哪些"><a href="#9-performSelector的局限性有哪些" class="headerlink" title="9.performSelector的局限性有哪些"></a>9.performSelector的局限性有哪些</h2><p>1.由于无法确定将要执行的selector具体是什么,ARC无法将其纳入合适的内存管理方法中,可能有内存泄漏<br>2.selector的返回值类型和参数个数、类型受到限制<br>建议使用GCD中的dispatch_async/dispatch_after等代替相应的performSelector</p><figure class="highlight armasm"><table><tr><td class="code"><pre><div class="line"></div><div class="line">- (void)fetchSelector:(NSInteger)condition &#123;</div><div class="line">    <span class="keyword">SEL </span><span class="keyword">selector;</span></div><div class="line">    <span class="meta">if</span> (condition == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">selector </span>= <span class="comment">@selector(dismiss);</span></div><div class="line">    &#125; <span class="meta">else</span> <span class="meta">if</span> (condition == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">selector </span>= <span class="comment">@selector(miss:);</span></div><div class="line">    &#125; <span class="meta">else</span> &#123;</div><div class="line">         <span class="keyword">selector </span>= <span class="comment">@selector(love);</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">self </span>performSelector:<span class="keyword">selector];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>警告:/Users/chenyalun/Desktop/iOS/program/Demo170404/Demo170404/YAHeader.m:70:11: PerformSelector may cause a leak because its selector is unknown</p><h2 id="10-bridge、bridge-retained与-bridge-transfer的区别"><a href="#10-bridge、bridge-retained与-bridge-transfer的区别" class="headerlink" title="10.bridge、bridge_retained与__bridge_transfer的区别"></a>10.<strong>bridge、</strong>bridge_retained与__bridge_transfer的区别</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">10</span>, @<span class="number">11</span>, @<span class="number">12</span>];</div><div class="line"><span class="built_in">CFArrayRef</span> cfarray = (__bridge <span class="built_in">CFArrayRef</span>)array;</div><div class="line"></div><div class="line"><span class="built_in">CFArrayRef</span> cfarray2 = (__bridge_retained <span class="built_in">CFArrayRef</span>)array;</div><div class="line"><span class="built_in">CFRelease</span>(cfarray2);</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *array2 = (__bridge_transfer <span class="built_in">NSArray</span> *)cfarray;</div></pre></td></tr></table></figure><p>__bridge表示ARC仍然具备该对象的所有权</p><p>__bridge_retained表示ARC交出该对象的所有权(需手动release)</p><p>__bridge_transfer:表示反向转换,同时ARC获取对象所有权</p><h2 id="11-NSCache相较NSDictionary的优点"><a href="#11-NSCache相较NSDictionary的优点" class="headerlink" title="11.NSCache相较NSDictionary的优点"></a>11.NSCache相较NSDictionary的优点</h2><p>1.在系统发出低内存通知时,NSCache自动删减缓存,并且先行删减最久未使用的对象<br>2.增加键的引用计数而不是拷贝它<br>3.NSCache线程安全,可以多线程访问而不出错<br>4.NSPurgeableData是NSMutableData的子类,将它与NSCache搭配使用,当NSPurgeableData对象所占内存为系统所丢弃时,该对象自动从NSCache缓存中清除</p><p>访问NSPurgeableData对象</p><figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">NSCache *cache = [[NSCache alloc] init];</div><div class="line"></div><div class="line">NSPurgeableData *purgeableData = [NSPurgeableData <span class="string">dataWithBytes:</span>@<span class="string">"ILOVEYOU"</span> <span class="string">length:</span><span class="number">10</span>];</div><div class="line">[cache <span class="string">setObject:</span>purgeableData <span class="string">forKey:</span>@<span class="number">00</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 访问NSPurgeableData</span></div><div class="line"><span class="keyword">if</span> (purgeableData) &#123;</div><div class="line">    <span class="comment">// 开始访问,现在还不应该丢弃自己所占用的内存</span></div><div class="line">    [purgeableData beginContentAccess];</div><div class="line">    </div><div class="line">    </div><div class="line">    [self <span class="string">useData:</span>purgeableData];</div><div class="line">    </div><div class="line">    <span class="comment">// 结束访问,现在可以丢弃自己所占用的内存啦</span></div><div class="line">    [purgeableData endContentAccess];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参考资料:</p><blockquote><p>乞力马扎罗的雪的博客:<a href="http://blog.csdn.net/chenyufeng1991/article/details/49687215" target="_blank" rel="external"> blog.csdn.net/chenyufeng1991/article/details/49687215</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 许多小技巧。 &lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C提要</title>
    <link href="http://blog.chenyalun.com/2017/04/02/C%E6%8F%90%E8%A6%81/"/>
    <id>http://blog.chenyalun.com/2017/04/02/C提要/</id>
    <published>2017-04-02T03:22:17.000Z</published>
    <updated>2017-05-11T10:19:06.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 不堪回首。 </p><a id="more"></a><p>Java、前端、Android、iOS的笔试题涌现大量C++的内容，我和小伙伴们苦不堪言，于是特意抽大半天时间试着回忆一下。</p><h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><h2 id="1-命名空间如何使用"><a href="#1-命名空间如何使用" class="headerlink" title="1.命名空间如何使用"></a>1.命名空间如何使用</h2><p>防止出现变量或函数的命名冲突.</p><p>在 main() 函数中声明命名空间 std，它的作用范围就位于 main() 函数内部，如果在其他函数中又用到了 std，就需要重新声明</p><p>如果希望在所有函数中都使用命名空间 std，可以将它声明在全局范围中<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 定义</span></div><div class="line"><span class="keyword">namespace</span> YA &#123;</div><div class="line"><span class="keyword">int</span> a;</div><div class="line"><span class="comment">// 变量、类、函数、typedef、#define 等都可以出现在命名空间中</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 使用方式一:域解析操作符</span></div><div class="line"><span class="comment">// :是域解析操作符,指明要使用的命名空间</span></div><div class="line">YA :: a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// 使用方式二:针对变量</span></div><div class="line"><span class="comment">// 如果以后出现了未指明命名空间的a，就使用YA :: a</span></div><div class="line"><span class="keyword">using</span> YA :: a;</div><div class="line">a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// 使用方式三:针对命名空间</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> YA; <span class="comment">// 声明整个命名空间</span></div></pre></td></tr></table></figure></p><h2 id="2-C-现行标准库"><a href="#2-C-现行标准库" class="headerlink" title="2.C++现行标准库"></a>2.C++现行标准库</h2><p>对于不带.h的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；<br>对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域</p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure><p>C语言的头文件在 C++ 中依然被支持，C++ 新增的库更加强大和灵活,例如 iostream、fstream、string 等</p><p>推荐:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure></p><h2 id="3-cin与cout"><a href="#3-cin与cout" class="headerlink" title="3.cin与cout"></a>3.cin与cout</h2><p>cout 和 cin 分别是 ostream 和 istream 类的对象,而不是关键字<br>使用:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> a,b;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a是"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"b是"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>其中endl表示end of line,表示换行,可用\n代替</p><h2 id="4-C-中const的作用"><a href="#4-C-中const的作用" class="headerlink" title="4.C++中const的作用"></a>4.C++中const的作用</h2><p>1.定义常量<br><code>const int a = 10; // a不可修改</code></p><p>2.类型检查<br><code>void f(const int i){}// 对传进来的参数进行类型检查,不匹配则提示</code></p><p>3.保护参数<br><code>void f(const int i){}// i不可修改</code></p><p>4.节省空间<br><figure class="highlight processing"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 替换三次,分配三次内存空间</span></div><div class="line">#define pi <span class="number">3.14</span></div><div class="line"><span class="keyword">double</span> a = pi;</div><div class="line"><span class="keyword">double</span> b = pi;</div><div class="line"><span class="keyword">double</span> c = pi;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> <span class="literal">PI</span> = <span class="number">3.14</span></div><div class="line"><span class="comment">// 只分配一次内存空间</span></div><div class="line"><span class="keyword">double</span> d = <span class="literal">PI</span>;</div><div class="line"><span class="comment">// 不再分配内存空间</span></div><div class="line"><span class="keyword">double</span> e = <span class="literal">PI</span>;</div></pre></td></tr></table></figure></p><p>混淆点:<br>指针本身是常量不可变,不可以指向其他</p><pre><code>char* const pContent;</code></pre><p>指针所指向的内容是常量不可变</p><pre><code>const char *pContent;</code></pre><p>两者都不可变</p><pre><code>const char* const pContent;</code></pre><h2 id="5-动态分配内存"><a href="#5-动态分配内存" class="headerlink" title="5.动态分配内存"></a>5.动态分配内存</h2><p>在C中<br>分配</p><pre><code>int *p = (int *)malloc(sizeof(int) * 10);</code></pre><p>释放</p><pre><code>free(p);</code></pre><p>在C++中 new[]分配 delete[]释放</p><pre><code>int *p = new int;delete p;int *p = new int[10];  //分配10个int型的内存空间delete[] p;</code></pre><p>new 是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收<br>用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。</p><h2 id="6-函数调用的流程"><a href="#6-函数调用的流程" class="headerlink" title="6.函数调用的流程"></a>6.函数调用的流程</h2><p>函数调用是有时间和空间开销的(递归效率低下)。<br>程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。</p><h2 id="7-内联函数"><a href="#7-内联函数" class="headerlink" title="7.内联函数"></a>7.内联函数</h2><p>作用:为了消除函数调用的时空开销，在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数.</p><p>在<strong>函数定义处</strong>添加inline关键字,声明处添加无效.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"内联函数"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意:</p><ol><li>当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以一般是将非常短小的函数声明为内联函数。</li><li>对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的。编译器有自己的判断能力，它会根据具体情况决定是否这样做。如何函数体非常大，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。</li></ol><p>缺点:编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大。</p><p>总结:小而短的函数声明为内联函数.</p><p>内联函数替代宏<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(a,b) (a+b)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a+b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="8-函数的默认参数-重载"><a href="#8-函数的默认参数-重载" class="headerlink" title="8.函数的默认参数/重载"></a>8.函数的默认参数/重载</h2><p>默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span> </span>&#123;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">sum(<span class="number">12</span>,<span class="number">23</span>);</div><div class="line">sum(<span class="number">12</span>)</div></pre></td></tr></table></figure></p><p>重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。<br>重载的结果是让一个函数名拥有了多种用途，使得命名更加方便,调用更加灵活。<br>要求:函数名相同,参数列表不同,仅仅返回类型不同不足以成为函数的重载。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">//交换 int 变量的值</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = *a;</div><div class="line">    *a = *b;</div><div class="line">    *b = temp;</div><div class="line">&#125;</div><div class="line"><span class="comment">//交换 float 变量的值</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">float</span> *a, <span class="keyword">float</span> *b)</span></span>&#123;</div><div class="line">    <span class="keyword">float</span> temp = *a;</div><div class="line">    *a = *b;</div><div class="line">    *b = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>重载的本质:<br>在编译时会根据参数列表对函数进行重命名,函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。</p><h2 id="9-对象的创建"><a href="#9-对象的创建" class="headerlink" title="9.对象的创建"></a>9.对象的创建</h2><p>类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。</p><p>成员变量大都以m_开头。</p><p>存储在栈上的对象</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><div class="line">Student stu<span class="comment">;</span></div><div class="line">Student *p = &amp;stu<span class="comment">;</span></div></pre></td></tr></table></figure><p>存储在堆上的对象<br><figure class="highlight abnf"><table><tr><td class="code"><pre><div class="line">Student *stu = new Student<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>使用 new 在堆上创建出来的对象是匿名的，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</p><h2 id="10-成员函数"><a href="#10-成员函数" class="headerlink" title="10.成员函数"></a>10.成员函数</h2><p>在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以建议在类体内部对成员函数作声明，而在类体外部进行定义.</p><p>不使用内联函数:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">class</span> Student&#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">int</span> age;</div><div class="line">     <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;  <span class="comment">//内联函数声明</span></div><div class="line"> &#125;;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> <span class="comment">//函数定义</span></div><div class="line"><span class="keyword">void</span> Student::say()&#123;</div><div class="line"> </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h2 id="11-构造函数"><a href="#11-构造函数" class="headerlink" title="11.构造函数"></a>11.构造函数</h2><p>构造函数必须是 public 属性的，否则创建对象时无法调用。<br>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。</p><p>一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成</p><p>调用没有参数的构造函数也可以省略括号。<br><figure class="highlight abnf"><table><tr><td class="code"><pre><div class="line">Student stu()<span class="comment">;</span></div><div class="line">Student stu<span class="comment">;</span></div><div class="line"></div><div class="line">Student *stu = new Student()<span class="comment">;</span></div><div class="line">Student *stu = new Student<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>参数初始化表可以用于全部成员变量，也可以只用于部分成员变量。<br>参数初始化顺序与初始化表列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。<br>初始化 const 成员变量的唯一方法就是使用参数初始化表。</p><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="comment">//采用参数初始化表</span></div><div class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123;</div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="12-析构函数"><a href="#12-析构函数" class="headerlink" title="12.析构函数"></a>12.析构函数</h2><p>析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号。<br>析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。</p><h2 id="13-this的本质"><a href="#13-this的本质" class="headerlink" title="13.this的本质"></a>13.this的本质</h2><p>this 是 C++ 中的一个关键字，也是一个 <strong>const 指针</strong>，它指向当前对象，通过它可以访问当前对象的所有成员。</p><p>his 虽然用在类的内部，但是只有在对象被创建以后才会给 this 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给 this 赋值。</p><p>this的本质:<br>this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。<br>this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。</p><h2 id="14-静态成员变量"><a href="#14-静态成员变量" class="headerlink" title="14.静态成员变量"></a>14.静态成员变量</h2><p>static 成员变量属于类，不属于某个具体的对象，即使创建多个对象,也只分配一份内存.</p><p>static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用</p><p>static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 将 m_total 声明为静态成员变量</span></div><div class="line"><span class="comment">//通过类类访问 static 成员变量</span></div><div class="line">Student::m_total = <span class="number">10</span>;</div><div class="line">    </div><div class="line"><span class="comment">//通过对象来访问 static 成员变量</span></div><div class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</div><div class="line">stu.m_total = <span class="number">20</span>;</div><div class="line">    </div><div class="line"><span class="comment">//通过对象指针来访问 static 成员变量</span></div><div class="line">Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李华"</span>, <span class="number">16</span>, <span class="number">96</span>);</div><div class="line">pstu -&gt; m_total = <span class="number">20</span>;</div></pre></td></tr></table></figure></p><p>静态成员变量必须初始化，而且只能在类体外进行</p><p>static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p><h2 id="15-静态成员函数"><a href="#15-静态成员函数" class="headerlink" title="15.静态成员函数"></a>15.静态成员函数</h2><p>普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。</p><p>普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。</p><p>普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。</p><p>静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</p><h2 id="16-常成员函数"><a href="#16-常成员函数" class="headerlink" title="16.常成员函数"></a>16.常成员函数</h2><p>const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的</p><p>常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Student&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">//声明常成员函数</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> m_age;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//定义常成员函数</span></div><div class="line"><span class="keyword">int</span> Student::getage() <span class="keyword">const</span>&#123;</div><div class="line">    <span class="keyword">return</span> m_age;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="17-友元函数与友元类"><a href="#17-友元函数与友元类" class="headerlink" title="17.友元函数与友元类"></a>17.友元函数与友元类</h2><p>借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。<br>在当前类以外定义的、不属于当前类的函数可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。</p><p>友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。</p><p>一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span>:</div><div class="line">     <span class="comment">// 构造函数</span></div><div class="line">    Address(<span class="keyword">char</span> *province, <span class="keyword">char</span> *city, <span class="keyword">char</span> *district);</div><div class="line">    </div><div class="line">    <span class="comment">//将Student类中的成员函数show()声明为友元函数</span></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Student::show(Address *addr);</div></pre></td></tr></table></figure></p><p>友元类中的所有成员函数都是另外一个类的友元函数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// 构造函数</span></div><div class="line">    Address(<span class="keyword">char</span> *province, <span class="keyword">char</span> *city, <span class="keyword">char</span> *district);</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">//将Student类声明为Address类的友元类</span></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Student;</div></pre></td></tr></table></figure></p><p>友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。<br>友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。</p><h2 id="18-struct与class比较"><a href="#18-struct与class比较" class="headerlink" title="18.struct与class比较"></a>18.struct与class比较</h2><p>使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的</p><p>class 继承默认是 private 继承，而 struct 继承默认是 public 继承</p><p>class 可以使用模板，而 struct 不能</p><h2 id="19-string的使用"><a href="#19-string的使用" class="headerlink" title="19.string的使用"></a>19.string的使用</h2><p>前提:<code>#include &lt;string&gt;</code></p><p>1.输入输出</p><pre><code>string s;cin&gt;&gt;s;cou&lt;&lt;s&lt;&lt;endl;</code></pre><p>2.通过下标访问</p><pre><code>string s = &quot;qwert&quot;;s[3] = &apos;d&apos;;couy&lt;&lt;s[2];    </code></pre><p>3.拼接</p><pre><code>string s = &quot;i&quot;;char *s1 = &quot;love&quot;;char s2[] = &quot;you&quot;;char s3 = &apos;!&apos;;string rs = s + s1 + s2 + s3;</code></pre><p>4.插入</p><pre><code>string s = &quot;sdf&quot;;s.insert(1,&quot;sds&quot;); // 索引/内容</code></pre><p>5.删除</p><pre><code>s1 = s2 = s3 = &quot;1234567890&quot;;s2.erase(5);s3.erase(5, 3); // 长度为3</code></pre><p>6.提取</p><pre><code>s1.substr(6, 6); // 长度为6</code></pre><p>7.查找</p><pre><code>s.find(&quot;,&quot;,1); // 从索引1开始查找逗号,返回索引</code></pre><h2 id="20-指针传递与引用传递的比较"><a href="#20-指针传递与引用传递的比较" class="headerlink" title="20.指针传递与引用传递的比较"></a>20.指针传递与引用传递的比较</h2><p>引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。</p><p>引用的定义方式类似于指针，只是用&amp;取代了*</p><pre><code>type &amp;name = data;// 指针传递// 比如交换数据swap(int *a, int *b) {int temp = *a;*a = *b;*b = temp;    }// 使用swap(&amp;a, &amp;b);//引用传递swap2(int &amp;a, int &amp;b) {int temp = a;a = b;b = temp;}// 使用swap2(a,b);</code></pre><p>引用也可以作为函数的返回值,不过不能返回局部变量的引用,因为局部变量过了作用域就销毁了</p><h2 id="21-继承"><a href="#21-继承" class="headerlink" title="21.继承"></a>21.继承</h2><p>继承方式包括 public（公有的）、private（私有的）和 protected（受保护的），此项是可选的，如果不写，那么默认为 private。</p><pre><code>class 派生类名:［继承方式］ 基类名{    派生类新增加的成员};</code></pre><p>不同的继承方式会影响基类成员在派生类中的访问权限。</p><p>1) public继承方式</p><pre><code>基类中所有 public 成员在派生类中为 public 属性；基类中所有 protected 成员在派生类中为 protected 属性；基类中所有 private 成员在派生类中不能使用。</code></pre><p>2) protected继承方式</p><pre><code>基类中的所有 public 成员在派生类中为 protected 属性；基类中的所有 protected 成员在派生类中为 protected 属性；基类中的所有 private 成员在派生类中不能使用。</code></pre><p>3) private继承方式</p><pre><code>基类中的所有 public 成员在派生类中均为 private 属性；基类中的所有 protected 成员在派生类中均为 private 属性；基类中的所有 private 成员在派生类中不能使用。</code></pre><p>基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。</p><p>基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。</p><p>类的构造函数不能被继承<br>析构函数也不能被继承<br>派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</p><h2 id="22-多重继承"><a href="#22-多重继承" class="headerlink" title="22.多重继承"></a>22.多重继承</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>: <span class="type">public A</span>, <span class="type">private B</span>, <span class="type">protected C&#123;</span></span></div><div class="line">    <span class="comment">//类D新增加的成员</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和<strong>声明派生类时基类出现的顺序</strong>相同。</p><h2 id="23-虚继承"><a href="#23-虚继承" class="headerlink" title="23.虚继承"></a>23.虚继承</h2><p><img src="http://static.chenyalun.com/2017/04/03/20170403002.jpg" alt=""><br>假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A –&gt;B–&gt;D 这条路径，还是来自 A–&gt;C–&gt;D 这条路径。因为类 B 和类 C 中都有成员变量 a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了错误。</p><p>消除歧义:使用域解析操作符</p><p>为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。<br>在继承方式前面加上 virtual 关键字就是虚继承<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">//间接基类A</span></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">int</span> m_a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//直接基类B</span></div><div class="line"><span class="keyword">class</span> B: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">int</span> m_b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//直接基类C</span></div><div class="line"><span class="keyword">class</span> C: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">int</span> m_c;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//派生类D</span></div><div class="line"><span class="keyword">class</span> D: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; m_a = a; &#125;  <span class="comment">//正确</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setb</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123; m_b = b; &#125;  <span class="comment">//正确</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setc</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123; m_c = c; &#125;  <span class="comment">//正确</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setd</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123; m_d = d; &#125;  <span class="comment">//正确</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> m_d;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><p>虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。</p><p>在最终派生类 D 的构造函数中，除了调用 B 和 C 的构造函数，还调用了 A 的构造函数，这说明 D 不但要负责初始化直接基类 B 和 C，还要负责初始化间接基类 A。直接派生类 B 和 C 对 A 的构造函数的调用是无效的.而在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误。</p><p>在类被构造的时候，先执行<strong>虚拟继承的父类的构造函数</strong>，然后从<strong>左到右执行普通继承的父类的构造函数</strong>，然后按照<strong>定义的顺序执行数据成员的初始化</strong>，最后是<strong>自身的构造函数的调用</strong>。析构函数与之完全相反，互成镜像。<br>见:<a href="http://gaocegege.com/Blog/cpp/cppclass" target="_blank" rel="external">http://gaocegege.com/Blog/cpp/cppclass</a></p><h2 id="24-C-向上转型"><a href="#24-C-向上转型" class="headerlink" title="24.C++向上转型"></a>24.C++向上转型</h2><p>编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。<br>基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。</p><h2 id="25-虚函数、纯虚函数与多态"><a href="#25-虚函数、纯虚函数与多态" class="headerlink" title="25.虚函数、纯虚函数与多态"></a>25.虚函数、纯虚函数与多态</h2><p>目的:让基类指针能够访问派生类的成员函数,只需要在该成员函数声明前面增加 virtual 关键字(基类\派生类都要操作)</p><p>有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）</p><p>虚函数的唯一用处就是构成多态,如果没有多态，我们只能访问成员变量。</p><p>只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）</p><p>构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。</p><p>析构函数可以声明为虚函数，而且有时候必须要声明为虚函数</p><p>将虚函数声明为纯虚函数，纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数。 语法格式为：</p><pre><code>virtual 返回值类型 函数名 (函数参数) = 0;</code></pre><p><strong>包含纯虚函数的类称为抽象类（Abstract Class）</strong><br>一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。</p><h2 id="26-运算符重载"><a href="#26-运算符重载" class="headerlink" title="26.运算符重载"></a>26.运算符重载</h2><p>运算符重载的格式为：</p><pre><code>返回值类型 operator 运算符名称 (形参表列){//TODO:}// 如complex operator+(const complex &amp;A) const;</code></pre><h2 id="27-模板"><a href="#27-模板" class="headerlink" title="27.模板"></a>27.模板</h2><p>函数模板<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , ...&gt; 返回值类型  函数名(形参列表)&#123;</div><div class="line"><span class="comment">//在函数体中可以使用类型参数</span></div><div class="line">&#125;</div><div class="line"> <span class="keyword">typename</span>关键字可使用<span class="keyword">class</span>代替</div><div class="line"> </div><div class="line"> </div><div class="line"> <span class="comment">// 如</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</div><div class="line">   T temp = a;</div><div class="line">   a = b;</div><div class="line">   b = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>关键在于函数定义前面加上 template<typename t,="" typename="" m=""></typename></p><p>类模板<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , …&gt; <span class="keyword">class</span> 类名&#123;</div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// template&lt;typename T1, typename T2&gt;  </span></div><div class="line"></div><div class="line"><span class="comment">// 类模板使用时需要指明类型,函数模板不需要</span></div><div class="line">Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; *p1 = <span class="keyword">new</span> Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt;(<span class="number">10.6</span>, <span class="number">109.3</span>);</div></pre></td></tr></table></figure></p><blockquote><p>参考博客<br>C语言中文网:<a href="http://c.biancheng.net/cpp/biancheng/cpp/rumen/" target="_blank" rel="external">http://c.biancheng.net/cpp/biancheng/cpp/rumen/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 不堪回首。 &lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://blog.chenyalun.com/categories/C/"/>
    
    
      <category term="C" scheme="http://blog.chenyalun.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>排序算法实现</title>
    <link href="http://blog.chenyalun.com/2017/03/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.chenyalun.com/2017/03/05/排序算法实现/</id>
    <published>2017-03-05T03:52:27.000Z</published>
    <updated>2017-04-26T01:06:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017.4.24 修改部分代码<br>2017.4.21 完善<br>2017.3.25 修改</p></blockquote><p align="center"> 排序算法。 </p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为笔试使用的编译器语言为Python2.7，所以以下代码使用Python2实现并规定从小到大为目标顺序。</p><p>八大排序：<br>直接插入排序，希尔排序，简单选择排序，堆排序，冒泡排序，快速排序，归并排序，基数排序。</p><h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>假定n1 = n2,排序前n1位于n2前面,如果排序后n1扔领先于n2,则称排序算法稳定.</p><h2 id="内排序与外排序"><a href="#内排序与外排序" class="headerlink" title="内排序与外排序"></a>内排序与外排序</h2><p>内排序:排序的整个过程中,待排序的所有记录全部被放置在内存中.<br>外排序:由于排序的记录太多,排序的过程中,需要内外存之间多次交换才能进行.</p><h1 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h1><p>原理:通过相邻元素的比较和交换，把较大的数交换到后面，类似水泡向上面(数组的后面，所以总是靠后的数字有序)升，故称为冒泡排序。如果两数相等，不交换，所以稳定。</p><p>普通方式</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(tempList)</span>:</span></div><div class="line">n = len(tempList)</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</div><div class="line"><span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">1</span>, n - x):<span class="comment"># 索引n-x之后的数已经排序好了</span></div><div class="line"><span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]:</div><div class="line">tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y]</div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"></div><div class="line"><span class="keyword">print</span> bubbleSort([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</div></pre></td></tr></table></figure><p>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，无需继续迭代。</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#交换排序-冒泡排序优化1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort1</span><span class="params">(tempList)</span>:</span></div><div class="line">n = len(tempList)</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</div><div class="line"><span class="comment">#标志位,倘若没有交换,说明已经排序好了</span></div><div class="line">flag = <span class="keyword">True</span></div><div class="line"><span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">1</span>, n - x):<span class="comment"># 索引n-x之后的数已经排序好了</span></div><div class="line"><span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]:</div><div class="line">tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y]</div><div class="line">flag = <span class="keyword">False</span></div><div class="line"><span class="keyword">if</span> flag: <span class="comment"># 发现并没有发生交换</span></div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"></div><div class="line"><span class="keyword">print</span> bubbleSort1([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</div></pre></td></tr></table></figure><p>优化2：记录最后发生交换的位置，位置之后的数据已经井然有序。</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#交换排序-冒泡排序优化2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort2</span><span class="params">(tempList)</span>:</span></div><div class="line">n = len(tempList)</div><div class="line"><span class="comment"># 循环范围</span></div><div class="line">m = n</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</div><div class="line"><span class="comment">#标志位,倘若没有交换,说明已经排序好了</span></div><div class="line">flag = <span class="keyword">True</span></div><div class="line"><span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">1</span>, m):<span class="comment"># 索引m之后的数已经排序好了</span></div><div class="line"><span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]:</div><div class="line">tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y]</div><div class="line">m = y</div><div class="line">flag = <span class="keyword">False</span></div><div class="line"><span class="keyword">if</span> flag: <span class="comment"># 发现并没有发生交换</span></div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"></div><div class="line"><span class="keyword">print</span> bubbleSort2([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</div></pre></td></tr></table></figure><p><strong>分析</strong><br>最好情况:数据井然有序,根据优化后的代码,只需要迭代一次,即n-1次的比较,则时间复杂度为O(n)<br>最坏情况:数据逆序,需要比较的次数为1+2+3+4+…+(n-1)=n(n-1)/2次,时间复杂度为O(n^2)</p><figure class="highlight tap"><table><tr><td class="code"><pre><div class="line">假定有4个数,分别为4<span class="number"> 3 </span>2 1,排序过程为:</div><div class="line">原数据:<span class="number"> 4 </span>3<span class="number"> 2 </span>1</div><div class="line">第1次:<span class="number"> 3 </span>4<span class="number"> 2 </span>1</div><div class="line">第2次:<span class="number"> 3 </span>2<span class="number"> 4 </span>1</div><div class="line">第3次:<span class="number"> 3 </span>2<span class="number"> 1 </span>4</div><div class="line">第4次:<span class="number"> 2 </span>3<span class="number"> 1 </span>4</div><div class="line">第5次:<span class="number"> 2 </span>1<span class="number"> 3 </span>4</div><div class="line">第6次:<span class="number"> 1 </span>2<span class="number"> 3 </span>4</div><div class="line"></div><div class="line">归纳推理:n(n-1)/2次</div></pre></td></tr></table></figure><h1 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h1><p>在未排序序列中找到最小元素，存放到排序序列的起始位置(与第一个元素交换位置)，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾(与第二个元素交换位置)。以此类推，直到所有元素均排序完毕。</p><p>通过n-i次关键字间的比较,从n-i+1个记录中选出最小的记录,并和第i个记录交换之.</p><p>选择排序的交换操作介于 0 和 ( n − 1 )次之间。<br>选择排序的比较操作为 n ( n − 1 ) / 2次之间。<br>选择排序的赋值操作介于 0 和 3 ( n − 1 )次之间。</p><p>当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(tempList)</span>:</span></div><div class="line">n = len(tempList)</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(n):</div><div class="line"><span class="comment"># 假定索引x对应的是最小值</span></div><div class="line">index = x</div><div class="line"><span class="keyword">for</span> y <span class="keyword">in</span> xrange(x + <span class="number">1</span>,n):</div><div class="line"><span class="comment"># 如果找到比索引index对应的值还要小的值,交换两者位置</span></div><div class="line"><span class="keyword">if</span> tempList[index] &gt; tempList[y]:</div><div class="line">tempList[index], tempList[y] = tempList[y], tempList[index]</div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">print</span> selectionSort([<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">30</span>])</div></pre></td></tr></table></figure><p><strong>分析</strong><br>特点:交换移动数据次数相当少<br>最好情况与最坏情况:比较次数一样多,为n(n-1)/2次,时间复杂度:O(n^2)</p><figure class="highlight tap"><table><tr><td class="code"><pre><div class="line">假定有4个数据,分别为<span class="number"> 4 </span>3<span class="number"> 2 </span>1</div><div class="line">原数据:<span class="number"> 4 </span>3<span class="number"> 2 </span>1</div><div class="line">第1次比较:<span class="number"> 4 </span>与 3</div><div class="line">第2次比较:<span class="number"> 4 </span>与 2</div><div class="line">第3次比较:<span class="number"> 4 </span>与<span class="number"> 1 </span>(此时数据为1<span class="number"> 3 </span>2 4)</div><div class="line">第4次比较:<span class="number"> 3 </span>与 2</div><div class="line">第5次比较:<span class="number"> 3 </span>与<span class="number"> 4 </span>(此时数据为<span class="number"> 1 </span>2<span class="number"> 3 </span>4)</div><div class="line">第6次比较:<span class="number"> 3 </span>与 4</div><div class="line"></div><div class="line">最终结果:<span class="number"> 1 </span>2<span class="number"> 3 </span>4</div><div class="line">比较次数:6次</div></pre></td></tr></table></figure><p>选择排序是不稳定的排序算法,比如<code>5 8 5 2 9</code>,显然第1个5最终落到第2个5的后面.</p><figure class="highlight tap"><table><tr><td class="code"><pre><div class="line">原数据:    5'<span class="number"> 8 </span>5<span class="number"> 2 </span>9</div><div class="line">第1次交换:<span class="number"> 2 </span>8<span class="number"> 5 </span>5' 9</div><div class="line">第2次交换:<span class="number"> 2 </span>5<span class="number"> 8 </span>5' 9</div><div class="line">第3次交换:<span class="number"> 2 </span>5 5'<span class="number"> 8 </span>9</div><div class="line">第4次交换:<span class="number"> 2 </span>5 5'<span class="number"> 8 </span>9</div><div class="line"></div><div class="line">最终 5'在<span class="number"> 5 </span>的前面.</div></pre></td></tr></table></figure><h1 id="三、直接插入排序"><a href="#三、直接插入排序" class="headerlink" title="三、直接插入排序"></a>三、直接插入排序</h1><p>原理:在一个已经有序的数据序列中插入一个数，在插入后此数据序列仍然有序。默认前1个数有序，第二个数与前一个数组成的有序数列比较并插入，第三个数与前两个数组成的有序数列比较并插入……所以总是靠前的数字有序。</p><p>遇到相等的数，插入到该数的后面，而不是前面，所以是稳定排序算法。</p><p><img src="http://static.chenyalun.com/2017/03/15/2017031501.gif" alt=""></p><p>最好情况：序列已经是升序排列了，需要进行的比较操作需(n-1)次,时间复杂度为O(n)。<br>最坏情况：序列是降序排列，那么此时需要进行的比较共有 n ( n − 1 ) / 2 次。<br>插入排序的赋值操作是比较操作的次数加上(n-1)次。<br>平均来说插入排序算法复杂度为 O ( n^2 )。<br>插入排序不适合对于数据量比较大的排序应用。<strong>用于少量元素的排序</strong>（通常为8个或以下）。</p><p>直接插入</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(tempList)</span>:</span></div><div class="line"><span class="comment"># 获取列表的长度</span></div><div class="line">n = len(tempList)</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>,n): <span class="comment"># 从第1个元素而非第0个元素开始遍历</span></div><div class="line"><span class="keyword">for</span> y <span class="keyword">in</span> xrange(x, <span class="number">0</span>, <span class="number">-1</span>): <span class="comment"># 在已经排好序的列表中逐个扫描</span></div><div class="line"><span class="keyword">if</span> tempList[y - <span class="number">1</span>] &gt; tempList[y]: <span class="comment"># 如果当前元素比前面的小</span></div><div class="line">tempList[y], tempList[y - <span class="number">1</span>] = tempList[y - <span class="number">1</span>], tempList[y] <span class="comment"># 两者位置互换</span></div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"></div><div class="line"><span class="comment"># print insertionSort([])</span></div><div class="line"><span class="comment"># print insertionSort([8])</span></div><div class="line"><span class="comment"># print insertionSort([5,2,7,0,1,5,9])</span></div></pre></td></tr></table></figure><h1 id="四、二分插入排序"><a href="#四、二分插入排序" class="headerlink" title="四、二分插入排序"></a>四、二分插入排序</h1><p>二分查找插入与希尔排序是直接插入排序的优化。</p><p>二分查找插入</p><p>使用Python模块实现</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># bisect模块实现了一个算法, 用于向一个有序列表中插入一个元素,不改变列表的序列</span></div><div class="line"><span class="comment"># 使用这个模块的函数前先确保操作的列表是已排序的</span></div><div class="line"></div><div class="line"><span class="comment">#import bisect </span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSortBisect</span><span class="params">(tempList)</span>:</span>  </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, len(tempList)):  </div><div class="line">        bisect.insort(tempList, tempList.pop(i), <span class="number">0</span>, i) <span class="comment"># 排序列表,移除并插入元素,区间开始,区间结束</span></div><div class="line">    <span class="keyword">return</span> tempList</div><div class="line"></div><div class="line"><span class="comment"># print insertionSortBisect([])</span></div><div class="line"><span class="comment"># print insertionSortBisect([8])</span></div><div class="line"><span class="comment"># print insertionSortBisect([5,2,7,0,1,5,9])</span></div></pre></td></tr></table></figure><p>手动实现</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#二分查找的前提必须待查找的序列有序</span></div><div class="line"><span class="comment"># 在有序列表中,返回值m应该所在的索引</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">indexOfInsertionSort</span><span class="params">(tempList, m)</span>:</span></div><div class="line"><span class="comment"># 获取列表的长度</span></div><div class="line">n = len(tempList)</div><div class="line">left, right = <span class="number">0</span>, n - <span class="number">1</span></div><div class="line"><span class="keyword">while</span> left &lt;= right:</div><div class="line">middle = (left + right) / <span class="number">2</span></div><div class="line"><span class="keyword">if</span> tempList[middle] &lt; m:<span class="comment"># 右半部分</span></div><div class="line">left = middle + <span class="number">1</span></div><div class="line"><span class="keyword">else</span>: <span class="comment">#左半部分,含相同元素</span></div><div class="line">right = middle <span class="number">-1</span></div><div class="line"><span class="keyword">return</span> right +<span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSortbin</span><span class="params">(tempList)</span>:</span></div><div class="line"><span class="comment"># 获取列表的长度</span></div><div class="line">n = len(tempList)</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>,n): <span class="comment"># 从头至尾遍历列表中的元素</span></div><div class="line">m = tempList[x]</div><div class="line">tempList.pop(x)</div><div class="line">index = indexOfInsertionSort(tempList[<span class="number">0</span>:x],m)</div><div class="line">tempList.insert(index , m) <span class="comment">#第一个参数是索引,第二个参数是数值</span></div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"></div><div class="line"><span class="comment">#print insertionSortbin([12,12,16,8,5,10,7])</span></div></pre></td></tr></table></figure><h1 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a>五、希尔排序</h1><p>先将待排记录序列分割为若干个子序列，分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序。</p><p>采用跳跃分割的策略:把相距某个”增量”的记录组成一个序列，保证在子序列内分别进行直接插入排序后得到的结果是基本有序的。</p><p>原始序列</p><blockquote><p>2 5 1 9 8 2 10 4</p></blockquote><p>4步长，分组，每列排序</p><blockquote><p>2 5 1 9<br>8 2 10 4</p></blockquote><p>排序后</p><blockquote><p>2 2 1 4<br>8 5 10 9</p></blockquote><p>也即</p><blockquote><p>2 2 1 4 8 5 10 9</p></blockquote><p>2步长，再分组</p><blockquote><p>2 2<br>1 4<br>8 5<br>10 9</p></blockquote><p>排序</p><blockquote><p>1 2<br>2 4<br>8 5<br>10 9</p></blockquote><p>也即：</p><blockquote><p>1 2 2 4 8 5 10 9</p></blockquote><p>最后以1步长进行排序（还是直接插入排序）。</p><p>一般插入</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSortShell</span><span class="params">(tempList)</span>:</span></div><div class="line">n = len(tempList)</div><div class="line"><span class="comment"># 确定分组,假定n = 6</span></div><div class="line">group = n / <span class="number">2</span> <span class="comment"># 此时group = 3,分成3组,3组元素索引分别为3与3-3,4与4-3,5与5-3</span></div><div class="line"><span class="keyword">while</span> group &gt; <span class="number">0</span>:</div><div class="line"><span class="comment">#x从3到5</span></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(group,n):</div><div class="line"><span class="comment"># 每组元素:x,x-group,x-group-group ......插入排序</span></div><div class="line">temp = tempList[x]</div><div class="line">y = x</div><div class="line"><span class="comment"># 这里使用简单的插入排序</span></div><div class="line"><span class="keyword">while</span> y &gt;= group <span class="keyword">and</span> tempList[y - group] &gt; temp:</div><div class="line">tempList[y] = tempList[y - group]</div><div class="line">y -= group</div><div class="line">tempList[y] = temp</div><div class="line"></div><div class="line">group /= <span class="number">2</span></div><div class="line"><span class="keyword">return</span> tempList</div></pre></td></tr></table></figure><p>互换法</p><figure class="highlight cs"><table><tr><td class="code"><pre><div class="line"><span class="function">def <span class="title">insertionSortShellExchange</span>(<span class="params">tempList</span>):</span></div><div class="line">n = len(tempList)</div><div class="line"><span class="meta"># 确定分组,假定n = 6</span></div><div class="line"><span class="keyword">group</span> = n / <span class="number">2</span> <span class="meta"># 此时group = 3,分成3组,3组元素索引分别为3与3-3,4与4-3,5与5-3</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">group</span> &gt; <span class="number">0</span>:</div><div class="line"><span class="meta">#x从3到5</span></div><div class="line"><span class="function"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="title">xrange</span>(<span class="params"><span class="keyword">group</span>,n</span>):</span></div><div class="line"># 每组元素:x,x-<span class="keyword">group</span>,x-<span class="keyword">group</span>-<span class="keyword">group</span> ......插入排序</div><div class="line">y = x</div><div class="line">m = tempList[x]</div><div class="line"><span class="keyword">while</span> y &gt;= <span class="keyword">group</span> and tempList[y - <span class="keyword">group</span>] &gt; m:</div><div class="line"><span class="meta"># 这里直接交换位置</span></div><div class="line">tempList[y], tempList[y - <span class="keyword">group</span>] = tempList[y - <span class="keyword">group</span>], tempList[y]</div><div class="line">y -= <span class="keyword">group</span></div><div class="line"></div><div class="line"><span class="keyword">group</span> /= <span class="number">2</span></div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"></div><div class="line"><span class="meta">#print insertionSortShell([1,8,10,2,4,0])</span></div><div class="line"><span class="meta">#print insertionSortShellExchange([1,8,10,2,4,0])</span></div></pre></td></tr></table></figure><p>由于记录是跳跃式的，希尔排序是不稳定的排序算法。</p><h1 id="六、堆排序"><a href="#六、堆排序" class="headerlink" title="六、堆排序"></a>六、堆排序</h1><p>堆排序是对简单选择排序的改进。</p><p>堆是具有以下性质的完全二叉树:<br>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。<br>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p>性质:按层遍历的方式给结点编号，则有:</p><pre><code>k(i) &gt;= k(2i)k(i) &gt;= k(2i+1)或k(i) &lt;= k(2i)k(i) &lt;= k(2i+1)</code></pre><p>堆排序就是利用堆进行排序的算法，基本思想是:将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根结点。把它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个值重新构造成一个堆，这样就会得到n个元素中的次小值，如此反复执行，便能得到一个有序序列了。</p><p>需要解决的两个问题:<br><strong>1. 如何由一个无序序列构建成一个堆</strong><br><strong>2. 如何在获取堆顶元素后，调整剩余元素成为一个新的堆</strong></p><p>所谓的将待排序的序列构建成一个大顶堆，其实就是从下往上、从右往左，将每个非叶结点当作根节点，将其和其子树调整成大顶堆。</p><p>在正式排序时，第i次取堆顶记录重建需要O(logi)的时间，并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为O(nlogn)。</p><p>堆排序对原始状态的排序不敏感，无论是最好最坏还是平均情况时间复杂度总是为O(nlogn)。</p><p>注意:由于初始构建堆所需的比较次数较多，因此，它并<strong>不适合待排序序列个数较少的情况</strong>。</p><p>实现</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># start是当前需要调整最小堆的位置,end是调整边界</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapAdjust</span><span class="params">(tempList, start, end)</span>:</span></div><div class="line">    root = start</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        child = root * <span class="number">2</span> + <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> child &gt; end:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> tempList[child] &lt; tempList[child + <span class="number">1</span>]:</div><div class="line">            child += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> tempList[root] &lt; tempList[child]:</div><div class="line">            tempList[root], tempList[child] = tempList[child], tempList[root]</div><div class="line">            root = child</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line"></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(tempList)</span>:</span></div><div class="line">    n = len(tempList)</div><div class="line">    <span class="comment"># 构造小顶堆</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n / <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        heapAdjust(tempList, i, n - <span class="number">1</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</div><div class="line">        <span class="comment"># 将堆顶记录和当前未排序子序列的最后一个记录交换</span></div><div class="line">        tempList[<span class="number">0</span>], tempList[i] = tempList[i], tempList[<span class="number">0</span>]</div><div class="line">        <span class="comment"># 重新调整为小顶堆</span></div><div class="line">        heapAdjust(tempList, <span class="number">0</span>, i - <span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> tempList</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">print</span> heapSort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>])</div></pre></td></tr></table></figure><h1 id="七、归并排序"><a href="#七、归并排序" class="headerlink" title="七、归并排序"></a>七、归并排序</h1><p>归并排序就是利用归并的思想实现的排序算法。原理是:假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两合并，得到n/2的向上取整个长度为2或者为1的有序子序列，然后两两合并，如此重复，直到得到一个长度为n的有序序列。该方法也称为2路归并排序。</p><p>比较操作的次数介于 ( nlogn ) / 2 和 nlogn − n + 1。<br>赋值操作的次数是 ( 2 nlogn )。</p><p><img src="http://static.chenyalun.com/2017/03/15/2017031503.gif" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#归并排序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(tempList)</span>:</span></div><div class="line">length = len(tempList)</div><div class="line"><span class="keyword">if</span> length &lt;= <span class="number">1</span>:</div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"><span class="comment"># 二分列表</span></div><div class="line">middle = length / <span class="number">2</span></div><div class="line">leftList = mergeSort(tempList[:middle])</div><div class="line">rightList = mergeSort(tempList[middle:])</div><div class="line"></div><div class="line"><span class="keyword">return</span> merge(leftList,rightList)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(leftList,rightList)</span>:</span></div><div class="line">leftIndex,rightIndex = <span class="number">0</span>, <span class="number">0</span></div><div class="line">result = []</div><div class="line"><span class="keyword">while</span> leftIndex &lt; len(leftList) <span class="keyword">and</span> rightIndex &lt; len(rightList):</div><div class="line"><span class="keyword">if</span> leftList[leftIndex] &lt; rightList[rightIndex]:</div><div class="line">result.append(leftList[leftIndex])</div><div class="line">leftIndex += <span class="number">1</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">result.append(rightList[rightIndex])</div><div class="line">rightIndex += <span class="number">1</span></div><div class="line"></div><div class="line">result += leftList[leftIndex:]</div><div class="line">result += rightList[rightIndex:]</div><div class="line"><span class="keyword">return</span> result</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">print</span> mergeSort([<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure><p>一趟归并需要耗费O(n)时间，由完全二叉树的深度可知，整个归并排序需要进行logn次，故，总的时间复杂度为O(logn)，并且最好/最坏/平均时间性能均是如此。</p><p>归并排序需要两两比较，不存在跳跃，因此稳定。</p><h1 id="八、快速排序"><a href="#八、快速排序" class="headerlink" title="八、快速排序"></a>八、快速排序</h1><p>20世纪十大算法之一。</p><p>关键词:基准 分组 递归</p><p>在平均状况下，排序n个项目要Ο(n log n)次比较。<br>在最坏状况下则需要Ο(n2)次比较。</p><p><img src="http://static.chenyalun.com/2017/03/15/2017031502.gif" alt=""></p><p>快速排序使用分治法策略来把一个序列分为两个子序列。</p><p>步骤为：</p><ol><li>从数列中挑出一个元素，作为基准数，</li><li>分区：把比基准大的放在右边，比基准小的放在左边，等于基准的放在基准列表中。</li><li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(tempList)</span>:</span></div><div class="line"><span class="keyword">if</span> len(tempList) &lt;= <span class="number">1</span>:</div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"></div><div class="line"><span class="comment"># 基准列表</span></div><div class="line">pivotList = []</div><div class="line"><span class="comment"># 比基准小的列表</span></div><div class="line">lessList = []</div><div class="line"><span class="comment"># 比基准大的列表</span></div><div class="line">moreList = []</div><div class="line"><span class="comment">#将第一个值作为基准</span></div><div class="line">pivot = tempList[<span class="number">0</span>]</div><div class="line"><span class="comment"># 遍历tempList</span></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> tempList:</div><div class="line"><span class="comment"># 比基准大,放入moreList</span></div><div class="line"><span class="keyword">if</span> x &gt; pivot:</div><div class="line">moreList.append(x)</div><div class="line"><span class="comment"># 比基准小,放入lessList</span></div><div class="line"><span class="keyword">elif</span> x &lt; pivot:</div><div class="line">lessList.append(x)</div><div class="line"><span class="comment"># 与基准相等,放入基准列表中</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">pivotList.append(x)</div><div class="line"></div><div class="line"><span class="comment"># 对lessList和moreList递归操作</span></div><div class="line">lessList = quickSort(lessList)</div><div class="line">moreList = quickSort(moreList)</div><div class="line"></div><div class="line"><span class="comment"># 返回排序好的列表</span></div><div class="line"><span class="keyword">return</span> lessList + pivotList + moreList</div></pre></td></tr></table></figure><p>甚至可以这么写</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort1</span><span class="params">(tempList)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(tempList) &lt;= <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> tempList</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        pivot = tempList[<span class="number">0</span>]</div><div class="line">        <span class="keyword">return</span> quickSort1([x <span class="keyword">for</span> x <span class="keyword">in</span> tempList[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; pivot])\</div><div class="line">         + [pivot] + \</div><div class="line">         quickSort1([x <span class="keyword">for</span> x <span class="keyword">in</span> tempList[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= pivot])</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">print</span> quickSort1([<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>])</div></pre></td></tr></table></figure><p>快速排序的时间复杂度取决于快速排序递归的深度，在最优情况下时间复杂度为O(logn)。最坏情况下，待排序为正序或者逆序，时间复杂度为O(n^2)</p><p>由于关键字的比较和交换是跳跃进行的，因此快速排序不稳定。</p><p>快速排序的优化:</p><ol><li><strong>优化选取枢轴</strong><br>三数取中法:取三个关键字先进行排序，将中间数作为枢轴，一般取左端、右端和中间三个数，也可以随机选取，至少枢轴不是最大或者最小的数。</li></ol><h1 id="九、计数排序"><a href="#九、计数排序" class="headerlink" title="九、计数排序"></a>九、计数排序</h1><p>计数排序是用来排序0到100之间的数字的最好的算法。</p><p>步骤:</p><blockquote><p>找出待排序的数组中最大和最小的元素<br>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项<br>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#计数排序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">countsort</span><span class="params">(tempList)</span>:</span></div><div class="line"><span class="keyword">if</span> len(tempList) &lt;= <span class="number">1</span>:</div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"></div><div class="line">maxValue = max(tempList)</div><div class="line">minValue = min(tempList)</div><div class="line"></div><div class="line"><span class="comment"># 创建计数列表countList</span></div><div class="line">countList = [<span class="number">0</span>] * (maxValue - minValue + <span class="number">1</span>)</div><div class="line"><span class="comment"># 获取元素出现次数</span></div><div class="line"><span class="keyword">for</span> e <span class="keyword">in</span> tempList:</div><div class="line">countList[e - minValue] += <span class="number">1</span></div><div class="line">index = <span class="number">0</span></div><div class="line">    <span class="comment"># 填值</span></div><div class="line"><span class="keyword">for</span> a <span class="keyword">in</span> xrange(maxValue - minValue + <span class="number">1</span>):</div><div class="line"><span class="keyword">for</span> c <span class="keyword">in</span> xrange(countList[a]):</div><div class="line">tempList[index] = a + minValue</div><div class="line">index += <span class="number">1</span></div><div class="line"><span class="keyword">return</span> tempList</div><div class="line"></div><div class="line">    </div><div class="line">    </div><div class="line"></div><div class="line">    </div><div class="line">    </div><div class="line"><span class="keyword">print</span> countsort([<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure><p>那么,以1,6,3,2,3为例<br>最值<br>maxValue = 6<br>minValue = 1</p><p>计数列表<br>countList = [0, 0, 0, 0, 0, 0]</p><p>元素出现的次数<br>countList = [1, 1, 2, 0, 0, 1]</p><table><thead><tr><th>a</th><th>countList[a] 即遍历次数</th><th>tempList[index]</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>tempList[0] = 1</td></tr><tr><td>1</td><td>1</td><td>tempList[1] = 2</td></tr><tr><td>2</td><td>2</td><td>tempList[2] = 3以及tempList[3] = 3</td></tr><tr><td>3</td><td>0</td><td></td></tr><tr><td>4</td><td>0</td><td></td></tr><tr><td>5</td><td>1</td><td>tempList[4] = 6</td></tr></tbody></table><p>排序成功:1, 2, 3, 3, 6</p><h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>算法分析：</p><p><img src="http://static.chenyalun.com/2017/03/15/2017031504.jpg" alt=""></p><p>代码保存在<a href="https://github.com/ChenYalun/YACode/tree/master/Blog" target="_blank" rel="external">GitHub</a>上。</p><p>参考资料：</p><blockquote><p>《大话数据结构》<br><a href="https://zh.wikipedia.org/zh-hans/" target="_blank" rel="external">维基百科</a><br><a href="https://segmentfault.com/a/1190000006546190#articleHeader17" target="_blank" rel="external">segmentfault</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="external">WuChong</a><br><a href="http://bubkoo.com/2014/01/13/sort-algorithm/selection-sort/" target="_blank" rel="external">bubkoo</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017.4.24 修改部分代码&lt;br&gt;2017.4.21 完善&lt;br&gt;2017.3.25 修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 排序算法。 &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.chenyalun.com/categories/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/categories/Python/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://blog.chenyalun.com/tags/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://blog.chenyalun.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS自定义转场总结</title>
    <link href="http://blog.chenyalun.com/2017/02/26/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.chenyalun.com/2017/02/26/iOS自定义转场总结/</id>
    <published>2017-02-26T07:22:34.000Z</published>
    <updated>2017-03-15T08:37:53.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 自定义转场总结。 </p><a id="more"></a><h1 id="一、勾弦"><a href="#一、勾弦" class="headerlink" title="一、勾弦"></a>一、勾弦</h1><p>转场的本质是下一场景的视图替换当前场景的视图以及相应的控制器的替换，表现为当前视图消失和下一视图出现。容器类 VC 的转场里 fromView 和 toView 是 containerView 的子层次的视图，而 Modal 转场里 presentingView 与ontainerView 是同层次的视图，只有 presentedView 是 containerView 的子层次视图。Custom 模式下 Modal 转场结束时 fromView 并未从视图结构中移除；FullScreen 模式的 Modal 转场结束后 fromView 主动被从视图结构中移除了。Custom 模式下，在 dismissal 中，不要像其他转场中那样将 toView加入 containerView 中，否则 dismiss 结束后本来可见的 presentingView 将会随着 containerView 一起被移除。</p><p>在 Modal 转场中，presentingView 并非 containerView 的子视图，这时通过viewForKey:方法来获取presentingView 得到的是 nil，必须通过viewControllerForKey:得到presentingVC 后来获取。当 UIViewController 的modalPresentationStyle属性为.Custom 或.FullScreen时，就有机会定制转场效果，此时modalTransitionStyle指定的转场动画将会被忽略。</p><p>容器 VC 的转场的代理由容器 VC 自身的代理提供不同，Modal 转场的代理由 presentedVC(目标控制器) 提供。Modal 转场在 Custom 模式下必须区分 presentation 和 dismissal 转场，而在 FullScreen 模式下可以不用这么做，因为 UIKit 会在 dismissal 转场结束后自动将 presentingView 放置到原来的位置。转场代理（Transitioning Delegate）根据不同的转场类型提供其所需要的动画控制类和交互控制类。</p><p>动画控制类(器)（Animation Controller）遵从UIViewControllerAnimatedTransitioning协议，并且负责执行实际的动画。交互控制类(器)（Interaction Controller）遵从UIViewControllerInteractiveTransition协议来控制可交互的转场动画。转场上下文（Transitioning Context）定义了转场时需要的元数据（比如转场所参与了的视图控制器和视图的属性），其遵从UIViewControllerContextTransitioning协议，并且这是由系统负责生成和提供。</p><p>转场协调器（Transition Coordinators）可以在运行转场动画时，并行的运行其他动画。转场协调器遵从UIViewControllerTransitionCoordinator协议。转场动画交互方式分两种，第一种是属于非交互式：必须要实现动画控制类，第二种交互式：必须要实现动画控制类和交互控制类（例如可以通过手势的滑动距离来控制转场动画的一个进度，一般应用中都可以通过手势的滑动来推出一个视图控制器)。</p><h1 id="二、简单转场"><a href="#二、简单转场" class="headerlink" title="二、简单转场"></a>二、简单转场</h1><p>基本类型</p><blockquote><p>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。<br>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。<br>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。<br>UIViewAnimationOptionRepeat：重复运行动画。<br>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。<br>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。<br>UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。<br>UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场 动画）。</p><p>UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，<br>而不是将旧视图从父视图移除（仅仅适用于转场动画）<br>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</p></blockquote><p>动画速度控制（可从其中选择一个设置）</p><blockquote><p>UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。<br>UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。<br>UIViewAnimationOptionCurveEaseOut：动画逐渐加速。<br>UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。</p></blockquote><p>转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）</p><blockquote><p>UIViewAnimationOptionTransitionNone：没有转场动画效果。<br>UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。<br>UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。<br>UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。<br>UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。<br>UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。<br>UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。<br>UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。</p></blockquote><p>简单使用<br>  作用于fromView的父视图，切换两个view，将formView从其父视图上移除，将toView重新粘在其父视图上，展现一个动画效果。</p>  <figure class="highlight clojure"><table><tr><td class="code"><pre><div class="line">[UIView transitionFromView:self.view toView:redView duration:5.0 options:</div><div class="line">UIViewAnimationOptionCurveLinear completion:^(<span class="name">BOOL</span> finished) &#123;</div><div class="line">        kLog(@<span class="string">"转场动画完成"</span>)<span class="comment">;</span></div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure><p>  重绘View视图，任何其子视图的改变或者其自身的改变都会触发转场动画的效果。</p>  <figure class="highlight clojure"><table><tr><td class="code"><pre><div class="line">[UIView transitionWithView:self.view duration:2.0 options:</div><div class="line">UIViewAnimationOptionCurveLinear animations:<span class="comment">^&#123;</span></div><div class="line">        self.view.alpha = 0.1;</div><div class="line">&#125; completion:^(<span class="name">BOOL</span> finished) &#123;</div><div class="line">        kLog(@<span class="string">"动画完成"</span>)<span class="comment">;</span></div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure><h1 id="三、模态转场"><a href="#三、模态转场" class="headerlink" title="三、模态转场"></a>三、模态转场</h1><p>源控制器A–&gt;目标控制器B</p><h2 id="1-提要"><a href="#1-提要" class="headerlink" title="(1) 提要"></a>(1) 提要</h2><p>可以只使用一个动画控制器Animator，但是要对Present/Dismiss分别实现。模态的类型默认为FullScreen，即在Present时，会移除fromView，而类型设置为Custom时，就会使fromView与toView共存。present时，要把toView加入到container的视图层级，dismiss时，要把fromView从container的视图层级中移除。非交互式转场，需要在动画执行完毕声明complete<code>[transitionContext completeTransition:YES];</code>交互式转场，需要判断转场完成或者取消。</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> isCancelled = transitionContext.transitionWasCancelled;</div><div class="line"><span class="comment">// 考虑到转场中途可能取消的情况，转场结束后，恢复视图状态。</span></div><div class="line">fromView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">toView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div></pre></td></tr></table></figure><p>在模态中，设置将要跳转到的视图控制器(presentedViewController)的transitioningDelegate。充当代理的对象可以是源视图控制器(presentingViewController)，也可以是自己创建的对象，它需要为转场动画提供一个animator对象。animator对象的animateTransition是整个动画的核心逻辑。</p><h2 id="2-无交互"><a href="#2-无交互" class="headerlink" title="(2) 无交互"></a>(2) 无交互</h2><p>设置<strong>目标控制器B</strong>的代理(可以是A，也可以是B)以及模态动画类型(常用UIModalPresentationCustom或UIModalPresentationFullScreen)。</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">YAShareViewController *shareViewController = [[YAShareViewController alloc] init];</div><div class="line">   </div><div class="line"><span class="comment">// 设置转场代理</span></div><div class="line">shareViewController.transitioningDelegate = <span class="keyword">self</span>;</div><div class="line"><span class="comment">// 设置转场动画类型</span></div><div class="line">shareViewController.modalPresentationStyle = <span class="built_in">UIModalPresentationCustom</span>;</div><div class="line">[<span class="keyword">self</span> presentViewController:shareViewController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">  </div><div class="line"></div><div class="line"><span class="comment">// 目标控制器的代理遵守UIViewControllerTransitioningDelegate协议并相关实现方法</span></div><div class="line"><span class="meta">#pragma mark - Transitioning Delegate</span></div><div class="line"></div><div class="line"><span class="comment">// 无交互出现动画</span></div><div class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source &#123;</div><div class="line"> YATransitionAnimator *animator = [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPresent];</div><div class="line"> </div><div class="line">     <span class="keyword">return</span> animator;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="comment">// 无交互消失动画</span></div><div class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed &#123;</div><div class="line"> YATransitionAnimator *animator = [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorDismiss];</div><div class="line">     <span class="keyword">return</span> animator;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代理方法中的动画管理者Animator独立存在，可以新建一继承自NSObject且遵守<code>UIViewControllerAnimatedTransitioning</code>协议的对象担任(仅仅遵守协议实现方法即可，不需设置代理)。</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#pragma mark – Life Cycle</span></div><div class="line">   </div><div class="line">+ (<span class="keyword">instancetype</span>)transitionAnimatorWithType:(TransitionAnimatorType)transitionAnimatorType &#123;</div><div class="line">  YATransitionAnimator *animator = [[YATransitionAnimator alloc] init];</div><div class="line">  animator.transitionAnimatorType = transitionAnimatorType;</div><div class="line">  <span class="keyword">return</span> animator;</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="meta">#pragma mark - AnimatedTransitioning delegate</span></div><div class="line">   </div><div class="line"><span class="comment">//返回动画时间</span></div><div class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">5.0</span>;</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">//执行动画的地方</span></div><div class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</div><div class="line">   </div><div class="line">  <span class="comment">// 1.获取动画必要元素</span></div><div class="line">  <span class="built_in">UIView</span> *containerView = [transitionContext containerView];</div><div class="line">  <span class="built_in">UIView</span> *fromView = [transitionContext viewForKey:<span class="built_in">UITransitionContextFromViewKey</span>];</div><div class="line">  <span class="built_in">UIView</span> *toView = [transitionContext viewForKey:<span class="built_in">UITransitionContextToViewKey</span>];</div><div class="line">  </div><div class="line">  toView.origin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>， kScreenHeight);      </div><div class="line">  </div><div class="line">  <span class="comment">// 2.动画</span></div><div class="line">  <span class="comment">// 出场</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>.transitionAnimatorType == TransitionAnimatorPresent) &#123;</div><div class="line">      <span class="comment">// 2.添加toView，不一定是addSubview方式</span></div><div class="line">      [containerView addSubview:toView];</div><div class="line">      [<span class="built_in">UIView</span> animateWithDuration:<span class="number">2.5</span> animations:^&#123;</div><div class="line">          toView.origin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>， <span class="number">0</span>);</div><div class="line">      &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">          <span class="comment">// 完成</span></div><div class="line">          [transitionContext completeTransition:<span class="literal">YES</span>];</div><div class="line">      &#125;];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 消失</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>.transitionAnimatorType == TransitionAnimatorDismiss) &#123;</div><div class="line">      [<span class="built_in">UIView</span> animateWithDuration:<span class="number">2.5</span> animations:^&#123;</div><div class="line">          fromView.origin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>， kScreenHeight);</div><div class="line">      &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">          <span class="comment">// 2.添加toView，不一定是addSubview方式</span></div><div class="line">          [fromView removeFromSuperview];</div><div class="line">          <span class="comment">// 完成</span></div><div class="line">          [transitionContext completeTransition:<span class="literal">YES</span>];</div><div class="line">  &#125;];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-交互"><a href="#3-交互" class="headerlink" title="(3) 交互"></a>(3) 交互</h2><p>(坑多，所以一般不用下列方式，取而代之使用UIPresentationController。)</p><p>在目标控制器的代理方法中，实现交互式代理方法:</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 2.交互出现动画</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForPresentation:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [[YAInteractiveTransition alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2.交互消失动画</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [[YAInteractiveTransition alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>新建一继承自UIPercentDrivenInteractiveTransition的交互组件类(最好这么做，也可以自定义类遵守UIViewControllerInteractiveTransitioning协议，但极不推荐)，实现必须的startInteractiveTransition方法。</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)startInteractiveTransition:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;&#125;</div></pre></td></tr></table></figure><h2 id="4-UIPresentationController"><a href="#4-UIPresentationController" class="headerlink" title="(4) UIPresentationController"></a>(4) UIPresentationController</h2><p>iOS8后的新API，极其方便。<br>把管理权限交给UIPresentationController.设置模态动画类型后，只需要在目标控制器的代理方法中实现:</p><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (nullable UIPresentationController *)<span class="selector-tag">presentationControllerForPresentedViewController</span><span class="selector-pseudo">:(UIViewController</span> *)<span class="selector-tag">presented</span> <span class="selector-tag">presentingViewController</span><span class="selector-pseudo">:(nullable</span> <span class="selector-tag">UIViewController</span> *)<span class="selector-tag">presenting</span> <span class="selector-tag">sourceViewController</span><span class="selector-pseudo">:(UIViewController</span> *)<span class="selector-tag">source</span> &#123;</div><div class="line">        return <span class="selector-attr">[[YAPresentationController alloc]</span> <span class="selector-tag">initWithPresentedViewController</span><span class="selector-pseudo">:presented</span> <span class="selector-tag">presentingViewController</span><span class="selector-pseudo">:presenting</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么所有的工作就在YAPresentationController控制器中了。<br>实现相应的方法:</p><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="comment">//在呈现过渡即将开始的时候被调用的</span></div><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">presentationTransitionWillBegin</span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">// 源控制器的View</span></div><div class="line">  <span class="selector-attr">[self.containerView addSubview:self.presentingViewController.view]</span>;</div><div class="line">  <span class="comment">// 背景View</span></div><div class="line">  <span class="selector-attr">[self.containerView addSubview:self.backgroundView]</span>;</div><div class="line">  <span class="comment">// 目标控制器View</span></div><div class="line">  <span class="selector-attr">[self.containerView addSubview:self.presentedView]</span>;</div><div class="line">            </div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">//在呈现过渡结束时被调用的</span></div><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">presentationTransitionDidEnd</span><span class="selector-pseudo">:(BOOL)completed</span>&#123;</div><div class="line">   </div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">//在退出过渡即将开始的时候被调用的</span></div><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">dismissalTransitionWillBegin</span>&#123;</div><div class="line"> </div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">//在退出的过渡结束时被调用的</span></div><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">dismissalTransitionDidEnd</span><span class="selector-pseudo">:(BOOL)completed</span>&#123;</div><div class="line">     </div><div class="line">&#125;</div><div class="line">   </div><div class="line">   </div><div class="line"><span class="comment">// 调整呈现的View的frame</span></div><div class="line"><span class="selector-tag">-</span> (CGRect)<span class="selector-tag">frameOfPresentedViewInContainerView</span>&#123;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="四、NavigationController转场"><a href="#四、NavigationController转场" class="headerlink" title="四、NavigationController转场"></a>四、NavigationController转场</h1><p>设置源控制器的导航控制器的代理，遵守UINavigationControllerDelegate协议，根据交互式或者非交互式实现相应方法.在方法中根据Push或者Pop返回相应的自定义动画控制器(或者交互控制器)。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 交互式</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)navigationController:(<span class="built_in">UINavigationController</span> *)navigationController</div><div class="line">                                 interactionControllerForAnimationController:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;) animationController &#123;</div><div class="line">  </div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">// 非交互式</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)navigationController:(<span class="built_in">UINavigationController</span> *)navigationController</div><div class="line">                                          animationControllerForOperation:(<span class="built_in">UINavigationControllerOperation</span>)operation</div><div class="line">                                                       fromViewController:(<span class="built_in">UIViewController</span> *)fromVC</div><div class="line">                                                         toViewController:(<span class="built_in">UIViewController</span> *)toVC &#123;</div><div class="line">  </div><div class="line">  <span class="comment">// Push情况下</span></div><div class="line">  <span class="keyword">if</span> (operation == <span class="built_in">UINavigationControllerOperationPush</span>) &#123;</div><div class="line">      <span class="keyword">return</span> [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPush];</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="built_in">UINavigationControllerOperationPop</span>) &#123; <span class="comment">// Pop情况下</span></div><div class="line">      <span class="keyword">return</span> [YATransitionAnimator transitionAnimatorWithType:TransitionAnimatorPop];</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="五、TabBarController转场"><a href="#五、TabBarController转场" class="headerlink" title="五、TabBarController转场"></a>五、TabBarController转场</h1><p>与导航控制器类似，设置源控制器的tabBarController的代理，遵循UITabBarControllerDelegate，实现相应的方法，只不过它既没有模态的Present和Dismiss，也没有导航控制器的Push和Pop，只有一种方式，更加简单，同样，在方法中返回自定义的动画控制器(或者交互控制器)。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)tabBarController: <span class="built_in">UITabBarController</span> *)tabBarControllerinteractionControllerForAnimationController:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationController &#123;&#125;</div><div class="line">  </div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)tabBarController:(<span class="built_in">UITabBarController</span> *)tabBarController animationControllerForTransitionFromViewController:(<span class="built_in">UIViewController</span> *)fromVC  toViewController:(<span class="built_in">UIViewController</span> *)toVC &#123;&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 自定义转场总结。 &lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://blog.chenyalun.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Git/LLDB/Linux等常用命令</title>
    <link href="http://blog.chenyalun.com/2017/02/20/Git:LLDB:Linux%E7%AD%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.chenyalun.com/2017/02/20/Git:LLDB:Linux等常用命令/</id>
    <published>2017-02-20T01:22:34.000Z</published>
    <updated>2017-04-10T03:10:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017.4.3 补充Clang指令<br>2017.4.2 补充</p></blockquote><p align="center"> Git/SVN/Linux/Vim/LLDB等常用、快忘记的命令总结。 </p><a id="more"></a><h1 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h1><pre><code>pod install --verbose --no-repo-update </code></pre><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>源代码管理工具能追踪一个项目从诞生一直到定案的过程，记录一个项目的所有内容变化，方便地查阅特定版本的修订情况。</p><p>Git与SVN的对比:<br>1.Git是分布式，有本地分支，SVN是集中式，无本地分支。<br>2.git合并操作保留原有的提交过程（即保留了合并来源的作者、提交次数、分离提交的内容）。<br>svn合并操作把来源多个提交合并成了一个合并提交。<br>3.git：可以修正提交(在自己的分支)。<br>svn：一旦提交就到服务器上，实际使用中就是不能修改。<br>4.SVN没有tag和真正意义的分支(它的分支是一个完整的目录。且这个目录拥有完整的实际文件)，Git支持。<br>5.Git有暂存区，提交速度快。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>1.清除本地以及远程的.DS_Store文件(修复后添加.gitignore)</p><pre><code>find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch</code></pre><p>2.克隆仓库到本地</p><pre><code>git clone https://github.com/ChenYalun/a.git</code></pre><p>3.添加忽略文件</p><pre><code>git add .gitignore</code></pre><p>4.提交修改</p><pre><code>git commit -m &quot;注释&quot;</code></pre><p>5.推送到远程仓库</p><pre><code>git push YAKit(仓库名称) origin(分支名称)</code></pre><h2 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h2><p>在git中，版本号是一个由SHA1生成的哈希值。<br> 查看git所有命令的帮助</p><pre><code>$ git help 子命令# 要退出帮助信息，按&quot;q&quot;# 翻看下页，按&quot;空格&quot;# 翻看上页，按&quot;CTRL+B&quot;# 要搜索相关文字，按&quot;/&quot;然后输入&quot;相关文字&quot;</code></pre><p>配置以及全局配置</p><pre><code>git config  user.name &quot;chenyalun&quot;git config  user.email iChenYalun@gmail.com git config --global user.name &quot;chenyalun&quot;git config --global user.email iChenYalun@gmail.com  查看当前所有配置git config -l 编辑(全局)配置文件git config -e [--global]</code></pre><p>在当前目录下初始化仓库</p><pre><code>git init</code></pre><p>新建一个目录，将其初始化为Git代码库</p><pre><code>git init [目录]</code></pre><p>添加所有的文件/指定的文件到暂存区</p><pre><code>git add .git add a.h，a.m</code></pre><p>添加目录到暂存区</p><pre><code>git add [dir]</code></pre><p>删除工作区文件</p><pre><code>git rm a.h a.m</code></pre><p>停止追踪指定文件,但是文件会保存在工作区</p><pre><code>git rm --cached a.h</code></pre><p>改名,并且将这个改名放入暂存区</p><pre><code>git mv old.h new.h</code></pre><p>提交文件，添加注释，要使用 -m 参数指定修改的备注信息</p><pre><code>git commit -m &quot;初始化仓库&quot;使用git时，每一次修改都需要添加(add)再提交(commit)，这一点是与svn不一样</code></pre><p>查询代码库当前状态(已加载，未加载等)</p><pre><code>git status</code></pre><p>查看所有版本库日志</p><pre><code>git log</code></pre><p>查看指定文件(a.m)的版本库日志</p><pre><code>git log a.m</code></pre><p>追加提交</p><pre><code>git commit -m &apos;initial commit&apos;git add forgotten_filegit commit --amend</code></pre><p>撤销某次提交</p><pre><code>git revert commitId</code></pre><p>提交时显示所有diff信息</p><pre><code>git commit -v</code></pre><p>使用一次新的commit，替代上一次提交<br>如果代码没有任何新变化，则用来改写上一次commit的提交信息</p><pre><code>git commit --amend -m [message]</code></pre><p>重做上一次commit，并包括指定文件的新变化</p><pre><code>git commit --amend a.h a.m</code></pre><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>恢复暂存区的指定文件到工作区</p><pre><code>git checkout a.h</code></pre><p>恢复某个commit的指定文件到暂存区和工作区</p><pre><code>git checkout [commit] [file]</code></pre><p>恢复暂存区的所有文件到工作区</p><pre><code>git checkout .</code></pre><p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p><pre><code>git reset a.h</code></pre><p>重置暂存区与工作区，与上一次commit保持一致</p><pre><code>git reset --hard</code></pre><p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p><pre><code>git reset [commit]</code></pre><p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p><pre><code>git reset --hard [commit]</code></pre><p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p><pre><code>git reset --keep [commit]</code></pre><p>新建一个commit，用来撤销指定commit<br>后者的所有变化都将被前者抵消，并且应用到当前分支</p><pre><code>git revert [commit]</code></pre><p>暂时将未提交的变化移除，稍后再移入</p><pre><code>git stashgit stash pop</code></pre><p>查看git的总提交次数</p><pre><code>git rev-list head | sort | wc -l</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>列出所有本地分支</p><pre><code>git branch</code></pre><p>列出所有远程分支</p><pre><code>git branch -r</code></pre><p>列出所有本地分支和远程分支</p><pre><code>git branch -a</code></pre><p>新建一个分支，但依然停留在当前分支</p><pre><code>git branch [branch-name]</code></pre><p>新建一个分支，并切换到该分支</p><pre><code>git checkout -b [branch]</code></pre><p>新建一个分支，指向指定commit</p><pre><code>git branch [branch] [commit]</code></pre><p>新建一个分支，与指定的远程分支建立追踪关系</p><pre><code>git branch --track [branch] [remote-branch]</code></pre><p>切换到指定分支，并更新工作区</p><pre><code>git checkout [branch-name]</code></pre><p>切换到上一个分支</p><pre><code>git checkout -</code></pre><p>建立追踪关系，在现有分支与指定的远程分支之间</p><pre><code>git branch --set-upstream [branch] [remote-branch]如:git branch --set-upstream dev remotes/origin/dev,名字保持一致</code></pre><p>合并指定分支到当前分支</p><pre><code>git merge [branch]// 通常使用下面这条:git merge --no-ff [branch]</code></pre><p>选择一个commit，合并进当前分支</p><pre><code>git cherry-pick [commit]</code></pre><p>删除分支</p><pre><code>git branch -d [branch-name]</code></pre><p>删除远程分支</p><pre><code>git push origin --delete [branch-name]git branch -dr [remote/branch]</code></pre><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>添加新的远程仓库</p><pre><code>git remote add &lt;name&gt; &lt;url&gt;</code></pre><p>拉取远程仓库的内容</p><pre><code>git fetch &lt;name&gt; [branchName] //不会合并，只拉取git pull &lt;name&gt;  [branchName] //拉取并且合并</code></pre><p>移除某个远程仓库</p><pre><code>git remote rm &lt;name&gt;</code></pre><p>重命名远程仓库</p><pre><code>git remote rename oldShortName newShortName</code></pre><p>查看远程仓库的url</p><pre><code>git remote -v</code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>列出所有tag</p><pre><code>git tag</code></pre><p>新建一个tag在当前commit</p><pre><code>git tag [tag]</code></pre><p>新建一个tag在指定commit</p><pre><code>git tag [tag] [commit]</code></pre><p>删除本地tag</p><pre><code>git tag -d [tag]</code></pre><p>删除远程tag</p><pre><code>git push origin :refs/tags/[tagName]</code></pre><p>查看tag信息</p><pre><code>git show [tag]</code></pre><p>提交指定tag</p><pre><code>git push [remote] [tag]</code></pre><p>提交所有tag</p><pre><code>git push [remote] --tags</code></pre><p>新建一个分支，指向某个tag</p><pre><code>git checkout -b [branch] [tag]</code></pre><h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><p>下载远程仓库的所有变动</p><pre><code>git fetch [remote]</code></pre><p>显示所有远程仓库</p><pre><code>git remote -v</code></pre><p>显示某个远程仓库的信息</p><pre><code>git remote show [remote]</code></pre><p>增加一个新的远程仓库，并命名</p><pre><code>git remote add [shortname] [url]</code></pre><p>取回远程仓库的变化，并与本地分支合并</p><pre><code>git pull [remote] [branch]</code></pre><p>上传本地指定分支到远程仓库</p><pre><code>git push [remote] [branch]</code></pre><p>强行推送当前分支到远程仓库，即使有冲突</p><pre><code>git push [remote] --force</code></pre><p>推送所有分支到远程仓库</p><pre><code>git push [remote] --all</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>设置git别名</p><pre><code>git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.unstage &apos;reset HEAD --&apos;</code></pre><p>文件权限不纳入版本管理</p><pre><code>git config core.filemode false</code></pre><h1 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h1><h2 id="初步-1"><a href="#初步-1" class="headerlink" title="初步"></a>初步</h2><p>checkout<br>将服务器上最新的代码仓库下载到本地，”只需要做一次”</p><p>update<br>从服务器上将其他人所做的修改下载到本地</p><p>commit<br>将工作提交到服务器</p><p>将文件添加到本地版本库中</p><pre><code>svn add main.c</code></pre><p>将文件提交到服务器的版本库中</p><pre><code>svn ci -m &quot;添加了main.c文件&quot; </code></pre><p>删除文件</p><pre><code>svn rm Person.h</code></pre><p>提交删除</p><pre><code>svn ci -m &quot;删除了文件&quot;注意：不要使用文件管理器直接删除文件</code></pre><p>撤销文件的修改</p><pre><code>svn revert Person.m</code></pre><p>恢复到之前的某个版本</p><pre><code>svn update -r 5svn up</code></pre><p>svn help (查看svn所有命令的帮助)</p><h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><pre><code>svn co http://192.168.1.188/svn/weibo --username=manager --password=managercheckout(co)之后，命令行会记录用户名和密码，后续操作不用再另行指定</code></pre><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><pre><code>命令行格式：svn &lt;subcommand&gt; [options] [args]说明svn 子命令 [选项] [参数]</code></pre><p>提示：</p><pre><code>[中括号]中包含的内容是可选的(子命令缩写)</code></pre><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><pre><code>查看svn日志svn log查看某一个文件的日志svn log filename查看某一个文件某个版本的日志svn log filename@1查看工作目录状态svn st</code></pre><h2 id="SVN-st"><a href="#SVN-st" class="headerlink" title="SVN st"></a>SVN st</h2><p>状态说明：描述文件被添加、删除或其他修改</p><pre><code>&apos; &apos; 没有修改&apos;A&apos; 被添加到本地代码仓库&apos;C&apos; 冲突&apos;D&apos; 被删除&apos;I&apos; 被忽略&apos;M&apos; 被修改&apos;R&apos; 被替换&apos;X&apos; 外部定义创建的版本目录&apos;?&apos; 文件没有被添加到本地版本库内，不在SVN的管理之下&apos;!&apos; 文件丢失或者不完整(不识别该文件)&apos;~&apos; 受控文件被其他文件阻隔&apos;U&apos; 更新最新的代码到本地(本地有文件的情况下)&apos;G&apos; 产生冲突后，更新操作去解决冲突，相当于进行合并</code></pre><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>Trunk<br>目前项目正在开发的版本</p><p>Tags<br>存放已经上线的重大版本</p><p>Branches<br>当发生重大bug或者有新需求时</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ol><li>读权限（r）写权限（w) 可执行权限（x）。</li><li><p>第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。</p></li><li><p>文件类型+所有者+用户组+其他用户。</p></li><li>空格:下一屏 回车:一行 q:退出 /word:搜索word (以及tab的自动补全)</li></ol><h2 id="初步-2"><a href="#初步-2" class="headerlink" title="初步"></a>初步</h2><p>最基本(不阐述)</p><pre><code>cd clear pwd mkdir rmdir who whoami exit ping</code></pre><p>查看</p><pre><code>ls -a(所有) -l(列表) -h(显示大小)</code></pre><p>重定向(结果重定向到一个文件，不存在创建，存在覆盖)</p><pre><code>ls &gt; a.txt </code></pre><p>分屏</p><pre><code>more</code></pre><p>管道(一个命令的结果作为另一个命令的输入)</p><pre><code>ls -a | more</code></pre><p>删除</p><pre><code>rm Dir/ -r 递归地删除，删除文件夹必带rm a.txt -f 强制删除，忽略不存在的文件，无需提示rm b -i 交互式</code></pre><p>链接<br>软链接:软链接不占用磁盘空间，源文件删除则软链接失效。(快捷方式)<br>硬链接:硬链接只能链接普通文件，不能链接目录。两个文件占用相同大小的硬盘空间，不常用。</p><pre><code>ln 源文件 链接文件 (硬链接)ln -s 源文件 链接文件 </code></pre><p>查看或合并</p><pre><code>cat q.txtcat 1.txt 2.txt &gt; 3.txt (重定向)</code></pre><p>文本搜索可正则</p><pre><code>grep -v(选项) &apos;app&apos;(匹配字符串) a.txt(文件名)-v 显示不包含匹配文本的所有行-n 显示匹配行及行号-i 忽略大小写</code></pre><p>查找</p><pre><code>find ./ -name a.txtfind ./ -name &apos;*.txt&apos;find ./ -size +10M(大于10M)</code></pre><p>拷贝</p><pre><code>cp-a     该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。-f     强制-i     交互-r     递归-v     进度</code></pre><p>移动(重命名)</p><pre><code>mv-f -v -i</code></pre><p>归档与压缩</p><pre><code>tar [参数] 打包文件名 文件gzip  [选项]  被压缩文件</code></pre><p>切换用户</p><pre><code>su 不切换目录su - 切换目录su root 到rootsu -root 到root，同时到/root目录</code></pre><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>日历</p><pre><code>cal</code></pre><p>时间</p><pre><code>date</code></pre><p>网卡</p><pre><code>ifconfig</code></pre><p>进程</p><pre><code>ps-a     所有-u     详细状态-x     显示没有控制终端的进程-w     显示加宽-r     正在运行</code></pre><p>动态进程</p><pre><code>topM     内存使用量 排序P     CPU占有率 排序T     运行时间 排序U     可以根据后面输入的用户名来筛选进程K     可以根据后面输入的PID来杀死进程。kill pidq     退出h     获得帮助</code></pre><p>关机重启</p><pre><code>reboot     重启shutdown –r now     重新启动shutdown -h now     立刻关机shutdown -h 20:25     在今天的20:25会关机shutdown -h +10     过十分钟后自动关机init 0     关机init 6     重启</code></pre><p>磁盘空间</p><pre><code>df-a     所有-m     以1024字节为单位显示-t     显示各指定文件系统的磁盘空间使用情况-T     显示文件系统</code></pre><p>目录所占磁盘空间</p><pre><code>du-a     递归-s     显示指定文件或目录占用的数据块-b     以字节为单位显示磁盘占用情况-l     计算所有文件大小，对硬链接文件计算多次</code></pre><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><h2 id="初步-3"><a href="#初步-3" class="headerlink" title="初步"></a>初步</h2><pre><code>i: 插入光标前一个字符 I: 插入行首 a: 插入光标后一个字符 A: 插入行未 o: 向下新开一行，插入行首 O: 向上新开一行，插入行首</code></pre><p>ESC:从插入模式或末行模式进入命令模式</p><p>移动光标:</p><pre><code>h: 左移 j: 下移 k: 上移 l: 右移M: 光标移动到中间行 L: 光标移动到屏幕最后一行行首 G: 移动到指定行，行号 -Gw: 向后一次移动一个字 b: 向前一次移动一个字{: 按段移动，上移 }: 按段移动，下移Ctr-d: 向下翻半屏 Ctr-u: 向上翻半屏Ctr-f: 向下翻一屏 Ctr-b: 向上翻一屏gg: 光标移动文件开头 G: 光标移动到文件末尾</code></pre><p>删除命令:</p><pre><code>x: 删除光标后一个字符，相当于 Del X: 删除光标前一个字符，相当于 Backspacedd: 删除光标所在行，n dd 删除指定的行数 D: 删除光标后本行所有内容，包含光标所在字符 d0: 删除光标前本行所有内容，不包含光标所在字符dw: 删除光标开始位置的字，包含光标所在字符</code></pre><p>撤销命令:</p><pre><code>u: 一步一步撤销 Ctr-r: 反撤销</code></pre><p>重复命令:</p><pre><code>.: 重复上一次操作的命令</code></pre><p>文本行移动:</p><pre><code>&gt;&gt;:文本行右移动&lt;&lt;:文本行左移动</code></pre><p>复制粘贴:</p><pre><code>yy: 复制当前行，n yy 复制 n 行 p: 在光标所在位置向下新开辟一行，粘贴</code></pre><p>可视模式:</p><pre><code>v: 按字符移动，选中文本 V: 按行移动，选中文本可视模式可以配合 d， y， &gt;&gt;， &lt;&lt; 实现对文本块的删除，复制，左右移动</code></pre><p>替换操作:</p><pre><code>r: 替换当前字符 R: 替换当前行光标后的字符</code></pre><p>查找命令:</p><pre><code>/: str查找n: 下一个N：上一个</code></pre><p>替换命令：</p><p>把abc全部替换成123</p><pre><code>末行模式下，将光标所在行的abc替换成123:%s/abc/123/g末行模式下，将第一行至第10行之间的abc替换成123:1， 10s/abc/123/g</code></pre><p>vim里执行 shell 下命令:</p><pre><code>末行模式里输入!，后面跟命令</code></pre><h1 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h1><h2 id="初步-4"><a href="#初步-4" class="headerlink" title="初步"></a>初步</h2><pre><code>help</code></pre><p>输出</p><pre><code>p (int)self.view.subviews.count 基本类型 po self.view 对象</code></pre><p>修改</p><pre><code>expr a = 3expr int $c = 10 声明一个新变量</code></pre><p>调用</p><pre><code>call self.view.backgroundColor = [UIColor redColor]方法无返回值时使用call</code></pre><p>堆栈</p><pre><code>bt 加all可打印所有thread的堆栈</code></pre><p>寻址</p><pre><code>image lookup --address 0x0000000103aca1e1寻找栈地址对应的代码位置</code></pre><h1 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h1><h2 id="初步-5"><a href="#初步-5" class="headerlink" title="初步"></a>初步</h2><p> 编译单个c源文件，并产生一个目标文件  </p><pre><code>cc -c one.c</code></pre><p> 编译多个c源文件，并为每个文件产生一个目标文件  </p><pre><code>cc -c one.c two.c three.c</code></pre><p> 链接单个目标文件产生一个名为a.out的可执行文件  </p><pre><code>cc one.o</code></pre><p> 链接多个目标文件  </p><pre><code>cc one.o two.o three.o</code></pre><p> 编译并链接一个c源文件  </p><pre><code>cc one.c</code></pre><p> 编译并链接多个c源文件  </p><pre><code>cc one.c two.c three.c</code></pre><p> 编译一个c源文件，并把它和现存的目标文件链接在一起  </p><pre><code>cc one.o two.o three.c</code></pre><p> 可执行文件重命名加上“-o name”这个选项  </p><pre><code>cc -o abc one.c</code></pre><p> 执行可执行文件  </p><pre><code>./a.out</code></pre><p>编译C++文件</p><pre><code>clang++ -Wall -g -std=c++11 -stdlib=libc++ fileName.cpp -o targetFileName</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017.4.3 补充Clang指令&lt;br&gt;2017.4.2 补充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; Git/SVN/Linux/Vim/LLDB等常用、快忘记的命令总结。 &lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://blog.chenyalun.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Git" scheme="http://blog.chenyalun.com/tags/Git/"/>
    
      <category term="SVN" scheme="http://blog.chenyalun.com/tags/SVN/"/>
    
      <category term="Linux" scheme="http://blog.chenyalun.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>iOS应用优化总结</title>
    <link href="http://blog.chenyalun.com/2017/02/14/iOS%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.chenyalun.com/2017/02/14/iOS应用优化总结/</id>
    <published>2017-02-14T11:26:34.000Z</published>
    <updated>2017-03-15T09:17:29.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 一些优化的Tips。 </p><a id="more"></a><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><ul><li><p>UITableView采用注册的方式使用reuseIdentifier<br><code>static NSString *CellIdentifier = @&quot;Cell&quot;;</code>复用 Cell 与各个 Section 的 Header 和 Footer。<br>复用 Cell 时， storyboard 中的 cell 设置 reuseIdentifier 完毕即可，无需注册，xib 与 class 自定义的cell 需要设置 reuseIdentifier 而且要注册。</p></li><li><p>使用UITableView+FDTemplateLayoutCell<br>优点:预缓存机制/自动的缓存失效机制/根据 autolayout 约束自动计算高度。<br>注意:cacheByKey比cacheByIndexPath 更为高效。</p> <figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="keyword">return</span> [tableView <span class="string">fd_heightForCellWithIdentifier:</span>reuseIdentifier <span class="string">cacheByIndexPath:</span>indexPath <span class="string">configuration:</span>^(YACommentTableViewCell *cell) &#123;</div><div class="line">       cell.comment = self.comments[indexPath.section][indexPath.row];</div><div class="line">   &#125;];</div></pre></td></tr></table></figure></li></ul><ul><li><p>使用</p><figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 不缓存高度</span></div><div class="line"><span class="keyword">return</span> [tableView <span class="string">fd_heightForCellWithIdentifier:</span>reuseIdentifier <span class="string">configuration:</span>^(YACommentTableViewCell *cell)&#123;</div><div class="line">    cell.comment = self.comments[indexPath.section][indexPath.row];</div><div class="line">    </div><div class="line">&#125;];</div><div class="line">     </div><div class="line"><span class="comment">// 更高效，但是当高度变化时，需要手动清除缓存</span></div><div class="line">YACommentModel *model = self.comments[indexPath.section][indexPath.row];</div><div class="line"><span class="keyword">return</span> [tableView <span class="string">fd_heightForCellWithIdentifier:</span>reuseIdentifier <span class="string">cacheByKey:</span>model.ID <span class="string">configuration:</span>^(id cell) &#123;</div><div class="line">     cell.comment = self.comments[indexPath.section][indexPath.row];</div><div class="line">&#125;];</div><div class="line">     </div><div class="line"><span class="comment">// 移除 key 对应的高度缓存</span></div><div class="line">[tableView.fd_keyedHeightCache <span class="string">invalidateHeightForKey:</span>key];</div><div class="line"><span class="comment">// 移除所有高度缓存</span></div><div class="line">[tableView.fd_keyedHeightCache invalidateAllHeightCache];</div></pre></td></tr></table></figure></li></ul><ul><li>设置 opaque 为YES，尽量把 view 设置为透明。</li></ul><ul><li><p>尽量不使用<code>cellForRowAtIndexPath:</code>，用一次然后缓存结果。</p></li><li><p>尝试缓存。</p></li><li><p>保证XIB文件的小巧灵活。</p></li><li><p>预处理懒加载。</p></li><li><p>处理内存警告。</p></li><li><p>单一固定的情况下，使用<code>rowHeight</code>， <code>sectionFooterHeight</code>和 <code>sectionHeaderHeight</code>来设定固定的高，而不是请求delegate。</p></li><li><p>使用</p><figure class="highlight cos"><table><tr><td class="code"><pre><div class="line">shadowPath，<span class="keyword">view</span>.layer.shadowPath = [[UIBezierPath bezierPathWithRect:<span class="keyword">view</span>.bounds] CGPath]<span class="comment">;</span></div><div class="line"></div><div class="line">  <span class="comment">// 而不是:</span></div><div class="line"></div><div class="line">  <span class="keyword">view</span>.layer.shadowOffset = CGSizeMake(-<span class="number">1</span>， <span class="number">1</span>)<span class="comment">;</span></div><div class="line">  </div><div class="line">  <span class="keyword">view</span>.layer.shadowRadius = <span class="number">1.0</span>f<span class="comment">;</span></div><div class="line">  </div><div class="line">  <span class="keyword">view</span>.layer.shadowOpacity = <span class="number">0.1</span><span class="comment">;</span></div></pre></td></tr></table></figure></li></ul><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul><li><p>合理开线程，主线程占1M，子线程占512K。UI 操作和 DataSource 的操作一定在主线程。DB 操作、日志记录、网络回调都在各自的固定线程。</p></li><li><p>选择合适的容器，减少subviews的数量。<br>NSArrayi:有序的。能搞按照索引快速查找元素。按照值查找很慢，插入和删除很慢。<br>NSDictionary:无序的。键值对存储。按照key可以快速查找。<br>NSSet: 无序的。按照值可以快速查找，插入和删除很快。</p></li><li><p>正确使用 <code>imageNamed:</code> 与 <code>imageWithContentsOfFile:</code>，<code>imageNamed:</code>的优点是当加载时会缓存图片，所以当图片会频繁的使用时，用<code>imageNamed:</code>。<code>imageWithContentsOfFile：</code>仅加载图片，图像数据不会缓存，对于较大的图片以及使用情况较少时，就可以用该方法，降低内存消耗。</p></li><li><p>慎用 NSDateFormatter和NSCalendar，缓存 NSDateFormatter 的结果。<br>Creating a date formatter is not a cheap operation. If you are likely to use a formatter frequently， it is typically more efficient to cache a single instance than to create and dispose of multiple instances. One approach is to use a static variable.</p></li></ul><ul><li><p>在iOS 7、macOS 10.9及以上系统版本，NSDateFormatter都是线程安全的。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>， <span class="keyword">strong</span>) <span class="built_in">NSDateFormatter</span> *formatter;</div><div class="line">   </div><div class="line">- (<span class="built_in">NSDateFormatter</span> *)formatter &#123;</div><div class="line"> <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *formatter;</div><div class="line"> <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line"> <span class="built_in">dispatch_once</span>(&amp;onceToken， ^&#123;</div><div class="line">     _formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line">     _formatter.dateFormat = <span class="string">@"EEE MMM dd HH:mm:ss Z yyyy"</span>; <span class="comment">// twitter date format</span></div><div class="line"> &#125;);</div><div class="line"> <span class="keyword">return</span> formatter</div><div class="line">;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>寻找 (NSDate *)dateFromString:(NSString )string 的替换品。下面是ISO8601 转成 NSDate 的 NSDateFormatter 的最著名替代品，也可以使用开源作品:NSDate+SSToolkitAdditions。</p> <figure class="highlight perl"><table><tr><td class="code"><pre><div class="line">  //<span class="comment">#include &lt;time.h&gt;</span></div><div class="line">time_t t;</div><div class="line">struct tm tm;</div><div class="line">strptime([iso8601String cStringUsingEncoding:NSUTF8StringEncoding]， <span class="string">"%Y-%m-%dT%H:%M:%S%z"</span>， &amp;tm);</div><div class="line">tm.tm_isdst = -<span class="number">1</span>;</div><div class="line">t = mktime(&amp;tm);</div><div class="line">[NSDate dateWithTimeIntervalSince197<span class="number">0</span>:t + [[NSTimeZone localTimeZone] secondsFromGM</div><div class="line">T]];</div></pre></td></tr></table></figure></li><li><p>不要随意使用 <code>NSLog()</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></div><div class="line"><span class="comment">// Only log when attached to the debugger</span></div><div class="line"><span class="meta">#    <span class="meta-keyword">define</span> DLog(...) NSLog(__VA_ARGS__)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#    <span class="meta-keyword">define</span> DLog(...) <span class="comment">/* */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">// Always log， even in production</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ALog(...) NSLog(__VA_ARGS__)</span></div></pre></td></tr></table></figure></li><li><p>当试图获取磁盘中一个文件的属性信息时，使用 <code>[NSFileManager attributesOfItemAtPath:error:]</code>会浪费大量时间读取可能根本不需要的附加属性。这时可以使用 stat 代替 NSFileManager，直接获取文件属性：</p> <figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line">  <span class="keyword">struct</span> stat statbuf;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cpath = [filePath fileSystemRepresentation];</div><div class="line">  <span class="keyword">if</span> (cpath &amp;&amp; stat(cpath， &amp;statbuf) == <span class="number">0</span>) &#123;</div><div class="line">      <span class="built_in">NSNumber</span> *fileSize = [<span class="built_in">NSNumber</span> numberWithUnsignedLongLong:statbuf.st_size];</div><div class="line">      <span class="built_in">NSDate</span> *modificationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:statbuf.st_mtime];</div><div class="line">      <span class="built_in">NSDate</span> *creationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:statbuf.st_ctime];</div><div class="line">      <span class="comment">// etc</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure></li><li><p>MLeakFinder 能在开发阶段，把内存泄露问题暴露无遗，减少了很多潜在的性能问题.    原理:在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 view，view 的 subviews 等等是否还存在。</p></li><li><p>接入bugly。</p></li><li><p>创造圆形图片避免使用以下方式(会造成离屏渲染):</p> <figure class="highlight maxima"><table><tr><td class="code"><pre><div class="line"><span class="built_in">view</span>.layer.cornerRadius = <span class="built_in">view</span>.<span class="built_in">width</span> * <span class="number">0.5</span>;</div><div class="line">   <span class="built_in">view</span>.layer.masksToBounds = <span class="literal">true</span></div></pre></td></tr></table></figure></li></ul><ul><li><p>圆形图片</p><figure class="highlight arduino"><table><tr><td class="code"><pre><div class="line">UIBezierPath *clipPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(<span class="number">0</span>， <span class="number">0</span>， <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">width</span>， <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">height</span>)] ;</div><div class="line">     </div><div class="line">[clipPath addClip] ;</div><div class="line">    </div><div class="line">[<span class="built_in">image</span> drawAtPoint:CGPointZero] ;</div><div class="line">     </div><div class="line"><span class="built_in">image</span> = UIGraphicsGetImageFromCurrentImageContext() ;</div><div class="line"> </div><div class="line">UIGraphicsEndImageContext() ;</div><div class="line">     </div><div class="line"><span class="built_in">return</span> <span class="built_in">image</span> ;</div></pre></td></tr></table></figure></li><li><p>设置Label的圆角。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 不要这么做：label.backgroundColor = aColor </span></div><div class="line"><span class="comment">// 以及不要在 IB 里为 label 设置背景色</span></div><div class="line"><span class="selector-tag">label</span><span class="selector-class">.layer</span><span class="selector-class">.backgroundColor</span> = aColor</div><div class="line"><span class="selector-tag">label</span><span class="selector-class">.layer</span><span class="selector-class">.cornerRadius</span> = <span class="number">5</span></div></pre></td></tr></table></figure></li><li><p>指定图片的宽高为整数，否则造成离屏渲染。</p></li><li><p>cell当中不要动态的添加子控件，选中适时地显示与隐藏。</p></li><li><p>当控件非常多时，把不需要与用户进行交互的控件.通过异步绘制成一张图片，把图片添加到cell当中。</p></li><li>将 UIView 的属性 clearsContextBeforeDrawing 设置为 NO 在多数情况下可以提高绘制性能，尤其是在用绘制代码实现了一个定制 view 的时候。</li><li><p>设置阴影。</p><figure class="highlight cos"><table><tr><td class="code"><pre><div class="line"><span class="keyword">view</span>.layer.shadowPath = [[UIBezierPath bezierPathWithRect:<span class="keyword">view</span>.bounds] CGPath]<span class="comment">;</span></div><div class="line">   </div><div class="line"><span class="comment">// 而不是</span></div><div class="line"><span class="keyword">view</span>.layer.shadowOffset = CGSizeMake(-<span class="number">1.0</span>f， <span class="number">1.0</span>f)<span class="comment">;</span></div><div class="line"><span class="keyword">view</span>.layer.shadowRadius = <span class="number">5.0</span>f<span class="comment">;</span></div><div class="line"><span class="keyword">view</span>.layer.shadowOpacity = <span class="number">0.6</span><span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>通常图层的以下属性将会触发离屏渲染：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">阴影（UIView<span class="selector-class">.layer</span><span class="selector-class">.shadowOffset</span>/shadowRadius/…）</div><div class="line">圆角（当 UIView<span class="selector-class">.layer</span><span class="selector-class">.cornerRadius</span> 和 UIView<span class="selector-class">.layer</span><span class="selector-class">.maskToBounds</span> 一起使用时）</div><div class="line">图层蒙板</div></pre></td></tr></table></figure></li><li><p>使用 Autorelease Pool，当需要在代码中创建许多临时对象时，可以显式的使用 Autorelease Pool。</p></li><li><p>使用IMP。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 一些优化的Tips。 &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.chenyalun.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.chenyalun.com/tags/iOS/"/>
    
      <category term="优化" scheme="http://blog.chenyalun.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS常用设计模式</title>
    <link href="http://blog.chenyalun.com/2017/02/11/iOS%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.chenyalun.com/2017/02/11/iOS常用设计模式/</id>
    <published>2017-02-11T07:36:34.000Z</published>
    <updated>2017-03-15T09:09:45.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 关于设计模式。 </p><a id="more"></a><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><ul><li><p>原型模式是通过克隆已有的对象来创建新的对象，已有的对象即为原型。(Objective-C中的深复制)</p></li><li><p>优点:将创建对象的代码隐藏，屏蔽初始化的具体细节，避免重复耗时的过程。</p></li><li><p>当需要创建一个新的实例，但不想依赖初始化器，使用此模式。</p></li><li><p>注意:深复制与浅复制的问题。浅复制:复制对象的引用，深复制:复制对象本身。不可变对象的copy操作是浅复制，其他情况是深复制，但是集合类对象即便是深复制，也是复制集合类对象自身，里面的元素并未复制，或者说是单层深复制，而要对集合类对象进行完全彻底的复制，归档可以解决。</p></li><li><p>应用:实现NSCopying协议并保证类的基类是NSObject。</p></li><li><p>实现方法: 根类遵循NSCopying协议，重写copyWithZone方法，创建一个复制方法Operation，方便自身以及增加属性的子类再次复制。</p></li><li><p>YAObject担当根类，遵循NSCopying协议，重写copyWithZone方法，提供复制接口copyWithObject，方便自身以及子类复制.YAPerson增加两个属性，且类型是集合类。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAObject</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></div><div class="line"><span class="comment">/** 年龄 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="comment">/** 姓名 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line">   </div><div class="line"><span class="comment">/** 复制操作 */</span></div><div class="line">- (<span class="keyword">void</span>)copyWithObject:(<span class="built_in">NSObject</span> *)object;</div><div class="line"><span class="keyword">@end</span></div><div class="line">   </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAPerson</span> : <span class="title">YAObject</span></span></div><div class="line"><span class="comment">/** 书籍 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">strong</span>) <span class="built_in">NSArray</span> *books;</div><div class="line"><span class="comment">/** 朋友 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *friends;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></li><li><p>copyWithZone操作中，[self class]使子类也能调用此方法，子类中，重写copyWithObject操作，当有集合类元素的时候，不能单纯的[array copy]，这样仅是复制了集合元素自身，却没有复制集合中的元素，是单层深复制，要copyItems。</p><figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="meta">@implementation</span> <span class="type">YAObject</span></div><div class="line"><span class="comment">// 实现的时候用copyWithZone，调用的时候用copy，最顶层的根类重写该方法，子类调用但不得重写</span></div><div class="line">- (id)copyWithZone:(<span class="type">NSZone</span> *)zone &#123;</div><div class="line">    <span class="type">YAObject</span> *<span class="class"><span class="keyword">object</span> </span>= [[[self <span class="class"><span class="keyword">class</span>] <span class="title">allocWithZone</span></span>:zone] init];</div><div class="line">    <span class="comment">// 把自己copy后赋予object</span></div><div class="line">    [self copyWithObject:<span class="class"><span class="keyword">object</span>]</span>;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">object</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 自身以及子类实现该方法以赋值给object</span></div><div class="line">- (void)copyWithObject:(<span class="type">YAObject</span> *)<span class="class"><span class="keyword">object</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">object</span>.<span class="title">name</span> </span>= self.name;</div><div class="line">    <span class="class"><span class="keyword">object</span>.<span class="title">age</span> </span>= self.age;</div><div class="line">&#125;</div><div class="line"><span class="meta">@end</span></div><div class="line"></div><div class="line"><span class="meta">@implementation</span> <span class="type">YAPerson</span></div><div class="line"><span class="comment">// 又增加了属性</span></div><div class="line"><span class="comment">// 自身以及子类实现该方法以赋值给object</span></div><div class="line">- (void)copyWithObject:(<span class="type">YAPerson</span> *)<span class="class"><span class="keyword">object</span> </span>&#123;</div><div class="line">    [<span class="keyword">super</span> copyWithObject:<span class="class"><span class="keyword">object</span>]</span>;</div><div class="line">    <span class="class"><span class="keyword">object</span>.<span class="title">books</span> </span>= [[<span class="type">NSArray</span> alloc] initWithArray:self.books copyItems:<span class="type">YES</span>];</div><div class="line">    <span class="class"><span class="keyword">object</span>.<span class="title">friends</span> </span>= [[<span class="type">NSMutableArray</span> alloc] initWithArray:self.friends copyItems:<span class="type">YES</span>];</div><div class="line">&#125;</div><div class="line"><span class="meta">@end</span></div></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><div class="line">YAObject *object = [[YAObject alloc] init]<span class="comment">;</span></div><div class="line">object.name = @<span class="string">"Aaron"</span><span class="comment">;</span></div><div class="line">object.age = <span class="number">22</span><span class="comment">;</span></div><div class="line">kLog(@<span class="string">"%@--%ld"</span>，object.name， object.age)<span class="comment">;</span></div><div class="line">  </div><div class="line">YAObject *objectB = [object copy]<span class="comment">;</span></div><div class="line">kLog(@<span class="string">"%@--%ld"</span>，objectB.name， objectB.age)<span class="comment">;</span></div><div class="line">  </div><div class="line">YAPerson *person = [[YAPerson alloc] init]<span class="comment">;</span></div><div class="line">person.name = @<span class="string">"A"</span><span class="comment">;</span></div><div class="line">person.age = <span class="number">25</span><span class="comment">;</span></div><div class="line">person.<span class="keyword">books </span>= @[@<span class="string">"V"</span>，@<span class="string">"T"</span>，@<span class="string">"N"</span>]<span class="comment">;</span></div><div class="line">person.friends = [NSMutableArray arrayWithObjects:@<span class="string">"QQ"</span>，@<span class="string">"WeChat"</span>， nil]<span class="comment">;</span></div><div class="line">  </div><div class="line">YAPerson *personB = [person copy]<span class="comment">;</span></div><div class="line">kLog(@<span class="string">"%@-%ld-%@-%@"</span>，personB.name， personB.age， personB.<span class="keyword">books， </span>personB.friends)<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul><h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><ul><li><p>单例模式保证某个类型的对象在应用中只存在一个实例。</p></li><li><p>封装共享资源，管理代表现实世界资源的对象。</p></li><li><p>当进一步创建对象却不能增加现实中的可用资源，或者希望对象只存在一个实例时使用。</p></li><li><p>要求该实例无法真正意义上被复制克隆。</p></li><li><p>实现:考虑多线程，重写alloc init方法。</p></li><li><p>考虑调用copy等方法，不遵循NSCopying协议，重写Copy等方法。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YASingleton</span> : <span class="title">NSObject</span></span></div><div class="line">  <span class="comment">// 接口</span></div><div class="line">  + (<span class="keyword">instancetype</span>)sharedSingleton;</div><div class="line">  <span class="keyword">@end</span></div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">@implementation</span> <span class="title">YASingleton</span></span></div><div class="line">     <span class="comment">// 重写alloc  init</span></div><div class="line">     <span class="keyword">static</span> YASingleton *singleton = <span class="literal">nil</span>;</div><div class="line">     + (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</div><div class="line">         <span class="keyword">if</span> (singleton == <span class="literal">nil</span>) &#123;</div><div class="line">             <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">             <span class="built_in">dispatch_once</span>(&amp;onceToken， ^&#123;</div><div class="line">                 singleton = [<span class="keyword">super</span> allocWithZone:zone];</div><div class="line">             &#125;);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> singleton;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     - (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">         <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">         <span class="built_in">dispatch_once</span>(&amp;onceToken， ^&#123;</div><div class="line">             singleton = [<span class="keyword">super</span> init];</div><div class="line">         &#125;);</div><div class="line">         <span class="keyword">return</span> singleton;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">// 考虑复制的情况</span></div><div class="line">     <span class="comment">/*</span></div><div class="line">      不建议</div><div class="line">     - (id)mutableCopyWithZone:(struct _NSZone *)zone &#123;</div><div class="line">         return singleton;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     - (id)copyWithZone:(struct _NSZone *)zone &#123;</div><div class="line">         return singleton;</div><div class="line">     &#125;</div><div class="line">     */</div><div class="line">     - (<span class="keyword">id</span>)<span class="keyword">copy</span> &#123;</div><div class="line">         <span class="keyword">return</span> singleton;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     - (<span class="keyword">id</span>)mutableCopy &#123;</div><div class="line">         <span class="keyword">return</span> singleton;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">// 接口</span></div><div class="line">     + (<span class="keyword">instancetype</span>)sharedSingleton &#123;</div><div class="line">         <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">      &#125;</div><div class="line">     <span class="keyword">@end</span></div></pre></td></tr></table></figure></li><li><p>除了使用GCD，也可以使用互斥锁。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 互斥锁的形式</span></div><div class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</div><div class="line">    <span class="keyword">if</span> (singleton == <span class="literal">nil</span>) &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        singleton = [<span class="keyword">super</span> allocWithZone:zone];</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> singleton;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>打印地址，验证：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><div class="line">YASingleton *sing = [YASingleton <span class="keyword">sharedSingleton];</span></div><div class="line">YASingleton *singB = [sing copy]<span class="comment">;</span></div><div class="line">YASingleton *singC = [sing mutableCopy]<span class="comment">;</span></div><div class="line">YASingleton *singD = [[YASingleton alloc] init]<span class="comment">;</span></div><div class="line">kLog(@<span class="string">"%p-%p-%p-%p"</span>，sing， singB， singC， singD)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>似乎封装成宏更好一点：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 单例</span></div><div class="line"><span class="meta">#define YASingH(Name) + (instancetype)shared##Name;</span></div><div class="line">   </div><div class="line"><span class="meta">#define YASingM(Name) \</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instace = <span class="literal">nil</span>; \</div><div class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone \</div><div class="line">&#123; \</div><div class="line"><span class="keyword">if</span> (_instace == <span class="literal">nil</span>) &#123; \</div><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken， ^&#123; \</div><div class="line">_instace = [<span class="keyword">super</span> allocWithZone:zone]; \</div><div class="line">&#125;); \</div><div class="line">&#125; \</div><div class="line"><span class="keyword">return</span> _instace; \</div><div class="line">&#125; \</div><div class="line">\</div><div class="line">- (<span class="keyword">id</span>)init \</div><div class="line">&#123; \</div><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken， ^&#123; \</div><div class="line">_instace = [<span class="keyword">super</span> init]; \</div><div class="line">&#125;); \</div><div class="line"><span class="keyword">return</span> _instace; \</div><div class="line">&#125; \</div><div class="line">\</div><div class="line">+ (<span class="keyword">instancetype</span>)shared<span class="meta">##Name \</span></div><div class="line">&#123; \</div><div class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init]; \</div><div class="line">&#125; \</div><div class="line">- (<span class="keyword">instancetype</span>)<span class="keyword">copy</span> \</div><div class="line">&#123; \</div><div class="line"><span class="keyword">return</span> _instace; \</div><div class="line">&#125; \</div><div class="line">\</div><div class="line">- (<span class="keyword">instancetype</span>)mutableCopy \</div><div class="line">&#123; \</div><div class="line"><span class="keyword">return</span> _instace; \</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h1><ul><li><p>适配器使得两个不兼容的API组件协同工作，用于连接两种不同种类的对象。</p></li><li><p>解决无法修改或者不修改源代码的组件的兼容性问题。</p></li><li><p>类适配器:适配器继承主功能组件，遵循适配接口协议。</p></li><li><p>对象适配器:适配器持有主功能组件(作为成员变量)，遵循适配接口协议。</p></li><li><p>类适配器的实现</p><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="variable">@interface</span> <span class="attribute">YAMac </span>: NSObject</div><div class="line"><span class="comment">// Mac自带显示接口</span></div><div class="line">- (void)show;</div><div class="line"><span class="variable">@end</span></div><div class="line">   </div><div class="line"><span class="comment">// 一般显示器DVI接口</span></div><div class="line"><span class="variable">@protocol</span> YADVI &lt;NSObject&gt;</div><div class="line">- (void)dvi;</div><div class="line"><span class="variable">@end</span></div><div class="line">   </div><div class="line"><span class="comment">// 适配器:继承自Mac，有显示的功能，遵循YADVI协议，可以显示到一般显示器上</span></div><div class="line"><span class="variable">@interface</span> <span class="attribute">YAMacDVIAdapter </span>: YAMac &lt;YADVI&gt;</div><div class="line"><span class="variable">@end</span></div><div class="line">  </div><div class="line"><span class="variable">@implementation</span> YAMac</div><div class="line">- (void)show &#123;</div><div class="line">  kLog(@"Mac自带显示接口");</div><div class="line">&#125;</div><div class="line"><span class="variable">@end</span></div><div class="line">   </div><div class="line"><span class="comment">// 适配器实现</span></div><div class="line"><span class="variable">@implementation</span> YAMacDVIAdapter</div><div class="line">   </div><div class="line">- (void)dvi &#123;</div><div class="line">  <span class="selector-attr">[super show]</span>; <span class="comment">// 可以显示内容</span></div><div class="line">  kLog(@"可以连接到一般的显示器");</div><div class="line">&#125;</div><div class="line"><span class="variable">@end</span></div><div class="line">   </div><div class="line"><span class="comment">// 具体使用，调用接口即可</span></div><div class="line">YAMacDVIAdapter *adapter = [[YAMacDVIAdapter alloc] init];</div><div class="line"><span class="selector-attr">[adapter dvi]</span>;</div></pre></td></tr></table></figure></li></ul><ul><li><p>当不再继承主功能组件，而是把它作为属性持有的时候，便是对象适配器。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAMac</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="comment">// Mac自带显示接口</span></div><div class="line">- (<span class="keyword">void</span>)show;</div><div class="line"><span class="keyword">@end</span></div><div class="line">   </div><div class="line"><span class="comment">// 一般显示器DVI接口</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YADVI</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)dvi;</div><div class="line"><span class="keyword">@end</span></div><div class="line">   </div><div class="line"><span class="comment">// 适配器:遵循YADVI协议，可以显示到一般显示器上，拥有Mac属性，有显示的功能</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAMacDVIAdapter</span> : <span class="title">NSObject</span> &lt;<span class="title">YADVI</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">strong</span>) YAMac *mac;</div><div class="line"><span class="keyword">@end</span></div><div class="line">   </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAMac</span></span></div><div class="line">- (<span class="keyword">void</span>)show &#123;</div><div class="line">  kLog(<span class="string">@"Mac自带显示接口"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line">   </div><div class="line"><span class="comment">// 适配器实现</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAMacDVIAdapter</span></span></div><div class="line">   </div><div class="line">- (<span class="keyword">void</span>)dvi &#123;</div><div class="line">  <span class="keyword">self</span>.mac = [[YAMac alloc] init];</div><div class="line">  [<span class="keyword">self</span>.mac show];</div><div class="line">  kLog(<span class="string">@"可以连接到一般的显示器"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div><div class="line">   </div><div class="line"><span class="comment">// 然而.使用方式没有改变</span></div><div class="line">YAMacDVIAdapter *adapter = [[YAMacDVIAdapter alloc] init];</div><div class="line">[adapter dvi];</div></pre></td></tr></table></figure></li></ul><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><ul><li><p>MVC 能使整个应用结构化，使应用的各个部分更易开发测试维护。</p></li><li><p>M是指数据模型，V是指用户界面，C则是控制器。</p></li><li><p>模型对象封装了应用程序的数据，并定义操控和处理该数据的逻辑和运算.视图对象是应用程序中用户可以看见的对象.控制器对象解释在视图对象中进行的用户操作，并将新的或更改过的数据传达给模型对象。</p></li><li><p>Model 和 View 永远不能相互通信，只能通过Controller传递。</p></li><li><p>Controller 与 Model 的通信: Notification 和 KVO。</p></li><li><p>Controller 与 View 的通信:outlet， action， 数据源，代理等。</p></li></ul><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><ul><li><p>MVC升级版</p></li><li><p>ViewController 从 ViewModel 层中读取数据然后显示在View上。</p></li><li><p>ViewController与ViewModel的通信:Block回调和ReactiveCocoa。</p></li><li><p>….// 待补充</p></li></ul><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><ul><li><p>一个代理对象可以代表其他资源。</p></li><li><p>当A对象要监听B对象的一些行为时，A成为B的代理.当B对象要通知A对象一些事情时(消息传递)，A成为B的代理。</p></li><li><p>遵守协议，设置代理，实现方法。</p></li><li><p>实现:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 定义协议</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YACodeDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@required</span></div><div class="line">- (<span class="keyword">void</span>)code;</div><div class="line"><span class="keyword">@end</span></div><div class="line">   </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAMan</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="comment">// 代理属性</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>， <span class="keyword">weak</span>) <span class="keyword">id</span> delegate;</div><div class="line"><span class="keyword">@end</span></div><div class="line">   </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YACoder</span> : <span class="title">NSObject</span> &lt;<span class="title">YACodeDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line">   </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAMan</span></span></div><div class="line">- (<span class="keyword">void</span>)setup &#123;</div><div class="line">  <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(code)]) &#123;</div><div class="line">      <span class="comment">// 告诉代理要做的事</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="keyword">@end</span></div><div class="line">   </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YACoder</span></span></div><div class="line">- (<span class="keyword">void</span>)code &#123;</div><div class="line">  <span class="comment">// 实现必须实现的方法</span></div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="keyword">@end</span></div><div class="line">    </div><div class="line"><span class="comment">// 具体使用时，设置代理</span></div><div class="line">YAMan *man = [[YAMan alloc] init];</div><div class="line">YACoder *coder = [[YACoder alloc] init];</div><div class="line">man.delegate = coder;</div></pre></td></tr></table></figure></li></ul><h1 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h1><ul><li><p>观察者模式定义了一种一对多的依赖关系，让一个或者多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 </p></li><li><p>一个对象需要在不依赖另一个对象的情况下，接收到另一个对象的通知。</p></li><li><p>实现:通知中心.假定A是观察者，B是被观察者。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 在A中</span></div><div class="line"><span class="comment">// 添加自己为观察者，通知产生执行show方法</span></div><div class="line">[[NSNotificationCenter defaultCenter] <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(show) <span class="string">name:</span>@<span class="string">"show"</span> <span class="string">object:</span>nil];</div><div class="line"></div><div class="line"><span class="comment">// 在自己即将销毁的那刻移除通知</span></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">[[NSNotificationCenter defaultCenter] <span class="string">removeObserver:</span>self];</div><div class="line"> &#125; </div><div class="line"> </div><div class="line"><span class="comment">// 在B中，负责适时发送通知</span></div><div class="line"><span class="comment">// 发出通知</span></div><div class="line">[[NSNotificationCenter defaultCenter] <span class="string">postNotificationName:</span>@<span class="string">"show"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>nil];</div></pre></td></tr></table></figure></li></ul><ul><li><p>键值观察(某个属性值改变时通知被观察者)</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 为view的alpha属性添加自己为观察者</span></div><div class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">[view addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"alpha"</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="comment">// 当自身销毁时为view移除观察</span></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    [<span class="keyword">self</span>.view removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"alpha"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当alpha属性改变，就会进入</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>，<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 关于设计模式。 &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.chenyalun.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.chenyalun.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>树与二叉树</title>
    <link href="http://blog.chenyalun.com/2017/01/24/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blog.chenyalun.com/2017/01/24/树与二叉树/</id>
    <published>2017-01-24T08:26:34.000Z</published>
    <updated>2017-04-21T04:43:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017.04.21 更正错误</p></blockquote><p align="center"> 二叉树。 </p><a id="more"></a><h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><p>树形结构是由节点和节点间的联系构成，最重要的特征是:每个节点都只有一个前驱，一个节点可以有多个后继。从一个树形结构里的任意两个节点出发，通过后继关系可达的节点集合:相互之间或者互不相交，或者有子集关系。</p><p>树(tree)是具有递归性质的结构，所以树的定义也是递归的。一棵树是 n (n≥0) 个节点的有限集 T(可为空)，T 非空时满足:有且仅有一个特殊的称为根的节点 r， 根节点外的其余节点划分为m(m ≥ 0)个互不相交的非空有限集。节点个数为 0 的树称为空树。一棵树可以只有根但没有子树(m = 0)，这是一棵单节点的树。</p><p>二叉树是一种树形结构，特点是与每个节点关联的子节点至多有两个(可为 0, 1, 2)。每个节点的子节点关联有位置关系，二叉树的两棵子树分别称作它的(其根的)左子树和右子树。<br>二叉树不是树的特殊情形:<br>1.<strong>其子树分左子树和右子树</strong>，即使只有 一棵子树也要明确说明是左还是右。<br>2.树中结点的最大度数没有限制，而二叉树结点的最大度数为2。<br>3.树的结点个数至少为 1，而二叉树的结点个数可以为 0</p><p>完全二叉树:除最下两层外，其余节点度数都是 2(显然都不是叶节点)，如果最底层的节点不满，则所有空位都在右边，左边没有空位。</p><p>满二叉树:树中每个分支节点(非叶节点)都有两棵非空子树。<br>扩充二叉树(由已有非空二叉树生成的一种二叉树): 是原二叉树的最小节点扩充，使原树中所有节点的度数都变成 2。扩充二叉树新增节点(称为其外部节点)的个数比原树节点(称为其内 部节点)的个数多 1。</p><p>深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。</p><ul><li>边:从父节点到子节点的连线(注意，边有方向)</li><li>兄弟节点:父节点相同的节点互为兄弟节点</li><li>树叶、分支节点:没有子节点的节点称为树叶，树中的其余节点称为分支节点</li><li>度数:一个节点的子节点个数称为该节点的度数，显然树叶的度数为 0</li><li>一棵树的度数就是它里面度数最大的节点的度数</li><li>从一个祖先节点到其子孙节点的一系列边称为树中一条路径</li><li>路径中<strong>边的条数</strong>称为路径长度，认为每个节点到自身有长 0 的路径</li><li>树根到节点的路径长度是该节点的层数</li><li>~~树的高度或深度是树中节点的最大层数(最长路径的长度)加 1(或者说是节点有多少排) ~~  </li><li>树的高度定义为层数最大的叶结点的层数加1</li><li>树的深度定义为层数最大的叶结点的层数(或者说是节点有多少排,深度=层数)</li></ul><p>部分教材定义不同.</p><p>重要!</p><ul><li>一棵深度为k，且有 2^k -1 个节点称之为满二叉树</li><li>一棵深度为k的完全二叉树，最少有 2^(k-1) 个节点，最多有2^k - 1个节点</li><li>对任何一棵二叉树T，如果其终端节点数为 n0 ，度为2的节点数为 n2 ，则 n0 = n2 + 1  </li></ul><h1 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h1><ol><li>非空二叉树第 i 层上至多有 2i 个节点(i ≥ 0)</li><li>高度为 k 的二叉树至多有 2k-1 个节点(k ≥ 0)</li><li>对任何非空二叉树 T，若其叶节点个数为 n0，度数为 2 的节点 个数为 n2，则n0 = n2 + 1</li><li>n个节点的完全二叉树的高度k=⎡log2(n+1)⎤</li><li>满二叉树里的叶节点比分支节点多一个</li></ol><h1 id="二叉树的list实现"><a href="#二叉树的list实现" class="headerlink" title="二叉树的list实现"></a>二叉树的list实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">BTree</span><span class="params">(data,left,right)</span>:</span></div><div class="line"><span class="keyword">return</span> [data,left,right]</div><div class="line"></div><div class="line"><span class="comment">#判断为空</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(btree)</span>:</span></div><div class="line"><span class="keyword">return</span> btree == []</div><div class="line"></div><div class="line"><span class="comment">#返回根(父)节点</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">root</span><span class="params">(btree)</span>:</span></div><div class="line"><span class="keyword">return</span> btree[<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="comment">#返回左节点</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(btree)</span>:</span></div><div class="line"><span class="keyword">return</span> btree[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="comment">#返回右节点</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span><span class="params">(btree)</span>:</span></div><div class="line"><span class="keyword">return</span> btree[<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="comment">#设置根节点</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">setRoot</span><span class="params">(btree,data)</span>:</span></div><div class="line">btree[<span class="number">0</span>] = data</div><div class="line"></div><div class="line"><span class="comment">#设置左节点</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">setLeft</span><span class="params">(btree,data)</span>:</span></div><div class="line">btree[<span class="number">1</span>] = data</div><div class="line"></div><div class="line"><span class="comment">#设置右节点</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">setRight</span><span class="params">(btree,data)</span>:</span></div><div class="line">btree[<span class="number">2</span>] = data</div><div class="line"></div><div class="line">   </div><div class="line">btree = BTree(<span class="number">1</span>,BTree(<span class="number">2</span>,[],[]),BTree(<span class="number">4</span>,[],[]))</div></pre></td></tr></table></figure><h1 id="二叉树的类实现"><a href="#二叉树的类实现" class="headerlink" title="二叉树的类实现"></a>二叉树的类实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">()</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data = <span class="number">0</span>,left = <span class="number">0</span>,right = <span class="number">0</span>)</span>:</span></div><div class="line">self.data = data <span class="comment">#数据域</span></div><div class="line">self.left = left <span class="comment">#左节点</span></div><div class="line">self.right = right <span class="comment">#右节点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinTree</span><span class="params">()</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,root = <span class="number">0</span>)</span>:</span></div><div class="line">self.root = root</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line"><span class="keyword">return</span> self.root == <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">#先序遍历:根左右</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self,treeRoot)</span>:</span></div><div class="line"><span class="keyword">if</span> treeRoot == <span class="number">0</span>:</div><div class="line"><span class="keyword">return</span></div><div class="line">print(treeRoot.data)</div><div class="line">self.preorder(treeRoot.left)</div><div class="line">self.preorder(treeRoot.right)</div><div class="line"></div><div class="line"><span class="comment">#中序遍历:左根右</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self,treeRoot)</span>:</span></div><div class="line"><span class="keyword">if</span> treeRoot == <span class="number">0</span>:</div><div class="line"><span class="keyword">return</span></div><div class="line">self.inorder(treeRoot.left)</div><div class="line">print(treeRoot.data)</div><div class="line">self.inorder(treeRoot.right)</div><div class="line"></div><div class="line"><span class="comment">#后序遍历:左右根</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self,treeRoot)</span>:</span></div><div class="line"><span class="keyword">if</span> treeRoot == <span class="number">0</span>:</div><div class="line"><span class="keyword">return</span></div><div class="line">self.postorder(treeRoot.left)</div><div class="line">self.postorder(treeRoot.right)</div><div class="line">print(treeRoot.data)</div><div class="line"></div><div class="line">tree1 = TreeNode(<span class="number">10</span>)</div><div class="line">tree2 = TreeNode(<span class="number">11</span>)</div><div class="line">tree3 = TreeNode(<span class="number">13</span>,tree1,tree2)</div><div class="line">tree4 = TreeNode(<span class="number">14</span>,tree3)</div><div class="line">tree5 = TreeNode(<span class="number">15</span>,tree4)</div><div class="line">root = TreeNode(<span class="number">17</span>,tree5)</div><div class="line"></div><div class="line">btree2 = BinTree(root)</div><div class="line"></div><div class="line">btree2.preorder(btree2.root)</div><div class="line">btree2.inorder(btree2.root)</div><div class="line">btree2.postorder(btree2.root)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017.04.21 更正错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 二叉树。 &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.chenyalun.com/categories/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/categories/Python/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://blog.chenyalun.com/tags/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://blog.chenyalun.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列的实现</title>
    <link href="http://blog.chenyalun.com/2017/01/22/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.chenyalun.com/2017/01/22/栈与队列的实现/</id>
    <published>2017-01-22T06:06:58.000Z</published>
    <updated>2017-03-15T09:26:30.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 栈与队列。 </p><a id="more"></a><p>栈(stack)，又称堆栈，是一种容器，可存入数据元素、 访问元素、删除元素。</p><p>栈保证任何时刻可以访问、删除的元素都是在此之前最后存入的那个 元素。</p><h1 id="list实现栈"><a href="#list实现栈" class="headerlink" title="list实现栈"></a>list实现栈</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#自定义异常</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackUnderFlow</span><span class="params">(ValueError)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line">    </div><div class="line"><span class="comment">#list开头设置为栈底 list结尾设置为栈顶</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment">#初始化</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.elems = []</div><div class="line"></div><div class="line">    <span class="comment">#判断为空</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.elems == []</div><div class="line"></div><div class="line">    <span class="comment">#返回栈顶元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.isEmpty():</div><div class="line">            <span class="keyword">raise</span> StackUnderFlow</div><div class="line">        <span class="keyword">return</span> self.elems[len(self.elems) - <span class="number">1</span>]</div><div class="line"></div><div class="line">    <span class="comment">#将元素压入栈中</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,data)</span>:</span></div><div class="line">        self.elems.append(data)</div><div class="line"></div><div class="line">    <span class="comment">#弹出栈顶元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.isEmpty():</div><div class="line">            <span class="keyword">raise</span> StackUnderFlow</div><div class="line">        <span class="keyword">return</span> self.elems.pop()</div></pre></td></tr></table></figure><h1 id="链表实现栈"><a href="#链表实现栈" class="headerlink" title="链表实现栈"></a>链表实现栈</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#链表头部设为栈顶,链表尾部设为栈底</span></div><div class="line"><span class="comment">#定义结点:数据域+指针域</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data,nextNode=None)</span>:</span><span class="comment">#缺省函数,指向的下一个结点默认为None</span></div><div class="line">        self.data = data <span class="comment">#当前结点的数据域</span></div><div class="line">        self.next = nextNode <span class="comment">#指向下一个结点</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment">#初始化</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.topNode = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="comment">#判断为空</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.topNode == <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="comment">#返回栈顶元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.isEmpty():</div><div class="line">            <span class="keyword">raise</span> StackUnderFlow</div><div class="line">        <span class="keyword">return</span> self.topNode.data</div><div class="line"></div><div class="line">    <span class="comment">#将元素压入栈中</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,data)</span>:</span></div><div class="line">    self.topNode = Node(data,self.topNode)</div><div class="line"></div><div class="line">    <span class="comment">#弹出栈顶元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    <span class="keyword">raise</span> StackUnderFlow</div><div class="line">    pnode = self.topNode</div><div class="line">    self.topNode = pnode.next</div><div class="line">    <span class="keyword">return</span> pnode.data</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#演练</span></div><div class="line">stack1 = Stack()</div><div class="line"></div><div class="line"><span class="comment">#返回栈顶元素</span></div><div class="line"><span class="comment">#print(stack1.top())</span></div><div class="line"></div><div class="line"><span class="comment">#将元素压入栈中</span></div><div class="line">stack1.push(<span class="number">12</span>)</div><div class="line">stack1.push(<span class="number">11</span>)</div><div class="line">print(stack1.top())</div><div class="line"></div><div class="line"><span class="comment">#弹出栈顶元素</span></div><div class="line">stack1.pop()</div><div class="line">print(stack1.top())</div><div class="line"></div><div class="line"><span class="comment">#判断为空</span></div><div class="line">print(stack1.isEmpty())</div><div class="line"></div><div class="line"></div><div class="line">stack2 = LinkStack()</div><div class="line"></div><div class="line"><span class="comment">#返回栈顶元素</span></div><div class="line"><span class="comment">#print(stack2.top())</span></div><div class="line"></div><div class="line"><span class="comment">#将元素压入栈中</span></div><div class="line">stack2.push(<span class="number">12</span>)</div><div class="line">stack2.push(<span class="number">11</span>)</div><div class="line">print(stack2.top())</div><div class="line"></div><div class="line"><span class="comment">#弹出栈顶元素</span></div><div class="line">stack2.pop()</div><div class="line">print(stack2.top())</div><div class="line"></div><div class="line"><span class="comment">#判断为空</span></div><div class="line">print(stack2.isEmpty())</div></pre></td></tr></table></figure><p>细节:当LinkStack类中含有self.top()方法时,不要再设置self.top重名属性<br>否则报错:object is not callable</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列(queue)，或称为队，也是一种容器<br>可存入数据元素、访问元素、删除元素</p><ul><li>出队操作的一端称为队头</li><li>入队操作的一端称为队尾</li><li>链接表队列的实现，使用链接表即可</li><li>顺序表队列的实现,入队在表尾,出队在表头</li></ul><p>考虑首元素出队后元素不前移，记住新队头位置。<br>这一设计也有问题: 反复入队出队，如果元素存储区固定，一定会在某次入队时出现队<br>尾溢出表尾(表满)的情况<br>出现这种溢出时，顺序表前部通常会有一些空闲位置 这是“假性溢出”，并不是真的用完了整个元素区<br>如果元素存储区自动增长(如 list)，首端将留下越来越大的空区。 而且这片空区永远也不会用到(完全浪费了)</p><ul><li><p>使用环形队列(把数组看作环形)可以解决这个问题</p><figure class="highlight nix"><table><tr><td class="code"><pre><div class="line">q.rear 是最后元素之后空位的下标</div><div class="line">q.head 是首元素的下标</div><div class="line">[q.head, q.rear) 是队列中所有元 素(看作按照环形排列)</div><div class="line">入队时，先存入，后移位</div><div class="line">当队列空: q.<span class="attr">head</span> == q.rear </div><div class="line">当队列满:(q.rear + <span class="number">1</span>) % q.<span class="attr">len</span> == q.head</div><div class="line"></div><div class="line">入队出队时的下标更新语句</div><div class="line">q.<span class="attr">head</span> = (q.head+<span class="number">1</span>) % q.len </div><div class="line">q.<span class="attr">rear</span> = (q.rear + <span class="number">1</span>) % q.len</div></pre></td></tr></table></figure></li></ul><h1 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h1><ul><li>elems引用着队列的元素存储区，是一个list 对象</li><li>len是这个存储区的有效容量(我们并不知道该 list 对象的实际大小)</li><li>head  是队列首元素(当时在队列里的存入最早的那个元素)的下标</li><li>elemNum始终记录着队列中元素的个数</li><li>队列里的元素在 elems 里连续存放，但需要在下标 len 存入元素时，操作改在下标 0 的位置存入</li><li><p>在 elemNum == len 的情况下，入队列操作将自动扩张存储区</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueUnderFlow</span><span class="params">(ValueError)</span>:</span></div><div class="line">  <span class="keyword">pass</span></div><div class="line">   </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">()</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,length = <span class="number">10</span>)</span>:</span></div><div class="line">      self.length = length <span class="comment">#存储区容量</span></div><div class="line">      self.elems = [<span class="number">0</span>] * self.length <span class="comment">#存储数据元素</span></div><div class="line">      self.head = <span class="number">0</span> <span class="comment">#队列首元素</span></div><div class="line">      self.elemNum = <span class="number">0</span> <span class="comment">#队列中元素个数</span></div><div class="line">   </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">      <span class="keyword">return</span> self.elemNum == <span class="number">0</span></div><div class="line">   </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">firstElem</span><span class="params">(self)</span>:</span> <span class="comment">#获取队头元素</span></div><div class="line">      <span class="keyword">if</span> self.isEmpty():</div><div class="line">          <span class="keyword">raise</span> QueueUnderFlow</div><div class="line">      <span class="keyword">return</span> self.elems[self.head]</div><div class="line">   </div><div class="line">  <span class="comment">#出队</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></div><div class="line">      <span class="keyword">if</span> self.isEmpty():</div><div class="line">          <span class="keyword">raise</span> QueueUnderFlow</div><div class="line">      e = self.elems[self.head]</div><div class="line">      self.head = (self.head + <span class="number">1</span>) % self.length</div><div class="line">      self.elemNum -= <span class="number">1</span></div><div class="line">      <span class="keyword">return</span> e</div><div class="line">   </div><div class="line">  <span class="comment">#入队</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self,data)</span>:</span></div><div class="line">      <span class="comment">#检验队列是否已满</span></div><div class="line">      <span class="keyword">if</span> self.elemNum == self.length:</div><div class="line">          self.extend() <span class="comment">#扩张存储区</span></div><div class="line">      self.elems[(self.head + self.elemNum) % self.length] = data</div><div class="line">      self.elemNum += <span class="number">1</span></div><div class="line">   </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extend</span><span class="params">(self)</span>:</span></div><div class="line">      oldLen = self.length</div><div class="line">      self.length *= <span class="number">2</span></div><div class="line">      newElems = [<span class="number">0</span>] * (self.length)</div><div class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(oldLen):</div><div class="line">          newElems[i] = self.elems[(self.head + i) % oldLen]</div><div class="line">      self.elems = newElems</div><div class="line">      self.head = <span class="number">0</span></div><div class="line">   </div><div class="line">   </div><div class="line"><span class="comment"># 演练</span></div><div class="line">queue = Queue()</div><div class="line">   </div><div class="line">queue.enqueue(<span class="number">11</span>)</div><div class="line">queue.enqueue(<span class="number">12</span>)</div><div class="line">queue.enqueue(<span class="number">13</span>)</div><div class="line">   </div><div class="line">print(queue.firstElem())</div><div class="line">   </div><div class="line">queue.dequeue()</div><div class="line">print(queue.firstElem())</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 栈与队列。 &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.chenyalun.com/categories/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/categories/Python/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://blog.chenyalun.com/tags/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="http://blog.chenyalun.com/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://blog.chenyalun.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>朴素算法和KMP算法实现串匹配</title>
    <link href="http://blog.chenyalun.com/2017/01/21/%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95%E5%92%8CKMP%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://blog.chenyalun.com/2017/01/21/朴素算法和KMP算法实现串匹配/</id>
    <published>2017-01-21T01:52:27.000Z</published>
    <updated>2017-03-15T09:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 串匹配。 </p><a id="more"></a><h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><ul><li>长度为 0 的串称为空串</li><li>串中字符的个数称为串的长度 </li><li>s1 和 s2 相等:其长度相等，且对应位置的各字符分别相同</li><li>子串是原串中连续的一段字符序列形成的串</li><li>空串是任何字符串的子串,任何字符串 s 也都是该串本身的子串</li><li>如果存在 s’ 使 s2 = s1 + s’，称 s1 为 s2 的一个前缀 </li><li>如果存在 s 使得 s2 = s + s1，称 s1 为 s2 的一个后缀 </li><li>前缀就是该串开头的一段字符构成的子串</li><li>后缀就是该串后的一段字符构成的子串</li><li>空串既是 s 的前缀，也是 s 的后缀</li><li>串s的n次幂是连续n个s拼接而成的串（在Python语言里用s * n表示）</li><li><code>&quot;==&quot; 与 &quot;is&quot;</code>的区别：<code>&quot;==&quot;</code>是比较内容相当，如变量值相等;<code>&quot;is&quot;</code>是比较对象的id是否相等</li><li>or是从左到有计算表达式，返回第一个为真的值</li><li>and从左到右计算表达式，若所有值均为真，则返回最后一个值，若存在假，返回第一个假值</li><li>在集合中:<code>&amp;求交集 |求并集 -求差集</code></li><li>在数值中:<code>&amp;按位与 |按位或 ^按位异或 ~按位取反</code></li><li>pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li></ul><h1 id="朴素匹配算法"><a href="#朴素匹配算法" class="headerlink" title="朴素匹配算法"></a>朴素匹配算法</h1><h2 id="逐个字符匹配"><a href="#逐个字符匹配" class="headerlink" title="逐个字符匹配"></a>逐个字符匹配</h2><p>t为目标串 p为匹配串</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">naiveMatch1</span><span class="params">(t,p)</span>:</span></div><div class="line">   n,m = len(t),len(p)</div><div class="line">   i,j = <span class="number">0</span>,<span class="number">0</span></div><div class="line">   <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</div><div class="line">       <span class="keyword">if</span> t[i] == p[j]: <span class="comment">#该字符匹配成功,匹配下一个字符</span></div><div class="line">           i += <span class="number">1</span></div><div class="line">           j += <span class="number">1</span></div><div class="line">       <span class="keyword">else</span>:</div><div class="line">           i = i - j + <span class="number">1</span> <span class="comment">#将j恢复至原位置加1</span></div><div class="line">           j = <span class="number">0</span> <span class="comment">#将匹配串复位</span></div><div class="line">   <span class="keyword">if</span> j == m:</div><div class="line">       print(<span class="string">"匹配成功"</span>)</div><div class="line">       <span class="keyword">return</span> i - j <span class="comment">#返回匹配成功的首字符的索引(从0开始)</span></div><div class="line">   print(<span class="string">"匹配失败"</span>)</div><div class="line">   <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure><h2 id="整个串匹配"><a href="#整个串匹配" class="headerlink" title="整个串匹配"></a>整个串匹配</h2><p>(时间复杂度:O(n*m))<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">naiveMatch2</span><span class="params">(t,p)</span>:</span></div><div class="line">   n = len(t)</div><div class="line">   m = len(p)</div><div class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(n-m+<span class="number">1</span>): <span class="comment">#实际上最多移动n-m+1次,而不是n次</span></div><div class="line">       <span class="keyword">if</span> t[i:i+m] == p: <span class="comment">#t串中从i位置开始的连续m个字符与p串比较</span></div><div class="line">           print(<span class="string">"匹配成功"</span>)</div><div class="line">           <span class="keyword">return</span> i <span class="comment">#返回匹配成功的首字符的索引(从0开始)</span></div><div class="line">   print(<span class="string">"匹配失败"</span>)</div><div class="line">   <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure></p><p> 演练</p><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">t = <span class="string">"abcdefghijklmnopqrst"</span></div><div class="line"><span class="selector-tag">p</span> = <span class="string">"opq"</span></div><div class="line">p2 = <span class="string">"opqw"</span></div><div class="line"><span class="function"><span class="title">naiveMatch1</span><span class="params">(t,p)</span></span></div><div class="line"><span class="function"><span class="title">naiveMatch1</span><span class="params">(t,p2)</span></span></div><div class="line"><span class="function"><span class="title">naiveMatch2</span><span class="params">(t,p)</span></span></div><div class="line"><span class="function"><span class="title">naiveMatch2</span><span class="params">(t,p2)</span></span></div></pre></td></tr></table></figure><ul><li>串p从左端对齐,依次向右边移动一位,直至目标串与匹配串完全匹配</li><li>朴素匹配算法简单但是效率低下,主要原因是:</li><li>一旦比较到两个串中有字符不匹配,直接将匹配串整体向右移动一位</li><li>不管不顾前面已经成功匹配的字符</li></ul><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>设法利用已匹配的字符数信息，根据部分匹配表移动多位而不是1位,提高效率</p><h2 id="部分匹配表"><a href="#部分匹配表" class="headerlink" title="部分匹配表"></a>部分匹配表</h2><ul><li>前缀:指除了最后一个字符以外，一个字符串的全部头部组合</li><li>后缀:指除了第一个字符以外，一个字符串的全部尾部组合</li><li>部分匹配值:前缀和后缀的’最长的’共有元素的长度</li><li>如”ABCDAB”的前缀为:[A AB ABC ABCD ABCDA]</li><li>后缀:[BCDAB CDAB DAB AB B]</li><li>共有元素为AB 长度为2</li></ul><p> <strong>假定求取匹配串ABCA的部分匹配值</strong></p><ol><li>A的前缀后缀都为空集,共有元素长度为0</li><li>AB的前缀为[A],后缀为[B],共有元素长度为0</li><li>ABC的前缀为[A AB],后缀为[BC C],共有元素长度为0</li><li>ABCA的前缀为[A AB ABC],后缀为[BCA CA A],共有元素A长度为1</li><li><p>部分匹配表为:</p><p> A B C A<br> 0 0 0 1</p></li></ol><p><strong>移动位数 = 已匹配的字符数 - 对应的部分匹配值</strong></p><h2 id="部分匹配表算法实现"><a href="#部分匹配表算法实现" class="headerlink" title="部分匹配表算法实现"></a>部分匹配表算法实现</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#1.拆分匹配串</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPart</span><span class="params">(p)</span>:</span></div><div class="line">   part = []</div><div class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(p)+<span class="number">1</span>):</div><div class="line">       part.append(p[:i])</div><div class="line">   <span class="keyword">return</span> part</div><div class="line">    </div><div class="line"><span class="comment">#2.根据某串获取其前缀后缀最长共有元素长度</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLength</span><span class="params">(p)</span>:</span></div><div class="line">   prefix = set()</div><div class="line">   suffix = set()</div><div class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(p)):</div><div class="line">       prefix.add(p[:i])</div><div class="line">       suffix.add(p[i:])</div><div class="line">   <span class="comment">#如果交集为空,则返回空串集合&#123;""&#125;的长度0</span></div><div class="line">   <span class="comment">#如果交集不为空,则返回交集中最后一个元素(也即最长元素)的长度</span></div><div class="line">   <span class="keyword">return</span> len((prefix &amp; suffix <span class="keyword">or</span> &#123;<span class="string">""</span>&#125;).pop())</div><div class="line">    </div><div class="line"><span class="comment">#3.获取部分匹配表</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">partialTable1</span><span class="params">(p)</span>:</span></div><div class="line">   result = []</div><div class="line">   <span class="keyword">for</span> elem <span class="keyword">in</span> getPart(p):</div><div class="line">       result.append(getLength(elem))</div><div class="line">   <span class="keyword">return</span> result</div></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#部分匹配表  </span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">partialTable2</span><span class="params">(p)</span>:</span>   </div><div class="line">   prefix = set()  </div><div class="line">   suffix = set()  </div><div class="line">   ret = [<span class="number">0</span>]  <span class="comment">#第一个字符的前缀后缀都为空,共有元素长度是0</span></div><div class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(p)):  </div><div class="line">       prefix.add(p[:i])  </div><div class="line">       suffix = &#123;p[j:i+<span class="number">1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>)&#125; </div><div class="line">       ret.append(len((prefix &amp; suffix <span class="keyword">or</span> &#123;<span class="string">""</span>&#125;).pop())) </div><div class="line">   <span class="keyword">return</span> ret  </div><div class="line">    </div><div class="line">print(partialTable1(<span class="string">"ABCDABDABCDABDABCDABDABCDABDABCDABDABCDABD"</span>))</div><div class="line">print(partialTable2(<span class="string">"ABCDABDABCDABDABCDABDABCDABDABCDABDABCDABD"</span>))</div></pre></td></tr></table></figure><h2 id="KMP核心算法"><a href="#KMP核心算法" class="headerlink" title="KMP核心算法"></a>KMP核心算法</h2><p>必须使用逐个字符匹配,不能使用整个串匹配<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmpMatch</span><span class="params">(t,p)</span>:</span></div><div class="line">   n,m = len(t),len(p)</div><div class="line">   table = partialTable2(p) <span class="comment">#获取匹配串的部分匹配表</span></div><div class="line">   cur = <span class="number">0</span></div><div class="line">   <span class="keyword">while</span> cur &lt;= n - m:</div><div class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">   <span class="keyword">if</span> t[i + cur] != p[i]:</div><div class="line">   cur += max(i - table[i - <span class="number">1</span>],<span class="number">1</span>)</div><div class="line">   <span class="keyword">break</span></div><div class="line">   <span class="keyword">else</span>:</div><div class="line">   print(<span class="string">"匹配成功"</span>)</div><div class="line">   <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">   print(<span class="string">"匹配失败"</span>)</div><div class="line">   <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">   </div><div class="line">    </div><div class="line">kmpMatch(<span class="string">"BBC ABCDAB ABCDABCDABDE"</span>,<span class="string">"ABCDABD"</span>)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 串匹配。 &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.chenyalun.com/categories/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/categories/Python/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://blog.chenyalun.com/tags/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="串匹配" scheme="http://blog.chenyalun.com/tags/%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Python3实现线性表链式存储</title>
    <link href="http://blog.chenyalun.com/2017/01/13/Python3%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <id>http://blog.chenyalun.com/2017/01/13/Python3实现线性表链式存储/</id>
    <published>2017-01-13T09:37:48.000Z</published>
    <updated>2017-03-15T09:13:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017.1.20完善</p></blockquote><p align="center"> 链表。 </p><a id="more"></a><h1 id="线性表之单链表"><a href="#线性表之单链表" class="headerlink" title="线性表之单链表"></a>线性表之单链表</h1><ol><li>线性表的链式存储结构是用一组任意的存储单元存储线性表的元素.</li><li>结点:由指针域和数据域组成</li><li>链表必须从头指针开始存取,头指针指向链表中的第一个结点</li><li>如果头指针指向空(None)则表示链表为空</li><li>一般常用头结点的指针域存储链表中的第一个结点的指针</li><li>线性链表中最后一个结点指向空(None)</li><li>单链表的第一个结点\首结点:self.head.next</li><li>单链表的头结点:self.head  </li><li>在<code>range(a,b)</code>中,a与b相等,如 <code>for i in range(0,0)</code>,循环体不会执行</li></ol><h1 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#定义结点:数据域+指针域</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data,nextNode=None)</span>:</span><span class="comment">#缺省函数,指向的下一个结点默认为None</span></div><div class="line">        self.data = data <span class="comment">#当前结点的数据域</span></div><div class="line">        self.next = nextNode <span class="comment">#指向下一个结点</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#结点的创建</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    linklist = Node(<span class="number">10</span>)</div><div class="line">    pnode = linklist <span class="comment">#使pnode和linklist指向的内容一致,都为第一个结点(非头结点)</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>,<span class="number">18</span>):<span class="comment">#依次创建结点</span></div><div class="line">        pnode.next = Node(i)</div><div class="line">        pnode = pnode.next</div><div class="line">    pnode = linklist <span class="comment">#获取第一个结点,依次遍历数据</span></div><div class="line">    <span class="keyword">while</span> pnode != <span class="keyword">None</span>:<span class="comment">#结点不为空时,打印数据</span></div><div class="line">        print(pnode.data)</div><div class="line">        pnode = pnode.next</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#定义单链表:定义头结点head,指向的第一个结点默认为None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.head = Node(<span class="keyword">None</span>)<span class="comment">#创建头结点</span></div><div class="line">        self.head.next = <span class="keyword">None</span> <span class="comment">#指向的第一个结点为空</span></div><div class="line">    <span class="comment">#判断链表是否为空</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.head.next == <span class="keyword">None</span></div><div class="line">    <span class="comment">#获取链表中结点个数(不含头结点)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span><span class="params">(self)</span>:</span></div><div class="line">        i = <span class="number">0</span></div><div class="line">        pnode = self.head</div><div class="line">        <span class="keyword">while</span> pnode.next != <span class="keyword">None</span>:</div><div class="line">            i += <span class="number">1</span></div><div class="line">            pnode = pnode.next</div><div class="line">        <span class="keyword">return</span> i</div><div class="line">            </div><div class="line"></div><div class="line">    <span class="comment">#在链表首部插入结点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prepend</span><span class="params">(self,data)</span>:</span></div><div class="line">        <span class="comment">#创建一个结点,使其指向链表中第一个结点(原先头结点所指)</span></div><div class="line">        <span class="comment">#再使头结点指向这个新创建的结点</span></div><div class="line">        self.head.next = Node(data,self.head.next)</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#在链表尾部插入结点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self,data)</span>:</span></div><div class="line">        <span class="comment">#若链表为空</span></div><div class="line">        <span class="keyword">if</span> self.head.next == <span class="keyword">None</span>:</div><div class="line">            self.head.next = Node(data)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="comment">#如若链表非空</span></div><div class="line">        pnode = self.head <span class="comment">#获取头结点</span></div><div class="line">        <span class="keyword">while</span> pnode.next != <span class="keyword">None</span>:</div><div class="line">            pnode = pnode.next</div><div class="line">        pnode.next = Node(data) <span class="comment">#此时pnode为最后一个结点</span></div><div class="line"></div><div class="line">        </div><div class="line">    <span class="comment">#在第i个位置插入数据data(从第一个结点算起,不含头结点)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,data,i)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.isEmpty():</div><div class="line">            self.head.next = Node(data)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">elif</span> i &lt; <span class="number">1</span> <span class="keyword">or</span> i &gt; self.getLength()+<span class="number">1</span>:</div><div class="line">            print(<span class="string">"插入位置不合法"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        pnode = self.head</div><div class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>,i):</div><div class="line">            pnode = pnode.next</div><div class="line">        <span class="comment">#创建新结点</span></div><div class="line">        newNode = Node(data)</div><div class="line">        <span class="comment">#此时pnode指向第i-1个位置上的结点</span></div><div class="line">        <span class="comment">#新结点的next指向第i个位置上的结点</span></div><div class="line">        newNode.next = pnode.next</div><div class="line">        <span class="comment">#第i-1个位置上的结点指向新结点</span></div><div class="line">        pnode.next = newNode</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#删除首结点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delFirst</span><span class="params">(self)</span>:</span></div><div class="line">        self.head.next = self.head.next.next<span class="comment">#头结点指向第二个结点即可</span></div><div class="line">    </div><div class="line"></div><div class="line">    <span class="comment">#删除尾结点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delLast</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.head.next == <span class="keyword">None</span>:</div><div class="line">            print(<span class="string">"链表为空"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        pnode = self.head <span class="comment">#获取头结点</span></div><div class="line">        <span class="keyword">while</span> pnode.next.next != <span class="keyword">None</span>:</div><div class="line">            pnode = pnode.next</div><div class="line">        pnode.next = <span class="keyword">None</span> <span class="comment">#将倒数第二个结点的next置空</span></div><div class="line">        </div><div class="line">    </div><div class="line">    <span class="comment">#在第i个位置删除节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delNodeAtIndex</span><span class="params">(self,i)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.isEmpty() <span class="keyword">or</span> i &lt; <span class="number">1</span> <span class="keyword">or</span> i &gt; self.getLength():</div><div class="line">            print(<span class="string">"删除位置不合法"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">elif</span> i == <span class="number">1</span>: <span class="comment">#i等于1的情况</span></div><div class="line">            self.delFirst()</div><div class="line">            <span class="keyword">return</span></div><div class="line">        pnode = self.head</div><div class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>,i):</div><div class="line">            pnode = pnode.next</div><div class="line">        pnode.next = pnode.next.next</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#获取首结点数据</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.head.next == <span class="keyword">None</span>:</div><div class="line">            print(<span class="string">"链表为空"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">return</span> self.head.next.data</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#获取尾结点数据</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">popLast</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.head.next == <span class="keyword">None</span>:</div><div class="line">            print(<span class="string">"链表为空"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        pnode = self.head <span class="comment">#获取头结点</span></div><div class="line">        <span class="keyword">while</span> pnode.next != <span class="keyword">None</span>:</div><div class="line">            pnode = pnode.next</div><div class="line">        <span class="keyword">return</span> pnode.data</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#获取表中所有元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printAllData</span><span class="params">(self)</span>:</span></div><div class="line">        pnode = self.head.next</div><div class="line">        <span class="keyword">while</span> pnode != <span class="keyword">None</span>:</div><div class="line">            print(pnode.data)</div><div class="line">            pnode = pnode.next</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#查找是否存在数据</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self,data)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.isEmpty():</div><div class="line">            <span class="keyword">return</span></div><div class="line">        pnode = self.head</div><div class="line">        <span class="keyword">while</span> pnode.next != <span class="keyword">None</span>:</div><div class="line">            pnode = pnode.next</div><div class="line">            <span class="keyword">if</span> pnode.data == data:</div><div class="line">                print(<span class="string">"存在这样的数据"</span>)</div><div class="line">                <span class="keyword">return</span></div><div class="line">        print(<span class="string">"不存在这样的数据"</span>)</div><div class="line">        <span class="keyword">return</span></div></pre></td></tr></table></figure><p>#演练</p><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">#创建单链表</div><div class="line">linklist2 = LinkList()</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(linklist2.getLength()</span></span>)</div><div class="line"></div><div class="line">#首端插入结点</div><div class="line">linklist2.prepend(<span class="number">23</span>)</div><div class="line">linklist2.prepend(<span class="number">22</span>)</div><div class="line">linklist2.prepend(<span class="number">21</span>)</div><div class="line">linklist2.printAllData()</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"*"</span>*<span class="number">20</span>)</span></span></div><div class="line"></div><div class="line">#拼接结点</div><div class="line">linklist2.append(<span class="number">24</span>)</div><div class="line">linklist2.append(<span class="number">25</span>)</div><div class="line">linklist2.append(<span class="number">26</span>)</div><div class="line">linklist2.printAllData()</div><div class="line"></div><div class="line">#获取首结点数据</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(linklist2.pop()</span></span>)</div><div class="line"></div><div class="line">#获取尾结点数据</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(linklist2.popLast()</span></span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"*"</span>*<span class="number">20</span>)</span></span></div><div class="line"></div><div class="line">#获取结点数量</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(linklist2.getLength()</span></span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"*"</span>*<span class="number">20</span>)</span></span></div><div class="line"></div><div class="line">#删除首结点</div><div class="line">linklist2.delFirst()</div><div class="line">linklist2.delFirst()</div><div class="line">linklist2.printAllData()</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"*"</span>*<span class="number">20</span>)</span></span></div><div class="line"></div><div class="line">#删除尾节点</div><div class="line">linklist2.delLast()</div><div class="line">linklist2.delLast()</div><div class="line">linklist2.printAllData()</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(linklist2.getLength()</span></span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"*"</span>*<span class="number">20</span>)</span></span></div><div class="line"></div><div class="line">#插入结点</div><div class="line">linklist2.insert(<span class="number">32</span>,<span class="number">1</span>)</div><div class="line">linklist2.insert(<span class="number">31</span>,<span class="number">1</span>)</div><div class="line">linklist2.insert(<span class="number">35</span>,<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="selector-id">#linklist2</span>.insert(<span class="number">310</span>,<span class="number">10</span>) #非法数据</div><div class="line">linklist2.printAllData()</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(linklist2.getLength()</span></span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"*"</span>*<span class="number">20</span>)</span></span></div><div class="line"></div><div class="line">#在第i个位置删除</div><div class="line">linklist2.delNodeAtIndex(<span class="number">1</span>)</div><div class="line">linklist2.delNodeAtIndex(<span class="number">4</span>)</div><div class="line">linklist2.delNodeAtIndex(<span class="number">10</span>) #非法数据</div><div class="line">linklist2.printAllData()</div><div class="line"></div><div class="line">#查找数据</div><div class="line">linklist2.find(<span class="number">24</span>)</div><div class="line">linklist2.find(<span class="number">88</span>)#非法数据</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017.1.20完善&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 链表。 &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.chenyalun.com/categories/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/categories/Python/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://blog.chenyalun.com/tags/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://blog.chenyalun.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python3实现线性表顺序存储</title>
    <link href="http://blog.chenyalun.com/2017/01/12/Python3%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/"/>
    <id>http://blog.chenyalun.com/2017/01/12/Python3实现线性表顺序存储/</id>
    <published>2017-01-12T09:41:12.000Z</published>
    <updated>2017-03-15T09:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017.1.13补充时间复杂度</p></blockquote><p align="center"> 顺序表。 </p><a id="more"></a><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ol><li>数据结构是相互之间存在一种或者多种特定关系的数据元素的集合.</li><li>按照逻辑结构分为:集合结构/线性结构/树形结构/图形结构.</li><li>按照物理结构可分为:顺序存储结构和链式存储结构.</li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol><li>输入/输出/确定/有穷/可行.</li><li>解决特定问题求解步骤的描述.</li><li>算法时间复杂度是算法的时间量度,表示随问题规模n的增大,算法执行时间的增长率和f(n)问题规模的某个函数的增长率相同,称作算法的渐近时间复杂度,简称时间复杂度.没有最高阶项,问题的大小与n无关,执行时间恒定的算法为O(1),单纯的分支结构时间复杂度也是O(1).</li><li>常数阶O(1),线性阶O(n),对数阶,平方阶O(m*n)</li><li>循环的时间复杂度 = 循环体的复杂度 * 循环次数</li><li>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n<em> n)&lt;O(n</em> n*n)&lt;O(2的n次)&lt;O(n!)&lt;O(n的n次方)</li></ol><pre><code>int i,j;for(i = 0;i &lt; m;i++) {     for(j = 0;j &lt; n; j++) {     /* 时间复杂度为O(1)的程序步骤序列 */     }}// 时间复杂度为O(m * n)int i,j;for(i = 0;i &lt; n;i++) {     for(j = i;j &lt; n; j++) {     /* 时间复杂度为O(1)的程序步骤序列 */     }}// 总的执行次数n(n+1)/2,时间复杂度为O(n*n)int count = 1;while (count &lt; n) {count = count * 2; /* 时间复杂度为O(1)的程序步骤序列 */ } // 时间复杂度为O(logN)</code></pre><h1 id="线性表之顺序表"><a href="#线性表之顺序表" class="headerlink" title="线性表之顺序表"></a>线性表之顺序表</h1><ol><li>线性表中元素的个数n定义为线性表的长度,n=0时为空表,其长度可以根据需要增长或缩短</li><li><p>特点:<br>存在唯一的一个被称作”第一个”的数据元素<br>存在唯一的一个被称作”最后一个”的数据元素<br>除第一个外,集合中的每一个元素均只有一个前驱<br>除最后一个外,集合中的每一个元素均只有一个后继</p></li><li><p>顺序表:用一组连续的存储单元依次存储线性表的数据元素</p></li><li>顺序表中当前元素的个数:length</li><li>在Python中,数据元素存放在列表中:data[length]<br>其中,len(data) == length</li><li>可以使用表中最后一个数据元素的下标获取当前表长</li><li>也可以直接使用length标记表长</li><li>顺序表的第一个元素的下标为1，数组的下标为0</li><li>在 n 个元素的顺序表里下标 i 处加入元素，需要移动 n - i 个元素;删 除下标为 i 的元素需要移动 n - i - 1个元素</li></ol><h1 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#定义顺序表</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqList</span>:</span></div><div class="line">    <span class="comment"># 1.创建一个指定存储容量的顺序表 newList : int -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,size)</span>:</span></div><div class="line">    self.maxSize = size <span class="comment">#指定的存储容量</span></div><div class="line">    self.data = list(range(size))<span class="comment">#数组存储的初始范围  </span></div><div class="line">    self.length = <span class="number">0</span> <span class="comment">#顺序表的当前长度(元素的个数)</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 2.判断表空?emptyList : List -&gt; bool</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment">#表中没有元素</span></div><div class="line">    <span class="keyword">return</span> self.length == <span class="number">0</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 3.判断表满?fullList : List -&gt; bool</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment">#表中元素个数与指定存储容量一致</span></div><div class="line">    <span class="keyword">return</span> self.length == self.maxSize</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 4.返回表中元素的个数length : List -&gt; integer</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">return</span> self.length</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 5.查找元素在表中首次出现的位置locate : List * Data -&gt; integer</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLocation</span><span class="params">(self,element)</span>:</span></div><div class="line">    <span class="comment">#判断表是否为空</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">    <span class="keyword">if</span> self.data[i] == element:</div><div class="line">    <span class="keyword">return</span> i+<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">#找不到返回-1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 6.取得指定位置的元素getElem : List * int -&gt; Data</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getElementAtIndex</span><span class="params">(self,index)</span>:</span><span class="comment">#index表示位置而不是索引</span></div><div class="line">    <span class="comment">#首先判断表空</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="comment">#其次判断位置是否越界</span></div><div class="line">    <span class="keyword">elif</span> index &gt; self.length <span class="keyword">or</span> index &lt; <span class="number">1</span>:</div><div class="line">    print(<span class="string">"错误!位置越界"</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">    <span class="keyword">return</span> self.data[index<span class="number">-1</span>]</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 5.首端插入prepend : List * Data -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prependElement</span><span class="params">(self,element)</span>:</span></div><div class="line">    <span class="comment">#首先判断顺序表是否已满</span></div><div class="line">    <span class="keyword">if</span> self.isFull():</div><div class="line">    print(<span class="string">"错误!顺序表已满"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="comment">#将所有元素往后移动一位,从最后一位开始,到第一个元素</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.length<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</div><div class="line">    self.data[i+<span class="number">1</span>] = self.data[i]</div><div class="line">    self.data[<span class="number">0</span>] = element</div><div class="line">    self.length += <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 6.尾端插入append : List * Data -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendElement</span><span class="params">(self,element)</span>:</span></div><div class="line">    <span class="comment">#首先判断顺序表是否已满</span></div><div class="line">    <span class="keyword">if</span>  self.isFull():</div><div class="line">    print(<span class="string">"错误!顺序表已满"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    self.data[self.length] = element</div><div class="line">    self.length += <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 7.定位插入insert : List * int * Data -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertElement</span><span class="params">(self,index,element)</span>:</span><span class="comment">#在index位置上插入元素</span></div><div class="line">    <span class="comment">#首先判断顺序表是否已满</span></div><div class="line">    <span class="keyword">if</span>  self.isFull():</div><div class="line">    print(<span class="string">"错误!顺序表已满"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="comment">#其次判断插入位置是否合理</span></div><div class="line">    <span class="keyword">elif</span> index &lt; <span class="number">1</span> <span class="keyword">or</span> index &gt; self.length:</div><div class="line">    print(<span class="string">"错误!插入位置不合理"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.length<span class="number">-1</span>,index<span class="number">-2</span>,<span class="number">-1</span>):</div><div class="line">    self.data[i+<span class="number">1</span>] = self.data[i]</div><div class="line">    self.data[index<span class="number">-1</span>] = element</div><div class="line">    self.length += <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 8.删除首个元素delFront : List -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delFront</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment">#判断是否为空表</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,self.length<span class="number">-1</span>):</div><div class="line">    self.data[i] = self.data[i+<span class="number">1</span>]</div><div class="line">    <span class="keyword">del</span> self.data[self.length<span class="number">-1</span>]</div><div class="line">    self.length -= <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 9.删除末尾元素delEnd : List -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delEnd</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment">#判断是否为空表</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="keyword">del</span> self.data[self.length<span class="number">-1</span>]</div><div class="line">    self.length -= <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 10.定位删除元素delete : List * int -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self,index)</span>:</span></div><div class="line">    <span class="comment">#判断是否为空表</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="comment">#过滤将要删除元素的位置</span></div><div class="line">    <span class="keyword">elif</span> index &lt; <span class="number">1</span> <span class="keyword">or</span> index &gt; self.length:</div><div class="line">    print(<span class="string">"错误!插入位置不合理"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(index<span class="number">-1</span>,self.length):</div><div class="line">    self.data[i] = self.data[i+<span class="number">1</span>]</div><div class="line">    self.length -= <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 11.删除一个数据delElem : List * Data -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delElem</span><span class="params">(self,element)</span>:</span></div><div class="line">    <span class="comment">#判断是否为空表</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">    index = self.getLocation(element) <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> index == <span class="number">-2</span>:</div><div class="line">    print(<span class="string">"没有找到"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">    <span class="keyword">del</span> self.data[index]</div><div class="line">    self.length -= <span class="number">1</span></div><div class="line">    </div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 12.删除所有数据delAllElem : List * Data -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></div><div class="line">    self.length = <span class="number">0</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#演练:</span></div><div class="line">s = SqList(<span class="number">8</span>)</div><div class="line"></div><div class="line"><span class="comment">#表是否为空</span></div><div class="line">print(s.data)</div><div class="line">print(s.isEmpty())</div><div class="line">print(s.isFull())</div><div class="line"></div><div class="line"><span class="comment">#末尾追加元素</span></div><div class="line">s.appendElement(<span class="number">12</span>)</div><div class="line">print(s.data)</div><div class="line">print(s.isEmpty())</div><div class="line">print(s.isFull())</div><div class="line"></div><div class="line"><span class="comment">#首端追加元素</span></div><div class="line">s.prependElement(<span class="number">13</span>)</div><div class="line">print(s.data)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#插入元素</span></div><div class="line">s.insertElement(<span class="number">1</span>,<span class="number">11</span>)</div><div class="line">s.insertElement(<span class="number">2</span>,<span class="number">12</span>)</div><div class="line">s.insertElement(<span class="number">4</span>,<span class="number">14</span>)</div><div class="line">print(s.data)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#获取表中元素个数</span></div><div class="line">print(s.length)</div><div class="line"></div><div class="line"><span class="comment">#获取元素12出现的位置</span></div><div class="line">print(s.getLocation(<span class="number">12</span>))</div><div class="line"></div><div class="line"><span class="comment">#获取第3个位置上的元素</span></div><div class="line">print(s.getElementAtIndex(<span class="number">3</span>))</div><div class="line"></div><div class="line"><span class="comment">#删除首个元素</span></div><div class="line">s.delFront()</div><div class="line">print(s.data)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#删除末尾元素</span></div><div class="line">s.delEnd()</div><div class="line">print(s.data)</div><div class="line"></div><div class="line"><span class="comment">#定位删除元素</span></div><div class="line">s.delete(<span class="number">21</span>) <span class="comment">#错误数据</span></div><div class="line">s.delete(<span class="number">2</span>)</div><div class="line">print(s.data)</div><div class="line"></div><div class="line"><span class="comment">#删除数据</span></div><div class="line">s.delElem(<span class="number">121</span>) <span class="comment">#错误数据</span></div><div class="line">s.delElem(<span class="number">12</span>)</div><div class="line">print(s.data)</div><div class="line"></div><div class="line"><span class="comment">#删除全部元素</span></div><div class="line">s.clear()</div><div class="line">print(s.isEmpty())</div></pre></td></tr></table></figure><h1 id="针对Python3"><a href="#针对Python3" class="headerlink" title="针对Python3"></a>针对Python3</h1><p>Python中已经内置list类型,具备顺序表的特点,拥有的常见函数或者方法可以轻易实现顺序表的相关操作</p><figure class="highlight vim"><table><tr><td class="code"><pre><div class="line">列表包含的函数:</div><div class="line"><span class="built_in">len</span>(<span class="keyword">list</span>) 方法返回列表元素个数。</div><div class="line"><span class="built_in">max</span>(<span class="keyword">list</span>) 方法返回列表元素中的最大值。</div><div class="line"><span class="built_in">min</span>(<span class="keyword">list</span>) 返回列表元素最小值</div><div class="line"><span class="keyword">list</span>(seq) 方法用于将元组转换为列表。</div><div class="line"></div><div class="line">列表包含的方法:</div><div class="line"><span class="keyword">list</span>.<span class="keyword">append</span>(obj)         在列表末尾添加新的对象</div><div class="line"><span class="keyword">list</span>.<span class="built_in">count</span>(obj)          统计某个元素在列表中出现的次数</div><div class="line"><span class="keyword">list</span>.<span class="built_in">extend</span>(seq)         在列表末尾一次性追加另一个序列中的多个值</div><div class="line"><span class="keyword">list</span>.<span class="built_in">index</span>(obj)          从列表中找出某个值第一个匹配项的索引位置</div><div class="line"><span class="keyword">list</span>.<span class="keyword">insert</span>(<span class="built_in">index</span>, obj)  将对象插入列表中的指定位置,<span class="built_in">index</span>指索引</div><div class="line"></div><div class="line"><span class="keyword">list</span>.<span class="keyword">pop</span>(<span class="built_in">index</span>)</div><div class="line">移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</div><div class="line"></div><div class="line"><span class="keyword">list</span>.<span class="built_in">remove</span>(obj)移除列表中某个值的第一个匹配项</div><div class="line"><span class="keyword">list</span>.<span class="built_in">reverse</span>()反向列表中元素</div><div class="line"><span class="keyword">list</span>.<span class="keyword">sort</span>([func])对原列表进行排序</div><div class="line"><span class="keyword">list</span>.clear()清空列表</div><div class="line"><span class="keyword">list</span>.<span class="keyword">copy</span>()复制列表</div></pre></td></tr></table></figure><ul><li>值得注意的是,Python2与Python3的区别</li><li>python2中的range返回的是一个列表</li><li>python3中的range返回的是一个迭代值</li><li><code>for i in range(1,10)</code>在python2和python3中都可以使用，但是要生成1-10的列表，就需要用<code>list(range(1,10))</code></li></ul><h1 id="结合内置方法"><a href="#结合内置方法" class="headerlink" title="结合内置方法"></a>结合内置方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"></div><div class="line"><span class="comment">#定义顺序表</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqList</span>:</span></div><div class="line">    <span class="comment"># 1.创建一个指定存储容量的顺序表 newList : int -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,size)</span>:</span></div><div class="line">    self.maxSize = size <span class="comment">#指定的存储容量</span></div><div class="line">    self.data = list(range(size)) <span class="comment">#数组存储的初始范围</span></div><div class="line">    self.length = <span class="number">0</span> <span class="comment">#顺序表的当前长度(元素的个数)</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 2.判断表空?emptyList : List -&gt; bool</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment">#表中没有元素</span></div><div class="line">    <span class="keyword">return</span> self.length == <span class="number">0</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 3.判断表满?fullList : List -&gt; bool</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment">#表中元素个数与指定存储容量一致</span></div><div class="line">    <span class="keyword">return</span> self.length == self.maxSize</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 4.返回表中元素的个数length : List -&gt; integer</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">return</span> self.length</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 5.查找元素在表中首次出现的位置locate : List * Data -&gt; integer</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLocation</span><span class="params">(self,element)</span>:</span></div><div class="line">    <span class="comment">#判断表是否为空</span></div><div class="line">        <span class="keyword">if</span> self.isEmpty():</div><div class="line">            print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        <span class="keyword">return</span> self.data.index(element) + <span class="number">1</span></div><div class="line">    </div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 6.取得指定位置的元素getElem : List * int -&gt; Data</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getElementAtIndex</span><span class="params">(self,index)</span>:</span><span class="comment">#index表示位置而不是索引</span></div><div class="line">    <span class="comment">#首先判断表空</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="comment">#其次判断位置是否越界</span></div><div class="line">    <span class="keyword">elif</span> index &gt; self.length <span class="keyword">or</span> index &lt; <span class="number">1</span>:</div><div class="line">    print(<span class="string">"错误!位置越界"</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">    <span class="keyword">return</span> self.data[index<span class="number">-1</span>]</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 5.首端插入prepend : List * Data -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prependElement</span><span class="params">(self,element)</span>:</span></div><div class="line">    <span class="comment">#首先判断顺序表是否已满</span></div><div class="line">    <span class="keyword">if</span> self.isFull():</div><div class="line">    print(<span class="string">"错误!顺序表已满"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    self.data.insert(<span class="number">0</span>,element)</div><div class="line">    self.length += <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 6.尾端插入append : List * Data -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendElement</span><span class="params">(self,element)</span>:</span></div><div class="line">    <span class="comment">#首先判断顺序表是否已满</span></div><div class="line">    <span class="keyword">if</span>  self.isFull():</div><div class="line">    print(<span class="string">"错误!顺序表已满"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    self.data.append(element)</div><div class="line">    self.length += <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 7.定位插入insert : List * int * Data -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertElement</span><span class="params">(self,index,element)</span>:</span><span class="comment">#在index位置上插入元素</span></div><div class="line">    <span class="comment">#首先判断顺序表是否已满</span></div><div class="line">    <span class="keyword">if</span>  self.isFull():</div><div class="line">    print(<span class="string">"错误!顺序表已满"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="comment">#其次判断插入位置是否合理</span></div><div class="line">    <span class="keyword">elif</span> index &lt; <span class="number">1</span> <span class="keyword">or</span> index &gt; self.length:</div><div class="line">    print(<span class="string">"错误!插入位置不合理"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">    self.data.insert(index<span class="number">-1</span>,element)</div><div class="line">    self.length += <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 8.删除首个元素delFront : List -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delFront</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment">#判断是否为空表</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    self.data.pop(<span class="number">0</span>)</div><div class="line">    self.length -= <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 9.删除末尾元素delEnd : List -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delEnd</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment">#判断是否为空表</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    self.data.pop()</div><div class="line">    self.length -= <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 10.定位删除元素delete : List * int -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self,index)</span>:</span></div><div class="line">    <span class="comment">#判断是否为空表</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="comment">#过滤将要删除元素的位置</span></div><div class="line">    <span class="keyword">elif</span> index &lt; <span class="number">1</span> <span class="keyword">or</span> index &gt; self.length:</div><div class="line">    print(<span class="string">"错误!删除位置不合理"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    self.data.pop(index<span class="number">-1</span>)</div><div class="line">    self.length -= <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 11.删除一个数据delElem : List * Data -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delElem</span><span class="params">(self,element)</span>:</span></div><div class="line">    <span class="comment">#判断是否为空表</span></div><div class="line">    <span class="keyword">if</span> self.isEmpty():</div><div class="line">    print(<span class="string">"错误!顺序表为空"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">    self.data.remove(element)</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 12.删除所有数据delAllElem : List * Data -&gt; List</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></div><div class="line">    self.length = <span class="number">0</span></div></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用内置方法实现,结合前辈经验,使用<code>list(range(size))</code>初始化列表,初始化后,列表中元素已经成为顺序表的一部分</li><li>顺序表访问元素极其方便,通过索引即可实现,然而插入删除元素却十分费心费力,时间主要耗费在移动元素上面</li><li>含有n个元素的顺序表中,在第i个元素之前,插入一个元素所需要移动元素次数的期望是 n/2</li></ul><p>推导:</p><pre><code>假定当前表长为n,在第1个位置插入需要移动n个元素,第二个位置插入需要移动n-1个元素,以此类推,第n个位置插入需要移动1个元素,第n+1个位置插入需要移动0个元素,一共需要移动的次数为 (0+n)*(1+n)/2  表长为n  则移动元素次数的期望为 (0+n)*(1+n)/2/(n+1)==&gt;n/2</code></pre><ul><li>含有n个元素的顺序表中,删除第i个元素需要移动元素次数的期望是 (n-1)/2</li></ul><p>推导:</p><pre><code>假定当前表长为n,删除第一个元素需要移动元素次数为n-1,删除第二个元素需要移动次数为n-2,以此类推,删除第n-1个元素需要移动元素次数为1,删除第n个元素需要移动元素次数为0,一共需要移动的次数为(0+n-1)n/2表长为n则移动元素次数的期望为 (0+n-1)/2/n==&gt;(n-1)/2</code></pre><ul><li>顺序表实现插入\删除元素的时间复杂度为O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017.1.13补充时间复杂度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 顺序表。 &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.chenyalun.com/categories/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/categories/Python/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://blog.chenyalun.com/tags/Python/"/>
    
      <category term="算法" scheme="http://blog.chenyalun.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="顺序表" scheme="http://blog.chenyalun.com/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python3入门笔记</title>
    <link href="http://blog.chenyalun.com/2016/12/20/Python3%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.chenyalun.com/2016/12/20/Python3入门笔记/</id>
    <published>2016-12-20T10:22:17.000Z</published>
    <updated>2017-04-02T00:51:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017.1.11修改</p></blockquote><p align="center"> 人生苦短,我用Python。 </p><a id="more"></a><h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><ul><li>让Python打印出指定的文字，可以用print()函数，然后把希望打印的文字用单引号或者双引号括起来，但不能混用单引号和双引号</li><li>用exit()退出Python</li><li>在Python交互式命令行下，可以直接输入代码，然后执行，并立刻得到结果。</li><li>直接输入python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。</li><li>print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出,会依次打印每个字符串，遇到逗号“,”会输出一个空格</li><li>Python提供了一个input(“提示文本,可以为空”)，可以让用户输入字符串，并存放到一个变量里。</li><li>以#开头的语句是注释,Python程序是大小写敏感的</li><li>当语句以冒号:结尾时，缩进的语句视为代码块。Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。</li><li>Python还允许用r’’表示’’内部的字符串默认不转义:<code>print(r&#39;\\\n&#39;)</code></li><li>Python允许用<code>’’’…’’’</code>的格式表示多行内容</li><li>一个布尔值只有True、False两种值</li><li>布尔值可以用and、or和not运算。</li><li>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</li><li>在Python中，通常用全部大写的变量名表示常量,事实上仍然是一个变量，Python根本没有任何机制保证不会被改变</li><li>/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数,//称为地板除，两个整数的除法仍然是整数</li><li>Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。</li><li>ASCII编码是1个字节，而Unicode编码通常是2个字节。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。</li><li>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言</li><li>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符</li><li>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示<code>x = b&#39;ABC&#39;</code></li><li>bytes的每个字符都只占用一个字节,以Unicode表示的str通过encode()方法可以编码为指定的bytes,<code>&#39;中文&#39;.encode(&#39;utf-8&#39;)</code>,含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错</li><li>在bytes中，无法显示为ASCII字符的字节，用\x##显示</li><li>如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法</li><li><p>计算str包含多少个字符，可以用len()函数,len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数,<code>len(&#39;中文&#39;)</code></p><pre><code>#!/usr/bin/env python3# -*- coding: utf-8 -*-第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</code></pre><p>字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%</p></li></ul><h1 id="实练"><a href="#实练" class="headerlink" title="实练"></a>实练</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="string">'''</span></div><div class="line">1,代码中有中文必须设置utf-8</div><div class="line">'''</div><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"></div><div class="line"><span class="comment">#2,单行注释,以#开头</span></div><div class="line"><span class="keyword">import</span> time <span class="comment">#引入时间模块</span></div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> calendar,os</div><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"><span class="comment">#爬取数据</span></div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line"><span class="comment">#指定math模块中的sqrt函数</span></div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">当你导入一个模块，Python解析器对模块位置的搜索顺序是：</div><div class="line"></div><div class="line">1.当前目录</div><div class="line">2.如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。</div><div class="line">3.如果都找不到，Python会查看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/</div><div class="line">4.模块搜索路径存储在system模块的sys.path变量中。</div><div class="line">变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。</div><div class="line"></div><div class="line"></div><div class="line">  在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。</div><div class="line">  创建text.py文件,定义相关函数,import text 即可引用自己的模块</div><div class="line">  注意,倘若在text.py中定义并执行相关函数,其他文件引用之后,并不会执行</div><div class="line">  测试函数代码，应该是单独执行text.py文件时才会执行</div><div class="line"></div><div class="line">  from math import *</div><div class="line"></div><div class="line">  可以根据__name__变量的结果能够判断出，是直接执行的python脚本还是被引入执行的，</div><div class="line">  从而能够有选择性的执行测试代码</div><div class="line"> ''' </div><div class="line"></div><div class="line"><span class="comment">#区分文件是主动执行的，还是被调用执行的。</span></div><div class="line">如果当前文件是主动执行的，__name__ 变量的值就是：__main__，</div><div class="line">如果是被导入执行的，则是被导入的文件名</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">print(<span class="string">"是直接执行的py脚本,而非引入"</span>)</div><div class="line"><span class="comment">#3,多行注释,使用3个单引号</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#3,输出,使用print函数,字符串格式化]</span></div><div class="line"><span class="string">'''</span></div><div class="line">%c %s %i %d %u无符号十进制整数</div><div class="line">%o %x十六进制小写 %X十六进制大写 %f</div><div class="line"></div><div class="line">'''</div><div class="line"></div><div class="line">print(<span class="string">"hello world"</span>)</div><div class="line"></div><div class="line">a = <span class="number">12</span></div><div class="line">b = <span class="number">58</span></div><div class="line">c = <span class="string">"swe"</span></div><div class="line">print(<span class="string">"hello %s 这孩子 %s 啊啊啊 %s"</span>%(a,b,c))</div><div class="line"></div><div class="line">print(<span class="string">"sss"</span>,a)</div><div class="line"></div><div class="line"><span class="comment">#4,输入</span></div><div class="line">inputs = input(<span class="string">"请输入数字"</span>)</div><div class="line">print(<span class="string">"您的数字是:%s"</span>%inputs)</div><div class="line"></div><div class="line"><span class="keyword">if</span> inputs == <span class="number">12</span>:</div><div class="line">print(<span class="string">"哈哈哈哈"</span>)</div><div class="line">print(<span class="string">"嘻嘻嘻嘻"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> inputs != <span class="number">12</span>:</div><div class="line">print(<span class="string">"哦哦哦哦"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#5,数据类型</span></div><div class="line"><span class="string">'''</span></div><div class="line">在python中，只要定义了一个变量，而且它有数据，那么它的类型就已经确定了</div><div class="line">可以使用type(变量的名字)，来查看变量的类型:type(a)</div><div class="line">常用的数据类型:</div><div class="line">* Numbers(包括int long float complex)</div><div class="line">* 布尔 True/False</div><div class="line">* String </div><div class="line">* List</div><div class="line">* Tuple(元组)</div><div class="line">* Dictionary</div><div class="line">'''</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#6,标识符</span></div><div class="line"><span class="comment"># 标识符由字符数字下划线组成,没有美元符号,且区分大小写</span></div><div class="line"><span class="comment"># 命名规则:驼峰式或者下划线连接</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#7,运算符</span></div><div class="line"><span class="string">'''</span></div><div class="line">* %取余 3%2</div><div class="line">* **幂 3**2  3的2次方</div><div class="line">* // 取整除</div><div class="line">* / 正常除法,可有余数</div><div class="line">* //=  **/ </div><div class="line">'''</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#8,逻辑运算 and or not</span></div><div class="line"><span class="comment"># 与</span></div><div class="line"><span class="keyword">if</span> inputs == <span class="number">15</span> <span class="keyword">and</span> a == <span class="number">12</span>:</div><div class="line">print(<span class="string">"and"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 或</span></div><div class="line"><span class="keyword">if</span> inputs == <span class="number">15</span> <span class="keyword">or</span> b == <span class="number">58</span>:</div><div class="line">print(<span class="string">"or"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 非</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> a == <span class="number">12</span>:</div><div class="line">print(<span class="string">"not"</span>)</div><div class="line"></div><div class="line"><span class="comment">#9,多重判断 if 与 elif</span></div><div class="line">score = <span class="number">99</span></div><div class="line"><span class="keyword">if</span> score &lt; <span class="number">60</span>:</div><div class="line">print(<span class="string">"不及格"</span>)</div><div class="line"><span class="keyword">elif</span> score &lt;<span class="number">80</span>:</div><div class="line">print(<span class="string">"良好"</span>)</div><div class="line"><span class="keyword">elif</span> score &lt; <span class="number">90</span>:</div><div class="line">print(<span class="string">"不错"</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">print(<span class="string">"优秀"</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#10,if嵌套</span></div><div class="line"><span class="keyword">if</span> a == <span class="number">12</span>:</div><div class="line">print(<span class="string">"a==12"</span>)</div><div class="line"><span class="keyword">if</span> a &gt; <span class="number">12</span>:</div><div class="line">print(<span class="string">"a&gt;12"</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">print(<span class="string">"a&lt;=12"</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">print(<span class="string">"a!=12"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#11,while循环与循环嵌套</span></div><div class="line"><span class="keyword">while</span> a == <span class="number">12</span>:</div><div class="line">print(<span class="string">"你不好"</span>)</div><div class="line">a = <span class="number">13</span></div><div class="line"><span class="keyword">while</span> b == <span class="number">58</span>:</div><div class="line">print(<span class="string">"哈哈哈哈"</span>)</div><div class="line">b = <span class="number">59</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#12,for循环:i从0开始,每次自增1</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</div><div class="line"><span class="keyword">if</span> i == <span class="number">5</span>:</div><div class="line"><span class="keyword">continue</span><span class="comment">#跳过i==5这次</span></div><div class="line">print(<span class="string">'i=%s'</span>%i)</div><div class="line"></div><div class="line"><span class="keyword">if</span> i == <span class="number">10</span>:</div><div class="line">print(<span class="string">"停止break"</span>)</div><div class="line"><span class="keyword">break</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#13,定义函数 print1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print1</span><span class="params">()</span>:</span></div><div class="line">print(<span class="string">"函数"</span>)</div><div class="line">print(<span class="string">"函数"</span>)</div><div class="line"></div><div class="line">print(<span class="string">"函数"</span>)</div><div class="line"></div><div class="line"><span class="comment">#调用函数print1</span></div><div class="line">print1()</div><div class="line"></div><div class="line"><span class="comment">#14,常用函数</span></div><div class="line"><span class="comment">#时间函数import time</span></div><div class="line">t = time.time()<span class="comment">#取出当前时间,以秒为单位的浮点小数</span></div><div class="line">t2 = time.localtime(t)<span class="comment">#取出本地时间</span></div><div class="line">t3 = time.asctime(t2) <span class="comment">#标准格式Fri Jun 10 10:58:53 2016</span></div><div class="line">print(t3)</div><div class="line"></div><div class="line"><span class="comment">#日历函数 import calendar</span></div><div class="line">cal = calendar.month(<span class="number">2016</span>,<span class="number">8</span>)</div><div class="line">print(cal) <span class="comment">#打印日历</span></div><div class="line"></div><div class="line"><span class="comment">#随机数函数 import random</span></div><div class="line">r = random.randint(<span class="number">1</span>,<span class="number">3</span>)<span class="comment">#从1到3范围内的整数,包括1和3</span></div><div class="line">print(r)</div><div class="line"></div><div class="line">r2 = random.randrange(<span class="number">1</span>,<span class="number">25</span>,<span class="number">5</span>)<span class="comment">#从1开始到25结束递增基数为5</span></div><div class="line">print(r2)</div><div class="line"></div><div class="line">r3 = random.uniform(<span class="number">1</span>,<span class="number">5</span>) <span class="comment">#最小值1最大值5,返回浮点数</span></div><div class="line">print(r3)</div><div class="line"></div><div class="line">random.random() <span class="comment">#生成0&lt;=n&lt;=1的浮点数</span></div><div class="line"></div><div class="line"><span class="comment">#15,字符串,相当于字符数组,可以通过下标取出字符,</span></div><div class="line">ss = <span class="string">"qwertyu"</span></div><div class="line">print(ss[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment">#取出下标从1到3 的字符,包括上边界,不包括下边界</span></div><div class="line">print(ss[<span class="number">1</span>:<span class="number">3</span>])</div><div class="line"></div><div class="line"><span class="comment">#从下标2开始 取到最后</span></div><div class="line">print(ss[<span class="number">2</span>:])</div><div class="line"></div><div class="line"><span class="comment">#从下标2开始到下标-2,不包括下标-2</span></div><div class="line">print(ss[<span class="number">2</span>:<span class="number">-2</span>])</div><div class="line"></div><div class="line"><span class="comment">#取出最后4个字符</span></div><div class="line">print(ss[<span class="number">-4</span>:])</div><div class="line"></div><div class="line"><span class="comment">#16,字符串常见操作</span></div><div class="line">sub = <span class="string">"my"</span></div><div class="line">s = <span class="string">"itismyapple"</span></div><div class="line"></div><div class="line"><span class="comment">#查找:检测sub是否在s中:s.find(sub, start=0, end=len(mystr))</span></div><div class="line"><span class="comment">#查找成功返回开始的索引,否则返回-1</span></div><div class="line">s.find(sub)</div><div class="line">re = s.find(sub,<span class="number">1</span>,<span class="number">8</span>)<span class="comment">#从下标1开始查找,到下标为8结束</span></div><div class="line">print(re)</div><div class="line"></div><div class="line">s.index(sub)<span class="comment">#与find相同,只不过没有找到会抛出异常</span></div><div class="line"></div><div class="line"><span class="comment">#返回 在start和end之间(包括) 在 s里面出现的次数</span></div><div class="line">c = s.count(<span class="string">"i"</span>, <span class="number">0</span>,<span class="number">8</span>)</div><div class="line">print(c)</div><div class="line"></div><div class="line"><span class="comment">#把 s 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次.</span></div><div class="line">s.replace(<span class="string">"t"</span>,<span class="string">"d"</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">#以 " " 为分隔符切片 s，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串</span></div><div class="line">s.split(<span class="string">" "</span>,<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="comment">#把字符串的第一个字符大写</span></div><div class="line">s.capitalize()</div><div class="line"></div><div class="line"><span class="comment">#检查字符串是否是以 obj 开头, 是则返回 True，否则返回 False</span></div><div class="line">s.startswith(<span class="string">"i"</span>)</div><div class="line"></div><div class="line"><span class="comment">#检查字符串是否以obj结束，如果是返回True,否则返回 False.</span></div><div class="line">s.endswith(<span class="string">"d"</span>)</div><div class="line"></div><div class="line"><span class="comment">#转换 s 中所有大写字符为小写</span></div><div class="line">s.lower()</div><div class="line"></div><div class="line"><span class="comment">#转换 s 中的小写字母为大写</span></div><div class="line">s.upper()</div><div class="line"></div><div class="line"><span class="comment">#返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</span></div><div class="line">s.ljust(<span class="number">5</span>) <span class="comment">#返回 "itismyapple     "</span></div><div class="line"></div><div class="line"><span class="comment">#返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</span></div><div class="line">s.rjust(<span class="number">5</span>) <span class="comment">#返回"     itismyapple"</span></div><div class="line"></div><div class="line"><span class="comment">#返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</span></div><div class="line"><span class="string">"s"</span>.center(<span class="number">10</span>) <span class="comment">#"    s     "</span></div><div class="line"></div><div class="line"><span class="comment">#删除 s 左边的空格</span></div><div class="line">s.lstrip()</div><div class="line"></div><div class="line"><span class="comment">#删除 s 字符串末尾的空格</span></div><div class="line">s.rstrip()</div><div class="line"></div><div class="line"><span class="comment">#类似于 find()函数，不过是从右边开始查找.</span></div><div class="line"><span class="string">"sieiess"</span>.rfind(<span class="string">"ie"</span>) <span class="comment">#返回3</span></div><div class="line"></div><div class="line"><span class="comment"># 类似于 index()，不过是从右边开始.</span></div><div class="line">s.rindex(<span class="string">"s"</span>)</div><div class="line"></div><div class="line"><span class="comment">#把"asdeeeads"以str分割成三部分,str前，str和str后</span></div><div class="line"><span class="string">"asdeeeads"</span>.partition(<span class="string">"eee"</span>)</div><div class="line"></div><div class="line"><span class="comment">#类似于 partition()函数,不过是从右边开始.</span></div><div class="line"><span class="string">"asdeeeads"</span>.rpartition(<span class="string">"eee"</span>)</div><div class="line"></div><div class="line"><span class="comment">#按照行分隔，返回一个包含各行作为元素的列表</span></div><div class="line"><span class="string">"asas\nds"</span>.splitlines()</div><div class="line"></div><div class="line"><span class="comment">#如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False</span></div><div class="line"><span class="string">"ssd"</span>.isalnum()</div><div class="line"></div><div class="line"><span class="comment">#如果 mystr 所有字符都是字母 则返回 True,否则返回 False</span></div><div class="line"><span class="string">"ssd"</span>.isalpha()</div><div class="line"></div><div class="line"><span class="comment">#如果 mystr 只包含数字则返回 True 否则返回 False.</span></div><div class="line"><span class="string">"232"</span>.isdigit()</div><div class="line"></div><div class="line"><span class="comment">#如果 mystr 中只包含空格，则返回 True，否则返回 False.</span></div><div class="line"><span class="string">" "</span>.isspace()</div><div class="line"></div><div class="line"><span class="comment">#如果 mystr 所有字符都是大写，则返回 True，否则返回 False</span></div><div class="line"><span class="string">"sd"</span>.isupper()</div><div class="line"></div><div class="line"><span class="comment">#mystr 中每个字符后面插入str,构造出一个新的字符串</span></div><div class="line"><span class="string">"sasd"</span>.join(<span class="string">"s"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#17,列表</span></div><div class="line">A = [<span class="string">"ds3s"</span>,<span class="string">"ds4s"</span>,<span class="string">"a4sd"</span>]</div><div class="line">print(A[<span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</div><div class="line">print(a)<span class="comment">#打印每一个元素</span></div><div class="line"></div><div class="line"><span class="comment">#18,列表增加元素</span></div><div class="line">A.append(<span class="string">"asasdad"</span>)</div><div class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</div><div class="line">print(a)<span class="comment">#打印每一个元素</span></div><div class="line"></div><div class="line"><span class="comment">#19,修改</span></div><div class="line">A[<span class="number">0</span>] = <span class="string">"1"</span></div><div class="line"></div><div class="line"><span class="comment">#20,查找</span></div><div class="line"><span class="keyword">if</span> <span class="string">"1"</span> <span class="keyword">in</span> A:</div><div class="line">print(<span class="string">"1存在于a中"</span>)</div><div class="line"><span class="keyword">if</span> <span class="string">"1"</span> <span class="keyword">not</span> <span class="keyword">in</span> A:</div><div class="line">print(<span class="string">"1不存在与a中"</span>)</div><div class="line"></div><div class="line"><span class="comment">#21,删除元素</span></div><div class="line"><span class="string">'''</span></div><div class="line">    del：根据下标进行删除</div><div class="line">    pop：删除最后一个元素</div><div class="line">    remove：根据元素的值进行删除</div><div class="line">'''</div><div class="line"><span class="keyword">del</span> A[<span class="number">0</span>]</div><div class="line">A.pop()</div><div class="line">A.remove(<span class="string">"ds4s"</span>)</div><div class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</div><div class="line">print(a)<span class="comment">#打印每一个元素</span></div><div class="line"></div><div class="line"><span class="comment">#21,统计字符个数</span></div><div class="line">cstr = input(<span class="string">"请输入字符"</span>)</div><div class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cstr:</div><div class="line">print(<span class="string">"%c:%d"</span>%(c,cstr.count(c)))</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#22,字典</span></div><div class="line">info = &#123;<span class="string">"name"</span>:<span class="string">"zhangsan"</span>,<span class="string">"age"</span>:<span class="number">12</span>&#125;</div><div class="line">print(info[<span class="string">"name"</span>])</div><div class="line"><span class="comment">#增加键值对</span></div><div class="line">info[<span class="string">"sex"</span>] = <span class="string">"man"</span></div><div class="line"></div><div class="line"><span class="comment">#删除元素</span></div><div class="line"><span class="keyword">del</span> info[<span class="string">"age"</span>]</div><div class="line"></div><div class="line"><span class="comment">#清空字典</span></div><div class="line">info.clear()</div><div class="line"></div><div class="line"><span class="comment">#删除整个字典</span></div><div class="line"><span class="keyword">del</span> info</div><div class="line"><span class="comment">#注意删除字典和清空字典的区别</span></div><div class="line"></div><div class="line"><span class="comment">#字典常用操作</span></div><div class="line">info2 = &#123;<span class="string">"name"</span>:<span class="string">"zhangsan"</span>,<span class="string">"age"</span>:<span class="number">12</span>&#125;</div><div class="line"><span class="comment">#测量字典中，键值对的个数</span></div><div class="line">len(info2)</div><div class="line"></div><div class="line"><span class="comment">#返回一个包含字典所有KEY的列表</span></div><div class="line">info2.keys()</div><div class="line"></div><div class="line"><span class="comment">#返回一个包含字典所有value的列表</span></div><div class="line">info2.values()</div><div class="line"></div><div class="line"><span class="comment">#返回一个包含所有（键，值）元组的列表</span></div><div class="line">info2.items()</div><div class="line"></div><div class="line"><span class="comment">#if "name" in info2如果key在字典中，返回True，否则返回False</span></div><div class="line"><span class="keyword">if</span> <span class="string">"name"</span> <span class="keyword">in</span> info2:</div><div class="line">print(<span class="string">"存在"</span>)</div><div class="line"></div><div class="line"><span class="comment">#遍历键/值/键值对</span></div><div class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> info2.items():</div><div class="line">print(key,value)</div><div class="line"></div><div class="line"><span class="comment">#23,Python的元组与列表类似，不同之处在于元组的元素不能修改。</span></div><div class="line">也可进行分片 和 连接操作. 元组使用小括号，列表使用方括号。</div><div class="line">atuple = (<span class="string">"as"</span>,<span class="number">121</span>,<span class="keyword">True</span>,<span class="keyword">False</span>,<span class="number">0</span>)</div><div class="line">atuple2 = (<span class="string">"a"</span>,<span class="number">121</span>,<span class="keyword">True</span>,<span class="keyword">False</span>,<span class="number">40</span>)</div><div class="line">print(atuple[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment">#合成新元组</span></div><div class="line">atuple3 = atuple + atuple2</div><div class="line"></div><div class="line"><span class="comment">#删除元素</span></div><div class="line"><span class="comment">#元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组</span></div><div class="line"><span class="keyword">del</span> atuple3</div><div class="line"></div><div class="line"><span class="comment">#24,元组运算符</span></div><div class="line"><span class="comment">#与字符串一样，元组之间可以使用 + 号和 * 号进行运算。</span></div><div class="line">这就意味着他们可以组合和复制，运算后会生成一个新的元组。</div><div class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) + (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line">[<span class="string">'Hi!'</span>] * <span class="number">4</span> <span class="comment">#['Hi!', 'Hi!', 'Hi!', 'Hi!']</span></div><div class="line"><span class="number">3</span> <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">#True</span></div><div class="line"></div><div class="line"><span class="comment">#25,元组索引截取</span></div><div class="line"><span class="comment">#因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素</span></div><div class="line"><span class="comment">#比较两个元组元素。</span></div><div class="line"></div><div class="line"><span class="comment">#cmp(tuple1, tuple2)</span></div><div class="line">tuple2 = (<span class="number">12</span>,<span class="number">234</span>,<span class="number">546</span>,<span class="number">56</span>)</div><div class="line">tuple2s = [<span class="number">12</span>,<span class="number">23</span>]</div><div class="line"><span class="comment">#计算元组元素个数。</span></div><div class="line">len(tuple2)</div><div class="line"><span class="comment">#返回元组中元素最大值。</span></div><div class="line">max(tuple2)</div><div class="line"><span class="comment">#返回元组中元素最小值。</span></div><div class="line">min(tuple2)</div><div class="line"><span class="comment">#将列表转换为元组。</span></div><div class="line">tuple(tuple2s)</div><div class="line"></div><div class="line"><span class="comment">#25,多维元组</span></div><div class="line">tuple3 = [(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>)]</div><div class="line">tuple3[<span class="number">1</span>] <span class="comment">#(2,5,6)</span></div><div class="line">tuple3[<span class="number">1</span>][<span class="number">0</span>] <span class="comment">#2</span></div><div class="line"></div><div class="line"><span class="comment">#26,带有参数和有返回值的函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a,b)</span>:</span></div><div class="line"><span class="keyword">return</span> a+b</div><div class="line"></div><div class="line">print(sum(<span class="number">45</span>,<span class="number">1</span>))</div><div class="line"></div><div class="line"><span class="comment">#27,缺省函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">(a,b = <span class="number">25</span>)</span>:</span></div><div class="line"><span class="keyword">return</span> a+b</div><div class="line">print(sum2(<span class="number">232</span>))</div><div class="line">print(sum2(<span class="number">232</span>,<span class="number">1</span>))</div><div class="line"></div><div class="line"><span class="comment">#28,不定长参数</span></div><div class="line"><span class="comment">#加了星号（*）的变量名会存放所有未命名的变量参数。</span></div><div class="line"><span class="comment">#参数以一个＊号开头的代表着一个任意长度的元组(tuple)，可以接收连续一串参数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">(a,b,*cs)</span>:</span></div><div class="line">print(a,b)</div><div class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cs:</div><div class="line">print(c)</div><div class="line">printinfo(<span class="number">23</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#29,函数的嵌套使用</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print3</span><span class="params">(a,b)</span>:</span></div><div class="line">print(a,b)</div><div class="line">print(sum(a,b))</div><div class="line">print3(<span class="number">2</span>,<span class="number">23</span>)</div><div class="line"></div><div class="line"><span class="comment">#30,打印指定条横线</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printline</span><span class="params">()</span>:</span></div><div class="line">print(<span class="string">"-"</span>*<span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printlinewithnum</span><span class="params">(a)</span>:</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(a):</div><div class="line">printline()</div><div class="line">print(<span class="string">"\n"</span>)</div><div class="line"></div><div class="line">printlinewithnum(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="comment">#31,变量</span></div><div class="line"><span class="comment">#局部变量,是在函数内部定义的变量</span></div><div class="line"><span class="comment">#全局变量,能在某一函数中使用,也能在其他函数中使用</span></div><div class="line"><span class="comment">#全局变量能够在所有的函数中进行访问</span></div><div class="line"><span class="comment">#如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错</span></div><div class="line">gol = <span class="number">12</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">chnum</span><span class="params">()</span>:</span></div><div class="line"><span class="keyword">global</span> gol <span class="comment">#声明此处的gol是特指全局变量,而非重名的局部变量</span></div><div class="line">gol = <span class="number">13</span></div><div class="line">print(gol)</div><div class="line">chnum()</div><div class="line">print(gol)</div><div class="line"></div><div class="line"><span class="comment">#32,递归函数,一个函数在内部调用自己</span></div><div class="line"><span class="comment">#示例:计算n的阶乘</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calnum</span><span class="params">(n)</span>:</span></div><div class="line">i = <span class="number">1</span></div><div class="line">result = <span class="number">1</span></div><div class="line"><span class="keyword">while</span> i &lt;= n:</div><div class="line">result *= i</div><div class="line">i += <span class="number">1</span></div><div class="line"><span class="keyword">return</span> result</div><div class="line">print(calnum(<span class="number">1</span>))</div><div class="line">print(calnum(<span class="number">0</span>))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calnum2</span><span class="params">(n)</span>:</span></div><div class="line"><span class="keyword">if</span> n &gt;= <span class="number">1</span>:</div><div class="line"><span class="keyword">return</span> n * calnum2(n<span class="number">-1</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line"><span class="keyword">return</span> <span class="number">1</span></div><div class="line">print(calnum2(<span class="number">1</span>))</div><div class="line">print(calnum2(<span class="number">0</span>))</div><div class="line"></div><div class="line"><span class="comment">#33,匿名函数</span></div><div class="line"><span class="comment">#用lambda关键词能创建小型匿名函数。</span></div><div class="line"><span class="comment">#Lambda函数能接收任何数量的参数但只能返回一个表达式的值</span></div><div class="line"><span class="comment">#匿名函数不能直接调用print，因为lambda需要一个表达式</span></div><div class="line">sum4 = <span class="keyword">lambda</span> a,b,c,d:a + b + c + d</div><div class="line">print(sum4(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>))</div><div class="line"></div><div class="line"><span class="comment">#34,位运算:直接操作二进制数</span></div><div class="line"><span class="string">'''</span></div><div class="line">&amp; 按位与 只有对应的两个二进位均为1时,结果位才为1</div><div class="line">| 按位或 只要对应的二个二进位有一个为1时,结果位就为1,否则为0</div><div class="line">^ 按位异或 不同为1 当对应的二进位相异(不相同)时,结果为1,否则为0</div><div class="line">~ 按位取反</div><div class="line">&lt;&lt; 按位左移:左移一位即乘以2,可能改变一个数的正负</div><div class="line">&gt;&gt; 按位右移::右移一位即除以2</div><div class="line">'''</div><div class="line"><span class="number">0b1011</span> &amp; <span class="number">0b1001010110</span></div><div class="line"><span class="number">0b1000110</span> | <span class="number">0b10010</span></div><div class="line"><span class="number">0b11101</span> ^ <span class="number">0b110000011</span></div><div class="line">~<span class="number">132</span></div><div class="line">print(<span class="number">12</span>&lt;&lt;<span class="number">3</span>)</div><div class="line">print(<span class="number">1024</span>&gt;&gt;<span class="number">4</span>)</div><div class="line"><span class="comment">#进制书写</span></div><div class="line"><span class="number">0o377</span> <span class="comment">#八进制</span></div><div class="line"><span class="number">0xFF</span> <span class="comment">#十六进制</span></div><div class="line"><span class="number">0b010010110</span> <span class="comment">#二进制</span></div><div class="line"></div><div class="line"><span class="comment">#进制转换</span></div><div class="line">print(type(oct(<span class="number">25</span>))) <span class="comment">#转八进制字符串</span></div><div class="line">hex(<span class="number">25</span>) <span class="comment">#转十六进制字符串</span></div><div class="line">bin(<span class="number">25</span>) <span class="comment">#转二进制字符串</span></div><div class="line"></div><div class="line"><span class="comment">#35,数据类型转换</span></div><div class="line">int(<span class="string">"123"</span>) <span class="comment">#字符串转数值</span></div><div class="line">float(<span class="string">"2324.3"</span>) <span class="comment">#将字符串转换为浮点数</span></div><div class="line">print(complex(<span class="number">1.2</span>,<span class="number">3.2</span>)) <span class="comment">#创建一个复数,在 Python 中，复数的虚部被表示为 j</span></div><div class="line">print(<span class="number">3.2</span>+<span class="number">1.4j</span>)</div><div class="line"></div><div class="line">print(str(<span class="number">23</span>)) <span class="comment">#将23转换为字符串</span></div><div class="line">print(repr(<span class="number">124</span>)) <span class="comment">#转换为表达式字符串</span></div><div class="line">tuple([<span class="number">23</span>,<span class="number">3</span>])</div><div class="line">list((<span class="number">23</span>,<span class="number">234</span>))</div><div class="line">chr(<span class="number">2</span>)</div><div class="line">ord(<span class="string">"d"</span>)</div><div class="line"></div><div class="line"><span class="comment">#35,实现乘法表</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print6</span><span class="params">()</span>:</span></div><div class="line">i = <span class="number">1</span></div><div class="line"><span class="keyword">while</span> i &lt;= <span class="number">9</span>:</div><div class="line">j = i</div><div class="line"><span class="keyword">while</span> j &lt;= <span class="number">9</span>:</div><div class="line">print(<span class="string">"%d*%d=%d"</span>%(i,j,i*j))</div><div class="line">j += <span class="number">1</span></div><div class="line">i += <span class="number">1</span></div><div class="line"></div><div class="line">print6()</div><div class="line"></div><div class="line"><span class="comment">#36,打开文件</span></div><div class="line"><span class="comment">#使用open函数，可以打开一个已经存在的文件，或者创建一个新文件</span></div><div class="line"><span class="comment">#open(文件名，访问模式) 返回文件句柄</span></div><div class="line">f = open(<span class="string">"s.txt"</span>,<span class="string">"w"</span>)</div><div class="line">f.close()<span class="comment">#关闭文件</span></div><div class="line"><span class="string">'''</span></div><div class="line">r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</div><div class="line">w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><div class="line">a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。</div><div class="line">也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</div><div class="line"></div><div class="line">rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</div><div class="line"></div><div class="line">wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。</div><div class="line">如果该文件不存在，创建新文件。</div><div class="line"></div><div class="line">ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。</div><div class="line">也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</div><div class="line"></div><div class="line">r+ 打开一个文件用于读写。文件指针将会放在文件的开头。</div><div class="line">w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><div class="line"></div><div class="line">a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。</div><div class="line">文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</div><div class="line">rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</div><div class="line">wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</div><div class="line"></div><div class="line">ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。</div><div class="line">如果该文件不存在，创建新文件用于读写。</div><div class="line">'''</div><div class="line"></div><div class="line"><span class="comment">#37,写数据到文件</span></div><div class="line">f = open(<span class="string">"s1"</span>,<span class="string">"w"</span>)</div><div class="line">f.write(<span class="string">"hello world"</span>)</div><div class="line">f.close()</div><div class="line"></div><div class="line"><span class="comment">#38,读数据</span></div><div class="line">f = open(<span class="string">"s1"</span>)</div><div class="line">content = f.read(<span class="number">5</span>) <span class="comment">#读取数据长度,字节为单位</span></div><div class="line">print(content)</div><div class="line">f.close()</div><div class="line"></div><div class="line"><span class="comment">#readlines按照行的方式把整个文件中的内容进行一次性读取，返回的是一个列表，每一行的数据为一个元素</span></div><div class="line">f = open(<span class="string">"s"</span>)</div><div class="line">content2 = f.readlines()</div><div class="line">print(content2[<span class="number">2</span>])</div><div class="line">f.close()</div><div class="line"></div><div class="line"><span class="comment">#38,获取当前读写的位置</span></div><div class="line">f = open(<span class="string">"222.txt"</span>, <span class="string">"r+"</span>)</div><div class="line">f.write(<span class="string">"123243454566"</span>)</div><div class="line">str12 = f.read(<span class="number">3</span>)</div><div class="line">print(<span class="string">"读取的数据是 : "</span>,str12)</div><div class="line"></div><div class="line"><span class="comment"># 查找当前位置</span></div><div class="line">position = f.tell()</div><div class="line">print(<span class="string">"当前文件位置 : "</span>, position)</div><div class="line">f.close()</div><div class="line"><span class="comment">#如果在读写文件的过程中，需要从另外一个位置进行操作的话，可以使用seek()</span></div><div class="line"><span class="string">'''</span></div><div class="line">seek(offset, from)有2个参数</div><div class="line"></div><div class="line">    offset:偏移量</div><div class="line">    from:方向</div><div class="line">        0:表示文件开头</div><div class="line">        1:表示当前位置</div><div class="line">        2:表示文件末尾</div><div class="line"></div><div class="line">'''</div><div class="line">f = open(<span class="string">"s"</span>, <span class="string">"r"</span>)</div><div class="line">str33 = f.read(<span class="number">30</span>)</div><div class="line">print(<span class="string">"读取的数据是 : "</span>, str33)</div><div class="line"></div><div class="line"><span class="comment"># 查找当前位置</span></div><div class="line">position = f.tell()</div><div class="line">print(<span class="string">"当前文件位置 : "</span>, position)</div><div class="line"></div><div class="line"><span class="comment"># 重新设置位置</span></div><div class="line">f.seek(<span class="number">5</span>,<span class="number">0</span>)</div><div class="line">f.close()</div><div class="line"></div><div class="line"><span class="comment">#39,文件操作</span></div><div class="line"><span class="comment">#文件重命名</span></div><div class="line"><span class="comment">#需要import os</span></div><div class="line"><span class="string">'''</span></div><div class="line">#os模块中的rename()可以完成对文件的重命名操作</div><div class="line">os.rename("s1","s111")</div><div class="line"></div><div class="line">#删除文件</div><div class="line">os.remove("s111")</div><div class="line"></div><div class="line">#创建文件夹</div><div class="line">os.mkdir("haha")</div><div class="line"></div><div class="line">#获取当前目录</div><div class="line">print(os.getcwd())</div><div class="line"></div><div class="line">#改变默认目录</div><div class="line">os.chdir("../")</div><div class="line"></div><div class="line">#获取目录中内容列表,返回数组</div><div class="line">os.listdir("./")</div><div class="line"></div><div class="line">#删除文件夹</div><div class="line">os.rmdir("haha")</div><div class="line"></div><div class="line">#判断是否是目录</div><div class="line">os.path.isdir("./react")</div><div class="line"></div><div class="line">#判断是否是文件</div><div class="line">os.path.isfile("./s")</div><div class="line">'''</div><div class="line"><span class="comment">#40,捕获异常</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">open(<span class="string">"ssss"</span>,<span class="string">"r"</span>)</div><div class="line"><span class="comment">#指定异常类型 定义异常变量</span></div><div class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> errmsg:</div><div class="line">print(<span class="string">"捕获到异常"</span>,errmsg)</div><div class="line">print(<span class="string">"-"</span>*<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="comment">#多个异常</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">open(<span class="string">"ssss"</span>,<span class="string">"r"</span>)</div><div class="line"><span class="comment">#指定异常类型 定义异常变量</span></div><div class="line"><span class="keyword">except</span> (IOError,NameError) <span class="keyword">as</span> errmsg:</div><div class="line">print(<span class="string">"捕获到异常"</span>,errmsg)</div><div class="line">print(<span class="string">"-"</span>*<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="comment">#不指定异常</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">open(<span class="string">"ssss"</span>,<span class="string">"r"</span>)</div><div class="line"><span class="comment">#指定异常类型 定义异常变量</span></div><div class="line"><span class="keyword">except</span> :</div><div class="line">print(<span class="string">"捕获到异常"</span>)</div><div class="line">print(<span class="string">"-"</span>*<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">常见异常：</div><div class="line"></div><div class="line">Exception           所有异常的基类</div><div class="line"></div><div class="line">AttributeError      特性应用或赋值失败时引发</div><div class="line"></div><div class="line">IOError             试图打开不存在的文件时引发</div><div class="line"></div><div class="line">IndexError          在使用序列中不存在的索引时引发</div><div class="line"></div><div class="line">KeyError            在使用映射不存在的键时引发</div><div class="line"></div><div class="line">NameError           在找不到名字（变量）时引发</div><div class="line"></div><div class="line">SyntaxError         在代码为错误形式时引发</div><div class="line"></div><div class="line">TypeError          在内建操作或者函数应用于错误类型的对象是引发</div><div class="line"></div><div class="line">ValueError:       </div><div class="line">在内建操作或者函数应用于正确类型的对象，但是该对象使用不合适的值时引发</div><div class="line"></div><div class="line">ZeroDivisionError  在除法或者模除操作的第二个参数为0时引发</div><div class="line">'''</div><div class="line"><span class="comment">#finally语句</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">open(<span class="string">"ssss"</span>,<span class="string">"r"</span>)</div><div class="line"><span class="comment">#指定异常类型 定义异常变量</span></div><div class="line"><span class="keyword">except</span> :</div><div class="line">print(<span class="string">"捕获到异常"</span>)</div><div class="line">print(<span class="string">"-"</span>*<span class="number">10</span>)</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">print(<span class="string">"一定执行的语句"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#else应用</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    num = <span class="number">100</span></div><div class="line">    print(num)</div><div class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> errorMsg:</div><div class="line">        print(<span class="string">'产生错误了:%s'</span>%errorMsg)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'没有捕获到异常，真高兴'</span>)</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">        print(<span class="string">'我一定会执行的哦'</span>)</div><div class="line"></div><div class="line"><span class="comment">#41,定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line"></div><div class="line"><span class="comment">#属性列表</span></div><div class="line"><span class="comment">#公有属性</span></div><div class="line">name = <span class="string">"AB"</span></div><div class="line"></div><div class="line"><span class="comment">#私有属性,私有属性是不能够在类外通过对象名来进行访问的</span></div><div class="line">__age = <span class="number">20</span></div><div class="line"></div><div class="line"><span class="comment">#在类中定义的方法至少会有一个参数，，一般以名为self的变量作为该参数，而且需要作为第一个参数。</span></div><div class="line"><span class="comment">#公有方法列表</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getName</span><span class="params">(self)</span>:</span></div><div class="line">print(self.name)</div><div class="line"></div><div class="line"><span class="comment">#私有方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getAge</span><span class="params">(self)</span>:</span></div><div class="line">print(self.__age)</div><div class="line"></div><div class="line"><span class="comment">#def get():报错</span></div><div class="line"><span class="comment">#print("无参数方法")</span></div><div class="line"></div><div class="line"><span class="comment">#构造器方法:在创建对象后执行</span></div><div class="line"><span class="comment">#def __init__():</span></div><div class="line"><span class="comment">#self.name = "QWE"</span></div><div class="line"></div><div class="line"><span class="comment">#传递参数的构造器方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></div><div class="line">self.name = name</div><div class="line"></div><div class="line"><span class="comment">#析构方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line">print(<span class="string">"析构方法被调用"</span>)</div><div class="line"></div><div class="line"><span class="comment">#创建对象</span></div><div class="line">p = Person(<span class="string">"zhangsan"</span>)</div><div class="line">print(p.name)</div><div class="line">p.getName()</div><div class="line"></div><div class="line"><span class="comment"># 提示找不到该属性p.__age</span></div><div class="line"><span class="comment"># 提示找不到该方法p.__getAge()</span></div><div class="line"><span class="comment">#self是对象自身的意思，在用某个对象调用该方法时，就将该对象作为第一个参数传递给self。</span></div><div class="line"></div><div class="line"><span class="keyword">del</span> p</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#42,继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">setName</span><span class="params">(self,name)</span>:</span></div><div class="line">self.name = name</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></div><div class="line">print(<span class="string">"学生的姓名是"</span>,self.name)</div><div class="line"></div><div class="line">stu = Student(<span class="string">"zhangsan"</span>)</div><div class="line">stu.setName(<span class="string">"李四"</span>)</div><div class="line">stu.print()</div><div class="line"></div><div class="line"><span class="comment">#  python中是可以多继承的</span></div><div class="line"><span class="comment">#  父类中的方法、属性，子类会继承</span></div><div class="line"><span class="comment">#  多继承:class HighStudent(Student,Worker)</span></div><div class="line"><span class="comment"># 假设A,B中都有方法test()</span></div><div class="line"><span class="comment">#若C继承A与B class C(A,B)  则调用A中的方法</span></div><div class="line"><span class="comment">#若C继承A与B class C(B,A)  则调用B中的方法</span></div><div class="line"><span class="comment">#若C继承A与B class C(A,B)  且C中也有test()方法,则调用C中重写的方法</span></div><div class="line"></div><div class="line"><span class="comment">#43,重写</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ani</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></div><div class="line">print(<span class="string">"调用Ani的方法"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Ani)</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></div><div class="line">print(<span class="string">"调用Dog的方法"</span>)</div><div class="line"></div><div class="line"></div><div class="line">dog = Dog()</div><div class="line">dog.print() <span class="comment">#调用自己的方法</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#44,多态</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line"><span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span><span class="params">(A)</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></div><div class="line">print(<span class="string">"A1"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span><span class="params">(A)</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></div><div class="line">print(<span class="string">"A2"</span>)</div><div class="line"></div><div class="line">a1 = A1()</div><div class="line">a2 = A2()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">showFunc</span><span class="params">(a)</span>:</span></div><div class="line">a.show()</div><div class="line"></div><div class="line">showFunc(a1)</div><div class="line">showFunc(a2)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#45,类属性</span></div><div class="line"><span class="comment">#类属性就是类对象所拥有的属性，它被所有类对象的实例对象所共有，</span></div><div class="line"><span class="comment">#内存中只存在一个副本，对于公有的类属性，在类外可以通过类对象和实例对象访问</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">object</span>:</span></div><div class="line">name = <span class="string">"object"</span></div><div class="line"></div><div class="line">obj1 = object()</div><div class="line">obj2 = object()</div><div class="line">print(obj1.name) <span class="comment">#实例没有name,会查找类的name,结果:object</span></div><div class="line">object.name = <span class="string">"lisi"</span></div><div class="line">print(obj2.name) <span class="comment">#显示 lisi</span></div><div class="line">print(obj1.name) <span class="comment">#显示 lisi</span></div><div class="line"></div><div class="line"><span class="comment">#给实例obj1增加实例属性</span></div><div class="line">obj1.name = <span class="string">"ads"</span></div><div class="line">print(obj1.name) <span class="comment">#屏蔽掉类属性,显示ads</span></div><div class="line">print(object.name) <span class="comment">#显示 lisi</span></div><div class="line"></div><div class="line"><span class="comment">#结论:</span></div><div class="line"><span class="comment">#相同名称的实例属性将屏蔽掉类属性</span></div><div class="line"><span class="comment">#但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</span></div><div class="line"><span class="comment">#Python是动态语言,可以动态增加属性</span></div><div class="line"><span class="comment">#想要修改类属性，如果在类外，可以通过类对象修改，如果在类里面，只有在类方法中进行修改。</span></div><div class="line"></div><div class="line"><span class="comment">#46,类方法</span></div><div class="line"><span class="string">'''</span></div><div class="line">是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法</div><div class="line">对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数</div><div class="line">当然可以用其他名称的变量作为其第一个参数.</div><div class="line">但是大部分人都习惯以'cls'作为第一个参数的名字，就最好用'cls'了</div><div class="line">能够通过实例对象和类对象去访问。</div><div class="line">'''</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></div><div class="line">    country = <span class="string">'china'</span></div><div class="line"></div><div class="line">    <span class="comment">#类方法，用classmethod来进行修饰</span></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCountry</span><span class="params">(cls)</span>:</span></div><div class="line">        <span class="keyword">return</span> cls.country</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></div><div class="line">    <span class="comment">#类属性</span></div><div class="line">    price = <span class="string">"1000"</span></div><div class="line"></div><div class="line"><span class="comment">#类方法</span></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPrice</span><span class="params">(cls,price)</span>:</span></div><div class="line">        cls.price = price</div><div class="line">        <span class="keyword">return</span> cls.price</div><div class="line"></div><div class="line">car1 = Car()</div><div class="line">print(car1.getPrice(<span class="number">200</span>))</div><div class="line"></div><div class="line"><span class="comment">#47,静态方法</span></div><div class="line"><span class="comment">#通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line">name = <span class="string">"Tom"</span></div><div class="line"></div><div class="line"><span class="meta">@staticmethod</span></div><div class="line"><span class="comment">#静态方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getName</span><span class="params">()</span>:</span></div><div class="line">print(Cat.name)</div><div class="line"></div><div class="line">Cat.getName()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#48,爬取数据</span></div><div class="line">response = urllib.request.urlopen(<span class="string">"http://acm.hit.edu.cn"</span>)</div><div class="line">html = response.read()</div><div class="line"><span class="comment">#中文转码</span></div><div class="line">htmlC = html.decode(<span class="string">"utf-8"</span>)</div><div class="line">print(htmlC)</div><div class="line"></div><div class="line"><span class="comment">#将网页存入文本</span></div><div class="line">f = open(<span class="string">"t.html"</span>,<span class="string">"wb"</span>)<span class="comment">#python是types格式，得用二进制读写. </span></div><div class="line">f.write(html) <span class="comment">#写入原始文件,不需要解码</span></div><div class="line">f.close()</div><div class="line"></div><div class="line"><span class="comment">#49,get参数拼接</span></div><div class="line">query = &#123;&#125;</div><div class="line">query[<span class="string">"key"</span>] = <span class="string">"python3"</span></div><div class="line">queryURL = urllib.parse.urlencode(query) <span class="comment">#得到key=python3</span></div><div class="line">url = <span class="string">"http://chenyalun.com/s?"</span> + queryURL</div><div class="line">print(url)</div><div class="line"></div><div class="line"><span class="comment">#50,使用BeautifulSoup</span></div><div class="line">html = <span class="string">"""&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></div><div class="line">    &lt;body&gt;</div><div class="line">    &lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</div><div class="line">    &lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</div><div class="line">    &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</div><div class="line">    &lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</div><div class="line">    &lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</div><div class="line">    and they lived at the bottom of a well.&lt;/p&gt;</div><div class="line">    &lt;p class="story"&gt;...&lt;/p&gt;</div><div class="line">    """</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line">soup = BeautifulSoup(html)</div><div class="line">print(soup.prettify())</div><div class="line"></div><div class="line"><span class="comment">#打印标签</span></div><div class="line">print(<span class="string">"标题是:"</span>,soup.title)</div><div class="line"></div><div class="line">print(<span class="string">"头部是"</span>,soup.head)</div><div class="line"></div><div class="line">print(<span class="string">"第一个a标签"</span>,soup.a)</div><div class="line"></div><div class="line">print(<span class="string">"第一个p标签"</span>,soup.p)</div><div class="line"></div><div class="line"><span class="comment">#它查找的是在所有内容中的第一个符合要求的标签</span></div><div class="line"><span class="comment">#标签的两个重要的属性:name 和 attrs</span></div><div class="line">print(soup.a.name)</div><div class="line">print(soup.p.attrs)</div><div class="line"><span class="comment">#属性的值</span></div><div class="line">print(<span class="string">"属性的值"</span>,soup.p.attrs[<span class="string">"name"</span>]) </div><div class="line">print(<span class="string">"属性的值"</span>,soup.p[<span class="string">"name"</span>])<span class="comment">#attrs可以省略</span></div><div class="line"></div><div class="line"><span class="comment">#用 .string获取文字</span></div><div class="line">print(soup.p.string)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#利用"CSS选择器"查找标签</span></div><div class="line"><span class="comment">#通过标签名查找</span></div><div class="line">print(soup.select(<span class="string">"title"</span>))</div><div class="line"></div><div class="line"><span class="comment">#通过类名查找</span></div><div class="line">print(soup.select(<span class="string">".sister"</span>))</div><div class="line"></div><div class="line"><span class="comment">#通过id查找</span></div><div class="line">print(soup.select(<span class="string">"#link1"</span>))</div><div class="line"></div><div class="line"><span class="comment">#组合查找</span></div><div class="line">print(soup.select(<span class="string">"p #link1"</span>)) <span class="comment">#格式同CSS</span></div><div class="line"></div><div class="line"><span class="comment">#直接子标签查找</span></div><div class="line">print(soup.select(<span class="string">"head &gt; title"</span>))</div><div class="line"></div><div class="line"><span class="comment">#属性查找</span></div><div class="line"><span class="comment">#属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格</span></div><div class="line">print(soup.select(<span class="string">'a[class="sister"]'</span>))</div><div class="line">print(soup.select(<span class="string">'a[href="http://example.com/elsie"]'</span>))</div><div class="line">print(soup.select(<span class="string">'p a[href="http://example.com/elsie"]'</span>))</div><div class="line"></div><div class="line"><span class="comment"># select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容</span></div><div class="line"><span class="keyword">for</span> title <span class="keyword">in</span> soup.select(<span class="string">"title"</span>):</div><div class="line">print(title.get_text)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017.1.11修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 人生苦短,我用Python。 &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.chenyalun.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.chenyalun.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>HTML/CSS/JavaScript学习笔记</title>
    <link href="http://blog.chenyalun.com/2016/12/06/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20/"/>
    <id>http://blog.chenyalun.com/2016/12/06/前端学习笔记 /</id>
    <published>2016-12-06T04:22:17.000Z</published>
    <updated>2017-03-15T09:13:47.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 大前端时代。 </p><a id="more"></a><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul><li><code>&lt;html&gt;&lt;/html&gt;</code>是根标签,<code>&lt;heal&gt;</code>定义文档的头部,常包含<code>&lt;title&gt; &lt;script&gt;</code></li><li><code>&lt;style&gt; &lt;meta&gt; &lt;link&gt;</code></li><li><code>&lt;em&gt;</code>表示强调，<code>&lt;strong&gt;</code> 表示更强烈的强调。并且在浏览器中<code>&lt;em&gt;</code> 默认用斜体表示，<code>&lt;strong&gt;</code>用粗体表示。</li><li><code>&lt;span&gt;</code>标签是没有语义的，它的作用就是为了设置单独的样式用的。</li><li>用<code>&lt;q&gt;</code>标签引用别人的语句,是对简短文本的引用:加上双引号</li><li><code>&lt;blockquote</code>是长文本引用:整体缩进</li><li>空标签现在一般使用 xhtml1.0 的版本的写法,如<code>&lt;br/&gt; &lt;img/&gt; &lt;hr/&gt;</code></li><li>在html代码中输入空格、回车都是没有作用的。要想输入空格，必须写入<code>&amp;nbsp;</code>。</li><li><code>&lt;adress&gt;</code>标签,添加地址:显示为斜体</li><li><code>&lt;code&gt;</code>标签:添加一行代码,<code>&lt;pre&gt;</code>预显示格式标签,被包围在 pre 元素中的文本通常会保留空格和换行符:添加一段代码(会转换其中的<code>&lt;br/&gt;</code>等)</li><li>ul-li是没有前后顺序的信息列表:每项li前都自带一个圆点</li><li>ol-li是有前后顺序的信息列表:每项li前都自带一个序号,序号默认从1开始</li><li>容器标签<code>&lt;div&gt;</code>,为网页划分独立的版块,给div命名:添加唯一的id属性，使逻辑更加清晰<br>创建表格的五个元素：`table、tr(一行)、th(表格表头)、td(一个单元格,有几个说明就有几列,表格中列的个数，取决于一行中数据单元格的个数。),</li><li>注意<code>tbody</code>:当表格内容非常多时，表格会下载一点显示一点，但如果加上<tbody>标签后，这个表格就要等表格内容全部下载完才会显示。注意1、table表格在没有添加css样式之前，在浏览器中显示是没有表格线的 2、表头，也就是th标签中的文本默认为粗体并且居中显示</tbody></li><li><code>&lt;table summary=&quot;表格简介文本&quot;&gt;</code>添加表格摘要,表格摘要并不会显示,<code>&lt;caption&gt;标题文本&lt;/caption&gt;</code>添加表格标题,显示在表格上方居中,需要包含在table标签中</li><li><code>&lt;a  href=&quot;目标网址&quot;  title=&quot;鼠标滑过显示的文本&quot;&gt;链接显示的文本&lt;/a&gt;</code>,title属性的作用，鼠标滑过链接文字时会显示这个属性的文本内容。加入a标签后，文字的颜色就会自动变为蓝色（被点击过的文本颜色为紫色）</li><li>新窗口打开超链接<code>&lt;a href=&quot;目标网址&quot; target=&quot;_blank&quot;&gt;click here!&lt;/a&gt;</code></li><li>使用mailto协议发送电子邮件,<code>mailto://abc@qq.com?&amp;cc=abcd@qq.com&amp;bcc=ab@qq.com&amp;subject=主题&amp;body=邮件内容</code>,其中,cc表示抄送,bcc表示密件抄送</li><li>插入图片语法<code>&lt;img src=&quot;图片地址&quot; alt=&quot;下载失败时的替换文本&quot; title = &quot;提示文本&quot;&gt;</code></li><li>表单是可以把浏览者输入的数据传送到服务器端,语法:<code>&lt;form   method=&quot;传送方式&quot;   action=&quot;服务器文件&quot;&gt;</code>,action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。method ： 数据传送的方式（get/post）</li><li><p>文本输入框input的类型:<code>text：文本框 password：密码框 raido：单选按钮 checkbox：复选框 file：文件选择框 submit：提交按钮,reset:重置</code></p><pre><code>&lt;form&gt;   &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt;&lt;/form&gt;`其中name为文本框命名,方便后台使用,value为文本框设置默认值,一般起提示作用文本输入域`&lt;textarea  rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt;`,在&lt;textarea&gt;&lt;/textarea&gt;标签之间可以输入默认值。注意这两个属性可用css样式的width和height来代替：col用width、row用height来代替。</code></pre></li><li>单选框与复选框:注意:同一组的单选按钮，name 取值一定要一致</li><li><p>下拉列表:</p><pre><code>&lt;select&gt;  &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt;  &lt;option value=&quot;旅游&quot;&gt;旅游&lt;/option&gt;  &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt;  &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt;&lt;/select&gt;` value为向服务器提交的值,设置selected=“selected”属性,则默认选中.</code></pre></li><li>下拉列表也可以进行多选操作，在<code>&lt;select&gt;</code>标签中设置multiple=”multiple”属性，就可以实现多选功能，在 windows 操作系统下，进行多选时按下Ctrl键同时进行单击（在 Mac下使用 Command +单击），可以选择多个选项。</li><li><p>form表单中的label标签:用于显示提示文本,并且当用户点击label时,将焦点转移到与之对应的控件(常用输入框)上,但是标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。 </p><pre><code>&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt;</code></pre></li></ul><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><ul><li>css 样式由选择符和声明组成，而声明又由属性和值组成,属性和值之间用英文冒号“：”分隔。当有多条声明时，中间可以英文分号“;”分隔,最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号。</li><li>CSS中有注释语句：用<code>/*</code>注释语句<code>*/</code>来标明,（Html中使用<code>&lt;!--注释语句--&gt;</code>)</li><li>内联式css样式表就是把css代码直接写在现有的HTML标签中，注意要写在元素的开始标签里,css样式代码要写在style=””双引号中，如果有多条css样式代码设置可以写在一起，中间用分号隔开</li><li><p>嵌入式css样式，写在当前的文件中.嵌入式css样式必须写在<code>&lt;style&gt;&lt;/style&gt;之间</code>，并且一般情况下嵌入式css样式写在<code>&lt;head&gt;&lt;/head&gt;</code>之间。注意设置style的type属性.</p><pre><code>&lt;style type=&quot;text/css&quot;&gt;span{   color:blue;}&lt;/style&gt;</code></pre></li><li>外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以“.css”为扩展名，在<code>&lt;head&gt;</code>内（不是在<code>&lt;style&gt;</code>标签内）使用<code>&lt;link&gt;</code>标签将css样式文件链接到HTML文件内,<code>&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</code>,<code>rel=&quot;stylesheet&quot; type=&quot;text/css&quot;</code>是固定写法不可修改。<code>&lt;link&gt;</code>标签位置一般写在<code>&lt;head&gt;</code>标签之内。</li><li>标签选择器; <code>标签名称{css样式代码;}</code></li><li>类选择器:<code>.类选器名称{css样式代码;}</code></li><li>ID选择器:<code>#id名称{css样式代码;}</code></li><li>子选择器:即大于符号(&gt;),用于选择指定标签元素的第一代子元素(只能是孩子)。<code>.food&gt;li{border:1px solid red;}</code></li><li>包含选择器:加入空格,用于选择指定标签元素下的后辈元素。<code>.first  span{color:red;}</code></li><li>通用选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素</li><li>伪类选择符:<code>a:hover{color:red;}</code></li><li>分组选择符:为html中多个<strong>标签元素</strong>设置同一个样式（，)<code>h1,span{color:red;}</code></li><li>类选择器和ID选择器的区别:1.ID选择器只能在文档中使用一次,类选择器可以使用多次,也即id选择器(名称)具有唯一性;2.可以使用类选择器词列表方法为一个元素同时设置多个样式。也即一个元素可以具有多个类,但只能有一个id:<code>&lt;span class=&quot;stress bigsize&quot;&gt;三年级&lt;/span&gt;</code></li><li><code>border:1px solid red;相当于border-width:1px;//边框宽度    border-style:solid; //边框风格    border-color:red; //边框颜色</code></li><li>继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。<code>border:1px solid red;</code>无法继承.</li><li>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于最后面的css样式会被应用。</li><li>继承是指标签的样式可以由子代继承，但有些标签是不能继承的，eg：border。<br>特殊性指用用权重来确定最后起作用的样式，id=100，class=10，标签=1，继承=0.1；<br>层叠指当权重相同时，后面的样式覆盖前面的样式。<br>important的使用。</li><li>浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式，但记住!important优先级样式是个例外，权值高于用户自己设置的样式。<code>p{color:red !important;}</code>注意分号放在!important的后面</li><li>任意浏览器的默认字体高度16px（16像素）。所有未经调整的浏览器都符合:1em=16px。为了简化font-size的换算，需要在css中的body选择器中声明font-size=62.5%，这就使em值变为16px*62.5%=10px,这样12px=1.2em,10px=1em,也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。注：建议不要使用em作为中文站点的文字单位，会导致文字变形十分严重的。em的值并不是固定的； em会继承父级元素的字体大小。</li><li><p>图片居中，不能直接对img标签使用<code>text-align:center;</code>而是对该img标签所在的div或者其他块级元素使用才会达到这种效果。</p><pre><code>字体:`font-family:”Microsoft Yahei”;`文字颜色,字号:`font-size:12px;color:#666`文字粗体:`font-weight:bold;`文字斜体:`font-style:italic;`文字下划线;`text-decoration:underline;`文字删除线:`text-decoration:line-through;`文本缩进:`text-indent:2em;`两个空格行间距(行高):`line-height:2em;`设置文字间隔或者字母间隔:`letter-spacing:50px;`注意：这个样式使用在英文单词时，是设置字母与字母之间的间距。单词间距:`word-spacing:50px;`为块状元素中的文本、图片设置居中样式:`text-align:center;`常用的块状元素有：`&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;`常用的内联元素有：`&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;`常用的内联块状元素有：`&lt;img&gt;、&lt;input&gt;`</code></pre></li><li>块状元素都自带换行效果；内联元素都是定义行内小区域且不换行，但如果没有内容就没有意义，不占空间；内联块状元素除了不换行，即使没有内容也会占空间。</li><li>在html中<code>&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;</code>就是块级元素。设置<code>display:block</code>就是将元素显示为块级元素。</li><li>将内联元素转换为块级元素:<code>a{display:block;}</code></li><li>块级元素特点：1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）2、元素的高度、宽度、行高以及顶和底边距都可设置。3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</li><li>在html中，<code>&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;</code>就是典型的内联元素（行内元素）（inline）元素。当然块状元素也可以通过代码<code>display:inline</code>将元素设置为内联元素。<code>display:inline;</code></li><li>内联元素特点：1、和其他元素都在一行上；2、元素的高度、宽度及顶部和底部边距不可设置；3、元素的宽度就是它包含的文字或图片的宽度，不可改变。</li><li>联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码<code>display:inline-block</code>就是将元素设置为内联块状元素。(css2.1新增)，<code>&lt;img&gt;、&lt;input&gt;</code>标签就是这种内联块状标签。</li><li>inline-block 元素特点：1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置。</li><li>边框:<code>border:2px  solid  red;</code>对应:<code>border-width:2px;border-style:solid;border-color:red;</code>border-style（边框样式）常见样式有：<br>dashed（虚线）| dotted（点线）| solid（实线）。border-width（边框宽度）中的宽度也可以设置为：thin | medium | thick（但不是很常用），最常还是用像素（px）</li><li>单独设置下边框:<code>border-bottom:1px solid red;</code> top right left bottom</li><li>css内定义的宽（width）和高（height），指的是填充以里的内容范围。因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</li><li>元素与其它元素之间的距离可以使用边界（margin）来设置。</li><li>元素内容与边框之间是可以设置距离的，称之为“填充”<code>padding-top</code>。 顺时针:上 右 下 左  或者 上下 左右 或者 上下左右</li><li>CSS包含3种基本的布局模型，用英文概括为：Flow、Layer 和 Float。在网页中，元素有三种布局模型：1、流动模型（Flow）2、浮动模型 (Float)3、层模型（Layer）</li><li>流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。流动布局模型具有2个比较典型的特征：第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）</li><li>块状元素这么霸道都是独占一行，设置元素浮动就可以实现让两个块状元素并排显示。<br>任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动.<code>float:left;</code></li><li>层布局模型就像是图像软件PhotoShop中非常流行的图层编辑功能一样，每个图层能够精确定位操作.CSS定义了一组定位（positioning）属性来支持层布局模型。层模型有三种形式：1、绝对定位(position: absolute)2、相对定位(position: relative)3、固定定位(position: fixed)</li><li>设置position:absolute(表示绝对定位)，作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。对于以前位置(<strong>右上角</strong>）向左移动100像素，向下移动20像素。<code>right:100px;   top:20px;</code>right的是让right的margin变为100px，同理top是让top的margin变为20px，所以要向右和向下移。</li><li>如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。<code>position:relative;    left:100px;    top:50px;</code>（相对于以前位置<strong>左上角</strong>）向右移动100像素，向下移动50像素。</li><li>absolute表里如一，移动了就是移动了。relative只是表面显示移动了，但实际还在文档流中原有位置，别的元素无法占据。</li><li>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与<code>background-attachment:fixed;</code>属性功能相同。</li><li>使用<code>position:relative</code>,相对于其它元素进行定位,参照定位的元素必须是相对定位元素的前辈元素;参照定位的元素必须加入position:relative;定位元素加入position:absolute，便可以使用top、bottom、left、right来进行偏移定位了</li><li><p>参照物不是浏览器</p><pre><code>#box1{    width:200px;    height:200px;    position:relative;            }#box2{    position:absolute;    top:20px;    left:30px;    } //box2就可以相对于父元素box1定位</code></pre></li><li><p>设置的颜色是16进制的色彩值时，如果每两位的值相同，可以缩写一半。<code>p{color:#000000;} == p{color:#000;} p{color: #336699;}==p{color: #369;}</code></p></li><li>字体的缩写<code>body{    font:12px/1.5em  &quot;宋体&quot;,sans-serif;}</code>1、使用这一简写方式你至少要指定 font-size 和 font-family 属性，其他的属性(如 font-weight、font-style、font-varient、line-height)如未指定将自动使用默认值。2、在缩写时 font-size 与 line-height 中间要加入“/”斜扛。</li><li>设置颜色值的三种方式:1,英文命令.2.RGB <code>p{color:rgb(133,45,200);}</code>每一项在0-255之间,也可以是百分数<code>p{color:rgb(20%,33%,25%);}</code>.3.十六进制(较普遍)<code>p{color:#00ffff;}</code></li><li><p>长度单位</p><pre><code>目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。1、像素像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS规范中假设“90像素=1英寸”）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。2、em就是本元素给定字体的 **font-size 值**，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。如下代码：p{font-size:12px;text-indent:2em;}上面代码就是可以实现段落首行缩进 24px（也就是两个字体大小的距离）。下面注意一个特殊情况：但当给 font-size 设置单位为 em 时，此时计算的标准以 p 的父元素的 font-size 为基础。如下代码：html:&lt;p&gt;以这个&lt;span&gt;例子&lt;/span&gt;为例。&lt;/p&gt;css:p{font-size:14px}span{font-size:0.8em;}结果 span 中的字体“例子”字体大小就为 11.2px（14 * 0.8 = 11.2px）。3、百分比p{font-size:12px;line-height:130%}设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。</code></pre></li><li><p>水平居中设置-行内元素:如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 <code>text-align:center</code>来实现的。</p></li><li>水平居中设置-定宽块状元素:当被设置元素为 块状元素 时用 <code>text-align：center</code>就不起作用了，这时也分两种情况：定宽块状元素和不定宽块状元素。定宽块状元素：块状元素的宽度width为固定值。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。</li><li><p>水平居中设置-不定宽块状元素方法（一）:(不定宽块状元素：块状元素的宽度width不固定。)不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）:1.加入 table 标签,为这个 table 设置“左右 margin 居中”（这个和定宽块状元素的方法一样,利用table标签的长度自适应性,可以看做一个定宽度块元素)<br>2.设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置3.设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的</p><pre><code>&lt;table&gt;  &lt;tbody&gt;    &lt;tr&gt;&lt;td&gt;    &lt;ul&gt;        &lt;li&gt;我是第一行文本&lt;/li&gt;        &lt;li&gt;我是第二行文本&lt;/li&gt;        &lt;li&gt;我是第三行文本&lt;/li&gt;    &lt;/ul&gt;    &lt;/td&gt;&lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;或者直接设置`display:table; margin:0 auto;`也即 .wrap{background:#ccc;display:table;margin:0 auto;}</code></pre></li><li><p>水平居中设置-不定宽块状元素方法（二）:改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。它将块状元素的 display 类型改为 inline，变成了行内元素，所以少了一些功能，比如设定长度值。</p></li><li>水平居中设置-不定宽块状元素方法（三）:通过给父元素设置 float值为left，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。</li><li>垂直居中-父元素高度确定的单行文本:设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。这种文字行高与块高一致带来了一个弊端：当文字内容的长度大于块的宽时，就有内容脱离了块。</li><li>垂直居中-父元素高度确定的多行文本（方法一）:插入 table标签，同时设置 vertical-align：middle。</li><li>垂直居中-父元素高度确定的多行文本（方法二）:设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式, 兼容性比较差。    <code>display:table-cell;/*IE8以上及Chrome、Firefox*/    vertical-align:middle;/*IE8以上及Chrome、Firefox*/</code></li><li>隐性改变display类型:有一个有趣的现象就是当为元素（不论之前是什么类型元素，display:none 除外）设置以下 2 个句之一： 1. position : absolute  2. float : left 或 float:right 简单来说，只要html代码中出现以上两句之一，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。</li></ul><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><ul><li>我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。放在<head>部分最常用的方式是在页面中head部分放置script&gt;元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。</head></li><li><p>放在<body>部分JavaScript代码在网页读取到该语句的时候就会执行。注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。</body></p><pre><code> &lt;script type=&quot;text/javascript&quot;&gt;  document.write(&quot;I love JS&quot;)&lt;/script&gt;</code></pre></li><li>单行注释，在注释内容前加符号 “//”。多行注释以”/<em>“开始，以”</em>/“结束。</li><li>1.变量必须使用字母、下划线(<em>)或者美元符(<code>$</code>)开始。2.然后可以使用任意多个英文字母、数字、下划线(</em>)或者美元符(<code>$</code>)组成。 3.不能使用JavaScript关键词与JavaScript保留字。变量要先声明再赋值，JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。</li><li>document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。第一种:输出内容用””括起，直接输出””号内的内容。第二种:通过变量，输出内容.第三种:输出多项内容，内容之间用+号连接。第四种:输出HTML标签，并起作用，标签使用<code>&quot;&quot;</code>括起来。<code>document.write(mystr+&quot;&lt;br&gt;&quot;);</code></li><li>js输出空格:<code>&quot;&amp;nbsp;”</code>或者<code>document.write(&quot;&lt;span style=&#39;white-space:pre;&#39;&gt;&quot;+&quot;  1        2    3    &quot;+&quot;&lt;/span&gt;”);</code>输出时添加<code>“white-space:pre;”</code>样式属性。这个样式表示”空白会被浏览器保留”</li><li>JavaScript-警告（alert 消息对话框）</li><li><p>JavaScript-确认（confirm 消息对话框）弹出对话框(包括一个确定按钮和一个取消按钮)。 <code>confirm(str);</code>当用户点击”确定”按钮时，返回true当用户点击”取消”按钮时，返回false</p><pre><code>function rec(){   var mymessage=confirm(&quot;你好棒&quot;)         ;   if(mymessage==true)   {       document.write(&quot;你是女士!&quot;);   }   else   {       document.write(&quot;你是男士!&quot;);   } }    </code></pre></li><li><p>JavaScript-提问（prompt 消息对话框）弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。<code>prompt(str1, str2);</code>str1: 要显示在消息对话框中的文本，不可修改,str2：文本框中的内容，可以修改.1. 点击确定按钮，文本框中的内容将作为函数返回值2. 点击取消按钮，将返回null.注:在用户点击对话框的按钮前，不能进行任何其它操作。</p><pre><code>score =  prompt(&quot;哈喽哈&quot;,&quot;默认值&quot;);if(score&gt;=90){   document.write(&quot;你很棒!&quot;);}</code></pre></li><li><p>JavaScript-打开新窗口（window.open）<code>window.open([URL], [窗口名称], [参数字符串])</code></p><pre><code>           URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。          窗口名称：可选参数，被打开窗口的名称。                   1.该名称由字母、数字和下划线字符组成。 2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。    _blank：在新窗口显示目标网页    _self：在当前窗口显示目标网页    _top：框架网页中在上部窗口中显示目标网页 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。4.name 不能包含有空格。</code></pre></li><li><p>参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。toolbar工具栏,scrollbars滚动条,status状态栏menubar菜单栏 值为yes/no 窗口宽高度width/height以及窗口顶部/左端距离屏幕顶部的像素数top/left  </p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt; window.open(&apos;http://www.imooc.com&apos;,&apos;_blank&apos;,&apos;width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes’)    &lt;/script&gt;</code></pre></li></ul><ul><li><p>JavaScript-关闭窗口（window.close）</p><pre><code> window.close();   //关闭本窗口 &lt;窗口对象&gt;.close();   //关闭指定的窗口 &lt;script type=&quot;text/javascript&quot;&gt;   var mywin=window.open(&apos;http://www.imooc.com&apos;); //将新打的窗口对象，存储在变量mywin中   mywin.close();&lt;/script&gt;</code></pre></li><li>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</li><li><p>HTML文档可以说由节点构成的集合，三种常见的DOM节点:1. 元素节点：上图中<code>&lt;html&gt;、&lt;body&gt;、&lt;p&gt;</code>等都是元素节点，即标签。2. 文本节点:向用户展示的内容，如<code>&lt;li&gt;...&lt;/li&gt;</code>中的JavaScript、DOM、CSS等文本。3. 属性节点:元素属性，如<code>&lt;a&gt;</code>标签的链接属性<code>href=&quot;http://www.chenyalun.com&quot;</code>。</p></li><li><p>通过ID获取元素:<code>document.getElementById(“id”)</code>,返回<code>[object HTMLParagraphElement]</code> ,注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。用<code>document.getELementById().innerHTML;</code>才可以获取到其中的内容.</p></li><li>innerHTML 属性用于获取或替换 HTML 元素的内容。Object.innerHTML,1.Object是获取的元素对象，如通过document.getElementById(“ID”)获取的元素。2.注意书写，innerHTML区分大小写。</li><li>改变 HTML 样式:<code>Object.style.property=new style;</code>例如:<code>mychar.style.color=red;</code></li><li>显示和隐藏（display属性）Object.style.display = value,其中value为none隐藏,value为block块级元素显示.其中none与block要加上引号</li><li>控制类名（className 属性）className 属性设置或返回元素的class 属性。<code>object.className = classname</code>作用:1.获取元素的class 属性2. 为网页内的某个元素指定一个css样式来更改该元素的外观</li><li>删除修改的样式:<code>document.getElementById(&quot;txt&quot;).removeAttribute(&quot;style&quot;);</code></li><li>外部引入JS <code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></li><li>变量:字母数字下划线美元符,变量名区分大小写,不允许使用关键字保留字</li><li>变量也可以不声明，直接使用，但为了规范，需要先声明，后使用。</li><li>“+”连接字符串时,符号两边不能有空格</li><li><code>jq1=numa + 30 &gt;10 &amp;&amp; numb * 3&lt;20;</code>算术操作符 → 比较操作符 → 逻辑操作符 → “=”赋值符号</li><li>定义数组: <code>var myarr=new Array();  myarr[0]=80;</code>实际上数组都是变长的,即使指定了长度为8，仍然可以将元素存储在规定长度以外。</li><li>创建数组:<code>var myarr = new Array(11,25,35); var myarr = [12,25,416];</code></li><li>只需使用下一个未用的索引，任何时刻可以不断向数组增加新元素。<code>myarray[5]=88; //使用一个新索引，为数组增加一个新元素</code></li><li>数组的属性:length长度</li><li>二维数组的表示:<code>myarray[ ][ ]</code>,简单定义:<code>var Myarr = [[0 , 1 , 2 ],[1 , 2 , 3]]</code>,也可以使用循环,myarr[0][1]=5; //将5的值传入到数组中，覆盖原有值。</li><li><code>==先转换类型再比较，===先判断类型，如果不是同一类型直接为false。</code></li><li>函数调用的两种情况:1.script标签中直接调用,2.点击按钮调用onClick事件</li><li>有参数的函数:<code>function 函数名(参数1,参数2){     函数代码}</code>,参数不要声明类型</li><li><code>function add2(x,y){   sum = x + y;   return sum; //返回函数值,return后面的值叫做返回值。}</code></li><li>事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。</li><li><p>常用JS事件:</p><pre><code>onclick鼠标单击事件onmouseover鼠标经过事件onmouseout鼠标移开事件onchange文本框**内容**改变事件,一般是textareaonselect文本框**内容**选中事件,一般是textareaonfocus光标聚焦onblur光标移开onload网页加载后,事件会在页面加载完成后，立即发生，同时执行被调用的程序。加载页面时，触发onload事件，**事件写在&lt;body&gt;标签内**。onunload卸载事件,当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。该事件目前只对IE起作用。</code></pre></li><li><p>使用parseInt()函数可解析一个字符串,并返回一个整数。</p></li><li>JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。对象的属性：反映该对象某些特定的性质的，如：字符串的长度、图像的长宽等；对象的方法：能够在对象上执行的动作。例如，表单的“提交”(Submit)，时间的“获取”(getYear)等；</li></ul><h2 id="Date日期对象"><a href="#Date日期对象" class="headerlink" title="Date日期对象"></a>Date日期对象</h2><ul><li><p>日期对象,使用关键字new，Date()的首字母必须大写。</p><pre><code>// 日期的相关属性与方法get/setDate() 返回设置日期get/setFullYear()  返回设置年份,用四位数表示get/setYear() 返回/设置年份get/setMonth() 返回/设置月份get/setHours() 返回/设置小时,24小时制get/setMinutes() 返回/设置分钟数get/setSeconds() 返回/设置秒钟数get/setTime() 返回/设置时间(毫秒为单位)getDay() 返回星期，返回的是0-6的数字，0 表示星期天。</code></pre></li><li><p>使用 String 对象的 toUpperCase() 方法来将字符串小写字母转换为大写.使用toLowerCase()方法，将字符串所有大写字母都变成小写的字符串</p></li><li>charAt() 方法可返回指定位置的字符。返回的字符是长度为 1 的字符串。</li><li>注意：1.字符串中第一个字符的下标是 0。最后一个字符的下标为字符串长度减一（string.length-1）。2.如果参数 index 不在 0 与 string.length-1 之间，该方法将返回一个空字符串。</li><li>indexOf(,) 方法可返回某个指定的字符串值在字符串中首次出现的位置。1.该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 substring。2.可选参数，从stringObject的startpos位置开始查找substring，如果没有此参数将从stringObject的开始位置查找。3.如果找到一个 substring，则返回 substring 的第一次出现的位置。stringObject 中的字符位置是从 0 开始的。</li><li>split(separator,limit) 方法将字符串分割为字符串数组，并返回此数组。注意：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。separator必须,从该参数指定的地方分割stringObject,limite,可选参数,分割的次数,如果设置该参数,则返回的子串不会多于这个参数指定的数组,如果无参数,则不限定次数</li><li>substring(起始位置,可选的结束位置(不包含该位置的字符)) 方法用于提取字符串中介于两个指定下标之间的字符。注意：1. 返回的内容是从 start开始(包含start位置的字符)到 stop-1 处的所有字符，其长度为 stop 减start。2. 如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。3. 如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。</li><li>substr() 方法从字符串中提取从 startPos位置开始的指定数目的字符串。<code>stringObject.substr(startPos,length)</code>  注意：如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。如果startPos为负数且绝对值大于字符串长度，startPos为0。</li><li>string.substring( 起点 ， 终点 )  string.substr( 起点 ，长度 )</li><li>Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。</li></ul><h2 id="MATH常用属性方法"><a href="#MATH常用属性方法" class="headerlink" title="MATH常用属性方法"></a>MATH常用属性方法</h2><ul><li><p>MATH</p><pre><code>E 返回算数常量e(约为2.71828)LN2 返回2的自然对数LN10 返回10的自然对数LOG2E 返回以2为底的e的对数LOG10E 返回以10为底的e的对数PI 圆周率SQRT1_2 返回2的平方根的倒数SQRT2 返回2 的平方根MATH常用方法abs(x) 返回数的绝对值acos(x) 返回数的反余弦值asin(x) 返回数的反正弦值atan(x) 返回数的反正切值atan2(y,x)返回由x轴到点(x,y)的角度(以弧度为单位)ceil(x)对数进行上舍入cos(x) 返回数的余弦exp(x) 返回e的指数floor(x)对数进行下舍入log(x) 返回数的自然对数max(x,y) 返回最高值min(x,y) 返回最小值pow(x,y) 返回x的y 次方random() 返回0--1之间的随机数round(x) 把数四舍五入最为接近的数sin(x) 正弦cos(x) 余弦tan(x) 正切sqrt(x) 平方根toSourse() 返回该对象的源代码value() 返回MATH对象的原始值</code></pre></li></ul><h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><ul><li><p>数组</p><pre><code>concat() 连接两个或更多的数组,并返回结果join() 把数组的所有元素放入一个字符串,元素通过指定的分隔符分割pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素,并返回新的长度reverse() 颠倒数组元素的顺序shift() 删除并返回数组的第一个元素slice(start,可选的end) 从某个已有的数组返回选定的元素sort() 对数组的元素进行排序splice() 删除元素,并向数组添加新元素toSource() 返回该对象的源代码toString() 把数组转换为字符串,并返回结果toLocalString() 把数组转化为本地数组,并返回结果unshift() 向数组的开头添加一个或者更多元素,并返回新的长度()valueOf() 返回数组对象的原始值</code></pre></li></ul><h2 id="window对象方法"><a href="#window对象方法" class="headerlink" title="window对象方法"></a>window对象方法</h2><ul><li><p>window</p><pre><code>alert() 显示带有一段消息和一个确定按钮的警告框prompt() 显示可以提示用户输入的对话框confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框open() 打开一个新的浏览器窗口或者查找一个已命名的窗口close() 关闭浏览器窗口print() 打印当前窗口的内容focus() 把键盘焦点给予一个窗口blur() 把键盘焦点从顶层窗口移开moveBy() 相对窗口的当前坐标移动指定的像素moveTo() 把窗口的左上角移动一个指定的坐标resizeBy() 按照指定的像素调整窗口的大小resizeTo() 把窗口的大小调整到指定的宽度和高度scrollBy() 按照指定的像素滚动内容scrollTo() 把内容滚动到指定的坐标setInterval(代码,间隔时间) 每隔一定时间执行代码(间隔性触发计时器),在执行时,从载入页面后每隔指定的时间执行代码。代码:函数或代码串,如”clock()”或者clock,交互时间:以毫秒为单位.返回该定时器setTimeout() 在指定的时间延迟后指定代码(一次性计时器)clearInterval() 取消setInterval() 的设置,传入定时器clearTimeout() 取消setTimeout() 的设置</code></pre></li></ul><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><ul><li><p>history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。<code>window.history.[属性|方法]</code></p><pre><code>length 返回浏览器历史列表的URL数量back() 加载history列表中前一个URLforward() 加载history列表下一个URLgo(number) 加载history列表某一个具体的页面,0:当前页面back()相当于go(-1),forward()相当于go(1)</code></pre></li></ul><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><ul><li><p>location用于获取或设置窗体的URL，并且可以用于解析URL。<code>location.[属性|方法]</code></p><pre><code>hash 设置或返回从#开始的URL(锚点)host 设置或返回主机名和当前URL的端口号hostname 设置或返回当前URL的主机名href 设置或返回完成的URLpathname 设置或返回当前URL的路径部分port 设置或返回当前URL的端口号protocol 设置或返回当前URL的协议search 设置或者返回从?开始的URL(查询部分)assign() 加载新的文档reload() 重新加载当前文档replace() 用新的文档替换当前文档</code></pre></li></ul><h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><ul><li><p>navigator 对* navigator 对象包含有关浏览器的信息</p><pre><code>appCodeName 浏览器代码名的字符串表示appName 浏览器的名称appVersion 浏览器平台以及版本platform 运行浏览器的操作系统平台userAgent 返回user-agent头部的值</code></pre></li></ul><h2 id="window中的screen-对象"><a href="#window中的screen-对象" class="headerlink" title="window中的screen 对象"></a>window中的screen 对象</h2><ul><li>window.screen 对象在编写时可以不使用 window 这个前缀。</li><li><p>screen对象用于获取用户的屏幕信息。<code>window.screen.属性</code>    </p><pre><code>height 屏幕的高度,单位像素width  屏幕的宽度,单位像素availHeight 窗口可用的屏幕高度,单位像素,减去界面特性，比如任务栏。availWidth 窗口可用的屏幕宽度,单位像素,减去界面特性，比如任务栏。colorDepth 用户浏览器表示的颜色位数,通常32位(每像素的位数)pixelDepth 浏览器颜色位数,通常32位(每像素的位数)(IE不支持)</code></pre></li></ul><h2 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h2><ul><li><p>节点属性与方法</p><pre><code>nodeName 返回一个字符串,其内容是给定节点的名字nodeType 返回一个整数,这个数值代表给定节点的类型nodeValue 返回给定节点的当前值innerHTML 节点内置文本childNodes 返回一个数组,这个数组由给定元素节点的子节点构成firstChild 返回第一个子节点lastChild 返回最后一个子节点parentNode 返回一个给定节点的父节点nextSibling返回给定节点的下一个子节点previousSibling 返回给定节点的上一个子节点document.createElement(&quot;elementType&quot;) 创建一个新的元素节点document.cr    document.createTextNode(&quot;text&quot;) 创建一个包含着给定文本的新文本节点,text为文本appendChild(node) 指定节点的最后一个子节点列表后添加一个新的子节点insertBefore(newnode,node) 将一个给定节点插入到一个给定元素节点的给定节点前面removeChild(node) 从一个给定元素中删除一个子节点replaceChild(newnode,oldnew) 把一个给定元素里的一个子节点替换为另外一个节点</code></pre><h3 id="docuument常用方法"><a href="#docuument常用方法" class="headerlink" title="docuument常用方法"></a>docuument常用方法</h3></li><li>document.getElementsByName(name) 返回带有指定名称的节点对象的集合。与getElementById() 方法不同的是，通过元素的 name 属性查询元素，而不是通过 id 属性</li><li>document.getElementsByTagName(Tagname)  Tagname是标签的名称，如p、a、img等标签名。和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。</li><li>elementNode.getAttribute(name),其中elementNode：使用getElementById()、getElementsByTagName()等方法，获取到的元素节点.name：要想查询的元素节点的属性名字.</li><li>elementNode.setAttribute(name,value),name: 要设置的属性名。value: 要设置的属性值。把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。</li><li><p>在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：nodeName : 节点的名称,nodeValue ：节点的值,nodeType ：节点的类型</p></li><li><p>nodeName 属性: 节点的名称，是只读的。</p><pre><code>1. 元素节点的 nodeName 与标签名相同2. 属性节点的 nodeName 是属性的名称3. 文本节点的 nodeName 永远是 #text4. 文档节点的 nodeName 永远是 #document</code></pre></li><li><p>nodeValue 属性：节点的值</p><pre><code>1. 元素节点的 nodeValue 是 undefined 或 null2. 文本节点的 nodeValue 是文本自身3. 属性节点的 nodeValue 是属性的值</code></pre></li><li><p>nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型:</p><pre><code>元素类型    节点类型  元素          1  属性          2  文本          3  注释          8  文档          9</code></pre></li><li><p>elementNode.childNodes,访问子节点.</p></li><li>node.firstChild,node.lastChild,访问子节点的第一项,最后一项,如果选定的节点没有子节点，则该属性返回 NULL。</li><li>elementNode.parentNode,获取指定节点的父节点,父节点只能有一个。览器兼容问题，chrome、firefox等浏览器标签之间的空白也算是一个文本节点。</li><li><code>nodeObject.nextSibling,nodeObject.previousSibling</code>,访问兄弟节点</li><li>appendChild(newnode),在指定节点的最后一个子节点列表之后添加一个新的子节点。</li><li>removeChild(),把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。如果要完全删除对象，给 x 赋 null 值</li><li><code>document.documentElement.clientHeight</code>表示HTML文档所在窗口的当前高度。,<code>window.innerHeight</code>- 浏览器窗口的内部高度,<code>document.body.clientHeight</code>,Document对象的body属性对应HTML文档的<body>标签</body></li><li><p>通用解决方案:</p><pre><code>var w=document.documentElement.scrollWidth   ||    document.body.scrollWidth;var h=document.documentElement.scrollHeight   ||    document.body.scrollHeight;</code></pre></li></ul><ul><li>网页尺寸:scrollHeight和scrollWidth，获取网页内容高度和宽度。scrollHeight 是网页内容实际高度，可以小于 clientHeight。scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。</li><li><p>通用解决方案:</p><pre><code>var w=document.documentElement.scrollWidth || document.body.scrollWidt h;var h=document.documentElement.scrollHeight || document.body.scrollHeight;</code></pre></li><li><p>offsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。</p></li><li><p>通用解决方案</p><pre><code>var w= document.documentElement.offsetWidth || document.body.offsetWidth;var h= document.documentElement.offsetHeight || document.body.offsetHeight;       </code></pre></li><li><p>scrollLeft:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。</p></li><li>scrollTop:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。</li><li>offsetLeft:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。</li><li>offsetTop:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。</li><li>offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。</li><li>clientHeight,大家对 clientHeight 都没有什么异议，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个工具条以下到状态栏以上的这个区域，与页面内容无关。</li><li>offsetHeight,IE、Opera 认为 offsetHeight = clientHeight + 滚动条 + 边框。,NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。</li><li>scrollHeight,IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。,NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。</li><li>浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;</li><li>JavaScript不区分整数和浮点数，统一用Number表示</li><li>NaN;NaN表示Not a Number，当无法计算结果时用NaN表示.Infinity;Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</li><li><code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；<br>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。始终坚持使用===比较</li><li>NaN这个特殊的Number与所有其他值都不相等，包括它自己,唯一能判断NaN的方法是通过isNaN()函数,<code>isNaN(NaN); // true</code></li><li>Swift用nil，Python用None表示,JavaScript用null</li><li>JavaScript的数组可以包括任意数据类型。</li><li>JavaScript的对象是一组由键-值组成的无序集合,JavaScript对象的键都是字符串类型，值可以是任意数据类型。</li><li>变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。</li><li>如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量,在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误,启用strict模式的方法是在JavaScript代码的第一行写上：<code>&#39;use strict&#39;;</code></li><li><code>`你好, ${name}, 你今年${age}岁了!</code>;`注意不是单引号</li><li>直接给Array的length赋一个新的值会导致Array大小的变化,如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化</li><li>空数组继续pop不会报错，而是返回undefined,如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉</li><li>空数组继续shift不会报错，而是返回undefined</li><li>splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素,从索引2开始删除3个元素,然后再添加两个元素:<code>arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook’);</code></li><li>concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里</li><li>unshift()和push()对应,头部添加若干元素,shift()和pop()对应删除末尾元素.</li><li><p>声明对象</p><pre><code>var person = {name : “AA”,age : 12,&apos;m-s&apos;: &apos;No&apos;,// 非有效变量sex : true};// 访问:person.name;  person[&apos;m-s&apos;]; person.a;// 访问不存在的属性不报错，而是返回undefined// 自由增加属性:person.b = 12;// 删除属性 delete person.age;// 检测对象以及父类具有某属性 &apos;name&apos; in person 返回布尔// 检测某对象具有某属性 person.hasOwnProperty(&apos;name&apos;); 返回布尔</code></pre></li><li><p>JavaScript把null、undefined、0、NaN和空字符串’’视为false，其他值一概视为true</p></li><li>for (var index in array) {// 此处的index是索引而非array中的元素}</li><li><p>Map是一组键值对的结构，具有极快的查找速度。<br><code>var m = new Map([[&#39;Michael&#39;, 95], [&#39;Bob&#39;, 75], [&#39;Tracy&#39;, 85]]); m.get(&#39;Michael&#39;); // 95</code><br>常用操作:</p><pre><code>var m = new Map(); // 空Mapm.set(&apos;Adam&apos;, 67); // 添加新的key-valuem.set(&apos;Bob&apos;, 59);m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: truem.get(&apos;Adam&apos;); // 67m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;m.get(&apos;Adam&apos;); // undefined</code></pre></li><li><p>Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。<code>var s2 = new Set([1, 2, 3]); // 含1, 2, 3</code>.通过add(key)方法可以添加元素到Set中,通过delete(key)方法可以删除元素</p></li><li>遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for … of循环来遍历。</li><li>for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。索引+属性</li><li>for … of循环则完全修复了这些问题，它只循环集合本身的元素,元素本身</li><li><p>forEach遍历</p><pre><code>var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.forEach(function (element, index, array) {    // element: 指向当前元素的值    // index: 指向当前索引    // array: 指向Array对象本身    alert(element);});var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);s.forEach(function (element, sameElement, set) {    alert(element);});var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);m.forEach(function (value, key, map) {    alert(value);});</code></pre></li><li>JavaScript允许传入任意个参数而不影响调用,传入的参数比定义的少也没有问题</li><li>JavaScript还有一个关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。类似数组不是数组</li><li><p>不在任何函数内定义的变量就具有全局作用域。全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。</p><pre><code>// 唯一的全局变量MYAPP:var MYAPP = {};// 其他变量:MYAPP.name = &apos;myapp&apos;;MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () {    return &apos;foo&apos;;};</code></pre></li><li>JavaScript的变量作用域实际上是函数内部,用let替代var可以申明一个块级作用域的变量,const来定义常量，const与let都具有块级作用域</li><li>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字</li><li>非strict环境下:直接使用this没毛病,strict环境下:函数内部首先写上var that = this;之后使用that</li><li>据是否是strict模式，this指向undefined或window</li><li>apply()把参数打包成Array再传入；  call()把参数按顺序传入。</li><li>简单的高阶函数:一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</li><li><p>map():对<strong>数组</strong>中的每一个且仅是单独的元素执行操作,</p><pre><code>// 把每一个元素转化为字符串 ,得到的仍是数组array.map(String)// 执行pow()function pow(x) {    return x * x;}array.map(pow),得到的仍是数组</code></pre></li><li><p>reduce():对<strong>数组</strong>中的最开始两个元素进行操作,将结果与第三个元素操作,以此类推</p><pre><code>// 数组求和arr.reduce(function (x, y) {    return x + y;});</code></pre></li><li><p>filter():根据传入的函数,作用于每一个元素,返回true或false,把数组中的某些元素过滤掉,返回剩余的元素</p><pre><code>var r = arr.filter(function (s) {    return  x % 2 !== 0;             });arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</code></pre></li><li>sort():排序,默认把所有元素先转换为String再排序,传入的排序函数,根据返回-1进行排序</li><li><p>箭头函数:在箭头函数中,可以直接使用this,而非that</p><pre><code>x =&gt; x*x// 相当于function (x) {return x*x;}// 含有多条语句,多个参数时(x,y) =&gt; {if (x &gt;0 ) {return 0;}return x*y;}// 不能省略{}// 特别注意返回一个对象:x =&gt; ({ foo: x })</code></pre></li><li><p>generator和函数不同的是，generator由function*定义,除了return语句，还可以用yield返回多次。调用generator对象有两个方法，一是不断地调用generator对象的next()方法,第二个方法是直接用for … of循环迭代generator对象</p></li><li>用typeof操作符获取对象的类型，它总是返回一个字符串:’number’,’boolean’,’string’,’function’,’object’,’undefined’,特别注意null的类型是object，Array的类型也是object</li><li>包装对象:<code>var n = new Number(123);</code>,返回object</li><li>JavaScript的月份范围用整数表示是0~11，0表示一月，1表示二月</li><li>RegExp中:在正则表达式中，如果直接给出字符，就是精确匹配。<code>用\d可以匹配一个数字，\w可以匹配一个字母或数字,.可以匹配任意字符，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符,\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格</code></li><li>更精确的匹配,[]表示范围:<code>[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线,[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串,[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）,A|B可以匹配A或B,^表示行的开头，^\d表示必须以数字开头。$表示行的结束，\d$表示必须以数字结束。js也可以匹配&#39;jsp&#39;，但是加上^js$就变成了整行匹配，就只能匹配&#39;js&#39;了</code></li><li><p>JavaScript有两种方式创建一个正则表达式：第一种方式是直接通过/正则表达式/写出来，第二种方式是通过new RegExp(‘正则表达式’)创建一个RegExp对象。</p><pre><code>var re1 = /as\_32/; // 最好,不用考虑转义问题var re2 = new RegExp(“as\\_32”);// 如果使用第二种写法，因为字符串的转义问题，字符串的两个\\实际上是一个\//RegExp对象的test()方法用于测试给定的字符串是否符合条件re1.test(&apos;sfdf&apos;);// 返回false</code></pre></li><li><p>用()表示的就是要提取的分组（Group）,exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。exec()方法在匹配失败时返回null</p><pre><code>var re = /^(\d{3})-(\d{3,8})$/;re.exec(&apos;010-12345&apos;); // [&apos;010-12345&apos;, &apos;010&apos;, &apos;12345&apos;]</code></pre></li><li>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符,加个?就可以让\d+采用非贪婪匹配</li><li><code>g表示全局匹配,var r1 = /test/g;// 等价于:var r2 = new RegExp(&#39;test&#39;, &#39;g&#39;);指定i标志，表示忽略大小写，m标志，表示执行多行匹配</code></li><li>注意,在范围匹配[]中,字符要加上反斜杠\,在一般匹配中不需要</li><li><code>[a-zA-Z_]其实就是\w</code></li><li>JSON序列化:JSON.stringify(object,[propertyName:value],’  ‘); 第二个参数用于控制如何筛选对象的键值，标明指定属性可以输出指定的属性,也可以传入函数进行处理,可以不写,第三个参数是缩进</li><li>反序列化:JSON.parse()把它变成一个JavaScript对象</li><li>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。<code>xiaoming.__proto__ = Student;</code></li><li>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</li><li>如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;</li><li>造函数首字母应当大写，而普通函数首字母应当小写</li></ul><p><br></p><p>花了一个周末学习一下前端方面的知识,笔记略微粗糙,复习时再做修正.</p>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 大前端时代。 &lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.chenyalun.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://blog.chenyalun.com/tags/HTML/"/>
    
      <category term="CSS" scheme="http://blog.chenyalun.com/tags/CSS/"/>
    
      <category term="JavaScript" scheme="http://blog.chenyalun.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>读博客之笔记二</title>
    <link href="http://blog.chenyalun.com/2016/11/10/%E8%AF%BB%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://blog.chenyalun.com/2016/11/10/读博客之笔记二/</id>
    <published>2016-11-10T08:02:17.000Z</published>
    <updated>2017-04-04T09:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 许多鞭辟入里的文章。 </p><a id="more"></a><h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>零零碎碎花了一个多星期才把王中周前辈的博客看完,文章比较详细,许多底层的东西我读了好几遍才理解,受益匪浅,把重要的知识点记下来,作复习之用.</p><h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><p>self 是类的隐藏的参数，指向当前调用方法的类，另一个隐藏参数是 _cmd，代表当前类方法的 selector。super 只是一个“编译器指示符”(编译器特性)，它和 self 指向的是相同的消息接收者。不同的是，super 告诉编译器，要去调用父类的方法，而不是本类里的。当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法。</p><h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p><code>id objc_msgSend(id theReceiver, SEL theSelector, ...)</code></p><p>以<code>[self setName:]</code> 为例，编译器会替换成调用<code>objc_msgSend</code> 的函数调用，其中 theReceiver 是 self，theSelector 是 <code>@selector(setName:)</code>，这个 selector 是从当前 self 的 class 的方法列表开始找的 setName，当找到后把对应的 selector 传递过去。</p><pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)struct objc_super {    id receiver;   Class superClass;};</code></pre><p> 而当使用<code>[super setName]</code> 调用时，会使用 <code>objc_msgSendSuper</code> 函数，结构体包含了两个成员，一个是 receiver，这个类似objc_msgSend 的第一个参数 receiver，第二个成员是记录所谓的“父类”。从 objc_super 结构体指向的 superClass 的方法列表开始找 setName 的 selector，找到后再以 <code>objc_super-&gt;receiver</code> 去调用这个 selector。</p><h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>NSNotification使用的是同步操作，如果想让NSNotification的post处和observer处异步执行，可以通过NSNotificationQueue实现。对于同一个通知，如果注册了多个观察者，则这多个观察者的执行顺序和他们的注册顺序是保持一致的。observer的回调方法执行线程和post的线程保持一致，如果想让post的线程和转发的线程不同，可以通过NSNotification重定向技术实现。addObserver和removeObserver必须成对出现，或者说添加了Observer必须适时移除Observer。因为通知中心并不retain Observer，若不移除，会极易给释放的对象发送消息。</p><h4 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h4><p>普屏中1点 = 1像素，Retina屏：1点 = 2像素。人手指的最小点击范围是44pixels，所以在iPhone的很多细节上都是44 pixels。使用图片资源时，方法：<code>[UIImage imageNamed:@&quot;adflower.png&quot;]]</code>，在实际运行时，如果发现当前的设备是Retina屏，会自动寻找图片”adflower@2x.png”。 <code>[UIScreen mainScreen].applicationFrame</code>获取app尺寸(去掉状态栏)，<code>[ UIScreen mainScreen].bounds</code>获取屏幕尺寸，<code>[[UIApplicationsharedApplication] statusBarFrame]</code>状态栏尺寸。</p><h4 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h4><p>在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是类对象(class object),它是一个单例(singleton),这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。任何直接或间接继承了NSObject的类，它的实例对象(instance objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个  <strong>实例对象(instace object)</strong>  所属的类的定义的一切：包括变量，方法，遵守的协议等等。 类对象并不是类的实例本身。它没有自己的实例变量，也不能执行类的实例的方法。类对象是一个功能完整的对象，也能被动态识别（dynamically typed），接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量），只是在运行时产生实例的代理。类对象是元类对象的一个实例，元类是根元类(root class’s metaclass)的实例,而根元类是其自身的实例，即根元类的isa指针指向自身。</p><p>一个消息发送给任何一个对象， 方法的检查 从对象的 isa 指针开始，然后是父类。实例方法在类中定义， 类方法 在元类和根类中定义。（根类的元类就是根类自己）。类对象(class object)中包含了类的实例变量、实例方法的定义，而元类对象(metaclass object)中包括了类的类方法的定义。类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。</p><p>①object_getClass跟随实例的isa指针，返回此实例所属的类，对于实例对象(instance)返回的是类(class),对于类(class)则返回的是元类(metaclass),<br>②<code>- class</code>方法对于实例对象(instance)会返回类(class),但对于类(class)则不会返回元类(metaclass),而只会返回类本身。<br>③class_isMetaClass可判断某类是否为元类.<br>④使用objc_allocateClassPair可在运行时创建新的类与元类对，使用class_addMethod和class_addIvar可向类中增加方法和实例变量，最后使用objc_registerClassPair注册后，就可以使用此类了。</p><h4 id="alloc方法"><a href="#alloc方法" class="headerlink" title="alloc方法"></a>alloc方法</h4><p>通过alloc或allocWithZone方法创建对象时，</p><ol><li>cocoa会遍历该对象所有的成员变量，通过成员变量的类型来计算所需占用的内存返回一个未”初使化“过的对象。</li><li>将该新对象的引用计数(Retain Count)设置成1。</li><li>该新对象的isa成员变量指向它的类对象。</li><li>将该新对象的所有其它成员变量的值设置成零。（根据成员变量类型的不同，零有可能是指nil或0）</li><li>返回指向该对象的一个指针。</li></ol><h4 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h4><p>大部分情况下，我们都不希望所有成员变量都是零，所以<br>①init方法做初使化工作，让对象的成员变量的值符合我们程序逻辑中的初始化状态。<br>②返回真正可以使用的指向该对象的指针<br>某些情况下，init会造成alloc的原本空间不够用，而进行第二次分配内存空间。所以下面的写法是错的：</p><pre><code>NSString  *s=[NSString alloc];[s init];// 这儿init返回的地址可能会变。s原本的指针地址可能是无效的地址。</code></pre><p>正确的写法是<code>NSString  *s=[[NSString alloc] init];</code><br>new简单地等价于 alloc + init，但不能指定init的参数，很少用。<br>NSInteger是一个有符号型int，它与int的区别就在于NSInteger可以自动识别机器是32位还是64位。NSInteger的无符号版本是NSUInteger。</p><h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><p>消息只有到运行时才会和函数实现绑定起来，而不是按照编译好的逻辑一成不变的执行。编译阶段只是确定了要去向receiver对象发送message消息，但是却没有发送，真正发送是等到运行的时候进行。NSObject 类定义了description方法,返回该类内容的字符串表示。某些 NSObject 的方法只是简单地从运行时系统中获得信息,从而允许对象进行一定程度的自我检查。<br>例如,class 返回对象的类;<code>isKindOfClass:</code>和 <code>isMemberOfClass:</code>则检查对象是否在指定的 类继承体系中;<code>respondsToSelector:</code>检查对象能否响应指定的消息;<code>conformsToProtocol:</code> 检查对象是否实现了指定协议类的方法;<code>methodForSelector:</code>则返回指定方法实现的地址。</p><p>①message（消息）<br>message 是一种抽象，包括了函数名+参数列表，并没有实际的实体存在。<br>②method（方法）<br>method是真正的存在的代码。如：<code>- (int)meaning { return 42; }</code><br>③selector（方法选择器）<br>selector 通过SEL类型存在，描述一个特定的method 或者说 message。在实际编程中，可以通过selector进行检索方法等操作。</p><h4 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h4><p>它是一个<code>char *</code>指针，仅仅表示它所代表的方法名字。</p><pre><code>typedef struct objc_selector *SEL;      SEL selector = @selector(message); //@selector不是函数调用，只是给编译器的一个提示       NSLog (@&quot;%s&quot;, (char *)selector); //print message   </code></pre><p>Objective-C在编译的时候，会根据方法的名字，生成一个用来区分这个方法的唯一的一个ID，这个ID就是SEL类型的（生成唯一的SEL）。只要方法的名字相同，那么它们的ID都是相同的。编译器会根据每个方法的方法名为那个方法生成唯一的SEL，这些SEL组成了一个Set集合，这个Set简单的说就是一个经过了优化过的hash表。SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，从而加快方法的查询速度。</p><h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p><code>typedef id (*IMP)(id, SEL, ...);</code><br>由于每个方法都对应唯一的SEL，可以通过SEL方便、快速、准确的获得它所对应的IMP（也就是函数指针），而在取得了函数指针之后，也就意味着取得了执行这段方法的代码的入口，这样就可以像普通的C语言函数调用一样使用这个函数指针。</p><pre><code>void (* performMessage)(id,SEL);//定义一个IMP（函数指针）   performMessage = (void (*)(id,SEL))[self methodForSelector:@selector(message)];//通过methodForSelector方法根据SEL获取对应的函数指针   performMessage(self,@selector(message));//通过取到的IMP（函数指针）跳过runtime消息传递机制，直接执行message方法。</code></pre><p>用IMP 的方式，省去了runtime消息传递过程中所做的一系列动作，比直接向对象发送消息高效一些。</p><h4 id="消息调用流程"><a href="#消息调用流程" class="headerlink" title="消息调用流程"></a>消息调用流程</h4><p>消息表达式[receiver message]在被转换成objc_msgSend(receiver, SEL)后，在运行时，runtime system会做以下事情：</p><ul><li><p>1、检查忽略的Selector（比如将会忽略retain和release消息）。</p></li><li><p>2、检查receiver是否为nil。（如果receiver为空，则会将 selector也设置为空，并且直接返回到消息调用的地方。）如果对象非空，就继续下一步。</p></li><li><p>3、根据SEL到当前类中查找对应的IMP，首先会在cache中检索它，如果找到了就根据函数指针跳转到这个函数执行，否则进行下一步。</p></li><li><p>4、检索当前类对象中的方法表（method list），如果找到了，加入cache中，并且就跳转到这个函数执行，否则进行下一步。</p></li><li><p>5、从父类中寻找,直到根类：NSObject类。找到了就将方法加入对应类的cache表中，如果仍未找到，则要进入动态方法决议。</p></li><li><p>6、如果动态方法决议仍不能解决问题，只能进行最后一次尝试，进入消息转发流程。</p></li></ul><p>注意：cache的原则就是缓存那些可能要执行的函数地址，下次调用的时候，速度就可以快速很多。</p><p>类方法和实例方法中，都可以访问self和_cmd这两个属性，因为它们都不属于类的实例变量，而是形参。objc_msgSend找到方法对应的实现时,将直接调用该方法实现,并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:接收消息的对象（也就是self指向的内容），方法选标（_cmd指向的内容）</p><p>”隐藏“：因为它们并没有在定义方法的源代码中声明,而是在代码编译时是插入方法的实现中的。在方法中可以通过 self 来引用消息接收者对象,通过选标_cmd 来引用方法本身。</p><pre><code>- (void)message  {      self.name = @&quot;James&quot;;//通过self关键字给当前对象的属性赋值      SEL currentSel = _cmd;//通过_cmd关键字取到当前函数对应的SEL      NSLog(@&quot;currentSel is :%s&quot;,(char *)currentSel);  } </code></pre><p> 当被调用的方法实现部分没有找到，而消息转发机制启动之前的这个中间时刻(动态添加方法)。<code>+(BOOL) resolveInstanceMethod:(SEL) sel</code>将被调用。这是NSObject根类提供的类方法。<br> @dynamic关键字的作用:①告诉编译器不要创建实现属性所用的实例变量；②告诉编译器不要创建该属性的get和setter方法。让编译器相信存取方法会在运行时找到。</p><pre><code>// 声明文件中@property(nonatomic,retain) NSString    *name; // 实现文件中@dynamic name;  </code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>默认情况下，编译器会为当前类自动生成一个NSString   <em>_name的实例变量（如果想改变实例变量的名称可以用@synthesize关键字），同时会生成两个名为` - (NSString </em>)name<code>和</code>- (void)setName:(NSString *)aName`的存取方法。</p><pre><code>void dynamicMethodIMP(id self, SEL _cmd)  {      // implementation ....  }  + (BOOL)resolveInstanceMethod:(SEL)sel  {      NSLog(@&quot;sel is %@&quot;, NSStringFromSelector(sel));      if(sel == @selector(setName:)){          class_addMethod([self class],sel,(IMP)dynamicMethodIMP,&quot;v@:&quot;);          return YES;      }      return [super resolveInstanceMethod:sel];  }  </code></pre><h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>外部调用的某个方法对象没有实现，而且resolveInstanceMethod方法中也没有做重定向处理时，就会触发<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>方法。这个方法通常用来将不能处理的消息转发给其它的对象。</p><pre><code>-(void)forwardInvocation:(NSInvocation *)invocation  {      SEL invSEL = invocation.selector;      if ([someOtherObject respondsToSelector:invSEL])          [anInvocation invokeWithTarget:someOtherObject];      } else {          [self doesNotRecognizeSelector:invSEL];       }                                                                            }  </code></pre><h4 id="Cocoa"><a href="#Cocoa" class="headerlink" title="Cocoa"></a>Cocoa</h4><p>它是一个面向对象的软件组件——类的集成套件，它使开发者可以快速创建强壮和全功能的 Mac OS X （IOS）应用程序。Cocoa包含了很多框架，其中最最核心的是Foundation框架和Application Kit（AppKit）框架（Cocoa Touch中叫UIKit框架）。</p><p>imageNamed的优点在于可以缓存已经加载的图片。这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回.imageWithContentsOfFile方法只是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到程序。当不需要重用该图像，或者需要将图像以数据方式存储到数据库，又或者要通过网络下载一个很大的图像时，可以使用这种方式。</p><h4 id="run-loop"><a href="#run-loop" class="headerlink" title="run loop"></a>run loop</h4><p>它是为了线程而生,是线程的基础架构部分，每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。主线程的run loop默认是启动的。UIApplicationMain()函数，会为main thread设置一个NSRunLoop对象.NSRunLoop类并不是线程安全的,不能在一个线程中去操作另外一个线程的run loop对象,CFRunLoopRef是线程安全的.获取到当前线程的run loop:<code>[NSRunLoop currentRunLoop];</code>获取对应的CFRunLoopRef类<code>- (CFRunLoopRef)getCFRunLoop;</code><br>一个run loop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。对消息处理过程进行了更好的抽象和封装，在NSRunLoop中每一个消息就被打包在input source或者是timer source中了。使用run loop可以使线程在有工作的时候工作，没有工作的时候休眠，这可以大大节省系统资源。创建输入源的时候，需要将其分配给run loop中的一个或多个模式.定时源在预设的时间点同步方式传递消息，这些消息都会发生在特定时间或者重复的时间间隔。定时源则直接传递消息给处理例程，不会立即退出run loop。</p><h4 id="创建NSTimer"><a href="#创建NSTimer" class="headerlink" title="创建NSTimer"></a>创建NSTimer</h4><pre><code>// 方式一:自动把timer加入MainRunloop的NSDefaultRunLoopMode中NSTimer *timer = [NSTimer scheduledTimerWithTimeInteral:1.0 target:self selector:@selector(action:) userInfo:ni] repeat:NO];// 停止[timer invalidate];// 方式二(需手动加到run loop中)   NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self seletor:@selector(timerAction) userInfo:nil repeats:YES];   [[NSRunloop mainRunloop] addTimer:timer forMode:NSDefaultRunloopMode];</code></pre><p>特点:调用创建方法后,target对象的引用计数会+1,直到执行完毕,自动-1.如果RunLoop正在执行一个连续的运算,timer就会被延迟触发</p><h4 id="响应者对象（Responder-Object）"><a href="#响应者对象（Responder-Object）" class="headerlink" title="响应者对象（Responder Object）"></a>响应者对象（Responder Object）</h4><p>指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。</p><h4 id="响应者链"><a href="#响应者链" class="headerlink" title="响应者链"></a>响应者链</h4><p>通常是由视图（UIView）构成的；</p><ul><li>一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）；</li><li>视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图；</li><li>单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者.</li><li>单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。<br>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:</li></ul><h4 id="方法的处理流程"><a href="#方法的处理流程" class="headerlink" title="方法的处理流程"></a>方法的处理流程</h4><p>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；<br>若返回NO,则hitTest:withEvent:返回nil;<br>若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；<br>若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；<br>如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。</p><p>非正式协议通常定义为NSObject的类别。</p><h4 id="类别与类扩展的区别："><a href="#类别与类扩展的区别：" class="headerlink" title="类别与类扩展的区别："></a>类别与类扩展的区别：</h4><p>①类别中只能增加方法；<br>②类扩展不仅可以增加方法，还可以增加实例变量（或者合成属性），只是该实例变量默认是@private类型的；<br>③类扩展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中。<br>④类扩展所声明的方法必须依托对应类的实现部分来实现。<br>⑤定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。</p><h4 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h4><p>全称是Key-value coding，翻译成键值编码。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。KVO全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。KVO机制很适合实现model和controller类之间的通讯。<br>KVC是不会自动调用键值验证方法的，我们需要手动验证。<code>- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</code><br>KVC可以自动的将数值或结构体型的数据打包或解包成NSNumber或NSValue对象，以达到适配的目的。<br>代码片段存放路径<code>~/Library/Developer/Xcode/UserData/CodeSnippets</code><br>ARC的英文全名是：Automatic Reference Counting，是编译器提供的管理Objective-C对象内存的一个机制。它并不是像垃圾回收机制那样，有一个负责内存回收的系统，而是仍然以引用计数为基础：在编译阶段，编译器会在需要retain或release对象的地方自动为我们加上对应的代码。</p><h4 id="内存管理规则"><a href="#内存管理规则" class="headerlink" title="内存管理规则"></a>内存管理规则</h4><p>一个Object-C对象存在strong类型的指针指向时，该对象就不会被释放。<br>①strong<br>该属性值对应 <code>__strong</code>关键字，即该属性所声明的指针变量将成为对象的持有者。strong是指向Objective-C对象指针的默认属性。<br>②weak<br>该属性对应<code>__weak</code>关键字，与<code>__weak</code>定义的变量一致，该属性所声明的变量将没有对象的所有权，并且当对象被破弃之后，对象将被自动赋值nil。<br>④copy<br>也是对象的所有者，与strong的区别是声明的指针变量是拷贝对象的持有者。<br>⑤assign<br>一般数值型变量用该属性声明，比如,int, BOOL，但无需显示写出，因为数值型变量的默认属性类型就是assign</p><p>使用关键字声明指针类型规范写法:</p><pre><code>//规范的写法MyClass * __weak myWeakReference;</code></pre><h4 id="weak和assign的异同"><a href="#weak和assign的异同" class="headerlink" title="weak和assign的异同"></a>weak和assign的异同</h4><p>相同点：指向的对象都是随时有可能被释放，即不拥有指向的对象<br>不同点：①weak只能用来声明Objective-C对象，assign既可以用来声明对象，也可以用来声明数值型变量；②很关键的一点区别，当一个weak关键字声明的指针指向的对象被释放掉得时候，该指针会自动的被指向nil而assign不存在该特性.</p><p>使用@property声明或作为普通实例变量声明的指向Objective-C对象的指针属性默认都是strong；而使用@property声明的数值型变量属性默认的是assign，普通的数值型变量的属性是__unsafe_unretaind。</p><table><thead><tr><th>属性</th><th>关键字</th><th>所有权</th></tr></thead><tbody><tr><td>strong</td><td>__strong</td><td>有</td></tr><tr><td>copy</td><td>__strong</td><td>有</td></tr><tr><td>retain</td><td>__strong</td><td>有</td></tr><tr><td>weak</td><td>__weak</td><td>无</td></tr><tr><td>assign</td><td>__unsafe_unretained</td><td>无</td></tr><tr><td>unsafe_unretained</td><td>__unsafe_unretained</td><td>无</td></tr></tbody></table><h4 id="使用ARC需要遵守的新规则"><a href="#使用ARC需要遵守的新规则" class="headerlink" title="使用ARC需要遵守的新规则"></a>使用ARC需要遵守的新规则</h4><p>①不要在dealloc方法中调用[super dealloc];<br>②不能使用 retain/release/retainCount/autorelease<br>③不能使用 NSAllocateObject/NSDeallocateObject<br>④不能使用 NSZone<br>⑤Objective-C 对象不能作为C语言结构体（struct/union）的成员</p><h4 id="instancetype"><a href="#instancetype" class="headerlink" title="instancetype"></a>instancetype</h4><p>表示某个方法返回的未知类型的Objective-C对象,instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型,能够确定对象的类型.有利于开发者在编译阶段发现错误。<br>关联返回类型（related result types）1、类方法中，以alloc或new开头2、实例方法中，以autorelease，init，retain或self开头.<br>instancetype和id的异同: 1、相同点:都可以作为方法的返回类型<br>2、不同点<br>①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；<br>②instancetype只能作为返回值，不能像id那样作为参数</p><h4 id="沙盒目录："><a href="#沙盒目录：" class="headerlink" title="沙盒目录："></a>沙盒目录：</h4><p>1、MyApp.app<br>存放应用程序本身的数据,整个目录是只读的,不能被iTunes同步<br>2、Documents<br>存放不可再生的的数据文件,会被iTunes同步.<br>3、Library<br>存放默认设置或其它状态信息。<br>除了Caches子目录外,会被iTunes同步.<br>4、Library/Caches<br>存放缓存文件，保存那些可再生的文件,不会被iTunes同步<br>5、Library/Preferences<br>存放应用程序的偏好设置文件。我们使用NSUserDefaults写的设置数据都会保存到该目录下的一个plist文件中，会被iTunes同步<br>6、tmp<br>存放各种临时文件,不会被iTunes同步</p><h4 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h4><p>采用散列表来管理引用计数,统一存储所有对象的引用计数,不用考虑每个对象内存块中引用计数所占的内存,在引用计数表中存储各个对象的内存地址.<br>NULL本质上是：(void<em>)0,表示C指针为空,如`charchar </em>string = NULL; <code>nil本质上是：(void *)0,表示指向Objective-C中对象的指针为空Nil本质上也是：(void *)0,表示Objective-C中Class类型的变量值为空,</code>Class anyClass = Nil;  `</p><h4 id="NSNull"><a href="#NSNull" class="headerlink" title="NSNull"></a>NSNull</h4><p>是一个Objective-C类,该类通常用于在集合对象中保存一个空的占位对象</p><pre><code>// 遇到nil截断NSArray *arr = [NSArray arrayWithObjects:@&quot;wang&quot;,@&quot;zz&quot;,nil,@&quot;foogry&quot;];// 存储空的占位对象NSArray *arr = [NSArray arrayWithObjects:@&quot;wang&quot;,@&quot;zz&quot;,[NSNull null],@&quot;foogry&quot;];</code></pre><blockquote><p>向作者致谢!<br>王中周的个人博客:<a href="http://blog.csdn.net/wzzvictory" target="_blank" rel="external">http://blog.csdn.net/wzzvictory</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 许多鞭辟入里的文章。 &lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>读博客之笔记一</title>
    <link href="http://blog.chenyalun.com/2016/10/28/%E8%AF%BB%E5%8D%9A%E5%AE%A2%E4%B9%8B%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://blog.chenyalun.com/2016/10/28/读博客之笔记一/</id>
    <published>2016-10-28T11:22:17.000Z</published>
    <updated>2017-04-04T09:19:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017.4.3 修改<br>2016.12.4 修改</p></blockquote><p align="center"> C语言方面。 </p><a id="more"></a><h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>这次零零碎碎花了一周时间拜读李明杰老师的博客,很多知识点理解地更透彻了,尤其是C语言方面的.不太熟悉或将近遗忘的知识点记录下来,做复习巩固之用.起初使用笔记的方式记录,但是达不到我想要的效果,于是尝试以问答的形式记录,而且以后的笔记也采用这种方式</p><h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><h2 id="1-C语言中怎么控制输入与输出格式"><a href="#1-C语言中怎么控制输入与输出格式" class="headerlink" title="1.C语言中怎么控制输入与输出格式"></a>1.C语言中怎么控制输入与输出格式</h2><figure class="highlight perl"><table><tr><td class="code"><pre><div class="line"><span class="keyword">printf</span>(<span class="string">"My height is %8.1f"</span>, <span class="number">179.95</span>f);<span class="regexp">//</span> 左对齐,小数点后<span class="number">1</span>位        </div><div class="line">   </div><div class="line"><span class="keyword">printf</span>(<span class="string">"My height is %-4d"</span>, <span class="number">60</span>); <span class="regexp">//</span> 左对齐，右边填空格</div><div class="line">scanf(<span class="string">"%d-%d-%d"</span>, &amp;a, &amp;b, &amp;c);</div><div class="line">scanf(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</div><div class="line"></div><div class="line"><span class="regexp">//</span> putchar一次只能输出一个字符，而<span class="keyword">printf</span>可以同时输出多个字符</div><div class="line"><span class="keyword">int</span> a = <span class="number">65</span>;</div><div class="line">putchar(a);</div></pre></td></tr></table></figure><h2 id="2-getchar-scanf-gets的区别"><a href="#2-getchar-scanf-gets的区别" class="headerlink" title="2.getchar/scanf/gets的区别"></a>2.getchar/scanf/gets的区别</h2><p>1.gets和getchar函数可以读入空格、TAB，直到遇到回车为止。scanf则不能读入空格和TAB。</p><p>2.gets一次只能读取一个字符串,getchar一次只能读入一个字符。scanf则可以同时接收多个字符。</p><p>3.getchar还能读入回车换行符，这时候要敲2次回车键。第1次敲的回车换行符被getchar读入，第2次敲的回车键代表输入结束。</p><h2 id="3-puts-prints-putchar的区别"><a href="#3-puts-prints-putchar的区别" class="headerlink" title="3.puts/prints/putchar的区别"></a>3.puts/prints/putchar的区别</h2><p>1.putchar一次只能输出一个字符,puts函数一次只能输出一个字符串，printf函数则可以同时输出多个字符串</p><p>2.printf与puts函数会首地址开始输出字符，一直到\0字符为止。</p><h2 id="4-介绍指针"><a href="#4-介绍指针" class="headerlink" title="4.介绍指针"></a>4.介绍指针</h2><p>1.计算机中的内存是以字节为单位的存储空间,内存的每一个字节都有一个唯一的编号，这个编号就称为地址.<br>2.凡存放在内存中的程序和数据都有一个地址，也就是说，一个函数也有自己的内存地址。变量存储单元的第一个字节的地址就是该变量的地址.<br>3.通过变量名引用变量，由系统自动完成变量名和其存储地址之间的转换，称为变量的”直接引用”方式.首先将变量a的地址存放在另一个变量中，比如存放在变量b中，然后通过变量b来间接引用变量a，间接读写变量a的值。这就是”间接引用”.</p><p>4.在指针变量没有指向确定地址之前，不要对它所指的内容赋值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> *p; *p = <span class="number">10</span>; <span class="comment">//这是错误的</span></div><div class="line"></div><div class="line"><span class="comment">// 正确做法</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// 也可以int *b = &amp;a;</span></div><div class="line"><span class="keyword">int</span> *b; <span class="comment">//b是指针变量</span></div><div class="line">b = &amp;a;</div><div class="line"></div><div class="line"><span class="comment">// 通过*b间接修改a的值</span></div><div class="line">*b = <span class="number">15</span>; <span class="comment">// 根据b地址访问对应的存储值</span></div></pre></td></tr></table></figure></p><p>5.指针操作中,数组名a是个常量,不能进行赋值运算</p><pre><code>char s[10];s = &quot;mj&quot;;// 错误! s是常量</code></pre><h2 id="5-常见字符串处理函数的用法"><a href="#5-常见字符串处理函数的用法" class="headerlink" title="5.常见字符串处理函数的用法"></a>5.常见字符串处理函数的用法</h2><p>包含string.h头文件后,strlen\strcpy\strcat\strcmp函数的用法<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 测量字符串的字符个数，不包括\0</span></div><div class="line"><span class="comment">// 长度为7</span></div><div class="line"><span class="keyword">int</span> size = <span class="built_in">strlen</span>(<span class="string">"abcdefg"</span>);</div><div class="line"><span class="comment">// 长度为2</span></div><div class="line"><span class="keyword">char</span> s[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'\0'</span>,<span class="string">'c'</span>&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// 右边拷贝到左边,</span></div><div class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</div><div class="line"><span class="built_in">strcpy</span>(s, <span class="string">"abcdefg"</span>);</div><div class="line"><span class="comment">// 遇到\0截断</span></div><div class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'\0'</span>,<span class="string">'c'</span>&#125;;</div><div class="line"><span class="built_in">strcpy</span>(s,c);<span class="comment">// 结果ab</span></div><div class="line"></div><div class="line"><span class="comment">// 右边拼接到左边,遇到\0截断</span></div><div class="line"><span class="keyword">char</span> s1[<span class="number">30</span>] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'\0'</span>, <span class="string">'d'</span>&#125;;</div><div class="line"><span class="built_in">strcat</span>(s1, <span class="string">"OC"</span>);<span class="comment">// 结果abOC</span></div><div class="line"></div><div class="line"><span class="comment">// 左减右,逐字符比较ASCII码差值,直到字符不相同或者遇见'\0'为止</span></div><div class="line"><span class="built_in">strcmp</span>(s1, s2);</div></pre></td></tr></table></figure></p><p>注意:strcpy中若数组长度不足以容纳整个字符串，则程序运行崩溃</p><h2 id="6-如何使一个函数有多个返回值"><a href="#6-如何使一个函数有多个返回值" class="headerlink" title="6.如何使一个函数有多个返回值"></a>6.如何使一个函数有多个返回值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b,<span class="keyword">int</span> *c)</span> </span>&#123;</div><div class="line">    <span class="comment">// 赋值给指针指向的变量</span></div><div class="line">    *c = a + b;</div><div class="line">    <span class="keyword">return</span> a * b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> m = <span class="number">2</span>,n = <span class="number">4</span>,s1,s2;</div><div class="line">    s1 =  test(m, n, &amp;s2);</div><div class="line">    </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d---%d"</span>,s1,s2);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="7-字符串常量与字符串变量"><a href="#7-字符串常量与字符串变量" class="headerlink" title="7.字符串常量与字符串变量"></a>7.字符串常量与字符串变量</h2><p><code>char *s = &quot;mj&quot;;3 *s = &quot;like&quot;;</code><br>两个错误:<br>1,s指向的是”mj”的首字符’m’,只有一个字节,要”like”存进1个字节的空间内，肯定内存溢出.<br>2,s指向的是字符串常量”mj”,不能再通过指针来修改字符串内容(字符数组可以修改).</p><pre><code>char a[] = &quot;lmj&quot;;定义的是一个字符串变量char *p2 = &quot;lmj&quot;;定义的是一个字符串常量</code></pre><h2 id="8-返回指针的函数"><a href="#8-返回指针的函数" class="headerlink" title="8.返回指针的函数"></a>8.返回指针的函数</h2><figure class="highlight axapta"><table><tr><td class="code"><pre><div class="line"> <span class="comment">// 将字符串str中的小写字母变成大写字母，并返回改变后的字符串</span></div><div class="line"> <span class="comment">// 注意的是：这里的参数要传字符串变量，不能传字符串常量</span></div><div class="line"> <span class="keyword">char</span> * upper(<span class="keyword">char</span> *<span class="keyword">str</span>) &#123;</div><div class="line">     <span class="comment">// 先保留最初的地址。因为等会str指向的位置会变来变去的。</span></div><div class="line">     <span class="keyword">char</span> *dest = <span class="keyword">str</span>;</div><div class="line"> </div><div class="line"> <span class="comment">// 如果还不是空字符</span></div><div class="line"> <span class="keyword">while</span> (*<span class="keyword">str</span> != <span class="string">'\0'</span>) &#123;</div><div class="line">     <span class="comment">// 如果是小写字母</span></div><div class="line">     <span class="keyword">if</span> (*<span class="keyword">str</span> &gt;= <span class="string">'a'</span> &amp;&amp; *<span class="keyword">str</span> &lt;= <span class="string">'z'</span>) &#123;</div><div class="line">         <span class="comment">// 变为大写字母。小写和大写字母的ASCII值有个固定的差值</span></div><div class="line">         *<span class="keyword">str</span> -= <span class="string">'a'</span> - <span class="string">'A'</span>;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">// 遍历下一个字符</span></div><div class="line">     <span class="keyword">str</span>++;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">// 返回字符串</span></div><div class="line"> <span class="keyword">return</span> dest;</div><div class="line">&#125;</div><div class="line">        </div><div class="line">        </div><div class="line">   </div><div class="line"><span class="comment">// 调用:</span></div><div class="line"> <span class="keyword">int</span> main()</div><div class="line"> &#123;</div><div class="line">     <span class="comment">// 定义一个字符串变量</span></div><div class="line">     <span class="keyword">char</span> <span class="keyword">str</span>[] = <span class="string">"lmj"</span>;</div><div class="line">     </div><div class="line">     <span class="comment">// 调用函数</span></div><div class="line">     <span class="keyword">char</span> *dest = upper(<span class="keyword">str</span>);</div><div class="line">     </div><div class="line">     printf(<span class="string">"%s"</span>, dest);</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h2 id="9-指向函数的指针"><a href="#9-指向函数的指针" class="headerlink" title="9.指向函数的指针"></a>9.指向函数的指针</h2><p>函数名的本质就是函数的地址.<br>假定函数名为func,返回一个整型<br><code>int *a = func; // 指针a与指针func一致</code></p><p>调用的三种方式:<br><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span>; <span class="comment">// 原先的调用方式:通过指针func调用</span></div><div class="line">*a(); <span class="comment">// *a指向函数本身</span></div><div class="line">a(); <span class="comment">// 相当于func();</span></div></pre></td></tr></table></figure></p><p>实例:</p><figure class="highlight fortran"><table><tr><td class="code"><pre><div class="line"><span class="built_in">int</span> <span class="built_in">sum</span>(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">int</span> main()</div><div class="line">&#123;</div><div class="line">    // 定义一个指针变量p，指向<span class="built_in">sum</span>函数</div><div class="line">    // 把函数名替换为(*p)即可,*p就相当于<span class="built_in">sum</span></div><div class="line">    <span class="built_in">int</span> (*p)(<span class="built_in">int</span> a, <span class="built_in">int</span> b) = <span class="built_in">sum</span>;</div><div class="line">    // 或者 <span class="built_in">int</span> (*p)(<span class="built_in">int</span>, <span class="built_in">int</span>) = <span class="built_in">sum</span>;</div><div class="line">    // 或者 <span class="built_in">int</span> (*p)() = <span class="built_in">sum</span>;</div><div class="line">    </div><div class="line">    // *p就相当于<span class="built_in">sum</span></div><div class="line">    <span class="built_in">int</span> result = (*p)(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line">    // 或者</div><div class="line">    <span class="built_in">int</span> result = p(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line">    </div><div class="line">    printf(<span class="string">"%d"</span>, result);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="10-将函数作为参数在函数间传递"><a href="#10-将函数作为参数在函数间传递" class="headerlink" title="10.将函数作为参数在函数间传递"></a>10.将函数作为参数在函数间传递</h2><figure class="highlight cs"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 减法运算</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> a - b;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="comment">// 加法运算</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="comment">// 这个counting函数是用来做a和b之间的计算，至于做加法还是减法运算，由函数的第1个参数决定</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting</span>(<span class="params"> <span class="keyword">int</span> (*p</span>)(<span class="params"><span class="keyword">int</span>, <span class="keyword">int</span></span>) , <span class="keyword">int</span> a, <span class="keyword">int</span> b) </span>&#123;</div><div class="line"> <span class="keyword">int</span> result = p(a, b);</div><div class="line"> printf(<span class="string">"计算结果为：%d\n"</span>, result);</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line"> <span class="comment">// 进行加法运算,传进来函数指针sum</span></div><div class="line"> counting(sum, <span class="number">6</span>, <span class="number">4</span>);</div><div class="line"> </div><div class="line"> <span class="comment">// 进行减法运算</span></div><div class="line"> counting(minus, <span class="number">6</span>, <span class="number">4</span>);</div><div class="line"> </div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="11-宏的使用"><a href="#11-宏的使用" class="headerlink" title="11.宏的使用"></a>11.宏的使用</h2><p>1.所有预处理指令都以符号”#”开头，并且结尾不用分号,作用范围是从它出现的位置到文件尾,主要有：宏定义、文件包含、条件编译.</p><p>2.使用带参数的宏定义,最好将参数和结果都用括号括起来.</p><p>3.宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值<br>问题,宏替换只在编译预处理阶段进行,带参数的宏比函数具有更高的执行效率.</p><p>4.条件编译<br><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line"><span class="selector-id">#if</span> 条件<span class="number">1</span></div><div class="line"> ..<span class="selector-class">.code1</span>...</div><div class="line"><span class="selector-id">#elif</span> 条件<span class="number">2</span></div><div class="line"> ..<span class="selector-class">.code2</span>...</div><div class="line"><span class="selector-id">#else</span></div><div class="line"> ..<span class="selector-class">.code3</span>...</div><div class="line"><span class="selector-id">#endif</span></div><div class="line"></div><div class="line"><span class="selector-id">#if</span> defined(MAX)</div><div class="line">     ..<span class="selector-class">.code</span>...</div><div class="line"><span class="selector-id">#endif</span></div><div class="line"></div><div class="line"><span class="selector-id">#if</span> !defined(MAX)</div><div class="line">     ..<span class="selector-class">.code</span>...</div><div class="line">#endif</div></pre></td></tr></table></figure></p><h2 id="12-include中-lt-gt-与””的区别"><a href="#12-include中-lt-gt-与””的区别" class="headerlink" title="12.include中&lt;&gt;与””的区别"></a>12.include中&lt;&gt;与””的区别</h2><p><code>#include　&lt;文件名&gt;</code>到C语言库函数头文件所在的目录中寻找文件<br><code>#include　&quot;文件名&quot;</code>系统会先在源程序当前目录下寻找，若找不到，再到操作系统的path路径中查找，最后才到C语言库函数头文件所在目录中查找.</p><h2 id="13-如何避免-include重复包含同一个头文件"><a href="#13-如何避免-include重复包含同一个头文件" class="headerlink" title="13.如何避免#include重复包含同一个头文件"></a>13.如何避免#include重复包含同一个头文件</h2><p>使用条件编译<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ONE_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _ONE_H_</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span></span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p><h2 id="14-变量的作用域"><a href="#14-变量的作用域" class="headerlink" title="14.变量的作用域"></a>14.变量的作用域</h2><p>1.在函数内部定义的变量，称为局部变量。形式参数也属于局部变量,在所有函数外部定义的变量，称为全局变量.</p><p>2.所有的局部变量在默认情况下都是自动变量,是存储在堆栈中的.所有的全局变量和被关键字static修饰的局部变量都是静态变量,是存储在静态内存中的，也就是不属于堆栈.</p><p>3.静态变量在程序运行之前创建，在程序的整个运行期间始终存在，直到程序结束。在程序执行到声明自动变量的代码块(函数)时，自动变量才被创建；当自动变量所在的代码块(函数)执行完毕后，这些自动变量就会自行销毁.</p><p>4.被关键字<strong>register修饰</strong>的<strong>自动变量</strong>都是寄存器变量,是存储在硬件寄存器中的,其生命周期即是自动变量的生命周期.寄存器变量只限于int、char和指针类型变量使用,将一些频繁使用的自动变量定义为寄存器变量，这样程序尽可能地为它分配寄存器存放，而不用内存.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">register</span> <span class="keyword">int</span> a;</div><div class="line"><span class="keyword">register</span> <span class="keyword">char</span> b;</div><div class="line"><span class="keyword">register</span> <span class="keyword">int</span> *c;</div></pre></td></tr></table></figure><h2 id="15-编译链接流程"><a href="#15-编译链接流程" class="headerlink" title="15.编译链接流程"></a>15.编译链接流程</h2><p>1.如果一个程序中有多个源文件(.c)，编译成功会生成对应的多个目标文件(.obj)，这些目标文件不能单独运行，因为这些目标文件之间可能会有关联。将这些相关联的目标文件链接在一起后才能生成可执行文件。</p><p>2.所谓编译，就是单独检查每个源文件的语法是否合理，并不会检查每个源文件之间的关联关系，一个源文件编译成功就生成一个目标文件。所谓链接，就是检查目标文件的关联关系，将相关联的目标文件组合在一起，生成可执行文件。</p><p>3.根据在当前文件中定义的函数是否允许其他文件访问,可将函数分为内部函数和外部函数.默认情况下，所有的函数都是外部函数,不允许重复定义同一个外部函数.</p><h2 id="16-extern与static关键字的作用"><a href="#16-extern与static关键字的作用" class="headerlink" title="16.extern与static关键字的作用"></a>16.extern与static关键字的作用</h2><p>使用extern关键字，表示引用其他文件的”外部函数”: <code>extern void test();</code>,然而extern可以省略,故直接声明即可.正规的项目里面，把”外部函数”的声明另写到一个头文件中,使用时直接包含头文件即可.</p><p>在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数),不允许其他文件访问.不同的文件中有同名的内部函数，则互不干扰。</p><p>默认情况下，一个函数不可以访问在它后面定义的全局变量.不同源文件中的同名全局变量代表着同一个变量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// a文件</span></div><div class="line"><span class="keyword">int</span> ss =<span class="number">10</span>;</div><div class="line">  </div><div class="line"><span class="comment">// b文件</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span>  ss ;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ss);<span class="comment">// 是10</span></div></pre></td></tr></table></figure><p>在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰</p><h2 id="17-如何定义结构体"><a href="#17-如何定义结构体" class="headerlink" title="17.如何定义结构体"></a>17.如何定义结构体</h2><p>定义结构体的三种形式(枚举变量的定义与之类似)</p><figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span> &#123;</div><div class="line">    <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 利用上面结构体定义结构体变量stu</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span> stu;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 直接定义结构体变量stu</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span> &#123;</div><div class="line">    <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">&#125; stu;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 定义结构体变量stu后,此结构体永不再用</span></div><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">&#125; stu;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 特殊:struct前放置typedef表示声明此"匿名"结构体的名字为Student</span></div><div class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">&#125; Student;</div></pre></td></tr></table></figure><p>注意:<br>1.定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间</p><p>2.将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参.</p><h2 id="18-结构体指针的使用"><a href="#18-结构体指针的使用" class="headerlink" title="18.结构体指针的使用"></a>18.结构体指针的使用</h2><p>结构体指针变量的定义形式：<code>struct 结构体名称 *指针变量名</code>,三种访问方式:</p><pre><code>结构体变量名.成员名(*指针变量名).成员名指针变量名-&gt;成员名</code></pre><h2 id="19-typedef的主要使用"><a href="#19-typedef的主要使用" class="headerlink" title="19.typedef的主要使用"></a>19.typedef的主要使用</h2><p>1.typedef给指针起别名:<br><figure class="highlight armasm"><table><tr><td class="code"><pre><div class="line">// 相当于char *<span class="keyword">str </span>= <span class="string">"This is a string!"</span><span class="comment">;</span></div><div class="line"><span class="keyword">String </span><span class="keyword">str </span>= <span class="string">"This is a string!"</span><span class="comment">;</span></div></pre></td></tr></table></figure></p><p>2.typedef给结构体起别名<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="built_in">CGRect</span> &#123;</div><div class="line"><span class="built_in">CGPoint</span> origin;</div><div class="line"><span class="built_in">CGSize</span> size;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CGRect</span> <span class="built_in">CGRect</span>;</div><div class="line"><span class="comment">// 为 struct CGRect 起别名叫作 CGRect</span></div></pre></td></tr></table></figure></p><p>3.typedef给指向结构体的指针起别名</p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 定义一个结构体并起别名</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">float</span> x;</div><div class="line">    <span class="keyword">float</span> y;</div><div class="line">&#125; Point;</div><div class="line"></div><div class="line"><span class="comment">// 给Point *起别名PP</span></div><div class="line"><span class="keyword">typedef</span> Point *PP;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义结构体变量</span></div><div class="line">    Point point = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</div><div class="line">    </div><div class="line">    <span class="comment">// 定义指针变量Point *p = &amp;point;</span></div><div class="line">    PP p = &amp;point;</div><div class="line">    </div><div class="line">    <span class="comment">// 利用指针变量访问结构体成员</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"x=%f，y=%f"</span>, p-&gt;x, p-&gt;y);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>4.typedef与枚举类型<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 定义枚举类型</span></div><div class="line"> <span class="keyword">enum</span> Season &#123;spring, summer, autumn, winter&#125;;</div><div class="line"> <span class="comment">// 给枚举类型enum Season起别名为Season</span></div><div class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> Season Season;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">     <span class="comment">// 定义枚举变量</span></div><div class="line">     Season s = spring;</div><div class="line">     </div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>5.typedef给指向函数的指针类型起别名<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 定义一个sum函数，计算a跟b的和</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = a + b;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d + %d = %d"</span>, a, b, c);</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*MySum)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个指向sum函数的指针变量p</span></div><div class="line">    MySum p = sum;</div><div class="line">    </div><div class="line">    <span class="comment">// 利用指针变量p调用sum函数</span></div><div class="line">    (*p)(<span class="number">4</span>, <span class="number">5</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>6.typedef与#define,给类型起别名，最好使用typedef，而不是使用#define.</p><figure class="highlight armasm"><table><tr><td class="code"><pre><div class="line"><span class="symbol">typedef</span> char *<span class="keyword">String1;</span></div><div class="line"><span class="symbol">#define</span> <span class="keyword">String2 </span>char *</div><div class="line"></div><div class="line">// 相当于char *<span class="keyword">str1;char </span>*<span class="keyword">str2;</span></div><div class="line"><span class="keyword">String1 </span><span class="keyword">str1, </span><span class="keyword">str2;</span></div><div class="line">// 相当于char *<span class="keyword">str3;char </span> <span class="keyword">str4;产生误会</span></div><div class="line"><span class="keyword">String2 </span><span class="keyword">str3, </span><span class="keyword">str4;</span></div></pre></td></tr></table></figure><h2 id="20-import与include的区别"><a href="#20-import与include的区别" class="headerlink" title="20.import与include的区别"></a>20.import与include的区别</h2><p> <code>#import</code>是一个预处理指令，作用跟C语言的<code>#include</code>类似，都是 包含(拷贝)某个文件的内容 到 预处理指令所在的位置。在OC中，使用#import来包含头文件，可以自动防止同一个头文件被包含多次。<code>#import &lt;...&gt;</code>表示包含系统自带的文件，<code>#import &quot;...&quot;</code>表示包含开发人员自己创建的文件.</p><h2 id="21-UIView显示的过程"><a href="#21-UIView显示的过程" class="headerlink" title="21.UIView显示的过程"></a>21.UIView显示的过程</h2><p>UIView之所以能显示在屏幕上，完全是因为它内部的一个层(CALayer对象)。当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了UIView的显示。<br>当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法.</p><h2 id="22-position与anchorPoint"><a href="#22-position与anchorPoint" class="headerlink" title="22.position与anchorPoint"></a>22.position与anchorPoint</h2><p>position可以用来设置CALayer在父层中的位置，它是以父层的左上角为坐标原点(0, 0);anchorPoint称为”定位点”，它决定着CALayer身上的哪个点会在position属性所指的位置。它的x、y取值范围都是0~1，默认值为(0.5, 0.5).</p><h2 id="23-Core-Animation会阻塞主线程吗"><a href="#23-Core-Animation会阻塞主线程吗" class="headerlink" title="23.Core Animation会阻塞主线程吗"></a>23.Core Animation会阻塞主线程吗</h2><p>Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程,而且是直接作用在CALayer上的，并非UIView.</p><h2 id="24-空指针"><a href="#24-空指针" class="headerlink" title="24.空指针"></a>24.空指针</h2><p>没有存储任何内存地址的指针就称为空指针(NULL指针,指向nil),空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。可以给空指针发送消息,但消息发送不出去.”野指针”不是NULL指针，是指向”垃圾”内存（不可用内存）的指针.</p><h2 id="25-不同编译器下各类型所占字节"><a href="#25-不同编译器下各类型所占字节" class="headerlink" title="25.不同编译器下各类型所占字节"></a>25.不同编译器下各类型所占字节</h2><p><img src="http://static.chenyalun.com/2017/04/03/20170403001.png" alt=""></p><blockquote><p>向作者致谢!<br>M了个J:<a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">http://www.cnblogs.com/mjios/</a></p><p>参考博客<br>C语言中文网:<a href="http://c.biancheng.net/cpp/html/88.html" target="_blank" rel="external">http://c.biancheng.net/cpp/html/88.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017.4.3 修改&lt;br&gt;2016.12.4 修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; C语言方面。 &lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://blog.chenyalun.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="C语言" scheme="http://blog.chenyalun.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="iOS开发" scheme="http://blog.chenyalun.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
