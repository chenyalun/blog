<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈亚伦</title>
  <subtitle>Write Less, Do More.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-10-25T14:05:21.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>陈亚伦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读「李明杰博客」</title>
    <link href="http://yoursite.com/2016/10/28/%E8%AF%BB%E6%9D%8E%E6%98%8E%E6%9D%B0%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/10/28/读李明杰博客/</id>
    <published>2016-10-28T11:22:17.000Z</published>
    <updated>2016-10-25T14:05:21.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 李明杰老师是我很尊敬的iOS启蒙老师. </p>

<a id="more"></a>
<h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>这次零零碎碎花了一周时间拜读他的博客,很多知识点理解的更透彻了.不太熟悉或将近遗忘的知识点记录下来,做复习巩固之用.</p>
<h1 id="钩玄"><a href="#钩玄" class="headerlink" title="钩玄"></a>钩玄</h1><ol>
<li><p>loadView、viewDidLoad及viewDidUnload的关系是怎样的?</p>
</li>
<li><p>为什么默认情况下UIImageView内的按钮无法点击?忽略视图的四种方法?</p>
</li>
<li><p>只声明一个局部int类型变量与只声明一个全局的int类型变量,却不初始化,其值是?</p>
</li>
<li><p>使用char存储大写字母A有哪两种赋值方式?</p>
</li>
<li><p>逗号表达式的运算过程<code>c = (++a, a *= 2, b = a * 5);</code>是怎样的?</p>
</li>
<li>枚举与结构体定义的三种方式?</li>
<li>为何不要在description方法中同时使用%@和self?</li>
</ol>
<h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><ol>
<li><p>不要在UIViewController的loadView方法中改变状态栏的可视性,会导致重复调用2次loadView和viewDidLoad方法.</p>
</li>
<li><p>控制打印格式</p>
<p> printf(“My height is %8.1f”, 179.95f);</p>
<p> scanf(“%d-%d-%d”, &amp;a, &amp;b, &amp;c);<br> scanf(“%d %d %d”, &amp;a, &amp;b, &amp;c);</p>
</li>
</ol>
<ol>
<li><p>计算机中的内存是以字节为单位的存储空间.<br>内存的每一个字节都有一个唯一的编号，这个编号就称为地址.<br>凡存放在内存中的程序和数据都有一个地址，也就是说，一个函数也有自己的内存地址。变量存储单元的第一个字节的地址就是该变量的地址.</p>
</li>
<li><p>二维数组的&amp;a[i] == (a+i)</p>
</li>
<li><p>gets可以读入包含空格、tab的字符串，直到遇到回车为止；<br>getchar函数可以读入空格、TAB，直到遇到回车为止。scanf则不能读入空格和TAB。scanf不能用来读取空格、tab.</p>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    char a[10];
    char b[10];
    gets(a);
    puts(a);

    scanf(&quot;%s&quot;,b);
    puts(b);
    return 0;
}
</code></pre></li>
</ol>
<pre><code>putchar(65); // A

putchar(&apos;A&apos;); // A

int a = 65;
putchar(a); // A

char c;
c = getchar();
</code></pre><ol>
<li><p>包含string.h头文件后,strlen\strcpy\strcat\strcmp函数的用法</p>
<pre><code>// 长度为2,遇空字符\0断!
int size = strlen(&quot;mj&quot;);

// 遇空字符\0断!
char s[10];
strcpy(s, &quot;lmj&quot;);

// 遇空字符\0断!
char s1[30] = &quot;LOVE&quot;;
strcat(s1, &quot;OC&quot;);

// 左减右,比字符ASCII码差值
strcmp(s1, s2);
</code></pre></li>
<li><p>通过变量名引用变量，由系统自动完成变量名和其存储地址之间的转换，称为变量的”直接引用”方式.<br>首先将变量a的地址存放在另一个变量中，比如存放在变量b中，然后通过变量b来间接引用变量a，间接读写变量a的值。这就是”间接引用”.</p>
</li>
<li><p>在指针变量没有指向确定地址之前，不要对它所指的内容赋值。<code>int *p; *p = 10; //这是错误的</code>.</p>
</li>
<li>基本数据类型作为函数实参时，只是纯粹地将值传递给形参，形参的改变并不影响实参。</li>
<li><p>如何使一个函数有多个返回值.</p>
<pre><code>int test(int a, int b,int *c) {
    // 赋值给指针指向的变量
    *c = a + b;
    return a * b;
}

int main(int argc, const char * argv[]) {
    int m = 2,n = 4,s1,s2;
    s1 =  test(m, n, &amp;s2);

    printf(&quot;%d---%d&quot;,s1,s2);
    return 0;
}
</code></pre></li>
<li>二维数组中,可以根据a[0]的地址获取其他元素的地址，使p=&amp;a[0],p+1就是a[1]的地址。这里的p+1不一定代表p的值加1，也可能是加2、加4或者加8。究竟加多少，这跟指针的类型有关.</li>
<li>指针操作中,数组名a是个常量,不能进行赋值运算！<code>*(p+i)和*(a+i)都表示数组元素a[i]</code><pre><code>char s[10];
s = &quot;mj&quot;;// 错误! s是常量
</code></pre></li>
<li>用数组名作为函数实参时，是把实参数组的首地址传递给形参数组，两个数组共同占用同一段内存空间，这样形参数组中的元素值发生变化就会使实参数组的元素值也同时变化.</li>
<li><code>char *s = &quot;mj&quot;;3 *s = &quot;like&quot;;</code>的两个错误:1,s指向的是”mj”的首字符’m’,只有一个字节,要”like”存进1个字节的空间内，肯定内存溢出.2,s指向的是字符串常量”mj”,不能再通过指针来修改字符串内容(字符数组可以修改).</li>
<li><p>分辨:</p>
<pre><code>char a[] = &quot;lmj&quot;;定义的是一个字符串变量
char *p2 = &quot;lmj&quot;;定义的是一个字符串常量
</code></pre></li>
<li><p>返回指针的函数</p>
<pre><code>   // 将字符串str中的小写字母变成大写字母，并返回改变后的字符串
   // 注意的是：这里的参数要传字符串变量，不能传字符串常量
   char * upper(char *str) {
       // 先保留最初的地址。因为等会str指向的位置会变来变去的。
       char *dest = str;

   // 如果还不是空字符
   while (*str != &apos;\0&apos;) {
       // 如果是小写字母
       if (*str &gt;= &apos;a&apos; &amp;&amp; *str &lt;= &apos;z&apos;) {
           // 变为大写字母。小写和大写字母的ASCII值有个固定的差值
           *str -= &apos;a&apos; - &apos;A&apos;;
       }

       // 遍历下一个字符
       str++;
   }

   // 返回字符串
   return dest;
}
// 调用:
   int main()
   {
       // 定义一个字符串变量
       char str[] = &quot;lmj&quot;;

       // 调用函数
       char *dest = upper(str);

       printf(&quot;%s&quot;, dest);
       return 0;
   }
</code></pre></li>
<li><p>指向函数的指针</p>
<pre><code>int sum(int a, int b) {
    return a + b;
}

int main()
{
    // 定义一个指针变量p，指向sum函数
    int (*p)(int a, int b) = sum;
    // 或者 int (*p)(int, int) = sum;
    // 或者 int (*p)() = sum;

    // 利用指针变量p调用函数
    int result = (*p)(1, 3);
    // 或者 int result = p(1, 3);

    printf(&quot;%d&quot;, result);
    return 0;
}
</code></pre></li>
</ol>
<ol>
<li><p>将函数作为参数在函数间传递</p>
<pre><code> // 减法运算
 int minus(int a, int b) {
    return a - b;
 }

// 加法运算
int sum(int a, int b) {
    return a + b;
}

// 这个counting函数是用来做a和b之间的计算，至于做加法还是减法运算，由函数的第1个参数决定
void counting( int (*p)(int, int) , int a, int b) {
    int result = p(a, b);
    printf(&quot;计算结果为：%d\n&quot;, result);
}

int main()
{
    // 进行加法运算
    counting(sum, 6, 4);

    // 进行减法运算
    counting(minus, 6, 4);

    return 0;
 }
</code></pre></li>
<li><p>所有预处理指令都以符号”#”开头，并且结尾不用分号,作用范围是从它出现的位置到文件尾,主要有：宏定义、文件包含、条件编译.</p>
</li>
<li>使用带参数的宏定义,最好将参数和结果都用括号括起来.</li>
<li>宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题,宏替换只在编译预处理阶段进行,带参数的宏比函数具有更高的执行效率.</li>
<li><p>条件编译</p>
<pre><code>#if 条件1
 ...code1...
#elif 条件2
 ...code2...
#else
 ...code3...
#endif

#if defined(MAX)
     ...code...
#endif

#if !defined(MAX)
     ...code...
#endif
</code></pre></li>
<li><p><code>#include　&lt;文件名&gt;</code>到C语言库函数头文件所在的目录中寻找文件,<code>#include　&quot;文件名&quot;</code>系统会先在源程序当前目录下寻找，若找不到，再到操作系统的path路径中查找，最后才到C语言库函数头文件所在目录中查找.</p>
</li>
<li><p>避免#include重复包含同一个头文件:使用条件编译</p>
<pre><code>#ifndef _ONE_H_
#define _ONE_H_

void one();

#endif
</code></pre></li>
<li>在函数内部定义的变量，称为局部变量。形式参数也属于局部变量,在所有函数外部定义的变量，称为全局变量.</li>
<li>所有的局部变量在默认情况下都是自动变量,是存储在堆栈中的.所有的全局变量和被关键字static修饰的局部变量都是静态变量,是存储在静态内存中的，也就是不属于堆栈.</li>
<li>静态变量在程序运行之前创建，在程序的整个运行期间始终存在，直到程序结束。在程序执行到声明自动变量的代码块(函数)时，自动变量才被创建；当自动变量所在的代码块(函数)执行完毕后，这些自动变量就会自行销毁.</li>
<li><p>被关键字register修饰的自动变量都是寄存器变量,是存储在硬件寄存器中的,其生命周期即是自动变量的生命周期.寄存器变量只限于int、char和指针类型变量使用,将一些频繁使用的自动变量定义为寄存器变量，这样程序尽可能地为它分配寄存器存放，而不用内存.</p>
<pre><code>register int a;
register char b;
register int *c;
</code></pre></li>
<li>如果一个程序中有多个源文件(.c)，编译成功会生成对应的多个目标文件(.obj)，这些目标文件不能单独运行，因为这些目标文件之间可能会有关联。将这些相关联的目标文件链接在一起后才能生成可执行文件。</li>
<li>所谓编译，就是单独检查每个源文件的语法是否合理，并不会检查每个源文件之间的关联关系，一个源文件编译成功就生成一个目标文件。所谓链接，就是检查目标文件的关联关系，将相关联的目标文件组合在一起，生成可执行文件。</li>
<li>根据在当前文件中定义的函数是否允许其他文件访问,可将函数分为内部函数和外部函数.默认情况下，所有的函数都是外部函数,不允许重复定义同一个外部函数.</li>
<li><p>使用extern关键字，表示引用其他文件的”外部函数”: <code>extern void test();</code>,然而extern可以省略,故直接声明即可.正规的项目里面，把”外部函数”的声明另写到一个头文件中,使用时直接包含头文件即可.</p>
<pre><code>#ifndef one_h
#define one_h

#include &lt;stdio.h&gt;
void test();
#endif /* one_h */
</code></pre></li>
<li><p>在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数),不允许其他文件访问.不同的文件中有同名的内部函数，则互不干扰。</p>
</li>
<li><p>默认情况下，一个函数不可以访问在它后面定义的全局变量.不同源文件中的同名全局变量代表着同一个变量</p>
<pre><code>// a文件
int ss =10;

// b文件
extern int  ss ;
printf(&quot;%d&quot;, ss);// 是10
</code></pre></li>
<li>在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰</li>
<li><p>定义结构体的三种形式(枚举变量的定义与之类似)</p>
<pre><code>struct Student {
    char *name;
    int age;
};
struct Student stu;
</code></pre></li>
</ol>
<pre><code>struct Student {
    char *name;
    int age;
} stu;



struct {
    char *name;
    int age;
} stu;
</code></pre><ol>
<li>定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量.结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列.</li>
<li>将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参.</li>
<li>结构体指针变量的定义形式：<code>struct 结构体名称 *指针变量名</code>,三种访问方式:<ul>
<li>结构体变量名.成员名</li>
<li>(*指针变量名).成员名</li>
<li>指针变量名-&gt;成员名</li>
</ul>
</li>
<li><p>typedef也可以给指针起别名:<code>typedef char *String;</code></p>
<pre><code>// 相当于char *str = &quot;This is a string!&quot;;
String str = &quot;This is a string!&quot;;
</code></pre></li>
<li><p>typedef给结构体起别名</p>
</li>
</ol>
<pre><code>    struct CGRect {
    CGPoint origin;
    CGSize size;
};
typedef struct CGRect CGRect;
</code></pre><ol>
<li><p>typedef给指向结构体的指针起别名</p>
<pre><code>#include &lt;stdio.h&gt;

// 定义一个结构体并起别名
typedef struct {
    float x;
    float y;
} Point;

// 起别名
typedef Point *PP;

int main(int argc, const char * argv[]) {
    // 定义结构体变量
    Point point = {10, 20};

    // 定义指针变量Point *p = &amp;point;
    PP p = &amp;point;

    // 利用指针变量访问结构体成员
    printf(&quot;x=%f，y=%f&quot;, p-&gt;x, p-&gt;y);
    return 0;
 }
</code></pre></li>
<li><p>typedef与枚举类型</p>
<pre><code>// 定义枚举类型
 enum Season {spring, summer, autumn, winter};
 // 给枚举类型起别名
 typedef enum Season Season;

 int main(int argc, const char * argv[]) {
     // 定义枚举变量
     Season s = spring;

     return 0;
 }
</code></pre><p>43.typedef给指向函数的指针类型起别名</p>
<pre><code>#include &lt;stdio.h&gt;

// 定义一个sum函数，计算a跟b的和
int sum(int a, int b) {
    int c = a + b;
    printf(&quot;%d + %d = %d&quot;, a, b, c);
    return c;
}

typedef int (*MySum)(int, int);

int main(int argc, const char * argv[]) {
    // 定义一个指向sum函数的指针变量p
    MySum p = sum;

    // 利用指针变量p调用sum函数
    (*p)(4, 5);

    return 0;
 }
</code></pre></li>
</ol>
<ol>
<li><p>typedef与#define,给类型起别名，最好使用typedef，而不是使用#define.</p>
<pre><code>typedef char *String1;
#define String2 char *

// 相当于char *str1;char *str2;
String1 str1, str2;
// 相当于char *str3;char  str4;产生误会
String2 str3, str4;
</code></pre></li>
<li><p>C语言的源文件拓展名为”.c”，OC的源文件拓展名为”.m”,编译器会将.m文件编译为.o目标文件.编译器只会编译.m文件，并不会编译.h文件.</p>
</li>
<li><code>#import</code>是一个预处理指令，作用跟C语言的<code>#include</code>类似，都是 包含(拷贝)某个文件的内容 到 预处理指令所在的位置。在OC中，使用#import来包含头文件，可以自动防止同一个头文件被包含多次。<code>#import &lt;...&gt;</code>表示包含系统自带的文件，<code>#import &quot;...&quot;</code>表示包含开发人员自己创建的文件.</li>
<li><code>+</code>表示静态方法,<code>-</code>表示动态方法,在.h中声明的所有方法作用域都是public类型，不能更改.成员变量默认作用域是@protected,成员变量必须写在大括号{ }里面.</li>
<li>OC建议get方法的名字跟成员变量保持一致</li>
<li>静态方法alloc分配存储空间,返回分配好内存的对象;对象的构造方法init进行初始化.</li>
<li>访问公共变量age:对象-&gt;成员变量,<code>stu-&gt;_age = 10; int a = stu-&gt;_age;</code></li>
<li>OC点语法的本质是方法调用，不是直接访问成员变量.</li>
<li>UIView之所以能显示在屏幕上，完全是因为它内部的一个层(CALayer对象)。当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了UIView的显示。</li>
<li>通过layer属性可以设置shadowColor\shadowOffset\shadowOpacity\cornerRadius\borderWidth\borderColor等;maskToBounds=YES：是强制内部的所有子层支持圆角效果，少了这个设置，是不会有圆角效果的,如果设置了maskToBounds=YES，那将不会有阴影效果.</li>
<li>CALayer是定义在QuartzCore框架中的；CGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的；UIColor、UIImage是定义在UIKit框架中的.</li>
<li>每一个UIView内部都默认关联着一个CALayer，这个Layer为Root Layer（根层）;所有的非Root Layer，也就是手动创建的CALayer对象，都存在着隐式动画。当对非Root Layer的部分属性进行相应的修改时，默认会自动产生一些动画效果，这些属性称为Animatable Properties(可动画属性)。<ul>
<li>bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画</li>
<li>backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画</li>
<li>position：用于设置CALayer的位置。修改这个属性会产生平移动画</li>
</ul>
</li>
<li>position可以用来设置CALayer在父层中的位置，它是以父层的左上角为坐标原点(0, 0);anchorPoint称为”定位点”，它决定着CALayer身上的哪个点会在position属性所指的位置。它的x、y取值范围都是0~1，默认值为(0.5, 0.5).</li>
<li>不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate.</li>
<li>当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法.</li>
<li>平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕.</li>
<li>Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程,而且是直接作用在CALayer上的，并非UIView.</li>
<li>没有存储任何内存地址的指针就称为空指针(NULL指针,指向nil),空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。可以给空指针发送消息,但消息发送不出去.”野指针”不是NULL指针，是指向”垃圾”内存（不可用内存）的指针.</li>
<li>源文件编译成功后，会生成一个.o目标文件，这就是一个二进制文件.</li>
<li><p>clang指令汇总</p>
<pre><code>编译单个c源文件，并产生一个目标文件  cc -c one.c
编译多个c源文件，并为每个文件产生一个目标文件  cc -c one.c two.c three.c
链接单个目标文件产生一个名为a.out的可执行文件  cc one.o
链接多个目标文件  cc one.o two.o three.o
编译并链接一个c源文件  cc one.c
编译并链接多个c源文件  cc one.c two.c three.c
编译一个c源文件，并把它和现存的目标文件链接在一起  cc one.o two.o three.c
可执行文件重命名加上“-o name”这个选项  cc -o abc one.c
执行可执行文件  ./a.out
</code></pre></li>
<li>当使用基本数据类型（char、int、float等）作为实参时，实参和形参之间只是值传递，修改形参的值并不影响到实参</li>
</ol>
<blockquote>
<p>向作者致谢!<br>M了个J:<a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">http://www.cnblogs.com/mjios/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 李明杰老师是我很尊敬的iOS启蒙老师. &lt;/p&gt;
    
    </summary>
    
      <category term="博记" scheme="http://yoursite.com/categories/%E5%8D%9A%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="ios开发" scheme="http://yoursite.com/tags/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C语言交换两个数值的八种方法</title>
    <link href="http://yoursite.com/2016/10/23/C%E8%AF%AD%E8%A8%80%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%80%BC%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/10/23/C语言交换两个数值的八种方法/</id>
    <published>2016-10-23T02:20:17.000Z</published>
    <updated>2016-10-25T14:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="center"> 在回顾C语言的时候,偶遇此题,因曾被其深虐,特意搜寻多种解决办法,以鞭笞岁月. </p><br><a id="more"></a><p></p>
<blockquote>
<p>编译器:XCode8.0</p>
</blockquote>
<h1 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">   int m = 5, n = 3;</div><div class="line">   m = m ^ n;</div><div class="line">   n = m ^ n;</div><div class="line">   m = m ^ n;</div><div class="line">   </div><div class="line">   printf(&quot;m:%d---n:%d&quot;,m,n);</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>异或一般是针对二进制数.</p>
<ol>
<li>两数异或,相同则得0,不同则得1</li>
<li>x ^ x = 0,x ^ 0 = x<br>第二行:  m:0101 n:0011<br>第三行:  m:0110 n:0011<br>第四行:  n:0101 m:0110<br>第五行:  m:0011 n:0101<br>此时,已完成交换.</li>
</ol>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><pre><code>int main(int argc, const char * argv[]) {
    int m = 2147483648, n = 2147483647;
    m = m + n - (n = m);
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><ol>
<li>从左向右依次进行,首先获取m与n的和,接着利用()运算符直接将m的值赋予n,此时n完成交换</li>
<li>同时()内的值是m的值,两数之和减去m值便是n的值,再将n的值赋予m,到这里m完成交换</li>
</ol>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><pre><code>int main(int argc, const char * argv[]) {
int m = 5, n = 3;
n = (long)((long)m &lt;&lt; 32 | (m = n)) &gt;&gt; 32;
printf(&quot;m:%d---n:%d&quot;,m,n);
return 0;
}
</code></pre><p>注:<code>__int64表示64位整型变量,Xcode中用long代替,VC6.0可直接使用__int64,即: b = (__int64)((__int64)a &lt;&lt; 32 | (a = b)) &gt;&gt; 32；</code></p>
<ol>
<li>(m = n):完成m的交换,()的值是n</li>
<li>(long)((long)m &lt;&lt; 32 | n):得到的结果是 <code>00...0  0101   00...0  11</code>第一部分28个0,第三部分30个0 </li>
<li>((long)((long)m &lt;&lt; 32 ) &gt;&gt; 32:得到的结果:把第三第四部分去掉,即<code>00...0  0101</code> 正好32位,且此值为m的值,再将其赋予n,完成n的交换.</li>
</ol>
<h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><pre><code>#define swap(x, y, z) ((z) = (x), (x) = (y), (y) = (z))

int main(int argc, const char * argv[]) {
    int m = 5, n = 3,t = 0;
    swap(m, n, t);
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><p>比较巧妙,把中间变量放在宏中.</p>
<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><pre><code>int main(int argc, char *argv[]) {
int m = 5, n = 3;
m = m + n;
n = m - n;
m = m - n;

printf(&quot;m:%d---n:%d&quot;,m,n);
return 0;
}
</code></pre><p>算是一种数学方法吧,但可能溢出.</p>
<h1 id="两数之积"><a href="#两数之积" class="headerlink" title="两数之积"></a>两数之积</h1><pre><code>int main(int argc, const char * argv[]) {
    int m = 5, n = 3;
    m = m * n;
    n = m / n;
    m = m / n;

    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><p>两数之和方法的变形,n不能为0,m更可能溢出.</p>
<h1 id="经典的交换函数"><a href="#经典的交换函数" class="headerlink" title="经典的交换函数"></a>经典的交换函数</h1><pre><code>void swap(int *a, int *b) {
    int temp = 0;
    temp = *a;
    *a = *b;
    *b = temp;
}

int main(int argc, const char * argv[]) {
    int m = 2147483648, n = 2147483647;
    swap(&amp;m,&amp;n);
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><h1 id="直接添加变量"><a href="#直接添加变量" class="headerlink" title="直接添加变量"></a>直接添加变量</h1><pre><code>int main(int argc, const char * argv[]) {
    int m = 2147483648, n = 2147483647,temp = 0;
    temp = m;
    m = n;
    n = temp;
    printf(&quot;m:%d---n:%d&quot;,m,n);
    return 0;
}
</code></pre><h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><p>int最大值，根据编译器类型不同而变化。<br>1 对于16位编译器，int占16位(2字节)。<br>int的最大值为32767.<br>2 对于32位和64位编译器，int占32位(4字节)。<br>int的最大值为2147483647</p>
<p>3 可以通过打印sizeof(int)查看平台对应的int占用字节数。乘8后即为位数。<br>最高位为符号位，如位数为n，则最大值为<br>2^(n-1)<br>即2的n-1次幂。</p>
<pre><code>printf(&quot;%lu&quot;,sizeof(int));
int a = 2147483648;
</code></pre><blockquote>
<p>参考并致谢:<br><a href="http://blog.csdn.net/ljx_5489464/article/details/50042571" target="_blank" rel="external">http://blog.csdn.net/ljx_5489464/article/details/50042571</a><br><a href="http://kiya.space/2013/07/26/c%E8%AF%AD%E8%A8%80swap(a,b)%E5%80%BC%E4%BA%A4%E6%8D%A2%E7%9A%844%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E2%80%A6/" target="_blank" rel="external">http://kiya.space/2013/07/26/c%E8%AF%AD%E8%A8%80swap(a,b)%E5%80%BC%E4%BA%A4%E6%8D%A2%E7%9A%844%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E2%80%A6/</a><br><a href="http://www.itdadao.com/articles/c15a428576p0.html" target="_blank" rel="external">http://www.itdadao.com/articles/c15a428576p0.html</a><br><a href="http://www.cnblogs.com/kubixuesheng/p/4104800.html" target="_blank" rel="external">http://www.cnblogs.com/kubixuesheng/p/4104800.html</a><br><a href="https://www.byvoid.com/blog/c-int64" target="_blank" rel="external">https://www.byvoid.com/blog/c-int64</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;p align = &quot;center&quot;&gt; 在回顾C语言的时候,偶遇此题,因曾被其深虐,特意搜寻多种解决办法,以鞭笞岁月. &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS学习笔记一：Cocoapods的安装与使用</title>
    <link href="http://yoursite.com/2016/10/10/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9ACocoapods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/10/10/iOS学习笔记一：Cocoapods的安装与使用/</id>
    <published>2016-10-10T04:50:17.000Z</published>
    <updated>2016-10-25T14:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> Cocoapods是非常好用的第三方库管理工具. </p>

<a id="more"></a>
<h1 id="升级Gem"><a href="#升级Gem" class="headerlink" title="升级Gem"></a>升级Gem</h1><pre><code>sudo gem update --system
</code></pre><h1 id="切换Cocoapods的数据源"><a href="#切换Cocoapods的数据源" class="headerlink" title="切换Cocoapods的数据源"></a>切换Cocoapods的数据源</h1><pre><code># 1.删除
gem sources --remove https://rubygems.org/

# 2.添加淘宝数据源
gem sources -a https://ruby.taobao.org/

# 3.查看
gem sources -l
</code></pre><h1 id="安装Cocoapods"><a href="#安装Cocoapods" class="headerlink" title="安装Cocoapods"></a>安装Cocoapods</h1><pre><code>sudo gem install cocoapods
或者（如10.11系统）
sudo gem install -n /usr/local/bin cocoapods
</code></pre><h2 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h2><pre><code>Error installing pods:activesupport requires Ruby version &gt;= 2.2.2
</code></pre><p>解决方式:</p>
<h3 id="安装-RVM"><a href="#安装-RVM" class="headerlink" title="安装 RVM"></a>安装 RVM</h3><pre><code>curl -L get.rvm.io | bash -s stable  
</code></pre><p>等待。</p>
<pre><code>source ~/.bashrc  
source ~/.bash_profile  
</code></pre><p>测试是否安装成功。</p>
<pre><code>rvm -v  
</code></pre><h3 id="用RVM升级Ruby"><a href="#用RVM升级Ruby" class="headerlink" title="用RVM升级Ruby"></a>用RVM升级Ruby</h3><pre><code># 1.查看当前ruby版本  
ruby -v  
# 显示 ruby 1.8.7  

# 2.列出已知的ruby版本  
rvm list known  

# 3.安装ruby 2.3  
rvm install 2.3  
</code></pre><p>安装完成之后ruby -v查看是否安装成功。</p>
<h1 id="更换托管地址"><a href="#更换托管地址" class="headerlink" title="更换托管地址"></a>更换托管地址</h1><ul>
<li><p>将Podspec文件托管地址从github切换到国内的oschina或者coding。</p>
</li>
<li><p>注意:如果pod setup 可以将github的代码下载得动，那就不用去更换托管地址了。</p>
<pre><code># 1.先移除
pod repo remove master

# 2.再添加
pod repo add master https://git.coding.net/CocoaPods/Specs.git

# 3.再更新
pod repo update
</code></pre></li>
</ul>
<h1 id="设置pod仓库-初始化Cocoapods"><a href="#设置pod仓库-初始化Cocoapods" class="headerlink" title="设置pod仓库(初始化Cocoapods)"></a>设置pod仓库(初始化Cocoapods)</h1><pre><code>pod setup 
# 会将Specs.git的代码下载到~/.cocoapods/repo/master,自己前往查看是否有文件
# 如果还是太慢，尝试下
pod install --verbose
</code></pre><h2 id="报错解决-1"><a href="#报错解决-1" class="headerlink" title="报错解决"></a>报错解决</h2><pre><code>[!] To setup the master specs repo, please run `pod setup`.
</code></pre><p>手动下载代码解决:</p>
<pre><code># 1.手动克隆文件至该目录
git clone https://git.coding.net/CocoaPods/Specs.git ~/.cocoapods/repos/master

# 2.初始化,完成后显示Setup completed
pod setup  
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code># 如果有版本号，则说明已经pod安装成功
pod --version
# 如果~/.cocoapods/repo/master目录下有文件,说明文件下载成功
</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>利用Cocoapods来安装第三方框架</p>
<ol>
<li>进入要安装框架的项目的.xcodeproj同级文件夹</li>
<li>在该文件夹中新建一个文件podfile</li>
<li><p>在文件中告诉cocoapods需要安装的框架信息</p>
<p>a.该框架支持的平台<br>b.适用的iOS版本<br>c.框架的名称<br>d.框架的版本</p>
</li>
</ol>
<h2 id="Podfile文件格式"><a href="#Podfile文件格式" class="headerlink" title="Podfile文件格式"></a>Podfile文件格式</h2><pre><code>platform :ios, &apos;9.0&apos;
target &apos;你的项目名称&apos; do
pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;
end     
</code></pre><h2 id="创建Podfile文件"><a href="#创建Podfile文件" class="headerlink" title="创建Podfile文件"></a>创建Podfile文件</h2><p>进入.xcodeproj同级文件夹下</p>
<pre><code># 初始化:会生成模板的Podfile文件
pod init  

# 或者手动创建Podfile文件
touch Podfile
</code></pre><h2 id="添加自己需要的第三方库"><a href="#添加自己需要的第三方库" class="headerlink" title="添加自己需要的第三方库"></a>添加自己需要的第三方库</h2><pre><code>pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;

# If you are using Swift, be sure to add use_frameworks! and set your target to iOS 8+:
pod &apos;SDWebImage&apos;, &apos;~&gt;3.8&apos;
use_frameworks!

pod &apos;Masonry&apos;

pod &apos;MBProgressHUD&apos;, &apos;~&gt; 1.0.0&apos;

pod &apos;MJExtension&apos;

pod &apos;MJRefresh&apos;

pod &apos;SVProgressHUD&apos;
</code></pre><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><pre><code>pod install --verbose --no-repo-update
# 显示
# Pod installation complete! There is 1 dependency from the Podfile and 1 total pod installed.
</code></pre><h2 id="Start"><a href="#Start" class="headerlink" title="Start!"></a>Start!</h2><p>以后打开项目点击xcworksapce后缀的文件，不要点击原来的项目文件。<br>导入头文件应该使用:</p>
<pre><code>#import &lt;&lt;#header#&gt;&gt;
</code></pre><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>platform :ios, ‘9.0’ 用来设置所有第三方库所支持的iOS最低版本<br>pod ‘SDWebImage’,’~&gt;2.6’ 设置框架的名称和版本号</p>
<p>版本号的规则：<br>‘&gt;1.0’    可以安装任何高于1.0的版本<br>‘&gt;=1.0’   可以安装任何高于或等于1.0的版本<br>‘<1.0' 任何低于1.0的版本="" '<="1.0'" 任何低于或等于1.0的版本="" '~="">0.1’   任何高于或等于0.1的版本，但是不包含高于1.0的版本<br>‘~&gt;0’     任何版本，相当于不指定版本，默认采用最新版本号</1.0'></p>
<h1 id="pod-install过程"><a href="#pod-install过程" class="headerlink" title="pod install过程"></a>pod install过程</h1><ol>
<li>分析依赖:该步骤会分析Podfile,查看不同类库之间的依赖情况。如果有多个类库依赖于同一个类库，但是依赖于不同的版本，那么cocoaPods会自动设置一个兼容的版本。</li>
<li><p>下载依赖:根据分析依赖的结果，下载指定版本的类库到本地项目中。</p>
</li>
<li><p>生成Pods项目：创建一个Pods项目专门用来编译和管理第三方框架，CocoaPods会将所需的框架，库等内容添加到项目中，并且进行相应的配置。</p>
</li>
<li>整合Pods项目：将Pods和项目整合到一个工作空间中，并且设置文件链接。</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>Mac显示隐藏的文件</p>
<pre><code>defaults write com.apple.finder AppleShowAllFiles -boolean true ; 
killall Finder
</code></pre><p>Mac取消显示隐藏文件</p>
<pre><code>defaults write com.apple.finder AppleShowAllFiles -boolean false ; 
killall Finder
</code></pre><blockquote>
<p>参考并致谢:<br><a href="http://blog.csdn.net/lissdy/article/details/9191351" target="_blank" rel="external">http://blog.csdn.net/lissdy/article/details/9191351</a><br><a href="http://www.cnblogs.com/yan520/p/5583362.html" target="_blank" rel="external">http://www.cnblogs.com/yan520/p/5583362.html</a><br><a href="http://www.jianshu.com/p/32d9cfb91471" target="_blank" rel="external">http://www.jianshu.com/p/32d9cfb91471</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; Cocoapods是非常好用的第三方库管理工具. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="ios开发" scheme="http://yoursite.com/tags/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记四：分类与代理</title>
    <link href="http://yoursite.com/2016/07/16/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9A%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/07/16/Objective-C学习笔记四：分类/</id>
    <published>2016-07-16T09:50:17.000Z</published>
    <updated>2016-10-25T14:37:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.16更正部分错别字</p>
</blockquote>
<p></p><p align="center"> 一些琐碎的笔记,关于分类、代理和block. </p><br><a id="more"></a> <p></p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>场合：在不修改原来类模型的情况下，给类扩充一些方法，且仅是方法，不扩充成员变量。可以给系统自带的类添加分类，扩充方法。（注意引入分类文件）<br>当添加分类的方法是重写原来类中的方法时,不需要引入分类文件。<br>声明文件的命名方式 【类+分类.h】</p>
<pre><code>@interface 类名 (分类名)
@end
</code></pre><p>实现文件的命名方式 【类+分类.m】</p>
<pre><code>@implementation 类名 (分类名)
@end
</code></pre><p>特征：用括号括住添加的分类<br>好处：一个庞大的类可以分模块开发、由多个人编写，有利于团队合作。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>1，分类可以访问原来类中的成员变量，但不能增加成员变量。（若要增加成员变量，可以使用继承）</p>
<p>2，分类的优先级最高，当调用类中的一个方法时，优先去分类中查找，再去原类中查找，最后去父类中查找。也即，倘若在分类中重写了原类中的方法，会覆盖掉原来的方法，导致原来的方法无法使用。（不建议重写原来类中的方法）<br>重写会出现警告：Category is implementing a method which will also be implemented by its primary class.</p>
<p>3，如果多个分类中有相同（方法签名相同，但不一样）的方法，则调用的是最后编译的方法。</p>
<h2 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h2><ul>
<li>方式1，直接在.m文件中写方法实现，不要在.h文件中进行方法声明</li>
<li>方式2，在.m文件中定义一个category，然后在category中声明一些方法，最后在@implementation和@end之间作方法实现。</li>
</ul>
<h1 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h1><p>类也是一个对象，是Class类型的对象，简称类对象，类对象就是类。<br>class类型的定义:<code>typedef struct objc_class *Class;</code><br>类名代表着类对象，每个类只有一个类对象。</p>
<h2 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h2><p>在程序启动的时候，就会加载所有的类和分类，并调用一次所有类和分类的+load方法；</p>
<ul>
<li>先加载父类，再加载子类，也即先调用父类的+load方法，再调用子类的+load方法;</li>
<li>先加载原始类，再加载分类（顺序也即父类——父类的分类——子类）。</li>
<li>不管程序运行过程中有没有用到这个类，都会调用+load加载。</li>
</ul>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h2><p>在第一次使用某个类时（比如创建对象），就会调用一次+initialize方法<br>一个类只会调用一次+initialize方法，先调用父类的，再调用子类的<br>获取类对象的两种方式</p>
<pre><code>Class c = [Person class];//类方法
</code></pre><p>或者</p>
<pre><code>Person *p = [Person new];
Class c = [p class];//对象方法
</code></pre><p>很明显，[p class]和[Person class]方法返回的都是是class类型<br>类对象调用类方法：</p>
<pre><code>Class c=[Person class];
  Person *p2=[c new];
</code></pre><h2 id="description方法"><a href="#description方法" class="headerlink" title="description方法"></a>description方法</h2><p>类似其他语言的ToString方法，NSObject自带的方法。返回值类型是<code>NSString ＊</code><br>默认情况下，使用NSLog和%@打印一个对象，输出的是&lt;类名:内存地址&gt;<br>如：<code>&lt;Person: 0x1002070a0&gt;</code><br>而NSLog(@”%@”,p)会调用-description方法</p>
<h3 id="description方法-1"><a href="#description方法-1" class="headerlink" title="-description方法"></a>-description方法</h3><p>使用NSLog和%@输出某个对象时，会调用对象的-description方法</p>
<h3 id="description方法-2"><a href="#description方法-2" class="headerlink" title="+description方法"></a>+description方法</h3><p>使用NSLog和%@输出某个类对象时，会调用类对象的+description方法</p>
<p>可以重写+description和-description方法修改NSLog的默认输出<br>注意：如果在-description方法中使用NSLog打印self，会造成死循环。</p>
<pre><code>// 重写-description方法
-(NSString *)description
{
  return [NSString stringWithFormat:@”%@”, self];    
}
</code></pre><p>编译无警告，无报错，运行出错。<br>真正重写：<br>假设属性为</p>
<pre><code>// 重写-description方法
-(NSString *)description
{
  return [NSString stringWithFormat:@”姓名：%@ 年龄：%d”, _name,_age];
}
</code></pre><h1 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h1><p>每个类的方法列表都存储在类对象中,每个方法都有一个与之对应的SEL类型的对象<br>根据一个SEL对象就可以找到方法的地址，进而调用方法<br>SEL类型定义</p>
<pre><code>typedef struct objc_selector *SEL;
</code></pre><p>SEL对象的创建：</p>
<pre><code>SEL s=@selector(test);
SEL s2=NSSelectorFromString(@”test”);
</code></pre><p>将SEL对象转换为NSString对象</p>
<pre><code>NSString *s3=NSStringFromSelector(s);
</code></pre><p>调用对象p的show方法：</p>
<pre><code>// 创建p对象
Person *p=[[Person alloc] init];
// 将show方法封装为SEL类型数据的s
SEL s=@selector(show);
// 调用s间接调用show方法
  [p performSelector:s];
</code></pre><h2 id="p-test-原理解释"><a href="#p-test-原理解释" class="headerlink" title="[p test]原理解释"></a>[p test]原理解释</h2><ol>
<li>把test包装成SEL类型的数据</li>
<li>根据SEL数据找到对应的方法地址</li>
<li>根据方法地址调用相应的方法<br>消息就是SEL。</li>
</ol>
<h1 id="NSLog方法总结"><a href="#NSLog方法总结" class="headerlink" title="NSLog方法总结"></a>NSLog方法总结</h1><ol>
<li><p>打印对象的内存地址</p>
<pre><code>NSLog(@”%p”,p);
</code></pre></li>
<li><p>打印指针的内存地址（&amp;p取出地址）</p>
<pre><code>NSLog(@”%p”,&amp;p);
</code></pre></li>
<li><p>打印某一对象（默认返回类名+内存地址，可以通过重写-description方法改变输出内容）</p>
<pre><code>NSLog(@”%@”,p);
</code></pre></li>
<li><p>打印代码行号</p>
<pre><code>NSLog(@”%d”,__LINE__);
</code></pre></li>
<li><p>打印文件路径</p>
<pre><code>NSLog(@”%d”,__FILE__);
</code></pre><p>注意：如果文件路径中存在中文，则无法输出<br>这时可以使用：</p>
<pre><code>printf(“%s\n”__FILE__);输出包含中文字符的路径（\n只是为了观看清晰）
</code></pre></li>
<li><p>打印当前函数名称</p>
<pre><code>NSLog(@”%s”,__func__);
</code></pre><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1></li>
</ol>
<p>一系列方法的列表（不能增加成员变量）。其中声明的方法可以被任何类实现，这种模式一般称作代理（delegation）。<br>如果一些类之间没有继承的关系，但是有某些相同的行为，这时要考虑使用代理。<br>代理的定义：<br>当一代理只针对某个类中，代理最好放在一个类的.h文件中，使用时引入即可。（假定在Person.h文件中）</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface Person : NSObject
@end

// 要在@interface之外设置代理
@protocol MyProtocol &lt;NSObject&gt;
// 必须实现的方法
@required
-(void)show;
-(void)myShow;
// 可选实现的方法
@optional
+(void)herShow;
@end
</code></pre><p>在Dog.h文件中遵守协议：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
// 声明协议@protocol  MyProtocol;
@protocol  MyProtocol;

@interface Dog : NSObject&lt;MyProtocol&gt;
// 遵守某个协议
// 注意导入协议文件#import &quot;Person.h&quot;或者声明协议@protocol  MyProtocol;
-(void)show;
-(void)myShow;
@end
</code></pre><p>当某一代理用在多个类中，协议需要放在单独创建的.h文件中<br>此时创建的只有一个名为BigProtocol的.h文件。</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt; 
@protocol BigProtocol &lt;NSObject&gt;
@required
-(void)bigShow;
@optional
-(void)bigShow2;
@end
</code></pre><p>在Cat.h文件中遵守协议</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
//@protocol BigProtocol;
#import &quot;BigProtocol.h&quot;
 @interface Cat : NSObject&lt;BigProtocol&gt;
-(void)bigShow;
@end
</code></pre><p>在Dog.h文件中遵守协议</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
//@protocol BigProtocol;
#import &quot;BigProtocol.h&quot;
@interface _Dog : NSObject&lt;BigProtocol&gt;
-(void)bigShow;
-(void)bigShow2;
@end
</code></pre><h2 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li><p>在遵守协议时，如果使用@protocol BigProtocol;编译器会警告：无法找到协议的定义<br>而使用<code>#import “BigProtocol.h“</code>，则完全没有问题。</p>
</li>
<li><p>如果某个类遵守多个协议，协议之间用逗号分隔：</p>
<pre><code>@interface Cat : NSObject&lt;BigProtocol,MyProtocol&gt;
</code></pre></li>
<li><p>一个协议本身可以遵守其他协议，如遵守名字叫NSObject的协议（默认是这种情况，基协议NSObject）<br>如果A协议遵守B协议，这时A协议就能拥有B协议的所有方法声明。</p>
<pre><code>@protocol BigProtocol &lt;NSObject&gt;
@end
</code></pre></li>
</ol>
<p>BigProtocol拥有NSObject协议的所有方法声明。</p>
<ol>
<li><p>约定框架中后缀为Delegate的都是协议。（协议类似其他语言的接口，就像C#中默认以I开头的都是接口 ）</p>
</li>
<li><p>要求某个对象必须遵守某个协议（如要求obj保存的对象遵守协议MyProtocol，并且继承Person）</p>
<pre><code>Person&lt;MyProtocol&gt; *obj=[[Person alloc] init];
</code></pre></li>
<li><p>利用conformsToProtocol:判断某个类是否实现了某个协议</p>
<pre><code>Cat *c=[[Cat alloc] init ];
bool result=  [c conformsToProtocol:@protocol(BigProtocol)];
NSLog(@&quot;%@&quot;,result?@&quot;YES&quot;:@&quot;NO&quot;);
[c conformsToProtocol:@protocol(BigProtocol)];返回的是bool类型。
</code></pre></li>
</ol>
<h1 id="block"><a href="#block" class="headerlink" title="block"></a>block</h1><p>块。<br>有返回值（void也可以）、有形参。block封装了一段代码，可以在任何时候执行。block可以作为函数参数或者函数返回值，而其本身又可以带输入参数和返回值。<br>在多线程，异步任务，集合遍历，集合排序，动画专场使用较多。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>返回值类型  (^+block名称)(参数类型列表)=^(参数列表){   代码内容  };
</code></pre><ol>
<li><p>注意大括号后面有分号</p>
</li>
<li><p>对比函数</p>
<pre><code>int (^MySum)(int ,int )=^(int a,int b){ return a+b;};
int     MySum (int a,int b){return a+b;}
</code></pre></li>
<li><p>block可以访问局部变量，但不能更改局部变量。<br>如果更改则报错：Variable is not assignable (missing__block type specifier)，如：</p>
<pre><code>int c=10;
// Block的定义
int (^MySum)(int ,int )=^(int a,int b)
{
  c=21;
  return a+b+c;
};
NSLog(@&quot;%i&quot;,MySum(10,20));
</code></pre></li>
</ol>
<p>如果硬是要修改：在局部变量前面加上<code>__block</code> ，如   <code>__block int c=21;</code>这时，便可以在block中修改局部变量了。</p>
<pre><code>__block  int c=10;
        // Block的定义
        int (^MySum)(int ,int )=^(int a,int b)
        {
             c=21;
            return a+b+c;
        };
        NSLog(@&quot;%i&quot;,MySum(10,20));
</code></pre><p>4 . block的调用，和函数一样，使用名称即可：<code>MySum(_形参列表);</code></p>
<p>5 . 如果block没有形参，则可以省略等号后面的()<br>如：  </p>
<pre><code>int (^SomeSum)()=^{return 25;};
</code></pre><p>但是等号前面的两对括号不可省略。</p>
<p>6 . 利用typedef声明类型</p>
<pre><code>格式：typedef  返回值类型 (^block块名称)(参数_类型列表)
例如：typedef int (^MyBlock)(int,int);

以后就可以用MyBlock这种类型定义Block变量
  MyBlock m=^(int a,int b){return a+b;};
        int c=m(15,25);
        NSLog(@”%i”,c);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.16更正部分错别字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;p align = &quot;center&quot;&gt; 一些琐碎的笔记,关于分类、代理和block. &lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记三：点语法与自动属性</title>
    <link href="http://yoursite.com/2016/05/18/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E7%82%B9%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/05/18/Objective-C学习笔记三：点语法与自动属性/</id>
    <published>2016-05-17T21:00:07.000Z</published>
    <updated>2016-10-25T14:09:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.16更正部分错别字<br>2016.05.24更正@private相关错误</p>
</blockquote>
<p align="center"> 点语法和自动属性的一些笔记. </p>



<a id="more"></a> 
<h3 id="点语法"><a href="#点语法" class="headerlink" title="点语法"></a>点语法</h3><p>本质是方法调用，不访问成员变量。前提是已经存在get和set方法(否则报错：Property ‘age’ not found on object of type ‘Person *’)。</p>
<pre><code>[p setAge:50];
int result=[p age];
NSLog(@”result的结果是：%i”,result);
</code></pre><p>相当于：</p>
<pre><code>p.age=50;
int result=p.age;
NSLog(@”result的结果是：%i”,result);
</code></pre><p>注意：此处的result未必等于50，因为在set方法中，age的值可能改变。</p>
<h4 id="方法的展开原理："><a href="#方法的展开原理：" class="headerlink" title="方法的展开原理："></a>方法的展开原理：</h4><p>[p        setAge   :      50];</p>
<p>对应</p>
<p>p     .     age=        50;</p>
<p>而<br>int result=[p       age];</p>
<p>对应<br>int result=p       .       age;</p>
<h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>1，set方法中</p>
<pre><code>-(void)setAge:(int)a
{
    self.age=a;
}
</code></pre><p>实际上是在set方法中调用set方法。</p>
<pre><code>-(int)age
{
    return self.age;
}
</code></pre><p>在get方法中调用get方法。<br>以上编译链接均无警告、无错误，但是运行会报错。</p>
<h3 id="成员变量的作用域"><a href="#成员变量的作用域" class="headerlink" title="成员变量的作用域"></a>成员变量的作用域</h3><h4 id="private"><a href="#private" class="headerlink" title="@private"></a>@private</h4><p>私有。<br>只能在当前类的对象方法中直接访问（当前类的对象方法的@implementation中访问），子类虽然继承（内存中存在），但无权限访问（感觉貌似没有继承，一层网给过滤掉。</p>
<h4 id="protected"><a href="#protected" class="headerlink" title="@protected"></a>@protected</h4><p>保护（默认是保护，不是私有）。<br>可以在当前类和子类的对象方法中直接访问（当前类和子类的@implementation中访问）。<br>假设父类Person有保护的成员变量_number，子类继承，什么变量都不增加，那么子类对象方法中访问的是父类的_number。</p>
<pre><code>-(void)show
{
    self-&gt;_number=1000;
    int result=self-&gt;_number;
    _number=5000;
    int result2= _number;
    NSLog(@”self-&gt;_number的值是：%i”,result);
    NSLog(@”_number的值是：%i”,result2);
}
</code></pre><h4 id="public"><a href="#public" class="headerlink" title="@public"></a>@public</h4><p>公开。任何地方都可以访问。一般用不到。</p>
<h4 id="package"><a href="#package" class="headerlink" title="@package"></a>@package</h4><p>同一个框架内可以访问，介于@public和@private之间。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>1,在类方法中不可能访问成员变量。<br>2,也可以在@implementation中声明成员变量。</p>
<pre><code>@implementation Student:NSObject
{
    @public int age;
    @private int number;
    @protected int no;
}
@end
</code></pre><p>然而.m文件一般不会被包含，也即一般没有必要访问，故而一般不把成员变量放在实现文件中。</p>
<h4 id="property和-synthesize属性合成"><a href="#property和-synthesize属性合成" class="headerlink" title="@property和@synthesize属性合成"></a>@property和@synthesize属性合成</h4><p>@property用在@interface中，代替get和set方法<br>如：<code>@property int age;</code><br>等价于</p>
<pre><code>-(int)age;
-(void)setAge:(int)age;
</code></pre><p>即便是<code>@property int _age;</code>那也会生成</p>
<pre><code>-(int)_age;
-(void)setAge:(int)_age;
</code></pre><p>而@synthesize用在@implementation实现中：@synthesize  age=成员变量名; 不允许对成员变量进行条件过滤，如@synthesize age=_age+100;</p>
<p><code>@synthesize age=_age;</code></p>
<p>等价于</p>
<pre><code>-(int)age
{
    return _age;
}
-(void)setAge:(int)age
{
    _age=age;
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> 1，如果.h文件中没有这个_age成员变量。那么，利用@property可以自动生成私有@private的_age。而默认的_age却是@protected的。<br> 2，@synthesize age将会访问age这个成员变量而非_age。<br> 3，若手动实现getter方法，编译器只会自动生成setter方法；若手动实现setter方法，编译器只会自动生成getter方法。</p>
<h5 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h5><p>@property已经独揽@synthesize的实现了，也即</p>
<p><code>@synthesize age=_age;</code>可以省略。只用写<code>@property int  age</code>就好了。（当然，前提是不对参数进行过滤，直接传到成员变量中，如果要过滤，还是要自己生成相应的方法。）</p>
<p> 4，默认情况下，getter和setter方法中的实现会访问下划线开头的成员变量。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>相当于<code>NSObject  *</code>  ，是万能指针。</p>
<h4 id="id类型的定义"><a href="#id类型的定义" class="headerlink" title="id类型的定义"></a>id类型的定义</h4><pre><code>typedef struct objc_object {
Class isa;
}*id;
</code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>用来初始化对象的方法，完整地创建一个可用对象。</p>
<p><code>Person *p=[Person alloc];</code><br>+alloc方法分配存储空间，返回对象。</p>
<p><code>p=[p init];</code><br>-init方法初始化</p>
<h4 id="init方法的重写"><a href="#init方法的重写" class="headerlink" title="init方法的重写"></a>init方法的重写</h4><p>目的：在对象创建完毕之后，使成员变量就有了一些默认的值。<br>注意：一定要先调用父类的构造方法，再进行子类内部成员变量的初始化<br>在@implementation中进行重写：</p>
<pre><code>-(id)init
{
    // 一定要先调用super的init方法，这是为了初始化父类的一些成员变量和其他属性
    self=[super init];
    // 判断对象是否初始化成功，如果对象初始化成功，再进行接下来的自定义初始化
    if(self!=nil)
    {
           _age=10086;
    }
    // 返回一个已经初始化完毕的对象
    return self;
}
</code></pre><p>上面代码不够简化，一般用下面代码。</p>
<pre><code>-(id)init
{
       // 简化版
    if([super init])
    {
        _age=10086;
    }
    return self;
}
</code></pre><h4 id="自定义构造方法"><a href="#自定义构造方法" class="headerlink" title="自定义构造方法"></a>自定义构造方法</h4><p>要求：是对象方法（对象的初始化），返回值是id类型，方法名以initWith开头。<br>注意：-init方法重写不需要在@interface中声明，因为已经声明过了，而自定义的构造方法需要在@interface中显式声明。</p>
<pre><code>// 声明
-(id)initWithAge:(int)age;




// 实现
-(id)initWithAge:(int)age
{
    if([super init])
    {
        _age=age+100;
    }
    return self;
}
</code></pre><p>调用示例：</p>
<pre><code>Person *p=[Person alloc];
p=[p init];
int r=p.age;
NSLog(@”r的值是%i”,r);

p= [p initWithAge:110];
int r2=p.age;
NSLog(@”r2的值是%i”,r2);
</code></pre><p>显而易见一个对象可以初始化多次。</p>
<p>含有多个参数的构造方法：<br><code>-(id)initWithAge:(int)age andNumber:(int)number;</code></p>
<h3 id="h文件和-m文件"><a href="#h文件和-m文件" class="headerlink" title=".h文件和.m文件"></a>.h文件和.m文件</h3><p>每个类分布在不同的文件中<br>类的声明放在.h文件中，类的实现放在.m文件中<br>若想使用某个类，就包含某个类的.h文件即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.16更正部分错别字&lt;br&gt;2016.05.24更正@private相关错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 点语法和自动属性的一些笔记. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记二：继承与属性</title>
    <link href="http://yoursite.com/2016/05/16/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/05/16/Objective-C学习笔记二：继承与属性/</id>
    <published>2016-05-16T11:22:17.000Z</published>
    <updated>2016-10-28T13:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.25 回顾</p>
</blockquote>
<p align="center"> 关于继承与属性的笔记. </p>

<a id="more"></a>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>优点：过滤不合理的值，屏蔽内部的赋值过程，让外界不必关注内部的细节。</p>
<p>成员变量的命名：以下划线开头。用于区分get方法名称和局部变量名称。尽量不设置为@public公有属性</p>
<pre><code>{
  int _speed;
}
</code></pre><p>set方法：设置成员变量，过滤一些不符合要求的值。以set开头，返回类型为void，后面跟上成员变量名，形参不与成员变量重名，形参类型与成员变量相同，成员变量的首字母大写。在set方法中设置行为，监听属性的改变。</p>
<pre><code>-(void)setSpeed:(int)s;

-(void)setSpeed:(int)s

{

_speed=s+20;

}
</code></pre><p> get方法：获取对象内部的成员变量，不接收参数，返回类型与成员变量类型相同，方法名称与成员变量名称相同（不含下划线）。不推荐以get开头。</p>
<pre><code>-(int)speed;

-(int)speed

{

return _speed;

}
</code></pre><p>只读：只提供get方法。可读可写：提供get和set方法。</p>
<h1 id="OC的弱语法"><a href="#OC的弱语法" class="headerlink" title="OC的弱语法"></a>OC的弱语法</h1><h2 id="调用未声明、未实现的对象方法"><a href="#调用未声明、未实现的对象方法" class="headerlink" title="调用未声明、未实现的对象方法"></a>调用未声明、未实现的对象方法</h2><p>编译 报错 <code>No visible @interface for ‘Dog’ declares the selector ‘ssss’</code>，链接运行 报错。</p>
<p><code>reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1002014a0’</code></p>
<p>给Dog对象发送不能识别的消息。</p>
<h2 id="调用已声明、未实现的对象方法"><a href="#调用已声明、未实现的对象方法" class="headerlink" title="调用已声明、未实现的对象方法"></a>调用已声明、未实现的对象方法</h2><p>编译警告：<code>Method definition for ‘ssss’ not found</code> 未实现方法 链接正常，运行报错</p>
<p><code>reason: ‘-[Dog ssss]: unrecognized selector sent to instance 0x1001002a0’</code></p>
<h2 id="调用未声明、已实现的对象方法"><a href="#调用未声明、已实现的对象方法" class="headerlink" title="调用未声明、已实现的对象方法"></a>调用未声明、已实现的对象方法</h2><p>编译 链接运行 错误 <code>No visible @interface for ‘Dog’ declares the selector ‘ssss’</code></p>
<p>在Dog的@interface中，对于ssss的声明是不可见的。</p>
<h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><p>类本身在内存中占据存储空间，里面有类\对象方法列表。直接通过类名执行的方法。</p>
<p>以+开头，只能由类名调用，类方法中不能访问成员变量（实例变量）。允许类方法与对象方法重名。(执行者不同，当然可以重名！)</p>
<p>使用场合：当不需要访问成员变量的时候，尽量使用类方法，提升效率。</p>
<p>输出类的名称：</p>
<pre><code>+(void)showClassName;

+(void)showClassName

{

NSLog(@”类的名称是：%@”,NSStringFromClass([self class]));

}
</code></pre><p>调用：<code>[Dog showClassName];</code></p>
<h1 id="self关键字"><a href="#self关键字" class="headerlink" title="self关键字"></a>self关键字</h1><p>self是指针，指向当前对象或类的调用者。出现在对象方法中，代表当前对象，出现在类方法中，代表当前类。不能出现在函数中（会报错：<code>Use of undeclared identifier ‘self’</code>使用未声明的标识符）。</p>
<p>用途：</p>
<ol>
<li><p>self-&gt;成员变量名 在对象方法中访问当前方法调用的成员变量，也即当成员变量与局部变量同名时，用来区分同名的局部变量。</p>
<pre><code>-(void)showSelfOfObject;

-(void)showSelfOfObject

{

NSLog(@”showSelfOfObject方法被调用”);

int _speed;

self-&gt;_speed=200;

_speed+=1000;

int result= self-&gt;_speed+10;

NSLog(@”result的值是：%i”,result);

NSLog(@”_speed的值是：%i”,_speed);

}
</code></pre></li>
</ol>
<p>当成员变量与局部变量同名时（编译警告<code>Local declaration of ‘_speed’ hides the instance variable</code>局部变量隐藏了成员变量），采用就近原则，访问局部变量。因此需要用self访问成员变量。</p>
<ol>
<li>方法的调用:在对象方法中调用当前对象的对象方法以及在类方法中调用当前类的类方法</li>
</ol>
<p>在对象方法中调用当前对象的对象方法</p>
<pre><code>-(void)showSelfOfObject;

-(void)showTestObject;

-(void)showSelfOfObject

{

NSLog(@”showSelfOfObject方法被调用”);

}

-(void)showTestObject

{

[self showSelfOfObject];

}
</code></pre><p>在类方法中调用当前类的类方法</p>
<pre><code>+(void)showSelfOfClass;

+(void)showTestClass;

+(void)showSelfOfClass

{

NSLog(@”showSelfOfClass方法被调用”);

}

+(void)showTestClass

{

[self showSelfOfClass];

}
</code></pre><p>常见错误：</p>
<ol>
<li><p>在对象方法中调用类方法（编译错误<code>No visible @interface for ‘Dog’ declares the selector ‘showSelfOfClass‘</code>）错误相当于未声明未定义却调用这个方法。</p>
</li>
<li><p>在类方法中调用对象方法（编译错误<code>No known class method for selector ‘showSelfOfObject‘</code>）未知的类方法</p>
</li>
</ol>
<p>3，self的死循环:调用本身</p>
<pre><code>-(void)showSelfOfObject

{

NSLog(@”showSelfOfObject方法被调用”);

[self showSelfOfObject];

}
</code></pre><p>4，调用函数</p>
<p>函数不依赖对象。<code>void f(); [self f]</code> 错误</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>场景：当两个类拥有相同的属性和方法时，将相同的内容抽取到父类中。当A类完全拥有B类的部分属性或方法时，考虑A类作为父类。</p>
<ol>
<li><p>父类必须声明在子类前面。</p>
</li>
<li><p>不允许子类和父类拥有相同的成员变量（如果子类有和父类拥有相同的成员变量，意味着，同一成员变量声明定义两次，编译错误 <code>Duplicute member ‘_age’</code>，哪怕成员变量的访问属性不同，子类公开父类私有，或者父类公开子类私有，都不行！）</p>
</li>
<li><p>子类方法和属性的访问过程：如果子类没有，再访问父类。即由子类开始。</p>
</li>
<li><p>Objective-C中只有单继承（与C＋＋不同）</p>
</li>
</ol>
<p>方法的重写:父类和子类拥有相同签名的类方法或者对象方法（子类重新实现了父类中的方法），则优先调用子类的同名方法。</p>
<pre><code>父类Person：

-(void)show

{

NSLog(@”调用了Person的show方法”);

}

子类Student：

-(void)show

{

//[super show];

NSLog(@”调用了Student的show方法”);

}

调用：

Student *p=[[Student alloc] init]; [p show];
</code></pre><p>很明显，调用的是重写的子类Student的show方法。</p>
<h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><p>场景：子类重写父类的方法时，想调用父类的方法（包括类方法和对象方法）。</p>
<p>效果与self类似，super在对象方法中就调用父类的对象方法，在类方法中就调用父类的类方法。</p>
<p>继承可以在不改变原来模型的基础上拓充方法，抽取公共代码，建立类与类之间的联系，减少代码的冗余性，但是，会增加耦合性。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>某一种事物的多种形态。<br>在实现继承的前提下，父类类型指针指向子类对象（右边是左边），指向子类对象的父类指针可以调用子类中重写父类的方法，但是指向子类对象的父类指针不能调用子类中拓展的方法（父类中没有的方法）。</p>
<pre><code>Person *p=[[Student alloc] init];

[p show];
</code></pre><p>Student是Person，show方法在子类和父类中都有，这里调用的是子类的show方法。</p>
<p>当子类拓展了一个showStudent对象方法，如果还想调用，则强制转换：将指向子类对象的父类指针强制转化为子类指针。</p>
<pre><code>Person *p=[[Student alloc] init];

Student p2=(Student )p;

[p2 showStudent];
</code></pre><p>将父类指针p强制转换为子类指针，使它可以调用子类Student拓展的showStudent方法。</p>
<p>如果不做强制转换，而直接调用子类拓展的方法</p>
<pre><code>Person *p=[[Student alloc] init];

[p showStudent];
</code></pre><p>编译报错： <code>No visible @interface for ‘Person’ declares the selector ‘showStudent’</code></p>
<p>转换语法： { 相应子类名 p=(父类名 )指向子类对象的父类指针；}</p>
<p>主要应用：<strong>动态绑定</strong><br>如果参数使用父类类型，可以传入父类、子类对象，调用相应的方法（如将子类对象传递给参数，调用子类的方法；将父类对象传递给参数，则调用父类的方法）</p>
<p>例如，Person和Student中都有同名show对象方法，可以通过test函数传入的参数判断调用哪个方法。</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

#import “Person.h”

#import “Student.h”

void test(Person * p)

{

[p show];

}

int main(int argc, const char * argv[]) {

@autoreleasepool {

Person *p=[[Person alloc] init];

Student *s=[[Student alloc] init];

test(p);

test(s);

}

return 0;

}
</code></pre><h1 id="NSString的使用"><a href="#NSString的使用" class="headerlink" title="NSString的使用"></a>NSString的使用</h1><ol>
<li><p>创建字符串与输出字符串</p>
<pre><code>NSString *s=@”Sometimes”;

NSLog(@”%@”,s);
</code></pre></li>
<li><p>格式化字符串</p>
<pre><code>int age=85;

NSString *s=[NSString stringWithFormat:@”传入的年龄参数是%d”,age];

NSLog(@”%@”,s);
</code></pre></li>
<li><p>调用NSString类方法。<br>length返回字数（不是字符数）</p>
<pre><code>NSString *s=@”123 456”;

NSLog(@”%@”,s);

NSUInteger size=[s length];

NSLog(@”%lu”,(unsigned long)size);
</code></pre></li>
</ol>
<p>返回的是7，包括空格。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.25 回顾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 关于继承与属性的笔记. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
      <category term="ios开发" scheme="http://yoursite.com/tags/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C学习笔记一：类</title>
    <link href="http://yoursite.com/2016/05/12/Objective-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/05/12/Objective-C学习笔记一：类/</id>
    <published>2016-05-11T21:00:49.000Z</published>
    <updated>2016-10-28T13:22:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10.28 回顾</p>
</blockquote>
<p align="center"> 万物皆是对象. </p>

<a id="more"></a>
<h1 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h1><p>三要素：事物名称（类名）；属性；行为（功能）</p>
<p>具有相同（或者类似）属性和行为的对象可以抽象出一个类。</p>
<h1 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h1><p>类名<br>1，首字母大写；2，不能有下划线；3，多个英文单词，使用驼峰标识</p>
<p>行为<br>哪个对象最清楚行为怎么做，就把行为设计在哪个对象身上</p>
<pre><code>@interface Person : NSObject

{

@public

int _age;

bool _sex;

}

-(void)print;

@end
</code></pre><p>大括号内用来声明对象属性（成员变量也即实例变量）,@public让外界指针可以间接访问对象内部的成员变量。成员变量默认会初始化为0.</p>
<p><code>: NSObject</code>（继承基类）使声明的类具有创建对象的能力。</p>
<h1 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h1><pre><code>@implementation Person

-(void)print

{

NSLog(@”输出内容”);

}

@end
</code></pre><p>已经导入声明文件<code>#import “Person.h”</code><br>类的实现即方法的实现。</p>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><pre><code>Person *p=[[Person alloc] init];

[p print];
</code></pre><p>对象的本质是结构体，对象需要通过指针操纵。</p>
<p>类在内存中也占据存储空间，在创建对象之前为类分配一份内存空间，将类加载进内存。而且只存储方法列表，其中由类产生的对象，都有一个isa指针指向类。</p>
<p>方法调用：<code>[行为执行者   行为名称]</code>;</p>
<p><code>[Person new]</code>执行Person这个类的new行为创建对象，返回对象地址。</p>
<p><code>Person *p=[Person new];</code>定义一个Person 类型的指针变量p，指向Person类型的对象。指针的类型是Person *，指针指向的类型是Person。</p>
<p><code>[p print];</code>表示给p指向的对象发送一条print消息。</p>
<p><code>Person p=[Person new];</code>等价于 <code>Person p;p=[Person new];</code>另外<code>Person *p2=p;</code>表示p2、p指向同一个内容。<code>p=p2</code>:将p2存储的指针交给p，使p存储的也是p2存储的内容。</p>
<h1 id="方法与函数的区别以及注意"><a href="#方法与函数的区别以及注意" class="headerlink" title="方法与函数的区别以及注意"></a>方法与函数的区别以及注意</h1><ul>
<li><p>OC方法只能声明在@interface和@end之间，只能实现在@implementation和@end之间。也就是说OC方法不能独立于类存在</p>
</li>
<li><p>C函数不属于类，跟类没有联系，C函数只归定义函数的文件所有</p>
</li>
<li><p>C函数不能访问OC对象的成员</p>
</li>
<li><p>对象方法归类／对象所有，函数属于整个文件所有，任何地方都可以放置函数（如果放在@interface与@end之间，将会忽略掉函数，即未定义）</p>
</li>
<li><p>方法只有声明，没有实现（经典错误）</p>
</li>
<li>方法没有声明，只有实现（编译器警告，但是能调用，OC的弱语法）</li>
<li>编译的时候：访问没有的成员变量直接报错，访问没有的方法，只是警告</li>
<li>同一个类中不允许两个对象方法同名</li>
</ul>
<h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><p>属性访问 <code>[Car new]-&gt;speed = 200;</code></p>
<p>方法调用<code>[ [Car new] run];</code></p>
<h1 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h1><p>不带参数的对象方法：</p>
<p><code>-(void)print; 方法名print</code></p>
<p>带一个参数的对象方法：</p>
<p><code>-(void)print:(int) a; 方法名print :</code></p>
<p>带多个参数的对象方法：</p>
<p><code>-(void)print:(int) a WithOther:(int) b;</code>方法名</p>
<p><code>print : WithOther:</code></p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><pre><code>typedef enum｛

SexMan,

SexWoman

｝Sex;
</code></pre><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><pre><code>typedef struct{

int year;

int month;

int day;

} Date;
</code></pre><p>访问枚举：<code>s-&gt;sex=SexMan;</code></p>
<p>访问结构体：<code>s-&gt;birthday.year=2016;</code></p>
<p>定义结构体：</p>
<p><code>Date d={2016,4,30};</code></p>
<p>访问结构体：</p>
<pre><code>s-&gt;birthday.year=2016;

s-&gt;birthday.month=4;

s-&gt;birthday.day=16;
</code></pre><p>等价于：</p>
<pre><code>Date d={2016,4,16};

s-&gt;birthday=d;
</code></pre><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>打印函数中注意％与%的区别</li>
<li>定义枚举、结构体等必需放在@interface的前面方可使用</li>
<li>OC方法中一个参数一个冒号</li>
<li>对象中有对象</li>
</ul>
<pre><code>@interface Student : NSObject

{

@public

//狗

Dog *dog;

}

-(void)letDogRun

{

[dog run];

}


// main.m文件

Student *stu=[Student new];

Dog *dog=[Dog new];

stu-&gt;dog=dog;

[stu letDogRun];
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10.28 回顾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align = &quot;center&quot;&gt; 万物皆是对象. &lt;/p&gt;
    
    </summary>
    
      <category term="ios开发" scheme="http://yoursite.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>浅谈负债哲学</title>
    <link href="http://yoursite.com/2016/05/06/%E6%B5%85%E8%B0%88%E8%B4%9F%E5%80%BA%E5%93%B2%E5%AD%A6/"/>
    <id>http://yoursite.com/2016/05/06/浅谈负债哲学/</id>
    <published>2016-05-05T21:00:45.000Z</published>
    <updated>2016-10-25T14:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"> 哲学上的负债,关于人性. </p>


<a id="more"></a>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p><span style="color: #000000;">首先抛出一个问题，银行放贷最关心的是什么？<br>并不是还贷的能力，而是抽贷的时机。</span></p>
<p>即使资不抵债，银行照样敢放出贷款，如果您不能理解，那么请往下看：</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">“信用卡体系的根基并非持卡人的信用，而是银行的不守信用”，这是我最初接触到信用卡时的第一想法。说来奇怪，当我第一次接触到信用卡的时候，并没有任何信用卡，甚至没有申请信用卡的想法；那年我大三，或者说大四，总之暑假还没有开学。</span></p>
<p><span style="color: #000000;">本来，作为一名实习生只能担任一些非核心的岗位，但因为父亲的原因，免除了基础性的工作，直接进入了能够接触到信用逻辑的技术部门；那是我最初接触到银行的信贷逻辑，并使我后来决定远离银行体系的原因。银行只是一台冷血的机器，这里只有利益的竞逐和赤裸裸的博弈，银行与用户，银行与银行，而没有理解与帮助。<!-- more --> </span></p>
<table class="t_table" cellspacing="0"><br><tbody><br><tr><br><td><br><br><span style="color: #000000;">银行客户分类服务标准：</span><br><br><span style="font-size: small; color: #000000;">贵宾客户：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供周到满意的全方位服务</span></span><br><br><span style="font-size: small; color: #000000;">高值客户：</span><br><div align="right"><span style="color: #000000;"><span style="font-size: xx-small;">提供周到满意的品质服务</span></span></div><br><span style="font-size: small; color: #000000;">金卡客户：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供客户满意的便捷服务</span></span><br><br><span style="color: #000000;"><span style="font-size: small;">基础客户</span><span style="font-size: xx-small;">：</span></span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供便捷舒适的基础业务</span></span><br><br><span style="font-size: small; color: #000000;">政策客户：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">提供政策要求的服务质量</span></span><br><br></td><br><td><br><br><span style="color: #000000;">银行关于不同类型投诉的处理方式：</span><br><br><span style="font-size: small; color: #000000;">重大过失投诉：</span><br><br><span style="font-size: xx-small; color: #000000;">指银监会可能亲审的投诉(比如身份冒用、账务冲正等)，由实权部门优先受理</span><br><br><span style="font-size: small; color: #000000;">终止合作投诉：</span><br><br><span style="font-size: xx-small; color: #000000;">指客户要求与银行互相拉黑，并按合同依法索赔的投诉，由实权部门直接受理</span><br><br><span style="color: #000000;"><span style="font-size: small;">贵宾客户</span><span style="font-size: small;">投诉：</span><span style="font-size: small;"><br></span></span><br><br><span style="font-size: xx-small; color: #000000;">指贵宾卡达标客户的各类(合理或无理的)投诉，由实权贵宾投诉部门特殊受理</span><br><br><span style="font-size: small; color: #000000;">一般类别投诉：</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">指普通投诉(</span><span style="font-size: xx-small;">包括</span><span style="font-size: xx-small;">客户执意要求管理层受理的投诉)，</span><span style="font-size: xx-small;">转回</span><span style="font-size: xx-small;">直接管理部门</span><span style="font-size: xx-small;">自行处理</span></span><br><br><span style="color: #000000;"><span style="font-size: small;">反复多次</span><span style="font-size: small;">投诉：</span><span style="font-size: small;"><br></span></span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">指针对同一情节投诉3次及以上的客户，转由兼职大学生</span><span style="font-size: xx-small;">接听投</span><span style="font-size: xx-small;">诉(只许说套话)</span></span><br><br></td><br></tr><br><tr><br><td colspan="2"><br><div align="left"><span style="color: #000000;">垃圾客户：提供便捷的存取款业务<span style="font-size: xx-small;">(即:个人储蓄账户业务)</span>，并避免该客户影响其他储户的客户体验</span></div></td><br></tr><br></tbody><br></table><br><div align="left"><span style="color: #000000;"><span style="font-size: xx-small;">其中低保户、</span><span style="font-size: xx-small;">五保户</span><span style="font-size: xx-small;">等属于政策客户</span><span style="font-size: xx-small;">，</span>除政策客户外，行内资产在15K以下的属于垃圾客户，</span></div><br><span style="color: #000000;">除重大过错外，垃圾客户所有投诉均属于无效投诉，包括柜员态度和拒绝服务。简而言之，银行对这类客户的态度是<span style="font-family: 宋体;"><span style="font-size: xx-small;">：(</span></span><span style="font-size: xx-small;">淘汰低端客户是目的，不属于客户流失，特别是垃圾客户)</span></span><br><br><span style="color: #000000;"><span style="font-size: medium;">要么忍着，要么滚，爱存不存，这点存款的盈利还挣不回服务成本。</span>另一方面，</span><br><br><span style="color: #000000;"><span style="font-size: xx-small;">银监对于</span>非重大过失是转回银行<span style="font-size: xx-small;">(投诉转申诉)</span>自行处理的<span style="font-size: xx-small;">，</span><span style="font-size: xx-small;">银行并</span>不害怕<span style="font-size: xx-small;">垃圾</span><span style="font-size: xx-small;">客户</span>投诉到银监会</span><br><div id="code_dc1"><br><br>1.  <span style="color: #000000;">注：关于日均存款，银行一般有两种计算方式：账面日均(一般24:00结算)和公允日均(一般22:00结算)</span><br>2.  <span style="color: #000000;">账面日均：每日某时刻的行内资产/行内负债作为数据单位，计算平均数。</span><br>3.  <span style="color: #000000;">公允日均：每日某时刻及之前42小时内，行内资产最低值/行内负债最高值作为数据单位，计算平均数。</span><br>4.  <span style="color: #000000;">借记类业务一般采用前一种，贷记类业务一般采用后一种（但支行签字承担责任的业务可以采用前一种）</span><br></div><br><br># 二<br><br>银行的收益不是柜员的：即使大闹银行，那帮人也没什么损失，只要高柜玻璃不碎根本不算事故，撑死算个意外<br><br>无效投诉，一只三不：只道歉(不认错)，不处罚，不整改，不赔偿(所有不反馈处罚决定的投诉,都是无效投诉)<br><div align="right"><br><br>无法理解”一只三不”?体会一下这句话:”对不起,先生,我们已经打烊了.”道歉是因为造成了不便(包括自身没有任何过错)<br><br></div><br><br>一方面，引入更多债权方，可以稀释已发卡行的资金风险，而逾期记录会阻碍其他债权方的加入或追加额度；<br>另一方面，持卡人一而再的利用逾期宽容策略是银行更加不能容忍的，没有银行能容忍自己成为风险转嫁终端。<br><br>银行不会(因为不愿意)上报持卡人的短期逾期，除非持卡人预见到银行不会上报该笔逾期。<br><br>与逾期记录相对的另一个扣分项是信报查询记录：<br>其中比较常见的是信用卡审批、本人查询、贷款审批和贷后管理。<br>其中扣分最严重的依次是：<br><br><table class="t_table" cellspacing="0"><br><tbody><br><tr><br><td><span style="color: #000000;">1.不知名机构的贷款审批<span style="font-size: xx-small;">(尤其是没有贷款记录的)</span></span></td><br><td><span style="color: #000000;">3.未持卡机构的信用卡审批</span></td><br></tr><br><tr><br><td><span style="color: #000000;">2.非冷冻机构的贷后管理</span></td><br><td><span style="color: #000000;">4.个人明细版的本人查询</span></td><br></tr><br></tbody><br></table>

<p>四大行或者其他著名银行的贷款审批是不会扣分的，而已持卡行的信用卡审批记录也是根本无所谓的。<br>特别需要注意的是：（贷后管理是不需要持卡人主动申请的，而银行方面为了防止贷后管理被投诉，）<br>银行卡部对贷后管理统一口径(不影响系统评分)，但实际执行中贷后管理比(已持卡行)信用卡审批扣分更多</p>
<p><span style="color: #000000;">对于明知资不抵债的人，银行依旧敢于放款，并不是信任持卡人或者贷款人的还款能力，而是豪赌其他贷款方像自己一样认为持卡人还有榨取空间而不会抢先抽贷。银行对于自己的批卡或者放款有自信（或者说盲目自信的相信）自己不会成为击鼓传花的最后一棒；换言之，银行有自信在用户可用资金不足之前及时抽贷或者停卡，而把坏账留给其他债权人。越没有信用的银行越敢于放贷，同样也是这些银行更急于抽贷。</span></p>
<p><span style="color: #000000;">说到抽贷，就不得不提到催收。</span><br><span style="color: #000000;">首先，催收的威逼利诱是不需要害怕的，没有打工者会为了那点提成冒着自己违法的风险。</span><br><span style="color: #000000;">但是同样的，催收也不害怕你的强硬威胁，同样因为大部分人不敢把狠话付诸行动。</span><br><span style="color: #000000;">记住关于催收的三个基本：</span><br><span style="color: #000000;">1.催收的利诱不能信，即使如约先还部分款，后续仍会一如既往的强硬。</span><br><span style="color: #000000;">2.催收总是试图诱导你对他动用武力，因为你的打手被认定共同受益，可以追究欠款的连带赔偿。</span><br><span style="color: #000000;">3.有资格做某事的人数超过总人口的8%，以这种行为做威胁必定没用；除非你有足够的专业背景。</span><br><span style="color: #000000;">简而言之：</span><br><span style="color: #000000;">催收不过是不敢付诸行动的苍蝇，不过你对他的强硬同样没用<span style="font-size: xx-small;">，除非你是土豪、律师或者暴力犯罪在逃犯</span></span><br><span style="color: #000000;"><span style="font-size: xx-small;">以上是常见的外包催收，还有一种连催收人员都鲜有耳闻的催收队伍：污点催收。<br>这类催收一般是对付那些想为家人保住财产的逾期者(或者说是想一人做事一人当的汉子)；<br>一言以蔽之：</span>直系亲属(及配偶)无钱可出则采用外包催收，而直系亲属不愿倾其所有的采用污点催收。</span><br><span style="color: #000000;">污点催收人是银行招安的一部分逾期特别巨大且确实走投无路的铤而走险者，一般具备以下协议：</span></p>
<div class="blockcode" style="text-align: justify;"><br><div id="code_DYg"><br><br>1.  <span style="color: #000000;">协议禁止催收时使用违法手段，否则造成的一切后果及法律责任自负，与银行无关；</span><br>2.  <span style="color: #000000;">不能达到签约的催收指标则视为违约，银行将继续依法对信用卡诈骗报案追究刑事责任；</span><br>3.  <span style="color: #000000;">达到催收指标满XX年后，可以不再追究刑事及民事责任，并发放一定金额的奖励；</span><br>4.  <span style="color: #000000;">因催收冲突或暴力袭击原因导致死亡的，向其子女发放优厚的死亡赔偿金(不属于死者的遗产)</span><br></div><br></div>

<p><span style="color: #000000;">但是，实际执行中：由于逾期者的亲属不存在法律上的连带责任，</span></p>
<div style="text-align: justify;" align="right"><span style="color: #000000;">银行摊派给污点催收的一定是通过合法手段<span style="font-size: xx-small;">(含法律渠道)</span>不可能回收的债务。</span></div>

<p><span style="color: #000000;">此种关系模式下：银行把自己最大的威胁<span style="font-size: xx-small;">(包括暴力压力和舆论压力)</span>变成了自己最锋利的刀，</span></p>
<div style="text-align: justify;" align="right"><span style="color: #000000;">催收和被催收的关系是：除非被催收者的父母妻儿倾家荡产，否则污点催收人必定家破人亡。</span></div>

<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p><span style="color: #000000;">进场自由，愿赌服输，<u>希望回本的赌徒永远都是loser</u>。</span></p>
<p><span style="color: #000000;">  所谓进场自由，当被抢先抽贷或者资金断流，信用卡所谓催收不过是迫使持卡人把烂账转嫁到亲友或其他债权方，而非让你尽早赚回本金，不要说什么没有钱，银行之所以催收恰是因为你没有资金，银行试图引入更多的债权人使自己完成抽贷全身而退。</span></p>
<p><span style="color: #000000;">  所谓愿赌服输，如果短期内无法全身而退，银行唯一要做的就是甩掉黑锅，把自己塑造成受害者，而隐藏面具下的魔鬼；作为赌局的输家，银行并不是妄图回本的loser，根本不在乎收回本金（沉没成本的收益期望小于风险成本+机会成本），让持卡人背负欺骗银行的黑锅，这才是信用卡刑事庭的本质。</span></p>
<p><span style="color: #000000;">关于刑事，插入一句：</span><span style="color: #000000;">A.还款优先抵扣滞纳金，判定是否存在持续还款</span><span style="color: #000000;">B.还款优先抵扣本金后，判定刑事判决具体刑期</span><span style="color: #000000;"><span style="font-size: xx-small;">同一笔还款在AB两个阶段，优先偿还的优先级不同，A阶段在B阶段之前结算。</span></span></p>
<div class="blockcode"><br><div id="code_K1F"><br><br>1.  <span style="color: #000000;">以5%滞纳金+利息为例，如果每月还款不超过本金的5%视为没有还款。</span><br>2.  <span style="color: #000000;">如果每月偿还5%，那么20个月后停止偿还，也仅仅是民事问题。</span><br>3.  <span style="color: #000000;">举例：欠款10万，</span><br>4.  <span style="color: #000000;">第2~5个月还款5000.01，第6~15个月偿还3K，则有且仅有第6~15个月视为没有还款。</span><br>5.  <span style="color: #000000;">量刑金额：49,999.96 (即100K-5000.01<em>4-3K</em>10)，利息及滞纳金部分不作为量刑标准。                                                    </span><br>6.  <span style="color: #000000;">数额较大：数额在5000元以上不满5万元的；</span><br>7.  <span style="color: #000000;">数额巨大：数额在5万元以上不满50万元的。</span><br></div><br></div>

<p><span style="color: #000000;">上述数据可以看出逾期还款的基准点是：两年结清本金，利息、罚金不免。</span></p>
<p>由此引出了逾期协商的本质：<strong>双方退而求其次</strong>。<br><span style="color: #000000;">所谓谈判的过错不过是时间（容忍期）与空间（资金关系）的利益交换。</span><br><span style="color: #000000;">银行拒绝与持卡人协商的原因仅仅是由于持卡人没有任何谈判的诚意。</span></p>
<p><span style="color: #000000;">谈判（或者说协商）的本质无非是：时间换空间，或者空间换时间；</span><br><span style="color: #000000;">逾期者的协商如果基于时空双降，这注定是失败的，除非你爸是李刚。</span></p>
<p><span style="color: #000000;">空间换时间（典型案例）：持卡人通过另有约定同意<span style="font-size: xx-small;">(刑期意义上)</span>还款优先冲抵滞纳金；</span><br><span style="color: #000000;">银行接受较长的约定还款期限并降低最低还款标准，但不降低滞纳金收取标准。</span><br><span style="color: #000000;">时间换空间（典型案例）：持卡人于15个工作日内从其他债权方<span style="font-size: xx-small;">(特别是直系亲属)</span>借到本金；</span><br><span style="color: #000000;">银行确认本金偿清后，免除全部利息与滞纳金，并永久拒绝持卡人的信贷业务。</span></p>
<p><span style="color: #000000;">想要延长还款期，并减免利息的，洗洗睡吧：银行相对于默认规则没有降低任何风险。</span><br><span style="color: #000000;">至于自首，只要你的供述事实构不成犯罪，一定会被经侦赶出来，立不了案，哪来的自首？</span></p>
<p><span style="color: #000000;">注意：判刑后银行仍有对债务的民事权力，可以申请法院强制执行，也就是说：坐牢也得还。</span><br>但是，在某些极端情况下，银行一定会免除债务的，比如因负债压力过大而自杀(不含劝离/解救成功，含抢救成功):<br>因自杀导致的病危通知书，仅一张，或因其他原因而起，因而银行不承担责任，所以没卵用。<br>两张因自杀导致的(三甲医院出具的)病危通知书，免利息、滞纳金。<br>三张以上因自杀导致的(三甲医院出具的)病危通知书，连本金都免。<br>无论最后是否抢救成功，但上述病危通知书必须是持卡人本人、直系亲属或配偶。<br><span style="color: #000000;">不想像上述那样极端？成为特殊人群也可以享受减免且免于刑事，比如<span style="font-size: xx-small;">(政府部门确认的)</span>地震受灾户。</span></p>
<h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p><span style="color: #000000;">没有一家银行能承受挤兑，同样没有任何股票能承受抛售，但仍有很多人安然的持有着存款或股票；从这个意义上来说，银行与这些投资者其实并没有本质区别，盲目的信任其他投资者会继续持有，而成功者总是踩着失败者的尸体在攀登；如同股票一样，庄家与散户不会同时获益，所谓双赢无非是找第三方作为失败者，金融的本质是<strong>零和博弈</strong>：你、中介与银行总有一方是失败者，而这三者中绝对强势的银行注定不败。</span></p>
<p><span style="color: #000000;">说到第三方，普及一个反常识的常识：</span></p>
<div style="text-align: justify;" align="right"><strong><span style="color: #000000;">除非你套的行为一定（must）会被银行发现，否则这个行为总是（always）会导致降额或封卡</span></strong></div>

<p>之所以原谅你说谎，是因为自始就看透了你的谎言；<br>如果被你成功欺骗了，会害怕你欺骗的能力，所以不会原谅你。<br>局外人认为：只有银行发现不了的路子，才能活的长久；这样的路子不会被银行发现是在套。<br>事实的真相是：银行把所有经此消费均认定为套的路子，才能活的长久；因为他是永远的说谎者。<br>被记录在案的“永远说谎者”在某种意义上就是诚实者，当然银行不会承认有一份永久说谎者名单。<br>无论跳码还是套码，银行永远不是吃亏者，只有交足了保护费的说谎者（商户）才有开绿灯的资格。<br>这条食物链里银行拿的是大头，才能保持长期稳定的平衡，虽然银行装受害者，让第三方支付机构背黑锅。</p>
<p>如果你套的行为成功骗过银行电脑系统，那么银行会害怕你的反监控能力，于是就不和你玩了。<br>换句话说，如果你骗过了银行电脑系统，那么一旦被发现，100%被降额封卡，零宽容，零容忍</p>
<p>能长期稳定的路子没有能骗过银行电脑系统的评估和风控的，<br>或者说是已经和银行报备过自己被用来套的路子才能长期存活。<br>当然，丰富账单也是必要的，主要是给银监看的，只要别太过分，银监也装傻；不过，丰富账单对系统评分没卵用</p>
<p>关于代还的认定，这里一般采用池缓冲的概念（最低标准一天两夜，即一晚上加一白天再加一晚上）：<br>任意一笔金额入账时刻止，之前的48/72小时内的总消费入账和总还款入账是银行判定代还的标准：<br>该笔入账及之前48小时内，总消费入账超过额度的70%且总还款入账超过额度的70%则视为代还；<br>该笔入账及之前72小时内，总消费入账超过额度的90%且总还款入账超过额度的90%则视为代还。<br>单笔消费金额/还款金额不作为代还判定要件，相邻两笔消费/还款间的时间间隔不作为代还认定标准</p>
<h1 id="五"><a href="#五" class="headerlink" title="五"></a>五</h1><p><span style="color: #000000;">那年，又到了事业编制的招考，一心想要脱离银行业的我毅然决然的决定备考。幸运地，我考上了，虽然面临着30万的违约金与保密赔偿款<span style="font-size: xx-small;">(已挣回并偿清)</span>，前景也不如在银行那样明朗。但是人没有梦想和咸鱼有什么区别，帮助银行助纣为虐并不是我的理想，从那一刻起，我决定利用银行间的博弈均衡彻底玩弄银行的授信体系，这也许当年的年少轻狂，虽然现在也并不怎么成熟。</span></p>
<p><span style="color: #000000;">不过，这并不是天朝国情决定的，而是资本的本质决定的。</span><br><span style="color: #000000;">即使是传说中刷卡能拒付的美国，拒付其实也没有那么容易成功。</span><br><span style="color: #000000;">在美国（以及大部分资本主义国家）</span><br><span style="color: #000000;">商户分为三类，可信商户、合作商户、普通商户。</span><br><span style="color: #000000;">用户分为三类，受邀用户、高值用户、普通用户。</span><br><span style="color: #000000;">当然，分类标准并不是商户的口碑，而仅仅是商户缴纳的年费，或者说保护费。</span></p>
<p><span style="color: #000000;">当用户等级高于或等于商户等级时，拒付轻松加愉快。</span><br><span style="color: #000000;"> 当用户等级低于          商户等级时，拒付永远失败。</span><br><span style="color: #000000;"> 例如只有受邀用户可以拒付可信商户，受邀用户指银行主动邀请才能办理的高端卡用户，比如运通黑、花旗主席卡</span></p>
<div align="center"><span style="color: #000000;">注意：美国拒付是商户承担资金损失（财货两空）；并不是银行负责赔付</span></div>

<p><span style="color: #000000;">附花旗信用卡协议：</span><br><span style="color: #000000;"> 您不得以未凭密交易、单据上无签名或无交易单据等为由否认交易或拒绝还款。</span></p>
<p><span style="color: #000000;">这里不能不说一下中国的盗刷立案制度，受害人报案制，也就是说：谁的过失谁负责，谁负责谁报案，</span></p>
<div align="center"><span style="color: #000000;">如果是银行的错必须由银行负责报案，如果持卡人泄露的信息则是持卡人进行报案。</span></div>

<p><span style="color: #000000;">如果被盗刷到派出所报案时，一口咬定不是亲友作案，自己也从没泄露过信息，那么肯定立不了案。</span><br><span style="color: #000000;"> 这并非派出所不作为，而是必须提供盗刷信息的泄露途径才能立案；否则，必须银行方面进行报案。</span><br><span style="color: #000000;"> 另一方面，</span><br><span style="color: #000000;"> 除非提供立案材料，否则银行要承担泄露支付信息的刑事风险，(相比于这个风险)钱根本不是问题。</span><br><span style="color: #000000;"> 所有表示银行承认存在可疑交易但拒绝赔付的所谓个人经历一定是软文，银行即使明知也根本不可能承认这一点：</span><br><span style="color: #000000;"> 负责受理盗刷投诉的客服人员只有耍官腔的权力，负责交流细节的只有法务部，律师知道有些真话不能说。</span><br><span style="color: #000000;"> 如果持卡人坚持自己没有泄露过支付信息，但无法提供银行泄露(故意或漏洞)持卡人支付信息的证据：</span><br><span style="color: #000000;"> 那么就会出现银行必须等待立案材料，而派出所表示必须银行方面报案的（伪）踢皮球，形成死锁。</span><br><span style="color: #000000;"> 国内银行赔付信用卡盗刷(名义上)是因为信用卡附赠的保险，但银行不会承认在盗刷事件中存在过错。</span></p>
<h1 id="六"><a href="#六" class="headerlink" title="六"></a>六</h1><p><span style="color: #000000;">说来讽刺，我第一家申请的是单位的工资行——中国银行，然而时至今日仍然没有能够攻略中行白金卡的方法，即使依赖于存款也无济于事，甚至不知道问题出在哪里，或许距离才能产生美。</span></p>
<p><span style="color: #000000;">我得到毕业证的两周后获得了人生中的第一张，不，准确地说是两张校友信用卡，15K的招行，以及半个月之后的建行，只有12K的金卡。</span></p>
<p><span style="color: #000000;">这是一个很讽刺的开局，只有不到3万的额度，却想要玩弄银行的授信体系，这与儿童的妄语其实并没有什么不同。当时，我一度放弃了轻狂的想法；但是讽刺的，成也萧何败也萧何，花旗竟然批复了一张高于当前总额度两倍的卡，即由此，我开始了信用卡的提额之路。</span></p>
<p><table class="t_table" cellspacing="0" bgcolor="#fcfcfc"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td><span style="color: #000000;">退款能否视为还款的通用规则：</span><br><span style="color: #000000;">   账单日之后的退款优先冲抵未出账单； </span><br><span style="color: #000000;">   冲抵未出后余款可用来冲抵已出账单。</span><br><span style="font-size: xx-small; color: #000000;"><br>余款（退款冲抵已出账单部分）：</span><br><span style="color: #000000;">   如果不小于上期账单，视为全额还款；<br>如果小于上期账单，不视为最低还款。</span><br><span style="font-size: xx-small; color: #000000;"><br>当余款小于上期账单时，以下二选一：</span><br><span style="color: #000000;">   ①另行存入达到最低还款额的现金金额</span><br><span style="color: #000000;">   ②补足余款和上期账单全额还款的差额</span></td></p>
<p><td><span style="color: #000000;"><span style="font-size: large;">当天消费入账时刻分节点：</span><span style="font-size: medium;"><br>招商银行：00:00<br>工商银行：06:00【以步步为赢到账为准】<br>中国银行：08:00【中行未持卡，未验证】<br>建设银行：17:00【银联单币：19:00】<br>花旗银行：21:00（浦发银行）【纽约8:00】<br>农业银行：22:00<br>邮储银行：24:00（上海银行）</span></span></td><br><br><br><br>也许是上天眷顾，恰逢建行的清华提额活动，凭借一张清华龙卡和事业单位的工牌从12K直接保送到了100K。而在建行提额的不久，花旗也随之提升了额度，到达了119K，而招商作为我的第一张卡并没有任何变化，此时已经过了2015年的春节，看着手里这三家银行的卡，我决定在将国有银行攻略之前，不再申请其他商业银行的卡，当然交通银行作为股份制重组的银行，并没有在我的日程表之中，取而代之的是出身邮局系统的邮政储蓄银行。</p>
<p>也许是首卡的情怀，或者是对额度的偏执，在申请中行期间，一直不忘关心招行的额度，在第8个多月的时候，招行终于分娩了，奇迹的从15K直接提到了43K，然而这依然是额度最低的一张卡。显然，如果一直保持着低位，必定拉低平均授信额度。最低单行额度反应了你对金融波动承受的幅度，越低的额度意味着你对越低的资金波动反应敏感，银行更关心你的最低单行(含正式销户不足一年)额度，其次才是最高单行(不含已销户)额度。说到信报，顺便提一句：个人明细版和银行打印版信报在信贷交易信息明细后紧接着是查询记录，但是：<br>银行数据版在这两个大类之间还有一个：信贷机构信息明细，这在个人版及银行打印版不体现。<br>包括进行过信用卡审批的所有银行/机构(包括未批卡机构)的列表以及相关数据，此大类下包含：<br>额度使用量峰值(概念类似单月股票最高点)和日均额度占用(概念类似借记卡日均存款)等按机构上报的数据；<br>以及未批卡机构的未批卡原因（一般是”其他原因”，但”进件不实”、”仿真流水”等会以代码形式高亮体现）；<br>以及已销户机构的销整户原因（一般是“个人原因”，但”信贷逾期”、”虚假交易”等会以代码形式高亮体现）。<br>显然，账单日前还款来降低负债(除了自我安慰之外)对银行并没有什么卵用。<br>不过，用来骗小贷公司还是绰绰有余的。</p>
<p>需要特别说明的一点是：即使消掉的账户也不会消失(包括额度)，但是：<br>银行只关心法人机构数，你的信报有多少个账户根本无所谓。</p>
<div class="blockcode"><br><div id="code_kJ4"><br><br>1.  比如建行北京分行发了一张双币卡，建行上海分行发了一张银联单币卡，招行发了一个双币卡。<br>2.  那么你的：<br>3.  账户数是5个。<br>4.  机构数是三个（建行北京分行、建行上海分行、招商银行）<br>5.  法人机构数是两个（建设银行、招商银行）<br></div><br></div>

<p><span style="color: #000000;">接触客户的柜员/客服是看不见具体的拒绝理由的，客服告知的拒批原因都是一本正经的胡说八道。</span><br><span style="color: #000000;">即使你是因为进件身份无法核实真实性，你的理财经理也会在查询之后告诉你是总授信额度过高。</span></p>
<p><span style="color: #000000;">明显的，招行拉低了最低单行的额度，这是有着明确目标的人所不能容忍的；即使现金分期毕业，仍然无法摆脱最低单行的命运；但作为第一张信用卡有一种情怀在里面，所以并没有销卡，而是决定直接申请白金卡；来到支行要了一张白金卡的申请表，也许长相过得去，前台客服并没有为难，轻松地填了银联白的申请表，甚至连信用卡都没有复印，说是查的到；过程很愉快，结局很扯淡，被拒绝了。</span></p>
<p><span style="color: #000000;">这时我才意识到小昭成为了额度的短板，既然柜台不行，那就邮寄；个人邮寄肯定不如柜台，于是另辟蹊径，走了公对公的挂号信邮寄，速度很缓慢，结局很愉快。银联白成功下卡，而且不是起步的6万，直接给了7万。更诡调的是，之后的某一天这张7万的卡被意外的刷空了，竟然还有额度外的现金分期，而这次分期之后的某个周六，恰逢招行大赦天下，又出现了一次分期，此时小昭在一个月之内，额度成为了最高的155K。</span></p>
<h1 id="七"><a href="#七" class="headerlink" title="七"></a>七</h1><p><span style="color: #000000;">关于羊毛或腿毛的性质，内在原理是发卡行对持卡人的定额补偿：</span><br><span style="font-size: medium; color: #000000;">薅羊毛的重点不在于撸没撸，而在于程度是否超过官方福利的阈值标准</span><br><span style="color: #000000;">以招商腿毛卡为例：</span><br>招商金卡正常封顶额度是5万，20元一积分。则50000/20=2500；<br>按每张腿毛卡5000取现计算，可得积分5000/20=250；<br>城市卡每张享有1.5倍积分，两张城市卡相对于3张腿毛卡；<br>因此相对于两张城市卡+7张卡，其中ATM最多取10K单笔，相对于两笔网络，即：<br>每月的标准操作是：两张城市卡+1次ATM取现+5次网络取现；<br><span style="color: #000000;">此时需要，2张城市卡+6张标准腿毛卡，恰为招行推荐的工作地+户籍地城市卡。</span><br><span style="color: #000000;">所以，不难看出：腿毛卡的每月定额补偿积分是以2500分为安全阈值的；</span><br><span style="color: #000000;">无论怎么撸，每月腿毛总收益不超过2500积分就是安全的官方福利；</span><br><span style="color: #000000;">而超过2500分/月就会带来各种各样的评分下降，月撸几十张城市卡的也就呵呵了。</span></p>
<p><span style="color: #000000;">招行达到最高额度之后，我彷徨了；是去申请工商还是先搞定中行？犹豫中，老农来单位推自己的尊然白金卡，只要持卡行在2~5行，单行额度不低于10万的在职职工都能保送尊然白，而且返还首年年费，恰好低空飞过标准线，蒙蒙的填了表，但意外的批了卡，这时我才知道这张没听说过的精粹白是什么卡种。</span></p>
<p><span style="color: #000000;">拿到精粹白的时候，信心嫉妒膨胀，传说中的邮储白成为了奋斗的目标，便无视了中行和工商。当时邮储还没有小白金，邮储白的逼格令我心驰神往，恰逢正式成为副主任科员，当然这在我们单位内算是比较常见的级别，也还属于小兵的范畴。</span></p>
<p><span style="color: #000000;">但是，年轻嘛，不试试怎么行？于是壮着胆子就去了，由于招商成功的经验，我自认为毫无问题，然而连申请表都没有拿到，就被赶了出来。这能忍？当然不能，于是尝试了各种网点，得到的结果都是一样的：白金信用卡没有申请表。</span></p>
<p><span style="color: #000000;">邮储碰壁后，就又开始了工商和中行的申请，恰逢大妈推广大来白金卡，于是工商的大来白成功填了表，当然只是试试看根本没报多大希望，毕竟工行连储蓄账户都没有，而中行那也屡战屡败。结果出乎意料，大来白金卡批了（初始额度不高，后来在和电话客服扯淡时，意外的发现能提额，这是后话）；而中国银行一如既往的坚定，申请失败。</span></p>
<p><span style="color: #000000;">这里说明一下刷卡与费率的问题：</span><br><span style="color: #000000;"><span style="font-size: medium;">如果某档费率的月消费金额不超过月总消费金额的5%，则该费率不计评分</span>。</span><br><span style="color: #000000;">以某月刷卡消费66K<span style="font-size: xx-small;">（注意：不是账单金额）</span>为例：</span><br><span style="color: #000000;">某费率下的总消费金额低于3.3K，则这些消费不会增加评分，更不会减分。</span><br><span style="color: #000000;">对于月消费6万多的持卡人，总额两三千的几笔消费，1.25与刷封顶的效果是完全一样的。</span><br><span style="color: #000000;">所以，不必对偶尔遇到的小额套码耿耿于怀，因为根本无所谓（即使是三农或者封顶）。</span><br><span style="color: #000000;">同样，对于月消费数万元的账户，用小额多笔高费率来美化账单其实也并没有什么卵用。</span></p>
<div class="blockcode"><br><div id="code_BAn"><br><br>1.  <span style="color: #000000;">注：66K和3.3K这两个数值很熟悉吧，提醒一下：</span><br>2.  <span style="color: #000000;">建行：45K<em>(1+50%)=67.5K（你懂得）</em></span><br>3.  <span style="color: #000000;">中行：50K(1+30%)=65K（搬砖办卡）</span><br>4.  <span style="color: #000000;">招行：60K+5K=65K（现金分期）</span><br>5.  <span style="color: #000000;">封顶：26/0.78%=3.333K</span><br></div><br></div><br><span style="color: #000000;">元旦左右，坐飞机回北京，想着15号线比机场线换乘走的路要少（13号线的步行距离你懂的），于是乘坐了空港3路，诡吊的是在天竺村附近车抛锚了，地图上看附近有家邮储支行就又去试了试，结果意外的凭工牌和精粹白填了一张表（虽然没要精粹白的复印件），更意外的是竟然批卡了，虽然是所有银行额度最低的一张卡，但总归里离集齐国有行更近了一步。</span><br><br><span style="color: #000000;">虽然，第一家申请的信用卡，到现在还没有攻略成功……</span><br><br># 八<br><br><span style="color: #000000;">最后，告诫诸位：</span><br><br><span style="color: #000000;">信用卡套出来锦上添花，会成为卡神；套出来用于苟延残喘，则更加卡奴。</span><br><br><span style="color: #000000;">当不用也过得去，就放心大胆的用，不用来生钱的钱不过是一堆废纸。</span><br><span style="color: #000000;">当不用就过不去，请千万别用，否则不过是饮鸩止渴。</span><br><br><span style="color: #000000;">卡神与卡奴的核心不在于奇技淫巧，而在于是否有额度外的存款使之活盘。</span><br><br><span style="color: #000000;">如果已经负资产，同样也有成为卡神的机会，但请确保手上的闲置存款不要低于总负债的20%。</span><br><span style="color: #000000;">看起来这样的闲置负债将加大利息成本，但请记住只有资金是活盘的总还有希望。</span><br><br><strong><span style="color: #000000;">当闲置存款低于负债的16.5%这条活盘警戒线超过7日，终会被债务拖垮，万劫不复。</span></strong><br><br><span style="color: #000000;">注：闲置存款不限于定活期：<br>余额宝、招行朝朝盈等能实时取现的都算闲置存款，但不包括各种封闭期禁止取款的理财产品。</span><br><br><span style="color: #000000;">建行看重代发收入<span style="font-size: xx-small;">(象征国家建设的贡献)           </span>中行看重行内存款<span style="font-size: xx-small;">(象征国库保障的需要)</span></span><br><br><span style="color: #000000;">工商看重理财贡献<span style="font-size: xx-small;">(象征以钱生钱的能力</span><span style="font-size: xx-small;">)           </span>农行看重单位性质<span style="font-size: xx-small;">(象征术业专攻的特性)</span></span><br><br><span style="font-size: large; color: #000000;">附录：销卡威胁处理流程</span><br><br><div class="blockcode"><br><br>1.  <span style="color: #000000;">销卡不销户？是，下一步；否，转第3步；</span><br>2.  <span style="color: #000000;">销卡成功，结束。</span><br>3.  <span style="color: #000000;">确认用户诉求并挽留？无需销户，下一步；销户，转第5步；</span><br>4.  <span style="color: #000000;">客户是否有其他诉求（如：提额、年费优惠）？是，下一步；否，转第2步；</span><br>5.  <span style="color: #000000;">不可逆确认？是，下一步；否，转第2步；</span><br>6.  <span style="color: #000000;">系统评测是否通过客户诉求？是，下一步；否，转第8步；</span><br>7.  <span style="color: #000000;">客户同意系统评测结果？是，调整后结束；否，下一步；</span><br>8.  <span style="color: #000000;">系统评测客户综合评分？高，下一步；一般或较低，转第10步；</span><br>9.  <span style="color: #000000;">客户是否反悔销户请求？是，结束；否，下一步；</span><br>10.  <span style="color: #000000;">销户成功，不可恢复，结束。</span><br></div>

<blockquote>
<p>原文刊自某信用卡论坛。某年某日拜读之后，收获巨大，特此转载。感谢作者。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt; 哲学上的负债,关于人性. &lt;/p&gt;
    
    </summary>
    
      <category term="金融理财" scheme="http://yoursite.com/categories/%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/"/>
    
    
      <category term="金融" scheme="http://yoursite.com/tags/%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记八：简单的RSS阅读器</title>
    <link href="http://yoursite.com/2016/05/04/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%85%AB%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84RSS%E9%98%85%E8%AF%BB%E5%99%A8/"/>
    <id>http://yoursite.com/2016/05/04/UWP开发笔记八：简单的RSS阅读器/</id>
    <published>2016-05-03T21:00:23.000Z</published>
    <updated>2016-10-28T13:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>一个简单的RSS阅读器. </p>

<a id="more"></a>
<p>一个简单的RSS阅读器，实现任意开启RSS网站内容订阅，不过，只能在阅读器中搜集到标题、日期。后期再补充。</p>
<p>这次起，把所有功能代码放在类中，MainPage不能再那么随便了。</p>
<p>新建RSSClass类：</p>
<pre><code>    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    // ItemsControl
    using Windows.UI.Xaml.Controls;
    // KeyRoutedEventArgs 
    using Windows.UI.Xaml.Input;
    // SyndicationClient 
    using Windows.Web.Syndication;

    namespace RSS阅读器
    {
      public   class RssClass
        {
            // 下载指定url的feed条目，逐一将其整合到集合控件ItemsControl中
            private async void Load(ItemsControl list,Uri url)
            {
                // 从URL异步检索源
                SyndicationClient client = new SyndicationClient();
                // 开始一个异步操作以下载从给定的URI的聚合feed。
                SyndicationFeed feed =await client.RetrieveFeedAsync(url);
                // 遍历feed中的所有item，将其添加到list中
                foreach (var item in feed.Items)
                {
                    list.Items.Add(item);
                }
            }

            // 
            public void Start(ref ItemsControl list,string url,KeyRoutedEventArgs args)
            {
                // 当按下回车键时
                if (args.Key== Windows.System.VirtualKey.Enter)
                {
                    try
                    {
                        Load(list, new Uri(url));
                    }
                    catch (Exception)
                    {

                        throw;
                    }
                    // 设置控件的焦点
                    list.Focus(Windows.UI.Xaml.FocusState.Keyboard);
                }
            }
        }
}
</code></pre><p>页面代码：</p>
<pre><code>&lt;Grid.RowDefinitions&gt;
           &lt;RowDefinition Height=&quot;Auto&quot;/&gt;
           &lt;RowDefinition Height=&quot;*&quot;/&gt;
       &lt;/Grid.RowDefinitions&gt;
       &lt;TextBox Name=&quot;URLTextBox&quot;
                Margin=&quot;10&quot;
                KeyDown=&quot;URLTextBox_KeyDown&quot;
                PlaceholderText=&quot;请输入RSS地址&quot;/&gt;
       &lt;ScrollViewer VerticalScrollBarVisibility=&quot;Auto&quot;
                     HorizontalScrollBarVisibility=&quot;Auto&quot;
                     Margin=&quot;20&quot;
                     Grid.Row=&quot;1&quot;&gt;

           &lt;ItemsControl Name=&quot;ListItemsControl&quot;&gt;
                   &lt;ItemsControl.ItemTemplate&gt;
                       &lt;!--数据模板--&gt;
                       &lt;DataTemplate&gt;
                       &lt;StackPanel&gt;
                           &lt;!--超链接--&gt;
                           &lt;HyperlinkButton NavigateUri=&quot;{Binding Path=Links[0].Uri}&quot;&gt;
                               &lt;!--超链接标题--&gt;
                               &lt;HyperlinkButton.Content&gt;
                                   &lt;TextBlock Text=&quot;{Binding Path=Title.Text}&quot;/&gt;
                               &lt;/HyperlinkButton.Content&gt;
                           &lt;/HyperlinkButton&gt;

                           &lt;!--文章日期--&gt;
                           &lt;TextBlock Text=&quot;{Binding Path=PublishedDate}&quot;/&gt;
                       &lt;/StackPanel&gt;
                       &lt;/DataTemplate&gt;
                   &lt;/ItemsControl.ItemTemplate&gt;
               &lt;/ItemsControl&gt;

       &lt;/ScrollViewer&gt;
</code></pre><p>cs逻辑代码：</p>
<pre><code>private RssClass rss = new RssClass();
       private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
       {
           rss.Start(ref ListItemsControl, URLTextBox.Text, e);
       }
</code></pre><p>明显清晰许多。</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>ItemsControl的数据绑定：</p>
<pre><code>&lt;ItemsControl Name=&quot;ListItemsControl&quot;&gt;
            &lt;ItemsControl.ItemTemplate&gt;
                             &lt;DataTemplate&gt;

                              &lt;/DataTemplate&gt;
             &lt;/ItemsControl.ItemTemplate&gt;
&lt;/ItemsControl&gt;
</code></pre><p>ScrollViewer的两个属性：</p>
<pre><code>VerticalScrollBarVisibility=”Auto”
HorizontalScrollBarVisibility=”Auto”
</code></pre><p>绑定RSS内容：</p>
<p>链接：<br>        <code>&lt;HyperlinkButton NavigateUri=”{Binding Path=Links[0].Uri}”&gt;</code></p>
<p>链接标题：<code>&lt;TextBlock Text=”{Binding Path=Title.Text}”/&gt;</code></p>
<p>文章日期：<br>        <code>&lt;TextBlock Text=”{Binding Path=PublishedDate}”/&gt;</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;一个简单的RSS阅读器. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记七：WebView与简单浏览器</title>
    <link href="http://yoursite.com/2016/05/02/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%EF%BC%9AWebView%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://yoursite.com/2016/05/02/UWP开发笔记七：WebView与简单浏览器/</id>
    <published>2016-05-01T21:00:18.000Z</published>
    <updated>2016-10-28T13:33:09.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>利用webview控件可以简单制作一个浏览器. </p>

<a id="more"></a>
<p>利用webview控件可以简单制作一个浏览器，实现基本的前进、后退、刷新、停止等功能。不过需要注意的是，如果网页是在新窗口打开，那就承受不了了，将自动用系统默认浏览器打开。所以，前进、后退功能的前提是：打开的网页是在同一个窗口。</p>
<p>命令栏代码：</p>
<pre><code>&lt;Page.BottomAppBar&gt;
        &lt;AppBar IsOpen=”True”&gt;
            &lt;StackPanel Orientation=”Horizontal”&gt;
                &lt;AppBarButton Name=”BackAppBarButton”
                              Click=”BackAppBarButton_Click”
                              Label=”返回”
                              Icon=”Back”/&gt;
                &lt;AppBarButton Name=”ForwardAppBarButton”
                              Label=”前进”
                              Icon=”Forward”
                              Click=”ForwardAppBarButton_Click”/&gt;
                &lt;AppBarButton Name=”RefreshAppBarButton”
                              Label=”刷新”
                              Icon=”Refresh”
                              Click=”RefreshAppBarButton_Click”/&gt;
                &lt;AppBarButton Name=”StopAppBarButton”
                              Click=”StopAppBarButton_Click”
                              Label=”停止”
                              Icon=”Stop”/&gt;
            &lt;/StackPanel&gt;
        &lt;/AppBar&gt;
    &lt;/Page.BottomAppBar&gt;
</code></pre><p>页面：</p>
<pre><code>&lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height=”Auto”/&gt;
            &lt;RowDefinition Height=”*”/&gt;
        &lt;/Grid.RowDefinitions&gt;
        &lt;TextBox Name=”URLTextBox”
                 InputScope=”Url”
                 KeyDown=”URLTextBox_KeyDown”
                 Margin=”20”/&gt;
        &lt;WebView Name=”Web”
                 Grid.Row=”1”
                 NavigationCompleted=”Web_NavigationCompleted”/&gt;

&lt;/Grid&gt;
</code></pre><p>后台逻辑：</p>
<pre><code>     // 返回处理
            private void BackAppBarButton_Click(object sender, RoutedEventArgs e)
            {
                if (Web.CanGoBack)
                {
                    Web.GoBack();
                }
            }

    // 前进处理
    private void ForwardAppBarButton_Click(object sender, RoutedEventArgs e)
    {
        if (Web.CanGoForward)
        {
            Web.GoForward();
        }
    }

    // 刷新
    private void RefreshAppBarButton_Click(object sender, RoutedEventArgs e)
    {
        Web.Refresh();
    }

    // 停止
    private void StopAppBarButton_Click(object sender, RoutedEventArgs e)
    {
        Web.Stop();
    }

    // 按（回车）键处理
    private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
    {
        // 如果按下的键是回车键
        if (e.Key== Windows.System.VirtualKey.Enter)
        {
            // 导航到文本框中的地址
            Web.Navigate(new Uri(URLTextBox.Text));
        }

        // 处理焦点
        Web.Focus(FocusState.Keyboard);
    }

    // 导航完成事件处理
    private void Web_NavigationCompleted(WebView sender, WebViewNavigationCompletedEventArgs args)
    {
        // 导航是否成功
        if (args.IsSuccess)
        {
            // 参数传递到地址栏
            URLTextBox.Text = args.Uri.ToString();
    }

}&lt;/pre&gt;
</code></pre><p>可以看到效果(原谅我无耻地用了自己的博客）：</p>
<p>初始页面：<img src="http://images.chenyalun.cn/2016/04/23/001.png" alt=""></p>
<p>打开新链接：</p>
<p><img src="http://images.chenyalun.cn/2016/04/23/002.png" alt=""></p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>对键盘的按键（回车）键处理：</p>
<pre><code>private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
{
// 如果按下的键是回车键
if (e.Key== Windows.System.VirtualKey.Enter)
{
// 导航到文本框中的地址
Web.Navigate(new Uri(URLTextBox.Text));
}
}
</code></pre><p>对焦点的处理：<br><code>Web.Focus(FocusState.Keyboard);</code></p>
<p>还有就是，文本框（地址栏）输入的文本必须是URL，即 <a href="http://chenyalun.com/" target="_blank" rel="external">http://chenyalun.com/</a> 如果是chenyalun.com那就会报错了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;利用webview控件可以简单制作一个浏览器. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记六：幸运彩色小球</title>
    <link href="http://yoursite.com/2016/04/30/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9A%E5%B9%B8%E8%BF%90%E5%BD%A9%E8%89%B2%E5%B0%8F%E7%90%83/"/>
    <id>http://yoursite.com/2016/04/30/UWP开发笔记六：幸运彩色小球/</id>
    <published>2016-04-29T21:00:46.000Z</published>
    <updated>2016-10-28T13:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>幸运彩色小球游戏. </p>

<a id="more"></a>
<p>这个和随机数与筛子游戏有异曲同工之妙，通过随机函数产生一定范围大小的数字，根据数字大小设定不同的颜色，点击命令栏的新建按钮，面板清空，重新产生一轮数字。</p>
<p>命令栏：</p>
<pre><code>&lt;Page.BottomAppBar&gt;
        &lt;AppBar&gt;
            &lt;StackPanel Orientation=”Horizontal”&gt;
                &lt;AppBarButton Name=”NewAppBarButton”
                              Label=”新建”
                              Icon=”NewFolder”
                              Click=”NewAppBarButton_Click”/&gt;
            &lt;/StackPanel&gt;
        &lt;/AppBar&gt;
    &lt;/Page.BottomAppBar&gt;
</code></pre><p>页面代码：</p>
<pre><code>&lt;StackPanel HorizontalAlignment=”Center”
            VerticalAlignment=”Center”
            Name=”DisplayStackPanel”
                    Orientation=”Horizontal”/&gt;
</code></pre><p>当然，为了方便起见，创建一个ShowBall类：需要引入的命名空间有：</p>
<pre><code>//Thickness
using Windows.UI.Xaml;
//控件
using Windows.UI.Xaml.Controls;
//SolidColorBrush
using Windows.UI.Xaml.Media;
//球
using Windows.UI.Xaml.Shapes;
</code></pre><p>完整代码：</p>
<pre><code>    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    //color
    using Windows.UI;

    //Thickness
    using Windows.UI.Xaml;
    //控件
    using Windows.UI.Xaml.Controls;
    //SolidColorBrush
    using Windows.UI.Xaml.Media;
    //球
    using Windows.UI.Xaml.Shapes;

    namespace Lucky_Lotto
    {
    public class ShowBall
    {
    // 定义随机数(种子为日期和时间的计时周期）
    private Random random = new Random((int)DateTime.Now.Ticks);

        // 定义获取数字集合方法
        private List&amp;lt;int&amp;gt; GetNumbers()
        {
            int Number;
            // 定义Numbers集合
            List&amp;lt;int&amp;gt; Numbers = new List&amp;lt;int&amp;gt;();
            // 当Numbers集合中整数个数小于6时，自动增加
            while (Numbers.Count &amp;lt; 6)
            {
                // 随机获取1到50之间的整数赋予Number（Number可以取1，不可取50）
                Number = random.Next(1, 50);
                // 将产生的随机数添加到集合之中
                // 处理当集合中的整数与产生的随机数相同的情况
                if (!Numbers.Contains(Number)||Number&amp;lt;1)
                {
                    Numbers.Add(Number);
                }
                // 对集合中的数字进行有序整理（美观起见）
                Numbers.Sort();
            }

            return Numbers;

        }
        // 对StackPanel进行处理：创建小球，增添颜色等
        // 将每个小球分别放在Canva中s，6个Canvas放在一个StackPanel中
        public void PlayBall(ref StackPanel stackpanel)
        {
            // 清空原先讯在的元素
            stackpanel.Children.Clear();

            // 对数字集合遍历
            foreach(int number in GetNumbers())
            {
                // 定义Canvas
                Canvas canvas = new Canvas();
                canvas.Width = 48;
                canvas.Height = 48;
                canvas.Margin = new Thickness(2);

                // 定义球
                Ellipse ellipse = new Ellipse();
                ellipse.Width = canvas.Width;
                ellipse.Height = canvas.Height;
                // 设置小球边框颜色是黑色
                ellipse.Stroke = new SolidColorBrush(Colors.Black);

                // 根据数字的大小设置小球的填充颜色
                if (number &amp;gt;= 1 &amp;amp;&amp;amp; number &amp;lt;= 9)
                {
                    ellipse.Fill = new SolidColorBrush(Colors.White);
                }
                else if (number &amp;gt; 9 &amp;amp;&amp;amp; number &amp;lt;= 19)
                {
                    ellipse.Fill = new SolidColorBrush(Color.FromArgb(255, 112, 200, 236));
                }
                else if (number &amp;gt; 19 &amp;amp;&amp;amp; number &amp;lt;= 29)
                {
                    ellipse.Fill = new SolidColorBrush(Colors.Magenta);
                }
                else if (number &amp;gt; 29 &amp;amp;&amp;amp; number &amp;lt;= 39)
                {
                    ellipse.Fill = new SolidColorBrush(Color.FromArgb(255, 112, 255, 0));
                }
                else if (number &amp;gt; 39 &amp;amp;&amp;amp; number &amp;lt;= 49)
                {
                    ellipse.Fill = new SolidColorBrush(Colors.Yellow);
                }

                // 定义球中的文本（数字）
                TextBlock textBlock = new TextBlock();
                textBlock.Text = number.ToString();
                textBlock.FontSize = 16;
                textBlock.Foreground = new SolidColorBrush(Colors.Black);
                textBlock.Margin = new Thickness(16, 12, 16, 12);

                // 将文本（数字）、小球添加到canvas中，将canvas添加到stackpanel中
                // 一定先添加球，再添加文本，否则文本不会显示
                canvas.Children.Add(ellipse);
                canvas.Children.Add(textBlock);
                stackpanel.Children.Add(canvas);
        }
    }
}

}
</code></pre><p>这样主页面的后台代码就可以轻松的调用了：</p>
<pre><code> // 新建类的实例
        public  ShowBall showball = new ShowBall();
        private void NewAppBarButton_Click(object sender, RoutedEventArgs e)
        {

  showball.PlayBall(ref DisplayStackPanel);
}&lt;/pre&gt;
</code></pre><p>演示：</p>
<p><img src="http://images.chenyalun.cn/2016/04/22/001.png" alt=""><img src="http://images.chenyalun.cn/2016/04/22/002.png" alt=""></p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><pre><code>// 对数字集合遍历
foreach(int number in GetNumbers())  {}

// 设置小球边框颜色是黑色
ellipse.Stroke = new SolidColorBrush(Colors.Black);

//设置margin

textBlock.Margin = new Thickness(16, 12, 16, 12);

// 一定先添加球，再添加文本，否则文本不会显示
canvas.Children.Add(ellipse);
canvas.Children.Add(textBlock);
stackpanel.Children.Add(canvas);

// 清空原先存在的元素
stackpanel.Children.Clear();

// 对集合中的数字进行有序整理（美观起见）
Numbers.Sort();

// 定义随机数(种子为日期和时间的计时周期）
private Random random = new Random((int)DateTime.Now.Ticks);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;幸运彩色小球游戏. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记五：应用数据本地存储</title>
    <link href="http://yoursite.com/2016/04/28/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%9A%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2016/04/28/UWP开发笔记五：应用数据本地存储/</id>
    <published>2016-04-27T21:00:59.000Z</published>
    <updated>2016-10-28T13:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>应用数据存储. </p>

<a id="more"></a>
<p>应用数据存储有两种形式，一种存储在本地，另一种是漫游到云端。输入信息，保存在本地，点击显示按钮，重新显现刚刚输入的信息。</p>
<p>命令栏代码：</p>
<p><pre class="lang:default decode:true ">&lt;Page.BottomAppBar&gt;<br>        &lt;AppBar&gt;<br>            &lt;StackPanel Orientation=”Horizontal”&gt;<br>                &lt;AppBarButton Name=”NewAppBarButton”<br>                              Icon=”Page”<br>                              Label=”新建”<br>                              Click=”NewAppBarButton_Click”/&gt;<br>                &lt;AppBarButton Name=”LoadAppBarButton”<br>                              Icon=”Folder”<br>                              Label=”显示”<br>                              Click=”LoadAppBarButton_Click”/&gt;<br>                &lt;AppBarButton Name=”SaveAppBarButton”<br>                              Icon=”Save”<br>                              Label=”保存”<br>                              Click=”SaveAppBarButton_Click”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.BottomAppBar&gt;</pre><br>页面代码：</p>
<p><pre class="lang:default decode:true "> &lt;StackPanel&gt;<br>            &lt;TextBox Name=”Email”<br>                     PlaceholderText=”邮箱”<br>                     Margin=”20”<br>                     InputScope=”EmailSmtpAddress”/&gt;<br>            &lt;TextBox Name=”Web”<br>                     PlaceholderText=”网址”<br>                     Margin=”20”<br>                     InputScope=”Url”/&gt;<br>            &lt;TextBox Name=”Tel”<br>                     PlaceholderText=”手机号码”<br>                     Margin=”20”<br>                     InputScope=”TelephoneNumber”/&gt;<br>        &lt;/StackPanel&gt;</pre><br>后台逻辑：</p>
<p><pre class="lang:default decode:true ">  //  新建存储<br>        private void NewAppBarButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            Email.Text = string.Empty;<br>            Web.Text = string.Empty;<br>            Tel.Text = string.Empty;<br>        }</pre></p>
<pre><code>// 保存信息
private void SaveAppBarButton_Click(object sender, RoutedEventArgs e)
{
    Save(&quot;Email&quot;, Email.Text);
    Save(&quot;Web&quot;, Web.Text);
    Save(&quot;Tel&quot;, Tel.Text);
}

// 加载存储信息
private void LoadAppBarButton_Click(object sender, RoutedEventArgs e)
{
    Email.Text = Load(&quot;Email&quot;);
    Web.Text = Load(&quot;Web&quot;);
    Tel.Text = Load(&quot;Tel&quot;);
}

// 应用本地设置信息存储:保存 键 值
public void Save(string key,string value)
{
    ApplicationData.Current.LocalSettings.Values[key] = value;
}

// 加载应用本地设置存储的信息
public string Load(string key)
{
    if (ApplicationData.Current.LocalSettings.Values[key]!=null)
    {
        return ApplicationData.Current.LocalSettings.Values[key].ToString();
    }

    return string.Empty;
}&lt;/pre&gt;
</code></pre><p>输入信息并保存：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/005.png" alt=""></p>
<p>点击新建清空数据，点击显示：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/006.png" alt=""></p>
<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><ul>
<li>空字符串：string.Empty</li>
<li>保存的方式为键值对：key和value</li>
<li>本地设置类： ApplicationData.Current.LocalSettings.Values[key] = value;其中key一般是字符串，value是保存的值</li>
<li>需要引入命名空间：应用数据存储  using Windows.Storage;</li>
<li>删除存储 ApplicationData.Current.LocalSettings.Values.Remove(“key”); 其中key是键<br>&nbsp;</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;应用数据存储. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记四：随机数与筛子游戏</title>
    <link href="http://yoursite.com/2016/04/26/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E7%AD%9B%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <id>http://yoursite.com/2016/04/26/UWP开发笔记四：随机数与筛子游戏/</id>
    <published>2016-04-25T21:00:25.000Z</published>
    <updated>2016-10-28T13:41:18.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>随机数与筛子游戏<br>. </p>

<a id="more"></a>
<p>点击方块，方块随机出现类似筛子的点数，连续点击，连续出现随机的数。当然，是有两个方块的。点击底部命令栏的刷新按钮，两块“筛子”均恢复空白状态。</p>
<p>命令栏：</p>
<p><pre class="lang:default decode:true ">&lt;Page.BottomAppBar&gt;<br>        &lt;AppBar&gt;<br>            &lt;StackPanel Orientation=”Horizontal”&gt;<br>                    &lt;AppBarButton Name=”NewAppBarButton”<br>                                  Icon=”Page”<br>                                  Click=”NewAppBarButton_Click”<br>                                  Label=”刷新”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.BottomAppBar&gt;</pre><br>页面代码：</p>
<p><pre class="lang:default decode:true "> &lt;Grid.ColumnDefinitions&gt;<br>            &lt;ColumnDefinition Width=”<em>“/&gt;<br>            &lt;ColumnDefinition Width=”Auto”/&gt;<br>            &lt;ColumnDefinition Width=”</em>“/&gt;<br>            &lt;ColumnDefinition Width=”Auto”/&gt;<br>            &lt;ColumnDefinition Width=”*”/&gt;<br>        &lt;/Grid.ColumnDefinitions&gt;</pre></p>
<pre><code>    &amp;lt;Grid Name=&quot;FirstGrid&quot;
          Tapped=&quot;FirstGrid_Tapped&quot;
          Width=&quot;100&quot;
          Height=&quot;100&quot;
          Background=&quot;HotPink&quot;
          Grid.Column=&quot;1&quot;&amp;gt;
        &amp;lt;Grid.RowDefinitions&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
            &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;/Grid.RowDefinitions&amp;gt;
        &amp;lt;Grid.ColumnDefinitions&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;/Grid.ColumnDefinitions&amp;gt;
    &amp;lt;/Grid&amp;gt;

&amp;lt;Grid Name=&quot;SecondGrid&quot;
          Tapped=&quot;SecondGrid_Tapped&quot;
          Width=&quot;100&quot;
          Height=&quot;100&quot;
          Background=&quot;HotPink&quot;
          Grid.Column=&quot;3&quot;&amp;gt;
    &amp;lt;Grid.RowDefinitions&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
        &amp;lt;RowDefinition /&amp;gt;
    &amp;lt;/Grid.RowDefinitions&amp;gt;
    &amp;lt;Grid.ColumnDefinitions&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;ColumnDefinition/&amp;gt;
    &amp;lt;/Grid.ColumnDefinitions&amp;gt;

&amp;lt;/Grid&amp;gt;&lt;/pre&gt;
</code></pre><p>后台代码MainPage.xaml.cs：</p>
<p>引入命名空间：</p>
<p><pre class="lang:default decode:true ">//颜色<br>using Windows.UI;<br>//图形<br>using Windows.UI.Xaml.Shapes;</pre><br>逻辑代码：</p>
<p><pre class="lang:default decode:true"> private void NewAppBarButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            //刷新页面<br>            FirstGrid.Children.Clear();<br>            SecondGrid.Children.Clear();<br>        }</pre></p>
<pre><code>    private void FirstGrid_Tapped(object sender, TappedRoutedEventArgs e)
    {
        // 移除面板上所有元素
        FirstGrid.Children.Clear();
        switch (Number())
        {
            case 0:
            case 1:
                Add(FirstGrid, 1, 1);
                break;
            case 2:
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 0);
                break;
            case 3:
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 1, 1);
                Add(FirstGrid, 2, 0);
                break;
            case 4:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 0);
                Add(FirstGrid, 2, 2);
                break;
            case 5:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 2, 2);
                Add(FirstGrid, 1, 1);
                Add(FirstGrid, 2, 0);
                break;
            case 6:
                Add(FirstGrid, 0, 0);
                Add(FirstGrid, 0, 2);
                Add(FirstGrid, 1, 0);
                Add(FirstGrid, 1, 2);
                Add(FirstGrid, 2, 0);
                Add(FirstGrid, 2, 2);
                break;
        }
    }

// 设置随机数
    public int Number()
    {
        // 返回0到7之间的随机整数
        return new Random().Next(0, 7);
    }

    // 设置添加圆点
    public void Add(Grid grid, int row, int col)
    {

        Ellipse ell = new Ellipse();
        // 设置填充颜色
        ell.Fill = new SolidColorBrush(Colors.White);
        // 设置宽高度
        ell.Width = 20;
        ell.Height = 20;
        // 设置圆点的在表格上的位置
        ell.SetValue(Grid.RowProperty, row);
        ell.SetValue(Grid.ColumnProperty, col);
        // 获取面板元素（把ell元素添加到面板中）
        grid.Children.Add(ell);
    }

    private void SecondGrid_Tapped(object sender, TappedRoutedEventArgs e)
    {
        // 移除面板上所有元素
        SecondGrid.Children.Clear();
        switch (Number())
        {
            case 0:
            case 1:
                Add(SecondGrid, 1, 1);
                break;
            case 2:
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 0);
                break;
            case 3:
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 1, 1);
                Add(SecondGrid, 2, 0);
                break;
            case 4:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 0);
                Add(SecondGrid, 2, 2);
                break;
            case 5:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 2, 2);
                Add(SecondGrid, 1, 1);
                Add(SecondGrid, 2, 0);
                break;
            case 6:
                Add(SecondGrid, 0, 0);
                Add(SecondGrid, 0, 2);
                Add(SecondGrid, 1, 0);
                Add(SecondGrid, 1, 2);
                Add(SecondGrid,2, 0);
                Add(SecondGrid, 2, 2);
                break;
        }
    }&lt;/pre&gt;
</code></pre><p>点击出现筛子点数：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/001.png" alt=""></p>
<p>点击刷新按钮，清空所有元素：</p>
<p><img src="http://images.chenyalun.cn/2016/04/21/002.png" alt=""></p>
<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><ul>
<li><h3 id="随机数："><a href="#随机数：" class="headerlink" title="随机数："></a>随机数：</h3></li>
</ul>
<p>Random()与时间相关的种子；</p>
<p>Random(seed)指定种子；</p>
<p>Random().NextDouble返回大于或等于0.0且小于1.0的随机浮点数；</p>
<p>Random().Next()返回非负随机整数；</p>
<p>Random().Next(下限，上限)返回指定范围非负随机整数（可取下限，不可取上限）；</p>
<h3 id="设置图形依赖属性："><a href="#设置图形依赖属性：" class="headerlink" title="设置图形依赖属性："></a>设置图形依赖属性：</h3><p>Ellipse ell = new Ellipse();</p>
<p>// 设置填充颜色<br>ell.Fill = new SolidColorBrush(Colors.White);</p>
<p>// 设置圆点的在表格上的位置<br>ell.SetValue(Grid.RowProperty, row);<br>ell.SetValue(Grid.ColumnProperty, col);<br>// 获取面板元素（把ell元素添加到面板中）<br>grid.Children.Add(ell);</p>
<p>// 移除面板上所有元素<br>SecondGrid.Children.Clear();</p>
<p>总结：代码比较琐碎，而且不是很令人满意，xaml创建图形很方便，可是处理逻辑的时候没有思路，只好把图形创建的代码写在后台。本想写个方法同时处理两个方块，然而并没有成功〒_〒</p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;随机数与筛子游戏&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记三：动画编程之图形的翻转</title>
    <link href="http://yoursite.com/2016/04/24/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E5%8A%A8%E7%94%BB%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9B%BE%E5%BD%A2%E7%9A%84%E7%BF%BB%E8%BD%AC/"/>
    <id>http://yoursite.com/2016/04/24/UWP开发笔记三：动画编程之图形的翻转/</id>
    <published>2016-04-23T21:00:40.000Z</published>
    <updated>2016-10-28T13:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>动画编程小尝试<br>. </p>

<a id="more"></a>
<p>动画编程可以实现很酷的很炫的效果，能让开发出的App散发无穷无尽的魅力，在颜值至上的时代，好看是检验UI的唯一标准。图形的翻转主要有三种形式：RotationX，RotationY，RotationZ，就是获取或设置围绕旋转的 X 轴或Y轴或Z轴旋转对象的角度。</p>
<p>计划在文本框中键入图片的地址源，按回车载入图片，点击命令栏中按钮，图片做出相应变换。</p>
<p>XAML代码：</p>
<pre class="lang:default decode:true ">&lt;!--命令栏--&gt;
    &lt;Page.BottomAppBar&gt;
        &lt;AppBar IsSticky="True"&gt;
            &lt;StackPanel Orientation="Horizontal" HorizontalAlignment="Right"&gt;
            &lt;AppBarButton Name="XRotateAppBarButton"
                          Icon="RepeatAll"
                          Label="Pitch"
                          Click="XRotateAppBarButton_Click"/&gt;
            &lt;AppBarButton Name="YRotateAppButton"
                          Icon="Rotate"
                          Label="Roll"
                          Click="YRotateAppButton_Click"/&gt;
            &lt;AppBarButton Name="ZRotateAppBarButton"
                          Icon="Refresh"
                          Label="Yaw"
                          Click="ZRotateAppBarButton_Click"/&gt;
            &lt;/StackPanel&gt;

        &lt;/AppBar&gt;
    &lt;/Page.BottomAppBar&gt;

    &lt;!--动画--&gt;
    &lt;Page.Resources&gt;
        &lt;!--X方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardX"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationX)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;

        &lt;!--Y方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardY"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationY)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;

        &lt;!--Z方向翻转--&gt;
        &lt;Storyboard x:Name="StoryBoardZ"&gt;
            &lt;DoubleAnimation Storyboard.TargetName="ResultImage"
                             Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationZ)"
                             From="0.0"
                             To="360.0"
                             AutoReverse="True"
                             RepeatBehavior="Forever"&gt;
            &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;
    &lt;/Page.Resources&gt;

    &lt;Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height="Auto"/&gt;
            &lt;RowDefinition Height="Auto"/&gt;
            &lt;RowDefinition Height="*"/&gt;
        &lt;/Grid.RowDefinitions&gt;
        &lt;TextBlock Text="请输入图片的地址"
                   HorizontalAlignment="Center"
                   Height="30"/&gt;
        &lt;TextBox  Grid.Row="1"
                  Name="URLTextBox"
                   FontSize="20"
                   HorizontalAlignment="Stretch"
                   Height="40"
                   Margin="20"
                   InputScope="Url"
                   KeyDown="URLTextBox_KeyDown"/&gt;
        &lt;Image Grid.Row="2"
               Name="ResultImage"
               Margin="60"
               Stretch="Uniform"&gt;
            &lt;!--注意一定要声明-Projection属性--&gt;
            &lt;Image.Projection&gt;
                &lt;PlaneProjection /&gt;
            &lt;/Image.Projection&gt;
        &lt;/Image&gt;
    &lt;/Grid&gt;</pre>
原图：

![](http://images.chenyalun.cn/2016/04/20/101.png)

X轴翻转:

![](http://images.chenyalun.cn/2016/04/20/102.gif)

&nbsp;

Y轴翻转：![](http://images.chenyalun.cn/2016/04/20/103.gif)

以及Z轴翻转：![](http://images.chenyalun.cn/2016/04/20/104.gif)

CS 代码（主要是获取文本框中的URL，以及处理按钮事件）：
<pre class="lang:default decode:true "> // TextBox输入完毕按下回车后，得到图片来源
        private void URLTextBox_KeyDown(object sender, KeyRoutedEventArgs e)
        {
            // 判断与事件关联的输入按钮是否为虚拟按键的Enter键
            if (e.Key==Windows.System.VirtualKey.Enter)
            {
                ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(new Uri(URLTextBox.Text));
            }
        }

        // 设置按下按钮后的翻转效果
        private   void XRotateAppBarButton_Click(object sender, RoutedEventArgs e)
        {
             StoryBoardX.Begin();
        }

        private void YRotateAppButton_Click(object sender, RoutedEventArgs e)
        {
            StoryBoardY.Begin();
        }

        private void ZRotateAppBarButton_Click(object sender, RoutedEventArgs e)
        {
            StoryBoardZ.Begin();
        }</pre>

<hr>
<hr>
<h2 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h2><h3 id="1-处理文本框的回车事件中，"><a href="#1-处理文本框的回车事件中，" class="headerlink" title="1,处理文本框的回车事件中，"></a>1,处理文本框的回车事件中，</h3><p>文本框输入类型：InputScope=”Url”   键盘按键属性KeyDown=”URLTextBox_KeyDown”</p>
<p>获取文本框内容并转换为URL：</p>
<p>// 判断与事件关联的按键是否为虚拟按键的Enter键<br>if (e.Key==Windows.System.VirtualKey.Enter)<br>{<br>ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(new Uri(URLTextBox.Text));</p>
<p>等同于：</p>
<pre class="lang:default decode:true ">Uri url = new Uri(URLTextBox.Text);
ResultImage.Source = new Windows.UI.Xaml.Media.Imaging.BitmapImage(url);</pre>
}

当然，如果引入命名空间了，那就更好了  using Windows.UI.Xaml.Media.Imaging;
<pre class="lang:default decode:true ">Uri url = new Uri(URLTextBox.Text);
ResultImage.Source = new BitmapImage(url);</pre>

<h3 id="2，关于动画"><a href="#2，关于动画" class="headerlink" title="2，关于动画"></a>2，关于动画</h3><p>首先目标图片要声明Projection属性，即添加：</p>
<pre class="lang:default decode:true ">&lt;Image.Projection&gt;
   &lt;PlaneProjection /&gt;
&lt;/Image.Projection&gt;</pre>
其次在 &lt;Page.Resources&gt;中添加故事板：
<pre class="lang:default decode:true ">&lt;Storyboard x:Name="StoryBoardX"&gt;
&lt;DoubleAnimation Storyboard.TargetName="ResultImage"
Storyboard.TargetProperty="(UIElement.Projection).(PlaneProjection.RotationX)"
From="0.0"
To="360.0"
AutoReverse="True"
RepeatBehavior="Forever"&gt;
&lt;/DoubleAnimation&gt;
&lt;/Storyboard&gt;
</pre>

<ul>
<li>命名：方便后台代码调用</li>
<li>类：DoubleAnimation针对Double属性，还有ColorAnimation针对Color属性，以及PointAnimation针对Point，这里图形翻转目标属性是PlaneProjection   值是double类型</li>
<li>Storyboard.TargetName：执行动画的对象名称</li>
<li>Storyboard.TargetProperty：执行动画的对象属性，此处是PlaneProjection.RotationX，写成Storyboard.TargetProperty=”PlaneProjection.RotationX”也没有关系</li>
<li>From：起始值</li>
<li>To：终点值</li>
<li>By：变化值</li>
<li>AutoReverse：自动重置（返回原状）</li>
<li>RepeatBehavior：播放次数</li>
<li>Duration：持续时间（值的格式为时分秒，即0.0.3  3秒）<br>以上是通过XAML写出界面，当然，完全可以在后台代码中，完成StoryBoard的设置：<br><pre class="lang:default decode:true ">            DoubleAnimation animation = new DoubleAnimation();<pre><code>animation.From = 0.0;
animation.To = 360.0;
animation.BeginTime = TimeSpan.FromSeconds(1);
animation.RepeatBehavior = RepeatBehavior.Forever;
Storyboard.SetTarget(animation, target);
Storyboard.SetTargetProperty(animation, &quot;(UIElement.Projection).(PlaneProjection.Rotation&quot; + axis + &quot;)&quot;);
rotation.Children.Clear();
rotation.Children.Add(animation);
rotation.Begin();
rotating = true;&lt;/pre&gt;
</code></pre>不过看个人爱好了，我还是喜欢XAML。</pre></li>
</ul>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;动画编程小尝试&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记二：AppBar和CommandBar</title>
    <link href="http://yoursite.com/2016/04/22/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AAppBar%E5%92%8CCommandBar/"/>
    <id>http://yoursite.com/2016/04/22/UWP开发笔记二：AppBar和CommandBar/</id>
    <published>2016-04-21T21:00:36.000Z</published>
    <updated>2016-10-28T13:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>AppBar和CommandBar<br>. </p>

<a id="more"></a>
<p>AppBar和CommandBar也算是比较常用的控件了，不过个人不太喜欢这些，主要是觉得很非主流，我还是喜欢把功能都做到汉堡菜单里。</p>
<p>1，CommandBar被包裹住了，一般放在页面顶部或底部。</p>
<p><pre class="lang:default decode:true ">&lt;Page<br>    x:Class=”ApplicationBar.MainPage”<br>    xmlns=”<a href="http://schemas.microsoft.com/winfx/2006/xaml/presentation" target="_blank" rel="external">http://schemas.microsoft.com/winfx/2006/xaml/presentation</a>“<br>    xmlns:x=”<a href="http://schemas.microsoft.com/winfx/2006/xaml" target="_blank" rel="external">http://schemas.microsoft.com/winfx/2006/xaml</a>“<br>    xmlns:local=”using:ApplicationBar”<br>    xmlns:d=”<a href="http://schemas.microsoft.com/expression/blend/2008" target="_blank" rel="external">http://schemas.microsoft.com/expression/blend/2008</a>“<br>    xmlns:mc=”<a href="http://schemas.openxmlformats.org/markup-compatibility/2006" target="_blank" rel="external">http://schemas.openxmlformats.org/markup-compatibility/2006</a>“<br>    mc:Ignorable=”d”&gt;</pre></p>
<p>  &lt;Page.BottomAppBar&gt;<br>        &lt;CommandBar&gt;</p>
<pre><code>    &amp;lt;/CommandBar&amp;gt;
&amp;lt;/Page.BottomAppBar&amp;gt;
&amp;lt;Grid Background=&quot;{ThemeResource ApplicationPageBackgroundThemeBrush}&quot;&amp;gt;
&amp;lt;/Grid&amp;gt;
</code></pre><p>&lt;/Page&gt;<br>所以就是这种效果，在CommandBar中有两种菜单可选</p>
<p>图标文字：添加AppBarButton即可</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/001.png" alt=""></p>
<p><pre class="lang:default decode:true ">&lt;AppBarButton Name=”FirstAppBarButton”<br>    Icon=”Account”<br>     Label=”主页”<br>    Click=”FirstAppBarButton_Click”/&gt;</pre><br>文字列表：需要夹在&lt;CommandBar.SecondaryCommands&gt;&lt;/CommandBar.SecondaryCommands&gt;中间</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/002.png" alt=""></p>
<p><pre class="lang:default decode:true ">&lt;CommandBar.SecondaryCommands&gt;<br>                &lt;AppBarButton Name=”TextAppBarButton1”<br>                              Label=”文字1”<br>                              Click=”TextAppBarButton1_Click”/&gt;<br>&lt;/CommandBar.SecondaryCommands&gt;</pre><br>2,AppBar 的话，可能更强大一点，它可以嵌套着命令栏CommandBar，不过也是需要放在页面顶部或者底部</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/005.png" alt=""></p>
<p><pre class="lang:default decode:true">&lt;Page.TopAppBar&gt;<br>        &lt;AppBar  &gt;</pre></p>
<pre><code>    &amp;lt;/AppBar&amp;gt;
&amp;lt;/Page.TopAppBar&amp;gt;&lt;/pre&gt;
</code></pre><p>对于每个命令栏按钮，依然可以添加Click事件进行处理。</p>
<p><img src="http://images.chenyalun.cn/2016/04/20/003.png" alt=""></p>
<p><img src="http://images.chenyalun.cn/2016/04/20/004.png" alt=""></p>
<hr>
<hr>
<h3 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;笔记</h3><p>1,</p>
<p><pre class="lang:default decode:true ">&lt;Page.TopAppBar&gt;<br>        &lt;AppBar  IsSticky=”True” &gt;<br>            &lt;StackPanel Orientation=”Horizontal” &gt;<br>                &lt;CommandBar&gt;<br>                    &lt;!–第二命令栏–&gt;<br>                    &lt;CommandBar.SecondaryCommands&gt;<br>                        &lt;AppBarButton Name=”Hide” Icon=”Cancel” Label=”文本” Visibility=”Collapsed” Click=”Show_Click”/&gt;<br>                    &lt;/CommandBar.SecondaryCommands&gt;<br>                     &lt;!–设置命令栏内容–&gt;<br>                    &lt;CommandBar.Content&gt;<br>                        &lt;TextBlock Text=”Now playing…” Margin=”12,14”/&gt;<br>                    &lt;/CommandBar.Content&gt;<br>                &lt;/CommandBar&gt;<br>                     &lt;!–分割线–&gt;<br>                &lt;AppBarSeparator/&gt;<br>                &lt;AppBarButton Name=”Show”<br>                              Icon=”Accept”<br>                              Label=”Show Other”<br>                              Click=”Show_Click”<br>                              IsCompact=”True”/&gt;<br>            &lt;/StackPanel&gt;<br>        &lt;/AppBar&gt;<br>    &lt;/Page.TopAppBar&gt;</pre><br>如上所示，AppBar中包裹命令栏。若菜单栏中只包含AppBarButton（普通按钮）、AppBarToggleButton（切换按钮）、AppBarSeparator（分割线） 这几个控件，且没有特殊布局格式要求，CommandBar 控件可以解决大多数问题。</p>
<p>第二命令栏需要使用：CommandBar.SecondaryCommands</p>
<p>命令栏内容：CommandBar.Content</p>
<p>命令按钮分割线： &lt;AppBarSeparator/&gt;</p>
<p>标签：label</p>
<p>图标: icon</p>
<p>顶部命令栏：&lt;Page.TopAppBar&gt;&lt;/Page.TopAppBar&gt;</p>
<p>底部命令栏： &lt;Page.BottomAppBar&gt; &lt;/Page.BottomAppBar&gt;</p>
<p>单词：toggle 切换   Separator分隔符</p>
<p>在AppBar属性中：IsSticky=”True”表示打开命令栏后，除非用户显式地点击鼠标右键或按Win+z, 或用手指从屏幕顶端或底端划过才会隐藏，否则AppBar会一直显示。一般不设置。</p>
<p>IsOpen=”True” 一直完全显示图标+文字，一般不设置。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;AppBar和CommandBar&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UWP开发笔记一：Hello UWP与对话框</title>
    <link href="http://yoursite.com/2016/04/20/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9AHello_UWP%E4%B8%8E%E5%AF%B9%E8%AF%9D%E6%A1%86/"/>
    <id>http://yoursite.com/2016/04/20/UWP开发笔记一：Hello_UWP与对话框/</id>
    <published>2016-04-19T21:00:51.000Z</published>
    <updated>2016-10-28T13:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>Hello World UWP<br>. </p>

<a id="more"></a>
<p>这段时间在悄悄地学习UWP开发，不过担心会忘记，所以感觉还是记下笔记比较好。一来自己没事可以翻着看看，可解闷了，二来欢迎志同道合的童鞋一起交流。</p>
<p>1，假定PC装好VS2015，文件–新建–项目–windows通用应用</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/001.png" alt=""></p>
<p>设置版本：</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/002.png" alt=""></p>
<p>2，右侧解决方案中，打开MainPage.xaml，写入xaml代码：</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/003.png" alt=""></p>
<p><pre class="lang:default decode:true ">  &lt;Button Name=”HelloUWPButton”<br>                Content=”显示”<br>                HorizontalAlignment=”Center”<br>                VerticalAlignment=”Center”<br>        Click=”HelloUWPButton_Click”/&gt;</pre><br>或者拖入Button控件，属性中设置Click事件：HelloUWPButton_Click，内容设置为：显示。</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/004.png" alt=""></p>
<p>3，处理click事件：</p>
<p><pre class="lang:default decode:true ">private async void HelloUWPButton_Click(object sender, RoutedEventArgs e)<br>        {<br>            await new Windows.UI.Popups.MessageDialog(“Hello UWP”).ShowAsync();</pre></p>
<pre><code>}&lt;/pre&gt;
</code></pre><p>4，调试运行即可。</p>
<p><img src="http://images.chenyalun.cn/2016/04/19/005.png" alt=""></p>
<hr>
<hr>
<h3 id="gt-gt-笔记"><a href="#gt-gt-笔记" class="headerlink" title="&gt;&gt;笔记"></a>&gt;&gt;<strong>笔记</strong></h3><p>1，其实点击事件的代码和下面两行等价：</p>
<p><pre class="lang:default decode:true ">var message = new MessageDialog(“Hello UWP”);<br>await  message.ShowAsync();</pre><br>&nbsp;</p>
<p>2，消息对话框引入的命名空间：<strong>using Windows.UI.Popups;</strong></p>
<p>&nbsp;</p>
<p>3，消息对话框的使用</p>
<p>创建对话框并设置内容：</p>
<p><pre class="lang:default decode:true ">var messageDialog = new MessageDialog(“消息对话框的内容”, “可省略的对话框标题”);</pre><br>设置对话框中的命令,最多有3个：</p>
<p><pre class="lang:default decode:true ">UICommand cmd1 = new UICommand();<br>UICommand cmd2 = new UICommand();<br>UICommand cmd3 = new UICommand();</pre><br>设置命令的标签文本：</p>
<p><pre class="lang:default decode:true ">cmd1.Label = “标签1”;<br>cmd2.Label = “标签2”;<br>cmd3.Label = “标签3”;</pre><br>设置命令的唯一标识符：</p>
<p><pre class="lang:default decode:true ">cmd1.Id = 1;<br>cmd2.Id = 2;<br>cmd3.Id = 3;</pre><br>设置消息对话框命令的默认ID（直接按下回车键就可以执行的命令）<br>三个命令默认从左到右DefaultCommandIndex依次是0，1，2，大于2或者不设置则DefaultCommandIndex的值为0</p>
<p><pre class="lang:default decode:true "> messageDialog.DefaultCommandIndex = 1;</pre><br>设置调用（点击）命令时引发的事件：OnCommend</p>
<p><pre class="lang:default decode:true ">cmd1.Invoked = new UICommandInvokedHandler(OnCommend);<br>cmd2.Invoked = new UICommandInvokedHandler(OnCommend);<br>cmd3.Invoked = new UICommandInvokedHandler(OnCommend);</pre><br>将3个命令添加到对话框中</p>
<p><pre class="lang:default decode:true ">messageDialog.Commands.Add(cmd1);<br>messageDialog.Commands.Add(cmd2);<br>messageDialog.Commands.Add(cmd3);</pre><br>显示消息对话框(异步)</p>
<p><pre class="lang:default decode:true ">await messageDialog.ShowAsync();</pre><br>截至目前，上面的代码可以简化为：</p>
<p><pre class="lang:default decode:true">var messageDialog = new MessageDialog(“消息对话框的内容”);<br>messageDialog.DefaultCommandIndex = 1;<br>messageDialog.Commands.Add(new UICommand(“标签1”, OnCommend, 1));<br>messageDialog.Commands.Add(new UICommand(“标签2”, OnCommend, 2));<br>messageDialog.Commands.Add(new UICommand(“标签3”, OnCommend, 3));<br>await messageDialog.ShowAsync();</pre><br>处理调用命令的事件：</p>
<p>一般通过命令的ID进行不同的处理，将object类型的command.Id转化为int32类型</p>
<p><pre class="lang:default decode:true "> private void OnCommend(IUICommand command)<br>        {<br>            var ID = Convert.ToInt32(command.Id);</pre></p>
<pre><code>    // 处理不同的命令
    if (ID == 1)
    {
        ResultTextBlock.Text = &quot;你点击了命令1：标签1&quot;;
    }
    else if (ID == 2)
    {
        ResultTextBlock.Text = &quot;你点击了命令2：标签2&quot;;
    }
    else
    {
        ResultTextBlock.Text = &quot;你点击了命令3：标签3&quot;;
    }

}&lt;/pre&gt;
</code></pre><p><img src="http://images.chenyalun.cn/2016/04/19/006.png" alt=""></p>
<p>4，单词积累：</p>
<p>popups：弹出窗口；弹出式视窗</p>
<p>invoked：恳求；实行；引起</p>
<p>5,github: <a href="http://www.chenyalun.cn/go/?url=https://github.com/chenyalun/UWP-Notes.git" target="_blank" rel="external">https://github.com/chenyalun/UWP-Notes.git</a></p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;Hello World UWP&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="UWP开发笔记" scheme="http://yoursite.com/categories/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UWP开发" scheme="http://yoursite.com/tags/UWP%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>泛谈单链表的插入与删除</title>
    <link href="http://yoursite.com/2015/11/04/%E6%B3%9B%E8%B0%88%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2015/11/04/泛谈单链表的插入与删除/</id>
    <published>2015-11-03T21:00:32.000Z</published>
    <updated>2016-10-28T13:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>简单探讨单链表的插入与删除<br>. </p>

<a id="more"></a>
<p>其实单链表也是比较有意思的，可惜我弄了好久才些微明白些。在顺序表中，一个数组就将近定义一个结构，但在单链表中，却又要和指针扯上关系了。</p>
<p>定义：</p>
<pre><code>typedef struct LNode{
    int data;
    struct LNode next;
}LNode;
</code></pre><p>江湖传言LNode *p等价于LinkList p，不知道有木有人认同呢？</p>
<pre><code>    #include&lt;stdio.h&gt;

    #include&lt;malloc.h&gt;
    //定义并初始化单链表
    typedef struct LNode{
    int data;
    struct LNode *next;
    }LNode;

    //单链表的创建与初始化，设定共n个节点（不含头节点）
    void CreateLinkList(LNode a,int n) {
    LNode p,q;
    p=a;
    while(n–){
    q=(LNode )malloc(sizeof(LNode *));
    scanf(“%d”,&amp;q-&gt;data);
    q-&gt;next=NULL;
    p-&gt;next=q;
    p=q;
    }
    }

    //查找是否存在一个值为x的节点，若存在，删之，并返回OK，否则返回NOT FOUND
    char SearchAndDelete(LNode c,int x){
    LNode p,q;
    p=c;
    //开始查找
    while(p-&gt;next!=NULL)
    {
    if(p-&gt;next-&gt;data==x)
    break;
    p=p-&gt;next;
    }
    //若找到则开始删除
    if(p-&gt;next==NULL)
    return “NOT FOUND”;
    else
    {
    q=p-&gt;next;
    p-&gt;next=p-&gt;next-&gt;next;
    free(q);
    return “OK”;
    }
    }

    //在链表c中第n个节点位置插入元素e
    void Insert(LNode c,int n,int e){
    LNode p=( LNode )malloc(sizeof(LNode )),
    q=( LNode )malloc(sizeof(LNode ));//插入的节点
    p=c;
    q-&gt;data=e;
    //找到要插入节点的位置
    for(int i=1;i&lt;n;i++){
    p=p-&gt;next;
    }
    //插入节点
    q-&gt;next=p-&gt;next;
    p-&gt;next=q;
    }
    //打印单链表
    void Print(LNode a){
    LNode p=( LNode )malloc(sizeof(LNode *));
    p=a-&gt;next;
    while(p!=NULL){
    printf(“%d\n”,p-&gt;data);
    p=p-&gt;next;
    }
    }

    int main(){
    LNode a=( LNode )malloc(sizeof(LNode *));
    CreateLinkList(a,5);
    Insert(a,3,10086);//假定在第3个位置插入数值为10086的节点
    Print(a);
    printf(“—————-\n”);
    SearchAndDelete(a,13);//查找并执行删除数值为13的节点
    Print(a);
    return 0;
}
</code></pre><p>说明如下：</p>
<p>1，假定输入的是11 12 13 14 15五个数值。在第三个位置（13的位置）插入一个数据域为10086的节点。此时原来的数值已经变成了11 12 10086 13 14 15</p>
<p>2，完事后，我为了方便不再另写代码，在11 12 10086 13 14 15的基础上假定查找并删除数据域为13的节点。</p>
<p><img src="http://source.chenyalun.cn/images/201511/5110101.jpg" alt=""></p>
<p>当然还有值得体会的是，把节点的内存分配放在主函数里.</p>
<p>像这样：</p>
<pre><code>LNode a=( LNode )malloc(sizeof(LNode *));
</code></pre><p>当然，清晰一点就是</p>
<pre><code>LNode a;
a=( LNode )malloc(sizeof(LNode *));
</code></pre><p>两者效果一样。</p>
<pre><code>void Print(LNode *a){

}
和

void Print(LNode &amp;a){
    a=( LNode )malloc(sizeof(LNode *));

}
</code></pre><p>这才是重点，和小伙伴研究一下，决定采取有违伦理惨无人道的第一种方式。最后在主函数中再调用malloc觉得还是蛮灵活轻便的。</p>
<p>当然，上面的代码不是为了解题，只是提供一个思路，具体可视情况修改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;简单探讨单链表的插入与删除&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="编程技巧" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>泛谈顺序表的插入与删除</title>
    <link href="http://yoursite.com/2015/11/02/%E6%B3%9B%E8%B0%88%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2015/11/02/泛谈顺序表的插入与删除/</id>
    <published>2015-11-01T21:00:11.000Z</published>
    <updated>2016-10-28T13:54:12.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>简单探讨顺序表的插入与删除<br>. </p>

<a id="more"></a>
<p>所谓的顺序表，在严版的书中，定义的异常专业巧妙。存储空间基址、当前长度、分配的存储容量，这三部分融合而成线性表之顺序表。</p>
<pre><code>typedef struct{
    Elemtype *elem;
    int length;
    int listsize;
}SqList;
</code></pre><p>翻翻资料。发现还有一种更巧妙而且容易理解的方式：</p>
<pre><code>typedef struct{
    int data[Max];
    int length;
}SqList;
</code></pre><p>这样一来，整个顺序表就与数组特别特别相似啦。</p>
<p>那么，声明一个很长很长但是彼此知道的Max长度数组，作为默认“表长”（其实不是表长），再给它一个长度length，如此，顺序表横空出世了。</p>
<p>既然如此，那关于什么插入、删除操作就不在话下了。</p>
<p>1 已知顺序表的所有元素值（自行输入），在元素e的位置插入元素m</p>
<p>题目很清楚，插入元素m后，后面的元素自然往后移动啦。</p>
<pre><code>    #include&lt;stdio.h&gt;
    //#include&lt;malloc.h&gt;
    //#include&lt;stdlib.h&gt;   //一般这两个是需要的

    #define Max 200
    //定义并初始化顺序表
    typedef struct{
    int data[Max];
    int length=10;
    }SqList;
    //顺序表l中查找元素e的位置
    int LocatElem(SqList l,int e){
    int i=0;
    for(;i&lt;l.length;++i)
    if(l.data[i]==e)
    return i+1;
    }

    //在元素e的位置插入元素m
    void Insert(SqList &amp;l,int e,int m) {
    int i=l.length,p=LocatElem(l,e);
    for(;i&gt;=p;–i){
    l.data[i]=l.data[i-1];
    }
    l.data[i]=m;
    l.length++;
    }

    int main(){
    int i=0,e=18,m=200;
    SqList a;
    for(;i&lt;a.length;++i)
    scanf(“%d”,&amp;a.data[i]);
    Insert(a,e,m);
    for(int i=0;i&lt;a.length;++i)
    printf(“%d\n”,a.data[i]);
    return 0;
}
</code></pre><p>这里假设我们输入从11，12一直到20的整数值，首先查找元素e=18的值的位置，插入m的值200。</p>
<p>原来：11 12 13 14 15 16 17 18 19 20</p>
<p>run后：11 12 13 14 15 16 17 200 18 19 20</p>
<p><img src="http://source.chenyalun.cn/images/201510/5103102.jpg" alt=""></p>
<p>2 已知顺序表所有元素的值（自行输入），删除顺序表中值为e的元素</p>
<pre><code>    #include&lt;stdio.h&gt;
    //#include&lt;malloc.h&gt;
    //#include&lt;stdlib.h&gt;

    #define Max 200
    //定义并初始化顺序表
    typedef struct{
    int data[Max];
    int length=10;
    }SqList;
    //顺序表l中查找元素e的位置
    int LocatElem(SqList l,int e){
    int i=0;
    for(;i&lt;l.length;++i)
    if(l.data[i]==e)
    return i+1;
    }

    //删除顺序表中值为e的元素
    void Delete(SqList &amp;l,int e){
    int i=LocatElem(l,e);
    for(;i&lt;=l.length;++i)
    l.data[i-1]=l.data[i];
    l.length–;
    }
    int main(){
    int i=0, e=15;//e的值自己说了算
    SqList a;
    for(;i&lt;a.length;++i)
    scanf(“%d”,&amp;a.data[i]);
    Delete(a,e);
    for(int i=0;i&lt;a.length;++i)
    printf(“%d\n”,a.data[i]);
    return 0;
}
</code></pre><p>改动不大，添加个函数而已。这里删除的是15，具体题目具体分析。</p>
<p>原来：11 12 13 14 15 16 17 18 19 20</p>
<p>run后：11 12 13 14 16 17 18 19 20<br><img src="http://source.chenyalun.cn/images/201510/5103101.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p align = &quot;center&quot;&gt;&lt;br&gt;简单探讨顺序表的插入与删除&lt;br&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="编程技巧" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
