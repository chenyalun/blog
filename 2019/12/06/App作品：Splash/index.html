<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="App作品：Splash">




  <meta name="keywords" content="iOS开发,开源项目,">




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x">



<link rel="canonical" href="http://blog.chenyalun.com/2019/12/06/App作品：Splash/">


<meta name="description" content="实践一些想法。">
<meta name="keywords" content="iOS开发,开源项目">
<meta property="og:type" content="article">
<meta property="og:title" content="App作品：Splash">
<meta property="og:url" content="http://blog.chenyalun.com/2019/12/06/App作品：Splash/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="实践一些想法。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image.chenyalun.com/2019/12/26/splash_001.png">
<meta property="og:image" content="https://image.chenyalun.com/2019/12/26/splash_002.png">
<meta property="og:image" content="https://image.chenyalun.com/2019/12/26/splash_003.png">
<meta property="og:image" content="https://image.chenyalun.com/2019/12/26/splash_004.png">
<meta property="og:updated_time" content="2020-01-02T03:49:30.241Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="App作品：Splash">
<meta name="twitter:description" content="实践一些想法。">
<meta name="twitter:image" content="https://image.chenyalun.com/2019/12/26/splash_001.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> App作品：Splash · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          App作品：Splash
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年12月6日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、前言"><span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、思路"><span class="toc-text">二、思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1，代码结构"><span class="toc-text">1，代码结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2，公有特性"><span class="toc-text">2，公有特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3，网络层设计"><span class="toc-text">3，网络层设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4，从MVC、MVVM到去Model化"><span class="toc-text">4，从MVC、MVVM到去Model化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5，网络优化"><span class="toc-text">5，网络优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6，持久化"><span class="toc-text">6，持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7，动态部署方案"><span class="toc-text">7，动态部署方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、总结"><span class="toc-text">三、总结</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p></p><p align="center"> 实践一些想法。 </p><br><a id="more"></a><p></p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>拜读了Casa前辈的<a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html" target="_blank" rel="noopener">《iOS应用架构谈》</a>系列文章，收获颇丰，萌生了想实践的想法。2017年到现在，虽然写过不少项目，但是始终没有App作品在App Store上架过，也一直有这个小心愿。手机里面有个叫Splasher的App，是壁纸类型的App，虽然壁纸质量不错，但是App体验不太好，加载慢，界面冷酷无情。后来打听到它的API来自无版权可以商用的UnSplash。天时地利人和都有了，我的第一个期望上架App Store的作品：Splash，诞生了。</p>
<p>虽然只是壁纸类的没有多少功能的不需要多少道行就能写出来的App，但是还是想简单聊一聊。</p>
<h1 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h1><h2 id="1，代码结构"><a href="#1，代码结构" class="headerlink" title="1，代码结构"></a>1，代码结构</h2><p>与俺目前的习惯一致：方法结构按照life cycle、Delegate方法实现、event response、getters and setters顺序。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - Life cycle</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - Event response</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - Getter and setter</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - Private methods</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - Public methods</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - UITableViewDelegate</span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> - UITableViewDataSource</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在viewDidload里面只做addSubview的事情，在viewDidLoad里面开一个layoutPageSubviews的方法，在这个里面创建Constraints并添加，在viewDidAppear里面做Notification的监听之类的事情。所有的属性都使用getter和setter，并且全部都放在最后。</p>
</blockquote>
<p>我觉得作者说的还是有道理的，虽然某些getter一定会用到，再做一层懒加载貌似显得冗余，但是从结构上看更清晰。</p>
<h2 id="2，公有特性"><a href="#2，公有特性" class="headerlink" title="2，公有特性"></a>2，公有特性</h2><p>面向切片编程</p>
<ul>
<li>什么是切片？<br>程序要完成一件事情，一定会有一些步骤，1，2，3，4这样。这里分解出来的每一个步骤我们可以认为是一个切片。</li>
<li>什么是面向切片编程？<br>你针对每一个切片的间隙，塞一些代码进去，在程序正常进行1，2，3，4步的间隙可以跑到你塞进去的代码，那么你写这些代码就是面向切片编程。</li>
<li>为什么会出现面向切片编程？<br>你要想做到在每一个步骤中间做你自己的事情，不用AOP也一样可以达到目的，直接往步骤之间塞代码就好了。但是事实情况往往很复杂，直接把代码塞进去，主要问题就在于：塞进去的代码很有可能是跟原业务无关的代码，在同一份代码文件里面掺杂多种业务，这会带来业务间耦合。为了降低这种耦合度，我们引入了AOP。</li>
<li>如何实现AOP？<br>Method Swizzling或者protocol的方式来实现拦截器（beforePerform、afterPerform）</li>
</ul>
<p>使用AOP而非继承来实现公有特性。比如每个ViewController都有一个通用的navigationHeaderBar:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAObjectIntercepter</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    [YAObjectIntercepter sharedInstance];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> YAObjectIntercepter *sharedInstance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [YAObjectIntercepter new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 方法拦截</span></span><br><span class="line">        [<span class="built_in">UIViewController</span> aspect_hookSelector:<span class="keyword">@selector</span>(viewDidLoad) withOptions:AspectPositionBefore usingBlock:^(<span class="keyword">id</span> &lt;AspectInfo&gt; aspectInfo)&#123;</span><br><span class="line">            [<span class="keyword">self</span> viewDidLoadWithViewController:[aspectInfo instance]];</span><br><span class="line">        &#125; error:<span class="literal">NULL</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - fake methods</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoadWithViewController:(<span class="built_in">UIViewController</span> *)viewController &#123;</span><br><span class="line">    <span class="keyword">if</span> ([viewController isKindOfClass:<span class="built_in">UIViewController</span>.class] &amp;&amp; [<span class="built_in">NSStringFromClass</span>(viewController.class) hasPrefix:<span class="string">@"YA"</span>]) &#123;</span><br><span class="line">        viewController.view.backgroundColor = <span class="built_in">UIColor</span>.whiteColor;</span><br><span class="line">        viewController.navigationHeaderBar.backgroundColor = <span class="built_in">UIColor</span>.whiteColor;</span><br><span class="line">        [viewController.view addSubview:viewController.navigationHeaderBar];</span><br><span class="line">        viewController.navigationHeaderBar.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, kIPHONEX_TOP, kScreenWidth, kNavigationBarHeight);</span><br><span class="line">        [viewController.navigationHeaderBar.leftButton setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"feed_back"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        [viewController.navigationHeaderBar.leftButton setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"feed_back"</span>] forState:<span class="built_in">UIControlStateHighlighted</span>];</span><br><span class="line">        [viewController.navigationHeaderBar.leftButton addTarget:viewController action:<span class="keyword">@selector</span>(popViewControllerWithAnimation) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="3，网络层设计"><a href="#3，网络层设计" class="headerlink" title="3，网络层设计"></a>3，网络层设计</h2><blockquote>
<p>1，网络层数据通信以Delegate为主，Notification为辅（网络信号从2G变成3G变成4G变成Wi-Fi）。<br>2，提供reformer机制来处理网络层反馈的数据，交付NSDictionary给业务层，使用Const字符串作为Key来保持可读性。<br>3，网络层上部分使用离散型设计，下部分使用集约型设计。设计合理的继承机制，让派生出来的APIManager受到限制，避免混乱。<br>关于集约型的API调用和离散型的API调用，我倾向于这样：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约化的手段组装请求，放飞请求，然而业务方调用API的时候，则是以离散的API调用方式来调用。如果你的App只提供了集约化的方式，而没有离散方式的通道，那么我建议你再封装一层，便于业务方使用离散的API调用方式来放飞请求。</p>
</blockquote>
<p>大型App可以使用封装AFN的YTKNetwork，而小型App由于API少，参数不复杂，很多就直接使用一个类，暴露Get和Post接口就可以了。</p>
<p><strong>下层：统一接口，以离散型封装AFNetworking</strong><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> *YAServerInterfaceName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首页Feed接口</span></span><br><span class="line"><span class="keyword">extern</span> YAServerInterfaceName <span class="keyword">const</span> kYAServerInterfaceFeed;</span><br><span class="line"><span class="comment">// 搜索接口</span></span><br><span class="line"><span class="keyword">extern</span> YAServerInterfaceName <span class="keyword">const</span> kYAServerInterfaceSearch;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YANetworkManager</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)manager;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)requestWithInterfaceName:(YAServerInterfaceName)interfaceName</span><br><span class="line">                                        parameters:(<span class="built_in">NSDictionary</span> *)parameters</span><br><span class="line">                                          progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *))downloadProgress</span><br><span class="line">                                           success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="keyword">id</span>))success</span><br><span class="line">                                           failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>把接口以及公共参数进行封装，避免散落一地。使用时只需要传入InterfaceName即可。每个业务都可以有自己的manager，成功或者失败回调以block的形式回传，供各个业务自己发挥。</p>
<p><strong>上层：统一APIManager，以集约型的delegate进行回调</strong><br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// API manager的基类</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">YABaseAPIManager </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) BOOL noMoreData;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">fetchNetworkDataWithParameters</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">parameters</span>;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">cancelPreviousRequest</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure></p>
<p>BaseAPIManager负责派生各个业务的APIManager，提供数据请求及取消数据请求接口。BaseAPIManager还约定了子类需要实现的方法：成功回调、失败回调、以及接口名称。具体请求的参数怎么配置、成功回调怎么处理、失败回调怎么处理都由子类决定。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@protocol</span> YABaseAPIManagerChildProtocol &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@required</span></span><br><span class="line">- (YAServerInterfaceName)interfaceName;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">APIManager</span><span class="selector-pseudo">:(YABaseAPIManager</span> *)<span class="selector-tag">manager</span> <span class="selector-tag">finishedWithFailedError</span><span class="selector-pseudo">:(NSError</span> *)<span class="selector-tag">error</span>;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">APIManager</span><span class="selector-pseudo">:(YABaseAPIManager</span> *)<span class="selector-tag">manager</span> <span class="selector-tag">finishedWithSuccessResult</span><span class="selector-pseudo">:(id)result</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure>
<h2 id="4，从MVC、MVVM到去Model化"><a href="#4，从MVC、MVVM到去Model化" class="headerlink" title="4，从MVC、MVVM到去Model化"></a>4，从MVC、MVVM到去Model化</h2><p><strong>MVC</strong><br>M应该做的事：<br>给ViewController提供数据；<br>给ViewController存储数据提供接口；<br>提供经过抽象的业务基本组件，供Controller调度；</p>
<p>C应该做的事：<br>管理View Container的生命周期；<br>负责生成所有的View实例，并放入View Container；<br>监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务；</p>
<p>V应该做的事：<br>响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等；<br>界面元素表达</p>
<p><strong>MVVM</strong><br>在MVC的基础上，把C拆出一个ViewModel专门负责数据处理的事情，就是MVVM。然后，为了让View和ViewModel之间能够有比较松散的绑定关系，于是我们使用ReactiveCocoa，因为苹果本身并没有提供一个比较适合这种情况的绑定方法。iOS领域里KVO，Notification，block，delegate和target-action都可以用来做数据通信，从而来实现绑定，但都不如ReactiveCocoa提供的RACSignal来的优雅，如果不用ReactiveCocoa，绑定关系可能就做不到那么松散那么好，但并不影响它还是MVVM。</p>
<p><strong>去Model化</strong><br>保留原始数据，定义reform协议，遵守该协议的对象来处理manager的原始数据，处理后的数据依然是字典或者数组。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@protocol</span> YAFeedReformerProtocol &lt;NSObject&gt;</span><br><span class="line">- (NSArray *)<span class="attribute">reformData</span>:(id)data <span class="attribute">manager</span>:(YAFeedAPIManager *)manager;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>每类数据对应一个Reformer：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyFeedID;             <span class="comment">///&lt; id</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyFeedThumbUrl;       <span class="comment">///&lt; 拇指图url</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyFeedSmallUrl;       <span class="comment">///&lt; 小图url</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyFeedRegularUrl;     <span class="comment">///&lt; 常规图url</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAFeedReformer</span> : <span class="title">NSObject</span> &lt;<span class="title">YAFeedReformerProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>根据字典的key可以直接使用:<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setPhotoInfo:(<span class="built_in">NSDictionary</span> *)photoInfo &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (YASettingManager.columnCount &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        url = [<span class="built_in">NSURL</span> URLWithString:photoInfo[kPropertyListDataKeyFeedRegularUrl]];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5，网络优化"><a href="#5，网络优化" class="headerlink" title="5，网络优化"></a>5，网络优化</h2><p><strong>针对链接建立环节的优化</strong></p>
<ul>
<li>使用缓存手段减少请求的发起次数（API名字和参数拼成一个字符串然后取MD5作为key，存储对应返回的数据）</li>
<li>使用策略来减少请求的发起次数（下拉刷新、条件筛选取消原先存在的请求，用户日志满足一定数量再上传）</li>
</ul>
<p><strong>针对DNS域名解析做的优化</strong><br>原因：API请求在DNS解析阶段的耗时会很多（网络信号源会经常变换、自己的App所做的DNS缓存会被别的DNS缓存给挤出去被清理掉、墙 这三个原因造成链路的DNS缓存很快失效相当于没有，于是直接走IP请求，绕过DNS服务的耗时）<br>方案：本地有一份IP列表，这些IP是所有提供API的服务器的IP，每次应用启动的时候，针对这个列表里的所有IP取ping延时时间，然后取延时时间最小的那个IP作为今后发起请求的IP地址。一般都是在应用启动的时候获得本地列表中所有IP的ping值，然后通过NSURLProtocol的手段将URL中的HOST修改为我们找到的最快的IP。另外，这个本地IP列表也会需要通过一个API来维护，一般是每天第一次启动的时候读一次API，然后更新到本地。</p>
<p><strong>针对链接传输数据量的优化</strong><br>压缩。</p>
<p><strong>针对链接复用的优化</strong><br>HTTP/2.0。</p>
<p><strong>判断API的调用请求是来自于经过授权的APP？</strong><br>设计签名<br>服务端需要给你一个密钥，每次调用API时，你使用这个密钥再加上API名字和API请求参数算一个hash出来，然后请求的时候带上这个hash。服务端收到请求之后，按照同样的密钥同样的算法也算一个hash出来，然后跟请求带来的hash做一个比较，如果一致，那么就表示这个API的调用者确实是你的APP。为了不让别人也获取到这个密钥，你最好不要把这个密钥存储在本地，直接写死在代码里面就好了。另外适当增加一下求Hash的算法的复杂度，那就是各种Hash算法（比如MD5）加点盐，再回炉跑一次Hash啥的。这样就能解决第一个目的了：确保你的API是来自于你自己的App。</p>
<p>网络优化在Splash上的实践主要是<strong>ip直连</strong>。Casa前辈给出了NSEtcHosts，但是它处理NSURLConnection，过时了，我学习借鉴写了个NSURLSession版本的。当然，思路都是一样的，自定义NSURLProtocol。增加了一点点功能：</p>
<ul>
<li>支持HTTPS</li>
<li>直连ip失败后自动切回host</li>
<li>支持AFN</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YAHostsConfiguration</span></span></span><br><span class="line"><span class="comment">// 配置host与IP的映射</span></span><br><span class="line">- (<span class="keyword">void</span>)resolveHostName:(<span class="built_in">NSString</span> *)hostName</span><br><span class="line">           mapIPAddress:(<span class="built_in">NSString</span> *)IPAddress;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YADomainURLProtocol</span> : <span class="title">NSURLProtocol</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)configureHostsWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;YAHostsConfiguration&gt; configuration))block;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAHostsConfiguration</span> : <span class="title">NSObject</span> &lt;<span class="title">YAHostsConfiguration</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *mutableIPAddressesByHostName;</span><br><span class="line">- (<span class="built_in">NSString</span> *)IPAddressForHostName:(<span class="built_in">NSString</span> *)hostName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAHostsConfiguration</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _mutableIPAddressesByHostName = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)IPAddressForHostName:(<span class="built_in">NSString</span> *)hostName &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.mutableIPAddressesByHostName[hostName.lowercaseString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)resolveHostName:(<span class="built_in">NSString</span> *)hostName mapIPAddress:(<span class="built_in">NSString</span> *)IPAddress &#123;</span><br><span class="line">    <span class="keyword">self</span>.mutableIPAddressesByHostName[hostName.lowercaseString] = IPAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kURLProtocolHostModifiedKey = <span class="string">@"kURLProtocolHostModifiedKey"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YADomainURLProtocol</span> () &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YADomainURLProtocol</span></span></span><br><span class="line">+ (YAHostsConfiguration *)sharedConfiguration &#123;</span><br><span class="line">    <span class="keyword">static</span> YAHostsConfiguration * sharedConfiguration = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedConfiguration = [YAHostsConfiguration new];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sharedConfiguration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)configureHostsWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;YAHostsConfiguration&gt; configuration))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (block) block([<span class="keyword">self</span> sharedConfiguration]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isHttps = [request.URL.scheme caseInsensitiveCompare:<span class="string">@"https"</span>] == <span class="built_in">NSOrderedSame</span>;</span><br><span class="line">    <span class="keyword">if</span> (isHttps) &#123;</span><br><span class="line">        <span class="comment">// 没有处理过且有映射</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> propertyForKey:kURLProtocolHostModifiedKey inRequest:request] &amp;&amp; [[<span class="keyword">self</span> sharedConfiguration] IPAddressForHostName:request.URL.host]) &#123;</span><br><span class="line">            YALog(<span class="string">@"命中ip直连"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="comment">// 容错</span></span><br><span class="line">    <span class="keyword">if</span> (request.URL.host.length == <span class="number">0</span>) <span class="keyword">return</span> request;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line">    <span class="built_in">NSURLComponents</span> *URLComponents = [<span class="built_in">NSURLComponents</span> componentsWithString:mutableRequest.URL.absoluteString];</span><br><span class="line">    URLComponents.scheme = <span class="string">@"https"</span>;</span><br><span class="line">    URLComponents.host = [[<span class="keyword">self</span> sharedConfiguration] IPAddressForHostName:URLComponents.host];</span><br><span class="line">    mutableRequest.URL = [URLComponents URL];</span><br><span class="line">    [<span class="keyword">self</span> setProperty:@(<span class="literal">YES</span>) forKey:kURLProtocolHostModifiedKey inRequest:mutableRequest];</span><br><span class="line">    <span class="comment">// 设置原先的host</span></span><br><span class="line">    [mutableRequest setValue:request.URL.host forHTTPHeaderField:<span class="string">@"host"</span>];</span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> new]];</span><br><span class="line">    [[<span class="keyword">self</span>.session dataTaskWithRequest:<span class="keyword">self</span>.request] resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading &#123;</span><br><span class="line">    [<span class="keyword">self</span>.session finishTasksAndInvalidate];</span><br><span class="line">    <span class="keyword">self</span>.session = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSURLSessionDataDelegate</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 加载完成: error回调</span></span><br><span class="line">        [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didFailWithError:error];</span><br><span class="line">        <span class="comment">// 出错: 取消ip直连</span></span><br><span class="line">        <span class="built_in">NSString</span> *host = [<span class="keyword">self</span>.request valueForHTTPHeaderField:<span class="string">@"host"</span>];</span><br><span class="line">        [YADomainURLProtocol sharedConfiguration].mutableIPAddressesByHostName[host.lowercaseString] = <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 加载完成: success回调</span></span><br><span class="line">        [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;</span><br><span class="line">    <span class="comment">// 接收response回调</span></span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</span><br><span class="line">    completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="comment">// 接收数据回调</span></span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 证书</span></span><br><span class="line"><span class="comment">// https: 证书</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span>, <span class="built_in">NSURLCredential</span> *))completionHandler &#123;</span><br><span class="line">    <span class="keyword">if</span> (!challenge) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *host = [<span class="keyword">self</span>.request.allHTTPHeaderFields objectForKey:<span class="string">@"host"</span>];</span><br><span class="line">    <span class="keyword">if</span> (!host) host = <span class="keyword">self</span>.request.URL.host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>] &amp;&amp; [<span class="keyword">self</span> createServerTrust:challenge.protectionSpace.serverTrust forDomain:host]) &#123;</span><br><span class="line">        <span class="comment">// 处理服务器自制证书，参照AFN</span></span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">        credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler(disposition, credential);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证SSL握手过程中服务端返回的证书是否可信任</span></span><br><span class="line"><span class="comment">// 参考AFN中 AFSecurityPolicy 模块的代码</span></span><br><span class="line"><span class="comment">// 注：只适用于一台服务器的IP只配置了一个默认的域名和SSL证书的情况</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)createServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain &#123;</span><br><span class="line">    <span class="comment">// 创建证书校验策略</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">// 需要验证请求的域名与证书中声明的CN字段是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定校验策略到服务端返回的证书上</span></span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error;</span><br><span class="line">    SecTrustEvaluate(serverTrust, &amp;result);</span><br><span class="line">    <span class="comment">// 评估当前serverTrust是否可信任，</span></span><br><span class="line">    <span class="comment">// 当 result 为 kSecTrustResultUnspecified 或 kSecTrustResultProceed 的情况下，serverTrust 可以被验证通过</span></span><br><span class="line">    <span class="keyword">return</span> (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>只需要这么使用：<br><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">NSURLProtocol</span> registerClass:YADomainURLProtocol.class]<span class="comment">;</span></span><br><span class="line">[<span class="name">YADomainURLProtocol</span> configureHostsWithBlock:^(<span class="name">id&lt;YAHostsConfiguration&gt;</span> configuration) &#123;</span><br><span class="line">    [<span class="name">configuration</span> resolveHostName:@<span class="string">"www.baidu.com"</span> mapIPAddress:@<span class="string">"220.181.38.150"</span>]<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>对于AFN，配置configuration即可<br><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">NSURLSessionConfiguration *configuration = <span class="comment">[NSURLSessionConfiguration defaultSessionConfiguration]</span>;</span><br><span class="line">configuration.protocolClasses = @<span class="comment">[YADomainURLProtocol.class]</span>;</span><br><span class="line">AFHTTPSessionManager *sessionManager = <span class="comment">[<span class="comment">[AFHTTPSessionManager alloc]</span> initWithSessionConfiguration:configuration]</span>;</span><br></pre></td></tr></table></figure></p>
<p>注意：目前没有考虑单IP多域名证书（SNI）。</p>
<blockquote>
<p>对于这种场景，iOS上层网络 API NSURLConnection/NSURLSession 都没有提供相关方法进行 SNI 字段的配置，因此需要 Socket 层级的底层网络库，例如 CFNetwork，来实现 IP 直连网络请求适配方案。<br>可以参考：阿里云的《<a href="https://help.aliyun.com/knowledge_detail/60147.html" target="_blank" rel="noopener">iOS HTTPS SNI 业务场景“IP直连”方案说明</a>》</p>
</blockquote>
<h2 id="6，持久化"><a href="#6，持久化" class="headerlink" title="6，持久化"></a>6，持久化</h2><p><strong>持久化方案有哪些？</strong></p>
<ul>
<li>NSUserDefault： 小规模数据，弱业务相关数据，都可以放到NSUserDefault里面，内容比较多的数据，强业务相关的数据就不太适合NSUserDefault了。</li>
<li>Keychain ： Keychain是苹果提供的带有可逆加密的存储机制，普遍用在各种存密码的需求上。另外，由于App卸载只要系统不重装，Keychain中的数据依旧能够得到保留，以及可被iCloud同步的特性，大家都会在这里存储用户唯一标识串。所以有需要加密、需要存iCloud的敏感小数据，一般都会放在Keychain。</li>
<li>文件存储：文件存储包括了Plist、archive、Stream等方式，一般结构化的数据或者需要方便查询的数据，都会以Plist的方式去持久化。Archive方式适合存储平时不太经常使用但很大量的数据，或者读取之后希望直接对象化的数据，因为Archive会将对象及其对象关系序列化，以至于读取数据的时候需要Decode很花时间，Decode的过程可以是解压，也可以是对象化，这个可以根据具体<nscoding>中的实现来决定。Stream就是一般的文件存储了，一般用来存存图片啊啥的，适用于比较经常使用，然而数据量又不算非常大的那种。</nscoding></li>
<li>数据库存储：苹果自带了一个Core Data，其他还有FMDB。数据库方案主要是为了便于增删改查，当数据有状态和类别的时候最好还是采用数据库方案比较好。因为你不可能通过文件系统遍历文件去甄别你需要获取的属于某个状态或类别的数据，这么做成本就太大了。当然，特别大量的数据也不适合直接存储数据库，比如图片或者文章这样的数据，一般来说，都是数据库存一个文件名，然后这个文件名指向的是某个图片或者文章的文件。如果真的要做全文索引这种需求，建议最好还是挂个API丢到服务端去做。</li>
</ul>
<p>上面是前辈总结的面试题答案😂</p>
<p>接下来是持久化的实践：<br>与以往不同的是，之前采用MVC或者MVVM模式，存在数据库的是Model，而现在去Model化了，存原始数据呢，还是存Reform之后的数据。我选择存储原始数据，原因有二：<br>1，Reformer有多个，但是原始数据只有一份，只存储一份原始数据避免冗余。<br>2，如果存储原始数据，那从数据库取出的数据和从网络获取的数据，格式将会是一样的，只需要一种处理方式。</p>
<p>怎么存储？每条photo信息中的photo_id作为主键，再加上时间戳用于筛选，photo_content自然就是存储的原始信息了：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">"t_photoList"</span> (</span><br><span class="line"><span class="string">"photo_id"</span> <span class="built_in">text</span>,</span><br><span class="line"><span class="string">"photo_content"</span> <span class="built_in">text</span>,</span><br><span class="line"><span class="string">"photo_date"</span> <span class="built_in">INTEGER</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">"photo_id"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这样职责更清晰了：APIManager负责从网络或者数据库取数据以及持久化数据，Reformer只负责格式化APIManager的数据。对于控制器来说，它做的也很简单了：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)feedAPIDidSuccessWithManager:(YAFeedAPIManager *)manager</span><br><span class="line">                           isNewData:(<span class="built_in">BOOL</span>)isNewData &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> &lt;<span class="built_in">NSDictionary</span> *&gt; *array = [manager fetchDataWithReformer:<span class="keyword">self</span>.feedReformer];</span><br><span class="line">    <span class="keyword">if</span> (isNewData) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.photoArray removeAllObjects];</span><br><span class="line">        [<span class="keyword">self</span>.refreshHeader endRefreshing];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.photoArray addObjectsFromArray:array];</span><br><span class="line">    <span class="keyword">if</span> (manager.noMoreData) &#123;</span><br><span class="line">        <span class="comment">// 没有更多数据</span></span><br><span class="line">        [<span class="keyword">self</span>.refreshFooter endRefreshingWithNoMoreData];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.refreshFooter endRefreshing];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.feedCollectionView reloadData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7，动态部署方案"><a href="#7，动态部署方案" class="headerlink" title="7，动态部署方案"></a>7，动态部署方案</h2><p>（1）Web App<br>其实所谓的web app，就是通过手机上的浏览器进行访问的H5页面。这个H5页面是针对移动场景特别优化的，比如UI交互等。</p>
<ul>
<li>优点<br>无需走苹果流程，所有苹果流程带来的成本都能避免，包括审核周期、证书成本等。<br>版本更新跟网页一样，随时生效。<br>不需要Native App工程师的参与，而且市面上已经有很多针对这种场景的框架。</li>
<li>缺点<br>重度依赖网络环境、流畅度不如Native、很难做好本地持久化（只能提供账户体系，对应账户的持久化数据全部存在服务端）、即时响应方案、远程通知实现方案、移动端传感器的使用方案复杂，维护难度大。<br>安全问题，H5页面等于是所有东西都暴露给了用户，如果对安全要求比较高的，很多额外的安全机制都需要在服务端实现。</li>
<li>总结<br>web app一般是创业初期会重点考虑的方案，因为迭代非常快，而且创业初期的主要目标是需要验证模式的正确性，并不在于提供非常好的用户体验，只需要完成闭环即可。</li>
</ul>
<p>（2）Hybrid App<br>通过市面上各种Hybrid框架，来做H5和Native的混合应用，或者通过JS Bridge来做到H5和Native之间的数据互通。</p>
<ul>
<li>优点<br>除了要承担苹果流程导致的成本以外，具备所有web app的优势、能够访问本地数据、设备传感器等</li>
<li>缺点<br>跟web app一样存在过度依赖网络环境的问题、用户体验也很难做到很好、安全性问题依旧存在、大规模的数据交互很难实现，例如图片在本地处理后，将图片传递给H5</li>
<li>总结<br>Hybrid方案更加适合跟本地资源交互不是很多，然后主要以内容展示为主的App。在天猫App中，大量地采用了JS Bridge的方式来让H5跟Native做交互，因为天猫App是一个以内容展示为主的App，且营销活动多，周期短，比较适合Hybrid。</li>
</ul>
<p>（3）React-Native</p>
<ul>
<li>优点<br>响应速度很快，只比Native慢一点，比webview快很多。<br>能够做到一定程度上的动态部署</li>
<li>缺点<br>组装页面的元素需要Native提供支持，一定程度上限制了动态部署的灵活性。</li>
<li>总结<br>由于View的展示和View的事件响应分属于不同的端，展示部分的描述在JS端，响应事件的监听和描述都在Native端，通过Native转发给JS端。所以，从做动态部署的角度上讲，React-Native只能动态部署新View，不能动态部署新View对应的事件。<br>View的原型需要从Native中取，以后某个页面需要添加某个复杂的view的时候，需要从现有的组件中拼装。<br>它解决的是如何不使用Objc/Swift来写iOS App的View的问题，对于如何通过不发版来给已发版的App更新功能这样的问题，帮助有限。</li>
</ul>
<p>（4）Lua Patch<br>waxPatch的主要原理是通过lua来针对objc的方法进行替换，由于lua本身是解释型语言，可以通过动态下载得到，因此具备了一定的动态部署能力。然而iOS系统原生并不提供lua的解释库，所以需要在打包时把lua的解释库编译进app。</p>
<ul>
<li>优点<br>能够通过下载脚本替换方法的方式，修改本地App的行为。<br>执行效率较高</li>
<li>缺点<br>对于替换功能来说，lua是很不错的选择。但如果要添加新内容，实际操作会很复杂，很容易改错，小问题变成大问题</li>
<li>总结<br>lua的解决方案在一定程度上解决了动态部署的问题。实际操作时，一般不使用它来做新功能的动态部署，主要还是用于修复bug时代码的动态部署。</li>
</ul>
<p>（5）Javascript Patch<br>这个工作原理其实跟上面说的lua那套方案的工作原理一样，只不过是用javascript实现。</p>
<ul>
<li>优点<br>打包时不用将解释器也编译进去，iOS自带JavaScript的解释器。</li>
<li>缺点<br>同Lua方案的缺点</li>
<li>总结<br>在对app打补丁的方案中，目前我更倾向于使用JSPatch的方案，在能够完成Lua做到的所有事情的同时，还不用编一个JS解释器进去，而且会javascript的人比会lua的人多，技术储备比较好做。</li>
</ul>
<p>（6）JSON Descripted View<br>使用JSON来描述一个View应该有哪些元素，以及元素的位置，以及相关的属性，比如背景色，圆角等等。然后本地有一个解释器来把JSON描述的View生成出来。<br>这跟React-Native有点儿像，一个是JS转Native，一个是JSON转Native。但是同样有的问题就是事件处理的问题，在事件处理上，React-Native做得相对更好。因为JSON不能够描述事件逻辑，所以JSON生成的View所需要的事件处理都必须要本地事先挂好。</p>
<ul>
<li>优点<br>能够自由生成View并动态部署</li>
<li>缺点<br>天猫实际使用下来，发现还是存在一定的性能问题，不够快<br>事件需要本地事先写好，无法动态部署事件</li>
<li>总结<br>其实JSON描述的View比React-Native的View有个好处就在于对于这个View而言，不需要本地也有一套对应的View，它可以依据JSON的描述来自己生成。然而对于事件的处理是它的硬伤，所以JSON描述View的方案，一般比较适用于换肤，或者固定事件不同样式的View，比如贴纸。</li>
</ul>
<p>作者总结地实在是太全面太好了（崇拜脸😁）。<br>目前来看，使用比较广泛的是JS Patch。手百参考了一下它的原理，自己又写了一个，用于热修复，之前老板让调研过，最近用了几次。</p>
<p>在Splash中目前还没有实践热更新方案。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>1.0.0版本已经发布了，但是最近开发人员注册好像出了点问题，付款老是失败，然后就没上线。</p>
<p>github放这了：<a href="https://github.com/chenYalun/Splash" target="_blank" rel="noopener">https://github.com/chenYalun/Splash</a></p>
<p><img src="https://image.chenyalun.com/2019/12/26/splash_001.png" style="zoom:20%"><img src="https://image.chenyalun.com/2019/12/26/splash_002.png" style="zoom:20%"><img src="https://image.chenyalun.com/2019/12/26/splash_003.png" style="zoom:20%"><img src="https://image.chenyalun.com/2019/12/26/splash_004.png" style="zoom:20%"></p>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/iOS开发/">iOS开发</a>
            
              <a href="/tags/开源项目/">开源项目</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2019/09/30/多线程与Runloop拾遗/">
        <span class="next-text nav-default">多线程与Runloop拾遗</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
