<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="App界面优化Tips">




  <meta name="keywords" content="iOS开发,阅读,">




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x">



<link rel="canonical" href="http://blog.chenyalun.com/2019/03/15/App界面优化Tips/">


<meta name="description" content="App界面优化的小Tips。">
<meta name="keywords" content="iOS开发,阅读">
<meta property="og:type" content="article">
<meta property="og:title" content="App界面优化Tips">
<meta property="og:url" content="http://blog.chenyalun.com/2019/03/15/App界面优化Tips/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="App界面优化的小Tips。">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2019-12-21T07:56:39.480Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="App界面优化Tips">
<meta name="twitter:description" content="App界面优化的小Tips。">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> App界面优化Tips · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          App界面优化Tips
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年3月15日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、列表视图"><span class="toc-text">一、列表视图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定高Cell"><span class="toc-text">定高Cell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1，复用"><span class="toc-text">1，复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2，设置行高"><span class="toc-text">2，设置行高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3，模型生成"><span class="toc-text">3，模型生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4，subviews操作"><span class="toc-text">4，subviews操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5，触发离屏渲染"><span class="toc-text">5，触发离屏渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6，圆角"><span class="toc-text">6，圆角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7，阴影"><span class="toc-text">7，阴影</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不定高cell"><span class="toc-text">不定高cell</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、异步渲染"><span class="toc-text">二、异步渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用"><span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异步绘制文字"><span class="toc-text">异步绘制文字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码阅读"><span class="toc-text">源码阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#YYSentinel"><span class="toc-text">YYSentinel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YYTransaction"><span class="toc-text">YYTransaction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YYAsyncLayer"><span class="toc-text">YYAsyncLayer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1，子线程的处理"><span class="toc-text">1，子线程的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2，异步绘制开关控制"><span class="toc-text">2，异步绘制开关控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3，绘制时机"><span class="toc-text">3，绘制时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4，绘制操作"><span class="toc-text">4，绘制操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、小结"><span class="toc-text">三、小结</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p></p><p align="center"> App界面优化的小Tips。</p><br><a id="more"></a><p></p>
<p>本来这篇文章只是阅读YYAsyncLayer后的体会，后来一再扩充，变成了App界面优化的小Tips。。。</p>
<h1 id="一、列表视图"><a href="#一、列表视图" class="headerlink" title="一、列表视图"></a>一、列表视图</h1><h2 id="定高Cell"><a href="#定高Cell" class="headerlink" title="定高Cell"></a>定高Cell</h2><h3 id="1，复用"><a href="#1，复用" class="headerlink" title="1，复用"></a>1，复用</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kWBStatusCellIdentifier = <span class="string">@"kWBStatusCellIdentifier"</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView</span><br><span class="line">         cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    WBStatusCell *cell = [tableView dequeueReusableCellWithIdentifier:kWBStatusCellIdentifier forIndexPath:indexPath];</span><br><span class="line">    [cell setLayout:_layouts[indexPath.row]];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准化的写法是这样的。<code>dequeueReusableCellWithIdentifier:forIndexPath:</code>方法比<code>dequeueReusableCellWithIdentifier:</code>方法多了“自动创建”。cell的重用ID最好使用静态常量，尽管直接使用<code>@&quot;kWBStatusCellIdentifier&quot;</code>，编译器层面也会做优化，帮我们生成静态常量，但是意义不一样。</p>
<p>cell的种类不要太多，尽量通过hidden subview来区别。</p>
<h3 id="2，设置行高"><a href="#2，设置行高" class="headerlink" title="2，设置行高"></a>2，设置行高</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">_tableView.rowHeight = <span class="number">60</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>由于是固定行高，直接在配置TableView的懒加载中直接设置rowHeight属性即可。如果使用代理，会使TableView多次询问，增加不必要的调用。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">60</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，能使用整数的地方就不要使用小数，<code>60</code>要比<code>60.2</code>更好一点，CPU不喜欢小数。不仅仅指rowHeight这个属性，其他视图的width、height等属性，在满足UE要求的情况下，都可以尽可能地采用整数。</p>
<h3 id="3，模型生成"><a href="#3，模型生成" class="headerlink" title="3，模型生成"></a>3，模型生成</h3><p>采用MVVM，需要字典转模型；去Model化，需要格式化字典；无论怎样，都要把数据转换成视图喜欢的样子，这些操作就可以放到子线程中进行。尤其是遇到DateFormatter、stringWithFormat这些稍微耗性能的方法，该缓存就缓存，该替换就替换。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">   <span class="comment">// 字典转模型</span></span><br><span class="line">   WBTimelineItem *item = [WBTimelineItem modelWithJSON:data];</span><br><span class="line">   _statuses = item.statuses;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 主线程刷新</span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       [_tableView reloadData];</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="4，subviews操作"><a href="#4，subviews操作" class="headerlink" title="4，subviews操作"></a>4，subviews操作</h3><p>1，子视图越少，出现问题的可能性也越小。所以在构思的时候，一个视图能解决的问题，没必要多写几个视图。比如需要在同一行展示内容a和内容b，可以考虑只使用一个Label。<br>2，视图的动态创建和销毁也是很heavily的，考虑设置hidden属性来控制显示和隐藏。<br>3，尽量选用轻量级的控件，不需要用户响应的可以换成CALayer，比如CALayer替代UIImageView：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CALayer</span> *)photoImageViewLayer &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_photoImageViewLayer) &#123;</span><br><span class="line">        _photoImageViewLayer = [[<span class="built_in">CALayer</span> alloc] init];</span><br><span class="line">        _photoImageViewLayer.contentsGravity = <span class="string">@"resizeAspectFill"</span>;</span><br><span class="line">        _photoImageViewLayer.masksToBounds = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _photoImageViewLayer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line">[<span class="keyword">self</span>.photoImageViewLayer yy_setImageWithURL:url</span><br><span class="line">                                    placeholder:<span class="built_in">UIImage</span>.randomColorImage</span><br><span class="line">                                        options:options</span><br><span class="line">                                    completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p>
<p>但是CALayer不能设置约束，这就需要自己计算frame了。</p>
<h3 id="5，触发离屏渲染"><a href="#5，触发离屏渲染" class="headerlink" title="5，触发离屏渲染"></a>5，触发离屏渲染</h3><p>离屛渲染需要开辟一块新的缓冲区，在渲染的过程中还会有多次的切换上下文，这些很消耗性能。</p>
<blockquote>
<p>如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。</p>
</blockquote>
<p>下面是常见的可能触发离屏渲染的操作：</p>
<p>1， layer.cornerRadius + layer.masksToBounds一起设置<br>2， 设置图层阴影layer.shadow<br>3， 设置蒙层layer.mask<br>4， layer.allowsGroupOpacity 设置为YES同时layer.opacity小于1.0<br>5， layer.shouldRasterize设置为YES。<br>开启 Rasterization 后，GPU 只合成一次内容，然后复用合成的结果；合成的内容超过100ms没有使用会从缓存里移除，所以对于不连续使用的内容进行光栅化是既没有意义又浪费资源的，在更新内容时还会产生更多的离屏渲染。对于内容不发生变化的视图，进行光栅化会使原本拖后腿的离屏渲染就成为了助力；如果视图内容是动态变化的，使用这个方案有可能让性能变得更糟。不要过度使用，系统限制缓存的大小为 2.5x screen size，过度使用的话也会造成离屏渲染。（一般用在单独的视图上，而不是cell的layer）<br>6， 使用UIBlurEffect</p>
<p><a href="https://zhuanlan.zhihu.com/p/72653360" target="_blank" rel="noopener">即刻App</a>的优化思路是这样：<br>1，对于图片的圆角，统一采用“precomposite”的策略，也就是不经由容器来做剪切，而是预先使用CoreGraphics为图片裁剪圆角<br>2，对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的layer盖住四个角，从视觉上制造圆角的效果<br>3，对于view的圆形边框，如果没有backgroundColor，可以放心使用cornerRadius来做<br>4，对于所有的阴影，使用shadowPath来规避离屏渲染<br>5，对于特殊形状的view，使用layer mask并打开shouldRasterize来对渲染结果进行缓存<br>6，对于模糊效果，不采用系统提供的UIVisualEffect，而是另外实现模糊效果（CIGaussianBlur），并手动管理渲染结果</p>
<h3 id="6，圆角"><a href="#6，圆角" class="headerlink" title="6，圆角"></a>6，圆角</h3><p>“cornerRadius和maskToBounds一起设置会触发离屏渲染”，这句话需要讨论一下了：</p>
<p>1，UIView这般设置圆角不会产生离屏渲染。<br>2，iOS9.0之后UIImageView中的png图片这般设置圆角不会触发离屏渲染，但是如果UIImageView的backgroundColor不是clearColor或者不是nil，则会触发离屏渲染。</p>
<p>上面两条是我搜了很多资料发现的，亲自验证了一下，在iOS13上第一条是真的。第二条试着不设置backgroundColor果然也没有出现离屏渲染。但是，是不是从iOS9开始的，我没有真机也没法做判断，而且也没有找到官方的说明。</p>
<p><strong>下面是之前的UIImageView设置圆角的处理方式</strong><br>直接使用layer.mask来达到圆角效果同样会触发离屏渲染，对于网络图片的圆角处理通常是先下载后圆角化。<br>下载逻辑（以我喜欢的YYWebImage为例）：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">NSString *radiusKey = [url.absoluteString <span class="string">stringByAppendingString:</span>@<span class="string">"radiusCache"</span>];</span><br><span class="line">UIImage *radiusImage = [YYImageCache.sharedCache <span class="string">getImageForKey:</span>radiusKey];</span><br><span class="line"><span class="keyword">if</span> (radiusImage) &#123;</span><br><span class="line">   self.photoImageView.image = radiusImage;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   [YYWebImageManager.sharedManager <span class="string">requestImageWithURL:</span>url <span class="string">options:</span>YYWebImageOptionShowNetworkActivity <span class="string">progress:</span>nil <span class="string">transform:</span>nil <span class="string">completion:</span>^(UIImage *image, NSURL *url, YYWebImageFromType from, YYWebImageStage stage, NSError * error) &#123;</span><br><span class="line">       dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           <span class="keyword">if</span> (!error &amp;&amp; image) &#123;</span><br><span class="line">               [YYImageCache.sharedCache <span class="string">setImage:</span>radiusImage <span class="string">imageData:</span>nil <span class="string">forKey:</span>radiusKey <span class="string">withType:</span>YYImageCacheTypeAll];</span><br><span class="line">               self.photoImageView.image = image.radiusImage;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图片下载完毕后做圆角处理并保存，但是有几个问题需要思考：<br>1，这张图片的圆角半径在业务上是固定的吗，如果不固定（比如需要10px、20px两种）那就需要存储多份了；<br>2，这张图片的展示效果是否只有圆角一种，是否同时存在有方图和圆角图两种形式？需要保留原图吗；</p>
<p>这个是使用Core Graphics创建圆角图片的不会触发离屏渲染的示例，可以子线程绘制：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)radiusImage &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</span><br><span class="line">    <span class="built_in">CGFloat</span> radius = <span class="number">100.</span>f; <span class="comment">// 这个度量是图片的，而不是imageView的</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">false</span>, <span class="built_in">UIScreen</span>.mainScreen.scale);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect byRoundingCorners:<span class="built_in">UIRectCornerAllCorners</span> cornerRadii:<span class="built_in">CGSizeMake</span>(radius, radius)];</span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(context, path.CGPath);</span><br><span class="line">    <span class="built_in">CGContextClip</span>(context);</span><br><span class="line">    [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathFillStroke);</span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7，阴影"><a href="#7，阴影" class="headerlink" title="7，阴影"></a>7，阴影</h3><p>假如需要这么设置阴影效果：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">button.layer.shadowColor </span>= UIColor.<span class="keyword">blackColor.CGColor;</span></span><br><span class="line"><span class="keyword">button.layer.shadowOpacity </span>= <span class="number">0</span>.<span class="number">5</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">button.layer.shadowRadius </span>= <span class="number">10</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">button.layer.shadowOffset </span>= CGSizeMake(<span class="number">10</span>, <span class="number">10</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>只需要再加上一句话就能避免离屏渲染了：<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">button</span>.layer.shadowPath = [UIBezierPath bezierPathWithRect:<span class="keyword">button</span>.bounds].CGPath;</span><br></pre></td></tr></table></figure></p>
<p>但是有个小问题，如果这个具有阴影效果的视图需要做frame动画，那它的shadow效果是不会改变的，这还得再想办法解决：<a href="https://www.jianshu.com/p/fd0e7709a404" target="_blank" rel="noopener">显式指定shadowPath的动画效果</a>。</p>
<h2 id="不定高cell"><a href="#不定高cell" class="headerlink" title="不定高cell"></a>不定高cell</h2><p>不定高的cell需要计算cell的高度。有两种方式：一是自己在后台根据模型数据配置子视图的布局，手动计算，并把高度存储到对应的模型中；二是借助自动布局，保证子视图“撑满”cell，自动更新cell的高度。</p>
<p>如果对性能要求不高，或者开发周期短，可以直接使用Auto Layout，再配合<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell/" target="_blank" rel="noopener">FDTemplateLayoutCell</a>的高度缓存机制，可以说已经很方便了。不然只能自己计算并做缓存处理。</p>
<h1 id="二、异步渲染"><a href="#二、异步渲染" class="headerlink" title="二、异步渲染"></a>二、异步渲染</h1><p>TableView和CollectionView的优化也可以借助异步渲染，YYAsyncLayer描述了异步渲染的核心原理。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YYAsyncLayer </span>: CALayer</span><br><span class="line"><span class="comment">// Default is YES.</span></span><br><span class="line"><span class="variable">@property</span> BOOL displaysAsynchronously;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@protocol</span> YYAsyncLayerDelegate &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@required</span></span><br><span class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将要绘制、正在绘制、绘制完毕 对应的block</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">YYAsyncLayerDisplayTask </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nullable, nonatomic, copy) void (^willDisplay)(CALayer *layer);</span><br><span class="line"><span class="variable">@property</span> (nullable, nonatomic, copy) void (^display)(CGContextRef context, CGSize size, BOOL(^isCancelled)(void));</span><br><span class="line"><span class="variable">@property</span> (nullable, nonatomic, copy) void (^didDisplay)(CALayer *layer, BOOL finished);</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>视图在初始化过程之前调用UIView类方法layerClass，并且使用返回的类来创建layer对象。通过创建UIView的子类，重写layerClass类函数可以改变创建图层时的默认的CALayer类。在自定义视图对象中，返回一个YYAsyncLayerDisplayTask，这个task承担着绘制的任务。</p>
<h3 id="异步绘制文字"><a href="#异步绘制文字" class="headerlink" title="异步绘制文字"></a>异步绘制文字</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YALabel</span> : <span class="title">UIView</span> &lt;<span class="title">YYAsyncLayerDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSAttributedString</span> *attributedString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YALabel</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAttributedString:(<span class="built_in">NSAttributedString</span> *)attributedString &#123;</span><br><span class="line">    _attributedString = attributedString;</span><br><span class="line">    <span class="comment">// YYTransaction let you perform a selector once before current runloop sleep.</span></span><br><span class="line">    [[YYTransaction transactionWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(setTextNeedsDisplay)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    [[YYTransaction transactionWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(setTextNeedsDisplay)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTextNeedsDisplay &#123;</span><br><span class="line">    [<span class="keyword">self</span>.layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    <span class="keyword">return</span> YYAsyncLayer.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask &#123;</span><br><span class="line">    YYAsyncLayerDisplayTask *task = [YYAsyncLayerDisplayTask new];</span><br><span class="line">    task.display = ^(<span class="built_in">CGContextRef</span> context, <span class="built_in">CGSize</span> size, <span class="built_in">BOOL</span> (^isCancelled)(<span class="keyword">void</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled() || <span class="keyword">self</span>.attributedString.string.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 修复绘制文字会颠倒</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="keyword">self</span>.bounds.size.height);</span><br><span class="line">            <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="built_in">NSAttributedString</span> *str = <span class="keyword">self</span>.attributedString;</span><br><span class="line">        [str enumerateAttribute:<span class="built_in">NSFontAttributeName</span> inRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, str.length) options:<span class="built_in">NSAttributedStringEnumerationLongestEffectiveRangeNotRequired</span> usingBlock:^(<span class="built_in">UIFont</span> *font, <span class="built_in">NSRange</span> range, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="comment">// 根据字体设置pointSize</span></span><br><span class="line">            <span class="built_in">CGContextSetTextPosition</span>(context, <span class="number">0</span>, font.pointSize);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">// 绘制</span></span><br><span class="line">        <span class="built_in">CTLineRef</span> line = <span class="built_in">CTLineCreateWithAttributedString</span>((__bridge <span class="built_in">CFAttributedStringRef</span>)str);</span><br><span class="line">        <span class="built_in">CTLineDraw</span>(line, context);</span><br><span class="line">        <span class="built_in">CFRelease</span>(line);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>使用的时候很简单了，设置一个AttributedString即可：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">YALabel *<span class="keyword">label</span><span class="bash"> = [YALabel new];</span></span><br><span class="line"><span class="bash">NSAttributedString *str = [[NSAttributedString alloc] initWithString:@<span class="string">"😀😁🤣😂Label的异步绘制"</span> attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:15]&#125;];</span></span><br><span class="line"><span class="bash">label.attributedString = str;</span></span><br><span class="line"><span class="bash">label.backgroundColor = UIColor.orangeColor;</span></span><br><span class="line"><span class="bash">label.frame = CGRectMake(100, 100, 200, 50);</span></span><br><span class="line"><span class="bash">[self.view addSubview:label];</span></span><br></pre></td></tr></table></figure></p>
<p>这里的newAsyncDisplayTask比较简单，只绘制了单行文本，如果真的要应用到项目中，可以利用CoreText更加完善些，加上自动换行，自适应size，图文混排等功能。</p>
<p>有前辈写了一个IM的Demo，里面有用到异步绘制：<a href="https://github.com/Yuzeyang/GCAsyncDisplayDemo" target="_blank" rel="noopener">https://github.com/Yuzeyang/GCAsyncDisplayDemo</a>  ，读一读还是很棒的。</p>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>源码不是很多，就几个文件，但是跟作者的其他框架一样，代码特别优秀。</p>
<h3 id="YYSentinel"><a href="#YYSentinel" class="headerlink" title="YYSentinel"></a>YYSentinel</h3><p>这是一个线程安全的计数器，内部维护了一个实例变量。如何做到线程安全? 主要是依赖于原子函数<code>OSAtomicIncrement32()</code>。</p>
<blockquote>
<p>如果我们想要初始化一个共享的数据结构，然后自动增加某个变量值来标识初始化操作完成，则我们必须使用<code>OSAtomicIncrement32Barrier</code>来确保数据结构的存储操作在变量自动增加前完成。</p>
</blockquote>
<p>使用这个类的目的： 标记某个操作是否完成，也即判断或者标记异步渲染操作的完成情况</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;libkern/OSAtomic.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程安全的计数器</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYSentinel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) int32_t value;</span><br><span class="line">- (int32_t)increase;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYSentinel</span> </span>&#123;</span><br><span class="line">    int32_t _value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int32_t)value &#123;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int32_t)increase &#123;</span><br><span class="line">    <span class="keyword">return</span> OSAtomicIncrement32(&amp;_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="YYTransaction"><a href="#YYTransaction" class="headerlink" title="YYTransaction"></a>YYTransaction</h3><p>只有两个方法接口。<br>方法一： 包装<code>target</code>和<code>selector</code>并生成一个<code>YYTransaction</code>对象。<br>方法二： commit这个对象。<br>包装成YYTransaction对象的方法不用多说，其内部使用实例变量引用着传递的参数。<br>最关键的是<code>commit</code>方法。It will perform the selector on the target once before main runloop’s current loop sleep. If the same transaction (same target and same selector) has already commit to runloop in this loop, this method do nothing. 也就是说在Runloop每次休眠之前只调用一次<code>target</code>的<code>selector</code>方法。</p>
<p>commit方法内部使用transactionSet集合添加了这个<code>YYTransaction</code>对象。作者给Runloop添加了一个observer，在 <code>kCFRunLoopBeforeWaiting</code> 和 <code>kCFRunLoopExit</code>这两种状态下会调用指定的<code>YYRunLoopObserverCallBack()</code>函数。这个函数的作用很简单：逐个遍历transactionSet集合中的所有元素，使其<code>target</code>调用对应的<code>selector</code>。</p>
<p><code>YYTransaction</code>重写了<code>- (NSUInteger)hash</code>方法和<code>- (BOOL)isEqual:(id)object</code>方法来确定“对象相等”。这保证了Set集合中的元素唯一性。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYTransaction</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (YYTransaction *)transactionWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector;</span><br><span class="line">- (<span class="keyword">void</span>)commit;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYTransaction</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SEL selector;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *transactionSet = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐个遍历transactionSet中的所有元素，使其target调用对应的selector</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> YYRunLoopObserverCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (transactionSet.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">NSSet</span> *currentSet = transactionSet;</span><br><span class="line">    transactionSet = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">    [currentSet enumerateObjectsUsingBlock:^(YYTransaction *transaction, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">        [transaction.target performSelector:transaction.selector];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Runloop处于kCFRunLoopBeforeWaiting或者kCFRunLoopExit的状态的时候调用YYRunLoopObserverCallBack()函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> YYTransactionSetup() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        transactionSet = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> runloop = <span class="built_in">CFRunLoopGetMain</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopObserverRef</span> observer;</span><br><span class="line">        </span><br><span class="line">        observer = <span class="built_in">CFRunLoopObserverCreate</span>(<span class="built_in">CFAllocatorGetDefault</span>(),</span><br><span class="line">                                           kCFRunLoopBeforeWaiting | kCFRunLoopExit,</span><br><span class="line">                                           <span class="literal">true</span>,      <span class="comment">// repeat</span></span><br><span class="line">                                           <span class="number">0xFFFFFF</span>,  <span class="comment">// after CATransaction(2000000)</span></span><br><span class="line">                                           YYRunLoopObserverCallBack, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(runloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">        <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYTransaction</span></span></span><br><span class="line"></span><br><span class="line">+ (YYTransaction *)transactionWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector&#123;</span><br><span class="line">    <span class="keyword">if</span> (!target || !selector) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    YYTransaction *t = [YYTransaction new];</span><br><span class="line">    t.target = target;</span><br><span class="line">    t.selector = selector;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把生成的YYTransaction对象放入transactionSet中</span></span><br><span class="line">- (<span class="keyword">void</span>)commit &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_target || !_selector) <span class="keyword">return</span>;</span><br><span class="line">    YYTransactionSetup();</span><br><span class="line">    [transactionSet addObject:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isEqual: 是通过hash方法来判等的</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)hash &#123;</span><br><span class="line">    <span class="keyword">long</span> v1 = (<span class="keyword">long</span>)((<span class="keyword">void</span> *)_selector);</span><br><span class="line">    <span class="keyword">long</span> v2 = (<span class="keyword">long</span>)_target;</span><br><span class="line">    <span class="keyword">return</span> v1 ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要_target和_selector都一致，就说明'YYTransaction'是同一个</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == object) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (![object isMemberOfClass:<span class="keyword">self</span>.class]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    YYTransaction *other = object;</span><br><span class="line">    <span class="keyword">return</span> other.selector == _selector &amp;&amp; other.target == _target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="YYAsyncLayer"><a href="#YYAsyncLayer" class="headerlink" title="YYAsyncLayer"></a>YYAsyncLayer</h3><p>最后是YYAsyncLayer的实现，最核心的逻辑就在这里了。我一年之前就曾经读过这块源码，当时有好多疑惑，现在再来看，有的疑惑已经解开了，有的还没有，在这记录一下。</p>
<h4 id="1，子线程的处理"><a href="#1，子线程的处理" class="headerlink" title="1，子线程的处理"></a>1，子线程的处理</h4><p>异步，自然要放到子线程。主队列对应的是主线程，4个不同优先级的全局队列并不对应4个子线程。毅然放在全局队列不太可取，可能会出现App在同一时刻存在几十个线程同时运行、创建、销毁的情况。“当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。”。使用串行队列又无法充分利用多核CPU的资源。作者在YYAsyncLayer中的思路是：创建和 CPU 数量相同的串行queue（最多16个），放到一个数组中，每次从数组中随机获取其中的一个queue。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Global display queue, used for content rendering.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> dispatch_queue_t <span class="title">YYAsyncLayerGetDisplayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_QUEUE_COUNT 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> queueCount;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span> queues[MAX_QUEUE_COUNT];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int32_t</span> counter = <span class="number">0</span>;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 获取运行该进程的系统的处于激活状态的处理器数量, iPhone 6s 是2个</span></span><br><span class="line">        queueCount = (<span class="keyword">int</span>)[NSProcessInfo processInfo].activeProcessorCount;</span><br><span class="line">        queueCount = queueCount &lt; <span class="number">1</span> ? <span class="number">1</span> : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</span><br><span class="line">        <span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; queueCount; i++) &#123;</span><br><span class="line">            <span class="keyword">dispatch_queue_attr_t</span> attr =</span><br><span class="line">            <span class="comment">// QOS_CLASS_USER_INITIATED 用户发起并等待的优先级</span></span><br><span class="line">            dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 创建串行队列</span></span><br><span class="line">            queues[i] = dispatch_queue_create(<span class="string">"com.ibireme.yykit.render"</span>, attr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 大量使用 OSAtomicIncrement32,由于该函数对某个值进行自增计算,而且是线程安全的,所以被用来作为绘制时的标记位(哨兵).异步绘制的关键在于每次调用 setNeedDisplay 时都会将哨兵变量自增,在 display 方法中,根据这个哨兵变量来确定是否继续绘制还是停止绘制.一致则继续绘制, 不一致则停止绘制</span></span><br><span class="line">    <span class="keyword">int32_t</span> cur = OSAtomicIncrement32(&amp;counter); <span class="comment">// counter自增一, 并取出该值,</span></span><br><span class="line">    <span class="keyword">if</span> (cur &lt; <span class="number">0</span>) cur = -cur; <span class="comment">// 啥时候会出现?? counter取INT_MAX的时候出现</span></span><br><span class="line">    <span class="keyword">return</span> queues[(cur) % queueCount]; <span class="comment">// 取余</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> MAX_QUEUE_COUNT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单纯就子线程绘制这个问题而言，思考一下，既然会出现“同一时刻存在几十个线程同时运行、创建、销毁”的情况，那如果直接操作线程呢，直接创建三五个NSThread对象，让它们处理App中的所有异步渲染操作。如果这样的话，就需要对这三五个NSThread对象进行线程保活，保证它们永远存在。再者只能通过performSelector:onThread:进行方法调用（或者再做一个block方式的封装）。<strong>最后也是最重要的是，没办法利用设备多核的优势。</strong>单核中的多线程实际上是每个时间片上只有一个线程在运行，而多核实际上是真的多线程，每一个时间片每个核都有一个线程在执行。dispatch_async是多核级别编程框架调度函数，这才真正决定了为啥要使用GCD。</p>
<h4 id="2，异步绘制开关控制"><a href="#2，异步绘制开关控制" class="headerlink" title="2，异步绘制开关控制"></a>2，异步绘制开关控制</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写修改CALayer或其子类属性的默认值，key为属性名称，如果没有该属性则返回nil。</span></span><br><span class="line">+ (<span class="keyword">id</span>)defaultValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"displaysAsynchronously"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(<span class="literal">YES</span>); <span class="comment">// 仅仅针对displaysAsynchronously这个属性修改</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> defaultValueForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="comment">// 设置屏幕缩放比例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CGFloat</span> scale; <span class="comment">// global</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        scale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">self</span>.contentsScale = scale;</span><br><span class="line">    <span class="comment">// 计数器, 控制多线程访问</span></span><br><span class="line">    _sentinel = [YYSentinel new];</span><br><span class="line">    <span class="comment">// 默认是YES</span></span><br><span class="line">    _displaysAsynchronously = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>displaysAsynchronously</code>来控制是否开启异步渲染。<br>但是这里有个问题想不通，YYAsyncLayer的init方法中已经初始化<code>_displaysAsynchronously</code>的值为YES了，但是作者又重写defaultValueForKey方法并在其中再次设置displaysAsynchronously属性为YES。这两个方式的效果一样呀，会不会多此一举了呢？</p>
<h4 id="3，绘制时机"><a href="#3，绘制时机" class="headerlink" title="3，绘制时机"></a>3，绘制时机</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">// layer销毁的时候, 计数器加1, 表示原先的绘制需要取消</span></span><br><span class="line">    [<span class="meta">_sentinel increase</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setNeedsDisplay &#123;</span><br><span class="line">    <span class="comment">// 被标记需要重新绘制, 则取消上次的异步调用</span></span><br><span class="line">    [<span class="meta">self _cancelAsyncDisplay</span>];</span><br><span class="line">    [<span class="meta">super setNeedsDisplay</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reload the content of this layer.</span></span><br><span class="line"><span class="comment">// Subclasses can override this method and use it to set the layer’s contents property directly. You might do this if your custom layer subclass handles layer updates differently.</span></span><br><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="comment">// 这个赋值是因为这样吗??</span></span><br><span class="line">    <span class="comment">// Assigning a value to this property causes the layer to use your image rather than create a separate backing store.</span></span><br><span class="line">    super.contents = super.contents;</span><br><span class="line">    [<span class="meta">self _displayAsync:_displaysAsynchronously</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_cancelAsyncDisplay &#123;</span><br><span class="line">    <span class="comment">// increase增加1, 与目前的不一致了, 表示目前的渲染已取消</span></span><br><span class="line">    [<span class="meta">_sentinel increase</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际的绘制逻辑中，是通过判断计数器<code>_sentinel</code>的值来确定是否取消绘制：<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">YYSentinel *sentinel = <span class="number">_</span>sentinel;</span><br><span class="line">int<span class="number">32_</span>t <span class="keyword">value</span> = sentinel.<span class="keyword">value</span>;</span><br><span class="line">BOOL (^isCancelled)(<span class="keyword">void</span>) = ^BOOL() &#123;</span><br><span class="line">  <span class="comment">// 值相等, 说明正在绘制没有取消, 否则说明已经取消啦</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span> != sentinel.<span class="keyword">value</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>反过来，只需要把计数器的值自增（<code>[_sentinel increase]</code>）就可以表示目前的绘制操作取消了。在Layer销毁的时候（dealloc）和被标记需要重新绘制的时候（setNeedsDisplay）应该取消原先的绘制操作。</p>
<p>按照苹果的说明，CALayer的子类可以重写display方法并在其中直接设置contents。YYAsyncLayer便在其中做了异步绘制操作。这里的<code>super.contents = super.contents;</code>一句话确实当然没看懂，后来发现也有小伙伴跟我一样没弄明白，然后查阅资料发现了苹果的解释：Assigning a value to this property causes the layer to use your image rather than create a separate backing store.</p>
<h4 id="4，绘制操作"><a href="#4，绘制操作" class="headerlink" title="4，绘制操作"></a>4，绘制操作</h4><p>最后便是绘制的操作了，写了很详细的注释：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心方法</span></span><br><span class="line">- (<span class="keyword">void</span>)_displayAsync:(<span class="built_in">BOOL</span>)async &#123;</span><br><span class="line">    <span class="comment">// 强引用代理, 避免释放</span></span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span>&lt;YYAsyncLayerDelegate&gt; delegate = (<span class="keyword">id</span>)<span class="keyword">self</span>.delegate;</span><br><span class="line">    <span class="comment">// 获取一个Display Task</span></span><br><span class="line">    YYAsyncLayerDisplayTask *task = [delegate newAsyncDisplayTask];</span><br><span class="line">    <span class="keyword">if</span> (!task.display) &#123; <span class="comment">// 没有需要绘制的内容, 设置contents为空</span></span><br><span class="line">        <span class="keyword">if</span> (task.willDisplay) task.willDisplay(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">self</span>.contents = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">YES</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (async) &#123; <span class="comment">// 异步绘制</span></span><br><span class="line">        <span class="keyword">if</span> (task.willDisplay) task.willDisplay(<span class="keyword">self</span>);</span><br><span class="line">        YYSentinel *sentinel = _sentinel;</span><br><span class="line">        int32_t value = sentinel.value;</span><br><span class="line">        <span class="built_in">BOOL</span> (^isCancelled)(<span class="keyword">void</span>) = ^<span class="built_in">BOOL</span>() &#123;</span><br><span class="line">            <span class="comment">// 值相等, 说明正在绘制没有取消, 否则说明已经取消啦</span></span><br><span class="line">            <span class="keyword">return</span> value != sentinel.value;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.bounds.size;</span><br><span class="line">        <span class="built_in">BOOL</span> opaque = <span class="keyword">self</span>.opaque;</span><br><span class="line">        <span class="built_in">CGFloat</span> scale = <span class="keyword">self</span>.contentsScale;</span><br><span class="line">        <span class="comment">// 获取背景色</span></span><br><span class="line">        <span class="built_in">CGColorRef</span> backgroundColor = (opaque &amp;&amp; <span class="keyword">self</span>.backgroundColor) ? <span class="built_in">CGColorRetain</span>(<span class="keyword">self</span>.backgroundColor) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (size.width &lt; <span class="number">1</span> || size.height &lt; <span class="number">1</span>) &#123; <span class="comment">// 宽或者高小于1的情况</span></span><br><span class="line">            <span class="comment">// 获取图片再释放掉, 为啥要多此一举?</span></span><br><span class="line">            <span class="comment">// 因为赋值给contents的就是一个CGImageRef, 如果直接self.contents = nil;会造成这个image在当前线程(主线程)释放。作者手动把这个image取出来的目的就是把'release'操作放在YYAsyncLayerGetReleaseQueue()这个队列中</span></span><br><span class="line">            <span class="built_in">CGImageRef</span> image = (__bridge_retained <span class="built_in">CGImageRef</span>)(<span class="keyword">self</span>.contents);</span><br><span class="line">            <span class="keyword">self</span>.contents = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(YYAsyncLayerGetReleaseQueue(), ^&#123;</span><br><span class="line">                    <span class="built_in">CFRelease</span>(image);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">YES</span>);</span><br><span class="line">            <span class="built_in">CGColorRelease</span>(backgroundColor);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从这里开始进入子线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(YYAsyncLayerGetDisplayQueue(), ^&#123;</span><br><span class="line">            <span class="comment">// 进入子线程后, 第1次取消绘制判断</span></span><br><span class="line">            <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                <span class="built_in">CGColorRelease</span>(backgroundColor);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开启图形上下文</span></span><br><span class="line">            <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, opaque, scale);</span><br><span class="line">            <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">            <span class="keyword">if</span> (opaque) &#123;</span><br><span class="line">            <span class="comment">// UIGraphicsPushContext:压栈当前的绘制对象, 生成新的绘制图层。UIKit的绘制必须在当前的上下文中绘制，而UIGraphicsPushContext可以将当前的参数context转化为可以UIKit绘制的上下文，进行绘制图片。</span></span><br><span class="line">            <span class="comment">// CGContextSaveGState:压栈当前的绘制状态</span></span><br><span class="line">                <span class="comment">// 这里是为了不"污染"原先的context内容, 保存状态后绘制新的内容</span></span><br><span class="line">                <span class="built_in">CGContextSaveGState</span>(context);</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 没有背景色或者 透明度小于1, 使用白色填充</span></span><br><span class="line">                    <span class="keyword">if</span> (!backgroundColor || <span class="built_in">CGColorGetAlpha</span>(backgroundColor) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="built_in">CGContextSetFillColorWithColor</span>(context, [<span class="built_in">UIColor</span> whiteColor].CGColor);</span><br><span class="line">                        <span class="built_in">CGContextAddRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width * scale, size.height * scale));</span><br><span class="line">                        <span class="built_in">CGContextFillPath</span>(context);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 这里使用backgroundColor填充</span></span><br><span class="line">                    <span class="keyword">if</span> (backgroundColor) &#123;</span><br><span class="line">                        <span class="built_in">CGContextSetFillColorWithColor</span>(context, backgroundColor);</span><br><span class="line">                        <span class="built_in">CGContextAddRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width * scale, size.height * scale));</span><br><span class="line">                        <span class="built_in">CGContextFillPath</span>(context);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">CGContextRestoreGState</span>(context);</span><br><span class="line">                <span class="built_in">CGColorRelease</span>(backgroundColor);</span><br><span class="line">            &#125;</span><br><span class="line">            task.display(context, size, isCancelled);</span><br><span class="line">            <span class="comment">// display完毕后, 第2次取消绘制判断</span></span><br><span class="line">            <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                <span class="comment">// 如果确定已经取消绘制了, 关闭图形上下文</span></span><br><span class="line">                <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">NO</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从当前上下文中获取生成的新内容</span></span><br><span class="line">            <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">            <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">            <span class="comment">// 从上下文中获取图片后, 第3次取消绘制判断</span></span><br><span class="line">            <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">NO</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="comment">// 转到主线程对contents赋值，第4次取消绘制判断</span></span><br><span class="line">                <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">NO</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 在这里对contents赋值</span></span><br><span class="line">                    <span class="keyword">self</span>.contents = (__bridge <span class="keyword">id</span>)(image.CGImage);</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">YES</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非异步绘制</span></span><br><span class="line">        <span class="comment">// 不需要进行线程安全判断了</span></span><br><span class="line">        [_sentinel increase];</span><br><span class="line">        <span class="comment">// 下面的代码都是和异步绘制相同的套路</span></span><br><span class="line">        <span class="keyword">if</span> (task.willDisplay) task.willDisplay(<span class="keyword">self</span>);</span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size, <span class="keyword">self</span>.opaque, <span class="keyword">self</span>.contentsScale);</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.opaque) &#123;</span><br><span class="line">            <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.bounds.size;</span><br><span class="line">            size.width *= <span class="keyword">self</span>.contentsScale;</span><br><span class="line">            size.height *= <span class="keyword">self</span>.contentsScale;</span><br><span class="line">            <span class="built_in">CGContextSaveGState</span>(context); &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">self</span>.backgroundColor || <span class="built_in">CGColorGetAlpha</span>(<span class="keyword">self</span>.backgroundColor) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">CGContextSetFillColorWithColor</span>(context, [<span class="built_in">UIColor</span> whiteColor].CGColor);</span><br><span class="line">                    <span class="built_in">CGContextAddRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</span><br><span class="line">                    <span class="built_in">CGContextFillPath</span>(context);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundColor) &#123;</span><br><span class="line">                    <span class="built_in">CGContextSetFillColorWithColor</span>(context, <span class="keyword">self</span>.backgroundColor);</span><br><span class="line">                    <span class="built_in">CGContextAddRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</span><br><span class="line">                    <span class="built_in">CGContextFillPath</span>(context);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="built_in">CGContextRestoreGState</span>(context);</span><br><span class="line">        &#125;</span><br><span class="line">        task.display(context, <span class="keyword">self</span>.bounds.size, ^&#123;<span class="keyword">return</span> <span class="literal">NO</span>;&#125;);</span><br><span class="line">        <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        <span class="keyword">self</span>.contents = (__bridge <span class="keyword">id</span>)(image.CGImage);</span><br><span class="line">        <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">YES</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看起来貌似很多，实际的绘制原理三行代码可以说清楚：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1，从当前图形上下文中获取Image</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="comment">// 2，关闭图形上下文</span></span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"><span class="comment">// 3，将image赋值给layer的contents属性</span></span><br><span class="line"><span class="keyword">self</span>.contents = (__bridge <span class="keyword">id</span>)(image.CGImage);</span><br></pre></td></tr></table></figure>
<p>在这之外更多的是 是否取消绘制的判断、没有背景色或者透明度小于1的处理、size极小值的处理等等。</p>
<p>当然还有那个巧妙的子线程异步释放对象的逻辑，记得也见过好多次了：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGImageRef</span> image = (__bridge_retained <span class="built_in">CGImageRef</span>)(<span class="keyword">self</span>.contents);</span><br><span class="line"><span class="keyword">self</span>.contents = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (image) &#123;</span><br><span class="line"> <span class="built_in">dispatch_async</span>(YYAsyncLayerGetReleaseQueue(), ^&#123;</span><br><span class="line">     <span class="built_in">CFRelease</span>(image);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>平时的业务开发中我们也可以这么用，比如：<br><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">// 含有大量元素的数组</span><br><span class="line">NSMutableArray *array = self.itemArray;</span><br><span class="line">self.itemArray = nil;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">  <span class="built_in"> array </span>= nil; // 子线程释放</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">《iOS 保持界面流畅的技巧》</a>这篇文章想必很多人都有人阅读过，也都能从中受益。<br>这里回顾一下ibireme大神的微博Demo性能优化技巧：<br><strong>1，预排版</strong><br>这里是指不定高cell的预排版，本文也已经提过，frame布局，可以子线程手动计算并把layout数据缓存在模型中，autolayout布局，可以借助FDTemplateLayoutCell做高度缓存。<br><strong>2，预渲染</strong><br>作者举了一个圆角图片预先裁剪并做缓存处理来避免离屏渲染的例子，也正如上文所说，layer.cornerRadius + layer.masksToBounds一起设置在新版本系统上已经不会触发离屏渲染（大多数人说是iOS9，我还没有确认），但是这个思路可以举一反三，很多可以提前的工作没必要等到cell要展示了才开始做。<br><strong>3，异步绘制+全局并发控制</strong></p>
<ul>
<li>借助YYDispatchQueuePool把App内所有异步操作按优先级不同放入了全局的 serial queue 中执行，尽量避免了过多线程导致的性能问题。</li>
<li>借助YYAsyncLayer和CoreText实现富文本的异步绘制（当然也可以直接使用功能更强大的YYText，作者把路都给铺好了😂）。</li>
</ul>
<p><strong>4，异步图片加载</strong><br>大多时候，只是显示简单的单张图片，可以直接使用UIView.layer.contents，而不需要使用UIImageView。当然，SDWebImage和YYWebImage把很多工作都做好了。<br><strong>5，不需要触摸事件的UIView换成CALayer</strong><br>可以这么做，但是CALayer没法设置约束了，如果使用自动布局就很蛋疼了。<br><strong>6，多个视觉元素合成一张图</strong><br>也是一种思路，甚至也一定条件下可以把cell的全部内容合成一张图片，但是可能性比较小，需要根据业务来走。<br>以微博为例，“来自iPhone”、会员图标、话题、转发微博原作者昵称、微博内容的链接这些元素都需要响应点击事件，根本不可能用一种图片代替。<br>百度的feed流，很多新闻的样式是相同的，而且不像微博需要处理很多子元素的点击事件，很多情况下只需要处理cell的点击事件就可以了，这才有合成一张图片的可能性。</p>
<p>过早的优化是万恶之源，所有的tips都只是建议，需要具体问题具体分析。很多前辈给我们提供了诸多便利的工具，对于我们，平时踏踏实实写代码，少写bug，不写crash，这才是最重要的。</p>
<blockquote>
<p>参考资料：<br><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">《iOS 保持界面流畅的技巧》</a><br><a href="http://tutuge.me/2015/02/19/提升UITableView性能-复杂页面的优化/" target="_blank" rel="noopener">《提升UITableView性能-复杂页面的优化》</a><br><a href="https://www.jianshu.com/p/15b8b1844e9c" target="_blank" rel="noopener">《iOS 阴影，圆角，避免离屏渲染》</a><br><a href="https://juejin.im/post/5acf34eff265da237314d6e0" target="_blank" rel="noopener">《UITableView 性能优化》</a></p>
</blockquote>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/iOS开发/">iOS开发</a>
            
              <a href="/tags/阅读/">阅读</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/03/21/开源项目：PageMenu/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">开源项目：PageMenu</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019/01/28/NSNotificationCenter探索/">
        <span class="next-text nav-default">NSNotificationCenter探索</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
