<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="Objective-C设计指北">




  <meta name="keywords" content="Objective-C,">




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x">



<link rel="canonical" href="http://blog.chenyalun.com/2019/08/22/Objective-C设计指北/">


<meta name="description" content="尝试回答“给你 C 语言，如何实现一个 Objective-C”。">
<meta name="keywords" content="Objective-C">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C设计指北">
<meta property="og:url" content="http://blog.chenyalun.com/2019/08/22/Objective-C设计指北/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="尝试回答“给你 C 语言，如何实现一个 Objective-C”。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image.chenyalun.com/2019/01/28/001.png">
<meta property="og:updated_time" content="2019-10-28T09:09:11.329Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C设计指北">
<meta name="twitter:description" content="尝试回答“给你 C 语言，如何实现一个 Objective-C”。">
<meta name="twitter:image" content="https://image.chenyalun.com/2019/01/28/001.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> Objective-C设计指北 · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Objective-C设计指北
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月22日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、类与对象"><span class="toc-text">一、类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#对象"><span class="toc-text">对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量与属性"><span class="toc-text">成员变量与属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SEL"><span class="toc-text">SEL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IMP"><span class="toc-text">IMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method"><span class="toc-text">Method</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类"><span class="toc-text">类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、协议"><span class="toc-text">二、协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、类扩展与分类"><span class="toc-text">三、类扩展与分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、关联对象"><span class="toc-text">四、关联对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、消息机制"><span class="toc-text">五、消息机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#objc-msgSend"><span class="toc-text">objc_msgSend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息转发"><span class="toc-text">消息转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一阶段"><span class="toc-text">第一阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二阶段"><span class="toc-text">第二阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三阶段"><span class="toc-text">第三阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法缓存"><span class="toc-text">方法缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、block"><span class="toc-text">六、block</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#结构"><span class="toc-text">结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型"><span class="toc-text">类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#捕获变量"><span class="toc-text">捕获变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block"><span class="toc-text">__block</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性修饰"><span class="toc-text">属性修饰</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、小结"><span class="toc-text">七、小结</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p align="center"> 尝试回答“给你 C 语言，如何实现一个 Objective-C”。 </p>

<a id="more"></a>
<p>孙源大神在他的文章中留下了这样一道问题：<a href="https://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-0/" target="_blank" rel="noopener">假如非要让我考一道 Runtime 的题，可能是“给你 C 语言，如何实现一个 Objective-C？</a>”，答到哪儿算哪儿。</p>
<p>这篇文章尝试做一点解答，也整体复习一下Objective-C。</p>
<h1 id="一、类与对象"><a href="#一、类与对象" class="headerlink" title="一、类与对象"></a>一、类与对象</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/// Represents an<span class="built_in"> instance </span>of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAI<span class="class">LABILITY;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Objective-C实例对象的本质是结构体，混沌初开的时候，其内部有且只有一个成员：Class类型的isa。isa是一个指向objc_class结构体的指针，在arm64上占用8个字节，在armv7上占用4个字节（本文都按照64位平台来说的）。一个NSObject对象只有这一个成员变量，理论上也只需要8个字节，但是通过memory read可以知道系统给它分配了16个字节。查看源码发现allocWithZone最终调用到instanceSize()函数时，为了内存对齐，限制了一个对象的最小占用内存为16个字节。同时，这也是为了呼应“操作系统的内存对齐”：给一个对象分配的字节数量为16的倍数。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">    <span class="comment">// 内存对齐之后的大小</span></span><br><span class="line">   size_t <span class="built_in">size</span> = alignedInstanceSize() + extraBytes;</span><br><span class="line">   <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">   <span class="built_in">if</span> (<span class="built_in">size</span> &lt; <span class="number">16</span>) <span class="built_in">size</span> = <span class="number">16</span>;</span><br><span class="line">   <span class="built_in">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在arm64架构之前，isa是一个普通的指针，直接指向类对象或者元类对象的内存地址。从arm64架构开始，isa被优化为一个共用体，使用位域把诸多信息存储在8个字节的方寸之间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;  <span class="comment">// 1表示优化过的isa指针</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;  <span class="comment">// 是否有设置过关联对象</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 是否有C++的析构函数</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// 类对象或者元类对象地址</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;  <span class="comment">// 是否未完成初始化</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;  <span class="comment">// 是否有弱引用指向过</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;  <span class="comment">// 是否正在dealloc</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 引用计数是否过大使得无法存储在isa中，</span></span><br><span class="line">                                          <span class="comment">// 如果是则引用计数存储在SideTable中</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>; <span class="comment">// 里面存储的值是引用计数减去1</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候使用掩码进行按位与运算就可以计算出它的类对象或者元类对象的地址。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">NSObject *obj = [NSObject <span class="keyword">new</span>];</span><br><span class="line"><span class="comment">// (lldb) p/x (long)obj-&gt;isa</span></span><br><span class="line"><span class="comment">// (long) $3 = 0x001dffff9da71141</span></span><br><span class="line">    </span><br><span class="line">Class cls = [NSObject class];</span><br><span class="line"><span class="comment">// (lldb) p/x (long)obj.class</span></span><br><span class="line"><span class="comment">// (long) $5 = 0x00007fff9da71140</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (lldb) p/x (0x001dffff9da71141 &amp; 0x00007ffffffffff8ULL)</span></span><br><span class="line"><span class="comment">// (unsigned long long) $7 = 0x00007fff9da71140</span></span><br></pre></td></tr></table></figure></p>
<p>每个实例对象生而不同，自己的成员变量理所应当地存储在每一个实例对象中，而方法具有唯一性，同一个类实例化的所有的对象应当共享一份对象方法。自然，对象方法应该存储在“类”中，这个“类”，就是类对象。除了对象方法之外还有类方法，就像全局函数，类方法存储在元类对象中。</p>
<h2 id="成员变量与属性"><a href="#成员变量与属性" class="headerlink" title="成员变量与属性"></a>成员变量与属性</h2><p>声明一个YAPerson类，并填充一些成员变量、属性、实例方法和类方法。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAPerson</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    uint age;</span><br><span class="line">    <span class="built_in">NSString</span> *nickname;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">BOOL</span> isRich;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> isMale;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>)singWithSongName:(<span class="built_in">NSString</span> *)songName &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"I'm singing a song named %@"</span>, songName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)canWork &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>创建一个YAPerson实例，它包含了继承自NSObject的成员变量isa和自有的成员变量。它的结构是这样的：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">struct YAPerson_IMPL &#123;</span><br><span class="line">    struct NSObject_IMPL NSObject_IVARS<span class="comment">; // Class isa;</span></span><br><span class="line">    uint age<span class="comment">;</span></span><br><span class="line">    NSString *nickname<span class="comment">;</span></span><br><span class="line">    <span class="keyword">BOOL </span>isRich<span class="comment">;</span></span><br><span class="line">    <span class="keyword">BOOL </span>_isMale<span class="comment">;</span></span><br><span class="line">    NSString *_name<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>迫于结构体内存对齐、系统内存对齐以及一个对象最小16个字节的限制，YAPerson实例占用48个字节。</p>
<p>当创建一个实例对象时，由于消息机制，类方法“new”的调用实际上是被转换为objc_msgSend()函数调用，消息接收者是类对象。而调用实例方法也是通过objc_msgSend()函数，只不过第一个参数是具体的实例对象。这里的字符串<code>@&quot;Love&quot;</code>会被编译器优化为常量字符串，直接取地址使用了。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">jack </span>singWithSongName:@<span class="string">"Love"</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">objc_msgSend(<span class="keyword">jack, </span>sel_registerName(<span class="string">"singWithSongName:"</span>), (NSString *)&amp;__NSConstantStringImpl__var_xxxxxx)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>当对实例对象的属性进行赋值时，点语法会被编译器转化为setter方法，最后还是调用objc_msgSend()函数：<br><code>objc_msgSend(jack, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_xxxxxxxxx);</code></p>
<p>当对实例对象的成员变量赋值时就比较有趣了，<code>jack-&gt;age = 23;</code>，大致是这种效果：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">#define __OFFSETOFIVAR__(<span class="name">TYPE</span>, MEMBER) ((<span class="name">long</span> long) &amp;((<span class="name">TYPE</span> *)0)-&gt;MEMBER)</span><br><span class="line">unsigned long int OBJC_IVAR_$_YAPerson$age = __OFFSETOFIVAR__(struct YAPerson, age);</span><br><span class="line">uint *ageOffset = (<span class="name">uint</span> *)((char *)jack + OBJC_IVAR_$_YAPerson$age)<span class="comment">;</span></span><br><span class="line">(<span class="name">*ageOffset</span>) = <span class="number">23</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>首先通过<code>__OFFSETOFIVAR__</code>宏，获取成员变量age在<code>YAPerson_IMPL</code>结构体中的偏移量：8个字节（isa占用8个字节），并把它存储为<strong>全局的常量</strong>，接着根据实例对象jack的地址加上成员变量age的偏移量获取age的地址，最后对age进行赋值。这些在编译的时候，就已经确定了，也即根本不需要通过<code>jack-&gt;age = 23;</code>这样的指针调用。一个成员变量的结构是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;  <span class="comment">// pointer to ivar offset location</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw; <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">int</span> size; <span class="comment">// 占用字节</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> WORD_SHIFT 3UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> WORD_SHIFT 2UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (alignment_raw == ~(<span class="keyword">uint32_t</span>)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ageIvar = &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$age, <span class="string">"age"</span>, <span class="string">"I"</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>由于偏移量是全局的常量，所以使用<code>int32_t *</code>类型的offset存储这个偏移量的地址，而不是使用<code>int32_t</code>存储这个偏移量的值。name和type描述了成员变量的名称与类型，alignment的值取决于<a href="https://developer.apple.com/documentation/objectivec/1418756-class_addivar?language=objc" target="_blank" rel="noopener">成员变量类型和机器架构</a>，它的最小值为2的n次方。size是该类型变量占用字节。</p>
<p>编译时确定偏移量的原因<a href="http://zhengtingi.cc/2017/03/08/runtime1-ivar/" target="_blank" rel="noopener">是这样</a>：</p>
<blockquote>
<p>In the modern runtime, if you change the layout of instance variables in a class, you do not have to recompile classes that inherit from it.<br>在程序启动后，runtime加载类的时候，通过计算基类的大小，runtime动态调整了类成员变量布局。于是我们的程序无需编译，就能在新版本系统上运行。<br>变量地址 = 对象地址 + ivar.offset<br>ivar.offset = 基类地址(动态) + ivar在本类中的偏移量(编译时固定)</p>
</blockquote>
<p>动态创建一个类，添加成员变量的时候我们会用到这些信息：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">class_addIvar</span>(myClass, <span class="string">"someIvar"</span>, sizeof(int), log2(_Alignof(int)), <span class="variable">@encode</span>(int))</span><br></pre></td></tr></table></figure></p>
<p>这个函数只能用在动态创建类的时候。类一旦定义完毕就无法再（在分类中）添加成员变量，因为“类中成员变量的偏移量是由基类大小和本类中成员变量共同决定的，如果一个类添加了成员变量，size发生了变化，会导致子类无法工作”。</p>
<p>一个类的所有成员变量信息汇聚在一起就成为了成员变量列表<code>struct ivar_list_t</code>，它在内存中只需要一份：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count; <span class="comment">// 数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> <span class="title">ivar_list</span>[6];</span> <span class="comment">// 成员变量数组</span></span><br><span class="line">&#125; _OBJC_$_INSTANCE_VARIABLES_YAPerson = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">ivar_t</span>),</span><br><span class="line">    <span class="number">6</span>,</span><br><span class="line">    &#123;&#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$age, <span class="string">"age"</span>, <span class="string">"I"</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$nickname, <span class="string">"nickname"</span>, <span class="string">"@\"NSString\""</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$isRich, <span class="string">"isRich"</span>, <span class="string">"B"</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$_isMale, <span class="string">"_isMale"</span>, <span class="string">"B"</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$_name, <span class="string">"_name"</span>, <span class="string">"@\"NSString\""</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_YAPerson$_block, <span class="string">"_block"</span>, <span class="string">"@?"</span>, <span class="number">3</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>_OBJC_$_INSTANCE_VARIABLES_YAPerson</code>是YAPerson类的全局的成员变量列表。</p>
<p>对于我们来说，Objective-C中的属性指的就是成员变量与存取器方法。一般地，声明一个属性的时候，编译器会生成一个下划线打头的成员变量，比如<code>@property (nonatomic, copy) NSString *name;</code>会生成成员变量：<code>NSString *_name;</code>。</p>
<p>在语言层面，属性指的是属性的名称与对属性的修饰（类型、原子性、内存策略等）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>name是属性的名称，attributes包含的信息就比较多了，可以通过property_getAttributes()获取，比如YAPerson的name属性，得到的是<code>&quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;</code>，“C”表示copy，“N”表示nonatomic，具体含义<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html" target="_blank" rel="noopener">官方文档</a>说的很详细。</p>
<p>当然，属性列表是所有属性的集合：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> <span class="title">prop_list</span>[3];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_YAPerson = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">property_t</span>),</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    &#123;&#123;<span class="string">"name"</span>,<span class="string">"T@\"NSString\",C,N,V_name"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"isMale"</span>,<span class="string">"TB,R,N,V_isMale"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"block"</span>,<span class="string">"T@?,C,N,V_block"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>_OBJC_$_PROP_LIST_YAPerson</code>是YAPerson类的全局的属性列表。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>设计一个方法需要解决三个问题：方法名、方法实现以及方法的参数类型和返回值类型。</p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>表征方法名的selector是SEL类型：<code>typedef struct objc_selector *SEL;</code>，也即“Defines an opaque type that represents a method selector”。关于它的解释目前主要有两种看法：<br>一、有人根据Runtime源码中的定义和官方文档认为它是指向objc_selector结构体的指针，但是objc_selector结构体的具体实现并没有开源。<br>二、有人说它就是C语言中的字符串常量<code>const char *</code>类型，理由是Runtime源码中sel_getName()的函数实现表明了<code>SEL</code>类型可以直接转换为<code>const char *</code>类型，而且“对于字符串的比较仅仅需要比较他们的地址就可以”，在各种查找中速度更快。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">sel_getName</span><span class="params">(SEL sel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) <span class="keyword">return</span> <span class="string">"&lt;null selector&gt;"</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">const</span> <span class="keyword">char</span> *)(<span class="keyword">const</span> <span class="keyword">void</span>*)sel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我觉得这两种看法可以结合一下，SEL是指向objc_selector结构体的指针，objc_selector的实现应该是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[];</span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    objc_selector(<span class="keyword">char</span> name[]) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1.从结果上看，可以满足直接转换为<code>const char *</code>类型：str的值就是“new”。从本质上看，指向结构体的指针就是指向结构体第一个成员（name数组）的指针。<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建结构体</span></span><br><span class="line">objc_selector selector = &#123;<span class="string">"new"</span>&#125;;</span><br><span class="line"><span class="comment">// p为指向结构体的指针</span></span><br><span class="line">objc_selector *p = &amp;selector;</span><br><span class="line"><span class="comment">// 将 p 强制转化为 const char * 类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> *<span class="built_in">str</span> = (<span class="keyword">const</span> <span class="built_in">char</span> *)p;</span><br><span class="line"><span class="comment">// 实际上str与结构体中的name是等价的</span></span><br><span class="line"><span class="built_in">bool</span> res = (<span class="built_in">str</span> == p-&gt;name);</span><br></pre></td></tr></table></figure></p>
<p>2.与SEL的内存表现是一致的。需要根据方法名的长度，创建相应长度的name数组。比如“new”方法，占用4个字节：<code>6e 65 77 00</code>。</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">objc_selector selector = &#123;"new"&#125;;</span><br><span class="line">objc_selector *p = &amp;selector;</span><br><span class="line">SEL sel = @selector(new);</span><br><span class="line">   </span><br><span class="line">(lldb) x p</span><br><span class="line">0x16f825c78: 6e<span class="number"> 65 </span>77<span class="number"> 00 </span>01<span class="number"> 00 </span>00<span class="number"> 00 </span>a0<span class="number"> 85 </span>c0<span class="number"> 00 </span>01<span class="number"> 00 </span>00<span class="number"> 00 </span> new.............</span><br><span class="line">(lldb) x sel</span><br><span class="line">0x1fc67fc8f: 6e<span class="number"> 65 </span>77<span class="number"> 00 </span>69<span class="number"> 73 </span>61<span class="number"> 00 </span>63 6f 6e<span class="number"> 66 </span>6f<span class="number"> 72 </span>6d<span class="number"> 73 </span> new.isa.conforms</span><br></pre></td></tr></table></figure>
<p>看源码不难得知，相同名称对应的selector在内存中只有一个，存储在NXMapTable中。也就是说通过<code>@selector()</code>语法糖、<code>sel_registerName()</code>函数、<code>NSSelectorFromString()</code>函数，都是从NXMapTable中取出selector。如果这个名称对应的selector已经注册在Runtime（存储在NXMapTable）中，直接返回，如果没有注册，才会进行创建。不同指针变量指向同一个结构体，这也解释了为啥可以使用<code>==</code>运算符比较。</p>
<p>最后一个问题，为什么表征方法名的selector要设计成结构体而不是直接使用<code>const char *</code>？</p>
<blockquote>
<p>When using selectors, you must use the value returned from sel_registerName or the Objective-C compiler directive @selector(). You cannot simply cast a C string to SEL.</p>
</blockquote>
<p>苹果希望我们使用诸如sel_registerName()这些转化函数，就是想让方法名与selector建立映射，同时把selector纳入管理。而不是像这样：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SEL </span><span class="keyword">sel </span>= (<span class="keyword">SEL)"show";</span></span><br><span class="line"><span class="keyword">[view </span>performSelector:<span class="keyword">sel];</span></span><br></pre></td></tr></table></figure>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>对于一般的函数来说，函数名也是指向函数实现的指针。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于func函数，<code>func()</code>是通过函数名调用，<code>(*func)()</code>是通过指向函数的指针调用。在Objective-C中，IMP就是指向函数的指针。</p>
<p>标准的IMP定义是这样的：<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef id (*<span class="type">IMP</span>)(id, <span class="type">SEL</span>, ...);</span><br></pre></td></tr></table></figure></p>
<p>在实际使用时，需要根据具体的参数、返回值重新定义：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> *(*_IMP)(<span class="keyword">id</span> ,SEL, ...);</span><br><span class="line">SEL sel = <span class="keyword">@selector</span>(description);</span><br><span class="line"><span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">_IMP imp = (_IMP)class_getMethodImplementation(obj.class, sel);</span><br><span class="line"><span class="keyword">if</span> (imp) &#123;</span><br><span class="line">    <span class="comment">// 函数名调用</span></span><br><span class="line">    <span class="built_in">NSString</span> *desc1 = imp(obj, sel);</span><br><span class="line">    <span class="comment">// 函数指针调用</span></span><br><span class="line">    <span class="built_in">NSString</span> *desc2 = (*imp)(obj, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>为了简便地描述类型、修饰符，字符串形式的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">类型编码</a>产生了。<code>const char *type = @encode(int)</code>在编译时便返回了字符串常量“i”，用来表明这是int类型。但是有一些像<code>const</code>、<code>inout</code>等方法参数的修饰符无法通过@encode()获取。对于方法来说，<code>const char *method_getTypeEncoding(Method m)</code>函数可以直接返回方法完整的Type Encode。这里的Method是集成了方法名SEL、函数指针、类型编码的结构体指针。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">typedef struct method_t *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line">struct method_t <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    SEL name;</span></span><br><span class="line"><span class="comment">    const char *types;</span></span><br><span class="line"><span class="comment">    IMP imp;</span></span><br><span class="line"><span class="comment">&#125;</span>;</span><br></pre></td></tr></table></figure>
<p>实例方法存放在类对象之中，这样，类对象的方法列表就产生了：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="keyword">struct</span> method_t method_list[<span class="number">6</span>];</span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_YAPerson = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(method_t),</span><br><span class="line">    <span class="number">6</span>,</span><br><span class="line">    &#123;&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"singWithSongName:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_YAPerson_singWithSongName_&#125;,</span><br><span class="line">    &#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"name"</span>, <span class="string">"@16@0:8"</span>, (<span class="keyword">void</span> *)_I_YAPerson_name&#125;,</span><br><span class="line">    &#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"setName:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_YAPerson_setName_&#125;,</span><br><span class="line">    &#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"isMale"</span>, <span class="string">"B16@0:8"</span>, (<span class="keyword">void</span> *)_I_YAPerson_isMale&#125;,</span><br><span class="line">    &#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"block"</span>, <span class="string">"@?16@0:8"</span>, (<span class="keyword">void</span> *)_I_YAPerson_block&#125;,</span><br><span class="line">    &#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"setBlock:"</span>, <span class="string">"v24@0:8@?16"</span>, (<span class="keyword">void</span> *)_I_YAPerson_setBlock_&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>类方法保存在元类对象之中，对于YAPerson，只有一个类方法<code>canWork</code>，其方法列表是这样：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span>  &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CLASS_METHODS_YAPerson = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">method_t</span>),</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    &#123;&#123;(struct objc_selector *)<span class="string">"canWork"</span>, <span class="string">"B16@0:8"</span>, (<span class="keyword">void</span> *)_C_YAPerson_canWork&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>成员变量列表、属性列表、实例方法列表、类方法列表都已经有了，那么一个类的结构也就出来了。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>class、meta-class、root meta-class的本质都是objc_class结构体，且都是以单例的形式表现在内存中。objc_class继承自objc_object，它的cache存储着缓存的方法列表，bits中的一些位存储着指向class_rw_t的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="comment">//  baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line">    <span class="comment">// methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容</span></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// bits &amp; FAST_DATA_MASK可以获取class_rw_t</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>YAPerson类对象的结构是这样的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="comment">//  baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList; <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols; <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars; <span class="comment">// 成员变量列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout; </span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties; <span class="comment">// 属性列表</span></span><br><span class="line">&#125; _OBJC_CLASS_RO_$_YAPerson = &#123;</span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    <span class="comment">// 计算 YAPerson 中的第一个成员变量在结构体中的偏移量</span></span><br><span class="line">    __OFFSETOFIVAR__(struct YAPerson, age),</span><br><span class="line">    <span class="keyword">sizeof</span>(struct YAPerson_IMPL),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="string">"YAPerson"</span>,</span><br><span class="line">    (<span class="keyword">method_list_t</span> *)&amp;_OBJC_$_INSTANCE_METHODS_YAPerson,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">ivar_list_t</span> *)&amp;_OBJC_$_INSTANCE_VARIABLES_YAPerson,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">property_list_t</span> *)&amp;_OBJC_$_PROP_LIST_YAPerson,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>元类对象与类对象的结构是相同的，就YAPerson而言，主要存储了类方法列表，内容是这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span></span> _OBJC_METACLASS_RO_$_YAPerson = &#123;</span><br><span class="line">    <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">class_t</span></span>), <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">class_t</span></span>),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="string">"YAPerson"</span>,</span><br><span class="line">    (<span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span></span> *)&amp;_OBJC_$_CLASS_METHODS_YAPerson,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二、协议"><a href="#二、协议" class="headerlink" title="二、协议"></a>二、协议</h1><p>协议规定了协议遵守者需要实现的方法。如果在协议中声明一个属性，实际上相当于在协议中添加了该属性对应的存取器方法声明。对于协议遵守者，一般来说，需要合成该属性对应的成员变量：<code>@synthesize 属性名;</code>。<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@class</span> YAStudent;</span><br><span class="line"><span class="variable">@protocol</span> YAStudentProtocol &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@required</span></span><br><span class="line"><span class="comment">// 实例属性</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) BOOL isExcellent;</span><br><span class="line"><span class="comment">// 类属性</span></span><br><span class="line"><span class="variable">@property</span> (class, nonatomic, copy) NSString *protocolName;</span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">isSame</span><span class="selector-pseudo">:(YAStudent</span> *)<span class="selector-tag">person</span>;</span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line">+ (NSString *)<span class="selector-tag">description</span>;</span><br><span class="line">@<span class="selector-tag">optional</span></span><br><span class="line"><span class="comment">// 可选的实例属性</span></span><br><span class="line">@<span class="selector-tag">property</span> (readonly, copy) <span class="selector-tag">NSString</span> *<span class="selector-tag">debugDescription</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure></p>
<p>上面声明的协议的对应的结构是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_t</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span> <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *instanceMethods; <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *classMethods; <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalInstanceMethods; <span class="comment">// 可选的实例方法列表</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalClassMethods; <span class="comment">// 可选的类方法列表</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *instanceProperties; <span class="comment">// 实例属性列表</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **_extendedMethodTypes;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName;</span><br><span class="line">    <span class="keyword">property_list_t</span> *_classProperties; <span class="comment">// 类属性列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为C++后</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">protocol_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * isa;  <span class="comment">// NULL</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_name; <span class="comment">// 协议名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> * <span class="title">protocol_list</span>;</span> <span class="comment">// super protocols</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span> <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span> <span class="comment">//类方法列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">optionalInstanceMethods</span>;</span> <span class="comment">// 可选的实例方法列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">optionalClassMethods</span>;</span> <span class="comment">// 可选的类方法列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> * <span class="title">properties</span>;</span> <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> size;  <span class="comment">// sizeof(struct _protocol_t)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;  <span class="comment">// = 0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> ** extendedMethodTypes; <span class="comment">// 方法type</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="string">"YAStudentProtocol"</span>,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_protocol_list_t</span> *)&amp;_OBJC_PROTOCOL_REFS_YAStudentProtocol,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">method_list_t</span> *)&amp;_OBJC_PROTOCOL_INSTANCE_METHODS_YAStudentProtocol,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">method_list_t</span> *)&amp;_OBJC_PROTOCOL_CLASS_METHODS_YAStudentProtocol,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">method_list_t</span> *)&amp;_OBJC_PROTOCOL_OPT_INSTANCE_METHODS_YAStudentProtocol,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_PROTOCOL_PROPERTIES_YAStudentProtocol,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">_protocol_t</span>),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">char</span> **)&amp;_OBJC_PROTOCOL_METHOD_TYPES_YAStudentProtocol</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，协议主要存储了方法。协议的方法列表和类对象中的方法列表结构是一样的，但是有一点，协议方法列表中的方法Method没有具体实现IMP。也容易理解，毕竟协议只能提供方法名、方法参数和返回值。那么有没有可能为协议添加方法实现呢？有。因为，协议继承自objc_object，所以协议也是一个实例对象。当获取它的superclass时，发现就是NSObject。<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">Protocol *<span class="keyword">pro</span> = objc_getProtocol(<span class="string">"YAStudentProtocol"</span>);</span><br><span class="line"></span><br><span class="line">(lldb) po [<span class="keyword">pro</span> <span class="keyword">class</span>]</span><br><span class="line">Protocol</span><br><span class="line">(lldb) po [<span class="keyword">pro</span> superclass]</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure></p>
<p>那么，把它当做一个普通对象即可：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Method me = class_getInstanceMethod(YAStudent.class, <span class="keyword">@selector</span>(show));</span><br><span class="line">IMP imp = method_getImplementation(me);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *type = method_getTypeEncoding(me);</span><br><span class="line"><span class="built_in">BOOL</span> success = class_addMethod(<span class="built_in">NSClassFromString</span>(<span class="string">@"Protocol"</span>), <span class="keyword">@selector</span>(show), imp, type);</span><br><span class="line"><span class="keyword">if</span> (success) &#123;</span><br><span class="line">   <span class="comment">// "创建"一个叫"YAStudentProtocol"的协议对象, 它的class是Protocol, 它的superclass是NSObject</span></span><br><span class="line">   Protocol *pro = objc_getProtocol(<span class="string">"YAStudentProtocol"</span>);</span><br><span class="line">   <span class="comment">// 调用协议对象的show方法</span></span><br><span class="line">   <span class="built_in">NSString</span> *result = [(<span class="keyword">id</span>)pro performSelector:<span class="keyword">@selector</span>(show)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然这么做意义并不是很大，但是脑洞再大一点，有没有可能只要遵守一个协议，那么就拥有了协议中的方法声明和方法实现呢？有。ProtocolKit解决了这个问题。</p>
<h1 id="三、类扩展与分类"><a href="#三、类扩展与分类" class="headerlink" title="三、类扩展与分类"></a>三、类扩展与分类</h1><p>类扩展和分类都可以给已有的类添加功能，不同的是类扩展是编译时合并到类中，分类是在运行时合并到类中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 主类的名称</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls; <span class="comment">// 类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span> <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span> <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span> <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span> <span class="comment">// 实例属性列表</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span> <span class="comment">// 类属性列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每创建一个分类时，都会产生一个_category_t结构体：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_YAStudent_</span>$_<span class="title">HighSchoolStudent</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>根据源码，分类中的属性、方法、协议等信息，合并到主类中的过程是这样的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Attach method lists and properties and protocols from categories to a class.</span></span><br><span class="line"><span class="comment">// Assumes the categories in cats are all loaded and sorted by load order, </span></span><br><span class="line"><span class="comment">// oldest categories first.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attachCategories</span><span class="params">(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证不为空</span></span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// "log methods replaced by category implementations"</span></span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是元类对象</span></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储空间分配 fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>; <span class="comment">// 方法数量</span></span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>; <span class="comment">// 属性数量</span></span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>; <span class="comment">// 协议数量</span></span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count; <span class="comment">// 分类数量</span></span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="comment">// 取出分类列表中的最后一个分类</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法列表</span></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取属性列表</span></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取协议列表</span></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    <span class="built_in">free</span>(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches &amp;&amp; mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="built_in">free</span>(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    <span class="built_in">free</span>(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，分类信息是按照分类列表的逆序逐个进行合并，分类列表的顺序是由加载顺序确定的。方法、属性、协议数组等，都是二维数组，一维对应着分类，二维对应着每条信息。</p>
<p>附加过程是这样的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">       <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">       <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">       <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">       <span class="comment">// 重新分配newCount的内存</span></span><br><span class="line">       setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">       <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">       <span class="comment">// 把addedLists放到老数据的前面, 形成新的array()-&gt;lists</span></span><br><span class="line">       memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">               oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">       <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">              addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">       <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">       List* oldList = <span class="built_in">list</span>;</span><br><span class="line">       <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">       setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">       <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">       <span class="comment">// 把oldList放到addedLists的后面</span></span><br><span class="line">       <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">       <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">              addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>各种情况都有考虑，但是目的只有一个：把addedLists插入到原有数据的前面。这也解释了为什么分类中的方法与主类中的方法同名时，实际上会调用分类的。表面上看是“覆盖”，实际上方法都是存在的，只不过一旦在方法列表中找到需要调用的方法，就不再往下找了。</p>
<h1 id="四、关联对象"><a href="#四、关联对象" class="headerlink" title="四、关联对象"></a>四、关联对象</h1><p>由于内存布局在类定义后就已经固定，所有没有办法在分类中添加成员变量，但是相似的场景还是有的，这就需要用到关联对象。</p>
<p>设置关联对象的逻辑是这样的：<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>set<span class="number">_</span>associative<span class="number">_</span>reference(id <span class="keyword">object</span>, <span class="keyword">void</span> *key, id <span class="keyword">value</span>, uintptr<span class="number">_</span>t policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old<span class="number">_</span>association(<span class="number">0</span>, nil);</span><br><span class="line">    <span class="comment">// 如果修饰策略是OBJC_ASSOCIATION_SETTER_RETAIN, 则new_value = [value retain]</span></span><br><span class="line">    <span class="comment">// 如果修饰策略是OBJC_ASSOCIATION_SETTER_COPY, 则new_value = [value copy]</span></span><br><span class="line">    id <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span> = <span class="keyword">value</span> ? acquireValue(<span class="keyword">value</span>, policy) : nil;</span><br><span class="line"></span><br><span class="line">    AssociationsManager manager;</span><br><span class="line">    <span class="comment">// 获取哈希表(AssociationsHashMap)的引用: associations</span></span><br><span class="line">    AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">    <span class="comment">// 获取object的"按位取反值"</span></span><br><span class="line">    unsigned long disguised<span class="number">_</span><span class="keyword">object</span> = DISGUISE(<span class="keyword">object</span>); <span class="comment">// ~(unsigned long)(object)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据object的"按位取反值"作为key, 查找对应的iterator, 如未查找到，返回end()</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised<span class="number">_</span><span class="keyword">object</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123; <span class="comment">// object已经设置过关联对象, 则需要更新key对应的对象</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123; <span class="comment">// 找到key对应的对象, 获取旧的对象, 设置新的对象</span></span><br><span class="line">                old<span class="number">_</span>association = j-&gt;second;</span><br><span class="line">                j-&gt;second = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有找到key对应的对象, 这是一个新的key</span></span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明在AssociationsHashMap中, object目前还没有对应的ObjectAssociationMap, 也即是第一次设置关联对象, 则创建ObjectAssociationMap</span></span><br><span class="line">            ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">            <span class="comment">// 存储refs</span></span><br><span class="line">            associations[disguised<span class="number">_</span><span class="keyword">object</span>] = refs;</span><br><span class="line">            <span class="comment">// 在ref中存储关联策略和new_value</span></span><br><span class="line">            (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            <span class="comment">// 标明当前类具有关联类, 它会将isa中的has_assoc标记为true</span></span><br><span class="line">            <span class="keyword">object</span>-&gt;setHasAssociatedObjects();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// value为空, 说明是要删除原先的关联引用(一般也是这么用的, 而不是使用remove)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找对应的iterator</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised<span class="number">_</span><span class="keyword">object</span>);</span><br><span class="line">        <span class="keyword">if</span> (i !=  associations.end()) &#123; <span class="comment">// 说明是有值的</span></span><br><span class="line">            <span class="comment">// 获取值(first是键, second是值): ObjectAssociationMap</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="comment">// 根据参数key, 获取在refs中对应的iterator</span></span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                <span class="comment">// 获取旧值</span></span><br><span class="line">                old<span class="number">_</span>association = j-&gt;second;</span><br><span class="line">                <span class="comment">// 把参数key对应的对象擦除</span></span><br><span class="line">                refs-&gt;erase(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果旧的关联对象不为空, 就把它release.  release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old<span class="number">_</span>association.hasValue()) ReleaseValue()(old<span class="number">_</span>association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取关联对象的逻辑是这样的：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">id _object_get_associative_reference(<span class="name">id</span> object, void *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    AssociationsManager manager;</span><br><span class="line">    // 获取AssociationsHashMap</span><br><span class="line">    AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">    disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">    AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">    if (i != associations.end()) &#123;</span><br><span class="line">        // 找到ObjectAssociationMap</span><br><span class="line">        ObjectAssociationMap *refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">        ObjectAssociationMap:<span class="symbol">:iterator</span> j = refs-&gt;find(<span class="name">key</span>)<span class="comment">;</span></span><br><span class="line">        if (<span class="name">j</span> != refs-&gt;end()) &#123;</span><br><span class="line">            // 再找到ObjcAssociation</span><br><span class="line">            ObjcAssociation <span class="symbol">&amp;entry</span> = j-&gt;second<span class="comment">;</span></span><br><span class="line">            // 取出关联对象和关联策略</span><br><span class="line">            value = entry.value()<span class="comment">;</span></span><br><span class="line">            policy = entry.policy()<span class="comment">;</span></span><br><span class="line">            // 策略是retain的话, 获取[value retain]</span><br><span class="line">            if (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((<span class="name">id</span>(<span class="name">*</span>)(<span class="name">id</span>, SEL))objc_msgSend)(<span class="name">value</span>, SEL_retain)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (<span class="name">value</span> <span class="symbol">&amp;&amp;</span> (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        // 策略是autorelease的话, 获取[value autorelease]</span><br><span class="line">        ((<span class="name">id</span>(<span class="name">*</span>)(<span class="name">id</span>, SEL))objc_msgSend)(<span class="name">value</span>, SEL_autorelease)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return value<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整体来看是比较简单的，有同学画了<a href="https://www.neroxie.com/2019/07/23/从源码理解关联属性/" target="_blank" rel="noopener">一幅图</a>，很清晰地说明了存储层次：<br><img src="https://image.chenyalun.com/2019/01/28/001.png" style="zoom:80%"></p>
<p>关联对象的存储与类的存储没有关系。全局的AssociationsHashMap存储着所有对象与关联对象的映射关系，并由AssociationsManager管理。在AssociationsHashMap中，每个对象的“按位取反值”作为键，每个对象对应的ObjectAssociationMap作为值。在ObjectAssociationMap中，参数key作为键，关联的对象被包装成ObjcAssociation并作为值存储。</p>
<p>实际使用时，一般把getter方法的selector作为key，避免了新变量的产生；在移除关联对象时，常常使用objc_setAssociatedObject()函数，传入空的object，而不是使用objc_removeAssociatedObjects()函数直接把所有的关联对象都给移除。</p>
<p>一个对象在销毁之前，会自动移除它所有的关联对象。利用这个特性，可以实现不hook dealloc方法而在<a href="http://www.tanhao.me/pieces/160626.html/" target="_blank" rel="noopener">一个对象生命周期结束的时候触发一个操作</a>。简单地说，就是利用一个中间对象，让它保存需要执行的操作，在其dealloc时执行操作。而把这个中间对象（或者保存中间对象的数组，亦或者是block）作为分类的关联属性，也算是一种思路吧。</p>
<p>最后就是很有意思的weak关联属性，这个在<a href="https://blog.chenyalun.com/2019/01/20/Weak%20Associated%20Object/">《Weak Associated Object》</a>一文中专门做了思考与说明，巧妙地利用现成的weak关键字和block即可轻松实现。</p>
<h1 id="五、消息机制"><a href="#五、消息机制" class="headerlink" title="五、消息机制"></a>五、消息机制</h1><p>Objective-C中的实例方法调用和类方法调用都是基于消息机制的，通过发送消息而不是直接的函数调用使得这个语言非常具有动态性，这也是很有意思的。</p>
<p>假定YAStudent继承自YAPerson，YAPerson继承自NSObject。</p>
<p>以YAStudent为模板创建出一个student实例，它的实例方法大致是这么调用的：首先会先通过isa找到YAStudent的类对象，在类对象的方法列表找到目标方法，没有找到的话再通过superclass找到YAPerson的类对象，再在其方法列表中查找，没有找到的话再通过superclass找到NSObject的类对象，看是否能在其方法列表中找到并调用。</p>
<p>YAStudent的类方法大致是这么调用的：会先通过isa找到YAStudent的元类对象，在其方法列表中查找目标方法，如果没有找到再通过superclass找到YAPerson的元类对象，如果还没有找到就再通过superclass找到NSObject的元类对象，还是没有找到的话<strong>最后再通过isa找到NSObject类对象</strong>，看是否能在其方法列表中找到并调用。</p>
<p>实例对象的isa指向类对象，类对象的isa指向元类对象，元类对象的isa指向根元类，根元类的isa指向它自己。类对象的superclass指针指向父类的类对象，元类对象的superclass指针指向父类的元类对象，<strong>根元类的superclass指针指向根类（NSObject）</strong>。</p>
<p>由于根元类的superclass指针指向根类，这就解释了<code>[NSObject show];</code>这样明明是类方法调用却成功变成了调用NSObject的show实例方法。<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> NSObject (YAShow)</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> NSObject (YAShow)</span><br><span class="line">- (void)show &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"- (void)show"</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure></p>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><p>编译器会将方法的调用转换为objc_msgSend、objc_msgSend_stret、objc_msgSendSuper和objc_msgSendSuper_stret。</p>
<blockquote>
<p>发送给对象的父类的消息会使用 objc_msgSendSuper;<br>有数据结构作为返回值的方法会使用 objc_msgSendSuper_stret 或 objc_msgSend_stret;<br>其它的消息都是使用 objc_msgSend 发送的。</p>
</blockquote>
<p>objc_msgSend的具体实现由汇编语言编写而成，原因有两个：</p>
<ol>
<li><p>一个C++函数不可能调用任意的函数指针，它可以重载、有可变参数，但是不可能有可变的返回值。</p>
</li>
<li><p>通过使用汇编，可以免去大量局部变量拷贝的操作，参数会直接被存放在寄存器中，当找到IMP时，参数已经保存在了寄存器中，可以直接使用，速度更快。</p>
</li>
</ol>
<p>第一条的解释是这样的，假定objc_msgSend是使用C++实现，那么从语法层面它需要做到能接收可变参数、返回值类型可以任意。比如返回值类型可以是<code>NSUInteger</code>也可以是<code>id</code>：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">NSUInteger n = [<span class="keyword">array</span> count];</span><br><span class="line">id obj = [<span class="keyword">array</span> objectAtIndex:<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化后</span></span><br><span class="line">NSUInteger n = (NSUInteger <span class="comment">(*)(id, SEL))objc_msgSend(array,  @selector(count));</span></span><br><span class="line"><span class="comment">id obj = (id (*)</span>(id, SEL, NSUInteger))objc_msgSend(<span class="keyword">array</span>, @<span class="keyword">selector</span>(objectAtIndex:), <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>可变参数可以做到，任意返回值类型貌似可以利用重载，但是仅仅返回值类型不同无法构成重载：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译通不过</span></span><br><span class="line"><span class="built_in">NSUInteger</span> objc_msgSend(<span class="keyword">id</span>, SEL, ...) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span>, SEL, ...) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而且就算这两条都做到了，也没有办法支撑无穷无尽的任意函数指针—不可能把所有函数指针一一穷举。</p>
<blockquote>
<p>objc_msgSend的解决办法，主要依据的是：当objc_msgSend被调用时，所有的参数已经被设置好了。<br>换一种方式来说，就是：在objc_msgSend开始执行时，栈帧（stack frame）的状态、数据，和各个寄存器的组合形式、数据，跟调用具体的函数指针（IMP）时所需的状态、数据，是完全一致的！</p>
</blockquote>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line">	MESSENGER_START</span><br><span class="line"></span><br><span class="line">	cmp	<span class="keyword">x</span><span class="number">0</span>, <span class="symbol">#0</span>			// 消息接收者为空，返回<span class="number">0</span></span><br><span class="line">	b.le	LNilOrTagged		//  (MSB tagged pointer looks negative)</span><br><span class="line">	ldr	<span class="keyword">x</span><span class="number">13</span>, [<span class="keyword">x</span><span class="number">0</span>]		// <span class="keyword">x</span><span class="number">13</span> = isa</span><br><span class="line">	<span class="keyword">and</span>	<span class="keyword">x</span><span class="number">16</span>, <span class="keyword">x</span><span class="number">13</span>, #ISA_MASK	// <span class="keyword">x</span><span class="number">16</span> = class	</span><br><span class="line">LGetIsaDone:</span><br><span class="line">	CacheLookup NORMAL		// calls imp <span class="keyword">or</span> objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">LNilOrTagged:</span><br><span class="line">	b.<span class="keyword">eq</span>	LReturnZero		// nil check</span><br><span class="line"></span><br><span class="line">	// tagged</span><br><span class="line">	mov	<span class="keyword">x</span><span class="number">10</span>, <span class="symbol">#0</span>xf<span class="number">000000000000000</span></span><br><span class="line">	cmp	<span class="keyword">x</span><span class="number">0</span>, <span class="keyword">x</span><span class="number">10</span></span><br><span class="line">	b.hs	LExtTag</span><br><span class="line">	adrp	<span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_classes<span class="title">@PAGE</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_classes<span class="title">@PAGEOFF</span></span><br><span class="line">	ubfx	<span class="keyword">x</span><span class="number">11</span>, <span class="keyword">x</span><span class="number">0</span>, <span class="symbol">#60</span>, <span class="symbol">#4</span></span><br><span class="line">	ldr	<span class="keyword">x</span><span class="number">16</span>, [<span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">11</span>, LSL <span class="symbol">#3</span>]</span><br><span class="line">	b	LGetIsaDone</span><br><span class="line"></span><br><span class="line">LExtTag:</span><br><span class="line">	// ext tagged</span><br><span class="line">	adrp	<span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_ext_classes<span class="title">@PAGE</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_ext_classes<span class="title">@PAGEOFF</span></span><br><span class="line">	ubfx	<span class="keyword">x</span><span class="number">11</span>, <span class="keyword">x</span><span class="number">0</span>, <span class="symbol">#52</span>, <span class="symbol">#8</span></span><br><span class="line">	ldr	<span class="keyword">x</span><span class="number">16</span>, [<span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">11</span>, LSL <span class="symbol">#3</span>]</span><br><span class="line">	b	LGetIsaDone</span><br><span class="line">	</span><br><span class="line">LReturnZero:</span><br><span class="line">	// <span class="keyword">x</span><span class="number">0</span> is already zero</span><br><span class="line">	mov	<span class="keyword">x</span><span class="number">1</span>, <span class="symbol">#0</span></span><br><span class="line">	movi	d<span class="number">0</span>, <span class="symbol">#0</span></span><br><span class="line">	movi	d<span class="number">1</span>, <span class="symbol">#0</span></span><br><span class="line">	movi	d<span class="number">2</span>, <span class="symbol">#0</span></span><br><span class="line">	movi	d<span class="number">3</span>, <span class="symbol">#0</span></span><br><span class="line">	MESSENGER_END_NIL</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>当一个方法没有相应的实现时，就会进入消息转发机制，在这套流程中，可以动态增加方法实现。</p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p><strong>在动态方法解析中可以直接添加上函数实现。</strong><br>比如调用YAPerson的instanceShow实例方法，当判断出这个selector是<code>instanceShow</code>的时候，在<code>resolveInstanceMethod</code>方法中为<code>instanceShow</code>实例方法添加上函数实现<code>instanceFunc</code>。而对于classShow类方法，在<code>resolveClassMethod</code>方法中为classShow方法添加上函数实现<code>classFunc</code>。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">instanceFunc</span>(id self, SEL _cmd) &#123;</span><br><span class="line">   <span class="selector-tag">NSLog</span>(@<span class="string">"%@, %p"</span>, self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)<span class="selector-tag">resolveInstanceMethod</span><span class="selector-pseudo">:(SEL)sel</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (sel_isEqual(sel, <span class="variable">@selector</span>(instanceShow))) &#123;</span><br><span class="line">        <span class="comment">// 添加关于类对象的sel实现</span></span><br><span class="line">        <span class="selector-tag">class_addMethod</span>(self.class, sel, (IMP)instanceFunc, <span class="string">"@:"</span>);</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[super resolveInstanceMethod:sel]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">classFunc</span>(id self, SEL _cmd) &#123;</span><br><span class="line">   <span class="selector-tag">NSLog</span>(@<span class="string">"%@, %p"</span>, self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)<span class="selector-tag">resolveClassMethod</span><span class="selector-pseudo">:(SEL)sel</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (sel_isEqual(sel, <span class="variable">@selector</span>(classShow))) &#123;</span><br><span class="line">         <span class="comment">// 添加关于元类对象的sel实现</span></span><br><span class="line">         <span class="selector-tag">class_addMethod</span>(object_getClass(self), sel, (IMP)classFunc, <span class="string">"@:"</span>);</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[super resolveClassMethod:sel]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预先把函数实现都写好了，再通过class_addMethod()把实现添加到方法中，那何不如直接完整地把方法实现写了，比如上面的例子，直接把instanceShow实例方法和classShow类方法完整地写出来不就行了？何必多此一举。</p>
<p>实际上，这一阶段常是配合<code>@dynamic</code>来使用。<a href="http://www.peerassembly.com/blog/using-dynamic-properties-to-access-nsuserdefaults.html" target="_blank" rel="noopener">peerassembly</a>举了一个还不错的例子：<br>假定需要通过Preferences接管NSUserDefaults，由它提供各个key的存取接口，那一般需要这么做：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Preferences </span>: NSObject &#123;</span><br><span class="line">    <span class="selector-tag">NSUserDefaults</span> *<span class="selector-tag">_defaults</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (Preferences *)<span class="selector-tag">sharedInstance</span>;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">property</span> (nonatomic, assign) <span class="selector-tag">BOOL</span> <span class="selector-tag">autoStartBreak</span>;</span><br><span class="line"><span class="comment">// ... 还有好多属性</span></span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">implementation</span> <span class="selector-tag">Preferences</span></span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">autoStartBreak</span> &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[_defaults boolForKey:@"autoStartBreak"]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setAutoStartBreak</span><span class="selector-pseudo">:(BOOL)autoStartBreak</span> &#123;</span><br><span class="line">    <span class="selector-attr">[_defaults setBool:autoStartBreak forKey:@"autoStartBreak"]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 写好多好多</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>需要对每一个属性都写上存取方法的实现，如果有20个属性，岂不是要写40个方法？</p>
<p>要是借助<code>resolveInstanceMethod()</code>，就可以这么办：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Preferences</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> autoStartBreak;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> iaFromSmartApp;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isDarkMode;</span><br><span class="line"><span class="comment">// ... 还有好多属性</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *_dynamicProperties;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Preferences</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> autoStartBreak, iaFromSmartApp, isDarkMode;</span><br><span class="line"><span class="built_in">BOOL</span> paprefBoolGetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    PAPropertyDescriptor *propertyDescriptor = _dynamicProperties[selectorString];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSUserDefaults</span>.standardUserDefaults boolForKey:propertyDescriptor.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> paprefBoolSetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">BOOL</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    PAPropertyDescriptor *propertyDescriptor = _dynamicProperties[selectorString];</span><br><span class="line">    [<span class="built_in">NSUserDefaults</span>.standardUserDefaults setBool:value forKey:propertyDescriptor.name];</span><br><span class="line">    [<span class="built_in">NSUserDefaults</span>.standardUserDefaults synchronize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    PAPropertyDescriptor *propertyDescriptor = [PAPropertyDescriptor new];</span><br><span class="line">    <span class="keyword">if</span> ([selectorString hasPrefix:<span class="string">@"set"</span>]) &#123; <span class="comment">// setAutoStartBreak --&gt;autoStartBreak</span></span><br><span class="line">        <span class="built_in">NSString</span> *first = [selectorString substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">3</span>, <span class="number">1</span>)];</span><br><span class="line">        <span class="built_in">NSString</span> *prop = [selectorString substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">4</span>, selectorString.length - <span class="number">5</span>)];</span><br><span class="line">        propertyDescriptor.name = [first.lowercaseString stringByAppendingString:prop];</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>.class, sel, (IMP)paprefBoolSetter, <span class="string">"v@:B"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        propertyDescriptor.name = selectorString;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>.class, sel, (IMP)paprefBoolGetter, <span class="string">"B@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_dynamicProperties[selectorString]) &#123;</span><br><span class="line">        _dynamicProperties[selectorString] = propertyDescriptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>通过建立映射，把所以存取器都统一纳入管理，更清晰高效。上面的只是一个示例，还要考虑许多问题，比如支持不同类型的属性、替换默认的方法实现等，这个作者已经写了一个完整的组件，可参考<a href="https://github.com/dhennessy/PAPreferences/blob/master/PAPreferences/PAPreferences.m" target="_blank" rel="noopener">PAPreferences</a>。</p>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p><strong>将消息转发给其他target。</strong><br>第一阶段中无法及时添加上相应的方法实现，就会进入第二阶段，我们可以在这里把消息转发给其他对象处理。如果是实例方法，需要实现<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>，如果是类方法，则需要实现<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>。</p>
<p>假定YAPerson的instanceShow实例方法没有具体的实现，而YASinger却是有的，那可以把消息转发给YASinger实例对象，交由它处理：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (id)<span class="string">forwardingTargetForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [YASinger <span class="keyword">new</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假定YADancer有classShow类方法的实现，那可以把消息转发给YADancer类对象：<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line"><span class="built_in">    return</span> YADancer.<span class="built_in">class</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上，把YAPerson的消息转发给其他对象（实例对象或者类对象）之后，其他对象就会开启新一轮的消息解析，它如果没有对应的方法实现，同样会开启这三个阶段。因此，其他对象不一定要完完整整地具备YAPerson所缺省的方法实现。</p>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p><strong>完整的消息转发。</strong><br>如若前两个阶段都没办法妥善地处理，就会进入消息解析的第三阶段。在这个阶段中，使用<code>forwardInvocation</code>配合<code>methodSignatureForSelector</code>对消息做最后一步的处理。</p>
<p>首先会解析methodSignatureForSelector，只有当它返回的方法签名不为空时，才会进入forwardInvocation流程中，因此我们对该方法重写并返回一个不为空的signature。<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>aSelector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([YAMethodHelper <span class="string">instancesRespondToSelector:</span>aSelector]) &#123;</span><br><span class="line">            signature = [YAMethodHelper <span class="string">instanceMethodSignatureForSelector:</span>aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着在forwardInvocation中获取创建的NSInvocation对象，调用selector即可：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">if</span> ([YAMethodHelper <span class="string">instancesRespondToSelector:</span>anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation <span class="string">invokeWithTarget:</span>_helper];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是很传统的处理步骤，实际上只要保证methodSignatureForSelector返回一个不为空的方法签名，可以在forwardInvocation中对NSInvocation对象做肆意更改。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">      <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">           signature = [<span class="built_in">NSObject</span> instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(<span class="keyword">class</span>)];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="comment">// 调用NSObject对象的description方法</span></span><br><span class="line">    anInvocation.selector = <span class="keyword">@selector</span>(description);</span><br><span class="line">    [anInvocation invokeWithTarget:[<span class="built_in">NSObject</span> new]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，前提是这么做有意义。</p>
<p>其实在这一阶段还可以实现<a href="http://kittenyang.com/forwardinvocation/" target="_blank" rel="noopener">伪多继承</a>：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *first = [(<span class="built_in">NSObject</span> *)<span class="keyword">self</span>.firstDelegate methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *second = [(<span class="built_in">NSObject</span> *)<span class="keyword">self</span>.secondDelegate methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (first)&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(second) &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    SEL aSelector = [anInvocation selector];</span><br><span class="line">    <span class="keyword">if</span>([<span class="keyword">self</span>.firstDelegate respondsToSelector:aSelector])&#123;</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.firstDelegate];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>([<span class="keyword">self</span>.secondDelegate respondsToSelector:aSelector])&#123;</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.secondDelegate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span>([<span class="keyword">self</span>.firstDelegate respondsToSelector:aSelector] || [<span class="keyword">self</span>.secondDelegate respondsToSelector:aSelector])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>
</blockquote>
<h2 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h2><p>为了加快方法查找速度，方法缓存产生了。调用过的方法会被缓存起来，如果方法是属于父类的，也会把方法缓存在自己的cache中。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets; <span class="comment">// 散列表，指向bucket_t结构体数组的指针</span></span><br><span class="line">    mask_t _mask; <span class="comment">// 散列表长度减1</span></span><br><span class="line">    mask_t _occupied; <span class="comment">// 已经缓存的方法数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *buckets();</span><br><span class="line">    <span class="function">mask_t <span class="title">mask</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">mask_t <span class="title">occupied</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incrementOccupied</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBucketsAndMask</span>(<span class="params"><span class="keyword">struct</span> bucket_t *newBuckets, mask_t newMask</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeToEmpty</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">mask_t <span class="title">capacity</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConstantEmptyCache</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeFreed</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">bytesForCapacity</span>(<span class="params">uint32_t cap</span>)</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">struct</span> bucket_t * endMarker(<span class="keyword">struct</span> bucket_t *b, uint32_t cap);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span>(<span class="params">mask_t oldCapacity, mask_t newCapacity</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t * find(cache_key_t key, id receiver);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bad_cache</span>(<span class="params">id receiver, SEL sel, Class isa</span>) __<span class="title">attribute__</span>(<span class="params">(noreturn</span>))</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> cache_key_t <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> IMP <span class="title">imp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (IMP)_imp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(<span class="keyword">cache_key_t</span> newKey)</span> </span>&#123; _key = newKey; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setImp</span><span class="params">(IMP newImp)</span> </span>&#123; _imp = newImp; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">cache_key_t</span> newKey, IMP newImp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法查找过程：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Selector转换为cache_key_t（unsigned long类型）</span></span><br><span class="line"><span class="keyword">cache_key_t</span> getKey(SEL sel) &#123;</span><br><span class="line">    assert(sel);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">cache_key_t</span>)sel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bucket_t</span> *<span class="keyword">cache_t</span>::find(<span class="keyword">cache_key_t</span> k, id receiver) &#123;</span><br><span class="line">    assert(k != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *b = _buckets;</span><br><span class="line">    <span class="keyword">mask_t</span> m = _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> begin = (<span class="keyword">mask_t</span>)(k &amp; m);</span><br><span class="line">    <span class="keyword">mask_t</span> i = begin;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i].key() == <span class="number">0</span>  ||  b[i].key() == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i = ((i+<span class="number">1</span>) &amp; m)) != begin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hack</span></span><br><span class="line">    Class cls = (Class)((<span class="keyword">uintptr_t</span>)<span class="keyword">this</span> - offsetof(objc_class, cache));</span><br><span class="line">    <span class="keyword">cache_t</span>::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>散列表的索引通过<code>index = selector &amp; _mask</code>获得。</p>
<h1 id="六、block"><a href="#六、block" class="headerlink" title="六、block"></a>六、block</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>block的本质是<code>__main_block_impl_0</code>结构体，它拥有isa指针，是一个封装了函数调用以及函数调用环境的Objective-C对象。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数实现以及isa</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些描述信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">size_t</span> reserved; </span><br><span class="line">    <span class="comment">// block大小</span></span><br><span class="line">    <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义一个block时，会调用<code>__main_block_impl_0</code>的构造函数，主要是把需要执行的函数地址赋值给FuncPtr指针。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数调用的第一个参数是指向block自己的指针，之后的才是自定义的参数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, <span class="keyword">int</span> age, <span class="keyword">double</span> <span class="built_in">height</span>) &#123;</span><br><span class="line">    <span class="comment">// block做的事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用block也即执行FuncPtr函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个int型参数、一个double型参数</span></span><br><span class="line"><span class="keyword">void</span> (*myBlock)(<span class="keyword">int</span>, <span class="keyword">double</span>) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">myBlock-&gt;FuncPtr(myBlock, <span class="number">22</span>, <span class="number">175.3</span>);</span><br></pre></td></tr></table></figure>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>从代码段（text区）、数据段（data区）、堆区再到栈区，内存地址逐渐增高。block有三种类型，分别分布在数据段、栈区和堆区。</p>
<p>没有访问auto变量的block是Global类型，继承关系链为：<code>__NSGlobalBlock__</code>，<code>__NSGlobalBlock</code>，<code>NSBlock</code>，<code>NSObject</code>。比如：<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^(<span class="built_in">void</span>) &#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>访问了auto变量的block是Stack类型，继承关系链为：<code>__NSStackBlock__</code>，<code>__NSStackBlock</code>，<code>NSBlock</code>，<code>NSObject</code>。比如：<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^(<span class="built_in">void</span>) &#123;</span><br><span class="line">   <span class="type">NSLog</span>(@<span class="string">"名字是:%d"</span>, age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当<code>__main_block_impl_0</code>的构造函数调用完毕，栈上的该结构体变量销毁，那取出该结构体的指针，再访问数据就不会是正确的数据了。这时候为了保证访问数据的正确性，需要把block放到堆空间，手动管理该结构体变量的生命周期。</p>
<p>Global类型的block调用copy方法后，它依然是Global类型。Stack类型的block调用copy方法后，就成为Malloc类型，继承关系链为：<code>__NSMallocBlock__</code>，<code>__NSMallocBlock</code>，<code>NSBlock</code>，<code>NSObject</code>。比如：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = [^(<span class="keyword">void</span>) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"名字是:%d"</span>, age);</span><br><span class="line">&#125; <span class="keyword">copy</span>];</span><br></pre></td></tr></table></figure></p>
<p>而Malloc类型的block调用copy方法后，引用计数增加1。</p>
<p>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况，block作为函数返回值时、将block赋值给<code>__strong</code>指针时、block作为Cocoa API中方法名含有usingBlock的方法参数时、block作为GCD API的方法参数时。</p>
<h2 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h2><p>一般来说，当block捕获外界的auto变量时，该变量会作为block对象的一个成员变量存储，是值传递；<br>当block捕获外界的static变量（非全局变量）时，block对象会增加一个存储该static变量的指针的成员变量，是指针传递；<br>对于全局变量（无论是否static修饰），block会直接访问，不进行捕获。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="built_in">NSString</span> *globalName = <span class="string">@"globalName"</span>;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *staticName = <span class="string">@"staticName"</span>;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">NSString</span> *autoName = <span class="string">@"autoName"</span>;</span><br><span class="line">    <span class="keyword">void</span> (^myBlock)(<span class="keyword">int</span>, <span class="keyword">double</span>) = ^(<span class="keyword">int</span> age, <span class="keyword">double</span> height) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"globalName: %@, staticName: %@, autoName: %@,"</span>, globalName, staticName, autoName);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"年龄是:%d, 身高是:%f"</span>, age, height);</span><br><span class="line">    &#125;;</span><br><span class="line">    myBlock(<span class="number">22</span>, <span class="number">175.3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 结构如下</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">    <span class="built_in">NSString</span> **staticName;</span><br><span class="line">    <span class="built_in">NSString</span> *autoName;</span><br><span class="line">    <span class="comment">// 初始化列表中对autoName和staticName赋值</span></span><br><span class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="built_in">NSString</span> **_staticName, <span class="built_in">NSString</span> *_autoName, <span class="keyword">int</span> flags=<span class="number">0</span>) : staticName(_staticName), autoName(_autoName) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>特殊地，self作为隐式参数，是<strong>局部变量</strong>，所以block访问时会进行捕获。而对于直接访问某个对象的成员变量，比如：<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^(<span class="built_in">void</span>) &#123; <span class="type">NSLog</span>(@<span class="string">"名字是:%@"</span>, _name); &#125;;</span><br></pre></td></tr></table></figure></p>
<p>实际上是首先访问self，接着访问self的成员变量<code>_name</code>，因此，也会对self进行捕获。</p>
<p>尤其需要说明的是，对于一般的auto变量来说，捕获基本数据类型的自动变量的方式是const copy。而当block内部访问了对象类型的auto变量时，如果block是在栈上，将不会对auto变量产生强引用。如果block被拷贝到堆上，会调用block内部的copy函数，copy函数内部会调用<code>_Block_object_assign</code>函数，<code>_Block_object_assign</code>函数会根据auto变量的修饰符<code>（__strong、__weak、__unsafe_unretained）</code>做出相应的操作，形成强引用（retain）或者弱引用。如果block从堆上移除，会调用block内部的dispose函数，dispose函数内部会调用<code>_Block_object_dispose</code>函数，<code>_Block_object_dispose</code>函数会自动释放引用的auto变量（release）。</p>
<h2 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h2><p>对于<code>__block</code>修饰的auto变量（含基本数据类型和对象类型），block捕获时会将该变量包装成新的对象：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">__block <span class="keyword">int</span> age = <span class="number">22</span>;</span><br><span class="line">__block <span class="built_in">NSObject</span> *strongObj = obj;</span><br><span class="line">__block __<span class="keyword">weak</span> <span class="built_in">NSObject</span> *weakObj = obj;</span><br><span class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">   age = <span class="number">23</span>;</span><br><span class="line">   strongObj = <span class="literal">nil</span>;</span><br><span class="line">   weakObj = <span class="literal">nil</span>;</span><br><span class="line">&#125;;</span><br><span class="line">myBlock();</span><br><span class="line"><span class="comment">// 再次访问</span></span><br><span class="line">strongObj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">age = <span class="number">24</span>;</span><br></pre></td></tr></table></figure></p>
<p>实际上是这样：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把age包装成新的对象</span></span><br><span class="line">struct <span class="variable">__Block_byref_age_0</span> &#123;</span><br><span class="line">    void *<span class="variable">__isa</span>;</span><br><span class="line">    <span class="variable">__Block_byref_age_0</span> *<span class="variable">__forwarding</span>;</span><br><span class="line">    int <span class="variable">__flags</span>;</span><br><span class="line">    int <span class="variable">__size</span>;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把strong修饰的strongObj包装成新的对象</span></span><br><span class="line">struct <span class="variable">__Block_byref_strongObj_1</span> &#123;</span><br><span class="line">    void *<span class="variable">__isa</span>;</span><br><span class="line">    <span class="variable">__Block_byref_strongObj_1</span> *<span class="variable">__forwarding</span>;</span><br><span class="line">    int <span class="variable">__flags</span>;</span><br><span class="line">    int <span class="variable">__size</span>;</span><br><span class="line">    void (*<span class="variable">__Block_byref_id_object_copy</span>)(void*, void*);</span><br><span class="line">    void (*<span class="variable">__Block_byref_id_object_dispose</span>)(void*);</span><br><span class="line">    NSObject *<span class="variable">__strong</span> strongObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把weak修饰的weakObj包装成新的对象</span></span><br><span class="line">struct <span class="variable">__Block_byref_weakObj_2</span> &#123;</span><br><span class="line">    void *<span class="variable">__isa</span>;</span><br><span class="line">    <span class="variable">__Block_byref_weakObj_2</span> *<span class="variable">__forwarding</span>;</span><br><span class="line">    int <span class="variable">__flags</span>;</span><br><span class="line">    int <span class="variable">__size</span>;</span><br><span class="line">    void (*<span class="variable">__Block_byref_id_object_copy</span>)(void*, void*);</span><br><span class="line">    void (*<span class="variable">__Block_byref_id_object_dispose</span>)(void*);</span><br><span class="line">    NSObject *<span class="variable">__weak</span> weakObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block的结构</span></span><br><span class="line">struct <span class="variable">__main_block_impl_0</span> &#123;</span><br><span class="line">    struct <span class="variable">__block_impl</span> impl;</span><br><span class="line">    struct <span class="variable">__main_block_desc_0</span>* Desc;</span><br><span class="line">    <span class="variable">__Block_byref_age_0</span> *age; <span class="comment">// by ref</span></span><br><span class="line">    <span class="variable">__Block_byref_strongObj_1</span> *strongObj; <span class="comment">// by ref</span></span><br><span class="line">    <span class="variable">__Block_byref_weakObj_2</span> *weakObj; <span class="comment">// by ref</span></span><br><span class="line">    <span class="variable">__main_block_impl_0</span>(void *fp, </span><br><span class="line">        struct <span class="variable">__main_block_desc_0</span> *desc, </span><br><span class="line">        <span class="variable">__Block_byref_age_0</span> *<span class="variable">_age</span>, </span><br><span class="line">        <span class="variable">__Block_byref_strongObj_1</span> *<span class="variable">_strongObj</span>, </span><br><span class="line">        <span class="variable">__Block_byref_weakObj_2</span> *<span class="variable">_weakObj</span>, int flags=<span class="number">0</span>) </span><br><span class="line">        : age(<span class="variable">_age</span>-&gt;<span class="variable">__forwarding</span>), strongObj(<span class="variable">_strongObj</span>-&gt;<span class="variable">__forwarding</span>), weakObj(<span class="variable">_weakObj</span>-&gt;<span class="variable">__forwarding</span>) &#123; <span class="comment">// 初始化列表</span></span><br><span class="line">        impl.isa = &amp;<span class="variable">_NSConcreteStackBlock</span>;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而从这一刻开始，再访问该auto变量（age、strongObj、weakObj），实质上是访问包装成新的对象内部的同名变量（原先的变量已经不存在了）。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">__block <span class="keyword">int</span> age = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">   age = <span class="number">23</span>;</span><br><span class="line">&#125;;</span><br><span class="line">myBlock();</span><br><span class="line">age = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行类型转换</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 *block_imp = (__bridge <span class="keyword">struct</span> __main_block_impl_0 *)(myBlock);</span><br><span class="line"><span class="keyword">struct</span> __Block_byref_age_0 *age_imp = block_imp-&gt;age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">(lldb) p/x &amp;age</span><br><span class="line">(<span class="keyword">int</span> *) $<span class="number">3</span> = <span class="number">0x00000001006207d8</span></span><br><span class="line">(lldb) p/x &amp;(age_imp-&gt;age)</span><br><span class="line">(<span class="keyword">int</span> *) $<span class="number">2</span> = <span class="number">0x00000001006207d8</span></span><br></pre></td></tr></table></figure>
<p>利用类型转换，打印变量age的地址与结构体age_imp中的age成员的地址，发现是一致的，也印证了这一点：<code>__block</code>修饰的age就是“不可见”的新结构体内部的age。</p>
<p>这个“被包装的新的对象”的内存管理也需要考虑，当block在栈上时，并不会对这个“新的对象”产生强引用。当block被copy到堆时，会对“新的对象”产生强引用。对于基本数据类型的包装并不需要赘述，而对于对象类型的包装倒值得一提。“新的对象”内部的strongObj以及weakObj的修饰策略很清晰地表明了它对原来对象内存管理的立场：原来是strong，包装后依然是strong；原来是weak，包装后依然是weak。</p>
<p>对于<code>__block</code>修饰的变量进行装箱也很容易理解，倘若考虑把被修改的auto变量的指针传递给block，这样似乎也能达到修改变量的效果，但是不应该忘记，被修改的auto变量的生命周期是不确定的，假如这个变量很快就销毁，过了很久block才得到执行，这时再去通过指针是无法访问到这个变量的，这种访问方式也很危险。而包装成一个新的对象后，这个对象的生命周期就随着block了，block无论在栈上还是在堆上，都没有关系。</p>
<h2 id="属性修饰"><a href="#属性修饰" class="headerlink" title="属性修饰"></a>属性修饰</h2><p>一般来说，只有当栈上的block作为方法的参数时，需要我们手动调用block的copy方法，将栈上的block复制到堆上，以避免坏内存问题。在ARC时代，如果block作为属性，无论是copy修饰还是strong修饰都是可以的。对于getter方法，由于block是作为方法的返回值，则它会自动被copy到堆空间，不需要我们关心。对于setter方法，block是作为方法的参数，如果是copy修饰，栈上的block自然会被调用copy方法而被复制到堆空间。如果是strong修饰，那么当把栈上的block赋值给 <code>__strong id</code>类型的对象，也是会被调用copy方法复制到堆空间的。<br>即便如此，还是推荐使用copy修饰，这样能时刻提醒我们这个block将来会被安全地copy到堆空间上。但是，如果是使用<code>weak</code>、<code>assign</code>、<code>unsafe_unretained</code>这些另类的修饰符修饰block，那很轻而易举地就会出问题了。</p>
<h1 id="七、小结"><a href="#七、小结" class="headerlink" title="七、小结"></a>七、小结</h1><p>halfrost同学概括了与Runtime有关的应用大概是这些，也是比较全面了。</p>
<ol>
<li>实现多继承（消息转发）</li>
<li>Method Swizzling</li>
<li>Aspect Oriented Programming（比如打点）</li>
<li>Isa Swizzling（KVO的动态派生）</li>
<li>Associated Object关联对象</li>
<li>动态地增加方法</li>
<li>NSCoding的自动归档和自动解档</li>
<li>字典和模型互相转换（KVC也可，利用IMP也行）</li>
</ol>
<p>这篇文章主要总结了Objective-C“对象”相关的基础知识，最后还提了一下这门语言特有的block。不知道有没有把开头的那道问题回答好（捂脸），写了好久，会经常回顾并完善。</p>
<blockquote>
<p>参考感谢：<br><a href="http://southpeak.github.io/2014/11/03/objective-c-runtime-3/" target="_blank" rel="noopener">《方法与消息》</a><br><a href="https://lpd-ios.github.io/2017/12/19/ObjC-Message/" target="_blank" rel="noopener">《用代码理解 ObjC 中的发送消息和消息转发》</a><br><a href="https://halfrost.com/how_to_use_runtime/" target="_blank" rel="noopener">《如何正确使用 Runtime》</a><br><a href="https://zhongwuzw.github.io/2018/04/21/iOS知识小集之为什么objc-msgSend-是用汇编实现的/" target="_blank" rel="noopener">《为什么objc_msgSend()是用汇编实现的》</a><br><a href="https://amywushu.github.io/2016/11/09/逆向知识-通过汇编解读-objc_msgSend.html" target="_blank" rel="noopener">《通过汇编解读-objc_msgSend》</a></p>
</blockquote>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Objective-C/">Objective-C</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/09/11/iOS中的Crash防护/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">iOS中的Crash防护</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019/08/07/开源项目：YAPageView/">
        <span class="next-text nav-default">开源项目：YAPageView</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
