<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="开源项目：YAPageView">




  <meta name="keywords" content="iOS开发,开源项目,">




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x">



<link rel="canonical" href="http://blog.chenyalun.com/2019/08/07/开源项目：YAPageView/">


<meta name="description" content="轻量级、新样式轮播视图。">
<meta name="keywords" content="iOS开发,开源项目">
<meta property="og:type" content="article">
<meta property="og:title" content="开源项目：YAPageView">
<meta property="og:url" content="http://blog.chenyalun.com/2019/08/07/开源项目：YAPageView/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="轻量级、新样式轮播视图。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image.chenyalun.com/2019/08/07/003.gif">
<meta property="og:image" content="https://image.chenyalun.com/2019/08/07/002.gif">
<meta property="og:image" content="https://image.chenyalun.com/2019/08/07/001.gif">
<meta property="og:updated_time" content="2019-10-27T05:55:20.871Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="开源项目：YAPageView">
<meta name="twitter:description" content="轻量级、新样式轮播视图。">
<meta name="twitter:image" content="https://image.chenyalun.com/2019/08/07/003.gif">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> 开源项目：YAPageView · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          开源项目：YAPageView
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月7日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、前言"><span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、思路"><span class="toc-text">二、思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#间距处理"><span class="toc-text">间距处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无限循环处理"><span class="toc-text">无限循环处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#点击事件处理"><span class="toc-text">点击事件处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自动轮播处理"><span class="toc-text">自动轮播处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定时器循环引用处理"><span class="toc-text">定时器循环引用处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#点击回调循环引用处理"><span class="toc-text">点击回调循环引用处理</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#三、使用"><span class="toc-text">三、使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#本地图片"><span class="toc-text">本地图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#网络图片"><span class="toc-text">网络图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置自动轮播时间"><span class="toc-text">设置自动轮播时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置点击回调"><span class="toc-text">设置点击回调</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、总结"><span class="toc-text">四、总结</span></a></li>
    </div>
  </div>


    <div class="post-content">
      
        <p></p><p align="center"> 轻量级、新样式轮播视图。 </p><br><a id="more"></a><p></p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在拜读<a href="http://adad184.com/" target="_blank" rel="noopener">里脊串的开发随笔</a>大神的博客时，发现个好玩的东西：<a href="http://adad184.com/2015/07/01/opensource-xxpagingscrollview/" target="_blank" rel="noopener">《开源项目:XXPagingScrollView》</a>。虽然是很常见的轮播视图，但是这种新样式的实现思路挺有意思。记得两年前在写某个项目时也遇到过这个，但是当然确实没有想出来咋实现这种非全屏有间隙的轮播控件。</p>
<p>读完大神的文章，很是兴奋，一般是不爱造重复的轮子，但是作者这个是<a href="https://github.com/adad184/XXPagingScrollView/blob/master/Classes/XXPagingScrollView.swift" target="_blank" rel="noopener">Swift版本</a>的，而且是基础组件，少了很多功能，所以心血来潮，在大神基础上再进一步。</p>
<p>相比较来说更加完善了：</p>
<ul>
<li>支持设置pagingWidth</li>
<li>支持设置pageInset</li>
<li>支持无限循环轮播</li>
<li>支持本地图片</li>
<li>支持网络图片</li>
<li>支持自动轮播、设置轮播时间间隔</li>
<li>支持点击回调</li>
</ul>
<p>整体代码约150行左右，更加精简。<br><img src="https://image.chenyalun.com/2019/08/07/003.gif"><br>项目地址:<a href="https://github.com/ChenYalun/YAPageView" target="_blank" rel="noopener">https://github.com/ChenYalun/YAPageView</a></p>
<h1 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h1><p>实际上轮播视图是烂大街的东西了，网上现成代码特别多。一般而言，假定需要n个页面，实现方式有：</p>
<ol>
<li>使用<code>UIScrollView</code>，添加 n 个<code>UIImageView</code>。</li>
<li>使用<code>UIScrollView</code>，添加两个<code>UIImageView</code>，动态循环调整。</li>
<li>使用<code>UICollectionView</code>。</li>
</ol>
<p>方法1比较基础，更适合非循环；方法3比较简单，但是<code>UICollectionView</code>过于heavily。<br>方法2，很精简轻量，就是处理起来有点绕。然而，绕一次，换来永久的舒适，很值得。</p>
<p>如何实现自定义<code>Page width</code>的视图，作者给出的方案是：</p>
<blockquote>
<p>方案1: 不使用<code>pagingEnabled</code>属性 而是手动的计算并设置滑动偏移<br>方案2: 使用<code>pagingEnabled</code>属性 扩大<code>UIScrollview</code>的显示范围即可</p>
</blockquote>
<p>很明显，方案2更好。思路是，扩大<code>UIScrollView</code>的可显示范围并让UIScrollView响应超出其本身范围的触摸事件。思路知道了，实现起来很简单，就是<code>clipsToBounds</code>属性和<code>pointInside</code>方法。</p>
<h4 id="间距处理"><a href="#间距处理" class="headerlink" title="间距处理"></a>间距处理</h4><p>核心有三条：</p>
<ol>
<li><code>UIScrollView</code>的宽度就是<code>pageWidth + pageInset</code>。</li>
<li>为了保持左右显示区域的对称性，<code>UIScrollView</code>的<code>x</code>是<code>(superView.width - pageWidth) * 0.5</code>。</li>
<li>子视图的frame是<code>CGRectMake(idx * (pageWidth + pageInset), 0, pageWidth, height)</code>，也即，子视图的宽度与<code>UIScrollView</code>的宽度保持一致。</li>
</ol>
<h4 id="无限循环处理"><a href="#无限循环处理" class="headerlink" title="无限循环处理"></a>无限循环处理</h4><ol>
<li>视图循环利用<br>使用三个<code>UIImageView</code>，记为左、中、右，重复利用。默认显示中间的imageView。</li>
<li>刷新逻辑<br>在<code>scrollViewDidScroll</code>回调中，当<code>UIScrollView</code>即将显示出下一个（可能是左、也可能是右）视图时，立即调用刷新方法。刷新的逻辑是：</li>
</ol>
<ul>
<li><p>重新计算left、currentIndex、right三个索引</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kLeft (_currentIndex == 0 ? kCount - 1 : _currentIndex - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kRight (_currentIndex == kCount - 1 ? 0 : _currentIndex + 1)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对左、中、右三个<code>UIImageView</code>重新设置配图</p>
  <figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">self.pageArray<span class="string">[0]</span>.image = self.imageArray<span class="string">[kLeft]</span>;</span><br><span class="line">self.pageArray<span class="string">[1]</span>.image = self.imageArray<span class="string">[_currentIndex]</span>;</span><br><span class="line">self.pageArray<span class="string">[2]</span>.image = self.imageArray<span class="string">[kRight]</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以非动画方式设置<code>UIScrollView</code>的偏移量</p>
  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> x = <span class="keyword">self</span>.scrollView.contentOffset.x;</span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="keyword">self</span>.pageWidth + <span class="keyword">self</span>.pageInset;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">   x = width;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   x += x &gt; width ? -width : width;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.scrollView setContentOffset:<span class="built_in">CGPointMake</span>(x, <span class="number">0</span>)];</span><br></pre></td></tr></table></figure>
<p>  这样便实现了无限循环。</p>
</li>
</ul>
<ol start="3">
<li><p>刷新时机处理<br><code>scrollViewDidScroll</code>会回调很多次，本来以为使用一个标志位就可以控制只刷新一次，但是并没有实现😂 所以，退一步，用了两个标志位：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> leftLock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> rightLock;</span><br></pre></td></tr></table></figure>
<p>逻辑是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Turn left.</span></span><br><span class="line"><span class="keyword">if</span> (offsetX &gt; <span class="number">2</span> * (width - <span class="keyword">self</span>.pageInset)) <span class="keyword">self</span>.rightLock = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">self</span>.leftLock &amp;&amp; offsetX &lt; width - <span class="number">2</span> * <span class="keyword">self</span>.pageInset) &#123;</span><br><span class="line">    <span class="keyword">self</span>.leftLock = <span class="literal">YES</span>;</span><br><span class="line">    _currentIndex = kLeft;</span><br><span class="line">    [<span class="keyword">self</span> refresh];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Turn right.</span></span><br><span class="line"><span class="keyword">if</span> (offsetX &lt; <span class="number">2</span> * <span class="keyword">self</span>.pageInset) <span class="keyword">self</span>.leftLock = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">self</span>.rightLock &amp;&amp; offsetX &gt; width + <span class="number">2</span> * <span class="keyword">self</span>.pageInset) &#123;</span><br><span class="line">    <span class="keyword">self</span>.rightLock = <span class="literal">YES</span>;</span><br><span class="line">    _currentIndex = kRight;</span><br><span class="line">    [<span class="keyword">self</span> refresh];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 请牢记<code>UIScrollView</code>的宽度width是<code>width=pageWidth+pageInset</code>，这里以即将显示右边视图为例：<br> scrollView的初始偏移量是<code>width</code>，逐渐偏移，直到越过空白间距(pageInset)要显示下一个视图时，此时offsetX为<code>width + (pageWidth - pageInset)</code>，也即代码中的<code>2 * (width - pageInset)</code>，立即将offsetX还原为<code>2 * (width - pageInset) - (width)</code>也就是<code>pageWidth-pageInset</code>，对leftLock加锁，更新当前索引。</p>
</li>
</ol>
<h4 id="点击事件处理"><a href="#点击事件处理" class="headerlink" title="点击事件处理"></a>点击事件处理</h4><p>对<code>UIScrollView</code>添加点击手势，计算出当前点击位置在图片数组中的索引即可：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> pointX = [tap locationInView:tap.view].x;</span><br><span class="line"><span class="built_in">NSUInteger</span> idx = _currentIndex;</span><br><span class="line"><span class="keyword">if</span> (pointX &lt; <span class="keyword">self</span>.pageWidth + <span class="keyword">self</span>.pageInset) &#123;</span><br><span class="line">   idx = kLeft;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pointX &gt; <span class="number">2</span> * <span class="keyword">self</span>.pageWidth + <span class="keyword">self</span>.pageInset) &#123;</span><br><span class="line">   idx = kRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="自动轮播处理"><a href="#自动轮播处理" class="headerlink" title="自动轮播处理"></a>自动轮播处理</h4><p>当设置<code>timeInterval</code>属性时，说明需要自动轮播，懒加载创建定时器：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">_timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:_timeInterval repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> *timer) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.scrollView setContentOffset:<span class="built_in">CGPointMake</span>(<span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.scrollView.frame) * <span class="number">2</span>, <span class="number">0</span>) animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>并把定时器放到<code>currentRunLoop</code>中，设置<code>NSRunLoopCommonModes</code>。当然，需要在ScrollView的一些代理中处理用户手动滑动与定时器设置的滑动的冲突。</p>
<h4 id="定时器循环引用处理"><a href="#定时器循环引用处理" class="headerlink" title="定时器循环引用处理"></a>定时器循环引用处理</h4><p>解决方式是，当PageView从父视图上移除时，手动销毁定时器：<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">- (void)willMoveToSuperview:<span class="type"></span>(UIView *)<span class="keyword">new</span><span class="type">Superview</span> &#123;</span><br><span class="line">    [<span class="keyword">super</span> willMoveToSuperview:<span class="type">newSuperview</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Superview</span> == nil) &#123; <span class="comment">// 视图从父视图移除时, 销毁定时器</span></span><br><span class="line">        [_timer invalidate];</span><br><span class="line">        _timer = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="点击回调循环引用处理"><a href="#点击回调循环引用处理" class="headerlink" title="点击回调循环引用处理"></a>点击回调循环引用处理</h4><p>点击事件给出的接口我选择使用block，（使用弱引用的代理就不会有这个问题了，但是代理会增加调用的复杂性，设置代理、遵守协议、实现方法巴拉巴拉。。。）</p>
<p>然而，同许多视图的block回调一样，会有循环引用的问题，只能这样使用：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">pageView.tapHandler = ^(<span class="built_in">NSUInteger</span> idx, <span class="built_in">UIImage</span> *img, <span class="built_in">NSURL</span> *url) &#123;</span><br><span class="line">   __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) <span class="keyword">self</span> = weakSelf;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"self = %@, index = %lu, url = %@"</span>, <span class="keyword">self</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)idx, url);</span><br><span class="line">   <span class="comment">/// ....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>万一调用方忘了呢，那就内存泄漏了。</p>
<p>大神<a href="https://yulingtianxia.com/blog/2015/11/13/Summary-of-the-first-month-in-the-internship-of-Tencent/" target="_blank" rel="noopener">玉令天下</a>的方式是使用弱引用的变量持有外界的调用者，然后在适当时机将组件“自己”置为空。不过需要给调用者写个分类（属性）持有组件，还需要明确切断循环引用的时机，对于我的这个100来行的PageView，可能有点不太合适。</p>
<p>突然脑洞一开，想到一个方法，显式让使用方传进来调用者，重新定义外界的<code>self</code>，将其作为一个回调参数传递给使用方（PageView内部使用weak持有外界的<code>self</code>）。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^tapHandler)(<span class="built_in">NSUInteger</span> idx, <span class="built_in">UIImage</span> *img, <span class="built_in">NSURL</span> *url, <span class="keyword">id</span> <span class="keyword">self</span>);</span><br></pre></td></tr></table></figure>
<p>外界使用的时候像这样：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">pageView.tapHandler = ^(<span class="built_in">NSUInteger</span> idx, <span class="built_in">UIImage</span> *img, <span class="built_in">NSURL</span> *url, <span class="built_in">UIViewController</span> *<span class="keyword">self</span>) &#123;</span><br><span class="line">   [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>确实能解决循环引用，而且不是很费事。但是，实际使用的时候是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">pageView.tapHandler = ^(<span class="built_in">NSUInteger</span> idx, <span class="built_in">UIImage</span> *img, <span class="built_in">NSURL</span> *url, <span class="keyword">id</span> controller) &#123;</span><br><span class="line">   <span class="comment">// 需要手动把id类型改成实际的类型，如UIViewController、UIView等等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>并不知道外界的<code>self</code>是啥类型，只能用<code>id</code>。我感觉也不是很巧妙。所以，还是使用苹果推荐的主流的weak-strong吧。</p>
<h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><h4 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h4><p>本地图片直接传入UIImage数组即可。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定构造器，设定pageWidth、pageInset等</span></span><br><span class="line">YAPageView *pageView = [[YAPageView alloc] <span class="string">initWithFrame:</span>CGRectMake(<span class="number">0</span>, <span class="number">200</span>, kScreenWidth, <span class="number">200</span>) <span class="string">controller:</span>self <span class="string">pageWidth:</span><span class="number">300</span> <span class="string">pageInset:</span><span class="number">20</span>];</span><br><span class="line">pageView.imageArray = @[</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"1"</span>],</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"2"</span>],</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"3"</span>],</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"4"</span>],</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"5"</span>],</span><br><span class="line">    [UIImage <span class="string">imageNamed:</span>@<span class="string">"6"</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h4 id="网络图片"><a href="#网络图片" class="headerlink" title="网络图片"></a>网络图片</h4><p>网络图片传入图片URL数组，并设置处理图片的block。这个block指的是给UIImageView设置图片URL的方式。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果使用SDWebImage，可以这么设置</span></span><br><span class="line">pageView.configImageHandler = ^(<span class="built_in">UIImageView</span> *imageView, <span class="built_in">NSURL</span> *url) &#123;</span><br><span class="line">   [imageView sd_setImageWithURL:url];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pageView.imageURLArray = @[</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/230/350/200"</span>],</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/231/350/200"</span>],</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/232/350/200"</span>],</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/233/350/200"</span>],</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/234/350/200"</span>],</span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://picsum.photos/id/235/350/200"</span>]</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h4 id="设置自动轮播时间"><a href="#设置自动轮播时间" class="headerlink" title="设置自动轮播时间"></a>设置自动轮播时间</h4><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">pageView.timeInterval = <span class="number">3</span>.f<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="设置点击回调"><a href="#设置点击回调" class="headerlink" title="设置点击回调"></a>设置点击回调</h4><p>别忘了循环引用的问题。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">pageView.tapHandler = ^(<span class="built_in">NSUInteger</span> idx, <span class="built_in">UIImage</span> *img, <span class="built_in">NSURL</span> *url) &#123;</span><br><span class="line">   __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) <span class="keyword">self</span> = weakSelf;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"self = %@, index = %lu, url = %@"</span>, <span class="keyword">self</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)idx, url);</span><br><span class="line">   [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>整体而言，没有冗余逻辑，能优化的也优化了（比如索引计算对取模的优化、定时器懒加载、刷新时机次数等等），应该算是比较轻量了吧哈哈哈哈。</p>
<p>具体应用方面，比如腾讯视频App中的首页Tab、会员Tab都有这种custom width的轮播图。<br><img src="https://image.chenyalun.com/2019/08/07/002.gif" style="zoom:80%"></p>
<p>QQ音乐中的发现Tab也是这种轮播图，不过不能无限循环（不能无限循环岂不是更简单。。）。<br><img src="https://image.chenyalun.com/2019/08/07/001.gif" style="zoom:80%"></p>
<p>好了，把两年前的坑填上了。</p>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/iOS开发/">iOS开发</a>
            
              <a href="/tags/开源项目/">开源项目</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/08/22/Objective-C设计指北/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Objective-C设计指北</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019/07/31/数据结构的Swift实现/">
        <span class="next-text nav-default">数据结构的Swift实现</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
