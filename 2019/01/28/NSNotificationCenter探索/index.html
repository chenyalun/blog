<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="NSNotificationCenter探索">




  <meta name="keywords" content="iOS开发,阅读,">




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x">



<link rel="canonical" href="http://blog.chenyalun.com/2019/01/28/NSNotificationCenter探索/">


<meta name="description" content="2019年10月14日 更新源码   探究NSNotificationCenter的实现并尝试自实现。">
<meta name="keywords" content="iOS开发,阅读">
<meta property="og:type" content="article">
<meta property="og:title" content="NSNotificationCenter探索">
<meta property="og:url" content="http://blog.chenyalun.com/2019/01/28/NSNotificationCenter探索/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="2019年10月14日 更新源码   探究NSNotificationCenter的实现并尝试自实现。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image.chenyalun.com/2019/01/28/002.png">
<meta property="og:updated_time" content="2019-12-26T07:28:22.438Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NSNotificationCenter探索">
<meta name="twitter:description" content="2019年10月14日 更新源码   探究NSNotificationCenter的实现并尝试自实现。">
<meta name="twitter:image" content="https://image.chenyalun.com/2019/01/28/002.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> NSNotificationCenter探索 · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          NSNotificationCenter探索
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年1月28日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、同步通知"><span class="toc-text">一、同步通知</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加observer"><span class="toc-text">添加observer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送通知"><span class="toc-text">发送通知</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、异步通知"><span class="toc-text">二、异步通知</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、子线程通知"><span class="toc-text">三、子线程通知</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、自实现"><span class="toc-text">四、自实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口文件"><span class="toc-text">接口文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Checklist"><span class="toc-text">Checklist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#功能测试"><span class="toc-text">功能测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现文件"><span class="toc-text">实现文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、小结"><span class="toc-text">五、小结</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <blockquote>
<p>2019年10月14日 更新源码</p>
</blockquote>
<p></p><p align="center"> 探究NSNotificationCenter的实现并尝试自实现。 </p><br><a id="more"></a><p></p>
<h1 id="一、同步通知"><a href="#一、同步通知" class="headerlink" title="一、同步通知"></a>一、同步通知</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>NSNotification并不复杂，封装了name、object以及userInfo，使用指定构造器初始化即可。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotification</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSNotificationName</span> name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="keyword">id</span> object;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *userInfo;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSNotificationName</span>)name object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)userInfo;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotification</span> (<span class="title">NSNotificationCreation</span>)</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)notificationWithName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)notificationWithName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>NSNotificationCenter则给我们提供了添加通知接收者、发送通知的接口。NSNotificationName就是<code>NSString *</code>，defaultCenter是单例。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotificationCenter</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="keyword">void</span> *_impl;</span><br><span class="line">    <span class="keyword">void</span> *_callback;</span><br><span class="line">    <span class="keyword">void</span> *_pad[<span class="number">11</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSNotificationCenter</span> *defaultCenter;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotification:(<span class="built_in">NSNotification</span> *)notification;</span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer;</span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span> &lt;<span class="built_in">NSObject</span>&gt;)addObserverForName:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)name object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)obj queue:(<span class="keyword">nullable</span> <span class="built_in">NSOperationQueue</span> *)queue usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSNotification</span> *note))block;</span><br><span class="line">    <span class="comment">// The return value is retained by the system, and should be held onto by the caller in order to remove the observer with removeObserver: later, to stop observation.</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h2 id="添加observer"><a href="#添加observer" class="headerlink" title="添加observer"></a>添加observer</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br></pre></td></tr></table></figure>
<p>最常用的就是这个方法，指定observer、selector、name以及object即可。它做了什么呢？<br>苹果官方文档解释如下：</p>
<blockquote>
<p>Adds an entry to the notification center’s dispatch table with an observer and a notification selector, and an optional notification name and sender.<br>Parameters</p>
</blockquote>
<blockquote>
<p>observer: Object registering as an observer.</p>
</blockquote>
<blockquote>
<p>aSelector: Selector that specifies the message the receiver sends observer to notify it of the notification posting. The method specified by aSelector must have one and only one argument (an instance of NSNotification).</p>
</blockquote>
<blockquote>
<p>aName: The name of the notification for which to register the observer; that is, only notifications with this name are delivered to the observer.<br>If you pass nil, the notification center doesn’t use a notification’s name to decide whether to deliver it to the observer.</p>
</blockquote>
<blockquote>
<p>anObject: The object whose notifications the observer wants to receive; that is, only notifications sent by this sender are delivered to the observer.<br>If you pass nil, the notification center doesn’t use a notification’s sender to decide whether to deliver it to the observer.</p>
</blockquote>
<blockquote>
<p>If your app targets iOS 9.0 and later or macOS 10.11 and later, you don’t need to unregister an observer in its dealloc method. Otherwise, you should call removeObserver:name:object: before observer or any object passed to this method is deallocated</p>
</blockquote>
<p>简单解释就是，把必需的observer、selector和可选的name、object注册到通知中心。这个selector有且只有一个参数，参数是NSNotification对象。若指定了通知的name，则observer必须匹配相同的name通知中心才会把消息分发给它，同样，若指定了通知的object，则observer必须匹配相同的object通知中心才会把消息分发给它。在iOS9.0或者macOS 10.11之后，咱们不必要在observer的dealloc方法中取消注册了（现在基本都要求最低是iOS9了）。</p>
<p>再看看坊间GNU的解释：</p>
<blockquote>
<p>Registers observer to receive notifications with the name<br> notificationName and/or containing object (one or both of these two must be<br> non-nil; nil acts like a wildcard).  When a notification of name name<br> containing object is posted, observer receives a selector message with this<br> notification as the argument.  The notification center waits for the<br> observer to finish processing the message, then informs the next registree<br> matching the notification, and after all of this is done, control returns<br> to the poster of the notification.  Therefore the processing in the<br> selector implementation should be short.</p>
</blockquote>
<blockquote>
<p>The notification center does not retain observer or object. Therefore,<br> you should always send removeObserver: or removeObserver:name:object: to<br> the notification center before releasing these objects.</p>
</blockquote>
<blockquote>
<p>As a convenience, when built with garbage collection, you do not need to<br> remove any garbage collected observer as the system will do it implicitly.</p>
</blockquote>
<blockquote>
<p>NB. For MacOS-X compatibility, adding an observer multiple times will<br> register it to receive multiple copies of any matching notification, however<br> removing an observer will remove <em>all</em> of the multiple registrations.</p>
</blockquote>
<p>我们得到的重要信息是：</p>
<ol>
<li>通知中心会等待所有符合条件的observer把通知消息处理完毕之后才会return，也即发送通知是同步的。这要求我们处理通知消息的逻辑应该“简短”、不会长时间阻塞。</li>
<li>通知中心并不增加observer和object的引用计数，建议我们适时removeObserver。</li>
<li>注册完全一致的observer信息（含name、object、selector）多次，回调也是有多次的，而只移除一次完全一致的observer信息，却会把所有的observer信息都移除掉。</li>
</ol>
<p>对于第三条这么理解，注册3次，回调也是有三次；而移除一次，所有的该通知都被移除了：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[NSNotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">dealWithNoti:</span>) <span class="string">name:</span>name <span class="string">object:</span>obj];</span><br><span class="line">[NSNotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">dealWithNoti:</span>) <span class="string">name:</span>name <span class="string">object:</span>obj];</span><br><span class="line">[NSNotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">dealWithNoti:</span>) <span class="string">name:</span>name <span class="string">object:</span>obj];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[NSNotificationCenter.defaultCenter <span class="string">removeObserver:</span>self <span class="string">name:</span>name <span class="string">object:</span>obj];</span><br></pre></td></tr></table></figure></p>
<p>源码逻辑是这样的：<br><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">- (void)addObserver:(id)observer</span><br><span class="line">           selector:(SEL)selector</span><br><span class="line">               <span class="keyword">name</span>:(NSString *)<span class="keyword">name</span></span><br><span class="line">             object:(id)object &#123;</span><br><span class="line">    Observation	*list;</span><br><span class="line">    Observation	*o;</span><br><span class="line">    NSIMapTable	m;</span><br><span class="line">    NSIMapNode	n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lockNCTable(_table);</span><br><span class="line">    <span class="comment">// 根据observer和selector获取Observation</span></span><br><span class="line">    o = obsNew(_table, selector, observer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">name</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据name在named表中搜索对应的NSIMapNode</span></span><br><span class="line">        <span class="function"><span class="title">n</span> = NSIMapNodeForKey(_table-&gt;</span>named, (NSIMapKey)(id)<span class="keyword">name</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="comment">// 没有在named表中找到</span></span><br><span class="line">            <span class="comment">// 优先在_table的缓存中查找, 找不到则创建</span></span><br><span class="line">            m = mapNew(_table);</span><br><span class="line">            <span class="comment">// 将name转换为不可变的name</span></span><br><span class="line">            <span class="keyword">name</span> = [<span class="keyword">name</span> copyWithZone:NSDefaultMallocZone()];</span><br><span class="line">            <span class="comment">// 把name作为key, 将新创建的m(NSIMapTable)设置到named表中</span></span><br><span class="line">            NSIM<span class="function"><span class="title">apAddPair</span>(_table-&gt;</span>named, (NSIMapKey)(id)<span class="keyword">name</span>, (NSIMapVal)(void *)m);</span><br><span class="line">            NS_CONSUMED(<span class="keyword">name</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在named表中找到了, 取出NSIMapNode对应的value</span></span><br><span class="line">            <span class="function"><span class="title">m</span> = (NSIMapTable)n-&gt;</span>value.ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// object作为key, 取出其在m表中对应的NSIMapNode</span></span><br><span class="line">        n = NSIMapNodeForSimpleKey(m, (NSIMapKey)object);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="title">o</span>-&gt;</span>next = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// m表中取不到object对应的值, 把Observation直接存到m表中</span></span><br><span class="line">            NSIMapAddPair(m, (NSIMapKey)object, (NSIMapVal)o);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// object作为key, 取出其在m表中对应的NSIMapNode, 获取node中的链表</span></span><br><span class="line">            <span class="function"><span class="title">list</span> = (Observation *)n-&gt;</span>value.ptr;</span><br><span class="line">            <span class="comment">// 把Observation追加到链表的最前面</span></span><br><span class="line">            <span class="function"><span class="title">o</span>-&gt;</span><span class="function"><span class="title">next</span> = list-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">list</span>-&gt;</span>next = o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object) &#123;</span><br><span class="line">        <span class="comment">// name不存在, 则从nameless表中搜索对应的NSIMapNode</span></span><br><span class="line">        <span class="function"><span class="title">n</span> = NSIMapNodeForSimpleKey(_table-&gt;</span>nameless, (NSIMapKey)object);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 同样的逻辑, 把Observation追加到链表的最前面</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="title">o</span>-&gt;</span>next = ENDOBS;</span><br><span class="line">            NSIM<span class="function"><span class="title">apAddPair</span>(_table-&gt;</span>nameless, (NSIMapKey)object, (NSIMapVal)o);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">list</span> = (Observation *)n-&gt;</span>value.ptr;</span><br><span class="line">            <span class="function"><span class="title">o</span>-&gt;</span><span class="function"><span class="title">next</span> = list-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">list</span>-&gt;</span>next = o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// name和object都为空, 把Observation追加到wildcard表的最前面</span></span><br><span class="line">        <span class="function"><span class="title">o</span>-&gt;</span><span class="function"><span class="title">next</span> = _table-&gt;</span>wildcard;</span><br><span class="line">        _<span class="function"><span class="title">table</span>-&gt;</span>wildcard = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlockNCTable(_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>named表的结构大致如此：<br><img src="https://image.chenyalun.com/2019/01/28/002.png" style="zoom:50%"></p>
<p>而nameless表则更简单，object作为key，observer数组作为value。</p>
<p>还有一种是以block的形式添加观察者：<br><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>addObserverForName:<span class="params">(NSString *)</span>name</span><br><span class="line">                  object:<span class="params">(id)</span>object</span><br><span class="line">                   queue:<span class="params">(NSOperationQueue *)</span>queue</span><br><span class="line">              usingBlock:<span class="params">(NSNotificationBlock)</span>block</span><br></pre></td></tr></table></figure></p>
<p>不需要设置selector，还能方便地在block中执行。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)addObserverForName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                  object:(<span class="keyword">id</span>)object</span><br><span class="line">                   queue:(<span class="built_in">NSOperationQueue</span> *)queue</span><br><span class="line">              usingBlock:(<span class="built_in">NSNotificationBlock</span>)block &#123;</span><br><span class="line">    <span class="built_in">NSNotificationObserver</span> *observer =</span><br><span class="line">    [[<span class="built_in">NSNotificationObserver</span> alloc] initWithQueue:queue block:block];</span><br><span class="line">    [<span class="keyword">self</span> addObserver:observer</span><br><span class="line">	         selector:<span class="keyword">@selector</span>(didReceiveNotification:)</span><br><span class="line">	             name:name</span><br><span class="line">	           object:object];</span><br><span class="line">    <span class="keyword">return</span> observer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码来看，这个方法实际上也是调用了addObserver:selector:name:object方法。observer没有变，但是把selector替换成了didReceiveNotification:，它的实现是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveNotification: (<span class="built_in">NSNotification</span> *)notif &#123;</span><br><span class="line">    <span class="keyword">if</span> (_queue != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSNotificationBlockOperation</span> *op = [[<span class="built_in">NSNotificationBlockOperation</span> alloc] </span><br><span class="line">			initWithNotification:notif block:_block];</span><br><span class="line">        [_queue addOperation:op];</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">CALL_BLOCK</span>(_block, notif);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>didReceiveNotification:方法处理了Queue的逻辑。如果Queue不存在，则直接调用block。如果Queue是存在的，继承自NSOperation的NSNotificationBlockOperation封装了需要回调的block和回传的NSNotification，并在main方法中调用了这个block。最后，这个operation被添加到指定的Queue中执行。</p>
<h2 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br></pre></td></tr></table></figure>
<p>发送通知最终是调用这个方法。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                      object:(<span class="keyword">id</span>)object</span><br><span class="line">                    userInfo:(<span class="built_in">NSDictionary</span> *)info &#123;</span><br><span class="line">    <span class="built_in">NSNotification</span> *notification;</span><br><span class="line">    notification = (<span class="keyword">id</span>)<span class="built_in">NSAllocateObject</span>(concrete, <span class="number">0</span>, <span class="built_in">NSDefaultMallocZone</span>());</span><br><span class="line">    notification-&gt;_name = [name copyWithZone: [<span class="keyword">self</span> zone]];</span><br><span class="line">    notification-&gt;_object = [object <span class="keyword">retain</span>];</span><br><span class="line">    notification-&gt;_info = [info <span class="keyword">retain</span>];</span><br><span class="line">    [<span class="keyword">self</span> _postAndRelease: notification];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键的是<code>_postAndRelease:</code>的实现：<br><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">- (void)_postAndRelease:(NSNotification *)notification &#123;</span><br><span class="line">    Observation	*o;</span><br><span class="line">    unsigned count;</span><br><span class="line">    NSString *<span class="keyword">name</span> = [notification <span class="keyword">name</span>];</span><br><span class="line">    id object;</span><br><span class="line">    GSIMapNode	n;</span><br><span class="line">    GSIMapTable	m;</span><br><span class="line">    GSIArrayItem i[<span class="number">64</span>];</span><br><span class="line">    GSIArray_t b;</span><br><span class="line">    GSIArray a = &amp;b;</span><br><span class="line">    <span class="comment">// 获取object</span></span><br><span class="line">    object = [notification object];</span><br><span class="line"></span><br><span class="line">    GSIArrayInitWithZoneAndStaticCapacity(a, _zone, <span class="number">64</span>, i);</span><br><span class="line">    lockNCTable(_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取没有指定name也没有指定object的所有observer</span></span><br><span class="line">    <span class="function"><span class="title">for</span> (o = _table-&gt;</span><span class="function"><span class="title">wildcard</span> = purgeCollected(WILDCARD); o != ENDOBS; o = o-&gt;</span>next) &#123;</span><br><span class="line">        GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定object但是没有指定name的所有observer</span></span><br><span class="line">    <span class="keyword">if</span> (object) &#123;</span><br><span class="line">        <span class="function"><span class="title">n</span> = GSIMapNodeForSimpleKey(_table-&gt;</span>nameless, (GSIMapKey)object);</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="title">o</span> = ((Observation *)n-&gt;</span>value.ext)</span><br><span class="line">            <span class="keyword">while</span> (o != (Observation *)-<span class="number">1</span>) &#123;</span><br><span class="line">                GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">                <span class="function"><span class="title">o</span> = o-&gt;</span>next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指定name而且object也与通知要求的object相匹配的所有observer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">name</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">n</span> = GSIMapNodeForKey(_table-&gt;</span>named, (GSIMapKey)((id)<span class="keyword">name</span>));</span><br><span class="line">        <span class="keyword">if</span> (n) &#123;</span><br><span class="line">            <span class="function"><span class="title">m</span> = (GSIMapTable)n-&gt;</span>value.ptr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// object为空</span></span><br><span class="line">            n = GSIMapNodeForSimpleKey(m, (GSIMapKey)object);</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="title">o</span> = ((Observation *)n-&gt;</span>value.ext)</span><br><span class="line">                <span class="keyword">while</span> (o != (Observation *)-<span class="number">1</span>) &#123;</span><br><span class="line">                    GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">                    <span class="function"><span class="title">o</span> = o-&gt;</span>next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// object不为空, 且匹配</span></span><br><span class="line">            <span class="keyword">if</span> (object != <span class="literal">nil</span>) &#123;</span><br><span class="line">                n = GSIMapNodeForSimpleKey(m, (GSIMapKey)<span class="literal">nil</span>);</span><br><span class="line">                <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="function"><span class="title">o</span> = ((Observation *)n-&gt;</span>value.ext)</span><br><span class="line">                    <span class="keyword">while</span> (o != (Observation *)-<span class="number">1</span>) &#123;</span><br><span class="line">                        GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">                        <span class="function"><span class="title">o</span> = o-&gt;</span>next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlockNCTable(TABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数组a, 逐个发送通知</span></span><br><span class="line">    count = GSIArrayCount(a);</span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        o = GSIArrayItemAtIndex(a, count).ext;</span><br><span class="line">        <span class="function"><span class="title">if</span> (o-&gt;</span>next != <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="function"><span class="title">o</span>-&gt;</span><span class="function"><span class="title">observer</span> performSelector:o-&gt;</span>selector withObject:notification];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 置空数组a</span></span><br><span class="line">    lockNCTable(_table);</span><br><span class="line">    GSIArrayEmpty(a);</span><br><span class="line">    unlockNCTable(_table);</span><br><span class="line">    <span class="comment">// release通知对象</span></span><br><span class="line">    RELEASE(notification);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键在于从表中获取符合要求的Observation：在wildcard表中获取匿名且没有指定object的Observation；在nameless表中获取匹配object但是匿名的Observation；在named表中获取object为空的Observation和object匹配的Observation。把这些Observation添加到一个数组中，遍历，逐个调用selector。</p>
<p>那么，移除通知自然也是根据name、object、observer，找到匹配的Observation对象，从相应的表中移除，不再赘述。</p>
<h1 id="二、异步通知"><a href="#二、异步通知" class="headerlink" title="二、异步通知"></a>二、异步通知</h1><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle;</span><br><span class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle coalesceMask:(<span class="built_in">NSNotificationCoalescing</span>)coalesceMask forModes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dequeueNotificationsMatching:(<span class="built_in">NSNotification</span> *)notification coalesceMask:(<span class="built_in">NSUInteger</span>)coalesceMask;</span><br></pre></td></tr></table></figure>
<p>通过NSNotificationQueue可以实现异步通知。NSNotificationCoalescing提供了聚合选项，不聚合、根据name聚合以及根据发送者聚合，也即如果在队列中已有该种通知，如果满足选项，则不会进入队列，只保留第一个通知。NSPostingStyle则可以设置通知发送的时机，立即同步发送、尽可能快地发送，以及在Runloop空闲时发送。</p>
<p><strong>场景如下：</strong><br>NSPostWhenIdle：比如当用户正在输入文字，需要在某个控件上实时展示文字的长度的时候，可以用到这个选项。<br>NSPostNow：实时发送通知，但是与同步通知相比，关键在于聚合选项：队列中已有满足选项的通知时，是否只保留一个。<br>NSPostASAP：多个通知进入到缓冲区后，利用聚合选项，只留下一个，并尽可能快地发送通知。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification</span><br><span class="line">               postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle</span><br><span class="line">               coalesceMask:(<span class="built_in">NSUInteger</span>)coalesceMask</span><br><span class="line">                   forModes:(<span class="built_in">NSArray</span> *)modes &#123;</span><br><span class="line">    <span class="keyword">if</span> (modes == <span class="literal">nil</span>) modes = defaultMode; <span class="comment">// 默认模式</span></span><br><span class="line">    <span class="keyword">if</span> (coalesceMask != <span class="built_in">NSNotificationNoCoalescing</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要聚合, 则先把队列中的相应的notification移除</span></span><br><span class="line">        [<span class="keyword">self</span> dequeueNotificationsMatching:notification</span><br><span class="line">			    coalesceMask:coalesceMask];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> (postingStyle) &#123;</span><br><span class="line">        <span class="comment">// 同步发送</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSPostNow</span>: &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *mode = [[<span class="built_in">NSRunLoop</span> currentRunLoop] currentMode];</span><br><span class="line">            <span class="comment">// 要求当前Runloop的mode需要匹配, 不然无效</span></span><br><span class="line">            <span class="keyword">if</span> (mode == <span class="literal">nil</span> || [modes indexOfObject:mode] != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">                [_center postNotification: notification];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 尽可能早发送(as soon as possible)</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSPostASAP</span>:</span><br><span class="line">            add_to_queue(_asapQueue, notification, modes, _zone); <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 在Runloop空闲时发送</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSPostWhenIdle</span>:</span><br><span class="line">            add_to_queue(_idleQueue, notification, modes, _zone); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从入口方法来看，关键在于add_to_queue()函数，根据NSPostingStyle选项，把通知添加到_asapQueue队列或者_idleQueue队列。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static void add_to_queue(NSNotificationQueueList *queue,</span><br><span class="line">                         NSNotification *notification,</span><br><span class="line">                         NSArray *modes, NSZone *_zone) &#123;</span><br><span class="line">    NSNotificationQueueRegistration *item;</span><br><span class="line">    item = NSZoneCalloc(_zone, <span class="number">1</span>, sizeof(NSNotificationQueueRegistration));</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span>notification = RETAIN(notification);</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span><span class="keyword">name</span> = [notification <span class="keyword">name</span>];</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span>object = [notification object];</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span>modes = [modes copyWithZone: [modes zone]];</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span>next = NULL;</span><br><span class="line">    <span class="function"><span class="title">item</span>-&gt;</span><span class="function"><span class="title">prev</span> = queue-&gt;</span>tail;</span><br><span class="line">    <span class="function"><span class="title">queue</span>-&gt;</span>tail = item;</span><br><span class="line">    <span class="function"><span class="title">if</span> (item-&gt;</span><span class="function"><span class="title">prev</span>) item-&gt;</span><span class="function"><span class="title">prev</span>-&gt;</span>next = item;</span><br><span class="line">    <span class="function"><span class="title">if</span> (!queue-&gt;</span><span class="function"><span class="title">head</span>) queue-&gt;</span>head = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，把notification和modes封装成NSNotificationQueueRegistration，并把它插入到双向链表queue的尾部。</p>
<p>以NSPostWhenIdle选项为例，在Runloop的<code>acceptInputForMode:beforeDate:</code>方法中找到了通知的发送痕迹：GSPrivateNotifyIdle(mode)。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void GSPrivateNotifyIdle(NSString *mode) &#123;</span><br><span class="line">    NotificationQueueList	*item;</span><br><span class="line">    <span class="function"><span class="title">for</span> (item = currentList(); item; item = item-&gt;</span>next) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span> (item-&gt;</span>queue) &#123;</span><br><span class="line">            <span class="function"><span class="title">notify</span>(item-&gt;</span><span class="function"><span class="title">queue</span>-&gt;</span>_center,</span><br><span class="line">                   <span class="function"><span class="title">item</span>-&gt;</span><span class="function"><span class="title">queue</span>-&gt;</span>_idleQueue,</span><br><span class="line">                   mode,</span><br><span class="line">                   <span class="function"><span class="title">item</span>-&gt;</span><span class="function"><span class="title">queue</span>-&gt;</span>_zone);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就很明朗了，notify()的逻辑是这样的：</p>
<ol>
<li>从双向链表list中取出所有的结点对象NSNotificationQueueRegistration，并把它放到一个数组中。</li>
<li>遍历该数组，逐个从list中移除：<code>remove_from_queue(list, item, zone);</code>。</li>
<li>遍历该数组，逐个发送通知<code>[NSNotificationCenter.defaultCenter postNotification:notification];</code>，而<code>postNotification:</code>方法本质上还是调用同步通知中的<code>_postAndRelease:</code>方法。</li>
</ol>
<p>什么时候发送，交由Runloop处理。</p>
<h1 id="三、子线程通知"><a href="#三、子线程通知" class="headerlink" title="三、子线程通知"></a>三、子线程通知</h1><p>子线程通知苹果给出了标准的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG" target="_blank" rel="noopener">解决方案</a>：利用NSMachPort。假定在A线程发送通知，需要在B线程处理通知，那么B线程中注册NSMachPort，A线程中使用此port发送通知，则B线程就能收到消息并进行处理。</p>
<p>简单概述实现思路就是：维护一个NSNotification数组，接收到通知时，如果通知分发的线程与期望的线程（处理通知的线程）不一致，则把这个通知添加到NSNotification数组中，并利用NSMachPort发送一个“信号”到期望的线程（也就是创建NSMachPort对象的线程）中，在期望的线程中收到信号后，把通知从NSNotification数组中移除，并处理。</p>
<p>比如，需要在主线程发送通知，而在子线程接收并处理通知，结合苹果给出的示例代码，可以这么做：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通知名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSNotificationName</span> YADemoNotification = <span class="string">@"YADemoNotification"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAThreadedNotificationHandler</span>: <span class="title">NSObject</span> &lt;<span class="title">NSMachPortDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *notifications;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *notificationThread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSLock</span> *notificationLock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMachPort</span> *notificationPort;</span><br><span class="line">- (<span class="keyword">void</span>)setUpThreadingSupport;</span><br><span class="line">- (<span class="keyword">void</span>)processNotification:(<span class="built_in">NSNotification</span> *)notification;</span><br><span class="line"><span class="comment">// Mach port delegate</span></span><br><span class="line">- (<span class="keyword">void</span>)handleMachMessage:(<span class="keyword">void</span> *)msg;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAThreadedNotificationHandler</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setUpThreadingSupport];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(processNotification:) name:YADemoNotification object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private methods</span></span><br><span class="line">- (<span class="keyword">void</span>)setUpThreadingSupport &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.notifications) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">self</span>.notifications      = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.notificationLock   = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="comment">// 配置期望线程（当前线程）</span></span><br><span class="line">    <span class="keyword">self</span>.notificationThread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置端口消息处理的线程（当前线程）</span></span><br><span class="line">    <span class="keyword">self</span>.notificationPort = [[<span class="built_in">NSMachPort</span> alloc] init];</span><br><span class="line">    [<span class="keyword">self</span>.notificationPort setDelegate:<span class="keyword">self</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:<span class="keyword">self</span>.notificationPort forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口代理</span></span><br><span class="line">- (<span class="keyword">void</span>)handleMachMessage:(<span class="keyword">void</span> *)msg &#123;</span><br><span class="line">    [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    <span class="keyword">while</span> ([<span class="keyword">self</span>.notifications count]) &#123;</span><br><span class="line">        <span class="built_in">NSNotification</span> *notification = [<span class="keyword">self</span>.notifications objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notifications removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span> processNotification:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    &#125;;</span><br><span class="line">    [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理通知</span></span><br><span class="line">- (<span class="keyword">void</span>)processNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread] != <span class="keyword">self</span>.notificationThread) &#123;</span><br><span class="line">        <span class="comment">// Forward the notification to the correct thread.</span></span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">        [<span class="keyword">self</span>.notifications addObject:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span>.notificationPort sendBeforeDate:[<span class="built_in">NSDate</span> date]</span><br><span class="line">                components:<span class="literal">nil</span></span><br><span class="line">                from:<span class="literal">nil</span></span><br><span class="line">                reserved:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Process the notification here;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"处理通知在%@线程"</span>, <span class="built_in">NSThread</span>.currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在控制器中，这样发送通知：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *thread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) YAThreadedNotificationHandler *notificationHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)startThread &#123;</span><br><span class="line">    <span class="keyword">self</span>.notificationHandler = [YAThreadedNotificationHandler new];</span><br><span class="line">    <span class="comment">// 主线程发送通知</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="built_in">NSNotificationCenter</span>.defaultCenter postNotificationName:YADemoNotification object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 子线程手动开启Runloop</span></span><br><span class="line">    [<span class="built_in">NSRunLoop</span>.currentRunLoop run];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(startThread) object:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.thread start];    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="四、自实现"><a href="#四、自实现" class="headerlink" title="四、自实现"></a>四、自实现</h1><p>有几个弱引用容器在日常工作中没有用过，但是又特别想亲手实践一番。偶尔看到一篇文章，说是自己实现了系统中通知中心的功能，出于好奇，自己也尝试一番，便在这里模仿了同步通知的实现。</p>
<p>主要原理就是创建一个字典observerMap，notification name作为key，NSMapTable作为value。在这个NSMapTable中，object作为key，用于存放observer的NSHashSet容器作为value。</p>
<h2 id="接口文件"><a href="#接口文件" class="headerlink" title="接口文件"></a>接口文件</h2><p>接口与系统保持一致。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> *YANotificationName <span class="built_in">NS_EXTENSIBLE_STRING_ENUM</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YANotificationCenter</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) YANotificationCenter *defaultCenter;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name:(<span class="keyword">nullable</span> YANotificationName)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer;</span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer name:(<span class="keyword">nullable</span> YANotificationName)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>
<h2 id="Checklist"><a href="#Checklist" class="headerlink" title="Checklist"></a>Checklist</h2><ul>
<li style="list-style: none"><input type="checkbox" checked> 不增加observer和object的引用计数</li>
<li style="list-style: none"><input type="checkbox" checked> 支持携带参数信息userInfo</li>
<li style="list-style: none"><input type="checkbox" checked> 可以不指定object</li>
<li style="list-style: none"><input type="checkbox" checked> 添加观察者时指定object，post通知时只有相同的object才会有效</li>
<li style="list-style: none"><input type="checkbox" checked> observer为nil，发送通知时没有作用</li>
<li style="list-style: none"><input type="checkbox" checked> 指定线程发送通知，则在指定线程调用</li>
<li style="list-style: none"><input type="checkbox" checked> 没有及时移除通知，observer销毁之后继续发送通知不会产生异常<br>(从iOS 9开始，即使不移除观察者对象，程序也不会出现异常。)</li>
<li style="list-style: none"><input type="checkbox" checked> 支持多个observer监听同一个通知</li>
<li style="list-style: none"><input type="checkbox" checked> 如果notificationName为nil，object有值，则接收所有指定为object的通知</li>
<li style="list-style: none"><input type="checkbox" checked> 如果notificationName为nil，且object也为nil，则接收系统内所有通知<br>(也即YANotificationCenter发出的所有通知)</li>
<li style="list-style: none"><input type="checkbox" checked> 移除所有通知后，相关方法不再调用</li>
<li style="list-style: none"><input type="checkbox" checked> 移除指定通知后，相关方法不再调用</li>
<li style="list-style: none"><input type="checkbox" checked> 同步处理通知消息</li>
<li style="list-style: none"><input type="checkbox"> 多次添加observer，发送通知时多次调用</li>
<li style="list-style: none"><input type="checkbox"> 支持异步发布通知（NotificationQueue）</li>
</ul>
<h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 不对observer和object强引用</span><br><span class="line"><span class="number">2.</span> 可以携带参数userInfo</span><br><span class="line"><span class="number">3.</span> 添加观察者时object为nil，post通知时object有值，依然有效(表示不限于指定的object)</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_1"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_1"</span> <span class="string">object:</span>self <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">4.</span> 添加观察者时指定object，post通知时相同的object，有效，不同的object，无效</span><br><span class="line"><span class="comment">// 有效</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_2"</span> <span class="string">object:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_2"</span> <span class="string">object:</span>self <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_3"</span> <span class="string">object:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_3"</span> <span class="string">object:</span>a <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 可以添加n次observer，发送通知时对应调用n次(不支持)</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_4"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">print3:</span>) <span class="string">name:</span>@<span class="string">"Noti_4"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_4"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">6.</span> 未添加observer，发送通知时没有作用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_5"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 指定线程发送通知，则在指定线程调用</span><br><span class="line"><span class="comment">// print方法是在发送通知的线程中调用的</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_6"</span> <span class="string">object:</span>nil];</span><br><span class="line">dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">NSLog(@<span class="string">"当前线程:%@"</span>,[NSThread currentThread]);</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_6"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> 没有在observer的dealloc方法中移除通知，observer销毁之后继续发送通知，无影响(从iOS <span class="number">9</span>开始，即使不移除观察者对象，程序也不会出现异常。)</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_7"</span> <span class="string">object:</span>nil];</span><br><span class="line"><span class="comment">// a对象销毁之后继续发送通知</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_7"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 多个observer监听同一个通知，所有observer的相关方法均得到调用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>a <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>b <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>c <span class="string">selector:</span><span class="meta">@selector</span>(print) <span class="string">name:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_8"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">10.</span> 如果notificationName为nil，object有值，则接收所有指定为object的通知</span><br><span class="line"><span class="comment">// 接收self发送的所有通知</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>nil <span class="string">object:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_9"</span> <span class="string">object:</span>self <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"><span class="number">11.</span> 如果notificationName为nil，且object也为nil，则接收系统内所有通知(也即YANotificationCenter发出的所有通知)</span><br><span class="line"><span class="comment">// 接收系统内所有通知，也即任意一个通知都会触发</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>nil <span class="string">object:</span>nil];</span><br><span class="line"><span class="number">12.</span> 移除所有通知后，相关方法不再调用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>@<span class="string">"Noti_10"</span> <span class="string">object:</span>nil];</span><br><span class="line"><span class="comment">// 移除所有通知后，再次发送通知没有效果</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">removeObserver:</span>self];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_10"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> 移除指定通知后，相关方法不再调用</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(print1) <span class="string">name:</span>@<span class="string">"Noti_11"</span> <span class="string">object:</span>nil];</span><br><span class="line"><span class="comment">// 移除指定通知后，再次发送通知没有效果</span></span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">removeObserver:</span>self <span class="string">name:</span>@<span class="string">"Noti_11"</span> <span class="string">object:</span>nil];</span><br><span class="line">[YANotificationCenter.defaultCenter <span class="string">postNotificationName:</span>@<span class="string">"Noti_11"</span> <span class="string">object:</span>nil <span class="string">userInfo:</span>@&#123;@<span class="string">"key"</span>: @<span class="string">"value"</span>&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="实现文件"><a href="#实现文件" class="headerlink" title="实现文件"></a>实现文件</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YANotificationCenter.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, YANotificationSenderType) &#123;</span><br><span class="line">    YANotificationSenderTypeObject   = <span class="number">0</span>, <span class="comment">// 指定对象</span></span><br><span class="line">    YANotificationSenderTypeObserver = <span class="number">1</span>, <span class="comment">// 观察者</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YANotificationCenter</span>()</span></span><br><span class="line"><span class="comment">// Recorder observer.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *observerMap;</span><br><span class="line"><span class="comment">// Recorder all the selector.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *selectorMap;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YANotificationCenter</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _observerMap = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        _selectorMap = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (YANotificationCenter *)defaultCenter &#123;</span><br><span class="line">    <span class="keyword">static</span> YANotificationCenter *center = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        center = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name:(YANotificationName)aName object:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line">    <span class="keyword">if</span> (!observer) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!aName) aName = (<span class="keyword">id</span>)kCFNull;</span><br><span class="line">    <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:aName];</span><br><span class="line">    <span class="keyword">if</span> (!map) map = [<span class="built_in">NSMapTable</span> weakToStrongObjectsMapTable];</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        <span class="built_in">NSHashTable</span> *set = [map objectForKey:observer];</span><br><span class="line">        <span class="keyword">if</span> (!set || ![set isKindOfClass:[<span class="built_in">NSHashTable</span> <span class="keyword">class</span>]]) set = [<span class="built_in">NSHashTable</span> weakObjectsHashTable];</span><br><span class="line">        [set addObject:anObject];</span><br><span class="line">        [map setObject:set forKey:observer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [map setObject:(<span class="keyword">id</span>)kCFNull forKey:observer];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.observerMap setObject:map forKey:aName];</span><br><span class="line">    <span class="built_in">NSString</span> *key = generateKey(observer, anObject, aName);</span><br><span class="line">    [<span class="keyword">self</span>.selectorMap setObject:<span class="built_in">NSStringFromSelector</span>(aSelector) forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line">    [<span class="keyword">self</span> postNotificationName:aName object:anObject userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotificationName:(YANotificationName)aName object:(<span class="keyword">id</span>)anObject userInfo:(<span class="built_in">NSDictionary</span> *)aUserInfo &#123;</span><br><span class="line">    <span class="comment">// When the notification name is nil.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:(<span class="keyword">id</span>)kCFNull];</span><br><span class="line">        <span class="keyword">id</span> key = <span class="literal">nil</span>;</span><br><span class="line">        <span class="built_in">NSEnumerator</span> *enumerator = map.keyEnumerator;</span><br><span class="line">        <span class="keyword">while</span> (key = [enumerator nextObject]) &#123;</span><br><span class="line">            <span class="built_in">NSHashTable</span> *set = [map objectForKey:key];</span><br><span class="line">            <span class="built_in">NSArray</span> *selectorList = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (set == (<span class="keyword">id</span>)kCFNull) &#123;</span><br><span class="line">                selectorList = <span class="keyword">self</span>.selectorMap.allValues;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([set containsObject:anObject]) &#123;</span><br><span class="line">                selectorList = selectorListForSender(<span class="keyword">self</span>, anObject, YANotificationSenderTypeObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!selectorList) <span class="keyword">break</span>;</span><br><span class="line">            [selectorList enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *selector, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">                SEL sel = <span class="built_in">NSSelectorFromString</span>(selector);</span><br><span class="line">                ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))[key methodForSelector:sel])(<span class="keyword">self</span>, sel, aUserInfo);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normal process.</span></span><br><span class="line">    <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:aName];</span><br><span class="line">    <span class="keyword">id</span> key = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSEnumerator</span> *enumerator = map.keyEnumerator;</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        <span class="keyword">while</span> (key = [enumerator nextObject]) &#123;</span><br><span class="line">            <span class="built_in">NSHashTable</span> *set = [map objectForKey:key];</span><br><span class="line">            <span class="keyword">if</span> (set == (<span class="keyword">id</span>)kCFNull || [set containsObject:anObject]) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *selector = [<span class="keyword">self</span>.selectorMap objectForKey:generateKey(key, anObject, aName)];</span><br><span class="line">                <span class="keyword">if</span> (!selector) <span class="keyword">return</span>;</span><br><span class="line">                SEL sel = <span class="built_in">NSSelectorFromString</span>(selector);</span><br><span class="line">                ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))[key methodForSelector:sel])(<span class="keyword">self</span>, sel, aUserInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (key = [enumerator nextObject]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *selector = [<span class="keyword">self</span>.selectorMap objectForKey:generateKey(key, anObject, aName)];</span><br><span class="line">            <span class="keyword">if</span> (!selector) <span class="keyword">return</span>;</span><br><span class="line">            SEL sel = <span class="built_in">NSSelectorFromString</span>(selector);</span><br><span class="line">            ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))[key methodForSelector:sel])(<span class="keyword">self</span>, sel, aUserInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.observerMap.allValues enumerateObjectsUsingBlock:^(<span class="built_in">NSMapTable</span> *map, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        [map removeObjectForKey:observer];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.selectorMap removeObjectsForKeys:selectorListForSender(<span class="keyword">self</span>, observer, YANotificationSenderTypeObserver)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer name:(YANotificationName)aName object:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line">    <span class="built_in">NSMapTable</span> *map = [<span class="keyword">self</span>.observerMap objectForKey:aName];</span><br><span class="line">    <span class="comment">// Remove selector.</span></span><br><span class="line">    [<span class="keyword">self</span>.selectorMap removeObjectForKey:generateKey(observer, anObject, aName)];</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        <span class="built_in">NSHashTable</span> *set = [map objectForKey:observer];</span><br><span class="line">        [set removeObject:anObject];</span><br><span class="line">        <span class="keyword">if</span> (set.count == <span class="number">0</span>) [map removeObjectForKey:observer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [map removeObjectForKey:observer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map.count == <span class="number">0</span>) [<span class="keyword">self</span>.observerMap removeObjectForKey:aName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">NSString</span> *generateKey(<span class="keyword">id</span> observer, <span class="keyword">id</span> anObject, YANotificationName name) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">        key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p_%@_%p"</span> ,anObject, name, observer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@_%p"</span>, name, observer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">NSArray</span> *selectorListForSender(YANotificationCenter *<span class="keyword">self</span>, <span class="keyword">id</span> object, YANotificationSenderType type) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *p = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, object];</span><br><span class="line">    <span class="built_in">NSPredicate</span> *predicate = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == YANotificationSenderTypeObject) &#123;</span><br><span class="line">        predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF BEGINSWITH %@"</span>, p];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF ENDSWITH %@"</span>, p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSArray</span> *keys = [<span class="keyword">self</span>.selectorMap.allKeys filteredArrayUsingPredicate:predicate];</span><br><span class="line">    <span class="built_in">NSArray</span> *result = [<span class="keyword">self</span>.selectorMap objectsForKeys:keys notFoundMarker:(<span class="keyword">id</span>)kCFNull];</span><br><span class="line">    <span class="keyword">return</span> result.count == <span class="number">0</span> ? <span class="literal">nil</span> : result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h1 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h1><ol>
<li>同步通知内部实现是维护了两层映射：第一层name作为key，第二层object作为key，最终把observer保存在数组中。iOS9之后对observer是安全的弱引用。</li>
<li>异步通知内部维护了一个双向链表以满足“聚合（NSNotificationCoalescing）”选项，依赖Runloop的迭代以满足“时机（NSPostingStyle）”选项。</li>
<li>使用子线程通知需要依靠NSMachPort的通信。</li>
</ol>
<p>日常开发中同步通知能满足绝大多数场景，异步通知的场景有限，苹果给出的几个例子还是很经典的。子线程通知也是常见的，比如子线程发通知主线程处理通知，但是我看大家都习惯直接利用GCD从子线程环境切换到主线程，再发出通知。</p>
<blockquote>
<p>参考资料：<br><a href="http://southpeak.github.io/2015/03/20/cocoa-foundation-nsnotificationcenter/" target="_blank" rel="noopener">《Notification与多线程》</a><br><a href="http://cloverkim.com/ios_notification-principle.html" target="_blank" rel="noopener">《NSNotification原理理解》</a><br><a href="https://philm.gitbook.io/philm-ios-wiki/mei-zhou-yue-du/shen-ru-si-kao-nsnotification" target="_blank" rel="noopener">《深入思考NSNotification》</a><br><a href="[](https://www.jianshu.com/p/83770200d476">《深入理解iOS NSNotification》</a>)</p>
</blockquote>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/iOS开发/">iOS开发</a>
            
              <a href="/tags/阅读/">阅读</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/03/15/App界面优化Tips/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">App界面优化Tips</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019/01/20/Weak Associated Object/">
        <span class="next-text nav-default">Weak Associated Object</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
