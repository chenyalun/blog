<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="「KVOController」的封装">




  <meta name="keywords" content="iOS开发,阅读,">




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x">



<link rel="canonical" href="http://blog.chenyalun.com/2019/01/12/「KVOController」的封装/">


<meta name="description" content="学习KVO的封装。">
<meta name="keywords" content="iOS开发,阅读">
<meta property="og:type" content="article">
<meta property="og:title" content="「KVOController」的封装">
<meta property="og:url" content="http://blog.chenyalun.com/2019/01/12/「KVOController」的封装/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="学习KVO的封装。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image.chenyalun.com/2019/01/07/001.png">
<meta property="og:updated_time" content="2019-07-30T03:58:22.122Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「KVOController」的封装">
<meta name="twitter:description" content="学习KVO的封装。">
<meta name="twitter:image" content="https://image.chenyalun.com/2019/01/07/001.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> 「KVOController」的封装 · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          「KVOController」的封装
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年1月12日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、使用"><span class="toc-text">一、使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、分类"><span class="toc-text">二、分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、接口"><span class="toc-text">三、接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、FBKVOController实现"><span class="toc-text">四、FBKVOController实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构造器"><span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口实现"><span class="toc-text">接口实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FBKVOInfo数据结构"><span class="toc-text">_FBKVOInfo数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#observe-info-方法"><span class="toc-text">_observe:info:方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、-FBKVOSharedController实现"><span class="toc-text">五、_FBKVOSharedController实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加监听"><span class="toc-text">添加监听</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#移除监听"><span class="toc-text">移除监听</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统KVO调用"><span class="toc-text">系统KVO调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、一个函数"><span class="toc-text">六、一个函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、总结"><span class="toc-text">七、总结</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p></p><p align="center"> 学习KVO的封装。 </p><br><a id="more"></a><p></p>
<p>KVOController源码只有700行左右，读一遍下来还是比较通畅的。这里做一个记录。</p>
<h1 id="一、使用"><a href="#一、使用" class="headerlink" title="一、使用"></a>一、使用</h1><p>使用起来极其简便。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置所观察的对象及其keyPath</span></span><br><span class="line">[<span class="keyword">self</span>.KVOController observe:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, change[<span class="built_in">NSKeyValueChangeNewKey</span>]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这里的<code>self.KVOController</code>可以自己创建，也可以使用默认，因为<code>KVOController</code>是懒加载的。</p>
<p>一般情况下是像上面这样使用的，还有一种情况，不需要强持有被观察者的时候：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.KVOControllerNonRetaining observe:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, change[<span class="built_in">NSKeyValueChangeNewKey</span>]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>只需使用<code>self.KVOControllerNonRetaining</code>即可不增加被观察者<code>self.myButton</code>的引用计数。</p>
<h1 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h1><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> NSObject (FBKVOController)</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) FBKVOController *KVOController;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) FBKVOController *KVOControllerNonRetaining;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>要实现以上使用的方式，是给 <code>NSObject</code> 分类添加两个属性:<code>KVOController</code>和<code>KVOControllerNonRetaining</code>。这个比较简单，使用<code>Runtime</code> 的关联属性即可。值得一提的是作者在 <code>getter</code> 方法里使用了懒加载，只有当使用到<code>KVOController</code>或者<code>KVOControllerNonRetaining</code>的时候，才会创建。当然，也可以选择自行创建。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (FBKVOController *)KVOController &#123;</span><br><span class="line">  <span class="keyword">id</span> controller = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">NSObjectKVOControllerKey</span>);</span><br><span class="line">  <span class="comment">// 懒加载KVOController, 用到时才会创建</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == controller) &#123;</span><br><span class="line">    controller = [FBKVOController controllerWithObserver:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">self</span>.KVOController = controller;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (FBKVOController *)KVOControllerNonRetaining &#123;</span><br><span class="line">  <span class="keyword">id</span> controller = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">NSObjectKVOControllerNonRetainingKey</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == controller) &#123;</span><br><span class="line">    controller = [[FBKVOController alloc] initWithObserver:<span class="keyword">self</span> retainObserved:<span class="literal">NO</span>];</span><br><span class="line">    <span class="keyword">self</span>.KVOControllerNonRetaining = controller;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两个 <code>getter</code> 方法分别对应强引用被观察者和弱引用被观察者。</p>
<h1 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h1><p>由此可以看到，核心功能的实现依赖于<code>FBKVOController</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)controllerWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造器</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer retainObserved:(<span class="built_in">BOOL</span>)retainObserved <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new <span class="built_in">NS_UNAVAILABLE</span>;</span><br></pre></td></tr></table></figure>
<p>构造方法里主要暴露了两种初始化方式，其中通过<code>initWithObserver</code>这个方法可以设置参数<code>retainObserved</code>以表明是否需要强引用被观察者。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> observer;</span><br></pre></td></tr></table></figure>
<p>只有一个只读属性，给出被观察者对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options block:(FBKVONotificationBlock)block;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options action:(SEL)action;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>
<p>作者给出了回调的三个选项：block回调，选择子回调以及 KVO 默认方法回调。可以在添加被观察者的时候自行选择。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPaths options:(<span class="built_in">NSKeyValueObservingOptions</span>)options block:(FBKVONotificationBlock)block;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPaths options:(<span class="built_in">NSKeyValueObservingOptions</span>)options action:(SEL)action;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPaths options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>
<p>考虑到不一定只观察一个对象的一个成员变量，因此作者提供了<code>keyPaths</code>选项，可以同时观察一个对象的多个keyPath：传入一个字符串数组即可。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object keyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="keyword">void</span>)unobserveAll;</span><br></pre></td></tr></table></figure>
<p>移除监听提供三种接口：移除某个对象某个keyPath 的监听，移除对某个对象的监听，取消观察者对所有对象的所有监听。</p>
<h1 id="四、FBKVOController实现"><a href="#四、FBKVOController实现" class="headerlink" title="四、FBKVOController实现"></a>四、FBKVOController实现</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FBKVOController</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSMapTable</span>&lt;<span class="keyword">id</span>, <span class="built_in">NSMutableSet</span>&lt;_FBKVOInfo *&gt; *&gt; *_objectInfosMap;</span><br><span class="line">  pthread_mutex_t _lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FBKVOController</code>主要维护了一个<code>NSMapTable</code>。<code>key</code> 是所观察的对象，<code>value</code> 是<code>NSMutableSet</code>类型的集合(内部元素是<code>_FBKVOInfo</code>类型)。维护一个<code>NSMapTable</code>的原因是：便于观察一个对象的多个<code>keyPath</code>，这个对象作为 <code>key</code>，这许多个<code>keyPath</code>封装成一个个<code>_FBKVOInfo</code>存入<code>NSMutableSet</code>中。另外一个成员变量<code>_lock</code>主要是保证线程安全。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="keyword">nullable</span> <span class="keyword">id</span>)observer retainObserved:(<span class="built_in">BOOL</span>)retainObserved &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) &#123;</span><br><span class="line">    _observer = observer;</span><br><span class="line">    <span class="comment">// 根据是否retainObserved，选择NSMapTable的"强-强"或者"弱-强"</span></span><br><span class="line">    <span class="built_in">NSPointerFunctionsOptions</span> keyOptions = retainObserved ? <span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> : <span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span>;</span><br><span class="line">    _objectInfosMap = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:keyOptions valueOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPersonality</span> capacity:<span class="number">0</span>];</span><br><span class="line">    pthread_mutex_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FBKVOController</code>所有暴露的构造方法接口都指向了上面的那个实现。这个方法只做了三件事: 1，初始化线程锁<code>_lock</code>，2，根据<code>retainObserved</code>参数创建不同类型的<code>NSMapTable</code>，是选择”强-强”还是选择”弱-强”。3，属性<code>observer</code>赋值。</p>
<p>由此可见，<code>FBKVOController</code>本身对被观察者<code>observer</code>是弱引用的(有一个 <code>weak</code> 属性的<code>observer</code>成员变量)，通过维护一个<code>NSMapTable</code>来最终确定对被观察者的强弱引用关系。</p>
<h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">observe:</span>(nullable id)object <span class="string">keyPath:</span>(NSString *)keyPath <span class="string">options:</span>(NSKeyValueObservingOptions)options <span class="string">block:</span>(FBKVONotificationBlock)block &#123;</span><br><span class="line">  <span class="keyword">if</span> (nil == object || <span class="number">0</span> == keyPath.length || NULL == block) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建数据结构_FBKVOInfo</span></span><br><span class="line">  _FBKVOInfo *info = [[_FBKVOInfo alloc] <span class="string">initWithController:</span>self <span class="string">keyPath:</span>keyPath <span class="string">options:</span>options <span class="string">block:</span>block];</span><br><span class="line">  <span class="comment">// 添加对object的观察, 并传入info</span></span><br><span class="line">  [self <span class="string">_observe:</span>object <span class="string">info:</span>info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以添加一个被观察者并且回调是 block 为例。在这个方法里首先是对参数的合理性判断，要求<code>object</code>、<code>keyPath</code>以及<code>block</code>均是合理值。<br> 接着把<code>keyPath</code>、<code>options</code>、<code>block</code>包装成一个数据结构<code>_FBKVOInfo</code>。<br> 最后调用自己的<code>_observe:info:</code>方法，传入<code>object</code>和<code>info</code>。</p>
<h3 id="FBKVOInfo数据结构"><a href="#FBKVOInfo数据结构" class="headerlink" title="_FBKVOInfo数据结构"></a>_FBKVOInfo数据结构</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">_FBKVOInfo </span>: NSObject</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> _FBKVOInfo &#123;</span><br><span class="line"><span class="variable">@public</span></span><br><span class="line">  __weak FBKVOController *_controller;</span><br><span class="line">  <span class="selector-tag">NSString</span> *<span class="selector-tag">_keyPath</span>;</span><br><span class="line">  <span class="selector-tag">NSKeyValueObservingOptions</span> <span class="selector-tag">_options</span>;</span><br><span class="line">  <span class="selector-tag">SEL</span> <span class="selector-tag">_action</span>;</span><br><span class="line">  <span class="selector-tag">void</span> *<span class="selector-tag">_context</span>;</span><br><span class="line">  <span class="selector-tag">FBKVONotificationBlock</span> <span class="selector-tag">_block</span>;</span><br><span class="line">  <span class="selector-tag">_FBKVOInfoState</span> <span class="selector-tag">_state</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_FBKVOInfo</code>是一个数据结构，包含了监听的<code>keyPath</code>、<code>block</code>、选择子、<code>context</code>等等元素。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithController:(FBKVOController *)controller</span><br><span class="line">                           keyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                           options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</span><br><span class="line">                             block:(<span class="keyword">nullable</span> FBKVONotificationBlock)block</span><br><span class="line">                            action:(<span class="keyword">nullable</span> SEL)action</span><br><span class="line">                           context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) &#123;</span><br><span class="line">    _controller = controller;</span><br><span class="line">    _block = [block <span class="keyword">copy</span>];</span><br><span class="line">    _keyPath = [keyPath <span class="keyword">copy</span>];</span><br><span class="line">    _options = options;</span><br><span class="line">    _action = action;</span><br><span class="line">    _context = context;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法的实现就是这样，不过有两个关键点:<code>block</code>和<code>keyPath</code>调用一下 <code>copy</code> 方法。<br><code>keyPath</code>调用一下 <code>copy</code>的原因是，这里的<code>_keyPath</code>是使用<code>__strong</code>修饰的，如果外面传进来的是不可变字符串，自然没有啥问题，可是一旦传进来一个可变字符串，如果直接赋值<code>_keyPath = keyPath;</code>，当这个可变字符串改变就会造成<code>_keyPath</code>也改变，比较容易产生不可控事件，所以调用 <code>copy</code>方法，也即是深复制浅复制的问题。</p>
<p>没有深复制的示例如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"key"</span>];</span><br><span class="line">   <span class="comment">// 假定是_keyPath = keyPath;而不是_keyPath = [keyPath copy];</span></span><br><span class="line">   _FBKVOInfo *info = [[_FBKVOInfo alloc] initWithController:<span class="keyword">self</span> keyPath:str options:<span class="built_in">NSKeyValueObservingOptionNew</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">       </span><br><span class="line">   &#125; action:<span class="keyword">@selector</span>(push) context:<span class="literal">nil</span>];</span><br><span class="line">   [str appendString:<span class="string">@"new"</span>];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, info-&gt;_keyPath); <span class="comment">//info-&gt;_keyPath不符合预期的改变了</span></span><br></pre></td></tr></table></figure>
<p>同样，<code>block</code> 的<code>copy</code>是把<code>block</code>从栈拷贝到堆中，防止被释放。因为<code>block</code>作为参数传入函数不会被 <code>copy</code>，依然在栈上，方法执行完立即释放的。</p>
<blockquote>
<p>在ARC下：大部分情况下系统会把Block自动copy到堆上。</p>
<p>Block作为变量：<br>方法中声明一个 block 的时候是在栈上；<br>引用了外部局部变量或成员变量, 并且有赋值操作（有名字），会被 copy 到堆上；<br>赋值给附有__strong修饰符的id类型的类或者Blcok类型成员变量时；<br>赋值给一个 weak 变量不会被 copy；</p>
<p>Block作为属性：<br>用 copy 修饰会被 copy；</p>
<p>Block作为函数参数：<br>作为参数传入函数不会被 copy，依然在栈上，方法执行完即释放；<br>作为函数的返回值会被 copy 到堆；</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">  <span class="keyword">return</span> [_keyPath hash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)<span class="keyword">object</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nil == <span class="keyword">object</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self == <span class="keyword">object</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (![<span class="keyword">object</span> isKindOfClass:[self <span class="class"><span class="keyword">class</span>]]) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [_keyPath isEqualToString:((_FBKVOInfo *)<span class="keyword">object</span>)-&gt;_keyPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_FBKVOInfo</code>还做了一点其他的事：<br>1.重写了<code>- (NSUInteger)hash;</code>方法，使用<code>_keyPath</code>的 <code>hash</code> 值来作为<code>_FBKVOInfo</code>的 <code>hash</code> 值。分配的这个<code>hash</code>值(即用于查找集合中成员的位置标识)，就是通过<code>hash</code>方法计算得来的，且<code>hash</code>方法返回的<code>hash</code>值最好唯一。<br>2.重写了<code>- (BOOL)isEqual:(id)object;</code>方法，满足<code>Equal</code>的条件有两个: 首先是类对象一致，再者是<code>_keyPath</code>匹配。换句话说，<code>_keyPath</code>决定了<code>_FBKVOInfo</code>是否是同一个。为了优化判等的效率，基于<code>hash</code>的<code>NSSet</code>和<code>NSDictionary</code>在判断成员是否相等时， 会这样做Step1: 成员的<code>hash</code>值是否和目标<code>hash</code>值相等，如果相同进入Step 2，如果不等，直接判断不相等<br>Step 2: <code>hash</code>值相同(即Step 1)的情况下，再进行对象判等， 作为判等的结果。</p>
<blockquote>
<p>hash值是对象判等的必要非充分条件</p>
</blockquote>
<p><code>NSPointerFunctionsObjectPointerPersonality</code>对于 <code>isEqual:</code> 和 <code>hash</code> 使用直接的指针比较。使用移位指针(shifted pointer)来做hash检测及确定两个对象是否相等；同时使用description方法来做描述字符串。</p>
<blockquote>
<p>Personalities determine hashing and equality. NSPointerFunctionsObjectPersonality provides the standard Foundation behavior of using hash and isEqual:. You can also use NSPointerFunctionsObjectPointerPersonality, which treats the contents as objects, but uses direct pointer value comparison; this is useful if you need a collection to work with object identity rather than value.<br>NSPointerFunctionsObjectPointerPersonality 使用 <code>==</code>判断相等<br>NSPointerFunctionsObjectPersonality 使用<code>hash</code>和<code>isEqual:</code>判断相等 </p>
</blockquote>
<h3 id="observe-info-方法"><a href="#observe-info-方法" class="headerlink" title="_observe:info:方法"></a>_observe:info:方法</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)<span class="variable">_observe</span>:(id)object info:(<span class="variable">_FBKVOInfo</span> *)info &#123;</span><br><span class="line">  <span class="comment">// lock</span></span><br><span class="line">  pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">  NSMutableSet *infos = [<span class="variable">_objectInfosMap</span> objectForKey:object];</span><br><span class="line">  <span class="comment">// 检查infos是否存在于_objectInfosMap中</span></span><br><span class="line">  <span class="variable">_FBKVOInfo</span> *existingInfo = [infos member:info];</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != existingInfo) &#123;</span><br><span class="line">    <span class="comment">// 已经存在了，return</span></span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不存在，创建infos并保存于_objectInfosMap中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == infos) &#123;</span><br><span class="line">    infos = [NSMutableSet <span class="built_in">set</span>];</span><br><span class="line">    [<span class="variable">_objectInfosMap</span> setObject:infos forKey:object];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把info添加到infos中</span></span><br><span class="line">  [infos addObject:info];</span><br><span class="line">  pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">  <span class="comment">// _FBKVOSharedController添加观察</span></span><br><span class="line">  [[<span class="variable">_FBKVOSharedController</span> sharedController] observe:object info:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先加锁。把被观察的对象<code>object</code>作为<code>key</code>从自己的<code>_objectInfosMap</code>获取其对应的<code>NSMutableSet</code>类型的集合，如果这个集合包含了已经封装好的<code>info</code>对象，说明已经对这个<code>info</code>添加过监听了，解锁直接 return 就是了。<br>如果这个<code>infos</code>集合不存在，创建。把<code>info</code>元素添加到这个<code>infos</code>集合中。解锁。调用<code>[[_FBKVOSharedController sharedController] observe:object info:info];</code>方法。</p>
<p>可见这个方法主要是使用<code>_objectInfosMap</code>保存了封装好的<code>info</code>对象，具体监听调用逻辑依赖于<code>_FBKVOSharedController</code>。</p>
<h1 id="五、-FBKVOSharedController实现"><a href="#五、-FBKVOSharedController实现" class="headerlink" title="五、_FBKVOSharedController实现"></a>五、_FBKVOSharedController实现</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_FBKVOSharedController</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedController;</span><br><span class="line">- (<span class="keyword">void</span>)observe:(<span class="keyword">id</span>)object info:(<span class="keyword">nullable</span> _FBKVOInfo *)info;</span><br><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">id</span>)object info:(<span class="keyword">nullable</span> _FBKVOInfo *)info;</span><br><span class="line">- (<span class="keyword">void</span>)unobserve:(<span class="keyword">id</span>)object infos:(<span class="keyword">nullable</span> <span class="built_in">NSSet</span> *)infos;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_FBKVOSharedController</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSHashTable</span>&lt;_FBKVOInfo *&gt; *_infos;</span><br><span class="line">  pthread_mutex_t _mutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_FBKVOSharedController</code>是一个单例。作用是观察 <code>_FBKVOInfo</code> 中的 <code>keyPath</code>，并给予回调(回调的类型可以是 <code>block</code>、<code>selector</code>、系统回调方法)。</p>
<p> 暴露出两个方法:</p>
<ol>
<li>添加监听，参数为<code>_infos</code></li>
<li><p>移除监听，参数为<code>_FBKVOInfo</code>或者<code>NSSet</code>类型的<code>infos</code>(容器内的元素仍然是<code>_FBKVOInfo</code>)</p>
<p>内部维护了一个哈希表(NSHashTable)<code>_infos</code>，用于保存这些<code>_FBKVOInfo</code>。除此之外还有一个锁:<code>_mutex</code>，用于实现线程安全。</p>
<p>哈希表的创建:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSHashTable</span> *infos = [<span class="built_in">NSHashTable</span> alloc];</span><br><span class="line">_infos = [infos initWithOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> capacity:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSPointerFunctionsWeakMemory</span>: 持弱指针引用着_FBKVOInfo对象。</span><br><span class="line"><span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> 使用==判定相等。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可见<code>_FBKVOSharedController</code>只是单纯地掌管<code>_FBKVOInfo</code>集合，它只需要解析<code>_FBKVOInfo</code>并给observer回调即可，其他的一切都不关心。</p>
<h2 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">observe:</span>(id)object <span class="string">info:</span>(nullable _FBKVOInfo *)info &#123;</span><br><span class="line">  <span class="keyword">if</span> (nil == info) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// _infos添加对象</span></span><br><span class="line">  pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">  [_infos <span class="string">addObject:</span>info];</span><br><span class="line">  pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">  <span class="comment">// 添加观察，传入的context是info</span></span><br><span class="line">  [object <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>info-&gt;_keyPath <span class="string">options:</span>info-&gt;_options <span class="string">context:</span>(<span class="keyword">void</span> *)info];</span><br><span class="line">  <span class="keyword">if</span> (info-&gt;_state == _FBKVOInfoStateInitial) &#123;</span><br><span class="line">    info-&gt;_state = _FBKVOInfoStateObserving; <span class="comment">// 初始状态转监听状态</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;_state == _FBKVOInfoStateNotObserving) &#123; <span class="comment">// 未监听状态便移除</span></span><br><span class="line">    <span class="comment">// this could happen when `NSKeyValueObservingOptionInitial` is one of the NSKeyValueObservingOptions,</span></span><br><span class="line">    <span class="comment">// and the observer is unregistered within the callback block.</span></span><br><span class="line">    <span class="comment">// at this time the object has been registered as an observer (in Foundation KVO),</span></span><br><span class="line">    <span class="comment">// so we can safely unobserve it.</span></span><br><span class="line">    <span class="comment">// NSKeyValueObservingOptionInitial：添加观察者时就触发回调，并且在后面赋值时也会触发回调，但是都只返回NSKeyValueChangeKindKey。观察者在callback block中取消观察，所以在这里removeObserver</span></span><br><span class="line">    [object <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>info-&gt;_keyPath <span class="string">context:</span>(<span class="keyword">void</span> *)info];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器中添加 info 元素，添加监听。</p>
<h2 id="移除监听"><a href="#移除监听" class="headerlink" title="移除监听"></a>移除监听</h2><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)unobserve:(id)object info:(nullable <span class="variable">_FBKVOInfo</span> *)info &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == info) return;</span><br><span class="line">  <span class="comment">// 哈希表中移除info</span></span><br><span class="line">  pthread_mutex_lock(&amp;<span class="variable">_mutex</span>);</span><br><span class="line">  [<span class="variable">_infos</span> removeObject:info];</span><br><span class="line">  pthread_mutex_unlock(&amp;<span class="variable">_mutex</span>);</span><br><span class="line">  <span class="comment">// 移除监听</span></span><br><span class="line">  <span class="keyword">if</span> (info-&gt;<span class="variable">_state</span> == <span class="variable">_FBKVOInfoStateObserving</span>) &#123;</span><br><span class="line">    [object removeObserver:self forKeyPath:info-&gt;<span class="variable">_keyPath</span> context:(void *)info];</span><br><span class="line">  &#125;</span><br><span class="line">  info-&gt;<span class="variable">_state</span> = <span class="variable">_FBKVOInfoStateNotObserving</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器中移除 info 元素，移除监听。</p>
<h2 id="系统KVO调用"><a href="#系统KVO调用" class="headerlink" title="系统KVO调用"></a>系统KVO调用</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change</span><br><span class="line">                       context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context &#123;</span><br><span class="line">  _FBKVOInfo *info;</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    <span class="comment">// 看看info是否存在于_infos中，如果存在，返回info</span></span><br><span class="line">    info = [_infos member:(__bridge <span class="keyword">id</span>)context];</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != info) &#123;</span><br><span class="line">    <span class="comment">// 局部变量强引用controller</span></span><br><span class="line">    FBKVOController *controller = info-&gt;_controller;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != controller) &#123;</span><br><span class="line">      <span class="comment">// 局部变量强引用observer</span></span><br><span class="line">      <span class="keyword">id</span> observer = controller.observer;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">nil</span> != observer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;_block) &#123;  <span class="comment">// 回调 block</span></span><br><span class="line">          <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *changeWithKeyPath = change;</span><br><span class="line">          <span class="keyword">if</span> (keyPath) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *mChange = [<span class="built_in">NSMutableDictionary</span> dictionaryWithObject:keyPath forKey:FBKVONotificationKeyPathKey];</span><br><span class="line">            [mChange addEntriesFromDictionary:change];</span><br><span class="line">            changeWithKeyPath = [mChange <span class="keyword">copy</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          info-&gt;_block(observer, object, changeWithKeyPath);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;_action) &#123; <span class="comment">// 回调 selector</span></span><br><span class="line">          [observer performSelector:info-&gt;_action withObject:change withObject:object];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 调用KVO 系统方法</span></span><br><span class="line">          [observer observeValueForKeyPath:keyPath ofObject:object change:change context:info-&gt;_context];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终在系统方法中给予不同类型的回调。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(uint8_t, <span class="variable">_FBKVOInfoState</span>) &#123;</span><br><span class="line">  <span class="variable">_FBKVOInfoStateInitial</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="variable">_FBKVOInfoStateObserving</span>,</span><br><span class="line">  <span class="variable">_FBKVOInfoStateNotObserving</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>作者使用了三个枚举值来记录监听状态。会不会是多此一举呢？不会。作用主要体现在添加监听的方法里有个移除监听操作：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 添加观察，传入的context是info</span></span><br><span class="line">[<span class="function"><span class="title">object</span> addObserver:self forKeyPath:info-&gt;</span>_<span class="function"><span class="title">keyPath</span> options:info-&gt;</span>_options context:(void *)info];</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="title">if</span> (info-&gt;</span>_state == _FBKVOInfoStateInitial) &#123;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>_state = _FBKVOInfoStateObserving; <span class="comment">// 初始状态转监听状态</span></span><br><span class="line">  &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (info-&gt;</span>_state == _FBKVOInfoStateNotObserving) &#123; <span class="comment">// 未监听状态便移除</span></span><br><span class="line">    [<span class="function"><span class="title">object</span> removeObserver:self forKeyPath:info-&gt;</span>_keyPath context:(void *)info];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>“未监听状态便移除“是怎么出现的？示例如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.KVOController observe:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span> options:<span class="built_in">NSKeyValueObservingOptionInitial</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">     [<span class="keyword">self</span>.KVOController unobserve:<span class="keyword">self</span>.myButton keyPath:<span class="string">@"backgroundColor"</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>包含了<code>NSKeyValueObservingOptionInitial</code>选项且在回调中移除了监听就会出现这种情况。因为如果有<code>NSKeyValueObservingOptionInitial</code>选项，在添加监听的时候就会有回调。调用栈如下：<br><img src="https://image.chenyalun.com/2019/01/07/001.png" alt></p>
<p>执行到<code>[object addObserver:self forKeyPath:info-&gt;_keyPath options:info-&gt;_options context:(void *)info];</code>这行代码的时候，首先添加监听，接着调用回调，而回调中又移除了观察，这时info的状态被设置为<code>_FBKVOInfoStateNotObserving</code>。接着进入了下面的 if-else 判断中，才有了移除监听的操作。可见逻辑非常严谨。</p>
<p>NSKeyValueObservingOption参考：</p>
<blockquote>
<p>NSKeyValueObservingOptionNew：接收方法中使用change参数传入变化后的新值，键为：&gt;NSKeyValueChangeNewKey；<br>NSKeyValueObservingOptionOld：接收方法中使用change参数传入变化前的旧值，键为：&gt;NSKeyValueChangeOldKey；<br>NSKeyValueObservingOptionInitial：注册之后立刻调用接收方法，如果配置了&gt;NSKeyValueObservingOptionNew，change参数内容会包含新值，键为：&gt;NSKeyValueChangeNewKey；<br>NSKeyValueObservingOptionPrior：如果加入这个参数，接收方法会在变化前后分别调用一次，共两&gt;次，变化前的通知change参数包含notificationIsPrior = 1。其他内容根据&gt;NSKeyValueObservingOptionNew和NSKeyValueObservingOptionOld的配置确定。</p>
</blockquote>
<h1 id="六、一个函数"><a href="#六、一个函数" class="headerlink" title="六、一个函数"></a>六、一个函数</h1><p>其实不是一个函数，不过是为了实现一个功能，核心还是一个函数。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.枚举字符串化</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *describe_option(<span class="built_in">NSKeyValueObservingOptions</span> option) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionNew</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionNew"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionOld</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionOld"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionInitial</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionInitial"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSKeyValueObservingOptionPrior</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"NSKeyValueObservingOptionPrior"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"unexpected option %tu"</span>, option);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.拼接option</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> append_option_description(<span class="built_in">NSMutableString</span> *s, <span class="built_in">NSUInteger</span> option) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == s.length) &#123;</span><br><span class="line">        [s appendString:describe_option(option)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [s appendString:<span class="string">@"|"</span>];</span><br><span class="line">        [s appendString:describe_option(option)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.NSKeyValueObservingOptions类型值遍历</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSUInteger</span> enumerate_flags(<span class="built_in">NSUInteger</span> *ptrFlags) &#123;</span><br><span class="line">    <span class="built_in">NSCAssert</span>(ptrFlags, <span class="string">@"expected ptrFlags"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ptrFlags) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> flags = *ptrFlags;</span><br><span class="line">    <span class="keyword">if</span> (!flags)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> flag = <span class="number">1</span> &lt;&lt; __builtin_ctzl(flags);</span><br><span class="line">    flags &amp;= ~flag;</span><br><span class="line">    *ptrFlags = flags;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.把options所有值都拼出来</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *describe_options(<span class="built_in">NSKeyValueObservingOptions</span> options) &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *s = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    <span class="built_in">NSUInteger</span> option;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != (option = enumerate_flags(&amp;options))) &#123;</span><br><span class="line">        append_option_description(s, option);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不使用 switch-case 把位移枚举的值遍历出来了。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Similar to __builtin_ctz, except the argument type is unsigned long.</span></span><br><span class="line"><span class="comment">// __builtin_ctz(x)：x末尾0的个数</span></span><br><span class="line"><span class="comment">// 左移__builtin_ctz(x)位得到原先的枚举值</span></span><br><span class="line">NSUInteger flag = <span class="number">1</span> &lt;&lt; __builtin_ctzl(<span class="keyword">flags</span>);</span><br><span class="line"><span class="comment">// flags 去除已经取到的值</span></span><br><span class="line"><span class="keyword">flags</span> &amp;= ~flag;</span><br><span class="line"><span class="comment">// 把更新后的flags赋予指向ptrFlags的指针</span></span><br><span class="line">*ptrFlags = <span class="keyword">flags</span>;</span><br></pre></td></tr></table></figure>
<p>不失为一个好办法。</p>
<h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><blockquote>
<p>使用 KVOController 进行键值观测可以说完美地解决了在使用原生 KVO 时遇到的各种问题。</p>
<p>1.不需要手动移除观察者；<br>2.实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；<br>3.使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；<br>4.每一个 keyPath 会对应一个属性，不需要在 block 中使用 if 判断 keyPath；</p>
</blockquote>
<p>以上引自draveness。解释如下：<br>1.NSMapTable 可以持有键和值的弱引用，当键或者值当中的一个被释放时，整个这一项就会被移除掉。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里使用被观察者observer作为强引用或者弱引用的key，使用_FBKVOInfo作为强引用的value</span></span><br><span class="line"><span class="built_in">NSPointerFunctionsOptions</span> keyOptions = retainObserved ? <span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> : <span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span>;</span><br><span class="line">_objectInfosMap = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:keyOptions valueOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPersonality</span> capacity:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>2.因为是在@selector(observeValueForKeyPath:ofObject:change:context:)中处理的回调。<br>3.使用FBKVONotificationBlock。<br>4._FBKVOInfo封装。</p>
<p>纵观全部代码，作者首先给分类添加了两个属性，用于接口调用。这些属性都指向了FBKVOController，FBKVOController主要维护了一个NSMapTable。key 是所观察的对象，value 是NSMutableSet类型的集合，其内部元素是_FBKVOInfo类型对象。一个_FBKVOInfo对象对应一个信息封装。之所以使用NSMapTable集合是便于对同一个对象的多个keyPath进行观察，同时处理被观察者的强弱引用。另外_FBKVOInfo对象是对FBKVOController、keyPath、context、回调block等信息的封装。最后，各个FBKVOController把所有对观察的处理交给单例_FBKVOSharedController，这个单例调用系统KVO方法回调、处理包含所有_FBKVOInfo对象的NSHashTable集合。</p>
<blockquote>
<p>参考资料<br><a href="https://github.com/draveness/analyze/blob/master/contents/KVOController/KVOController.md" target="_blank" rel="noopener">https://github.com/draveness/analyze/blob/master/contents/KVOController/KVOController.md</a><br><a href="https://blog.csdn.net/DonnyDN/article/details/77750751" target="_blank" rel="noopener">https://blog.csdn.net/DonnyDN/article/details/77750751</a><br><a href="https://www.jianshu.com/p/915356e280fc" target="_blank" rel="noopener">https://www.jianshu.com/p/915356e280fc</a><br><a href="https://blog.kyleduo.com/2014/10/20/ios_learning-kvo/" target="_blank" rel="noopener">https://blog.kyleduo.com/2014/10/20/ios_learning-kvo/</a></p>
</blockquote>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/iOS开发/">iOS开发</a>
            
              <a href="/tags/阅读/">阅读</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/01/20/Weak Associated Object/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Weak Associated Object</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019/01/02/读「YYCache」/">
        <span class="next-text nav-default">读「YYCache」</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
