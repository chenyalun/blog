<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="多线程与Runloop拾遗"><meta name="keywords" content="iOS开发, Ya"><link rel="alternate" href="/atom.xml" title="Ya"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="https://blog.chenyalun.com/2019/09/30/多线程与Runloop拾遗/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>多线程与Runloop拾遗 - Ya</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/阅读/">
        <li class="mobile-menu-item">标签
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            标签
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">多线程与Runloop拾遗
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-09-30
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本"><span class="toc-text">基本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁"><span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-sync类型"><span class="toc-text">dispatch_sync类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-once类型"><span class="toc-text">dispatch_once类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-apply"><span class="toc-text">dispatch_apply</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步"><span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存取方法加锁"><span class="toc-text">存取方法加锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Runloop"><span class="toc-text">Runloop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用"><span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1，控制线程周期"><span class="toc-text">1，控制线程周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2，解决NSTimer在UIScrollView滑动时停止工作"><span class="toc-text">2，解决NSTimer在UIScrollView滑动时停止工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3，监控应用卡顿"><span class="toc-text">3，监控应用卡顿</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方案一"><span class="toc-text">方案一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方案二"><span class="toc-text">方案二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方案三"><span class="toc-text">方案三</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4，应用起死回生"><span class="toc-text">4，应用起死回生</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自实现"><span class="toc-text">自实现</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><p align="center"> 回顾了多线程、Runloop相关的重点知识。 </p>

<a id="more"></a>
<p>比较零碎。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>首先简单回顾几个常见的术语：<br>同步：只能在当前线程中执行任务，不具备开启新线程的能力。在队列里面的任务完成之前会一直等待。<br>异步：可以在新的线程中执行任务，具备开启新线程的能力。它不会做任何等待，可以继续执行任务。<br>串行：一个任务执行完毕后，再执行下一个任务。<br>并发：多个任务并发（同时）执行，并发队列的并发功能只有在异步函数下才有效。</p>
<p>自己创建的串行队列（非主队列），使用异步方式，会开启新线程执行任务。<br>并发队列下的异步方式，会开启新线程，并发执行任务。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="dispatch-sync类型"><a href="#dispatch-sync类型" class="headerlink" title="dispatch_sync类型"></a>dispatch_sync类型</h3><p>主队列下的同步执行，会产生死锁。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在主线程执行task方法</span></span><br><span class="line">- (<span class="keyword">void</span>)task &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"a任务"</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 追加到主队列中按照顺序执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"b任务"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"c任务"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是同步执行，所以c任务需要等待b任务执行完毕之后才可以执行；又因为是主队列且a任务和c任务都要在主线程执行，所以b任务需要等待（a任务和）c任务执行完毕之后才可以执行；这样a任务与c任务互相等待产生了死锁。</p>
<p>再比如<a href="http://southpeak.github.io/2016/09/20/ios-techset-8/" target="_blank" rel="noopener">知识小集</a>中的一个例子：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(<span class="string">"com.app.test"</span>, NULL)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">queue</span>, ^&#123; </span><br><span class="line">    dispatch_sync(<span class="name">queue</span>, ^&#123;</span><br><span class="line">        // 向串行队列queue中追加任务B</span><br><span class="line">        NSLog(@<span class="string">"B任务"</span>)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"A任务"</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>向串行队列queue中追加任务B，B任务需要等待A任务执行完毕才能执行，由于是串行队列下的同步执行，A任务需要等待B任务执行完毕才能执行，二者互相等待产生死锁。</p>
<p>可以总结，<strong>使用sync函数向当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</strong>。</p>
<h3 id="dispatch-once类型"><a href="#dispatch-once类型" class="headerlink" title="dispatch_once类型"></a>dispatch_once类型</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">void test() &#123;</span><br><span class="line">    static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class="line">        test()<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">"This is a test"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatch_once的<a href="http://southpeak.github.io/2016/08/31/ios-techset-7/" target="_blank" rel="noopener">递归调用</a>也会产生死锁。</p>
<blockquote>
<p>onceToken在第一次执行block之前，其值将由NULL变为指向第一个调用者的指针(&amp;dow)。如果在block完成之前，有其它的调用者进来，则会把这些调用者放到一个waiter链表中(走else分支)，直到block执行完成。waiter链中的每个调用者都会等待一个信号量(dow.dow_sema)。在block执行完成后，除了将onceToken置为DISPATCH_ONCE_DONE外，还会去遍历waiter链中的所有waiter，抛出相应的信号量，以告知waiter们调用结束。<br>递归调用test()时，第二次调用作为一个waiter，在等待block完成，而block的完成依赖于test()的执行完成，这就成了一个死锁。</p>
</blockquote>
<p>下一篇文章看一下GCD源码吧。。</p>
<h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h3><p>tutuge介绍了一个<a href="http://tutuge.me/2015/04/03/something-about-gcd/" target="_blank" rel="noopener">例子</a>：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(<span class="string">"com.app.test"</span>, DISPATCH_QUEUE_SERIAL)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_apply(<span class="number">3</span>, queue, ^(<span class="name">size_t</span> i) &#123;</span><br><span class="line">    NSLog(@<span class="string">"apply loop outside %zu"</span>, j)<span class="comment">;</span></span><br><span class="line">    // 死锁</span><br><span class="line">    dispatch_apply(<span class="number">3</span>, queue, ^(<span class="name">size_t</span> j) &#123;</span><br><span class="line">        NSLog(@<span class="string">"apply loop inside %zu"</span>, j)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>dispatch_apply是将block追加到指定的Queue中执行指定次数，并等待全部block执行完毕，也即它用的是dispatch_sync。这自然解释了为啥会死锁了。官方文档上苹果推荐的使用方式是配合dispatch_get_global_queue全局队列。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>iOS中的线程同步方案有很多：</p>
<ul>
<li>OSSpinLock（自旋锁，忙等）</li>
<li>os_unfair_lock（休眠，iOS10+）</li>
<li>pthread_mutex（互斥锁，可递归，可条件，休眠）</li>
<li>dispatch_semaphore（信号量）</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)（串行同步）</li>
<li>NSLock（封装mutex）</li>
<li>NSRecursiveLock（封装mutex递归锁）</li>
<li>NSCondition（封装mutex条件锁）</li>
<li>NSConditionLock（封装NSCondition，可设置条件值）</li>
<li>@synchronized（封装mutex递归锁，语法简单）</li>
</ul>
<p>ibireme在<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">《不再安全的OSSpinLock》</a>中介绍了自旋锁（比如OSSpinLock）优先级翻转的问题：<br>假定有优先级较高的线程a，优先级较低的线程b，一开始由线程b执行任务，则加锁，线程a处于忙等状态。但是由于线程a的优先级较高，获得的时间片也较多，那么线程b的时间片比较少，可能一直无法往下执行，无法释放锁。于是造成线程a一直处于忙等状态，而优先级较低的线程b却在一直执行任务，便出现了优先级反转。<br>当使用互斥锁时就不会有这种问题：线程a不会忙等，而是休眠，也即不会占用CPU资源，这样线程b的任务很快执行完毕并释放锁，线程a的任务就得到执行了。</p>
<p>什么情况使用自旋锁比较划算？</p>
<ul>
<li>预计线程等待锁的时间很短</li>
<li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li>
<li>CPU资源不紧张</li>
<li>多核处理器</li>
</ul>
<p>什么情况使用互斥锁比较划算？</p>
<ul>
<li>预计线程等待锁的时间较长</li>
<li>单核处理器</li>
<li>临界区有IO操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
<p>在开发中常用的是信号量，性能较高（次于OSSpinLock和os_unfair_lock）且方便。</p>
<h2 id="存取方法加锁"><a href="#存取方法加锁" class="headerlink" title="存取方法加锁"></a>存取方法加锁</h2><p>nonatomic与atomic是很常见的话题。atomic保证了getter和setter的原子性，方法内部是线程安全的。但是不能保证使用属性过程中的线程安全。而大多数情况下，需要保证“使用属性过程中的线程安全”。所以，这就造成我们经常选择nonatomic：<br>1， 项目中有太多的属性设置取值操作，每次都加锁，消耗性能；<br>2， 并不是每个属性取值设值操作都需要加锁的，完全可以在真正需要的地方自己加锁；</p>
<p>对于属性来说，最理想的自然是读操作，允许多条线程并发执行，写操作，同一时刻只能一条线程执行。实现方案有两种，读写锁pthread_rwlock或者GCD中的dispatch_barrier_async。个人喜欢第二种。<br><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">@synthesize <span class="built_in">name</span> = <span class="variable">_name</span>;</span><br><span class="line">- (void)<span class="built_in">setName</span>:(NSString *)<span class="built_in">name</span> &#123;</span><br><span class="line">    dispatch_barrier_sync(self.propertyQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">name</span> != <span class="variable">_name</span>) &#123;</span><br><span class="line">            <span class="variable">_name</span> = <span class="built_in">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)<span class="built_in">name</span> &#123;</span><br><span class="line">    <span class="variable">__block</span> NSString *<span class="built_in">name</span> = <span class="literal">nil</span>;</span><br><span class="line">    dispatch_sync(self.propertyQueue, ^&#123;</span><br><span class="line">        <span class="built_in">name</span> = <span class="variable">_name</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    return <span class="built_in">name</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>Runloop与线程</strong><br>每条线程都有唯一的一个与之对应的RunLoop对象，RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value。线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建，<br>会在线程结束时销毁。主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop。</p>
<p><strong>Runloop的Mode</strong><br>CFRunLoopModeRef代表RunLoop的运行模式。一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer。RunLoop启动时只能选择其中一个Mode，作为currentMode<br>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入（这样做可以保证专心处理一个Mode下的事件）。不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响。如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出。</p>
<p>kCFRunLoopDefaultMode是App的默认Mode，通常主线程是在这个Mode下运行。UITrackingRunLoopMode是界面跟踪 Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响。</p>
<p><strong>Mode下的Source0/Source1/Timer/Observer</strong><br>Source0</p>
<ul>
<li>触摸事件处理</li>
<li>performSelector:onThread:</li>
</ul>
<p>Source1</p>
<ul>
<li>基于Port的线程间通信（比如<a href="https://blog.chenyalun.com/2019/01/28/NSNotificationCenter探索/#三、子线程通知">不同线程间的Notification</a>）</li>
<li>系统事件捕捉</li>
</ul>
<p>Timers</p>
<ul>
<li>NSTimer</li>
<li>performSelector:withObject:afterDelay:（内部也是定时器）</li>
</ul>
<p>Observers</p>
<ul>
<li>用于监听RunLoop的状态</li>
<li>UI刷新（BeforeWaiting）</li>
<li>Autorelease pool（BeforeWaiting）</li>
</ul>
<p><strong>Runloop的内部逻辑</strong><br>01、通知Observers：进入Loop<br>02、通知Observers：即将处理Timers<br>03、通知Observers：即将处理Sources<br>04、处理Blocks<br>05、处理Source0（可能会再次处理Blocks）<br>06、如果存在Source1，就跳转到第8步<br>07、通知Observers：开始休眠（等待消息唤醒）<br>08、通知Observers：结束休眠（被某个消息唤醒）<br>    （01）&gt; 处理Timer<br>    （02）&gt; 处理GCD Async To Main Queue<br>    （03）&gt; 处理Source1<br>09、处理Blocks<br>10、根据前面的执行结果，决定如何操作<br>    （01）&gt; 回到第02步<br>    （02）&gt; 退出Loop<br>11、通知Observers：退出Loop</p>
<p><strong>Runloop状态监听</strong><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 创建Observer</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">   <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">       <span class="keyword">case</span> kCFRunLoopEntry: &#123;</span><br><span class="line">           <span class="built_in">CFRunLoopMode</span> mode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"kCFRunLoopEntry - %@"</span>, mode);</span><br><span class="line">           <span class="built_in">CFRelease</span>(mode);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">           </span><br><span class="line">       <span class="keyword">case</span> kCFRunLoopExit: &#123;</span><br><span class="line">           <span class="built_in">CFRunLoopMode</span> mode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"kCFRunLoopExit - %@"</span>, mode);</span><br><span class="line">           <span class="built_in">CFRelease</span>(mode);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">           </span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Observer到RunLoop中</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure></p>
<p><strong>休眠的实现原理</strong><br>依靠mach_msg()函数，做到用户态处理消息，内核态等待消息，没有消息就让线程休眠。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1，控制线程周期"><a href="#1，控制线程周期" class="headerlink" title="1，控制线程周期"></a>1，控制线程周期</h3><p>借助Runloop实现线程保活：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAPermenantThread</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *innerThread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAPermenantThread</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _innerThread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">CFRunLoopSourceContext</span> context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">CFRunLoopSourceRef</span> source = <span class="built_in">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="number">0</span>, &amp;context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(source);</span><br><span class="line">            <span class="comment">// 第3个参数：returnAfterSourceHandled，设置为true，代表执行完source后就会退出当前loop</span></span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        [_innerThread start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))task &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !task) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(executeInnerTask:) onThread:<span class="keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stopThread) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - private methods</span></span><br><span class="line">- (<span class="keyword">void</span>)stopThread &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeInnerTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))task &#123;</span><br><span class="line">    <span class="keyword">if</span> (task) task();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2，解决NSTimer在UIScrollView滑动时停止工作"><a href="#2，解决NSTimer在UIScrollView滑动时停止工作" class="headerlink" title="2，解决NSTimer在UIScrollView滑动时停止工作"></a>2，解决NSTimer在UIScrollView滑动时停止工作</h3><p>修改Runloop的Mode即可。</p>
<h3 id="3，监控应用卡顿"><a href="#3，监控应用卡顿" class="headerlink" title="3，监控应用卡顿"></a>3，监控应用卡顿</h3><p>常见原因：<br>死锁：主线程拿到锁 A，需要获得锁 B，而同时某个子线程拿了锁 B，需要锁 A，这样相互等待就死锁了。<br>抢锁：主线程需要访问 DB，而此时某个子线程往 DB 插入大量数据。通常抢锁的体验是偶尔卡一阵子，过会就恢复了。<br>主线程大量 IO：主线程为了方便直接写入大量数据，会导致界面卡顿。<br>主线程大量计算：算法不合理，导致主线程某个函数占用大量 CPU。<br>大量的 UI 绘制：复杂的 UI、图文混排等，带来大量的 UI 绘制。</p>
<blockquote>
<p>主线程绝大部分计算或者绘制任务都是以Runloop为单位发生。单次Runloop如果时长超过16ms，就会导致UI体验的卡顿。    ——by mrpeak前辈</p>
</blockquote>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>创建一个子线程，监控主线程的活动情况，如果发现有卡顿，就将堆栈dump下来。如何监控？主要利用Runloop状态监听，kCFRunLoopExit的时间，减去kCFRunLoopEntry的时间，获得一次Runloop所耗费的时间。<br>实际上，主线程的RunLoop是在应用启动时自动开启的，主线程中的block、交互事件、以及其他任务都是在kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting之间执行，所以可以在即将开始执行Sources时，记录一下起始时间，并标记任务状态为YES，将要进入睡眠状态时，标记置为NO。</p>
<p>第一种方式是添加一个定时器，设定为2秒一次回调，也即每隔2秒计算一下时间差看是否会有卡顿发生。有同学已经给出了<a href="http://hl1987.com/2018/04/27/RunLoop总结：RunLoop的应用场景（四）App卡顿监测/" target="_blank" rel="noopener">方法</a>。</p>
<p>每次定时器回调时，若任务状态仍然为YES（说明Runloop在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间），则判断时间有没有超过阈值：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> RunLoopTimerCallBack(<span class="built_in">CFRunLoopTimerRef</span> timer, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">     YAFluencyMonitorManager *manager = (__bridge YAFluencyMonitorManager *)info;</span><br><span class="line">     <span class="keyword">if</span> (!manager.excuting) <span class="keyword">return</span>;</span><br><span class="line">     <span class="built_in">NSTimeInterval</span> excuteTime = [<span class="built_in">NSDate</span>.date timeIntervalSinceDate:manager.startDate];</span><br><span class="line">     <span class="keyword">if</span> (excuteTime &gt;= manager.fault) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"线程卡顿了%f秒"</span>, excuteTime);</span><br><span class="line">         [manager handleStackInfo];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，我从数据库中读出1000条数据，再把这1000条数据写到数据库中，这些操作都在主线程进行，利用第三方框架CrashReporter可以看到函数调用栈：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">Thread <span class="number">0</span>:</span><br><span class="line"><span class="number">0</span>   libsystem_kernel.dylib              <span class="number">0x00000001874cb42c</span> fsync + <span class="number">8</span></span><br><span class="line"><span class="number">1</span>   libsqlite3.dylib                    <span class="number">0x00000001893549ec</span> sqlite3_randomness + <span class="number">2520</span></span><br><span class="line"><span class="number">2</span>   libsqlite3.dylib                    <span class="number">0x000000018934a780</span> sqlite3_free_table + <span class="number">62008</span></span><br><span class="line"><span class="number">3</span>   libsqlite3.dylib                    <span class="number">0x0000000189335d0c</span> sqlite3_value_text + <span class="number">23504</span></span><br><span class="line"><span class="number">4</span>   libsqlite3.dylib                    <span class="number">0x0000000189301f44</span> sqlite3_finalize + <span class="number">3608</span></span><br><span class="line"><span class="number">5</span>   libsqlite3.dylib                    <span class="number">0x000000018932e774</span> sqlite3_step + <span class="number">60828</span></span><br><span class="line"><span class="number">6</span>   libsqlite3.dylib                    <span class="number">0x000000018931fb5c</span> sqlite3_step + <span class="number">388</span></span><br><span class="line"><span class="number">7</span>   FMDB                                <span class="number">0x00000001051b39d0</span> -[FMDatabase executeUpdate:error:withArgumentsInArray:orDictionary:orVAList:] + <span class="number">3152</span></span><br><span class="line"><span class="number">8</span>   FMDB                                <span class="number">0x00000001051b4038</span> -[FMDatabase executeUpdate:] + <span class="number">96</span></span><br><span class="line"><span class="number">9</span>   FMDB                                <span class="number">0x00000001051b4ab8</span> -[FMDatabase commit] + <span class="number">48</span></span><br><span class="line"><span class="number">10</span>  FMDB                                <span class="number">0x00000001051bb270</span> __46-[FMDatabaseQueue beginTransaction:withBlock:]_block_invoke + <span class="number">592</span></span><br><span class="line"><span class="number">11</span>  libdispatch.dylib                   <span class="number">0x00000001053d2bd8</span> _dispatch_client_callout + <span class="number">16</span></span><br><span class="line"><span class="number">12</span>  libdispatch.dylib                   <span class="number">0x00000001053e1858</span> _dispatch_lane_barrier_sync_invoke_and_complete + <span class="number">124</span></span><br><span class="line"><span class="number">13</span>  FMDB                                <span class="number">0x00000001051bafd8</span> -[FMDatabaseQueue beginTransaction:withBlock:] + <span class="number">176</span></span><br><span class="line"><span class="number">14</span>  FMDB                                <span class="number">0x00000001051bb2dc</span> -[FMDatabaseQueue inTransaction:] + <span class="number">80</span></span><br><span class="line"><span class="number">15</span>  Splash                              <span class="number">0x0000000104cb0be4</span> +[YAFeedPhotoDBManager savePhotoListToDataBase:] + <span class="number">388</span></span><br><span class="line"><span class="number">16</span>  Splash                              <span class="number">0x0000000104c9f380</span> __65-[YAFeedAPIManager parseAPIManager:successResult:isFromDataBase:]_block_invoke + <span class="number">80</span></span><br><span class="line"><span class="number">17</span>  Splash                              <span class="number">0x0000000104cb09d8</span> __73+[YAFeedPhotoDBManager loadPhotoListWithStartTime:limitCount:completion:]_block_invoke + <span class="number">60</span></span><br><span class="line"><span class="number">18</span>  libdispatch.dylib                   <span class="number">0x00000001053d17fc</span> _dispatch_call_block_and_release + <span class="number">24</span></span><br><span class="line"><span class="number">19</span>  libdispatch.dylib                   <span class="number">0x00000001053d2bd8</span> _dispatch_client_callout + <span class="number">16</span></span><br><span class="line"><span class="number">20</span>  libdispatch.dylib                   <span class="number">0x00000001053e0c34</span> _dispatch_main_queue_callback_4CF + <span class="number">1316</span></span><br><span class="line"><span class="number">21</span>  CoreFoundation                      <span class="number">0x000000018764f3a8</span> &lt;redacted&gt; + <span class="number">12</span></span><br><span class="line"><span class="number">22</span>  CoreFoundation                      <span class="number">0x000000018764a39c</span> &lt;redacted&gt; + <span class="number">2004</span></span><br><span class="line"><span class="number">23</span>  CoreFoundation                      <span class="number">0x00000001876498a0</span> CFRunLoopRunSpecific + <span class="number">464</span></span><br><span class="line"><span class="number">24</span>  GraphicsServices                    <span class="number">0x00000001915a1328</span> GSEventRunModal + <span class="number">104</span></span><br><span class="line"><span class="number">25</span>  UIKitCore                           <span class="number">0x000000018b73a740</span> UIApplicationMain + <span class="number">1936</span></span><br><span class="line"><span class="number">26</span>  Splash                              <span class="number">0x0000000104cac944</span> main + <span class="number">120</span></span><br><span class="line"><span class="number">27</span>  libdyld.dylib                       <span class="number">0x00000001874d4360</span> &lt;redacted&gt; + <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>可以看到，问题就在<code>+[YAFeedPhotoDBManager savePhotoListToDataBase:]</code>这行代码了。</p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>第二种方式主要是对检测粒度的改进。比如，卡顿阈值T=500ms、卡顿次数N=1，可以判定为单次耗时较长的一次有效卡顿；而卡顿阈值T=50ms、卡顿次数N=5，可以判定为频次较快的一次有效卡顿。这样就需要对每次Runloop时间段做处理。<a href="https://juejin.im/post/5cacb2baf265da03904bf93b" target="_blank" rel="noopener">minjing_linlv同学</a>有给出Demo，作者没有使用定时器来定时监测卡顿状况，而是“实时计算两个状态区域之间的耗时是否到达某个阀值”。</p>
<p>把代码down下来试了一试，发现作者是把卡顿耗时和卡顿次数两个条件综合起来判断的，耗时的实现是利用dispatch_semaphore_wait函数，设置了超时参数。</p>
<p>不过代码这块有几个地方值得商榷：<br>1，子线程卡顿监控最好开一个独立的常驻线程，而作者却用了一个全局队列。<br>2，“发生一次有效的卡顿回调函数”，设置这种接口而且暴露给外界不知道意义何在，发生卡顿难道不是这个单例自己处理并上报吗？<br>3，在setter方法中手动调用willChangeValueForKey和didChangeValueForKey，貌似是为了手动触发KVO，但是却又不重写automaticallyNotifiesObserversForName方法，那这么做图啥？</p>
<p>只看作者思路，这种方式较方案一显得细腻，还是挺棒的。</p>
<h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>其实最棒的还是<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207890859&amp;idx=1&amp;sn=e98dd604cdb854e7a5808d2072c29162&amp;scene=4" target="_blank" rel="noopener">《微信iOS卡顿监控系统》</a>这篇文章介绍的。</p>
<p>总结一下key point：<br>1，CPU 占用超过了100%和主线程 Runloop 执行了超过2秒综合起来判断是一次卡顿发生了（需要双核iPhone）。<br>2，遇到相同的卡顿堆栈，按照斐波那契数列将检查时间递增，避免同一个卡顿写入多个文件，也避免检测线程围着同一个卡顿空转。<br>3，主要根据堆栈的最内层归类，这样能够将同一原因的卡顿归类起来。<br>4，抽样上报，减小后台压力。</p>
<h3 id="4，应用起死回生"><a href="#4，应用起死回生" class="headerlink" title="4，应用起死回生"></a>4，应用起死回生</h3><p>App出现异常后，手动创建一个循环，在这个循环里面跑Runloop的所有mode。主要就是下面这段代码：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出runLoop所有运行的mode</span></span><br><span class="line"><span class="built_in">NSArray</span> *allModes = <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CFRunLoopCopyAllModes</span>(<span class="built_in">CFRunLoopGetCurrent</span>()));</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *mode <span class="keyword">in</span> allModes) &#123;</span><br><span class="line">    <span class="comment">//在每个 mode 中轮流运行至少0.001 秒</span></span><br><span class="line">        <span class="built_in">CFRunLoopRunInMode</span>((<span class="built_in">CFStringRef</span>)mode, <span class="number">0.001</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，如果在自己手动创建的循环里面又一次出现crash，那神仙也没办法了。</p>
<p>整理一下，是这样：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YACrashHandlerManager</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> shouldIgnore;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YACrashHandlerManager</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)handleException:(<span class="built_in">NSException</span> *)exception &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *message = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"崩溃原因如下:\n%@\n%@"</span>,</span><br><span class="line">                         [exception reason],</span><br><span class="line">                         [[exception userInfo]</span><br><span class="line">                          objectForKey:kCaughtExceptionStackInfoKey]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,message);</span><br><span class="line">    <span class="comment">// 弹出弹窗, 设置shouldIgnore的值</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *allModes = <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CFRunLoopCopyAllModes</span>(<span class="built_in">CFRunLoopGetCurrent</span>()));</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">self</span>.shouldIgnore) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *mode <span class="keyword">in</span> allModes) &#123;</span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>((<span class="built_in">CFStringRef</span>)mode, <span class="number">0.001</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    configCatchExceptionHandler(<span class="literal">YES</span>);</span><br><span class="line">    <span class="keyword">if</span> ([[exception name] isEqual:kSignalExceptionName]) &#123;</span><br><span class="line">        kill(getpid(), [[[exception userInfo] objectForKey:kSignalKey] intValue]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [exception raise];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> *getBacktrace() &#123;</span><br><span class="line">    <span class="keyword">void</span> *callstack[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> frames = backtrace(callstack, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">char</span> **strs = backtrace_symbols(callstack, frames);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *backtrace = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:frames];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frames; i++) &#123;</span><br><span class="line">        [backtrace addObject:[<span class="built_in">NSString</span> stringWithUTF8String:strs[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    free(strs);</span><br><span class="line">    <span class="keyword">return</span> backtrace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> configCatchExceptionHandler(<span class="built_in">BOOL</span> isNil) &#123;</span><br><span class="line">    <span class="keyword">void</span> (*handler)(<span class="keyword">int</span>) = SIG_DFL;</span><br><span class="line">    <span class="built_in">NSUncaughtExceptionHandler</span> *exc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isNil) &#123;</span><br><span class="line">        handler = signalHandler;</span><br><span class="line">        exc = &amp;handleException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(exc);</span><br><span class="line">    signal(SIGABRT, handler);</span><br><span class="line">    signal(SIGILL, handler);</span><br><span class="line">    signal(SIGSEGV, handler);</span><br><span class="line">    signal(SIGFPE, handler);</span><br><span class="line">    signal(SIGBUS, handler);</span><br><span class="line">    signal(SIGPIPE, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> handleException(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="built_in">NSException</span> *customException = [<span class="built_in">NSException</span> exceptionWithName:[exception name] reason:[exception reason] userInfo:@&#123;kCaughtExceptionStackInfoKey: [exception callStackSymbols]&#125;];</span><br><span class="line">    [[YACrashHandlerManager sharedManager] performSelectorOnMainThread:<span class="keyword">@selector</span>(handleException:) withObject:customException waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> signalHandler(<span class="keyword">int</span> signal) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *stack = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, getBacktrace()];</span><br><span class="line">    <span class="built_in">NSException</span> *customException = [<span class="built_in">NSException</span> exceptionWithName:kSignalExceptionName</span><br><span class="line">                                                           reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedString</span>(<span class="string">@"Signal %d was raised."</span>, <span class="literal">nil</span>), signal]</span><br><span class="line">                                                         userInfo:@&#123;kSignalKey:[<span class="built_in">NSNumber</span> numberWithInt:signal], kCaughtExceptionStackInfoKey: stack&#125;];</span><br><span class="line">    [[YACrashHandlerManager sharedManager] performSelectorOnMainThread:<span class="keyword">@selector</span>(handleException:) withObject:customException waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="自实现"><a href="#自实现" class="headerlink" title="自实现"></a>自实现</h2><p>这篇文章有空写一点，结果发出来都12月份了。太忙了，hold不住。。。立个flag，2020年Q1自实现一个Runloop。</p>
<blockquote>
<p>网上搜了几篇很棒的文章：<br><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="noopener">iOS 并发编程之 Operation Queues</a><br><a href="http://dnduuhn.com/2018/12/02/iOS-多线程编程知识整理/" target="_blank" rel="noopener">iOS 多线程编程知识整理</a><br><a href="http://dnduuhn.com/2018/12/11/iOS-多线编程之线程安全/" target="_blank" rel="noopener">iOS 多线编程之线程安全</a><br><a href="http://zenonhuang.me/2018/03/08/technology/2018-03-01-LockForiOS/" target="_blank" rel="noopener">谈 iOS 的锁</a><br><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">@synchronized，这儿比你想知道的还要多</a><br><a href="http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/" target="_blank" rel="noopener">Threading Programming Guide(2)</a><br><a href="http://zenonhuang.me/2018/04/17/technology/2018-04-17-Runloop/" target="_blank" rel="noopener">RunLoop 源码阅读</a><br><a href="http://zhengtingi.cc/2017/02/20/RunLoop1/" target="_blank" rel="noopener">RunLoop深入学习笔记</a></p>
</blockquote>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/iOS开发/">iOS开发</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2019/12/06/App作品：Splash/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">App作品：Splash</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2019/09/11/iOS中的Crash防护/">
        <span class="next-text nav-default">iOS中的Crash防护</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2014 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
