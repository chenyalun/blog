<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="iOS中的Crash防护">




  <meta name="keywords" content="iOS,">




  <link rel="alternate" href="/atom.xml" title="Ya">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x">



<link rel="canonical" href="http://blog.chenyalun.com/2019/09/11/iOS中的Crash防护/">


<meta name="description" content="避免App crash。">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS中的Crash防护">
<meta property="og:url" content="http://blog.chenyalun.com/2019/09/11/iOS中的Crash防护/index.html">
<meta property="og:site_name" content="Ya">
<meta property="og:description" content="避免App crash。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image.chenyalun.com/2019/09/11/001.png">
<meta property="og:updated_time" content="2019-10-27T08:13:47.446Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS中的Crash防护">
<meta name="twitter:description" content="避免App crash。">
<meta name="twitter:image" content="https://image.chenyalun.com/2019/09/11/001.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  



    <title> iOS中的Crash防护 · Ya </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ya</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/阅读/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ya</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              时间线
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/阅读/">
            
            
              阅读
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          iOS中的Crash防护
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年9月11日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、常见Crash类型"><span class="toc-text">一、常见Crash类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-unrecognized-selector-crash"><span class="toc-text">1. unrecognized selector crash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-容器-crash"><span class="toc-text">2. 容器 crash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-KVO-crash"><span class="toc-text">3. KVO crash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#预防"><span class="toc-text">预防</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#防护"><span class="toc-text">防护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-NSTimer-crash"><span class="toc-text">4. NSTimer crash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法一"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法二"><span class="toc-text">方法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法三"><span class="toc-text">方法三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Bad-Access-crash"><span class="toc-text">5. Bad Access crash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#block为nil"><span class="toc-text">block为nil</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针传递未判空"><span class="toc-text">指针传递未判空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assgin修饰对象"><span class="toc-text">assgin修饰对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self提前释放"><span class="toc-text">self提前释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速遍历下的-autoreleasing"><span class="toc-text">快速遍历下的__autoreleasing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IMP调用"><span class="toc-text">IMP调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-其他类型的crash"><span class="toc-text">6. 其他类型的crash</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、小结"><span class="toc-text">二、小结</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p align="center"> 避免App crash。 </p>

<a id="more"></a>
<p>App的质量评测主要有两个关注点，一个是Crash，另一个是卡顿。手百已经建立了卡顿监测平台，主要是通过监测主线程的Runloop的状态切换耗时实现。对于Crash只做了收集，及时报告给个业务方，但并没有“防护”平台（貌似由于种种原因目前还没有完成）。假如需要做一个简单的crash防护措施，该怎么着手呢？</p>
<p><a href="https://neyoufan.github.io/2017/01/13/ios/BayMax_HTSafetyGuard/" target="_blank" rel="noopener">《大白健康系统–iOS APP运行时Crash自动修复系统》</a>这篇文章总结地很不错了，网上很多组件都是根据这篇文章开发的（手百内部也有参考）。本文在前辈们的基础上，简单叙述下自己的想法。</p>
<h1 id="一、常见Crash类型"><a href="#一、常见Crash类型" class="headerlink" title="一、常见Crash类型"></a>一、常见Crash类型</h1><h2 id="1-unrecognized-selector-crash"><a href="#1-unrecognized-selector-crash" class="headerlink" title="1. unrecognized selector crash"></a>1. unrecognized selector crash</h2><p><code>unrecognized selector sent to instance</code>类型的crash是比较常见的，原因是没有找到方法的实现。H5与NA交互时，别人难免会调错；项目在合并分支、重构等大改动的时候也难免不小心把方法的实现删掉了（这种情况俺遇到好多次了==）。这类crash的防护是最有意义的，一来解决了体验问题，二来只是添加一个单纯的实现，一般不会影响其他功能和数据。</p>
<p>根据消息机制，resolveInstanceMethod需要在类中提前加上，略显冗余；forwardInvocation需要创建NSInvocation，开销较大且常被外界重写以转发消息。<a href="https://neyoufan.github.io/2017/01/13/ios/BayMax_HTSafetyGuard/" target="_blank" rel="noopener">最适合的还是forwardingTargetForSelector</a>。</p>
<p>需要考虑的有：</p>
<ol>
<li>防护实例方法和类方法。</li>
<li>防护的方法要可供选择，如白名单，或者前缀等（避免影响其他业务方）。</li>
<li>获取crash的函数调用栈以供追踪。</li>
<li>不能影响已重写了<code>forwardInvocation:</code>方法（含实例方法和类方法）的类。</li>
</ol>
<p>第一条，方法交换时传入类对象或者元类对象即可；<br>第二条，可以获取当前的classString进行定制化判断；<br>第三条，<code>[NSThread callStackSymbols]</code>可以获取调用栈；<br>第四条，可以参考KVO中判断<code>willChangeValueForKey:</code>是否已被重写的逻辑—<a href="https://blog.chenyalun.com/2019/05/31/Key-Value%20Observing源码初探/">比较IMP是否一致</a>。也即比较NSObject和当前类中的<code>forwardInvocation:</code>方法的IMP是否一致；当然，需要对<code>-forwardInvocation:</code>和<code>+forwardInvocation:</code>区分；</p>
<p>这样，首先添加一个继承自NSObject的target，重写resolveInstanceMethod和resolveClassMethod以添加空白的方法实现：<code>forwardingTargetDynamicMethod</code>。这里也是获取调用栈的好时机：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define kYACurrentCallStackSymbols [NSString stringWithFormat:@<span class="meta-string">"%@"</span>,[NSThread callStackSymbols]]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAForwardingTarget</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAForwardingTarget</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> forwardingTargetDynamicMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;&#125;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    class_addMethod(<span class="keyword">self</span>.class, sel, (IMP)forwardingTargetDynamicMethod, <span class="string">"v@:"</span>);</span><br><span class="line">    [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Unrecognized instance Method: %@\n调用栈是:%@"</span>, <span class="built_in">NSStringFromSelector</span>(sel), kYACurrentCallStackSymbols);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    class_addMethod(object_getClass(<span class="keyword">self</span>), sel, (IMP)forwardingTargetDynamicMethod, <span class="string">"v@:"</span>);</span><br><span class="line">    [class_getSuperclass(<span class="keyword">self</span>) resolveClassMethod:sel];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Unrecognized class Method: %@\n调用栈是:%@"</span>, <span class="built_in">NSStringFromSelector</span>(sel), kYACurrentCallStackSymbols);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>利用方法交换，在NSObject的分类中hook <code>forwardingTargetForSelector:</code>方法处理转发逻辑：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">YAResolveUnrecognizedSelector</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">YAResolveUnrecognizedSelector</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        ya_methodSwizzle(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(forwardingTargetForSelector:), <span class="keyword">@selector</span>(swizzleForwardingTargetForSelector:));</span><br><span class="line">        ya_methodSwizzle(object_getClass(<span class="keyword">self</span>), <span class="keyword">@selector</span>(forwardingTargetForSelector:), <span class="keyword">@selector</span>(swizzleForwardingTargetForSelector:));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define swizzleForwardingTargetForSelector(arg) \</span></span><br><span class="line">arg (<span class="keyword">id</span>)swizzleForwardingTargetForSelector:(SEL)aSelector &#123; \</span><br><span class="line">    <span class="keyword">id</span> result = [<span class="keyword">self</span> swizzleForwardingTargetForSelector:aSelector]; \</span><br><span class="line">    <span class="keyword">if</span> (result) <span class="keyword">return</span> result; \</span><br><span class="line">    <span class="built_in">NSString</span> *classString = <span class="built_in">NSStringFromClass</span>(object_getClass(<span class="keyword">self</span>)); \</span><br><span class="line">    <span class="built_in">BOOL</span> isClsMethod = [@<span class="meta">#arg isEqualToString:@<span class="meta-string">"+"</span>]; /* 区分类方法和实例方法 */\</span></span><br><span class="line">    Class currCls = isClsMethod ? object_getClass(<span class="keyword">self</span>) : <span class="keyword">self</span>.class;\</span><br><span class="line">    Class oriCls = isClsMethod ? object_getClass(<span class="built_in">NSObject</span>.class) : <span class="built_in">NSObject</span>.class;\</span><br><span class="line">    IMP currentImp = class_getMethodImplementation_stret(currCls, <span class="keyword">@selector</span>(forwardInvocation:));\</span><br><span class="line">    IMP originImp = class_getMethodImplementation_stret(oriCls, <span class="keyword">@selector</span>(forwardInvocation:));\</span><br><span class="line">    <span class="comment">/* 也可以添加白名单. */</span> \</span><br><span class="line">    <span class="keyword">if</span> ([classString hasPrefix:<span class="string">@"YA"</span>] &amp;&amp; currentImp == originImp) &#123; \</span><br><span class="line">        <span class="comment">/* 避免crash. */</span>\</span><br><span class="line">        <span class="keyword">return</span> isClsMethod ? YAForwardingTarget.class : [YAForwardingTarget new]; \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">/* 抛出异常. */</span> \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; \</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class method and instance method.</span></span><br><span class="line">swizzleForwardingTargetForSelector(+)</span><br><span class="line">swizzleForwardingTargetForSelector(-)</span><br><span class="line"><span class="meta">#undef swizzleForwardingTargetForSelector</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>在获取到classString时，可以根据下发的白名单判断是否需要防护，当然也可以直接判断前缀，只防护自己业务的方法。</p>
<h2 id="2-容器-crash"><a href="#2-容器-crash" class="headerlink" title="2. 容器 crash"></a>2. 容器 crash</h2><p>再一个比较常见的就是容器crash，比如向NSMutableArray中添加空元素抛出异常。这种crash看似很低级，但却防不胜防。当向一个数组中添加元素时，需要由开发者考虑这个元素有没有可能为空，如果有，做空值判断；如果没有，直接添加即可。但是这种“考虑”往往不是百分百可靠的。最保险的办法是对所有被添加的元素都做空值判断，可是项目中的容器何其多，每次都要if判断，是否有性能方面的影响呢？这就是另一种权衡了。</p>
<p>现在不考虑那么多，假定需要对NSMutableArray的addObject做防护，最简单的是添加一个safe方法：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@implementation</span> NSMutableArray (YAResolveNilObject)</span><br><span class="line">- (void)<span class="attribute">ya_addObject</span>:(id)anObject &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (anObject) &#123;</span><br><span class="line">        <span class="selector-attr">[self addObject:anObject]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>之后使用时只需要使用<code>ya_addObject:</code>就行了。当然最优雅的还是进行hook，让外界继续使用原生方法：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@implementation</span> NSMutableArray (YAResolveNilObject)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    <span class="selector-tag">static</span> <span class="selector-tag">dispatch_once_t</span> <span class="selector-tag">onceToken</span>;</span><br><span class="line">    <span class="selector-tag">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="selector-tag">ya_methodSwizzle</span>(NSClassFromString(@<span class="string">"__NSArrayM"</span>), <span class="variable">@selector</span>(<span class="attribute">addObject</span>:), <span class="variable">@selector</span>(<span class="attribute">ya_addObject</span>:));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">ya_addObject</span><span class="selector-pseudo">:(id)anObject</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (anObject) &#123;</span><br><span class="line">        <span class="selector-attr">[self ya_addObject:anObject]</span>;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        <span class="selector-tag">NSLog</span>(@<span class="string">"防护了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是Array系列是类簇，直接hook NSMutableArray是无法成功的，需要hook对外隐藏的实际起作用的类：<code>__NSArrayM</code>。还有就是如果要考虑线程安全的话，自己再通过加锁来保证（这种case较少，建议单独写一个线程安全的addObject，一股脑全都加锁实在没有必要）。不然 <code>if (anObject)</code>判断时发现为<code>YES</code>，而到<code>addObject:</code>时，anObject又为空了，十分尴尬。</p>
<p>除了addObject时的判空，还有objectAtIndex时的range判断，也需要处理。</p>
<p>NSMutableArray是这样，那NSMutableSet、NSMutableDictionary、NSCache等类也好说了。</p>
<h2 id="3-KVO-crash"><a href="#3-KVO-crash" class="headerlink" title="3. KVO crash"></a>3. KVO crash</h2><p>KVO引起crash有两种场景：<br>1，observer已经销毁，但是未及时移除监听；<br>2，addObserver与removeObserver不匹配（重复添加或移除、没有添加却移除等）；</p>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><p>从“预防”层面讲，可以使用KVO的第三方框架：<a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">KVOController</a>。<br>1，使用单例接管了系统的observeValueForKeyPath方法，通过它再来分发调用。如果observer已经销毁，则不再回调（block），解决了第一个问题；<br>2，只有addObserver接口，其内部依赖容器避免外界重复addObserver，没有暴露removeObserver接口，解决了第二个问题；</p>
<p>而且KVOController极其优雅，只调用一个方法就可以完成一个对象的键值观测。更多介绍可以查看draveness大神的文章：<a href="https://draveness.me/kvocontroller" target="_blank" rel="noopener">《如何优雅地使用 KVO》</a>，当然也可以简单参考下俺写的水文<a href="https://blog.chenyalun.com/2019/01/12/「KVOController」的封装/">《「KVOController」的封装》</a>。</p>
<h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><p>好了，预防层面有办法解决了，那防护层面呢？“observer已经销毁，但是未及时移除监听”，针对这个问题很自然地想到在observer的dealloc方法中做移除监听操作。这种做法的思路是：<br>1， hook addObserver方法，object为key，keyPath数组作为value，与observer建立关系，大致是这种结构：<br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">observer1:</span> &#123;</span><br><span class="line"><span class="symbol">    object1:</span> [<span class="string">"keyPath1"</span>, <span class="string">"keyPath2"</span>], </span><br><span class="line"><span class="symbol">    object2:</span> [<span class="string">"keyPath3"</span>, <span class="string">"keyPath4"</span>],</span><br><span class="line">    <span class="comment">///....</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="symbol">observer2:</span> &#123;</span><br><span class="line"><span class="symbol">    object3:</span> [<span class="string">"keyPath5"</span>, <span class="string">"keyPath6"</span>], </span><br><span class="line"><span class="symbol">    object4:</span> [<span class="string">"keyPath7"</span>, <span class="string">"keyPath8"</span>],</span><br><span class="line">    <span class="comment">///....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2， hook observer的dealloc方法，在这里面逐个移除object的keyPath监听：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// observer1</span></span><br><span class="line">[object1 <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>keyPath1];</span><br><span class="line">[object1 <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>keyPath2];</span><br><span class="line">[object2 <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>keyPath3];</span><br><span class="line">[object2 <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>keyPath4];</span><br><span class="line"></span><br><span class="line"><span class="comment">// observer2</span></span><br><span class="line"><span class="comment">/// ...</span></span><br></pre></td></tr></table></figure></p>
<p>具体代码实现层面，NSMapTable可以支持直接使用对象（object）作为key；keyPath的重复过滤可以使用NSMutableSet；可以使用一个标志位判断是否重复添加或者移除；</p>
<p>hook后的addObserver方法：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">ya_addObserver:</span>(NSObject *)observer <span class="string">forKeyPath:</span>(NSString *)keyPath <span class="string">options:</span>(NSKeyValueObservingOptions)options <span class="string">context:</span>(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    BOOL shouldAddObserver = YES;</span><br><span class="line">    NSString *observerKey = [NSString <span class="string">stringWithFormat:</span>@<span class="string">"%p"</span>, observer];</span><br><span class="line">    <span class="keyword">if</span> (!mainMap) &#123;</span><br><span class="line">        mainMap = [NSMutableDictionary dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMapTable *subMap = [mainMap <span class="string">objectForKey:</span>observerKey];</span><br><span class="line">    <span class="keyword">if</span> (!subMap) &#123;</span><br><span class="line">        subMap = [NSMapTable strongToStrongObjectsMapTable];</span><br><span class="line">        NSMutableSet *set = [NSMutableSet <span class="string">setWithObject:</span>keyPath];</span><br><span class="line">        [subMap <span class="string">setObject:</span>set <span class="string">forKey:</span>self];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NSMutableSet *set = [subMap <span class="string">objectForKey:</span>self];</span><br><span class="line">        <span class="keyword">if</span> ([set <span class="string">containsObject:</span>keyPath]) &#123;</span><br><span class="line">            <span class="comment">// 重复addObserver</span></span><br><span class="line">            shouldAddObserver = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        [set <span class="string">addObject:</span>keyPath];</span><br><span class="line">    &#125;</span><br><span class="line">    [mainMap <span class="string">setObject:</span>subMap <span class="string">forKey:</span>observerKey];</span><br><span class="line">    <span class="keyword">if</span> (shouldAddObserver) &#123;</span><br><span class="line">        [self <span class="string">ya_addObserver:</span>observer <span class="string">forKeyPath:</span>keyPath <span class="string">options:</span>options <span class="string">context:</span>context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理，removeObserver原理大致相同，就不再复述了。</p>
<p>hook后的dealloc方法：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ya_dealloc &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selfKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, <span class="keyword">self</span>];</span><br><span class="line">    <span class="built_in">NSMapTable</span> *subMap = [mainMap objectForKey:selfKey];</span><br><span class="line">    <span class="keyword">if</span> (subMap) &#123;</span><br><span class="line">        [[[subMap keyEnumerator] allObjects] enumerateObjectsUsingBlock:^(<span class="keyword">id</span> object, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">          <span class="built_in">NSSet</span> *set = [subMap objectForKey:object];</span><br><span class="line">          [set enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">              [object removeObserver:<span class="keyword">self</span> forKeyPath:key];</span><br><span class="line">          &#125;];</span><br><span class="line">          <span class="comment">// 移除keyPath</span></span><br><span class="line">          [subMap removeObjectForKey:object];</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">// 移除subMap</span></span><br><span class="line">        [mainMap removeObjectForKey:selfKey];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> ya_dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这种方式有个问题：hook dealloc方法风险极大，因为这个方法关乎App中所有对象的释放，代码一旦有瑕疵，后果不堪设想。子线程调用、hook方式正确与否都会产生<a href="https://www.valiantcat.cn/index.php/2017/11/03/53.html" target="_blank" rel="noopener">潜在的风险</a>，应该尽量避免这种风险极大的操作。那还有其他方式能在对象销毁之前做点事吗？有的。关联对象。<br>一个对象在dealloc之前会移除自己的所有关联对象，我们可以自定义一个对象，将其作为NSObject的关联对象，同时在这个自定义对象的dealloc方法中做上面的操作。为了避免循环引用，自定义的对象不能强引用NSObject，但是使用weak的话，在实践中会发现被关联的NSObject已经销毁了，根本获取不到，所以这里使用<code>unsafe_unretained</code>。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 被关联的对象</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAKVOInfoObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 注意使用unsafe_unretained修饰</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>) <span class="keyword">id</span> object;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAKVOInfoObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">id</span> observer = <span class="keyword">self</span>.object;</span><br><span class="line">        <span class="built_in">NSString</span> *observerKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, observer];</span><br><span class="line">        <span class="built_in">NSMapTable</span> *subMap = [mainMap objectForKey:observerKey];</span><br><span class="line">        <span class="keyword">if</span> (subMap) &#123;</span><br><span class="line">          [[[subMap keyEnumerator] allObjects] enumerateObjectsUsingBlock:^(<span class="keyword">id</span> object, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            <span class="built_in">NSSet</span> *set = [subMap objectForKey:object];</span><br><span class="line">            [set enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">                [object removeObserver:observer forKeyPath:key];</span><br><span class="line">            &#125;];</span><br><span class="line">            <span class="comment">// 移除keyPath</span></span><br><span class="line">            [subMap removeObjectForKey:object];</span><br><span class="line">          &#125;];</span><br><span class="line">          <span class="comment">// 移除subMap</span></span><br><span class="line">          [mainMap removeObjectForKey:observerKey];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 分类，用于设置关联对象</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">YAKVOInfoObject</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)ya_setKVOInfoObject:(YAKVOInfoObject *)object &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">"ya_kVOInfoObject"</span>, object, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>这样一来似乎更体面一点了，设置关联对象的时机自然是在成功addObserver的时候，而且每个对象只需要设置一次即可。</p>
<p>需要注意的是，由于需要严格依赖observer的dealloc方法，如果系统的自动释放池出现了延时释放，会导致observer被销毁之后过一段时间关联对象才会释放，这时候使用<code>unsafe_unretained</code>访问的就是非法地址。所以需要在关联对象的dealloc方法中添加上自己的自动释放池。这一点我确实没有想到，请参考<a href="https://www.valiantcat.cn/index.php/2017/11/03/53.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>到这里，removeObserver的时机已经搞定了，至于对这些keyPath和object的保存，可以参考上面的代码使用全局的容器，当然也可以把它们放在关联对象YAKVOInfoObject中存储。还有一种方式，是使用代理，不过我想了一下，要是使用代理，首先要设置observer的delegate为object，然后还要在observer销毁的时候移除delegate（也就是object）的keyPath监听，但是keyPath需要保存，observer销毁的时机同样需要hook，似乎observer与object只是多了一层直接联系，并且把结构搞得更加复杂了。。。</p>
<p>至于未及时移除NSNotificationCenter的监听产生的crash在iOS9之后已经不存在了，而且我在<a href="https://blog.chenyalun.com/2019/01/28/NSNotificationCenter探索/">《NSNotificationCenter探索》</a>这篇文章中还利用弱引用容器简单实现了个demo，即便不移除也不会产生异常，作为练习之用。目前App的最低版本已经是iOS9了，不过还是建议addObserver后能有对应的removeObserver，有头有尾，严谨一些。当然，要是铁了心非要对它加上防护，原理与KVO这个类似，或者说更简单了，毕竟不需要保存keyPath、object之类的。</p>
<h2 id="4-NSTimer-crash"><a href="#4-NSTimer-crash" class="headerlink" title="4. NSTimer crash"></a>4. NSTimer crash</h2><p>NSTimer会强引用着target，target往往也需要强引用着NSTimer，容易产生循环引用，引发内存泄漏进而可能产生crash问题（ps：CADisplayLink同理，推荐使用不依赖Runloop更准时的dispatch_source_t）。</p>
<p>可以举个循环引用的例子：控制器强引用着YASinger对象，YASinger对象强引用着NSTimer。当控制器调用<code>self.singer = nil;</code>的时候，会发现sing方法依然在不停调用。可见，NSTimer内部又强引用着YASinger对象，二者是循环引用，控制器把YASinger对象的引用计数减1并不能使得它及时销毁。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YASinger</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YASinger</span></span></span><br><span class="line">- (<span class="keyword">void</span>)sing &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"YASinger  show"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startTask &#123;</span><br><span class="line">    YASinger *singer = [YASinger new];</span><br><span class="line">    singer.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:singer selector:<span class="keyword">@selector</span>(sing) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="keyword">self</span>.singer = singer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一般解决NSTimer的循环引用问题有三种方法。</strong></p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><strong>使用block作为中间件，可以参考BlocksKit2.2.5的实现：</strong><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">BlocksKit</span>)</span></span><br><span class="line">+ (<span class="keyword">id</span>)bk_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)inTimeInterval block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block repeats:(<span class="built_in">BOOL</span>)inRepeats</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> scheduledTimerWithTimeInterval:inTimeInterval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(bk_executeBlockFromTimer:) userInfo:[block <span class="keyword">copy</span>] repeats:inRepeats];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)bk_timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)inTimeInterval block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block repeats:(<span class="built_in">BOOL</span>)inRepeats</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> timerWithTimeInterval:inTimeInterval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(bk_executeBlockFromTimer:) userInfo:[block <span class="keyword">copy</span>] repeats:inRepeats];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)bk_executeBlockFromTimer:(<span class="built_in">NSTimer</span> *)aTimer &#123;</span><br><span class="line">	<span class="keyword">void</span> (^block)(<span class="built_in">NSTimer</span> *) = [aTimer userInfo];</span><br><span class="line">	<span class="keyword">if</span> (block) block(aTimer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>NSTimer实例对象直接强引用着NSTimer的类对象（单例），通过持有block再间接持有外界的target。这样NSTimer与target的引用问题就转化为NSTimer的block与target的引用问题。而这类问题是我们非常熟悉的，可以通过weakSelf-strongSelf解决：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">- (void)startTask &#123;</span><br><span class="line">    YASinger *singer = [YASinger new]<span class="comment">;</span></span><br><span class="line">    self.singer = singer<span class="comment">;</span></span><br><span class="line">    __weak YASinger *weakSinger = singer<span class="comment">;</span></span><br><span class="line">    singer.timer = [NSTimer <span class="keyword">bk_scheduledTimerWithTimeInterval:1 </span><span class="keyword">block:^(NSTimer </span>*timer) &#123;</span><br><span class="line">        __strong YASinger *singer = weakSinger<span class="comment">;</span></span><br><span class="line">        [singer sing]<span class="comment">;</span></span><br><span class="line">    &#125; repeats:YES]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>使用继承自NSObject的对象作为中间件，弱引用着target：</strong><br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YAWeakTarget </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, weak)   id target;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) SEL selector;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) NSTimer *timer;;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> YAWeakTarget</span><br><span class="line">- (void)<span class="attribute">timerTask</span>:(NSTimer *)timer &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (self.target) &#123;</span><br><span class="line">        <span class="selector-attr">[self.target performSelector:self.selector withObject:timer.userInfo]</span>;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        <span class="selector-attr">[self.timer invalidate]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>由YAWeakTarget保存着target、selector和timer，并负责间接调用target的selector方法。使用的时候，统一调用YAWeakTarget的<code>timerTask:</code>方法：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startTask &#123;</span><br><span class="line">    YASinger *singer = [YASinger <span class="keyword">new</span>];</span><br><span class="line">    self.singer = singer;</span><br><span class="line">    YAWeakTarget *weakTarget = [YAWeakTarget <span class="keyword">new</span>];</span><br><span class="line">    weakTarget.target = singer;</span><br><span class="line">    weakTarget.selector = <span class="meta">@selector</span>(sing);</span><br><span class="line">    weakTarget.timer = [NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">1</span> <span class="string">target:</span>weakTarget <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">timerTask:</span>) <span class="string">userInfo:</span>@&#123;&#125; <span class="string">repeats:</span>YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一图胜千言：<br><img src="https://image.chenyalun.com/2019/09/11/001.png" style="zoom:40%"></p>
<p>打破循环引用的根本原因是NSTimer的invalidate方法得到执行。NSTimer在其invalidate方法调用后，Runloop会自动移除对它的引用，它也会移除对target和userInfo的强引用。</p>
<p>weakTarget一旦发现YASinger为nil，就会调用定时器的invalidate方法。因此，weakTarget强引用着timer也是没关系的（也就是图中的蓝线）。</p>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p><strong>使用继承自NSProxy的对象作消息转发：</strong><br><code>forwardInvocation:</code>和<code>methodSignatureForSelector:</code>两个基本方法必须实现。在这基础上，加上自己需要的。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    _target = target;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target respondsToSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.target respondsToSelector:invocation.selector]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>使用的时候，这么做就行了：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startTask &#123;</span><br><span class="line">    YASinger *singer = [YASinger <span class="keyword">new</span>];</span><br><span class="line">    self.singer = singer;</span><br><span class="line">    singer.timer = [NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">1</span> <span class="string">target:</span>[[YAProxy alloc] <span class="string">initWithTarget:</span>singer] <span class="string">selector:</span><span class="meta">@selector</span>(sing) <span class="string">userInfo:</span>@&#123;&#125; <span class="string">repeats:</span>YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这三种方法就个人而言，我更喜欢方法三。方法一需要时刻牢记weak-strong，影响代码美观；方法二不优雅，还要引入中间件。方法三中的Proxy专门做消息转发，而且复用性强，并不单单针对NSTimer的循环引用问题。</p>
<p>如此，根本方法有了，剩下的就是做相关方法的hook工作了，不再赘述。</p>
<h2 id="5-Bad-Access-crash"><a href="#5-Bad-Access-crash" class="headerlink" title="5. Bad Access crash"></a>5. Bad Access crash</h2><p>这种crash产生的原因是向已经销毁的对象发送消息。类型很常见，但是却又比较难排查。防护层面也是有办法的，原理是hook 需要监测的对象的dealloc方法，不让它释放内存（避免调用dealloc方法），并修改它的isa指针从而把之后的消息转发给固定的对象。</p>
<p>假定需要监测“YA”打头的所有对象：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">YAResolveZombie</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        ya_methodSwizzle(<span class="built_in">NSObject</span>.class, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"dealloc"</span>), <span class="keyword">@selector</span>(ya_dealloc));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ya_dealloc &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *clsName = <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class);</span><br><span class="line">    <span class="keyword">if</span> ([clsName hasPrefix:<span class="string">@"YA"</span>]) &#123;</span><br><span class="line">        <span class="comment">// 修改isa指针</span></span><br><span class="line">        object_setClass(<span class="keyword">self</span>, YAZombieInfoObject.class);</span><br><span class="line">        <span class="comment">// 记录类信息</span></span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">"ya_className"</span>, clsName, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他对象正常调用dealloc</span></span><br><span class="line">        [<span class="keyword">self</span> ya_dealloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>而这个YAZombieInfoObject对象是现成的（我看有文章使用动态生成class，确实没有必要），类似unrecognized selector crash的防护，记录类名、方法名、调用栈等信息即可。由于类对象是单例，所以只需要防护实例对象（实例方法）就行了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YAZombieInfoObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YAZombieInfoObject</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> forwardingTargetDynamicMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *clsName = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="string">"ya_className"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Class name is %@, zombie instance Method is %@, \n调用栈是:%@"</span>,clsName,  <span class="built_in">NSStringFromSelector</span>(_cmd), kYACurrentCallStackSymbols);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    class_addMethod(<span class="keyword">self</span>.class, sel, (IMP)forwardingTargetDynamicMethod, <span class="string">"v@:"</span>);</span><br><span class="line">    [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这种方法有几个点需要考虑：<br>1，被监测对象的范围怎么衡量，是所有自定义的类吗？<br>2，被监测对象延迟释放会占用内存，内存限制多少合适？<br>3，被监测对象最终还是调要dealloc的，什么时机比较合适？<br>4，这种方法hook了dealloc方法，会不会有潜在的危险？</p>
<p>预防为主，下面简单列举几个这种类型的例子吧。</p>
<h3 id="block为nil"><a href="#block为nil" class="headerlink" title="block为nil"></a>block为nil</h3><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">void (^block)() = <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">block()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>一般是新人才犯这种错误。block在执行之前一定要判空，不然会造成程序读取内存地址时出错。</p>
<p>使用条件运算符可以使风格更加<a href="http://southpeak.github.io/2016/09/20/ios-techset-8/" target="_blank" rel="noopener">优雅</a>：<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">!<span class="built_in">block</span> ?: <span class="built_in">block</span>();</span><br></pre></td></tr></table></figure></p>
<h3 id="指针传递未判空"><a href="#指针传递未判空" class="headerlink" title="指针传递未判空"></a>指针传递未判空</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> saveText(<span class="built_in">NSString</span> *text, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="comment">// 保存文本却失败了</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递error</span></span><br><span class="line">    *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"error"</span> code:<span class="number">-1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">saveText(<span class="string">@"test"</span>, <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure>
<p>同样地，指针不做判空也是会出问题。</p>
<h3 id="assgin修饰对象"><a href="#assgin修饰对象" class="headerlink" title="assgin修饰对象"></a>assgin修饰对象</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSString</span> *cuid;</span><br></pre></td></tr></table></figure>
<p>这种错误一般是在复制、粘贴的时候没仔细review造成的，一旦出问题也很严重，而且排查起来极其蛋疼。。。</p>
<h3 id="self提前释放"><a href="#self提前释放" class="headerlink" title="self提前释放"></a>self提前释放</h3><p>为了保证性能，<code>self</code>的修饰是<code>__unsafe_unretained</code>而不是<code>strong</code>（<strong>一般情况下</strong>调用方都不会在方法执行时把这个对象释放所以不增加引用计数）。这就有可能造成方法还没有执行完毕，而自己（self）被释放掉，从而产生坏内存访问。</p>
<p>比如<a href="https://blog.sunnyxx.com/2015/01/17/self-in-arc/" target="_blank" rel="noopener">孙源大神文章中的例子</a></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@class</span> YARequest;</span><br><span class="line"><span class="variable">@protocol</span> YARequestDelegate &lt;NSObject&gt;</span><br><span class="line">- (void)requestFinished;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">YARequest </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, weak) id &lt;YARequestDelegate&gt; delegate;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> YARequest</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    <span class="selector-attr">[self.delegate requestFinished]</span>;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"%@"</span>, self); <span class="comment">// EXC_BAD_ACCESS</span></span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure>
<p>控制器中的方法：<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> YARequest *gRequest;</span><br><span class="line"><span class="comment">// 开始执行</span></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    gRequest = [YARequest <span class="keyword">new</span>];</span><br><span class="line">    gRequest.<span class="keyword">delegate</span> = self;</span><br><span class="line">    [<span class="meta">gRequest start</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line">- (<span class="keyword">void</span>)requestFinished &#123;</span><br><span class="line">    gRequest = nil;</span><br><span class="line">    NSLog(<span class="string">@"请求执行完毕"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很容易就发现EXC_BAD_ACCESS了。原因是在YARequest的代理方法中，控制器把YARequest置为nil了。这就造成继续在start方法中访问<code>self</code>产生了问题。</p>
<p>注意：这里的gRequest对象，直接使用了全局变量而不是属性。如果使用属性的getter取值，对象作为返回值会自动被auto release，引用计数会被干扰，就没办法复现了。</p>
<p>这个case出现的可能性比较低，但是也值得注意的。</p>
<h3 id="快速遍历下的-autoreleasing"><a href="#快速遍历下的-autoreleasing" class="headerlink" title="快速遍历下的__autoreleasing"></a>快速遍历下的<code>__autoreleasing</code></h3><p>指向引用类型指针的指针作为参数传递时，是使用<code>__autoreleasing</code>修饰的。比如NSFileManager中的删除文件方法：<code>removeItemAtURL:(NSURL *)url error:(NSError *__autoreleasing  *)error;</code><br>当这种指针遇见<code>enumerateObjectsUsingBlock</code>时，金风玉露一相逢，就该出问题了。比如这个<a href="http://tutuge.me/2016/04/30/autoreleasing-meet-autoreleasepool/" target="_blank" rel="noopener">例子</a>，看着没毛病，其实是有问题的：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决方法: void enumerateArray(__strong NSError **error) &#123;</span></span><br><span class="line"><span class="keyword">void</span> enumerateArray(<span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>, @<span class="number">5</span>];</span><br><span class="line">    [array enumerateObjectsUsingBlock:^(<span class="built_in">NSNumber</span> *obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">0</span> &amp;&amp; error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"error"</span> code:<span class="number">-1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    enumerateArray(&amp;error);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，编译器也会警告的：Block captures an autoreleasing out-parameter, which may result in use-after-free bugs。</p>
<p><code>__autoreleasing</code>修饰时，会把外界的这个对象放到自动释放池中，可是enumerateObjectsUsingBlock恰恰是会自己创建自动释放池的，这样一来，<code>*error</code>被创建之后在下次迭代之前就已经销毁了。于是外界访问已经释放的<code>*error</code>自然会出错了。解决这个问题也很简单，改为<code>__strong</code>修饰即可。</p>
<p>两个小点：<br>1、enumerateObjectsUsingBlock内部会自己创建自动释放池，<code>for循环</code>、<code>for in循环</code>是没有这个能力的。因为这是属于C语言的语法，自然不存在自动释放池的概念。不过要是自己手动添加<code>@autoreleasepool{}</code>，那就又另说了。<br>2、关于为啥指向引用类型的指针的指针默认是使用<code>__autoreleasing</code>修饰的，这个我觉得和引用类型的返回值需要被添加到自动释放池中是同样的道理：本来自己作用域内retain的对象就应该自己把它release，但是偏偏这个对象要延长它的生命周期以供外界使用，所以就需要被添加到autoreleasepool中延迟release了。</p>
<h3 id="IMP调用"><a href="#IMP调用" class="headerlink" title="IMP调用"></a>IMP调用</h3><p>坏内存：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SEL</span> sel = @selector(showText:);</span><br><span class="line"><span class="type">IMP</span> imp = [<span class="keyword">self</span>.target methodForSelector:sel]; <span class="comment">// self.target为nil</span></span><br><span class="line">id (*<span class="function"><span class="keyword">func</span>)<span class="params">(id, SEL, id)</span></span> = (void *)imp;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">self</span>, sel, @<span class="string">"text"</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>正常：<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">SEL sel = <span class="symbol">@selector</span>(showText:)<span class="comment">;</span></span><br><span class="line">IMP imp = [self.target methodForSelector:sel]<span class="comment">;</span></span><br><span class="line">id (*<span class="function"><span class="keyword">func</span>)<span class="params">(id, SEL, id)</span> = <span class="params">(void *)</span><span class="title">imp</span>;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="function"><span class="keyword">func</span>) <span class="title">func</span><span class="params">(self, sel, @<span class="string">"text"</span>)</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>当直接使用函数指针调用方法时，倘若获取的imp为nil而直接调用也会产生异常。比如当<code>self.target</code>返回nil时，就会造成imp也为nil。这时候做一个判空再好不过了。</p>
<h2 id="6-其他类型的crash"><a href="#6-其他类型的crash" class="headerlink" title="6. 其他类型的crash"></a>6. 其他类型的crash</h2><p>还有几个我见过的crash，一并分享一下，以后慢慢补充：</p>
<p><strong>遍历数组的同时移除数组元素</strong><br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">NSMutableArray *array = [NSMutableArray arrayWithArray:<span class="symbol">@[</span><span class="symbol">@1</span>, <span class="symbol">@2</span>, <span class="symbol">@3</span>, <span class="symbol">@4</span>, <span class="symbol">@5]]</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">for</span> (NSNumber *num <span class="keyword">in</span> array) &#123;</span><br><span class="line">   <span class="keyword">if</span> ([num isEqualToNumber:<span class="symbol">@1]</span>) &#123;</span><br><span class="line">       [array removeObject:num]<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用逆序遍历可以解决：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">for</span> (NSNumber *num in array.reverseObjectEnumerator) &#123;</span><br><span class="line">   <span class="selector-tag">if</span> ([num <span class="attribute">isEqualToNumber</span>:<span class="variable">@1</span>]) &#123;</span><br><span class="line">       <span class="selector-attr">[array removeObject:num]</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为啥使用逆序遍历就能解决问题呢？因为正序遍历时，移除元素会造成没有遍历的元素的索引发生异常，而逆序遍历时，索引改变的是遍历过的元素，而没有遍历到的元素索引却没有改变，自然索引也不会越界了。</p>
<p>还有一点，这个reverseObjectEnumerator目前还是好使的，往后好不好使不好说的：</p>
<blockquote>
<p>In Objective-C, it is not safe to modify a mutable collection while enumerating through it. Some enumerators may currently allow enumeration of a collection that is modified, but this behavior is not guaranteed to be supported in the future.</p>
</blockquote>
<p><strong>非法数值</strong><br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">CGFloat <span class="built_in">width</span> = <span class="number">100.0</span>;</span><br><span class="line">CGFloat <span class="built_in">height</span> = <span class="number">0.0</span>;</span><br><span class="line">CGFloat <span class="built_in">scale</span> = <span class="built_in">width</span> / <span class="built_in">height</span>;</span><br><span class="line">UIView *<span class="built_in">view</span> = [[UIView alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">width</span>, <span class="built_in">height</span> * <span class="built_in">scale</span>)];</span><br></pre></td></tr></table></figure></p>
<p>一个非法的数值在传来传去传到UIView的frame上的时候，就该出问题了：<code>&#39;CALayer bounds contains NaN: [0 0; 100 nan].</code>。判断数值的合法性可以使用isnan()函数和isinf()函数。遇到除法的时候，一定要做个判断。</p>
<h1 id="二、小结"><a href="#二、小结" class="headerlink" title="二、小结"></a>二、小结</h1><p>这篇文章写得很是随意，简单描述了自己的想法却没有给出完整的解决方案。Crash防护在一定程度上是有意义的，能增强用户体验，但是还有几个问题需要考虑的：</p>
<ol>
<li>Crash防护原理大多是hook系统方法，那是否会对App产生性能或者速度方面的影响，尤其是亿万级别的App？比如是做速度优化的核心方法？</li>
<li>发生Crash一定是App出现异常情况了，系统把它杀死也是一种保护机制。倘若执意让App继续运行，会不会造成数据异常、界面异常？</li>
</ol>
<p>Crash防护只能算作一个兜底策略，目前来说，很多问题可以通过热修复解决，更有针对性。当然，最核心最重要的是小伙伴们都有良好的编程习惯，仔细review。</p>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/iOS/">iOS</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/12/06/App作品：Splash/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">App作品：Splash</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019/08/22/Objective-C设计指北/">
        <span class="next-text nav-default">Objective-C设计指北</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ChenYalun" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/icqk" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://stackoverflow.com/users/7026915/allen" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    May Be 
  </span>
  
  <span class="theme-info">
    Better  
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even"> </a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Ya</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  
  <script>
    var cloudTieConfig = {
      url: document.location.href, 
      sourceId: "",
      productKey: "f132359147224247aa1c3ad32d20490b",
      target: "cloud-tie-wrapper"
    };
  </script>
  <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>





    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
